<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A bunch of ways to reuse code in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I found this article by Alexis Beingessner as the most understandable description of the type system in Rust, and what can be done with them. I hope s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A bunch of ways to reuse code in Rust</h1><div class="post__text post__text-html js-mediator-article">  <i>I found this <a href="http://cglab.ca/~abeinges/blah/rust-reuse-and-recycle/">article by</a> <a href="https://github.com/Gankro/">Alexis Beingessner</a> as the most understandable description of the type system in Rust, and what can be done with them.</i>  <i>I hope someone this translation will be useful.</i>  <i>Do not look at the fact that the obvious things are described first - in the end you can drown.</i>  <i>The article is huge and most likely will be disassembled into chapters.</i>  <i>Translated fairly freely.</i>  <i>Author's style saved.</i>  <i>- comment per.</i> <br><br>  (article written about Rust 1.7 stable) <br><br>  There is a lot of stuff in the Rust type system.  As far as I know, practically all the complexity of this <i>all</i> lies in expressing the program in the most generalized form.  Moreover, the people also require more!  I have always had problems with a simple understanding of the most difficult things, because this post is rather a reminder to myself.  But nevertheless, I also like to do something useful to others, so this article also has things that I can hardly forget, but which some may not know. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This article will not provide an exhaustive description of the syntax or general details of the features described.  It tells <i>why it</i> happens anyway, since I always forget these things.  If you found this article in an attempt to learn Rust fully, you should definitely get acquainted with the <a href="https://github.com/ruRust/rust_book_ru">Book</a> to begin with.  At the same time, I <i>will</i> clarify here some arbitrary theoretical aspects of what is happening. <br>  Most likely, this article is full of mistakes, and it should not claim to be the official leadership.  This is just a collection of what I‚Äôve dug up in a week while I was looking for a new job. <br><a name="habracut"></a><br><h3>  Brief description of code reuse principles </h3><br>  (hereinafter the term ‚Äúreuse‚Äù I mean ‚Äúreuse‚Äù - sounds not so clumsy, it is understood faster - comment. per.) <br><br>  The desire to use parts of the code more than once has existed since the earliest times when the very first computers got their first useful result bit.  Definitely, I have no idea how the reuse of the code looked at that wonderful time.  Maybe crib leaves?  Or a stack of punched cards?  I have no idea.  I am interested in how this is done now. <br><br>  The most well-known form of code reuse is definitely a function.  Well, yes, the functions are familiar to everyone.  However, depending on what language you write and what you need to do, the capabilities of functions like receiving code reuse may not be enough.  Perhaps you need to apply something that exists under the modern terms "metaprogramming" (when the code creates itself) or "polymorphism" (when the code can be applied to different types of data). <br><br>  Technically, these principles are completely different, however, they often have to be used together.  Modern languages ‚Äã‚Äãimplement these principles quite widely: macros, patterns, generics, inheritance, function pointers, interfaces, overload, grouping (union), and so on.  However, all this is only a semantic variety of the implementation of the three basic principles - monomorphism, virtualization, enumeration. <br><br><h4>  Monomorphism </h4><br>  Monomorphism is essentially the practice of copy-paste a piece of code, with minor changes in each new copy.  The main benefit of monomorphism is the ability to ‚Äúperfectly customize‚Äù the implementation, without scaring the compiler with complex constructions.  This is also the main disadvantage of the principle - in the worst case, we will get a pretty thick code, because of the many almost identical parts that are physically copied to all the places where they are used.  To the thick binary and increased compile time, the monstrous load on the instruction cache in the processor is added here.  In fact, there is no reuse of code here! <br><br>  The semantic limitation of monomorphism is that it cannot be used (directly) in processing several different types of data at the same time.  For example, I want to build a job queue (job queue) that accepts various tasks, and with its help to perform these tasks in the order received.  Provided that all tasks are identical, everything is solved by a monomorphism quite simply.  Problems appear when tasks are different - it becomes unclear how to implement this <i>only by</i> monomorphism.  Therefore, his name is monomorphism.  Abstraction over code that does just <i>one thing</i> . <br><br>  Common examples of monomorphism: C ++ templates, C macros, Go Generate, C # generics.  Most of them work at compilation, except C # generics, which are mono morphic during code execution.  All that is created at compile time is a template.  Monomorphism is terribly popular as a means of optimization in ordinary (inline) and JIT compilation. <br><br><h4>  Virtualization </h4><br>  The exact opposite of monomorphism, to which each developer comes, having played enough copy-paste: fasten the application variability.  Both data and executable code can be virtualized, after which all that the user of the virtual interface sees is pointing to <i>something</i> . <br><br>  Virtualization allows code to work with types of different size and structure in exactly the same way.  Virtualization of a function allows it to have alternative behavior without the need for copy-paste.  An example with an execution queue, on which a monomorphism breaks teeth, is perfectly solved by virtualization - any task that needs to be performed is a pointer to a function that can be found and launched.  We need data separately for each task - without questions, we add another pointer to the data, they will be loaded together with the function. <br><br>  The main drawback of virtualization is that it <i>usually</i> affects performance, the variability of the code results in frequent heap allocation, jumping on pointers (the cache is resentful) and determining what <i>exactly</i> we are dealing with at the moment. <br>  However, virtualization can be more productive than monomorphing!  Every time when the function jerks statically, the compiler is able to bin it, but it does not always, because, as already mentioned, it overloads and trash the binary.  For the same reasons, forced virtualization of rarely used functions is beneficial.  For example, exception handlers do not want to run all the time, and it is better to virtualize them, thus clearing the instruction cache for the ‚Äúerror-free‚Äù execution branch. <br><br>  Common examples of virtualization include function pointers and empty (void) C pointers, callbacks, inheritance, Java generics, Javascript prototypes.  Note that in many of these examples there is no difference between data virtualization and executable code.  For example, if I have a pointer to an <b>Animal</b> , both the <b>Cat</b> and the <b>Dog</b> can stand behind it, and when I ask this <b>Animal</b> to give a <b>voice ()</b> - does he know from somewhere, tell him "Gav" or "Meow"? <br><br>  The usual way to implement virtualization for each object of each type is the inheritance hierarchy for the hidden storage of pointers to different implementation pieces that may be needed during the work of the program, called ‚Äúvtable‚Äù.  Usually, a stack of function pointers is stored in a vtable (including the <b>voice ()</b> from the example above), but the size, alignment in memory, and the specific type of object can also be stored. <br><br><h4>  Transfers </h4><br>  Enums is a trade-off between virtualization and monomorphism.  At runtime, monomorphic code can be <i>only one, without options</i> , virtualized can be <i>anything</i> .  The code from the listing can be <i>any of a limited list of options</i> .  Usually the use of enums is to work with some kind of integer "tag" that defines the option from the list that needs to be used. <br><br>  For example, our execution queue, implemented by listing, can define three types of possible tasks, ‚ÄúCreate‚Äù, ‚ÄúModify‚Äù, ‚ÄúDelete‚Äù.  To use, for example, "Creation", you only need to send the queue data for the Creation, marked with a tag corresponding to the "Create" function.  The queue sees the tag, understands from it what is wanted of it and what lies in the data, and runs the corresponding code. <br><br>  As in virtualization, enumeration can understand different data types using the same code, which is no longer necessary to copy.  As in monomorphism, there is no need for variation ‚Äî only the tag changes.  In addition, it is much easier to optimize transfers. <br><br>  It should, however, be noted that if the variability is not used at all, the enumerated type will seriously grow, since each type object will have to store information for the largest type that is present in the enumeration.  In order to ‚ÄúDelete‚Äù, only the name is enough, but ‚ÄúCreate‚Äù asks for the name, type, author, contents, and so on, and even if it so happens that the queue is mainly used for ‚Äúdeletion‚Äù, it will be memory ask for both permanent creation. <br><br>  Well, of course, you need to know in advance the whole range of possibilities, this is the main limitation of transfers.  Both monomorphism and virtualization can be expanded if necessary at any time, which cannot be said about the enumeration - the pattern can be imposed on a new type, the class can be inherited, and the enumeration is already burned in the code tightly.  It is better not to pick it up with attempts to deceive and expand it - you are more likely to break the code of those who already use it! <br><br>  Therefore, this strategy is somewhat unintelligible.  Many languages ‚Äã‚Äãhave it in the form of <b>enum</b> , however its use is seriously limited due to the inability to associate data separately for each option in the enumeration.  C allows you to define an option as a group of two types, but deciding which of these types is data and what is the code imposes on the enumeration user.  In many functional languages, there are groups with tags (tagged unions), which are a union of enumerations and a group in C, allowing you to glue arbitrary data to different enumeration options. <br><br><h3>  What about Rust? </h3><br>  Yes, we have listed the capabilities of other languages, but what can we do with ours?  And in our everything keeps on three pillars: <br><ul><li>  Macros (simple monomorphism) </li><li>  Enumerations (full, with data!) </li><li>  Treyty (there will be fun) </li></ul><br><h4>  Macros </h4><br>  It's simple.  Net reuse code.  In Rust, they work on top of the main syntax tree (AST, abstract syntax tree) - you feed a macro with a syntax tree, the result is another tree.  There is no information about types like ‚Äúhm, this line is similar to someone's name‚Äù in macros ( <a href="https://danielkeep.github.io/tlborm/book/mbe-min-captures-and-expansion-redux.html">in fact, there</a> is <a href="https://danielkeep.github.io/tlborm/book/mbe-min-captures-and-expansion-redux.html">not much</a> - approx. Lane). <br><br>  Usually, macros are used for two reasons: to extend the language itself or to make a copy of the existing code.  The first one is <a href="">openly used in the standard Rust library</a> ( <b>println!,</b> <b>Thread_local!,</b> <b>Vec!,</b> <b>Try!,</b> And so on): <br><br><pre><code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///   `Vec`,  . /// /// `vec!`   `Vec`s    . ///     : /// /// -  `Vec`    : /// /// ``` /// let v = vec![1, 2, 3]; /// assert_eq!(v[0], 1); /// assert_eq!(v[1], 2); /// assert_eq!(v[2], 3); /// ``` /// /// -  `Vec`      : /// /// ``` /// let v = vec![1; 3]; /// assert_eq!(v, [1, 1, 1]); /// ``` /// ///   -          , ///    `Clone`,      ,    . /// ///   `clone()`   ,    ///     `Clone`. , /// `vec![Rc::new(1); 5]`         integer  , ///     . #[cfg(not(test))] #[macro_export] #[stable(feature = "rust1", since = "1.0.0")] macro_rules! vec { ($elem:expr; $n:expr) =&gt; ( $crate::vec::from_elem($elem, $n) ); ($($x:expr),*) =&gt; ( &lt;[_]&gt;::into_vec($crate::boxed::Box::new([$($x),*])) ); ($($x:expr,)*) =&gt; (vec![$($x),*]) }</span></span></code> </pre> <br>  and the latter is <a href="">used internally</a> to implement multiple duplicate interfaces: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//        //  T -&gt; T      . //          //      macro_rules! impl_from { ($Small: ty, $Large: ty) =&gt; { impl From&lt;$Small&gt; for $Large { fn from(small: $Small) -&gt; $Large { small as $Large } } } } //  -&gt;  impl_from! { u8, u16 } impl_from! { u8, u32 } impl_from! { u8, u64 } //         ...</span></span></code> </pre><br>  As I see it, macros are the worst way to reuse code.  They should help (variable names are not used internally and do not flow away from the macro), but many are too addicted to them (using <b>unsafe</b> in macros gives strange side effects (wondering which ones?).).  At the heart of the macro processor is a regular expression (if you close your eyes to the fact that <b>expr</b> and <b>tt</b> parse is not trivial at all), and in general, no one likes to read regulars! <br><br>  More importantly, IMHO, the macros here are essentially metaprogramming with dynamic typing.  The compiler does not check that the body of the macro corresponds to its signature, it generates code according to the macro, receives something at the output, and only then does the check, which leads to the typical problem of dynamic programming - late binding of errors.  So we can get an analog of the imperishable <b>"undefined is not a function"</b> for Rust: <br><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">macro_rules!</span></span> make_struct { (name: ident) =&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span></span> { field: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, } } } make_struct! { Foo }</code> </pre><br><pre> <code class="bash hljs">&lt;anon&gt;:10:16: 10:19 error: no rules expected the token `Foo` &lt;anon&gt;:10 make_struct! { Foo } ^~~ playpen: application terminated with error code 101</code> </pre><br>  What is the mistake here?  Of course, I forgot about <b>$</b> , because the macro understands the <b>name</b> not as a variable, but as a literal and always gives <br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">name</span></span></span></span> { field: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> }</code> </pre><br>  (To be honest, the reason to treat macros as cool is cool - approx. lane.) <br>  Further, if a normal error comes out in the macro-generated code, there will be indigestible porridge in the logs: <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::fs::File; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-built_in"><span class="hljs-built_in">try!</span></span>(File::open(<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>)); }</code> </pre><br><pre> <code class="bash hljs">&lt;std macros&gt;:5:8: 6:42 error: mismatched types: expected `()`, found `core::result::Result&lt;_, _&gt;` (expected (), found enum `core::result::Result`) [E0308] &lt;std macros&gt;:5 <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> $ crate:: result:: Result:: Err ( &lt;std macros&gt;:6 $ crate:: convert:: From:: from ( err ) ) } } ) &lt;anon&gt;:4:13: 4:38 note: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this expansion of try! (defined <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;std macros&gt;) &lt;std macros&gt;:5:8: 6:42 <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>: see the detailed explanation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> E0308</code> </pre><br>  Well ... but in our pros, like other dynamically typed languages, there is much more flexibility in expressions.  In short, macros are beautiful in those areas where their use is justified, they are simply ... fragile or something. <br><br><h4>  Worth mentioning: syntax extension and code generation </h4><br>  Of course, macros have limits.  They do not execute arbitrary code at compile time.  This is good for safety and frequent assembly, but sometimes it interferes.  In Rust, this can be fixed in two ways: syntax extensions (known as <b>procedural macros</b> ) and code generation (build.rs) (in the unstable branch of the language there are still <a href="https://rurust.github.io/rust_book_ru/src/compiler-plugins.html">plugins for the compiler</a> - note. Lane).  They all give you the green light to do anything to generate anything. <br><br>  Syntax extensions look like macros or annotations, but they have the ability to ask the compiler to perform arbitrary actions to (ideally) change the syntax tree.  The <b>build.rs</b> files <b>are</b> understood by the Cargo batch manager as something that needs to be built and run each time the package is built.  Obviously, they are allowed to fumble in the project as they please.  It is expected that it is better to use it for code generation inaccessible to macros. <br><br>  I could also add a couple of examples, but not particularly in the topic of these possibilities, and I am completely indifferent to them.  Well, code generation, okay.  And in general, I have not been writing this article for the first day and have <b>thoroughly podzadolbalsya</b> (author's caps removed - approx. Lane.). <br><br><h4>  Transfers </h4><br>  Exactly described groupings with tags. <br>  Most often found in the person of <b>Option</b> and <b>Result</b> , expressing a successful / unsuccessful result of something.  That is, it is literally a listing with the options "Success" and "Breakage". <br><br>  You can write your enumerations.  Here, for example, you need a network code that works with <b>ipv4</b> and <b>ipv6</b> .  You definitely do not need the possible support of a hypothetical <b>ipv8</b> , and even if it is necessary, the dog still knows what to do with it in the code.  We write an enumeration for what exactly is: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IpAddress</span></span></span></span> { V4(IPv4Address), V6(Ipv6Address), } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span></span>(addr: IpAddress) { <span class="hljs-comment"><span class="hljs-comment">// ,  ,    match addr { V4(ip) =&gt; connect_v4(ip), V6(ip) =&gt; connect_v6(ip), } }</span></span></code> </pre><br>  Everything.  Then you can work with the general type <b>IpAddress</b> , and if anyone needs to know the exact type inside, it can be obtained using the <b>match</b> method in the manner described above. <br><br><h4>  Treit </h4><br>  Up to this point, everything was simple, now it will be more complicated and interesting. <br>  In short, the traits in Rust are intended to describe <i>everything else</i> .  Monomorphizing, virtualization, reflection, operator overloading, type conversion, copying semantics, thread safety, higher-order functions, iterators for loops ‚Äî this whole colorful panopticon works through treits.  Further, all new user language features are most likely to be realized through traits. <br><br>  In general, traits are interfaces.  No seriously. <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyType</span></span></span></span> { data: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, } <span class="hljs-comment"><span class="hljs-comment">// ,   trait MyTrait { fn foo(&amp;self) -&gt; u32; } //     impl MyTrait for MyType { fn foo(&amp;self) -&gt; u32 { self.data } } fn main() { let mine = MyType { data: 0 }; println!("{}", mine.foo()); }</span></span></code> </pre><br>  Very often, communication with traits is no different from communication with interfaces in Java or C #, but sometimes you have to cross the line.  Traits are conceived architecturally more flexible.  In C # and Java, only the owner of <b>MyType</b> can implement <b>MyTrait</b> for <b>MyType</b> .  In Rust, <i>this is also allowed for the owner of</i> <b>MyTrait</b> .  This allows authors of libraries with treits to write their implementations also for, say, types from the standard library. <br>  Of course, letting such a feature take its course is quite fraught with it - you never know who will come to realize where.  Therefore, this happiness is limited by the visibility of the implementations only for the code that has the corresponding trait in the scope.  From here, by the way, all problems with work with input-output, if not to import <b>Read</b> and <b>Write</b> explicitly. <br><br><h4>  In topic: consistency </h4><br>  Those familiar with Haskell can see in traits a lot in common with type classes.  They also have the right to ask a completely obvious and reasonable question: what, in fact, will happen if we implement the same treit for the same type several times in different places?  The issue of consistency, that is.  In a coherent world, there is only one pair of implementation of the treyt-type.  And in Rust, to achieve consistency, there are more restrictions than there are in Haskell.  The restrictions are as follows: you must be the owner of either a trait or the type that implements it, and you should not have circular dependencies. <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Trait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Type</code> </pre><br>  It is beautiful, simple and understandable, but a bit wrong, since you can draw something like: <br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Trait <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>&lt;MyType&gt;</code> </pre><br>  even if you have no idea where Trait and MyType are physically located.  Correct handling of such manipulations is the main difficulty of consistency.  It is regulated by the so-called.  ‚ÄúRules of uniqueness‚Äù (orphan rules), which require the condition that for the entire web of dependencies only one crate contains the implementation of a trait for a certain combination of types (about combinations will be lower - comment. Per.).  As a result, two different libraries containing conflicting implementations, being imported at the same time, simply do not compile.  It is sometimes annoying to such an extent that Niko Matsakis wants to curse naturally ( <a href="https://github.com/nikomatsakis">Niko Matsakis</a> , one of Rust‚Äôs main committers). <br><br>  It's funny that consistency violations in the standard Rust library (which is glued together from several non-overlapping parts) are very often, so some traits, implementations and types pop up in rather unexpected places.  Even more funny, that not so much help to shuffle the types, as a result of which the <b>fundamental [#]</b> crutch was born, ordering the compiler to close its eyes on the inconsistency. <br><br><h4>  Generics </h4><br>  (I understand that it is correct to call them ‚Äúgeneralized types‚Äù, but this is first, long, secondly, less clear, since everyone still uses the term ‚Äúgenerics‚Äù - comment.) <br><br>  So how do you use traits to reuse code?  Here Rust gives us a choice!  We can monomorphize, we can virtualize.  <i>In the overwhelming majority of cases,</i> monomorphism is a choice in the standard library, as well as in most of the code I have seen.  This is probably because monomorphism is generally more efficient as well as clearly more generalized.  Nevertheless, the monomorphic interface can be virtualized, which I will show later. <br><br>  The monomorphic interface is implemented in Rust by generics: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,   . struct Concrete { data: u32, } //  . `&lt;..&gt;`     . //    `Generic`   ,  // `Concrete`,         `u32`. struct Generic&lt;T&gt; { data: T, } //   impl Concrete { fn new(data: u32) -&gt; Concrete { Concrete { data: data } } fn is_big(&amp;self) -&gt; bool { self.data &gt; 120 } } //     Foo. // ,   ,   , //        //   . // ( ,         - ..) impl Generic&lt;u32&gt; { fn is_big(&amp;self) -&gt; bool { self.data &gt; 120 } } //     T. // "impl"   Generic. // ,      //  ,     &lt;T&gt;. impl&lt;T&gt; Generic&lt;T&gt; { fn new(data: T) -&gt; Generic&lt;T&gt; { Generic { data: data } } fn get(&amp;self) -&gt; &amp;T { &amp;self.data } } //  . trait Clone { fn clone(&amp;self) -&gt; Self; } //  . //     .      //       ,    . //   . trait Equal&lt;T&gt; { fn equal(&amp;self, other: &amp;T) -&gt; bool; } //    impl Clone for Concrete { fn clone(&amp;self) -&gt; Self { Concrete { data: self.data } } } //        impl Equal&lt;Concrete&gt; for Concrete { fn equal(&amp;self, other: &amp;Concrete) -&gt; bool { self.data == other.data } } // ,      ,    ! impl Clone for u32 { fn clone(&amp;self) -&gt; Self { *self } } impl Equal&lt;u32&gt; for u32 { fn equal(&amp;self, other: &amp;u32) -&gt; Self { *self == *other } } //  ,   ! impl Equal&lt;i32&gt; for u32 { fn equal(&amp;self, other: &amp;i32) -&gt; Self { if *other &lt; 0 { false } else { *self == *other as u32 } } } //        impl&lt;T: Equal&lt;u32&gt;&gt; Equal&lt;T&gt; for Concrete { fn equal(&amp;self, other: &amp;T) -&gt; bool { other.equal(&amp;self.data) } } //        // ,  ,  `T`  //  `Clone`!  * * (trait bound). // (  , .    - ..) impl&lt;T: Clone&gt; Clone for Generic&lt;T&gt; { fn clone(&amp;self) -&gt; Self { Generic { data: self.data.clone() } } } //       . //     - U. impl&lt;T: Equal&lt;U&gt;, U&gt; Equal&lt;Generic&lt;U&gt;&gt; for Generic&lt;T&gt; { fn equal(&amp;self, other: &amp;Generic&lt;U&gt;) -&gt; bool { self.equal(&amp;other.data) } } //  ,     . impl Concrete { fn my_equal&lt;T: Equal&lt;u32&gt;&gt;(&amp;self, other: &amp;T) -&gt; bool { other.equal(&amp;self.data) } } impl&lt;T&gt; Generic&lt;T&gt; { // ,   :   `equal`  , //  ,   . // (`x == y`     `y == x`).       , //   `T: Equal&lt;U&gt;`   ?       //   `T`,   `U`   ! //   . fn my_equal&lt;U: Equal&lt;T&gt;&gt;(&amp;self, other: &amp;Generic&lt;U&gt;) -&gt; bool { other.data.equal(&amp;self.data) } }</span></span></code> </pre><br>  <i>Fuh.</i> <br>  As we see, as soon as the need arises to define interfaces and their implementations, our choice is rich for different variations of generalization.  And under the hood of the compiler, as I said, all this is monomorphized.  At least before the first optimization, we get the following intermediate code: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  struct Generic&lt;T&gt; { data: T } impl&lt;T&gt; Generic&lt;T&gt; { fn new(data: T) { Generic { data: data } } } fn main() { let thing1 = Generic::new(0u32); let thing2 = Generic::new(0i32); }</span></span></code> </pre><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  struct Generic_u32 { data: u32 } impl Generic_u32 { fn new(data: u32) { Generic { data: data } } } struct Generic_i32 { data: i32 } impl Generic_i32 { fn new(data: i32) { Generic { data: data } } } fn main() { let thing1 = Generic_u32::new(0u32); let thing2 = Generic_i32::new(0i32); }</span></span></code> </pre><br>  You may be surprised (or not surprised), but some important functions are inlined <i>very much where</i> .  For example, brson found in the Servo code <a href="https://gist.github.com/brson/18a1517e9b747a09c492">more than 1,700 copies of</a> <b>Option :: map</b> .  In general, it is true that the virtualization of all these calls will completely kill runtime performance. <br><br><h4>  Too important: type definition and turbo-fish operator </h4><br>  (I can't translate ‚Äúturbofish‚Äù better. Options are welcome - approx. per.) <br>  Generics in Rust determine the type automatically.  If the type is somewhere specified, everything works like a clock.  And if not specified, fireworks start: <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Vec::new()  ,     //   ,   .   .     //  `Vec`,  -  . let mut x = Vec::new(); //    `u8`  `x`,    `Vec&lt;T&gt;` x.push(0u8); x.push(10); x.push(20); // `collect`   .   ,   // `FromIterator`,    Vec  VecDeque. //    - ,    // `collect` ,    `Vec::new()`,     //     //  -     . let y: Vec&lt;u8&gt; = x.clone().into_iter().collect(); //    ,       //   "-" `::&lt;&gt;`! let y = x.clone().into_iter().collect::&lt;Vec&lt;u8&gt;&gt;();</span></span></code> </pre><br><br><h4>  Trait objects </h4><br>  So how do we get virtualized?  How do we delete information about a particular type in order to become just a faceless ‚Äúsomething‚Äù?  With Rust, this happens with trait objects.  You simply say that a given type instance is an instance of a trait, and the compiler does the rest.  Of course, you also need to abstract from the size of the instance, because we also hide behind a pointer, like &amp;, &amp; mut, Box, Rc, Arc: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Print</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Print <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Print <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i64</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">//    let x = 0i32; let y = 10i64; x.print(); // 0 y.print(); // 10 // Box&lt;Print&gt; - -,     // ,  Print.   Box&lt;Print&gt;    // `Box&lt;T: Print&gt;`,    -,   `Box&lt;Print&gt;`. //    `data`  `Box&lt;Print&gt;`, //  -     ! // ,    i32  i64     , //         . let data: [Box&lt;Print&gt;; 2] = [Box::new(20i32), Box::new(30i64)]; //     . for val in &amp;data { val.print(); // 20, 30 } }</span></span></code> </pre><br>  Please note, the requirement to hide a specific type behind the pointer has more consequences than it might seem at first glance.  Here, for example, our old familiar treit: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clone</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; }</code> </pre><br>  A trait defines a function that returns an instance of its own type <i>by value</i> . <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: &amp;<span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span> = ...; <span class="hljs-comment"><span class="hljs-comment">// -  ,  let y = x.clone(); //   , ...? }</span></span></code> </pre><br>  But how much space should be reserved on the stack for <b>y</b> ?  What is he like? <br>  The answer is that <i>we do not know this at compile time</i> .  This suggests that the <b>Clone</b> trait object is meaningless in fact.  More precisely, a treyt cannot be turned into a treyt-object, if it contains a reference to its own type as a value (and not a pointer ‚Äî a comment per.). <br><br>  Trait objects are implemented in Rust in a rather unexpected way.  Let's remember - usually virtualized tables of functions are used for such purposes.  There are at least two reasons that are annoying in this way. <br>  The first is that everything is stored behind the pointer, regardless of whether it is necessary.  That is, if the type is defined as virtualized, then <i>this pointer should be stored for all type instances</i> . <br><br>  The second is that getting the functions you need from a virtual table is not such a trivial task.  This is all due to the fact that interfaces are in general a special case of multiple inheritance (in C ++, full inheritance of multiple inheritance).  As an example, here's a set for you: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Animal</span></span></span></span> { } <span class="hljs-comment"><span class="hljs-comment">//  trait Feline { } //  trait Pet { } //  // , ,  struct Cat { } // ,  struct Dog { } // ,  struct Tiger { }</span></span></code> </pre><br>  How to organize storage of function pointers in case of mixed types, such as <b>Animal + Pet</b> , or <b>Animal + Feline</b> ?  <b>Animal + Pet</b> consists of Cat and Dog.  We tamper them with the following signs: <br><br><pre> Cat vtable Dog vtable Tiger vtable
 + ----------------- + + ----------------- + + ----------- ------ +
 |  type stuff |  |  type stuff |  |  type stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Animal stuff |  |  Animal stuff |  |  Animal stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Pet stuff |  |  Pet stuff |  |  Feline stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Feline stuff |
 + ----------------- +
</pre><br><br>  And now Cat and Tiger are different.  Ok, swap the Pet and Cat cats at Cat: <br><br><pre> Cat vtable Dog vtable Tiger vtable
 + ----------------- + + ----------------- + + ----------- ------ +
 |  type stuff |  |  type stuff |  |  type stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Animal stuff |  |  Animal stuff |  |  Animal stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Feline stuff |  |  Pet stuff |  |  Feline stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Pet stuff |
 + ----------------- +
</pre><br><br>  Uh, now Cat and Dog are different.  Overlap the markup under the function again, like this. <br><br><pre> Cat vtable Dog vtable Tiger vtable
 + ----------------- + + ----------------- + + ----------- ------ +
 |  type stuff |  |  type stuff |  |  type stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Animal stuff |  |  Animal stuff |  |  Animal stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Feline stuff |  |  |  |  Feline stuff |
 + ----------------- + + ----------------- + + ----------- ------ +
 |  Pet stuff |  |  Pet stuff |
 + ----------------- + + ----------------- +
</pre><br><br>  Good.  Only it does not scale.  It turns out that each interface should have its own unique offset, so that each virtual table of functions could theoretically contain any necessary interface, but this also means that <i>each table should store information about all the interfaces without exception</i> .  Yes, the unused space at the end of the table can be cut off, but this is poor consolation, too much memory is consumed.  In addition, we cannot know the offset of interfaces that are imported from dynamic libraries.  Therefore, in most languages, function tables are defined only during program execution. <br><br>  However, this all has nothing to do with Rust.  Rust does not store virtual tables in types.  Trayte objects in Rust are so-called <i>thick pointers</i> .  <b>&amp; Pet</b> is not one pointer, but two, on the data and on the virtual table.  The virtual table of the trait object, in turn, is not tied to a specific type.  It is unique for each combination of types. <br><br><pre> Cat's Pet vtable Dog's Pet vtable<font></font>
+-----------------+ +-----------------+<font></font>
 | type stuff |  | type stuff |<font></font>
+-----------------+ +-----------------+<font></font>
 | Pet stuff |  | Pet stuff |<font></font>
+-----------------+ +-----------------+<font></font>
</pre><br><br> ,   <b> + </b>  <b> + </b>  .  ,        . <br><br>         . ,     ,    ,    ,    ,  <b></b>      <b></b> . <br><br>      .      ,    ,   .      <i>    </i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is possible due to the fact that we can find out statically the type of each object at some </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specific</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> point in time, and all casts to treit objects as well. </font><font style="vertical-align: inherit;">Replacing monomorphing with virtualization here is fraught with a serious drop in performance. </font><font style="vertical-align: inherit;">(and, therefore, in the language there is a very limited possibility of casting - comment. per.).</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warning: the opportunity to find fault! </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thick pointers can in principle be generalized further to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obese pointers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . As a ‚Äúfat pointer‚Äù, the type </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animal + Feline</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indicates one common virtual table, nevertheless there is no reason not to divide this table into two, separately for each treit, awarding the type two pointers to them, respectively. In theory, this can limit the monomorphism of the table, due to even more thickened pointers. This idea pops up regularly, but no one takes it seriously.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we recall a recent statement - the user can make the monomorphic interface virtualized. </font><font style="vertical-align: inherit;">This is possible thanks to such a thing as ‚Äúimplement a treit for a treit‚Äù (impl Trait for Trait), or rather, a treit object implements its own treyt (IMHO is the coolest feature of the type system - approx. Per.). </font><font style="vertical-align: inherit;">As a result, the following code is valid:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//   ... trait Print { fn print(&amp;self); } impl Print for i32 { fn print(&amp;self) { println!("{}", self); } } impl Print for i64 { fn print(&amp;self) { println!("{}", self); } } // ?Sized ,  T    (&amp;, Box, Rc,   ). // Sized (  ) - ,   . //      Traits  [T]  " ". //  `T: ?Sized`,      //    T  ,    , //   Sized    . fn print_it_twice&lt;T: ?Sized + Print&gt;(to_print: &amp;T) { to_print.print(); to_print.print(); } fn main() { //      :  . print_it_twice(&amp;0i32); // 0, 0 print_it_twice(&amp;10i64); // 10, 10 //      i32::Print  i64::Print. let data: [Box&lt;Print&gt;; 2] = [Box::new(20i32), Box::new(30i64)]; for val in &amp;data { //  :    . //   &amp;Box&lt;Print&gt;  &amp;Print ,   //   -     ... print_it_twice(&amp;**val); // 20, 20, 30, 30 } }</span></span></code> </pre><br>  Cool.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not exactly perfect, but cool. </font><font style="vertical-align: inherit;">Unfortunately, there is no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl Trait for Box &lt;Trait&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - it seems to me that it will interact badly with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl &lt;T: Trait&gt; Trait for Box &lt;T&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but I haven‚Äôt seriously dug it up yet. </font><font style="vertical-align: inherit;">Maybe enough that </font><font style="vertical-align: inherit;">we have </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sized</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Associated Types </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What are the consequences of the fact that we define something as generalized by some type? And what do we want to express by this? Actually, the expression and the consequence are the same here, we want to determine how to work with the type that we slip. In fact - our type is an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">input parameter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct Foo &lt;T&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> says that we can put together a full type only from Foo and T together, Foo itself is incomplete. If you have a passion for special terms, you can say that Foo is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a type constructor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a function that takes a type as an argument and returns a type as a result. That is a higher order type.</font></font><br><br>  Further. <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trait Eat &lt;T&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or the generalized treat of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - what does he tell us about himself? At a minimum, that it can be implemented more than once. And also that for each of its implementations one must keep in mind a certain third-party type </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , without it </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eat is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> incomplete. Hence the conclusion that it is impossible to say that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is implemented somewhere, only </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eat &lt;T&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be implemented </font><font style="vertical-align: inherit;">, where </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in turn, is defined by the user. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, ok, and we have to do with it? This can be shown by the example of iterators:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span></span>&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;; } <span class="hljs-comment"><span class="hljs-comment">/// ,    ,    struct StackIter&lt;T&gt; { data: Vec&lt;T&gt;, } //   [min, max) struct RangeIter { min: u32, max: u32, } impl&lt;T&gt; Iterator&lt;T&gt; for StackIter&lt;T&gt; { fn next(&amp;mut self) -&gt; Option&lt;T&gt; { self.data.pop() } } impl Iterator&lt;u32&gt; for RangeIter { fn next(&amp;mut self) -&gt; Option&lt;u32&gt; { if self.min &gt;= self.max { None } else { let res = Some(self.min); self.min += 1; res } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Still alright. We can write both general and private interface implementations. And then miracles began to work - every </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">real</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type can implement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only once</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . StackIter &lt;Cat&gt; implements only </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator &lt;Cat&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it has no need to implement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator &lt;Dog&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In fact, he cannot be allowed to implement anything else, otherwise the user will be puzzled, which object </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of the implemented types</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator :: next ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> return to it </font><font style="vertical-align: inherit;">! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that we are absolutely not thrilled that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as an input type for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the same input type </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Nevertheless, there is no way out of this, because we, as a user, cannot hardcode the types that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator :: next ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yields </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This information is required to give us the type that implements the iterator! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this not too joyful moment, it's time to get acquainted with the associated types. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Associated types allow us to specify that the implementation of a trait should indicate additional types associated with a particular implementation. </font><font style="vertical-align: inherit;">That is to say that the trait requires specific types in the same way as specific functions. </font><font style="vertical-align: inherit;">Here is an appropriately converted </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//       , //      type Item; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; } /// ,    ,    struct StackIter&lt;T&gt; { data: Vec&lt;T&gt;, } //   [min, max) struct RangeIter { min: u32, max: u32, } impl&lt;T&gt; Iterator for StackIter&lt;T&gt; { //     //   - type Item = T; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { self.data.pop() } } impl Iterator for RangeIter { //    type Item = u32; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { if self.min &gt;= self.max { None } else { let res = Some(self.min); self.min += 1; res } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And now we cannot implement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> several times. </font><font style="vertical-align: inherit;">Although associated types can be generalized, they cannot be defined separately from other types, such as, for example, here:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> RangeIter { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span> = T; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::Item&gt; { <span class="hljs-built_in"><span class="hljs-built_in">unimplemented!</span></span>() } }</code> </pre><br><pre> <code class="bash hljs">&lt;anon&gt;:3:6: 3:7 error: the <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> parameter `T` is not constrained by the impl trait, self <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>, or predicates [E0207] &lt;anon&gt;:3 impl&lt;T&gt; Iterator <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> RangeIter { ^</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the associated types can be entitled to give the name " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outgoing types</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we have limited the implementation of the trait to associated types, what else does this give us? </font><font style="vertical-align: inherit;">Now we can express something such inaccessible earlier?</font></font><br>  And then! <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is the state machine (our slightly tweaked iterator): </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NextState</span></span></span></span>: StateMachine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Self::NextState&gt;; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, this is a type, an instance of which we can ask to make </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">step ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the result of which will be its transformation into another instance of the same type. </font><font style="vertical-align: inherit;">Express it to the generic ...:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span></span>&lt;NextStep: StateMachine&lt;_____&gt;&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">step</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;NextState&gt;; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... and happily get infinite recursion of types. Since the generic type of generic is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incoming</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it must be defined by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">user of the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trait. In this case, this type is the treit itself. However, you can do without the associated types - we also have virtualization!</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateMachine</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// Box ! self    Box&lt;Self&gt;. //  Rc&lt;Self&gt;    ,   *Box *. // (    ,     - ..) fn step(self: Box&lt;Self&gt;) -&gt; Option&lt;Box&lt;StateMachine&gt;&gt;; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we drew our old state machine, but without associated types. We absorb the original copy (self is not borrowed from us, that is, after the completion of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">step ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it can no longer be used - comment. Per.), At the output we get </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">something</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that implements the state machine. But for this to work, we need to restrict the use of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> state machines to their implementations on the heap, and we lose information about a particular type of machine after the first call to step (). With associative types neither the first nor the second occurs. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here's another: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trait objects do not work with associated types</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">For the same reason why they do not work with Self by value, the specific implementation type is unknown. </font><font style="vertical-align: inherit;">The way to make them friends is to specify all specific types. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Box &lt;Iterator&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> curses, and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Box &lt;Iterator &lt;Item = u32 &gt;&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is quite a whistle.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Where clauses </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Our old example: </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Generic&lt;T&gt; { <span class="hljs-comment"><span class="hljs-comment">// ,   :   `equal`  , //  ,   . // (`x == y`     `y == x`).       , //   `T: Equal&lt;U&gt;`   ?       //   `T`,   `U`   ! //   . fn my_equal&lt;U: Equal&lt;T&gt;&gt;(&amp;self, other: &amp;Generic&lt;U&gt;) -&gt; bool { other.data.equal(&amp;self.data) } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now we are able to associate types - how will this help us? </font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  :      //   " ",       //   ,    Item! fn min&lt;I: Iterator&lt;Item = T&gt;, T: Ord&gt;(mut iter: I) -&gt; Option&lt;I::Item&gt; { if let Some(first) = iter.next() { let mut min = first; for x in iter { if x &lt; min { min = x; } } Some(min) } else { None } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And there is a solution - the condition "Where". </font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;T&gt; Generic&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">my_equal</span></span></span></span>&lt;U&gt;(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: &amp;Generic&lt;U&gt;) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T: Equal&lt;U&gt; { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.data.equal(&amp;other.data) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span></span>&lt;I&gt;(<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> iter: I) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;I::Item&gt; <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> I: <span class="hljs-built_in"><span class="hljs-built_in">Iterator</span></span>, I::Item: <span class="hljs-built_in"><span class="hljs-built_in">Ord</span></span>, { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(first) = iter.next() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> min = first; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iter { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; min { min = x; } } <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(min) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } }</code> </pre><br> <b>Where</b>    <i></i> .  ,  .   ,     . <b>Where</b>     ,  , , ,  ‚Äî  , ,    . <br><br>  ,          ( - <b>impl Send for MyReference&lt;T&gt; where &amp;T: Send</b>    (  <a href="https://github.com/rust-lang/rust/pull/35091">  </a> ‚Äî ..)),  <b>Where</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interaction with treyt-objects is also accompanied by some special effects. </font><font style="vertical-align: inherit;">Remember, I said that treyte, which implies addressing to oneself by meaning, cannot be used in a treyt-object? </font><font style="vertical-align: inherit;">In short, special effects can fix this:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Print</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>); <span class="hljs-comment"><span class="hljs-comment">// `where Self: Sized` ,  //   - . , //   Print  -! fn copy(&amp;self) -&gt; Self where Self: Sized; } impl Print for u32 { fn print(&amp;self) { println!("{}", self); } fn copy(&amp;self) -&gt; Self { *self } } fn main() { let x: Box&lt;Print&gt; = Box::new(0u32); x.print(); }</span></span></code> </pre><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Higher order trait restrictions </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If by this time you have not gone to the roof yet - you are just lucky, as the next section does not leave her a chance. </font><font style="vertical-align: inherit;">Here a frankly muddy bog will take place and be described, in which only notorious fanatics of stranded type systems can get the pleasure of picking. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we will write higher-order functions, which, in turn, are "functions that work with functions." </font><font style="vertical-align: inherit;">A beautiful and well-known example is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">map ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>&gt; = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y: <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>&gt; = x.map(|v| v &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre><br>          ,  Rust    . ¬´, ,  ,  , ¬ª,  ,    ¬´    !¬ª.  : <b>Fn</b> , <b>FnMut</b>  <b>FnOnce</b> .      ,        ,     ,    . <br><br> <b>Fn</b> -  ,   . <b>Fn(A, B) -&gt; C</b> ,   ,   . -   .   :    . <b>Fn(A, B) -&gt; C</b> ‚Äî     ,     (  1.7  ).     <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fn &lt;(A, B), Output = C&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Incoming types, outgoing types are clearly visible, everything is straightforward as we tell! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on this, the closure from the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">map ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> example </font><font style="vertical-align: inherit;">implements </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FnOnce (u32) -&gt; bool</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">While not at all scary. </font><font style="vertical-align: inherit;">For now.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_first</span></span></span></span>(input: &amp;(<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>)) -&gt; &amp;<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { &amp;input.<span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> a = (<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> b = (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(&amp;a); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(&amp;b); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, x.map(get_first).unwrap()); <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, y.map(get_first).unwrap()); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What, in fact, does </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_first</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trait </font><font style="vertical-align: inherit;">implement here? </font><font style="vertical-align: inherit;">Looks like </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fn (&amp; (u32, i32)) -&gt; &amp; u32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">Hell no.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFn</span></span></span></span>&lt;Input&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// -;    //  ,      . struct Thunk; impl MyFn&lt;&amp;(u32, i32)&gt; for Thunk { type Output = &amp;u32; }</span></span></code> </pre><br><pre> <code class="bash hljs">&lt;anon&gt;:9:11: 9:22 error: missing lifetime specifier [E0106] &lt;anon&gt;:9 impl MyFn&lt;&amp;(u32, i32)&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Thunk { ^~~~~~~~~~~ &lt;anon&gt;:9:11: 9:22 <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>: see the detailed explanation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> E0106 &lt;anon&gt;:10:19: 10:23 error: missing lifetime specifier [E0106] &lt;anon&gt;:10 <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Output = &amp;u32; ^~~~ &lt;anon&gt;:10:19: 10:23 <span class="hljs-built_in"><span class="hljs-built_in">help</span></span>: see the detailed explanation <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> E0106 error: aborting due to 2 previous errors</code> </pre><br>     ‚Äî    .  :      ‚Äî   !  ,  Rust  ,        99% ,      (  ,      ,      ‚Äî ..). <br><br> , <b>get_first</b>        : <br><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_first</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(input: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>)) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> { &amp;input.<span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre><br>   :     ,   <i></i>  . ,    : <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFn</span></span></span></span>&lt;Input&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thunk</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; MyFn&lt;&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>)&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Thunk { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compiles. </font><font style="vertical-align: inherit;">And now I tell you the opposite: the trey we need is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fn (&amp; (u32, i32)) -&gt; &amp; u32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">There, above, I lied to you. </font><font style="vertical-align: inherit;">How and why, now I will show with an example filter for an iterator:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">///    struct Filter&lt;I, F&gt; { iter: I, pred: F, } ///   fn filter&lt;I, F&gt;(iter: I, pred: F) -&gt; Filter&lt;I, F&gt; { Filter { iter: iter, pred: pred } } impl&lt;I, F&gt; Iterator for Filter&lt;I, F&gt; where I: Iterator, F: Fn(&amp;I::Item) -&gt; bool, // !   -   !   ? { type Item = I::Item; fn next(&amp;mut self) -&gt; Option&lt;I::Item&gt; { while let Some(val) = self.iter.next() { if (self.pred)(&amp;val) { return Some(val); } } None } } fn main() { let x = vec![1, 2, 3, 4, 5]; for v in filter(x.into_iter(), |v: &amp;i32| *v % 2 == 0) { println!("{}", v); // 2, 4 } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything is strange and strange. </font><font style="vertical-align: inherit;">We need </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pred () to</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> work with the lifetime </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp; val</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Alas, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we are not able to explicitly call this lifetime</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , even if we hang the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Where</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> condition </font><font style="vertical-align: inherit;">on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">next ()</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (in general, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterator</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will not allow </font><font style="vertical-align: inherit;">us </font><font style="vertical-align: inherit;">this way). </font><font style="vertical-align: inherit;">This lifetime simply appears and disappears inside the function, we can neither select nor name it. </font><font style="vertical-align: inherit;">And we also need pred () to work with that name ‚Äî you can't call it! </font><font style="vertical-align: inherit;">Getting in the forehead will require pred () to work with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lifetimes.</font></font> Suddenly: <br><br><pre> <code class="rust hljs">F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;I::Item) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it's sugar for </font></font><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>(&amp;I::Item) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for &lt;'a&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is read almost literally: for all' a (for all 'a)! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's call this </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constraint higher-order trait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (higher rank trait bound (HRTB) ). </font><font style="vertical-align: inherit;">You do not need to work with them, unless you have already been sucked into some swamp with complex types of structures. </font><font style="vertical-align: inherit;">Usually, HTRBs are shown when working with functional traits, and even there they are covered with syntactic sugar, that is, they are often transparent to the user. </font><font style="vertical-align: inherit;">Even at the moment, the restrictions of higher-order traits work only with lifetimes.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Types of higher orders </font></font></h4><br>    ,          .   <b>Vec</b>     <b>(T) -&gt; Vec&lt;T&gt;</b> .          ,  <b>impl&lt;T&gt; Trait for Vec&lt;T&gt;</b>  <b>fn make_vec&lt;T&gt;() -&gt; Vec&lt;T&gt;</b> .       ‚Äî    ,      .  ,       . <br><br> ,    ,      (reference-counted pointers). Rust   , <b>Rc</b>  <b>Arc</b> . <b>Rc</b> , <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arc is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> thread safe. Suppose, from the point of view of implementation in our structure, these types are completely interchangeable. But for users of the structure it is very important what kind of pointer-counter is used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, we want our structure to be generalized relative to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ideally, we would write such things:</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,   .   ! ///     . /// RefCount   Rc  Arc,    . struct Node&lt;RefCount: RcLike, T&gt; { elem: T, next: Option&lt;RefCount&lt;Node&lt;RefCount, T&gt;&gt;&gt;, }</span></span></code> </pre><br> ,   !      Rc  Arc ,     . - ,   ,  -,  <b>Rc&lt;SomeType&gt;</b> .        <b>Rc&lt;Node&lt;T&gt;&gt;</b> ,    ,     <b>Rc</b>  <b>Arc</b> .      ,  ,  : <br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// ,    `next` , ///      . trait RefIterator { type Item; fn next(&amp;mut self) -&gt; &amp;mut T }</span></span></code> </pre><br> ,    ,    <br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefIterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> Self::Item; }</code> </pre><br>     ,       ,    ,    <b>Self::Item</b>  - .      ,   : <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RefIterator</span></span></span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Self::Item&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems more beautiful and more generalized, because you can write </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Self :: Item = &amp; mut T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and theoretically we are satisfied. </font><font style="vertical-align: inherit;">So far, we do not notice that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Item has</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quietly turned into a type constructor, but it is impossible to generalize them! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although if you ask the compiler well, you can. </font><font style="vertical-align: inherit;">But I did not tell you that. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please do not scorch the office. </font></font></s> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The key knowledge here is the understanding that the treit has incoming and outgoing types, that is, the treit is a function on top of the types.</font></font> Look here: <br><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeToType</span></span></span></span>&lt;Input&gt; { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type constructor! </font><font style="vertical-align: inherit;">Let's go to implement the general </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RefIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> reference </font><b><font style="vertical-align: inherit;">counting iterator</font></b><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::marker::PhantomData; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::mem; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cmp; <span class="hljs-comment"><span class="hljs-comment">// ,  RefIter    struct MyType&lt;'a&gt; { slice: &amp;'a mut [u8], index: usize, } //     : trait LifetimeToType&lt;'a&gt; { type Output; } // - , //      /// &amp;'* T struct Ref_&lt;T&gt;(PhantomData&lt;T&gt;); /// &amp;'* mut T struct RefMut_&lt;T&gt;(PhantomData&lt;T&gt;); /// MyType&lt;*&gt; struct MyType_; //   ,      impl&lt;'a, T: 'a&gt; LifetimeToType&lt;'a&gt; for Ref_&lt;T&gt; { type Output = &amp;'a T; } impl&lt;'a, T: 'a&gt; LifetimeToType&lt;'a&gt; for RefMut_&lt;T&gt; { type Output = &amp;'a mut T; } impl&lt;'a&gt; LifetimeToType&lt;'a&gt; for MyType_ { type Output = MyType&lt;'a&gt;; } //   ,   ! // `Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output` // -   'a  TypeCtor. // // , : &lt;X as Trait&gt;::AssociatedItem  " -", //      . // // :  ,     HRTB, //    `T: 'a`. // `for&lt;'a&gt; Self::TypeCtor: LifetimeToType&lt;'a&gt;`   // `&amp;'a T`    `'a`, //       `T: 'static`! //    "where"  `next`. trait RefIterator { type TypeCtor; fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;&lt;Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output&gt; where Self::TypeCtor: LifetimeToType&lt;'a&gt;; } // ! struct Iter&lt;'a, T: 'a&gt; { slice: &amp;'a [T], } struct IterMut&lt;'a, T: 'a&gt; { slice: &amp;'a mut [T], } struct MyIter&lt;'a&gt; { slice: &amp;'a mut [u8], } // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">FIXME:</span></span></span><span class="hljs-comment"> https://github.com/rust-lang/rust/issues/31580 //      ,    . //         // (     ,   ) fn _hack_project_ref&lt;'a, T&gt;(v: &amp;'a T) -&gt; &lt;Ref_&lt;T&gt; as LifetimeToType&lt;'a&gt;&gt;::Output { v } fn _hack_project_ref_mut&lt;'a, T&gt;(v: &amp;'a mut T) -&gt; &lt;RefMut_&lt;T&gt; as LifetimeToType&lt;'a&gt;&gt;::Output { v } fn _hack_project_my_type&lt;'a&gt;(v: MyType&lt;'a&gt;) -&gt; &lt;MyType_ as LifetimeToType&lt;'a&gt;&gt;::Output { v } //  (   ) impl&lt;'x, T&gt; RefIterator for Iter&lt;'x, T&gt; { type TypeCtor = Ref_&lt;T&gt;; fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;&lt;Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output&gt; where Self::TypeCtor: LifetimeToType&lt;'a&gt; { if self.slice.is_empty() { None } else { let (l, r) = self.slice.split_at(1); self.slice = r; Some(_hack_project_ref(&amp;l[0])) } } } impl&lt;'x, T&gt; RefIterator for IterMut&lt;'x, T&gt; { type TypeCtor = RefMut_&lt;T&gt;; fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;&lt;Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output&gt; where Self::TypeCtor: LifetimeToType&lt;'a&gt; { if self.slice.is_empty() { None } else { let (l, r) = mem::replace(&amp;mut self.slice, &amp;mut []).split_at_mut(1); self.slice = r; Some(_hack_project_ref_mut(&amp;mut l[0])) } } } impl&lt;'x&gt; RefIterator for MyIter&lt;'x&gt; { type TypeCtor = MyType_; fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;&lt;Self::TypeCtor as LifetimeToType&lt;'a&gt;&gt;::Output&gt; where Self::TypeCtor: LifetimeToType&lt;'a&gt; { if self.slice.is_empty() { None } else { let split = cmp::min(self.slice.len(), 5); let (l, r) = mem::replace(&amp;mut self.slice, &amp;mut []).split_at_mut(split); self.slice = r; let my_type = MyType { slice: l, index: split / 2 }; Some(_hack_project_my_type(my_type)) } } } // ! fn main() { let mut data: [u8; 12] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]; { let mut iter = Iter { slice: &amp;data }; while let Some(v) = iter.next() { println!("{:?}", v); } } { let mut iter = IterMut { slice: &amp;mut data }; while let Some(v) = iter.next() { println!("{:?}", v); } } { let mut iter = MyIter { slice: &amp;mut data }; while let Some(v) = iter.next() { println!("{:?} {}", v.slice, v.index); } } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'm not sure that I will be able to decipher what is happening above, and I am not sure that this is necessary ‚Äî the usual sequence of actions described here earlier. And anyway, will it help us deal with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And yes!</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::sync::Arc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Deref; <span class="hljs-comment"><span class="hljs-comment">//   T -&gt; Output trait RcLike&lt;T&gt; { type Output; fn new(data: T) -&gt; Self::Output; } //  struct Rc_; struct Arc_; impl&lt;T&gt; RcLike&lt;T&gt; for Rc_ { type Output = Rc&lt;T&gt;; fn new(data: T) -&gt; Self::Output { Rc::new(data) } } impl&lt;T&gt; RcLike&lt;T&gt; for Arc_ { type Output = Arc&lt;T&gt;; fn new(data: T) -&gt; Self::Output { Arc::new(data) } } struct Node&lt;Ref, T&gt; //  `where`     ( - ) where Ref: RcLike&lt;Node&lt;Ref, T&gt;&gt;, { elem: T, //  : Option&lt;Rc&lt;Node&lt;Rc_, T&gt;&gt; next: Option&lt;&lt;Ref as RcLike&lt;Node&lt;Ref, T&gt;&gt;&gt;::Output&gt; } struct List&lt;Ref, T&gt; where Ref: RcLike&lt;Node&lt;Ref, T&gt;&gt;, { head: Option&lt;&lt;Ref as RcLike&lt;Node&lt;Ref, T&gt;&gt;&gt;::Output&gt; } impl&lt;Ref, T, RefNode&gt; List&lt;Ref, T&gt; where Ref: RcLike&lt;Node&lt;Ref, T&gt;, Output=RefNode&gt;, RefNode: Deref&lt;Target=Node&lt;Ref, T&gt;&gt;, RefNode: Clone, { fn new() -&gt; Self { List { head: None } } fn push(&amp;self, elem: T) -&gt; Self { List { head: Some(Ref::new(Node { elem: elem, next: self.head.clone(), })) } } fn tail(&amp;self) -&gt; Self { List { head: self.head.as_ref().and_then(|head| head.next.clone()) } } } fn main() { //  ( ,      ) let list: List&lt;Rc_, u32&gt; = List::new().push(0).push(1).push(2).tail(); println!("{}", list.head.unwrap().elem); // 1 let list: List&lt;Arc_, u32&gt; = List::new().push(10).push(11).push(12).tail(); println!("{}", list.head.unwrap().elem); // 11 }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almost</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> succeeded, but the above-mentioned condition prevents </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where Ref: RcLike &lt;Node &lt;Ref, T &gt;&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This is a hole in our abstraction. On the one hand, users of our structure do not need to know about Node, on the other hand, we have to mention them there. And I would like to be able to say that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ref</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RcLike </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for anything</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Technically, it sounds like </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where for &lt;T&gt; Ref: RcLike &lt;T&gt;</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This will allow us to hide the optional distribution details of the use of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ref</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Alas.    ,         ,   .   -  ,     ,         !   . <br> (   ,     <a href="https://github.com/rust-lang/rfcs/issues/376">  RFC</a> ,        ,     -,       ‚Äî ..) <br><br> ,  ,   ,     ,     ,    ,    Rust     .   ,         . <br><br><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Have you ever thought that two copies of the same type are actually interchangeable? So that if we had two </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widgets</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and we swapped them, no-one would lead us. In most cases, this is highly welcome. And what if you </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prohibit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instances of the same type to be interchanged? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays, for example. When we iterate through an array, this is usually done to get its elements. Well, yes, this task requires us to provide the appropriate iterators for the various needs of accessing the elements: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IterMut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It would not be more convenient if the iterator told us </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to look, and we already decided </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is there a boss? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Theoretically, this is possible if your array has its own index iterator. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0, 1, 2, ..., len - 1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Run on indices, business, everyone is happy. Only in this case the reliability of the iterator suffers. Usually, the iterators are just waiting for confidence that each element will be passed at least once, and they are guaranteed not to fall.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Access by index breaks all of the above. Indices can be changed, you can change the array itself, making the indices invalid, you can finally accidentally pull the indices of one array onto another. But all this is solved, with varying degrees of effort. Against the substitution of indexes - type-wrapper over them, so that their real values ‚Äã‚Äãare inaccessible to the user. Binding them to the lifetime of their array will help excellently against invalidating indices. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And with the substitution of the array itself? I have two arrays, the types of their indices are identical and de facto interchangeable, but we do not want this. The way we get the (un) desired is called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generalizability</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (generativity). The basis of generalizability is the idea of ‚Äã‚Äãhaving different instances of the same type different associated types.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value of the associated type depends on the type instance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , that is. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I'm tired, terribly tired. We are almost the finish line anyway, so I‚Äôll just copy here a demonstration of the above, which I wrote some time ago. Anyway, everything is in the comments, read them.</font></font><br><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      , //       ""  //   .        , //    ,     . // (      Vec,        ). // //     "   ",  //   .      //   ,         , //      ( ?).    //   ,      ,    //       ,     . //     .    //       (let idx = arr.validate(idx)). // //     -    //  ,    ,   //       ( moving values in/out  try!). //  ,        //   , ,    ,  . //          //  API ( ,    Vec --     `push`  `pop`. //       . // //     ,        , //       ,        // //      gereeter    //    BTreeMap.  ST Monad  Haskell   . // //      ,     //     &amp;[T]  &amp;mut [T]. fn main() { use indexing::indices; let arr1: &amp;[u32] = &amp;[1, 2, 3, 4, 5]; let arr2: &amp;[u32] = &amp;[10, 20, 30]; //   ( ,     ) indices(arr1, |arr1, it1| { indices(arr2, move |arr2, it2| { for (i, j) in it1.zip(it2) { println!("{} {}", arr1.get(i), arr2.get(j)); //        // println!("{} ", arr2.get(i)); // println!("{} ", arr1.get(j)); } }); }); //   ,      let _a = indices(arr1, |arr, mut it| { let a = it.next().unwrap(); let b = it.next_back().unwrap(); println!("{} {}", arr.get(a), arr.get(b)); // a //   ,    }); //     ,    let (x, y) = indices(arr1, |arr, mut it| { let a = it.next().unwrap(); let b = it.next_back().unwrap(); (arr.get(a), arr.get(b)) }); println!("{} {}", x, y); //  :    !? // (:        ) } mod indexing { use std::marker::PhantomData; use std::ops::Deref; use std::iter::DoubleEndedIterator; // Cell&lt;T&gt;   T;  Cell&lt;&amp;'id _&gt;  `id` . //  ,         // 'id  "" . type Id&lt;'id&gt; = PhantomData&lt;::std::cell::Cell&lt;&amp;'id mut ()&gt;&gt;; pub struct Indexer&lt;'id, Array&gt; { _id: Id&lt;'id&gt;, arr: Array, } pub struct Indices&lt;'id&gt; { _id: Id&lt;'id&gt;, min: usize, max: usize, } #[derive(Copy, Clone)] pub struct Index&lt;'id&gt; { _id: Id&lt;'id&gt;, idx: usize, } impl&lt;'id, 'a&gt; Indexer&lt;'id, &amp;'a [u32]&gt; { pub fn get(&amp;self, idx: Index&lt;'id&gt;) -&gt; &amp;'a u32 { unsafe { self.arr.get_unchecked(idx.idx) } } } impl&lt;'id&gt; Iterator for Indices&lt;'id&gt; { type Item = Index&lt;'id&gt;; fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { if self.min != self.max { self.min += 1; Some(Index { _id: PhantomData, idx: self.min - 1 }) } else { None } } } impl&lt;'id&gt; DoubleEndedIterator for Indices&lt;'id&gt; { fn next_back(&amp;mut self) -&gt; Option&lt;Self::Item&gt; { if self.min != self.max { self.max -= 1; Some(Index { _id: PhantomData, idx: self.max }) } else { None } } } pub fn indices&lt;Array, F, Out&gt;(arr: Array, f: F) -&gt; Out where F: for&lt;'id&gt; FnOnce(Indexer&lt;'id, Array&gt;, Indices&lt;'id&gt;) -&gt; Out, Array: Deref&lt;Target = [u32]&gt;, { //    .      //         (,  //  F).   ,    `indices`  //  ,       . // //          //  ,     `'static`,      ,     //  *this*.           . //       ,    ,  //           // ,     . // //       , //     ,     ,      . //   ,        , //        . let len = arr.len(); let indexer = Indexer { _id: PhantomData, arr: arr }; let indices = Indices { _id: PhantomData, min: 0, max: len }; f(indexer, indices) } }</span></span></code> </pre><br><br> ,   ,  ?  ,  .    <i></i>   .      Rust   Unsafe           ‚Äî          (  . <i></i>   ‚Äî ..)     ,    ,   ,  <b>unsafe</b> ‚Äî    . <br><br>     ‚Äî         ,          Rust,      HTRB     . <br><br>  ,   .      .      .   .  . </div><p>Source: <a href="https://habr.com/ru/post/307616/">https://habr.com/ru/post/307616/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../307604/index.html">CodeRush for Roslyn 16.1.6 - Official Release</a></li>
<li><a href="../307606/index.html">Java DevTools: Fashionable does not mean good</a></li>
<li><a href="../307608/index.html">Can a startup hit the $ 20 billion cyber risk insurance market?</a></li>
<li><a href="../307612/index.html">PostgreSQL in Russian seriously and for a long time</a></li>
<li><a href="../307614/index.html">UltraCMOS Peregrine Semiconductor: Microwave capabilities of CMOS technology</a></li>
<li><a href="../307618/index.html">History of programming languages: how Haskell became the standard of functional programming</a></li>
<li><a href="../307620/index.html">Errors of questionnaires. 1 error: sample offset. 8 ways to attract the right respondents</a></li>
<li><a href="../307622/index.html">Porting FreeModbus under STM32. Version from dinar</a></li>
<li><a href="../307624/index.html">The report on the results of "My Circle" for July 2016, and the most popular vacancies of the month</a></li>
<li><a href="../307626/index.html">Changes in CleverStyle Framework 5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>