<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We relieve the player from irritation: the correct use of random numbers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you happen to chat with an RPG fan, you will soon hear complaints about randomized results and loot, as well as how annoying they can be. Many game...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We relieve the player from irritation: the correct use of random numbers</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c7/54a/54a/3c754a54ae259cf8cbc3d8c9526dad78.jpg" alt="image"></div><br>  If you happen to chat with an RPG fan, you will soon hear complaints about randomized results and loot, as well as how annoying they can be.  Many gamers express their annoyance, and while some developers come up with innovative solutions, the majority still forces us to pass into enraging checks for perseverance. <br><br>  But there is a better way.  Using random numbers and generating them in a different way, we can create an exciting gameplay that creates an ‚Äúideal‚Äù level of complexity, without dislodging players.  But before we get to this, let's look at the basics of random number generators (or RNG). <br><a name="habracut"></a><br><h2>  Random Number Generator and its Applications </h2><br>  Random numbers are found everywhere and are used to add variation to the software.  In general, RNGs are usually used to model chaotic events, to demonstrate inconstancy, or to be an artificial limiter. <br><br>  Most likely, you interact daily with random numbers or the results of their actions.  They are used in scientific experiments, video games, animations, art, and in virtually every computer application.  For example, the RNG is most likely implemented in simple animations on your phone. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now that we have talked a little about the RNG, let's take a look at their implementation and learn how to use them to improve games. <br><br><h2>  Standard random number generator </h2><br>  In almost every programming language, among other functions, there is a standard RNG.  His job is to return a random value in the range of two numbers.  In different systems, standard RNGs can be implemented in dozens of different ways, but in general they have the same effect: they return a random number from the interval, each value in which can be selected with the same probability. <br><br>  In games, generators are often used to simulate bone rolls.  Ideally, they should be used only in situations where each of the results should occur an equal number of times. <br><br>  If you want to experiment with rarity or different degrees of randomization, then the following method is more suitable for you. <br><br><h2>  Weighted random numbers and rarity slots </h2><br>  This type of RNG is the basis for any RPG with item rarity system.  In particular, it applies when you need a randomized result, but some values ‚Äã‚Äãshould drop out with less frequency than others.  When studying probabilities, a bag of balls is often given as an example.  With a weighted RNG, there may be three blue balls and one red in the bag.  Since we only need one ball, we will get either red or blue, but more likely it will be blue. <br><br>  Why may weighted randomization be important?  Let's take the SimCity in-game events as an example.  If each event were chosen in unweighted ways, then the probability of each event would be statistically the same.  That is, with the same probability you would be offered to open a new casino or an earthquake would occur.  By adding weights, we can make these events happen in proportionate probability, ensuring good gameplay. <br><br><h3>  Types and uses </h3><br><h4>  Grouping the same items </h4><br>  In many books on computer science, this method is called "bag".  The name speaks for itself - classes or objects are used to create a visual representation of the bag in the literal sense. <br><br>  In fact, it works like this: there is a container in which objects can be placed, a function for placing an object in a ‚Äúbag‚Äù and a function for randomly selecting an item from a ‚Äúbag‚Äù.  Returning to our example with the balls, we can say that our bag will contain blue, blue, blue and red balls. <br><br>  Using this method of randomization, we can approximately set the frequency of occurrence of the results in order to average the gameplay for each player.  If we simplify the results to the scale from ‚ÄúVery bad‚Äù to ‚ÄúVery good‚Äù, we will get a much more pleasant system compared to the one when a player can get an unnecessary sequence of unwanted results (for example, ‚ÄúVery bad‚Äù results 20 times in a row). <br><br>  However, it is still possible to statistically get a series of bad results, just the probability of this has decreased.  We will look at a method that goes a little further to reduce unwanted results. <br><br>  Here is a brief example of what the bag class pseudocode might look like: <br><br><pre><code class="cpp hljs">Class Bag { <span class="hljs-comment"><span class="hljs-comment">//    ,    Array itemsInBag; //      Constructor (Array startingItems) { itemsInBag = startingItems; } //   ,   (      ) Function addItem (Object item) { itemsInBag.push(item); } //       random,     Function getRandomItem () { return(itemsInBag[random(0,itemsInBag.length-1)]); } }</span></span></code> </pre> <br><h4>  Implementation of rarity slots </h4><br>  Rare slots are a standardization method for setting the frequency of dropping an object (usually used to simplify the process of creating a game's design and player rewards). <br><br>  Instead of setting the frequency of each individual item in the game, we create a corresponding rarity - for example, the rarity "Normal" may represent the probability of a certain result 20 to X, and the rarity level "Rare" - the probability 1 to X. <br><br>  This method does not greatly change the function of the bag, but it can be used to increase efficiency on the developer‚Äôs side, allowing you to quickly assign the statistical probability of an exponentially large number of objects. <br><br>  In addition, splitting rarities into slots is useful for changing player perceptions.  It allows you to quickly and without having to mess with numbers to understand how often an event should occur so that the player does not lose interest. <br><br>  Here is a simple example of how we can add rarity slots to our bag: <br><br><pre> <code class="cpp hljs">Class Bag { <span class="hljs-comment"><span class="hljs-comment">//    ,    Array itemsInBag; //   ,   Function addItem (Object item) { //     Int timesToAdd; //    //(       , //  ) Switch(item.rarity) { Case 'common': timesToAdd = 5; Case 'uncommon': timesToAdd = 3; Case 'rare': timesToAdd = 1; } //         While (timesToAdd &gt;0) { itemsInBag.push(item); timesToAdd--; } } }</span></span></code> </pre> <br><h2>  Variable frequency random numbers </h2><br>  We talked about some of the most common ways of dealing with accidents in games, so let's move on to more complicated ones.  The concept of using variable frequencies begins in the same way as the bag in the examples above: we have a specified number of results, and we know how often we want them to occur.  The difference in implementation is that we want to change the probability of the results when they occur. <br><br>  Why do we need this?  Take, for example, collecting games.  If we have ten possible outcomes for the item to be obtained, when nine are ‚Äúnormal‚Äù and one is ‚Äúrare‚Äù, then the probabilities are very simple: 90% of the time a player will receive a normal item, and 10% of the time - a rare one.  The problem arises when we take into account several puffs from the bag. <br><br>  Let's look at our chances of getting a series of ordinary results: <br><br><ul><li>  At the first draw, the probability of getting a normal object is 90%. </li><li>  With two stretches, the probability of getting both ordinary items is 81%. </li><li>  With 10 stretches, there is still a likelihood of 35% of all ordinary items. </li><li>  With 20 stretches, there is still a probability of 12%. </li></ul><br>  That is, although the initial 9: 1 ratio seemed ideal to us, in fact, it corresponds only to average results, that is, 1 in 10 players will spend twice the desired amount on getting a rare item.  Moreover, 4% of players will spend on receiving a rare item three times longer, and 1.5% of losers - four times more. <br><br><h3>  How do variable frequencies solve this problem? </h3><br>  The solution is to implement an interval of randomness in our objects.  To do this, we set the maximum and minimum rarity of each object (or rarity slots, if you want to combine this method with the previous example).  For example, let's give our ordinary object a minimum rarity value of 1, and a maximum value of 9. A rare item will have a minimum and maximum value of 1. <br><br>  Now, according to the scenario shown above, we will have ten items, nine of which are instances of the usual, and one - rare.  At the first draw, there is a 90% chance of getting a regular item.  At variable frequencies, after stretching a regular object, we reduce its rarity value by 1. <br><br>  At the same time, in the next stretch, we will have a total of nine items, eight of which are ordinary, which gives a probability of 89% of the usual draw.  After each result with the usual object, the randomness of this object falls, which increases the probability of drawing out the rare, until we are left with two objects in the bag, one ordinary and one rare. <br><br>  Thus, instead of a 35% probability of drawing out 10 ordinary objects in a row, we will have only 5% probability left.  The probability of boundary results, such as pulling out 20 ordinary objects in a row, is reduced to 0.5%, and then it becomes even smaller.  This creates permanent results for the players, and protects us from boundary cases in which the player constantly draws a bad result. <br><br><h3>  Creating a class of variable frequencies </h3><br>  The simplest implementation of a variable frequency is to remove the item from the bag, and not just return it: <br><br><pre> <code class="cpp hljs">Class Bag { <span class="hljs-comment"><span class="hljs-comment">//    ,    Array itemsInBag; //      Constructor (Array startingItems) { itemsInBag = startingItems; } //   ,   (      ) Function addItem (Object item) { itemsInBag.push(item); } Function getRandomItem () { //pick a random item from the bag Var currentItem = itemsInBag[random(0,itemsInBag.length-1)]; //    ,     If (instancesOf (currentItem, itemsInBag) &gt; currentItem.minimumRarity) { itemsInBag.remove(currentItem); } return(currentItem); } }</span></span></code> </pre> <br>  Although some problems appear in such a simple version (for example, the bag gradually enters a state of normal distribution), it displays minor changes to stabilize randomization results. <br><br><h3>  Idea development </h3><br>  We have described the basic idea of ‚Äã‚Äãvariable frequencies, but in our own implementations we need to consider many more aspects: <br><br><ul><li>  Removing objects from the bag allows us to achieve permanent results, but over time returns us to the problems of standard randomization.  How can we change the functions in such a way that both increasing and decreasing items can avoid this? </li><li>  What happens when we deal with thousands or millions of items?  In this case, the solution may be to use a bag filled with bags.  For example, you can create a bag for each rarity (all ordinary items in one bag, rare in the other) and put each one into slots inside a large bag.  This will provide ample opportunities for manipulation. </li></ul><br><h2>  Less boring random numbers </h2><br>  In many games, standard random number generation is still used to create difficulty.  This creates a system in which half of the players deviates in one direction or the other from the expected results.  If left unattended, there will be the possibility of boundary cases with too many repeated bad results. <br><br>  By limiting the scatter intervals, we can provide a more holistic gameplay and allow more players to enjoy it. <br><br><h2>  Summarize </h2><br>  Random number generation is one of the pillars of good game design.  To improve the gameplay, carefully check your statistics and implement the most appropriate types of generation. </div><p>Source: <a href="https://habr.com/ru/post/354132/">https://habr.com/ru/post/354132/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354122/index.html">The million question</a></li>
<li><a href="../354124/index.html">Review of materials on machine learning ‚Ññ 3 (April 16 - 23, 2018)</a></li>
<li><a href="../354126/index.html">And if we do not design a system for managing the production of IT products. Part 1. Analysis of box solutions</a></li>
<li><a href="../354128/index.html">Moving from the CIS to the Czech Republic, own experience</a></li>
<li><a href="../354130/index.html">HoleyBeep: explanation and exploit</a></li>
<li><a href="../354134/index.html">Hypothesis</a></li>
<li><a href="../354136/index.html">Build rpm packages and configure your repository</a></li>
<li><a href="../354138/index.html">How the stats and monitoring of WebRTC changed the monitoring of VoIP</a></li>
<li><a href="../354140/index.html">Kubernetes Ice Cream, or Beginner Container Solutions</a></li>
<li><a href="../354142/index.html">Difficulties of translation: how to find plagiarism from English in Russian scientific articles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>