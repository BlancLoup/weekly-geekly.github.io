<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Some aspects of the development of payment systems. Part II. One time passwords and ECDSA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good health,%% username! 

 In the first part, I told you as little as possible to protect the database of our payment system. But, as one of the comm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Some aspects of the development of payment systems. Part II. One time passwords and ECDSA</h1><div class="post__text post__text-html js-mediator-article">  Good health,%% username! <br><br>  In the <a href="http://habrahabr.ru/blogs/pay_sistem/96091/">first part,</a> I told you as little as possible to protect the database of our payment system.  But, as one of the commentators <a href="http://habrahabr.ru/blogs/pay_sistem/96091/">noted</a> , when a web server is compromised, it is possible to peep all user logins and passwords.  This is where One time passwords (OTP) comes to our rescue. <br>  Under the cut is my free interpretation of this term using elliptic curve cryptography (ECC).  By the way, payment systems are far from the only field of application of this technology. <br>  <b>Upd:</b> <br>  <b>Achtung</b> !  When hacking a web server, there is still the possibility of substitution of payment details, so it‚Äôs better not to sign a random string (although this will protect the system from being completely compromised, but it doesn‚Äôt protect it from cases when the details are replaced right during the payment), and the hash of the payment document , showing the user with all the details of the payment program. <br>  ZY  Generating a key is also better on the client side. <br><a name="habracut"></a><br>  In order not to invent disposable password cards, it was decided to use EDS.  I just turned up the occasion to use the elliptic curves so loved by me because of its reliability and speed. <br>  The scheme was as follows: <br><ol><li>  When registering a user, we give him an encrypted file with an open / private key and a password from it.  We leave only the public key. </li><li>  When the user wants to make a payment or money transfer, we randomly generate a string that we show him.  We save it in a DB with a binding to the user. </li><li>  The user copies the string into a special program that, using the password given, decrypts the private key and signs our random string. </li><li>  The user gives us the signature, we check it with the public key and give the go-ahead for the operation. </li></ol><br><br>  It was necessary to write an external storage for MySQL and related programs.  The good old OpenSSL was chosen as the crypto-library.  As a result, 2 days without sleep, the working version of: <br><ol><li>  Programs that generate a key pair and put it in the database (written in Builder). </li><li>  Programs for the user, generating a digital signature (on it). </li><li>  External storage, this digital signature verifier (the user needs an answer instantly, the program does not roll).  Posted by vc. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Immediately I warn you: the code does not shine with beauty, C is not my main PS. <br><br>  Now the points: <br><br>  <b>1) Generate the key</b> <br><blockquote>  <font color="black"><font color="#0000ff">const</font> KEYSIZE = SHA512_DIGEST_LENGTH + 4;</font>  <font color="black"><font color="#008000">// 4 bytes on the "salt"</font></font> <font color="black"><br></font>  <font color="black">unsigned <font color="#0000ff">char</font> * pubkey = (unsigned <font color="#0000ff">char</font> *) OPENSSL_malloc (10000),</font> <font color="black"><br></font>  <font color="black">* privkey = (unsigned <font color="#0000ff">char</font> *) OPENSSL_malloc (10000);</font>  <font color="black"><font color="#008000">// public and private key buffers</font></font> <font color="black"><br></font>  <font color="black">AnsiString pub, prv, userid, paypass;</font>  <font color="black"><font color="#008000">// strings for storing public, private keys and their password</font></font> <font color="black"><br></font>  <font color="black">unsigned <font color="#0000ff">char</font> md [KEYSIZE] = {0};</font>  <font color="black"><font color="#008000">// there will be a password hash</font></font> <font color="black"><br></font>  <font color="black">unsigned <font color="#0000ff">int</font> i = ParamCount ();</font> <font color="black"><br><br></font>  <font color="black">paypass = <font color="#A31515">"rAnDom_PaSs"</font> ;</font> <font color="black"><br><br></font>  <font color="black">EC_GROUP * group = EC_GROUP_new_by_curve_name (NID_sect571r1);</font>  <font color="black"><font color="#008000">// choose an elliptic curve</font></font> <font color="black"><br></font>  <font color="black">EC_GROUP_set_point_conversion_form (group, POINT_CONVERSION_UNCOMPRESSED);</font> <font color="black"><br><br></font>  <font color="black">EC_KEY * x = EC_KEY_new ();</font> <font color="black"><br></font>  <font color="black">EC_KEY_set_group (x, group);</font> <font color="black"><br></font>  <font color="black">BIO * <font color="#0000ff">out</font> = BIO_new (BIO_s_mem ());</font>  <font color="black"><font color="#008000">// We will write in memory</font></font> <font color="black"><br><br></font>  <font color="black"><font color="#008000">// Code to slow down the brute force</font></font> <font color="black"><br><br></font>  <font color="black">env_md_ctx_st mdctx;</font>  <font color="black"><font color="#008000">// context for hash</font></font> <font color="black"><br></font>  <font color="black">EVP_MD_CTX_init (&amp; mdctx);</font> <font color="black"><br></font>  <font color="black">EVP_DigestInit_ex (&amp; mdctx, EVP_sha512 (), NULL);</font>  <font color="black"><font color="#008000">// Hashing Algorithm - SHA512</font></font> <font color="black"><br></font>  <font color="black">EVP_DigestUpdate (&amp; mdctx, paypass.c_str (), strlen (paypass.c_str ()));</font>  <font color="black"><font color="#008000">// Hash password for the first time</font></font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">for</font> (i = 0; i &lt;0x20000; i ++) {</font> <font color="black"><br><br></font>  <font color="black">memcpy (md, mdctx.md_data, SHA512_DIGEST_LENGTH);</font>  <font color="black"><font color="#008000">// copy hash to array</font></font> <font color="black"><br><br></font>  <font color="black">md [64] = i ^ md [0] ^ md [7] ^ md [5] ^ md [23];</font>  <font color="black"><font color="#008000">// calculate additional 4 bytes</font></font> <font color="black"><br></font>  <font color="black">md [65] = i ^ md [1] ^ md [9] ^ md [6] ^ md [53];</font>  <font color="black"><font color="#008000">// based on previous hash</font></font> <font color="black"><br></font>  <font color="black">md [66] = i ^ md [3] ^ md [25] ^ md [11] ^ md [48];</font>  <font color="black"><font color="#008000">// they will be so-called</font></font>  <font color="black"><font color="#008000">round salt</font></font> <font color="black"><br></font>  <font color="black">md [67] = i ^ md [8] ^ md [18] ^ md [17] ^ md [2];</font> <font color="black"><br><br></font>  <font color="black">EVP_DigestUpdate (&amp; mdctx, md, KEYSIZE);</font>  <font color="black"><font color="#008000">// and hash the previous hash + salt</font></font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br><br></font>  <font color="black">EVP_DigestFinal (&amp; mdctx, md, NULL);</font>  <font color="black"><font color="#008000">// finish counting the hash</font></font> <font color="black"><br></font>  <font color="black">EVP_MD_CTX_cleanup (&amp; mdctx);</font> <font color="black"><br><br></font>  <font color="black">EC_KEY_generate_key (x);</font>  <font color="black"><font color="#008000">// generate key pair</font></font> <font color="black"><br><br></font>  <font color="black">PEM_write_bio_ECPrivateKey ( <font color="#0000ff">out</font> , x, EVP_aes_256_cbc (), md, KEYSIZE, NULL, NULL);</font>  <font color="black"><font color="#008000">// write the AES-256 encrypted key pair with the key calculated in the previous step</font></font> <font color="black"><br></font>  <font color="black">BIO_flush ( <font color="#0000ff">out</font> );</font> <font color="black"><br></font>  <font color="black">i = BIO_read ( <font color="#0000ff">out</font> , privkey, 10,000);</font>  <font color="black"><font color="#008000">// find out the number of bytes written</font></font> <font color="black"><br><br></font>  <font color="black"><font color="#008000">// for fidelity let's compress ZLIB</font></font> <font color="black"><br><br></font>  <font color="black">zByte * compr;</font> <font color="black"><br></font>  <font color="black">uLong comprLenPrv = 1000 * <font color="#0000ff">sizeof</font> ( <font color="#0000ff">int</font> );</font> <font color="black"><br></font>  <font color="black">zByte * comprPrv = (zByte *) calloc ((uInt) comprLenPrv, 1);</font> <font color="black"><br></font>  <font color="black">compress2 (comprPrv, &amp; comprLenPrv, ( <font color="#0000ff">const</font> Bytef *) privkey, i, Z_BEST_COMPRESSION);</font> <font color="black"><br><br></font>  <font color="black">OPENSSL_free (privkey);</font> <font color="black"><br></font>  <font color="black">BIO_free ( <font color="#0000ff">out</font> );</font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">out</font> = BIO_new (BIO_s_mem ());</font>  <font color="black"><font color="#008000">// another buffer for the public key</font></font> <font color="black"><br></font>  <font color="black">PEM_write_bio_EC_PUBKEY ( <font color="#0000ff">out</font> , x);</font>  <font color="black"><font color="#008000">// write it to memory in PEM format</font></font> <font color="black"><br></font>  <font color="black">BIO_flush ( <font color="#0000ff">out</font> );</font> <font color="black"><br></font>  <font color="black">BIO_read ( <font color="#0000ff">out</font> , pubkey, 10,000);</font>  <font color="black"><font color="#008000">// read it in a piece of memory</font></font> <font color="black"><br><br></font>  <font color="black"><font color="#008000">// Magic code to copy the private encrypted key to the byte array</font></font> <font color="black"><br></font>  <font color="black">TByteDynArray cp;</font> <font color="black"><br></font>  <font color="black">cp.set_length (comprLenPrv);</font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">for</font> (i = 0; i &lt;comprLenPrv; i ++) {</font> <font color="black"><br></font>  <font color="black">cp [i] = comprPrv [i];</font> <font color="black"><br></font>  <font color="black">}</font> <font color="black"><br><br></font>  <font color="black"><font color="#008000">// copy the public key into the string</font></font> <font color="black"><br></font>  <font color="black">AnsiString pubk;</font> <font color="black"><br></font>  <font color="black">pubk.sprintf ( <font color="#A31515">"% s"</font> , pubkey);</font> <font color="black"><br><br><br></font>  <font color="black"><font color="#008000">// release the memory</font></font> <font color="black"><br></font>  <font color="black">free (comprPrv);</font> <font color="black"><br></font>  <font color="black">OPENSSL_free (pubkey);</font> <font color="black"><br></font>  <font color="black">BIO_free ( <font color="#0000ff">out</font> );</font> <font color="black"><br></font>  <font color="black">EC_KEY_free (x);</font> <font color="black"><br></font> </blockquote><br><br>  <b>2) We sign on the client with this key a random string issued by the server</b> <br><blockquote>  <font color="black">...</font> <font color="black"><br></font>  <font color="black">unsigned <font color="#0000ff">long</font> i;</font> <font color="black"><br></font>  <font color="black">unsigned <font color="#0000ff">char</font> * x;</font> <font color="black"><br></font>  <font color="black">unsigned <font color="#0000ff">char</font> buf [1024] = {0};</font> <font color="black"><br><br></font>  <font color="black"><font color="#008000">// Sign the line with the key.</font></font>  <font color="black"><font color="#008000">key - read and decoded key from item 1.</font></font>  <font color="black"><font color="#008000">s - rendome line.</font></font> <font color="black"><br></font>  <font color="black">ECDSA_SIG * sig = ECDSA_do_sign (s.c_str (), s.Length (), key);</font> <font color="black"><br><br></font>  <font color="black">x = buf;</font> <font color="black"><br></font>  <font color="black">i = i2d_ECDSA_SIG (sig, &amp; x);</font>  <font color="black"><font color="#008000">// convert to binary form</font></font> <font color="black"><br></font>  <font color="black">x = buf;</font> <font color="black"><br></font>  <font color="black">ECDSA_SIG_free (sig);</font> <font color="black"><br></font>  <font color="black"><font color="#008000">// so that the signature can be copied - convert it to base64</font></font> <font color="black"><br></font>  <font color="black">BIO * b64 = BIO_new (BIO_f_base64 ());</font> <font color="black"><br></font>  <font color="black">BIO_set_flags (b64, BIO_FLAGS_BASE64_NO_NL);</font>  <font color="black"><font color="#008000">// no line breaks</font></font> <font color="black"><br></font>  <font color="black">BIO * mem = BIO_new (BIO_s_mem ());</font> <font color="black"><br></font>  <font color="black">mem = BIO_push (b64, mem);</font> <font color="black"><br></font>  <font color="black">BIO_write (mem, &amp; buf, i);</font> <font color="black"><br></font>  <font color="black">BIO_flush (mem);</font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">char</font> * res;</font> <font color="black"><br></font>  <font color="black">BIO_get_mem_data (mem, &amp; res);</font> <font color="black"><br></font>  <font color="black">mAnswer-&gt; Text = res;</font>  <font color="black">// output the result to the user.</font> </blockquote>  . <br><br>  <b>3) We check the signature</b> <br><blockquote>  <font color="black"><font color="#0000ff">int</font> ssl_VerifySignature ( <font color="#0000ff">const</font> <font color="#0000ff">char</font> * key, <font color="#0000ff">const</font> <font color="#0000ff">char</font> * str, <font color="#0000ff">const</font> <font color="#0000ff">char</font> * csig)</font> <font color="black"><br></font>  <font color="black">{</font> <font color="black"><br><br></font>  <font color="black">OpenSSL_add_all_algorithms ();</font> <font color="black"><br><br></font>  <font color="black">BIO * bkey = BIO_new (BIO_s_mem ());</font> <font color="black"><br></font>  <font color="black">BIO_write (bkey, key, ( <font color="#0000ff">int</font> ) strlen (key));</font> <font color="black"><br></font>  <font color="black">BIO_flush (bkey);</font> <font color="black"><br><br></font>  <font color="black">EC_KEY * ec = PEM_read_bio_EC_PUBKEY (bkey, NULL, NULL, NULL);</font>  <font color="black"><font color="#008000">// read the public key</font></font> <font color="black"><br></font>  <font color="black">BIO_free (bkey);</font> <font color="black"><br><br></font>  <font color="black"><font color="#0000ff">if</font> (! ec) <font color="#0000ff">return</font> -2;</font> <font color="black"><br><br></font>  <font color="black">unsigned <font color="#0000ff">long</font> i;</font> <font color="black"><br></font>  <font color="black">unsigned <font color="#0000ff">char</font> * x;</font> <font color="black"><br></font>  <font color="black">unsigned <font color="#0000ff">char</font> buf [1024] = {0};</font> <font color="black"><br><br></font>  <font color="black">BIO * b64 = BIO_new (BIO_f_base64 ());</font> <font color="black"><br></font>  <font color="black">BIO_set_flags (b64, BIO_FLAGS_BASE64_NO_NL);</font> <font color="black"><br></font>  <font color="black">BIO * mem = BIO_new (BIO_s_mem ());</font> <font color="black"><br></font>  <font color="black">BIO_write (mem, csig, ( <font color="#0000ff">int</font> ) strlen (csig));</font> <font color="black"><br></font>  <font color="black">mem = BIO_push (b64, mem);</font> <font color="black"><br></font>  <font color="black">x = buf;</font> <font color="black"><br></font>  <font color="black">i = BIO_read (mem, x, 1024);</font> <font color="black"><br></font>  <font color="black">x = buf;</font> <font color="black"><br><br></font>  <font color="black">ECDSA_SIG * sig = ECDSA_SIG_new ();</font> <font color="black"><br></font>  <font color="black">sig = d2i_ECDSA_SIG (&amp; sig, ( <font color="#0000ff">const</font> unsigned <font color="#0000ff">char</font> **) &amp; x, i);</font>  <font color="black"><font color="#008000">// read the signature</font></font> <font color="black"><br><br></font>  <font color="black">i = ECDSA_do_verify (( <font color="#0000ff">const</font> unsigned <font color="#0000ff">char</font> *) str, ( <font color="#0000ff">int</font> ) strlen (str), sig, ec);</font>  <font color="black"><font color="#008000">// check string signature</font></font> <font color="black"><br></font>  <font color="black">BIO_free_all (mem);</font> <font color="black"><br></font>  <font color="black">ECDSA_SIG_free (sig);</font> <font color="black"><br></font>  <font color="black"><font color="#0000ff">return</font> i;</font> <font color="black"><br></font>  <font color="black">}</font> </blockquote>  . <br><br>  Thus, even if the hacker gets access to the user's account, he will not be able to spend his money \ change password \ soap \ any other functions that you consider necessary to protect using this method. <br>  And if the key is stolen, then thanks to the password hashing cycle with salt 0x20000 (131072), even simple passwords will get stuck once. </div><p>Source: <a href="https://habr.com/ru/post/96116/">https://habr.com/ru/post/96116/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../96108/index.html">Qmmp: continued. Alternative Interfaces</a></li>
<li><a href="../96109/index.html">Fast download</a></li>
<li><a href="../9611/index.html">CSS Bugs. Errors during layout</a></li>
<li><a href="../96111/index.html">Hacked a number of Israeli sites</a></li>
<li><a href="../96115/index.html">About the demise of the old dirty Web or the Legend of the life-giving sensor</a></li>
<li><a href="../96117/index.html">A game without a player. Zero player game</a></li>
<li><a href="../9612/index.html">YouTube launches the promise.</a></li>
<li><a href="../96122/index.html">Comparing OpenCL with CUDA, GLSL and OpenMP</a></li>
<li><a href="../96123/index.html">Autoruns goes offline and hits viruses</a></li>
<li><a href="../96126/index.html">QIWI-cheating</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>