<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Binary search trees and recursion are just</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many books and articles on this topic. In this article I will try to clearly explain the most basic. 

 A binary tree is a hierarchical data...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Binary search trees and recursion are just</h1><div class="post__text post__text-html js-mediator-article">  There are many books and articles on this topic.  In this article I will try to clearly explain the most basic. <br><br>  A binary tree is a hierarchical data structure in which each node has a value (it is also a key in this case) and references to the left and right descendant.  A node at the topmost level (which is not a descendant of anyone) is called a root.  Nodes that have no descendants (both descendants of which are NULL) are called leaves. <br><br><img src="https://habrastorage.org/files/772/ac8/a1e/772ac8a1ed9c4abb862c036a2113a196.png" alt="image"><br>  <i>Fig.</i>  <i>1 Binary tree</i> <br><a name="habracut"></a><br>  A binary search tree is a binary tree with additional properties: the value of the left child is less than the value of the parent, and the value of the right child is greater than the value of the parent for each node of the tree.  That is, data in a binary search tree is stored in sorted form.  Each time you insert a new or delete an existing node, the sorted order of the tree is preserved.  When searching for an element, the sought value is compared with the root.  If the desired is greater than the root, then the search continues in the right descendant of the root; if less, then in the left, if equal, then the value is found and the search is terminated. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/7f3/d02/51c/7f3d0251cd5f42e8a0a1f3aec41da199.png" alt="image"><br>  <i>Fig.</i>  <i>2 Binary search tree</i> <br>  A balanced binary search tree is a binary search tree with logarithmic height.  This definition is more ideological than strict.  Strict definition operates with the difference of the depth of the deepest and shallowest leaf (in AVL trees) or the ratio of the depth of the deepest and shallowest leaf (in red-black trees).  In a balanced binary search tree, search, insert and delete operations are performed in logarithmic time (since the path to any sheet from the root is no more than a logarithm).  In the degenerate case of an unbalanced binary search tree, for example, when a sorted sequence was inserted into an empty tree, the tree would turn into a linear list, and the search, insert and delete operations would be performed in linear time.  Therefore, balancing a tree is extremely important.  Technically, balancing is performed by turning parts of the tree when inserting a new element, if the insertion of this element violated the balance condition. <br><br><img src="https://habrastorage.org/files/826/c95/0ae/826c950ae33346b28fbc5d88505b6abb.png" alt="image"><br>  <i>Fig.</i>  <i>3 Balanced Binary Search Tree</i> <br><br>  A balanced binary search tree is used when you need to quickly search for items, alternating with inserts of new items and deletions of existing ones.  If the set of elements stored in the data structure is fixed and there are no new inserts and deletions, then the array is preferable.  Because the search can be performed by a binary search algorithm for the same logarithmic time, but there are no additional costs for storing and using pointers.  For example, in C ++, the associative containers set and map are a balanced binary search tree. <br><br><img src="https://habrastorage.org/files/d38/04f/b8e/d3804fb8e23947a796e679cbbb6d3614.png" alt="image"><br>  <i>Fig.</i>  <i>4 Extremely unbalanced binary search tree</i> <br><br>  Now briefly discuss recursion.  Recursion in programming is a function call to itself with other arguments.  In principle, a recursive function can call itself with the same arguments, but in this case there will be an infinite recursion cycle that will result in a stack overflow.  Inside any recursive function, there must be a base case in which the function exits, as well as a call or calls to itself with other arguments.  Arguments should not just be different, but should bring the function call to the base case.  For example, the call inside the recursive function of calculating factorial should come with a smaller argument, and calls within the recursive tree walk function should go with nodes farther from the root closer to the leaves.  Recursion can be not only direct (direct call itself), but also indirect.  For example, A calls B, and B calls A. Using recursion, you can emulate an iterative loop as well as the operation of a stack data structure (LIFO). <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">factorial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(n &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   { return 1; } return n * factorial(n - 1); //     } // factorial(1): return 1 // factorial(2): return 2 * factorial(1) (return 2 * 1) // factorial(3): return 3 * factorial(2) (return 3 * 2 * 1) // factorial(4): return 4 * factorial(3) (return 4 * 3 * 2 * 1) //    n (n    -  int //  .     long long   //   .        ,  //           //  ). void reverseBinary(int n) { if (n == 0) //   { return; } cout &lt;&lt; n%2; reverseBinary(n/2); //     } //        void forvardBinary(int n) { if (n == 0) //   { return; } forvardBinary(n/2); //     cout &lt;&lt; n%2; } //      //        //      void ReverseForvardBinary(int n) { if (n == 0) //   { return; } cout &lt;&lt; n%2; //     ReverseForvardBinary(n/2); //     cout &lt;&lt; n%2; //     } //        , //      int product(int x, int y) { if (y == 0) //   { return 0; } return (x + product(x, y-1)); //     } //    x * y (  xy ) //      , //     </span></span></code> </pre> <br>  Let's briefly discuss trees from the point of view of graph theory.  A graph is a set of vertices and edges.  An edge is a connection between two vertices.  The number of possible edges in a graph is quadratically dependent on the number of vertices (for understanding, you can submit a standings of played matches).  A tree is a connected graph without cycles.  Connectivity means that from any vertex to any other there is a path along the edges.  The absence of cycles means that this path is the only one.  Traversing a graph is a systematic visit to all its vertices once each.  There are two types of traversal graph: 1) search in depth;  2) search wide. <br><br>  The search in width (BFS) goes from the initial vertex, first visits all the vertices located at a distance of one edge from the initial one, then visits all the vertices at a distance of two edges from the initial one, and so on.  The width search algorithm is non-recursive (iterative) in nature.  For its implementation, the queue data structure (FIFO) is used. <br><br>  Depth-first search (DFS) goes from the initial vertex, visiting not yet visited vertices without regard for the distance from the initial vertex.  The depth-first search algorithm is recursive in nature.  To emulate recursion in an iterative version of the algorithm, the stack data structure is used. <br><br>  From a formal point of view, it is possible to make both a recursive and an iterative version of both search in width and search in depth.  To bypass the width in both cases, a queue is needed.  Recursion in a recursive wide bypass implementation only emulates a loop.  To crawl into depth, there is a recursive implementation without a stack, a recursive implementation with a stack, and an iterative implementation with a stack.  Iterative implementation of a detour in depth without a stack is impossible. <br><br>  The asymptotic complexity of traversal is both in width and in depth O (V + E), where V is the number of vertices, E is the number of edges.  That is, it is linear in the number of vertices and edges.  From the substantive point of view, the O (V + E) record is equivalent to the O (max (V, E)) record, but the latter is not accepted.  That is, the complexity will be determined by the maximum of two values.  Despite the fact that the number of edges depends quadratically on the number of vertices, we cannot write the complexity as O (E), since if the graph is highly sparse, this will be an error. <br><br>  DFS is used in the algorithm for finding strong connected components in a directed graph.  BFS is used to find the shortest path in the graph, in the algorithms for sending messages over the network, in garbage collectors, in the indexing program - in the search engine spider.  Both DFS and BFS are used in the algorithm for the search for the minimum spanning tree, when checking cycles in a graph, to check for duplicity. <br>  A width walk in the graph corresponds to a walk through the levels of a binary tree.  With this bypass, there is a visit to the nodes on the principle from top to bottom and from left to right.  Three types of binary tree traversal correspond to depth traversal in a graph: direct (pre-order), symmetrical (in-order) and reverse (post-order). <br><br>  The direct round goes in the following order: root, left descendant, right descendant.  Symmetrical - left descendant, root, right descendant.  Reverse - left descendant, right descendant, root.  In the code of the recursive function of the corresponding traversal, the corresponding order of calls is retained (the order of the lines of code), where instead of the root there is a call of the given recursive function. <br><br>  If we are given an image of a tree, and we need to find its rounds, then the following technique can help (see. Fig. 5).  We circle the tree of the envelope of a closed curve (we start to go left down and close right up).  Direct traversal will correspond to the order in which the envelope, moving from the root for the first time, passes next to the nodes to the left.  For symmetric traversal, the order in which the envelope, moving from the root for the first time, passes next to the nodes below.  For the reverse traversal, the order in which the envelope, moving from the root, first passes next to the nodes to the right.  In the code of the recursive call, the direct bypass goes: call, left, right.  Symmetric - left, call, right.  Reverse - left right, call. <br><br><img src="http://habrastorage.org/files/654/015/a63/654015a637ab473cbbe11a1adcc993c5.png" alt="image"><br>  <i>Fig.</i>  <i>5 Auxiliary pattern for crawling</i> <br><br>  For binary search trees, symmetric traversal traverses all nodes in sorted order.  If we want to visit the nodes in reverse sorted order, then in the code of the recursive function of the symmetric traversal, we should swap the left and right children. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeNode</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> data; <span class="hljs-comment"><span class="hljs-comment">// / TreeNode *left; //     TreeNode *right; //     }; void levelOrderPrint(TreeNode *root) { if (root == NULL) { return; } queue&lt;TreeNode *&gt; q; //   q.push(root); //     while (!q.empty() ) //     { TreeNode* temp = q.front(); //      q.pop(); //      cout &lt;&lt; temp-&gt;data &lt;&lt; " "; //       if ( temp-&gt;left != NULL ) q.push(temp-&gt;left); //      if ( temp-&gt;right != NULL ) q.push(temp-&gt;right); //      } } void preorderPrint(TreeNode *root) { if (root == NULL) //   { return; } cout &lt;&lt; root-&gt;data &lt;&lt; " "; preorderPrint(root-&gt;left); //    preorderPrint(root-&gt;right); //    } //         . //          //    void inorderPrint(TreeNode *root) { if (root == NULL) //   { return; } preorderPrint(root-&gt;left); //    cout &lt;&lt; root-&gt;data &lt;&lt; " "; preorderPrint(root-&gt;right); //    } //         . //      void postorderPrint(TreeNode *root) { if (root == NULL) //   { return; } preorderPrint(root-&gt;left); //    preorderPrint(root-&gt;right); //    cout &lt;&lt; root-&gt;data &lt;&lt; " "; } //         . //      ( ). void reverseInorderPrint(TreeNode *root) { if (root == NULL) //   { return; } preorderPrint(root-&gt;right); //    cout &lt;&lt; root-&gt;data &lt;&lt; " "; preorderPrint(root-&gt;left); //    } //          . //       void iterativePreorder(TreeNode *root) { if (root == NULL) { return; } stack&lt;TreeNode *&gt; s; //   s.push(root); //     /*        .      1)   2)    !  (!      !) 3)    !  */ while (s.empty() == false) { //      TreeNode *temp = s.top(); s.pop(); cout &lt;&lt; temp-&gt;data &lt;&lt; " "; if (temp-&gt;right) s.push(temp-&gt;right); //      if (temp-&gt;left) s.push(temp-&gt;left); //      } } //          //      .</span></span></code> </pre><br>  I hope you did not fall asleep, and the article was useful.  Soon I hope to follow the continuation of the <s>banquet of the</s> article. </div><p>Source: <a href="https://habr.com/ru/post/267855/">https://habr.com/ru/post/267855/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267845/index.html">Automation of development in ZeptoLab</a></li>
<li><a href="../267847/index.html">How do we do without 1C?</a></li>
<li><a href="../267849/index.html">September 29, we invite you to view AzureCon and meet with experts at Microsoft Technology Center</a></li>
<li><a href="../267851/index.html">Transparent Squid with HTTPS filtering resources without certificate substitution (x86)</a></li>
<li><a href="../267853/index.html">AMD and Hyper-Threading</a></li>
<li><a href="../267857/index.html">Moscow CocoaHeads October 2</a></li>
<li><a href="../267859/index.html">Fiber optic communication cables. How it's done</a></li>
<li><a href="../267865/index.html">Paul Graham: "Revenge of the nerds", part 1</a></li>
<li><a href="../267871/index.html">Drone dodging probe: Expose the sensation</a></li>
<li><a href="../267873/index.html">Attempt to implement universal parser online stores using SlimerJS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>