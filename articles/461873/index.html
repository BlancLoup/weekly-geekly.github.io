<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ViewPager 2 - new functionality in the old wrapper</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ViewPager is one of the most famous and widely used components of the Android Support Library. All the simplest carousels, onboardings and sliders are...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ViewPager 2 - new functionality in the old wrapper</h1><div class="post__text post__text-html js-mediator-article">  ViewPager is one of the most famous and widely used components of the Android Support Library.  All the simplest carousels, onboardings and sliders are made on it.  In February 2019, the AndroidX development team released ViewPager2.  Let's look at what these prerequisites were and what advantages the updated version of the component has. <br><br><img src="https://habrastorage.org/webt/eu/aw/ss/euawsscpwdgkcngbjdjqabx1uhc.png"><br><a name="habracut"></a><br><h3>  ViewPager 2 </h3><br>  At the time of writing this post (July 2019), a beta version of <a href="https://developer.android.com/jetpack/androidx/releases/viewpager2">ViewPager2 is available</a> , which means that the problems mentioned below can be fixed and the functionality improved and expanded.  The developers promise in the future to add support for TabLayout (while it can only work with the first version), optimize the adapter‚Äôs performance, make many minor corrections and finalize the documentation. <br><br><h3>  Integration </h3><br>  The component is not supplied with standard packages, but is connected separately.  To do this, add the following line to the dependencies block in your module‚Äôs gradle script: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="java hljs">implementation <span class="hljs-string"><span class="hljs-string">"androidx.viewpager2:viewpager2:1.0.0-beta02"</span></span></code> </pre> <br><h3>  Implementation </h3><br>  Let's start with the good news: the transition from the first to the second version is as simple as possible and boils down to a change in imports.  The good old syntax was not touched: the <i>getCurrentItem ()</i> method returns the current page, <i>ViewPager2.onPageChangeCallback</i> allows <i>you</i> to subscribe to the pager <i>state</i> , the adapter is still installed via <i>setAdapter ().</i> <br><br><hr><br>  It is worth digging deeper, as it becomes clear that the first and second pagers have nothing in common except interfaces.  Familiarity with the implementation of the setAdapter () method leaves no room for doubt: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Adapter adapter)</span></span></span><span class="hljs-function"> </span></span>{ mRecyclerView.setAdapter(adapter); }</code> </pre><br>  Yes, ViewPager2 is just a wrapper over <b>RecyclerView</b> .  On the one hand, this is a big plus, on the other - it adds a headache.  Disguising <i>RecyclerView</i> as a leaflet became possible with the advent of <b>PagerSnapHelper</b> .  This class changes the physics of scroll.  When the user releases his finger, <i>PagerSnapHelper</i> calculates which element of the list is closest to the centerline of the list, and with smooth animation aligns it exactly in the center.  Thus, if the swipe was sharp enough, the list scrolls to the next element, otherwise - with the animation returns to its original state. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PagerSnapHelper().attachToRecyclerView(mRecyclerView);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/737/962/b7a/737962b7a5620216a2a6d0c71353a2a1.gif" alt="image"><br><blockquote>  When using PagerSnapHelper, make sure that the width and height of the RecyclerView itself, as well as all its ViewHolders, are set to MATCH_PARENT.  Otherwise, the behavior of SnapHelper will be unpredictable, bugs may occur in completely unexpected places.  All this makes the creation of a carousel of elements of small height rather time-consuming, although possible. </blockquote><br>  Given all of the above, in the layout the widget will look like this: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">androidx.viewpager2.widget.ViewPager2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@+id/main_pager"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  In the same package as <i>ViewPager2,</i> we can also find the <b>ScrollEventAdapter</b> class, which helps maintain syntax continuity.  <i>ScrollEventAdapter</i> implements <b>RecyclerView.OnScrollListener</b> and transforms scroll events <b>into OnPageChangeCallback</b> events. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrollStateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull RecyclerView recyclerView, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG &amp;&amp; newState == RecyclerView.SCROLL_STATE_DRAGGING) { ... dispatchStateChanged(SCROLL_STATE_DRAGGING); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... }</code> </pre><br>  Now <i>OnPageChangeCallback</i> is represented not by an interface, but by an abstract class, which allows you to override only the necessary methods (in most cases, you only need o <i>nPageSelected (Int)</i> , which works when a specific page is selected): <br><br><pre> <code class="java hljs">main_pager.registerOnPageChangeCallback( object : ViewPager2.OnPageChangeCallback() { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPageSelected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: Int)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//do your stuff } } )</span></span></code> </pre><br><h3>  Features </h3><br>  <b>Noteworthy is the setPageTransformer ()</b> method, which takes <b>ViewPager2.PageTransformer</b> as a parameter.  It sets a <i>callback</i> for each page selection event and serves to set its own animation for this page.  <i>Callback</i> receives the <i>View of the</i> current page and its number as input.  The closest analogue to this method is the <i>ItemAnimator</i> from <i>RecyclerView</i> . <br><br>  In new versions of the library, two implementations of the transformer were added: <br><br>  <b>CompositePageTransformer</b> and <b>MarginPageTransformer</b> .  The first is responsible for combining transformers in order to apply several transformations to one pager at once, and the second for indenting between pages: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53d/c0d/49b/53dc0d49b39527079355f55a5c5cf4e0.gif" alt="image"><br><br>  In addition, the new widget supports orientation changes: by simply calling the <b>setOrientation ()</b> method, you can turn your pager into a vertical list with swipes from top to bottom: <br><br><pre> <code class="kotlin hljs">main_pager.setOrientation(ViewPager2.ORIENTATION_VERTICAL)</code> </pre><br>  This happens again due to the transition to the <i>RecyclerView</i> : under the hood, a change of orientation of the <i>LayoutManager is called</i> , which is responsible for displaying the list items.  It should be noted that delegating a large number of tasks to other classes has benefited the new component: its listing has become much more compact and readable. <br><br>  This is not the end of the fun.  In one update, <i>ViewPager2</i> received support for <i>ItemDecoration</i> : a <i>helper</i> class for decorating child <i>View</i> .  This mechanism can be used to draw separators between elements, borders, cell highlighting. <br><br>  There are already a lot of ready-made implementations of decorators, because for many years they have been successfully used when working with the usual <i>RecyclerView</i> .  All developments are now applicable to pagers.  Out of the box, a standard implementation of pager element separators is available: <br><br><pre> <code class="kotlin hljs">main_pager.addItemDecoration( DividerItemDecoration(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, RecyclerView.HORIZONTAL) )</code> </pre><br>  Along with the next update in May 2019, <i>ViewPager2</i> added another important method: <b>setOffscreenPageLimit (Int)</b> .  He is responsible for how many elements to the right and left of the central will be initialized in the pager.  Although <i>RecyclerView</i> is responsible for caching and displaying the <i>View by</i> default, using this method you can explicitly set the desired number of items to load. <br><br><h3>  Adapter </h3><br>  The ideological successor of the first pager adapter is the <i>FragmentStateAdapter</i> : the interaction interfaces and class naming are almost the same.  The changes affected only the naming of some methods.  If earlier it was necessary to implement the abstract function <i>getItem (position)</i> to return the desired <i>Fragment</i> instance for the given position, and this naming could be interpreted in two ways, now this function has been renamed to <i>createFragment (position)</i> .  The total number of fragments is supplied as before by the <i>getCount ()</i> function. <br><br>  Of the important structural changes to the interface, it should also be noted that the adapter now has the ability to control the life cycle of its elements, therefore, together with the <i>FragmentManager</i> in the constructor, it accepts a <i>Lifecycle object</i> , either an <i>Activity</i> or a <i>Fragment</i> .  Because of this, for security, the <i>saveState ()</i> and <i>restoreState ()</i> methods were declared final, and closed to inheritance. <br>  The <b>FragmentViewHolder</b> class is responsible for storing fragments inside the <i>RecyclerView</i> .  The <b>onCreateViewHolder ()</b> method of <b>FragmentStateAdapter</b> calls <b>FragmentViewHolder.create ()</b> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FragmentViewHolder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewGroup parent)</span></span></span><span class="hljs-function"> </span></span>{ FrameLayout container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(parent.getContext()); container.setLayoutParams( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) ); container.setId(ViewCompat.generateViewId()); container.setSaveEnabled(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FragmentViewHolder(container); }</code> </pre><br>  When the <b>onBindViewHolder ()</b> method is <b>called</b> , the identifier of the element at the current position and the <i>ViewHolder</i> identifier are <i>associated</i> , to further attach the fragment to it: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> itemId = holder.getItemId(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> viewHolderId = holder.getContainer().getId(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long boundItemId = itemForViewHolder(viewHolderId); ... mItemIdToViewHolder.put(itemId, viewHolderId); ensureFragment(position); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  And finally, when attaching a container from the <i>ViewHolder</i> to the <i>View</i> hierarchy, a <i>FragmentTransaction</i> is executed, adding a <i>Fragment</i> to the container: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">placeFragmentInViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FragmentViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ Fragment fragment = mFragments.get(holder.getItemId()); ... scheduleViewAttach(fragment, container); mFragmentManager.beginTransaction() .add(fragment, <span class="hljs-string"><span class="hljs-string">"f"</span></span> + holder.getItemId()) .setMaxLifecycle(fragment, STARTED) .commitNow(); ... }</code> </pre><br>  Thus, two uses of <i>ViewPager2 emerge</i> : through the inheritance of the adapter class, either directly from <i>RecyclerView.Adapter</i> , or from <i>FragmentStateAdapter</i> . <br><br><hr><br>  Surely you will have a question: why use a second pager with Fragments and an adapter for them when there is a normally functioning first version?  <i>ViewPager</i> is far from a "silver bullet" when working with large dynamic data lists.  It is great for creating carousels with a static set of pictures or banners, but paginated news feeds with loading advertising posts, filtering give birth to hard-supported and ugly monsters.  Sooner or later, you will surely come across a burning desire to rewrite everything on <i>RecyclerView</i> .  Now you don‚Äôt have to do this, because the pager itself turned into it, borrowing its powerful capabilities for working with dynamic lists, while wrapping them in the usual syntax. <br><br>  The only thing the <i>PagerAdapter</i> can offer <i>us</i> is the <b>notifyDataSetChanged ()</b> method, which forces the <i>ViewPager to</i> redraw all rendered list items.  You may reasonably notice that no one is stopping us from storing a list of positions for existing elements and returning <i>POSITION_UNCHANGED</i> from the <i>getItemPosition ()</i> method for them, that's it.  However, this solution cannot be called beautiful, it is rather cumbersome, moreover, it is difficult to extend to those cases when the elements in the list are constantly changing, and not only sequentially added to the end.  <i>FragmentStateAdapter</i> has a full arsenal of <i>RecyclerView.Adapter</i> methods, so the logic of redrawing elements can be configured much more flexibly.  Moreover, together with the <i>FragmentStateAdapter,</i> you can use <i>DiffUtil</i> , which allows you to almost completely automate the work of notification of changes. <br><br><img src="https://habrastorage.org/webt/8s/j9/xg/8sj9xgon6lnfcn1thlzbhox2jtw.png"><br><blockquote>  <b>Attention!</b>  For the <i>notify</i> ... methods to work correctly (except for <i>notifyDataSetChanged</i> ), the <b>getItemId (Int)</b> and c <b>ontainsItem (Long)</b> methods should be redefined.  This is done because the default implementation looks only at the page number, and if, for example, you add a new element after the current one, it will not be added, since <i>getItemId</i> will remain unchanged.  An example of overriding these two methods based on a list of elements of type <i>Int</i> : </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[position].toLong() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(itemId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.contains(itemId.toInt()) }</code> </pre><br><hr><br>  The main reason for the appearance of <i>ViewPager2</i> is the reluctance to reinvent the wheel.  On the one hand, the <b>AndroidX</b> development <b>team is</b> clearly ready to abandon the obsolete <i>ViewPager</i> now and is certainly not going to invest in expanding its functionality.  Yes, and why?  After all, <i>RecyclerView</i> already knows everything that is needed.  On the other hand, removing and discontinuing support for such a widely used component will clearly not add community loyalty. <br><br>  To summarize: <i>ViewPager2 is</i> definitely worthy of attention, although at the moment it is not without serious flaws. <br><br><h3>  Minuses </h3><br><ul><li>  Dampness and a large number of bugs (excusable for beta); </li><li>  Closeness.  <i>RecyclerView</i> is a <i>private</i> field of <i>ViewPager2</i> , which deprives us of many possibilities: it is impossible to implement <i>swipe-to-dismiss</i> or <i>drag-n-drop</i> ( <b>ItemTouchHelper</b> connects directly to <i>RecyclerView</i> ), you can not redefine <b>ItemAnimator</b> in any way, do not access <b>LayoutManager</b> directly and use <b>RecycledViewPool</b> .  However, with the release of new versions of the component, the number of interface methods inherited from <i>RecyclerView</i> is growing (for example, <i>ItemDecoration</i> ), and we can hope to add the missing methods in the future. </li></ul><br><h3>  pros </h3><br><ul><li>  Support for all the advantages of <i>RecyclerView.Adapter</i> : combining elements of different types in one list, adding and removing elements directly during swipe, animated redrawing of the contents of the list when changing; </li><li>  Support for the full spectrum of <i>notify</i> ... methods and automatic calculation of changes using <i>DiffUtil</i> ; </li><li>  Ease of transition due to the continuity of syntax; </li><li>  Support for vertical and horizontal orientation "out of the box"; </li><li>  <i>RTL</i> support; </li><li>  Support <i>ItemDecorator</i> ; </li><li>  Support for software <i>scrolling</i> through <i>fakeScrollBy ()</i> ; </li><li>  Ability to manually set the number of loaded items; </li><li>  The ability to use any of the ready-made open-source solutions to reduce <i>boilerplate code</i> , which is inevitable when writing custom <i>RecyclerView.Adapter</i> .  For example, <a href="https://github.com/surfstudio/EasyAdapter/"><i>EasyAdapter</i></a> . </li></ul><br>  As a summary, I want to say that <b>ViewPager2 is</b> really worth a <b>closer</b> look.  This is a promising, extensible, and functional solution.  And although it is still too early to launch a <i>new widget</i> in production, it is safe to say that after a full release it can and should completely supplant its ancestor. <br><br>  For those daring and decisive, whom the article inspired to experiment, <i>PagerSnapHelper</i> appeared in the 28th version of the <b>Support Library</b> , which means that you can use it together with your <i>RecyclerView</i> by creating <i>ViewPager2 yourself</i> . <br><br>  <a href="https://github.com/surfstudio/ViewPager2-Sample/tree/%25231-fragmentadapter-sample">The sample</a> operation <i>ViewPager2</i> and <i>FragmentStateAdapter</i> . <br><br>  Official <a href="https://developer.android.com/jetpack/androidx/releases/viewpager2">release-notes</a> ViewPager2 </div><p>Source: <a href="https://habr.com/ru/post/461873/">https://habr.com/ru/post/461873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461863/index.html">How Chinese Mpow Headphones Bestseller on Amazon: Getting to Know the Brand</a></li>
<li><a href="../461865/index.html">Video course ‚ÄúIntroduction to reversing from scratch using IDA PRO. Chapter 1"</a></li>
<li><a href="../461867/index.html">How to recognize pictures and texts on your phone using ML Kit</a></li>
<li><a href="../46187/index.html">"Classmates" have become a partner of "Runner"</a></li>
<li><a href="../461871/index.html">101 tips for becoming a good programmer (and human)</a></li>
<li><a href="../461875/index.html">5 nm vs 3 nm</a></li>
<li><a href="../461877/index.html">Java vs Kotlin for Android: developer opinions</a></li>
<li><a href="../461879/index.html">The book "Linux in action"</a></li>
<li><a href="../46188/index.html">Large HDD</a></li>
<li><a href="../461881/index.html">Node.js Logging Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>