<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pubcookie: Single Point of Authentication for Web Applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many solutions to implement Single Sign On technology in one form or another. By single sign-on is understood the situation when having auth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pubcookie: Single Point of Authentication for Web Applications</h1><div class="post__text post__text-html js-mediator-article"> There are many solutions to implement Single Sign On technology in one form or another.  By single sign-on is understood the situation when having authorized once on some dedicated authorization server (or just on your own machine), you get access to all available network resources without additional authorization. <br><br>  We are now gradually engaged in refactoring our internal intranet services, which have often developed spontaneously, and are considering various technologies, the use of which can make our internal infrastructure more convenient and safer. <br><br>  SSO technologies, as a rule, are rather complicated, but if you limit yourself to single-sign-on for a set of web applications only, there is a relatively simple solution that allows you to implement this feature without changing or slightly changing the application code.  This decision is called <a href="http://www.pubcookie.org/">Pubcookie</a> , and it will be discussed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  If we use Pubcookie, then when entering a protected resource, we will automatically be redirected to a special dedicated login server, on which we will log in and automatically return back.  At the same time, we do not need to change anything in the protected application, it <code>REMOTE_USER</code> receives the name of the current user from <code>REMOTE_USER</code> . <br><br>  Let's see how you can configure this mechanism. <br><br>  <b>Scheme of work</b> <br><br>  The authentication process involves the following components: <br><br><ol><li>  Client browser; </li><li>  The application server on which the application requiring authentication is deployed, in our case, it is Apache with the Pubookie module and, in fact, the protected application; </li><li>  The login server, in our case, is again Apache with a standard authentication application and our settings for this application; </li><li>  Actually, the authentication service. </li></ol><br><br>  <b>Authentication is as follows:</b> <br><br><ol><li>  A user browser requests a specific resource from an application server configured to use Pubcookie. </li><li>  The Pubcookie module installed on the application server intercepts the request and checks that it is not associated with a valid current session and does not contain information from the login server (the so-called granting cookie) to create a new session. <br>  In case of successful verification, the module generates a response containing a redirect and two cookies: a presession cookie for the application and a granting request cookie for the login server. Both cookies contain, among other information, a random number generated by the module.  All cookies are transmitted in encrypted form. </li><li>  The client browser redirects (granting request) to the login server with the granting request cookie sent to it.  The request data allows the access server to determine the application server for which authentication is requested, the URL of the original request, the type of authorization, etc. </li><li>  The login server decodes the granting request cookie and interprets the content.  The server generates the login form and sends it to the client. </li><li>  The user enters his login and password into the form and sends it to the login server; </li><li>  The login server receives the login and password and sends them to the authentication service used for verification. </li><li>  The login server receives the verification result from the authentication service. </li><li>  If the check is successful, the login server generates a response containing a redirect and two new cookies.  The first, granting cookie, is intended for the application server and contains a verified username and additional information, including a random number generated in clause 2, signed with the private key of the access server and encrypted with the symmetric key used on the application server and the access server.  The second one, login cookie, is intended for the login server and is used in the event of subsequent user visits to it. </li><li>  The user browser re-requests the protected resource from the application server.  The request contains a granting cookie and a presession cookie. </li><li>  The pubcookie module on the application server intercepts the request, decrypts the granting cookie, checks the signature and compares the random number in the granting cookie with the same number in the presession cookie.  If everything converges, the username is passed to the application and the request is processed by the application.  This also generates a session cookie, for subsequent access to protected resources.  The response generated by the application is sent to the user. </li></ol><br><br>  If, in step 4, granting request also contains a valid login cookie (set in step 8), steps 5, 6 and 7 are skipped and the login server proceeds directly to step 8, generating a granting cookie using the username obtained from the login cookie.  Thus, we get a Single Sign On technology element for a set of web applications: no need to log in for each web application, just enter your login and password once. <br><br>  <b>Assembly</b> <br><br>  We will consider for Ubuntu, under FreeBSD also does not cause problems: <br><br>  Download the distribution from <a href="http://www.pubcookie.org/">www.pubcookie.org</a> .  Before building, we make two patches: <br><br>  1. Patches configure for a problem with APXS: <br><br><pre> <code class="hljs perl"><span class="hljs-number"><span class="hljs-number">3783</span></span>c3783 &lt; APACHE_PREFIX=<span class="hljs-string"><span class="hljs-string">`$APXS -q PREFIX`</span></span> --- &gt; APACHE_PREFIX=<span class="hljs-string"><span class="hljs-string">"/usr/share/apache2"</span></span></code> </pre><br><br>  Here by the method of striking with a hammer, it is possible and correct, probably, to do. <br><br>  2. Patches src / index.cgi.c for UTF-8 encoding: <br><br><pre> <code class="hljs lisp"><span class="hljs-number"><span class="hljs-number">461</span></span>c461 &lt; print_header (<span class="hljs-name"><span class="hljs-name">p</span></span>, <span class="hljs-string"><span class="hljs-string">"Content-Type: text/html; charset=ISO-8859-1\n"</span></span>)<span class="hljs-comment"><span class="hljs-comment">; --- &gt; print_header (p, "Content-Type: text/html; charset=utf-8\n");</span></span></code> </pre><br><br>  When configuring, we point out the assembly of the module and cgi-applications to enter: <br><br><pre> <code class="hljs javascript">$./configure --enable-apache --<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-apxs=<span class="hljs-regexp"><span class="hljs-regexp">/usr/</span></span>bin/apxs2 --enable-login</code> </pre><br><br>  Then we collect, preferably in the deb-package. <br><br>  <b>Generating keys and certificates</b> <br><br>  Https is used to work with protected resources.  Well, then they are protected. <br><br>  We generate two pairs of keys. <br><br>  The first is the SSL key pair, used by the Apache for SSL and the key server (see below): <br><br><pre> <code class="hljs pgsql">$ openssl req -<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> -x509 -<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.crt -newkey rsa:<span class="hljs-number"><span class="hljs-number">1024</span></span> -nodes -keyout <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.key</code> </pre><br><br>  The second is the granting key pair, for signing and verifying granting cookies: <br><br><pre> <code class="hljs cs">$ openssl req -<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> -x509 -<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> granting.crt -newkey rsa:<span class="hljs-number"><span class="hljs-number">1024</span></span> -nodes -keyout granting.key</code> </pre><br><br>  An example of a purely demonstration, we use self-signed certificates, in reality it's more complicated.  Accordingly, we generate a toy CA bundle: <br><br><pre> <code class="hljs pgsql">$ cp <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.crt ca-bundle.crt</code> </pre><br><br>  As a result, we get the files: server.crt, server.key, granting.crt, granting.key, ca-bundle.crt. <br><br>  Setting the login server <br><br>  Let the server be called access.techart.intranet <br><br>  The access server runs a key server and an authentication application managed by a web server. <br><br>  The key server distributes symmetric keys used to encrypt the contents of cookies.  It runs under xinetd, respectively, we write it there: <br><br><pre> <code class="hljs pgsql">service keyserver { <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = UNLISTED protocol = tcp port = <span class="hljs-number"><span class="hljs-number">2222</span></span> <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> socket_type = stream wait = <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = root <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> = tty <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> = /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keyserver }</code> </pre><br><br>  After restarting xinetd server is available on port 2222. <br><br>  The authentication application is a regular CGI application that should be accessible via https.  Accordingly, it is necessary to configure a virtual host for it: <br><br><pre> <code class="hljs pgsql">&lt;VirtualHost *:<span class="hljs-number"><span class="hljs-number">443</span></span>&gt; ServerName <span class="hljs-keyword"><span class="hljs-keyword">login</span></span>.techart.intranet DocumentRoot /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/<span class="hljs-keyword"><span class="hljs-keyword">login</span></span> DirectoryIndex <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.cgi AddHandler cgi-script cgi &lt;Directory /&gt; <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span> FoolowSymLinks <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span> +ExecCGI AllowOverride <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> &lt;/Directory&gt; SSLEngine <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> SSLCertificateFile /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.crt SSLCertificateKeyFile /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.key &lt;/VirtualHost&gt;</code> </pre><br><br>  It remains to configure pubcookie.  Edit the file / usr / local / pubcookie / config: <br><br><pre> <code class="hljs pgsql">#    logging_level: <span class="hljs-number"><span class="hljs-number">1</span></span> #   . #        auth.php, #     . basic_verifier: verify_fork verify_exe: /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/auth.php #   SSL ssl_key_file: /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.key ssl_cert_file: /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.crt #  granting  granting_key_file: /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/granting.key granting_cert_file: /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/granting.crt # - (CGI) login_uri: https://<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.techart.intranet/ login_host: <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.techart.intranet enterprise_domain: .techart.intranet logout_prog: /logout/<span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.cgi #   keymgt_uri: localhost:<span class="hljs-number"><span class="hljs-number">2222</span></span> ssl_ca_file: /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/ca-bundle.crt #    default_l_expire: <span class="hljs-number"><span class="hljs-number">8</span></span>h #   -,  ,    . app_logout_string-app1.techart.intranet-app1:   app1</code> </pre><br><br>  In this example, we use the verify_fork mode, when an arbitrary external program is returned as the authentication service, which returns a normal or erroneous exit code depending on whether the user has been identified.  At the same time, the program reads the user name and password from stdin. <br><br>  In our case, this is a php script that can, for example, access a database or a text file, while other modes are supported, for example, working with LDAP and Kerberos. <br><br>  Now we generate a key that allows the login server to connect to the key server: <br><br><pre> <code class="hljs pgsql">$ sudo keyclient -P <span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.techart.intranet</code> </pre><br><br>  The generated key will be recorded in <code>keys/access.techart.intranet</code> .  This operation must be performed for each host using Pubcookie. <br><br>  After performing all these manipulations at <a href="http://access.techart.intranet/">access.techart.intranet,</a> we should see the login form. <br><br>  <b>Setting up an application server.</b> <br><br>  On the application server, we configure the pubcookie configuration file in the same way as on the access server.  In addition, it is necessary to connect the mod_pubcookie module to Apache. <br><br>  To do this, create the file <code>/etc/apache2/mods-available/pubcookie.conf</code> : <br><br><pre> <code class="hljs perl">PubcookieGrantingCertFile /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/<span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>/granting.crt PubcookieSessionKeyFile /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/<span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>/server.key PubcookieSessionCertFile /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/<span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>/server.crt PubcookieKeyDir /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/<span class="hljs-keyword"><span class="hljs-keyword">keys</span></span>/ PubcookieLogin https:<span class="hljs-regexp"><span class="hljs-regexp">//access</span></span>.techart.intranet/ PubcookieLoginMethod POST PubcookieDomain .techart.intranet PubcookieEncryption AES PubcookieAuthTypeNames EGNetID</code> </pre><br><br>  Then everything is as usual: <br><br><pre> <code class="hljs pgsql">/etc/apache2/mods-available/pubcookie.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>: LoadModule pubcookie_module /usr/lib/apache2/modules/mod_pubcookie.so $ sudo a2enmod pubcookie $ sudo service <span class="hljs-keyword"><span class="hljs-keyword">restart</span></span> apache2</code> </pre><br><br>  Now we set up the application itself: <br><br><pre> <code class="hljs pgsql">&lt;VirtualHost *:<span class="hljs-number"><span class="hljs-number">443</span></span>&gt; ServerName app1.techart.intranet &lt;Directory /srv/http/app1&gt; AuthType EGNetID require <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> PubcookieAppID app1 <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span> Indexes FollowSymLinks MultiViews AllowOverride <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> AllowOverride AuthConfig <span class="hljs-keyword"><span class="hljs-keyword">Order</span></span> allow,deny allow <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> &lt;/Directory&gt; SSLEngine <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> SSLCertificateFile /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.cert SSLCertificateKeyFile /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/pubcookie/keys/<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.key &lt;/VirtualHost&gt;</code> </pre><br><br>  In this case, we closed access to the entire application, however, we could specify authentication options for a particular subdirectory, put them in <code>.htaccess</code> , etc. <br><br>  Setting the <code>AllowOverride AuthConfig</code> allows an application to get the current user name from REMOTE_USER. <br><br>  We restart Apache, and if everything went fine, then when entering <a href="https://app1.techart.intranet/">app1.techart.intranet,</a> we should be redirected to <a href="https://login.techart.intranet/">login.techart.intranet</a> , where we log in and automatically return back. <br><br>  <b>Virtual hosts</b> <br><br>  All of the above works for virtual hosts bound to a dedicated IP.  To work with name-based virtual hosts, <a href="httpd/NameBasedSSLVHostsWithSNI">SNI support is</a> required in OpenSSL (from version 0.9.8j) and in Apache (since 2.2.12).  In addition, SNI is not supported for IE versions below 7. <br><br>  For this configuration, the Common Name field should contain a list of used hosts.  Edit openssl.cnf and re-generate a set of keys. <br><br><pre> <code class="hljs delphi">[req_distinguished_name] <span class="hljs-number"><span class="hljs-number">0</span></span>.commonName = Common <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> (eg, YOUR <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span>.commonName_default = app1.techart.intranet <span class="hljs-number"><span class="hljs-number">0</span></span>.commonName_max = <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>.commonName = Common <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> (eg, YOUR <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) <span class="hljs-number"><span class="hljs-number">1</span></span>.commonName_default = app2.techart.intranet <span class="hljs-number"><span class="hljs-number">1</span></span>.commonName_max = <span class="hljs-number"><span class="hljs-number">64</span></span> ...</code> </pre><br><br>  In the description of the virtual host in Apache we register: <br><br><pre> <code class="hljs pgsql">SLCipherSuite HIGH SSLProtocol <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> -SSLv2</code> </pre><br><br>  and restart apache. <br><br>  <b>Configure the access server user interface</b> <br><br>  The appearance of the login form and service pages of the login server can be <a href="http://www.pubcookie.org/docs/templates.html">configured using templates</a> that are located in the login_templates directory.  To use UTF-8 you need to patch <code>index.cgi.c</code> . <br><br>  <b>Logout setup</b> <br><br>  Session closure can be performed both in a separate application and on the login server.  The easiest way to do this on the login server is to create a <code>logout</code> subdirectory with <code>.htaccess</code> containing a single directive: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">PubcookieEndSession</span></span> <span class="hljs-literal"><span class="hljs-literal">redirect</span></span></code> </pre><br><br>  <b>Total</b> <br><br>  In general, the mechanism is quite simple, the main difficulty in setting is associated not so much with Pubcookie, as with OpenSSL. <br><br>  Accordingly, in the case of implementation, the most important thing is to properly configure the basic infrastructure for managing keys / certificates. <br><br>  At the same time, in a situation where there are quite a lot of legacy applications on the intranet, the use of Pubcookie allows you to implement centralized access control for them with minimal effort. <br><br>  Several links: <br><br><ul><li>  <a href="http://pubcookie.org/">http://www.pubcookie.org</a> - project site, latest version dated 02/01/2010; </li><li>  <a href="http://parsedout.com/2007/12/installing-pubcookie-33-on-ubuntu-710-with-apache-2/">Installing pubcookie 3.3 on Ubuntu 7.10 with Apache2</a> - the article is old, but still relevant; </li><li>  <a href="http://libresoft.es/Members/lcanas/blog/single-sign-on-with-pubcookie">Single Sign On with PubCookie</a> is another article. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/99002/">https://habr.com/ru/post/99002/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../98994/index.html">Smart TV: Intel is preparing a "smart TV"</a></li>
<li><a href="../98995/index.html">Lenovo invites you to a Formula 1 race car show in Moscow</a></li>
<li><a href="../98997/index.html">Yandex.Direct VS Carpet Bombing Sniper Rifle</a></li>
<li><a href="../98998/index.html">PHP 5.2 ‚Üí 5.3: translation difficulties</a></li>
<li><a href="../98999/index.html">A millionth user has signed up for Foursquare</a></li>
<li><a href="../99004/index.html">Roskomnadzor stopped squatting in the RF domain</a></li>
<li><a href="../99005/index.html">Parable about patterns</a></li>
<li><a href="../99006/index.html">Ural student bikes</a></li>
<li><a href="../99007/index.html">Tips in the search box in Opera for Google and others</a></li>
<li><a href="../99008/index.html">Content Consumer Portrait</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>