<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implicit type conversion in javascript. How many will be! + [] + [] +! []?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Type casting is the process of converting values ‚Äã‚Äãfrom one type to another (for example, strings to numbers, objects to logical values, and so on). A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implicit type conversion in javascript. How many will be! + [] + [] +! []?</h1><div class="post__text post__text-html js-mediator-article"> Type casting is the process of converting values ‚Äã‚Äãfrom one type to another (for example, strings to numbers, objects to logical values, and so on).  Any type in JavaScript, whether it is a primitive type, or an object, can be converted to another type.  Recall that primitive data types in JS are <code>Number</code> , <code>String</code> , <code>Boolean</code> , <code>Null</code> , <code>Undefined</code> .  The <code>Symbol</code> type has been added to this list in ES6, which behaves not at all like other types.  Explicit type conversion is a simple and straightforward process, but everything changes when it comes to implicit type conversion.  Here, what happens in JavaScript, some consider strange or illogical, although, of course, if you look into the standards, it becomes clear that all these "oddities" are features of the language.  Anyway, any JS-developer periodically has to deal with implicit type conversion, besides, tricky questions about type casting may well meet at the interview. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/347866/"><img src="https://habrastorage.org/getpro/habr/post_images/2d3/7f7/837/2d37f7837f00054aae22f11379cfcbec.jpg" alt="image"></a> <br><br>  This article is devoted to the features of the operation of the casting mechanisms in JavaScript.  We will start it with a list of expressions, the results of the calculation of which may look completely unexpected.  You can test yourself by trying to find the values ‚Äã‚Äãof these expressions without looking at the end of the article, where their analysis will be given. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">check yourself</font> </h2><br>  Here is a list of interesting expressions that we just talked about: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">true</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> / "6" "number" + <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + "number" [<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> "foo" + + "bar" <span class="hljs-string"><span class="hljs-string">'true'</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> == <span class="hljs-string"><span class="hljs-string">'false'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> == <span class="hljs-string"><span class="hljs-string">''</span></span> !!"false" == !!"true" [<span class="hljs-string"><span class="hljs-string">'x'</span></span>] == <span class="hljs-string"><span class="hljs-string">'x'</span></span> [] + <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> || "0" &amp;&amp; {} [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] == [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] {}+[]+{}+[<span class="hljs-number"><span class="hljs-number">1</span></span>] !+[]+[]+![] <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  It is full of such that it looks more than strange, but it works without problems in JS, using implicit type conversion.  In the vast majority of cases, implicit type conversions in JS are best avoided.  Consider this list as an exercise to test your knowledge of how type casting works in JavaScript.  If there is nothing new for you, take a look at <a href="https://wtfjs.com/">wtfjs.com</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/f5b/b00/794f5bb005d99f701487b1fe3202f3a0.png"><br>  <i><font color="#999999">JavaScript is full of weirdness</font></i> <br><br>  Here is a page with a <a href="https://dorey.github.io/JavaScript-Equality-Table/">table</a> that shows the behavior of the non-strict equality operator in JavaScript, <code>==</code> , when comparing values ‚Äã‚Äãof different types.  The implicit type conversion performed by the <code>==</code> operator makes this table much less comprehensible and logical than, say, a table for the strict equality operator, <code>===</code> , a link to which can be found on the above page.  To memorize the comparison table for the operator <code>==</code> almost impossible.  But remembering all this is not necessary - it is enough to master the principles of type conversion used in JavaScript. <br><br><h2>  <font color="#3AC1EF">Implicit type conversion and explicit type conversion</font> </h2><br>  Type conversion can be explicit and implicit.  When a developer expresses an intention to convert a value of one type into a value of another type, writing it appropriately in the code, say, as <code>Number(value)</code> , this is called explicit type conversion (or explicit type conversion). <br><br>  Since JavaScript is a language with weak typing, values ‚Äã‚Äãcan be converted between different types automatically.  This is called implicit type conversion.  This usually happens when different values ‚Äã‚Äãare used in expressions, like <code>1 == null</code> , <code>2/'5'</code> , <code>null + new Date()</code> .  An implicit type conversion can also be triggered by an expression context, such as <code>if (value) {‚Ä¶}</code> , where <code>value</code> implicitly cast to a logical data type. <br><br>  There is an operator that causes no implicit type conversion - this is a strict equality operator, <code>===</code> .  The non-strict equality operator, <code>==</code> , on the other hand, performs the comparison operation and, if necessary, performs implicit type conversion. <br><br>  Implicit type conversion is a double-edged sword: it is a source of confusion and errors, but it is also a useful mechanism that allows you to write less code without losing its readability. <br><br><h2>  <font color="#3AC1EF">Three types of type conversion</font> </h2><br>  The first feature of working with types in JS that you need to know about is that there are only three types of transformations: <br><br><ul><li>  To string ( <code>String</code> ) <br></li><li>  To <code>Boolean</code> <br></li><li>  <code>Number</code> <br></li></ul><br>  The second feature of JS that needs to be considered is that the conversion logic for primitive types and for objects works differently, but primitives and objects can be converted into these three types.  Let's start with primitive data types. <br><br><h2>  <font color="#3AC1EF">Primitive data types</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Conversion to String</font> </h3><br>  In order to explicitly convert a value to a string, you can use the <code>String()</code> function.  An implicit conversion causes the use of the usual addition operator, <code>+</code> , with two operands, if one of them is a string: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-number"><span class="hljs-number">123</span></span>) <span class="hljs-comment"><span class="hljs-comment">//   123 + ''    //  </span></span></code> </pre> <br>  All primitive types are converted to strings in a completely natural and expected way: <br><br><pre> <code class="hljs vhdl"><span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-number"><span class="hljs-number">123</span></span>)                   // '<span class="hljs-number"><span class="hljs-number">123</span></span>' <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(-<span class="hljs-number"><span class="hljs-number">12.3</span></span>)                 // '-<span class="hljs-number"><span class="hljs-number">12.3</span></span>' <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)                  // <span class="hljs-symbol"><span class="hljs-symbol">'null</span></span>' <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(undefined)             // <span class="hljs-symbol"><span class="hljs-symbol">'undefined</span></span>' <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)                  // <span class="hljs-symbol"><span class="hljs-symbol">'true</span></span>' <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)                 // <span class="hljs-symbol"><span class="hljs-symbol">'false</span></span>'</code> </pre> <br>  In the case of the <code>Symbol</code> type, the case is somewhat more complicated, since values ‚Äã‚Äãof this type can be converted to a string type only explicitly.  <a href="https://leanpub.com/understandinges6/read/">Here</a> you can read the details about the conversion rules of type Symbol. <br><br><pre> <code class="hljs pgsql">String(Symbol(<span class="hljs-string"><span class="hljs-string">'my symbol'</span></span>))   // <span class="hljs-string"><span class="hljs-string">'Symbol(my symbol)'</span></span> <span class="hljs-string"><span class="hljs-string">''</span></span> + Symbol(<span class="hljs-string"><span class="hljs-string">'my symbol'</span></span>)      //  TypeError</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Conversion to Boolean</font> </h3><br>  To explicitly convert a value to a boolean type, use the <code>Boolean()</code> function.  An implicit conversion occurs in a logical context, or is called by logical operators ( <code>||</code> <code>&amp;&amp;</code> <code>!</code> ). <br><br><pre> <code class="hljs erlang-repl">Boolean(<span class="hljs-number"><span class="hljs-number">2</span></span>)          //   if (<span class="hljs-number"><span class="hljs-number">2</span></span>) { ... }      //      !!<span class="hljs-number"><span class="hljs-number">2</span></span>                 //     <span class="hljs-number"><span class="hljs-number">2</span></span> || <span class="hljs-string"><span class="hljs-string">'hello'</span></span>        //    </code> </pre> <br>  Notice that operators like <code>||</code>  and <code>&amp;&amp;</code> convert values ‚Äã‚Äãto a logical type for internal purposes, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">return the</a> values ‚Äã‚Äãof the source operands, even if they are not logical. <br><br><pre> <code class="hljs bash">//     123,   <span class="hljs-literal"><span class="hljs-literal">true</span></span> // <span class="hljs-string"><span class="hljs-string">'hello'</span></span>  123         &amp;&amp;     <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> x = <span class="hljs-string"><span class="hljs-string">'hello'</span></span> &amp;&amp; 123;   // x === 123</code> </pre> <br>  Since when casting a value to a logical type, only two results are possible - <code>true</code> or <code>false</code> , it is easiest to master this kind of conversion, remembering the expressions that return <code>false</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-string"><span class="hljs-string">''</span></span>)           // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>)            // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>    <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-number"><span class="hljs-number">-0</span></span>)           // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">NaN</span></span>)          // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)         // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(undefined)    // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)        // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br>  Any value not in this list is converted to <code>true</code> , including objects, functions, arrays, dates, and user-defined types.  Values ‚Äã‚Äãof type <code>Symbol</code> also converted to <code>true</code> .  Empty objects and empty arrays are also converted to <code>true</code> : <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Boolean</span></span>({})             // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>([])             // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(Symbol())       // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> !!Symbol()              // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() {})  // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Conversion to Type Number</font> </h3><br>  Explicit conversion to a numeric type is performed using the <code>Number()</code> function - that is, according to the same principle used for the <code>Boolean</code> and <code>String</code> types. <br><br>  Implicit coercion of a value to a numeric type is a more complicated topic, since it is applied, perhaps, more often than conversion to a string or a logical value.  Namely, the conversion to the <code>Number</code> type is performed by the following operators: <br><br><ul><li>  Comparison operators ( <code>&gt;</code> , <code>&lt;</code> , <code>&lt;=</code> , <code>&gt;=</code> ). <br></li><li>  Bitwise operators ( <code>|</code> , <code>&amp;</code> , <code>^</code> , <code>~</code> ). <br></li><li>  Arithmetic operators ( <code>-</code> , <code>+</code> , <code>*</code> , <code>/</code> , <code>%</code> ).  Note that the <code>+</code> operator with two operands does not cause an implicit conversion to a numeric type if at least one operator is a string. <br></li><li>  Unary operator <code>+</code> . <br></li><li>  The non-strict equality operator <code>==</code> (and also <code>!=</code> ).  Note that the <code>==</code> operator does not perform an implicit conversion to a number if both operands are strings. <br></li></ul><br><pre> <code class="hljs pgsql">Number(<span class="hljs-string"><span class="hljs-string">'123'</span></span>)   //   +<span class="hljs-string"><span class="hljs-string">'123'</span></span>          //   <span class="hljs-number"><span class="hljs-number">123</span></span> != <span class="hljs-string"><span class="hljs-string">'456'</span></span>    //   <span class="hljs-number"><span class="hljs-number">4</span></span> &gt; <span class="hljs-string"><span class="hljs-string">'5'</span></span>         //   <span class="hljs-number"><span class="hljs-number">5</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>          //   <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> | <span class="hljs-number"><span class="hljs-number">0</span></span>        //  </code> </pre> <br>  Here‚Äôs how primitive values ‚Äã‚Äãare converted to numbers: <br><br><pre> <code class="hljs lisp">Number(<span class="hljs-name"><span class="hljs-name">null</span></span>)                   // <span class="hljs-number"><span class="hljs-number">0</span></span> Number(<span class="hljs-name"><span class="hljs-name">undefined</span></span>)              // NaN Number(<span class="hljs-name"><span class="hljs-name">true</span></span>)                   // <span class="hljs-number"><span class="hljs-number">1</span></span> Number(<span class="hljs-name"><span class="hljs-name">false</span></span>)                  // <span class="hljs-number"><span class="hljs-number">0</span></span> Number(<span class="hljs-string"><span class="hljs-string">" 12 "</span></span>)                 // <span class="hljs-number"><span class="hljs-number">12</span></span> Number(<span class="hljs-string"><span class="hljs-string">"-12.34"</span></span>)               // <span class="hljs-number"><span class="hljs-number">-12.34</span></span> Number(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)                   // <span class="hljs-number"><span class="hljs-number">0</span></span> Number(<span class="hljs-string"><span class="hljs-string">" 12s "</span></span>)                // NaN Number(<span class="hljs-number"><span class="hljs-number">123</span></span>)                    // <span class="hljs-number"><span class="hljs-number">123</span></span></code> </pre> <br>  When converting strings to numbers, the system first truncates spaces, as well as the <code>\n</code> and <code>\t</code> characters at the beginning or end of the string, and returns <code>NaN</code> if the resulting string is not a real number.  If the string is empty, 0 is returned. <br><br>  Values ‚Äã‚Äãof <code>null</code> and <code>undefined</code> handled differently: <code>null</code> converted to <code>0</code> , while <code>undefined</code> converted to <code>NaN</code> . <br><br>  Values ‚Äã‚Äãof type <code>Symbol</code> cannot be converted to a number, either explicitly or implicitly.  Moreover, when attempting such a conversion, a <code>TypeError</code> error is <code>TypeError</code> .  One would expect that this would cause the conversion of a <code>Symbol</code> value to <code>NaN</code> , as it does with <code>undefined</code> , but it does not.  Details on the rules for converting <code>Symbol</code> type values ‚Äã‚Äãcan be found at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">MDN</a> . <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">'my symbol'</span></span>))    <span class="hljs-comment"><span class="hljs-comment">//  TypeError +Symbol('123')                 //  TypeError</span></span></code> </pre> <br>  Here are two special rules to remember: <br><br>  When applying the <code>==</code> operator to <code>null</code> or <code>undefined</code> conversion to a number is performed.  The value <code>null</code> is only <code>null</code> or <code>undefined</code> and is not equal to anything else. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-literal"><span class="hljs-literal">null</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>               // <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> == <span class="hljs-literal"><span class="hljs-literal">null</span></span>            <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> == <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  The value of <code>NaN</code> not equal to anything, including yourself.  In the following example, if the value is not equal to itself, then we are dealing with <code>NaN</code> <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> !== <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { console.log("we're dealing with NaN here") }</code> </pre> <br><h2>  <font color="#3AC1EF">Type conversion for objects</font> </h2><br>  So, we have considered type conversion for primitive values.  It's all pretty simple.  When it comes to objects, and the system encounters expressions like <code>[1] + [2,3]</code> , it first needs to convert the object to a primitive value, which is then converted to its final type.  When working with objects, we recall, there are also only three directions of transformations: to a number, to a string, and to a logical value. <br><br>  The simplest is to convert to a logical value: any value that is not a primitive is always implicitly converted to <code>true</code> , this is also true for empty objects and arrays. <br><br>  Objects are converted to primitive values ‚Äã‚Äãusing the <code>[[ToPrimitive]]</code> internal method, which is responsible for both the conversion to a numeric type and the conversion to a string. <br><br>  Here is the pseudo-implementation of the <code>[[ToPrimitive]]</code> method: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToPrimitive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">input, preferredType</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (preferredType){   <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>:     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toNumber(input);     <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>:     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toString(input);     <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> toNumber(input);  } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPrimitive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value !== <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>(value); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPrimitive(input.toString())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.toString();   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPrimitive(input.valueOf())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.valueOf();   <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toNumber</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPrimitive(input.valueOf())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.valueOf();   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isPrimitive(input.toString())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.toString();   <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">TypeError</span></span>(); } }</code> </pre> <br>  The <code>[[ToPrimitive]]</code> passed an input value and the preferred type to convert it to: <code>Number</code> or <code>String</code> .  The <code>preferredType</code> argument is optional. <br><br>  Both when converting to a number and converting to a string, two methods of the object passed to <code>[[ToPrimitive]]</code> : this is <code>valueOf</code> and <code>toString</code> .  Both methods are declared in the <code>Object.prototype</code> , and are thus available for any type based on <code>Object</code> , for example - <code>Date</code> , <code>Array</code> , and so on. <br><br>  In general, the operation of the algorithm is as follows: <br><br><ol><li>  If the input value is a primitive, do nothing and return it. <br></li><li>  Call <code>input.toString()</code> , if the result is a value of the primitive type - return it. <br></li><li>  Call <code>input.valueOf()</code> , if the result is a value of a primitive type - return it. <br></li><li>  If neither <code>input.toString()</code> nor <code>input.valueOf()</code> gives a primitive value, give a TypeError error. <br></li></ol><br>  When converting to a number, <code>valueOf</code> (3) is first called, if the result cannot be obtained, <code>toString</code> (2) is called.  When converting to a string, the reverse sequence of actions is used ‚Äî first <code>toString</code> (2) is called, and in case of failure, <code>valueOf</code> (3) is called. <br><br>  Most built-in types do not have a <code>valueOf</code> method, or have a <code>valueOf</code> , which is returned by the object for which it is called ( <code>this</code> ), so this value is ignored, since it is not a primitive.  That is why converting to numbers and strings can work the same way - both come down to the <code>toString()</code> call. <br><br>  Different operators can call either a conversion to a number or a conversion to a string using the <code>preferredType</code> parameter.  But there are two exceptions: the lax equality operator <code>==</code> and the <code>+</code> operator with two operands cause a default conversion (the <code>preferredType</code> not specified or is set to <code>default</code> ).  In this case, most of the built-in types are considered, as a standard behavior, conversion to a number, with the exception of the <code>Date</code> type, which converts an object into a string. <br><br>  Here is an example of <code>Date</code> behavior on type conversion: <br><br><pre> <code class="hljs pgsql">let d = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>(); //    let str = d.toString();  // <span class="hljs-string"><span class="hljs-string">'Wed Jan 17 2018 16:15:42'</span></span> //   ,   -      Unix let num = d.valueOf();   // <span class="hljs-number"><span class="hljs-number">1516198542525</span></span> //     //  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>   d      console.log(d == str);   // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> //     //  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>,   d       valueOf() console.log(d == num);   // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> //  <span class="hljs-string"><span class="hljs-string">'Wed Jan 17 2018 16:15:42Wed Jan 17 2018 16:15:42'</span></span> // <span class="hljs-string"><span class="hljs-string">'+'</span></span>,  ,   <span class="hljs-string"><span class="hljs-string">'=='</span></span>,      console.log(d + d); //  <span class="hljs-number"><span class="hljs-number">0</span></span>,    <span class="hljs-string"><span class="hljs-string">'-'</span></span>     ,      console.log(d - d);</code> </pre> <br>  Standard methods <code>toString()</code> and <code>valueOf()</code> can be redefined to intervene in the logic of converting an object into primitive values. <br><br><pre> <code class="hljs coffeescript">var obj = { prop: <span class="hljs-number"><span class="hljs-number">101</span></span>, toString(){   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Prop: '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop; }, valueOf() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop; } }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(String(obj));  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'Prop: 101'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj + <span class="hljs-string"><span class="hljs-string">''</span></span>)      <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'101'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(+obj);         <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">101</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj &gt; <span class="hljs-number"><span class="hljs-number">100</span></span>);    <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br>  Notice that <code>obj + ''</code> returns <code>'101'</code> as a string.  The <code>+</code> operator calls the standard transform mode.  As already mentioned, <code>Object</code> treats coercion to a number as a default conversion, so it uses the <code>valueOf()</code> method first and not the <code>toString()</code> method. <br><br><h2>  <font color="#3AC1EF">Method Symbol.toPrimitive ES6</font> </h2><br>  In ES5, it is permissible to change the logic of converting an object to a primitive value by overriding the <code>toString</code> and <code>valueOf</code> methods. <br><br>  In ES6, you can go even further and completely replace the internal mechanism <code>[[ToPrimitive]]</code> by implementing the object method <code>[Symbol.toPrimtive]</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Disk { constructor(capacity){   this.capacity = capacity; } [Symbol.toPrimitive](hint){   switch (hint) {     <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'string'</span></span>:       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Capacity: '</span></span> + this.capacity + <span class="hljs-string"><span class="hljs-string">' bytes'</span></span>;     <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>:       //   KiB       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.capacity / <span class="hljs-number"><span class="hljs-number">1024</span></span>;     <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>:       //            <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.capacity / <span class="hljs-number"><span class="hljs-number">1024</span></span>;   } } } // <span class="hljs-number"><span class="hljs-number">1</span></span>MiB  let disk = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Disk(<span class="hljs-number"><span class="hljs-number">1024</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span>); console.log(String(disk))  // Capacity: <span class="hljs-number"><span class="hljs-number">1048576</span></span> bytes console.log(disk + <span class="hljs-string"><span class="hljs-string">''</span></span>)     // <span class="hljs-string"><span class="hljs-string">'1024'</span></span> console.log(+disk);        // <span class="hljs-number"><span class="hljs-number">1024</span></span> console.log(disk &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>);  // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Case study</font> </h2><br>  Armed with theory, let us return to the expressions given at the beginning of the material.  Here are the results of evaluating these expressions: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">true</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>             // <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span> / "6"                 // <span class="hljs-number"><span class="hljs-number">2</span></span> "number" + <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>        // <span class="hljs-string"><span class="hljs-string">'number153'</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + "number"        // <span class="hljs-string"><span class="hljs-string">'18number'</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>               // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> "foo" + + "bar"          // <span class="hljs-string"><span class="hljs-string">'fooNaN'</span></span> <span class="hljs-string"><span class="hljs-string">'true'</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>           // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> == <span class="hljs-string"><span class="hljs-string">'false'</span></span>         // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> == <span class="hljs-string"><span class="hljs-string">''</span></span>               // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> !!"false" == !!"true"    // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> [<span class="hljs-string"><span class="hljs-string">'x'</span></span>] == <span class="hljs-string"><span class="hljs-string">'x'</span></span>             // <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> [] + <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>            // <span class="hljs-string"><span class="hljs-string">'null1'</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> || "0" &amp;&amp; {}           // {} [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] == [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>]       // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> {}+[]+{}+[<span class="hljs-number"><span class="hljs-number">1</span></span>]             // <span class="hljs-string"><span class="hljs-string">'0[object Object]1'</span></span> !+[]+[]+![]              // <span class="hljs-string"><span class="hljs-string">'truefalse'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">0</span></span>          // <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-number"><span class="hljs-number">0</span></span>          // <span class="hljs-string"><span class="hljs-string">'Thu Jan 01 1970 02:00:00(EET)0'</span></span></code> </pre> <br>  Let us examine each of these examples. <br><br><h3>  <font color="#3AC1EF">‚ñçtrue + false</font> </h3><br>  The <code>+</code> operator with two operands causes a conversion to a number for <code>true</code> and <code>false</code> : <br><br><pre> <code class="hljs coffeescript"><span class="hljs-literal"><span class="hljs-literal">true</span></span> + <span class="hljs-literal"><span class="hljs-literal">false</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç12 / '6'</font> </h3><br>  The arithmetic division operator, <code>/</code> , causes a conversion to a number for the string <code>'6'</code> : <br><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">12</span></span> / <span class="hljs-string"><span class="hljs-string">'6'</span></span> ==&gt; <span class="hljs-number"><span class="hljs-number">12</span></span> / <span class="hljs-number"><span class="hljs-number">6</span></span> ==<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span><span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç ‚Äúnumber‚Äù + 15 + 3</font> </h3><br>  The <code>+</code> operator has left-to-right associativity, so the expression <code>"number" + 15</code> is executed first.  Since one of the operands is a string, the <code>+</code> operator causes a conversion to the string for the number <code>15</code> .  In the second step, the evaluation of the expression <code>"number15" + 3</code> processed in the same way: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-string"><span class="hljs-string">"number"</span></span> + <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"number15"</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"number153"</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç15 + 3 + ‚Äúnumber‚Äù</font> </h3><br>  The <code>15 + 3</code> expression is evaluated first.  There is absolutely no need for type conversion, since both operands are numbers.  In the second step, the value of the expression <code>18 + 'number'</code> calculated, and since one of the operands is a string, a conversion to the string is called. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-string"><span class="hljs-string">"number"</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">18</span></span> + <span class="hljs-string"><span class="hljs-string">"number"</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"18number"</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç [1]&gt; null</font> </h3><br>  The comparison operator <code>&gt;</code> performs numeric comparison <code>[1]</code> and <code>null</code> : <br><br><pre> <code class="hljs coffeescript">[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-literal"><span class="hljs-literal">null</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'1'</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç "foo" + + "bar"</font> </h3><br>  The unary <code>+</code> operator has a higher priority than the normal <code>+</code> operator.  As a result, the expression <code>+'bar'</code> evaluated first.  Unary <code>+</code> invokes a conversion to a number for the string <code>'bar'</code> .  Since the string is not a valid number, the result is <code>NaN</code> .  In the second step, the value of the expression <code>'foo' + NaN</code> calculated. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-string"><span class="hljs-string">"foo"</span></span> + + <span class="hljs-string"><span class="hljs-string">"bar"</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span> + (+<span class="hljs-string"><span class="hljs-string">"bar"</span></span>) =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span> + NaN =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"fooNaN"</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Ru'true '== true and false ==' false '</font> </h3><br>  The <code>==</code> operator causes the conversion to a number, the string <code>'true'</code> converted to <code>NaN</code> , the Boolean value <code>true</code> converted to <code>1</code> . <br><br><pre> <code class="hljs coffeescript"><span class="hljs-string"><span class="hljs-string">'true'</span></span> == <span class="hljs-literal"><span class="hljs-literal">true</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> NaN == <span class="hljs-number"><span class="hljs-number">1</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> == <span class="hljs-string"><span class="hljs-string">'false'</span></span>  =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> == NaN =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçnull == ''</font> </h3><br>  The <code>==</code> operator usually converts to a number, but this is not the case with the value <code>null</code> .  The value <code>null</code> is only <code>null</code> or <code>undefined</code> and nothing else. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-literal"><span class="hljs-literal">null</span></span> == <span class="hljs-string"><span class="hljs-string">''</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç !! "false" == !! "true"</font> </h3><br>  Operator <code>!!</code>  converts the strings <code>'true'</code> and <code>'false'</code> to boolean <code>true</code> , since they are non-empty strings.  Then the <code>==</code> operator simply checks the equality of the two logical values <code>true</code> without type conversion. <br><br><pre> <code class="hljs coffeescript">!!<span class="hljs-string"><span class="hljs-string">"false"</span></span> == !!<span class="hljs-string"><span class="hljs-string">"true"</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> == <span class="hljs-literal"><span class="hljs-literal">true</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç ['x'] == 'x'</font> </h3><br>  The <code>==</code> operator calls a conversion to a numeric type for arrays.  The object method <code>Array.valueOf()</code> returns the array itself, and this value is ignored because it is not a primitive.  The array method <code>toString()</code> converts the array <code>['x']</code> into the string <code>'x'</code> . <br><br><pre> <code class="hljs coffeescript">[<span class="hljs-string"><span class="hljs-string">'x'</span></span>] == <span class="hljs-string"><span class="hljs-string">'x'</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> == <span class="hljs-string"><span class="hljs-string">'x'</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span>  <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç [] + null + 1</font> </h3><br>  The <code>+</code> operator causes conversion to a number for the empty array <code>[]</code> .  The method of the <code>Array</code> object <code>valueOf()</code> ignored, since it returns the array itself, which is not a primitive.  The array method <code>toString()</code> returns an empty string. <br><br>  In the second step, the value of the expression <code>'' + null + 1</code> calculated. <br><br><pre> <code class="hljs coffeescript">[] + <span class="hljs-literal"><span class="hljs-literal">null</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-literal"><span class="hljs-literal">null</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span>  <span class="hljs-string"><span class="hljs-string">'null'</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'null1'</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç0 ||</font>  <font color="#3AC1EF">"0" &amp;&amp; {}</font> </h3><br>  Logical Operators <code>||</code>  and <code>&amp;&amp;</code> in the course of operation, cast the operands to a logical type, but return the source operands (which are of a different type than the logical one).  The value <code>0</code> false, and the value <code>'0'</code> true, since it is a non-empty string.  An empty object <code>{}</code> is also converted to a true value. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-string"><span class="hljs-string">"0"</span></span> &amp;&amp; {} =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span>  (<span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-string"><span class="hljs-string">"0"</span></span>) &amp;&amp; {} =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> (<span class="hljs-literal"><span class="hljs-literal">false</span></span> || <span class="hljs-literal"><span class="hljs-literal">true</span></span>) &amp;&amp; <span class="hljs-literal"><span class="hljs-literal">true</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">"0"</span></span> &amp;&amp; {} =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> &amp;&amp; <span class="hljs-literal"><span class="hljs-literal">true</span></span>             <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> {}</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç [1,2,3] == [1,2,3]</font> </h3><br>  Type conversion is not required since both operands are of the same type.  Since the <code>==</code> operator checks for equality of references to objects (and not whether objects contain the same values) and two arrays are two different objects, <code>false</code> will be returned as a result. <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">1,2,3</span></span>] == [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] ==&gt;  <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç {} + [] + {} + [1]</font> </h3><br>      ,   <code>+</code>          .  <code>valueOf</code>   <code>Object</code>  <code>Array</code>    ,    .  <code>toString()</code>    .    ,      <code>{}</code>     ,     ,  .     , <code>+[]</code> ,        <code>toString()</code> ,    0. <br><br><pre> <code class="hljs coffeescript">{}+[]+{}+[<span class="hljs-number"><span class="hljs-number">1</span></span>] =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> +[]+{}+[<span class="hljs-number"><span class="hljs-number">1</span></span>] =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> + {} + [<span class="hljs-number"><span class="hljs-number">1</span></span>] =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> + <span class="hljs-string"><span class="hljs-string">'[object Object]'</span></span> + [<span class="hljs-number"><span class="hljs-number">1</span></span>] =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'0[object Object]'</span></span> + [<span class="hljs-number"><span class="hljs-number">1</span></span>] =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'0[object Object]'</span></span> + <span class="hljs-string"><span class="hljs-string">'1'</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'0[object Object]1'</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñç!+[]+[]+![]</font> </h3><br>           . <br><br><pre> <code class="hljs coffeescript">!+[]+[]+![] =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> (!+[]) + [] + (![]) =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> !<span class="hljs-number"><span class="hljs-number">0</span></span> + [] + <span class="hljs-literal"><span class="hljs-literal">false</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> + [] + <span class="hljs-literal"><span class="hljs-literal">false</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> + <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-literal"><span class="hljs-literal">false</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'truefalse'</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñçnew Date(0) ‚Äî 0</font> </h3><br>  <code>-</code>        <code>Date</code> .  <code>Date.valueOf()</code>       Unix. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">0</span></span>) - <span class="hljs-number"><span class="hljs-number">0</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> - <span class="hljs-number"><span class="hljs-number">0</span></span> =<span class="hljs-function"><span class="hljs-function">=&gt;</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñçnew Date(0) + 0</font> </h3><br>  <code>+</code>    .   <code>Data</code>      ,     <code>toString()</code> ,   <code>valueOf()</code> . <br><br><pre> <code class="hljs 1c">new Date(<span class="hljs-number"><span class="hljs-number">0</span></span>) + <span class="hljs-number"><span class="hljs-number">0</span></span> ==&gt; 'Thu Jan 01 <span class="hljs-number"><span class="hljs-number">1970</span></span> 02:00:00 GMT+<span class="hljs-number"><span class="hljs-number">0200</span></span> (EET)' + <span class="hljs-number"><span class="hljs-number">0</span></span> ==&gt; 'Thu Jan 01 <span class="hljs-number"><span class="hljs-number">1970</span></span> 02:00:00 GMT+<span class="hljs-number"><span class="hljs-number">0200</span></span> (EET)0'</code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>   ‚Äî      JavaScript,      . ,    ,         ,     ,  ,  ,   ,   ,   ¬´ ¬ª,   -     . <br><br>  <b>Dear readers!</b>      ,        JavaScript    ? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/347866/">https://habr.com/ru/post/347866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347852/index.html">Web development experience when making a ‚ÄúMake a Word‚Äù game</a></li>
<li><a href="../347854/index.html">Special projects at Sberbank Technologies: how banks are preparing Hadoop, Spark, Kafka and other Big Data</a></li>
<li><a href="../347856/index.html">Data structures with program properties</a></li>
<li><a href="../347858/index.html">Digest news from the world of PostgreSQL. Issue number 2</a></li>
<li><a href="../347864/index.html">Absurdly fast base64 encoding and decoding</a></li>
<li><a href="../347868/index.html">The miner on the site is evil (although it can be good)</a></li>
<li><a href="../347870/index.html">‚ÄúStrashilka‚Äù about GDPR</a></li>
<li><a href="../347872/index.html">Pygest # 23. News, releases, articles, interesting projects and libraries from the world of Python [February 4, 2018 - February 26, 2018]</a></li>
<li><a href="../347874/index.html">Is it time for open and free processors?</a></li>
<li><a href="../347876/index.html">Changes in Big Data that are waiting for us in 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>