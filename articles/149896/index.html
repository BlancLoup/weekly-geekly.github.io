<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Modeling parametric log houses on ... C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Who cares how to simulate such a parametric log cabin in a few lines of C ++ code? 


 For several years we have been using the free version of the sg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Modeling parametric log houses on ... C ++</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/169/14b/213/16914b213570e712f30d0030713b9dba.png"><br>  Who cares how to simulate such a parametric log cabin in a few lines of C ++ code? <br><a name="habracut"></a><br><br>  For several years we have been using the free version of the sgCore solid-state modeling library in our projects ( <a href="http://www.geometros.com/sgcore/review.htm">here is a</a> brief overview of the possibilities).  Recently, the authors have released a version for iOS, and since this platform is actively developing, I think that a small introductory example to this library will be interesting to many.  I want to show with a small example how to use it to make a rather complex model in just a few steps. <br><br>  Here are the demo project sources for this article. <br>  <a href="">iOS</a> <br>  <a href="">mac</a> <br>  <a href="">win</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Create a model of a parametric log house.  In order not to complicate things, we will introduce only three parameters - the radius of the log section, the width of the house and the length of the house.  It is clear that in real problems the number of parameters will be much more, but in this example, the introduction of new parameters will not bring anything new.  Thus, we need to build a model of the house that will be rebuilt by calling just one function. <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sgFloat log_size, sgFloat houseSizeX, sgFloat houseSizeY)</span></span></span></span>;</code> </pre> <br>  To begin with, we initialize the library core.  This must be done once in the main thread before the first use of the sgCore functions: <br><pre> <code class="cpp hljs">sgInitKernel();</code> </pre><br>  Our first step will be the construction of the cross section of the log.  To ensure that the logs are not just lay on top of each other, but form a more or less stable construction, we will make the section shape not round, but consisting of two arcs: <br><br><img src="https://habrastorage.org/storage2/c58/875/5ed/c588755edfc6982ce450bd631cde32e9.png"><br><br>  A log of a similar cross section can be obtained in two ways ‚Äî either by creating a flat cross section itself and using a flat contour extrusion operation, or creating two cylinders of the same radius, displacing one of the cylinders, and applying a boolean subtraction operation.  Since the extrusion operation is faster than boolean subtraction - so we use the first method. <br>  Create a section of two arcs.  For a snug fit of the logs to each other, these arcs should be the same radius: <br><br><img src="https://habrastorage.org/storage2/109/2c6/160/1092c61606c831710093263e782af879.png"><br><br>  To create two arcs, we need to calculate the intersection points of two surroundings of the same radius.  This radius is one of the parameters of our model - therefore the function of constructing the contour of the log will have one input parameter - the radius of the log <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildLogSection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sgFloat log_size)</span></span></span></span>;</code> </pre><br>  Create the first arc of the section at three points: <br><br><img src="https://habrastorage.org/storage2/983/34f/1c5/98334f1c511eb0d77600975367b710c9.png"><br><br>  Let the angle, which sets the intersection of these two circles, will be equal to 45 degrees.  Then the points defining the first arc will have the following coordinates: <br><pre> <code class="cpp hljs">SG_POINT arc1BeginP = {log_size*cosCalc, -log_size*sinCalc, <span class="hljs-number"><span class="hljs-number">0</span></span>}; SG_POINT arc1EndP = {-log_size*cosCalc, -log_size*sinCalc, <span class="hljs-number"><span class="hljs-number">0</span></span>}; SG_POINT arc1MidP = {<span class="hljs-number"><span class="hljs-number">0</span></span>, log_size, <span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre><br>  Where log_size is the radius of the log, and sinCalc and cosCalc are the sines and cosines of the angle, which, as we have agreed, is 45 degrees.  By setting different angles, you can get a huge number of different options for sections, consisting of two arcs. <br><br>  Create an arc structure by these three points: <br><pre> <code class="cpp hljs">SG_ARC arc1; arc1.FromThreePoints(arc1BeginP, arc1EndP, arc1MidP, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><br>  The first three arguments are calculated points, the last argument is to invert or not the arc given by three points.  If this parameter is false, then the midpoint of the arc will lie on the arc created by us, if true, then an arc will be created that complements the arc created by the first method to a complete circle. <br><br>  We will create the second arc in a different way - by two end points, normals to the arc plane and radius.  The end points of the second arc coincide with the end points of the first, the normal to the arc plane is the Z axis, that is, the vector (0, 1, 1), and the radius is the same as the first arc, that is, log_size.  We build the structure of the second arc: <br><pre> <code class="cpp hljs">SG_ARC arc2; arc2.FromBeginEndNormalRadius(arc1BeginP, arc1EndP, zAxe, log_size, <span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br>  Next we need to build the objects themselves of the geometric kernel - the heirs of the sgCObject.  For arcs, these will be objects of the class sgCArc.  Since we are going to build a contour along these arcs, we immediately save our arcs into an array: <br><pre> <code class="cpp hljs">sgCObject* acrsObjs[<span class="hljs-number"><span class="hljs-number">2</span></span>]; acrsObjs[<span class="hljs-number"><span class="hljs-number">0</span></span>] = sgCArc::Create(arc1); acrsObjs[<span class="hljs-number"><span class="hljs-number">1</span></span>] = sgCArc::Create(arc2);</code> </pre><br>  And we will create the contour itself, which we will later use to build the log: <br><pre> <code class="cpp hljs">m_log_section = sgCContour::CreateContour(acrsObjs, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  After the section is built, we can create a log.  Since we need to create logs of various lengths, we will create a function that extrudes our section to an arbitrary length. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">sgC3DObject* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sgFloat logH)</span></span></span></span>;</code> </pre><br>  Since we created a flat contour in the XOY plane, we will extrude the contour of the log section along the Z axis (perpendicular to the section plane): <br><pre> <code class="cpp hljs">SG_VECTOR extrVect = {<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>, logH}; sgCObject* logObj = sgKinematic::Extrude(*m_log_section, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, extrVect, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre><br>  The first argument of the extrusion function is the outer contour that is extruded, the second argument is an array of holes in the extruded object ‚Äî also flat contours that lie inside the outer contour, the third argument is the number of holes.  Since there are no through holes along the entire length of the log in the logs from which the house is being built, these two arguments are null.  The fourth argument is the extrusion vector - it is directed along the Z axis and has a length - logH - the argument of the log creation function.  The last argument is to close the created object to a solid or simply to create a side surface of extrusion.  In other words - we need to create "bottoms" or not.  We have it is true. <br><br>  Let's create the first log of any length and add it to our scene: <br><pre> <code class="cpp hljs">sgGetScene()-&gt;AttachObject(BuildLog(houseSizeX));</code> </pre><br>  After starting the program we will see an empty scene.  Where is the log ??? <br>  In fact, the log was created and it will be rendered if you use for drawing not an array of triangles of the object, but its wireframe model.  So far, our log has no triangles - so we did not see anything. <br>  In order for a three-dimensional object to appear in the form of triangles - the object must be triangulated.  This can be done automatically for all created three-dimensional objects, or manually for each object.  For automatic triangulation, you must enable the flag: <br><pre> <code class="cpp hljs">sgC3DObject::AutoTriangulate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, SG_DELAUNAY_TRIANGULATION);</code> </pre><br>  The second argument is the type of triangulation.  More types of triangulation are described in the sgCore documentation. <br>  But there is one subtlety.  Triangulation of very complex objects may take some time.  And for using and working with objects, triangulation itself is not necessary - it is necessary only for visualizing the final result.  Therefore, if you build complex objects as intermediate, then you should disable automatic triangulation and triangulate the final results that the user will see.  Since we will have a lot of complex operations before obtaining the final result, we will therefore turn off automatic triangulation and manually triangulate only those objects that really need to be visualized. <br>  Therefore, we slightly transform the creation of our log: <br><pre> <code class="cpp hljs">sgC3DObject* log1 = BuildLog(houseSizeX); log1-&gt;Triangulate(SG_DELAUNAY_TRIANGULATION);</code> </pre><br>  Here is what we get: <br><br><img src="https://habrastorage.org/storage2/9f1/a0a/963/9f1a0a963e813aae190d02948e455fbc.png"><br><br>  The next step will be the construction of grooves for each log created.  The grooves are grooves in the log in those places where another log will fit to the log.  We will build grooves in our logs where the logs on which this log lies will be attached to it, taking into account the indents adopted during the construction of log houses. <br>  To do this, we expand the function of constructing a log by entering new parameters: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">sgC3DObject* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BuildLog</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sgFloat logH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withGroove, sgFloat logH, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> withGroove, sgFloat groove_size, sgFloat grooveShift)</span></span></span></span>;</code> </pre><br>  withGroove - a flag, is it necessary to build a groove <br>  groove_size - groove radius (equal to the radius of the log) <br>  grooveShift - indent from the edge of the log, on which the groove will be built. <br>  The groove will be two - from both ends of the log. <br>  To build grooves we will use boolean subtraction.  For speed, the subtracted object will be the cylinder.  You can, of course, use another log, but since the logs will intersect in such a way that they can be considered cylinders relative to each other (a notch formed by the second arc of the extruded contour does not participate in the process of constructing the groove), we will deduct the cylinder. <br>  Create two cylinders of radius equal to the radius of the log, of arbitrary length (the length of this temporary object does not matter, this does not affect the speed of work or the result).  The most important thing at this step is to correctly place these temporary objects in the space.  Since our base of the log stands on the XOY plane and is directed along the Z axis, we must also place these temporary objects accordingly.  Cylinders, like primitive objects, are also created with a base on the XOY plane, with a centrum at the origin and directed along the Z axis. Thus, we first need to rotate our temporary objects around the Y axis, then shift it so that the groove depth is taken into account ( we have it will be half the thickness of the log - that is, just the parameter log_size) and indents from the edges of the log.  Thus, the creation of these temporary objects will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (withGroove) { sgFloat cylH = <span class="hljs-number"><span class="hljs-number">10</span></span>*groove_size; sgC3DObject* cyl1 = sgCreateCylinder(groove_size, cylH, <span class="hljs-number"><span class="hljs-number">24</span></span>); cyl1-&gt;InitTempMatrix()-&gt;Rotate(zeroP, yAxe, <span class="hljs-number"><span class="hljs-number">90.0</span></span>*M_PI/<span class="hljs-number"><span class="hljs-number">180.0</span></span>); SG_VECTOR transVect = {-cylH/<span class="hljs-number"><span class="hljs-number">2</span></span>, -groove_size, grooveShift}; cyl1-&gt;GetTempMatrix()-&gt;Translate(transVect); cyl1-&gt;ApplyTempMatrix(); cyl1-&gt;DestroyTempMatrix(); sgC3DObject* cyl2 = sgCreateCylinder(groove_size, cylH, <span class="hljs-number"><span class="hljs-number">24</span></span>); cyl2-&gt;InitTempMatrix()-&gt;Rotate(zeroP, yAxe, <span class="hljs-number"><span class="hljs-number">90.0</span></span>*M_PI/<span class="hljs-number"><span class="hljs-number">180.0</span></span>); transVect.z = logH-grooveShift; cyl2-&gt;GetTempMatrix()-&gt;Translate(transVect); cyl2-&gt;ApplyTempMatrix(); cyl2-&gt;DestroyTempMatrix(); }</code> </pre><br><br>  These objects do not need to be triangulated, but let's temporarily do it and add to the scene, just to see if we have placed them: <br><br><img src="https://habrastorage.org/storage2/ddf/dea/738/ddfdea73852253a61cfd1511f9c1d614.png"><br><br>  Fine.  Objects are placed as needed.  Remove from the code the triangulation of these objects and will not add them to the scene. <br>  Next, you need to use a boolean subtraction to get the log in grooves. <br>  First we subtract the first temporary object.  Since, as a result of a Boolean subtraction, a group is created, there it must be broken up, the group object must be deleted, and the pointer to the first log pointer should be reassigned (and the only object from the collapsed group).  In this case, we will not forget to remove that temporary cylinder, since we no longer need it, as well as the old log object: <br><pre> <code class="cpp hljs">sgCGroup* boolRes1 = sgBoolean::Sub((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sgC3DObject&amp;)(*logObj), *cyl1); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ChCnt = boolRes1-&gt;GetChildrenList()-&gt;GetCount(); sgCObject** allChilds = (sgCObject**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ChCnt*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sgCObject*)); boolRes1-&gt;BreakGroup(allChilds); sgCObject::DeleteObject(boolRes1); sgCObject::DeleteObject(logObj); logObj = allChilds[<span class="hljs-number"><span class="hljs-number">0</span></span>]; sgCObject::DeleteObject(cyl1);</code> </pre><br><br>  We will do the same with the second variable cylinder: <br><pre> <code class="cpp hljs">boolRes1 = sgBoolean::Sub((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sgC3DObject&amp;)(*logObj), *cyl2); ChCnt = boolRes1-&gt;GetChildrenList()-&gt;GetCount(); allChilds = (sgCObject**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ChCnt*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sgCObject*)); boolRes1-&gt;BreakGroup(allChilds); sgCObject::DeleteObject(boolRes1); sgCObject::DeleteObject(logObj); logObj = allChilds[<span class="hljs-number"><span class="hljs-number">0</span></span>]; sgCObject::DeleteObject(cyl2);</code> </pre><br><br>  After these two operations we get the following result: <br><br><img src="https://habrastorage.org/storage2/52a/820/3df/52a8203dfa8e18e5ce9f82584b1e8cf1.png"><br><br>  The next step is to create the walls.  In fact, this step does not bring anything new - we just have to create the necessary number of logs and place them in the appropriate places.  We only say that to create the same logs, we will use the cloning function of the object (Clone ()), and not the creation from scratch.  Let us skip here the description of where a log should be located, and just show the steps for constructing the walls: <br><br><img src="https://habrastorage.org/storage2/81b/461/a61/81b461a61df46ec364813e63a00eb247.png"><br><img src="https://habrastorage.org/storage2/3ca/566/fd1/3ca566fd18f66ff1c314786407a18bef.png"><br><img src="https://habrastorage.org/storage2/3a2/854/99b/3a285499b8c695c68a742a99c25826f7.png"><br><br>  So the walls are built.  Now we have a fully parametric model of the foundation of a house, and it fully meets the physical requirements of logging into each other - through solid-state operations with objects.  This means that our house model is created not just for display, but completely corresponds to a house that is actually being built. <br>  Let's change the parameters a bit and see how it will change the house: <br><br><img src="https://habrastorage.org/storage2/abb/fa8/f8a/abbfa8f8a142b2ec4f7bb9c37f94e378.png"><br><img src="https://habrastorage.org/storage2/298/b13/d4c/298b13d4cb42e221923f2c0c878c2413.png"><br><br>  As you can see, having a parametric model, and changing only a few numbers, you can easily get an infinite number of models. <br>  The next step is to add to the window model. <br>  To build the window, we use two operations: extrusion and boolean subtraction.  Of course, in real houses there are usually rectangular windows, but we want to make a window of some unusual shape, so we will use not just a temporary box (as could be done in the case of a rectangular window), but extrude a rounded contour. <br>  So, first create such a contour.  It will consist of an arc and three segments.  The functions of creating a contour and its extrusion are completely analogous to those used in the creation of the log, so we will not focus on this.  After extruding the contour of the window and placing it in the required place, we get the following: <br><br><img src="https://habrastorage.org/storage2/a3e/50b/ab7/a3e50bab7da7c4597d655eb6cf90388e.png"><br><br>  We will subtract our window from the logs of the very first wall.  Therefore, we will disable their triangulation in the function of their creation and then we will triangulate the results of applying the subtraction window.  In order to subtract a window from a wall, it is necessary to subtract the window object from each wall log.  You can do this more optimally, because we know where exactly what log is located and where the window is located and apply a Boolean operation only to those logs that really intersect with the window.  But we will be laid on the result of a boolean subtraction.  If it is zero, then the objects do not overlap.  It is also necessary to take into account that in this case the result of Boolean operations may consist of several objects (the window divides the log into two).  Do not forget after all the boolean operations to delete the temporary object and the old logs: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> oldCnt = m_walls[<span class="hljs-number"><span class="hljs-number">0</span></span>].size(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;oldCnt;i++) { sgCGroup* boolRes = sgBoolean::Sub(*m_walls[<span class="hljs-number"><span class="hljs-number">0</span></span>][i], *winObj); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boolRes) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ChCnt = boolRes-&gt;GetChildrenList()-&gt;GetCount(); sgCObject** allChilds = (sgCObject**)<span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ChCnt*<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(sgCObject*)); boolRes-&gt;BreakGroup(allChilds); sgCObject::DeleteObject(boolRes); sgGetScene()-&gt;DetachObject(m_walls[<span class="hljs-number"><span class="hljs-number">0</span></span>][i]); sgDeleteObject(m_walls[<span class="hljs-number"><span class="hljs-number">0</span></span>][i]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>;j&lt;ChCnt;j++) { ((sgC3DObject*)allChilds[j])-&gt;Triangulate(SG_VERTEX_TRIANGULATION); sgGetScene()-&gt;AttachObject(allChilds[j]); } m_walls[<span class="hljs-number"><span class="hljs-number">0</span></span>][i] = (sgC3DObject*)allChilds[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j=<span class="hljs-number"><span class="hljs-number">1</span></span>;j&lt;ChCnt;j++) m_walls[<span class="hljs-number"><span class="hljs-number">0</span></span>].push_back((sgC3DObject*)allChilds[j]); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(allChilds); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m_walls[<span class="hljs-number"><span class="hljs-number">0</span></span>][i]-&gt;Triangulate(SG_VERTEX_TRIANGULATION); } sgDeleteObject(winObj);</code> </pre><br><br>  After that, we get a house model with a window: <br><br><img src="https://habrastorage.org/storage2/a18/947/d13/a18947d13e820fd735128ecc0533b9b1.png"><br><br>  The last step is to add a ramp.  We will do this in two stages - first we cut the logs that will intersect in the roof surface, then we will create the ramp surface itself. <br><br>  To begin, remove all calls triangulations of all previously created is ancient.  When creating the roof will be used to truncate all the logs of the roof surface - that is, boolean subtraction.  Triangulate all the results of these subtractions. <br>  So, using the extrusion operation, we will create a temporary object that will truncate our logs under the roof surface: <br><img src="https://habrastorage.org/storage2/19e/b91/6fe/19eb916fe38ee9689c5d987dcd765f99.png"><br>  And we will subtract this temporary object from all logs in the same way that the window was subtracted from the logs of the first wall: <br><img src="https://habrastorage.org/storage2/0a4/96c/eb3/0a496ceb385d4f0f40e2a565c6873834.png"><br>  It remains only to create the surface of the slope.  To do this, we also use the extrusion operation.  Then we get the finished model of the log house: <br><img src="https://habrastorage.org/storage2/73d/832/44c/73d83244c74c968103ce804f82607ab2.png"><br><img src="https://habrastorage.org/storage2/faa/e22/1f8/faae221f8d9d47b470e4b13deab4c058.png"><br>  As well as an infinite number of variations of this model, by varying the parameters: <br><img src="https://habrastorage.org/storage2/701/e12/c2e/701e12c2e26743f29b4c7d18c868fa0b.png"><br><img src="https://habrastorage.org/storage2/0f1/2c5/9e4/0f12c59e43d5f4df0d1f9d8c85336499.png"><br><img src="https://habrastorage.org/storage2/e93/128/55e/e9312855e615b4543c0f81041cb6a6be.png"></div><p>Source: <a href="https://habr.com/ru/post/149896/">https://habr.com/ru/post/149896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../149890/index.html">Raspberry Pi: detailed setup from scratch to TorrentBox</a></li>
<li><a href="../149892/index.html">Internet 2002-2012: what has changed over the decade?</a></li>
<li><a href="../149893/index.html">Project Animusic 3 asks for help</a></li>
<li><a href="../149894/index.html">Auto Acceleration - a project for car enthusiasts</a></li>
<li><a href="../149895/index.html">‚ÄúRunet today‚Äù, August 20, 2012. Experts of the issue: German Klimenko, Dmitry Chistov</a></li>
<li><a href="../149898/index.html">Full Python application on Android</a></li>
<li><a href="../149899/index.html">Again competition and again prizes</a></li>
<li><a href="../149900/index.html">System Center 2012 App Controller: we drive Virtual Machine Manager 2012 and Windows Azure into one team</a></li>
<li><a href="../149901/index.html">Blackberry Playbook 4G LTE Tablet PC Appears in Canada</a></li>
<li><a href="../149903/index.html">Testing is not a search for errors!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>