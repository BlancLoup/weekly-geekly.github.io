<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A bit about the interfaces in .Net (based on one interview)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last Monday, I was lucky to get an interview at Senior .Net Developer in one international company. During the interview I was offered to take a test ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A bit about the interfaces in .Net (based on one interview)</h1><div class="post__text post__text-html js-mediator-article">  Last Monday, I was lucky to get an interview at Senior .Net Developer in one international company.  During the interview I was offered to take a test where a number of questions were related to .Net.  In particular, in one of the questions it was necessary to give an assessment (truth / false) to a number of statements, among which were: <br><br><blockquote>  In .Net, any array of elements, for example, int [], implements an IList by default, which allows it to be used as a collection in a foreach statement. <br></blockquote><br><br>  Quickly answering this question in the negative and separately added to the fields.  that foreach requires an implementation not of an IList, but of an IEnumerable, I moved on to the next question.  However, on the way home I was tormented by the question: does the array implement this interface anyway or not? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      About IList, I vaguely remembered that this interface gives me an IEnumerable, an indexer and a Count property that contains the number of elements in the collection, as well as a couple of rarely used properties, such as IsFixedCollection ().  The array has the Length property for its size, and the Count in IEnumerable is an extension method from LINQ, which would be impossible if this method were implemented in a class.  Thus, it turned out that the array could not implement the IList interface, but some vague feeling did not give me rest.  Therefore, in the evening after the interview, I decided to conduct a small study. <br><br><a name="habracut"></a><br><h4>  Class System.Array </h4><br>  Since Reflector.Net was not installed with me, I simply wrote a short C # program to find out what interfaces are implemented by an integer array. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = v.GetType(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = t.GetInterfaces(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tp <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> i) Console.WriteLine(tp.Name);</code> </pre> <br><br>  Here is the complete list of interfaces received from the console window: <br><br><pre> <code class="cs hljs">ICloneable IList ICollection IEnumerable IStructuralComparable IStructuralEquatable IList`<span class="hljs-number"><span class="hljs-number">1</span></span> ICollection`<span class="hljs-number"><span class="hljs-number">1</span></span> IEnumerable`<span class="hljs-number"><span class="hljs-number">1</span></span> IReadOnlyList`<span class="hljs-number"><span class="hljs-number">1</span></span> IReadOnlyCollection`<span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br><br>  Thus, an <b>array in .Net still implements the IList interface and its generic version of IList &lt;&gt;</b> . <br><br>  To get more complete information, I built a system.Array class diagram. <br><br><img src="https://habrastorage.org/storage2/6a1/881/47c/6a188147c3b799ac30e7c6c7defbe374.png"><br><br>  My mistake immediately caught my eye: Count was a property not of IList, but of ICollection, the previous interface in the inheritance chain.  However, the array itself no longer had such a property as many other properties of the IList interface, although other properties of this interface, IsFixedSize and IsReadOnly, were implemented.  How is that even possible? <br><br>  Everything immediately falls into place when you remember that in C # you can implement interfaces not only <br>  implicitly, but explicitly.  I knew about this possibility from textbooks, where an example of such an implementation in the case was cited.  when the base class already contains a method with the same name as the interface method.  I also saw this feature in ReSharper.  However, to date, I have not directly encountered the need to explicitly implement interfaces in my own projects. <br><br><h4>  Comparing explicit and implicit interface implementations </h4><br>  Let's compare these two types of interface implementations: <br><br><table><tbody><tr><th>  Criteria <br></th><th>  Implicit implementation <br></th><th>  Explicit implementation <br></th></tr><tr><td>  Basic syntax <br></td><td><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ITest</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ImplicitTest</span></span> : <span class="hljs-title"><span class="hljs-title">ITest</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br></td><td><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ITest</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoTest</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExplicitTest</span></span> : <span class="hljs-title"><span class="hljs-title">ITest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ITest.DoTest() { } }</code> </pre><br><br></td></tr><tr><td>  Visibility <br></td><td>  Implicit implementation has always been open (public), so methods and properties can be accessed directly. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> imp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ImplicitTest(); imp.DoTest();</code> </pre><br></td><td>  Explicit implementation is always closed. <br>  To access the implementation, you need to cast an instance of the class to the interface (upcast to interface). <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExplicitTest(); ((ITest)exp).DoTest();</code> </pre><br></td></tr><tr><td>  Polymorphia <br></td><td>  The implicit implementation of an interface can be virtual (virtual), which allows rewriting this implementation in descendant classes. <br></td><td>  Explicit implementation is always static.  It cannot be rewritten (override) or overlapped (new) in descendant classes.  <sup>Note</sup>  <sup>one</sup> <br></td></tr><tr><td>  Abstract class and implementation <br></td><td>  An implicit implementation can be abstract and can only be implemented in a descendant class. <br></td><td>  An explicit implementation cannot be abstract, but the class itself can have other abstract methods and itself be abstract.  <sup>Note</sup>  <sup>2</sup> <br></td></tr></tbody></table><br>  Notes: <br>  <sup>Note</sup>  <sup>1</sup> - As <a href="https://habrahabr.ru/users/mayorovp/" class="user_link">mayorovp</a> rightly notes in the comments, the implementation can be redefined when the interface is re-explicitly implemented in the descendant class (see the first comment on the article). <br><br>  <sup>Note</sup>  <sup>2</sup> - In <a href="http://www.dev102.com/2008/04/08/4-key-differences-between-implicit-and-explicit-interface-implementation/">one of the blogs</a> indicated that the class itself can not be abstract.  Perhaps this was true for some of the previous versions of the compiler, in my experiments I could easily implement the interface explicitly in an abstract class. <br><br><h4>  Why do we need an explicit interface implementation </h4><br>  An explicit interface implementation, according to <a href="http://msdn.microsoft.com/en-us/library/vstudio/ms173157.aspx">MSDN</a> , is necessary in the case when several interfaces implemented by a class have a method with the same signature.  This problem in its general form is known in the English-speaking world under the chilling name <a href="http://en.wikipedia.org/wiki/Diamond_problem">"deadly diamond of death"</a> , which translates into Russian as the <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25BE%25D0%25B2%25D0%25B8%25D0%25B4%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BD%25D0%25B0%25D1%2581%25D0%25BB%25D0%25B5%25D0%25B4%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">"diamond pattern"</a> .  Here is an example of such a situation: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Listing 1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IJogger</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISkier</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Athlete</span></span>: <span class="hljs-title"><span class="hljs-title">ISkier</span></span>, <span class="hljs-title"><span class="hljs-title">IJogger</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Am I an Athlete, Skier or Jogger?"</span></span>); } }</code> </pre><br><br>  By the way, this example is the correct code in C #, that is, it is (correctly) compiled and run, while the Run () method is both a method of the class itself and an implementation of two interfaces.  Thus, we can have one implementation for different interfaces and for the class itself.  You can check it with the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Listing 2 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Athlete(); sp.Run(); (sp <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ISkier).Run(); (sp <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> IJogger).Run();</code> </pre><br><br>  The result of the execution of this code will be <i>‚ÄúAm I an Athlete, Skier or Jogger?‚Äù</i> , <i>Displayed</i> in the console three times. <br><br>  This is where we can use an explicit interface implementation to separate all three cases: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Listing 3 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sportsman</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"I am a Sportsman"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Athlete</span></span>: <span class="hljs-title"><span class="hljs-title">Sportsman</span></span>, <span class="hljs-title"><span class="hljs-title">ISkier</span></span>, <span class="hljs-title"><span class="hljs-title">IJogger</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"I am an Athlete"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ISkier.Run() { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"I am a Skier"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> IJogger.Run() { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"I am a Jogger"</span></span>); } }</code> </pre><br><br>  In this case, when executing the code from Listing 2, we see three lines in the console, <i>‚ÄúI am an Athlete‚Äù</i> , <i>‚ÄúI am a Skier‚Äù</i> and <i>‚ÄúI am a Jogger‚Äù</i> . <br><br><h4>  Pros and cons of various interface implementations </h4><br><h5>  Implementation visibility and sample implementation </h5><br>  As shown above, the implicit implementation is not syntactically different from the usual class method (and if this method has already been defined in the ancestor class, then in this syntax the method will be hidden (hidden) in the children and the code will be compiled without problems c compiler warning about hiding a method.).  Moreover, it is possible to selectively implement individual methods of a single interface both explicitly and implicitly: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Listing 4 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Code</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"I am a class method"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ICommand</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CodeCommand</span></span> : <span class="hljs-title"><span class="hljs-title">Code</span></span>, <span class="hljs-title"><span class="hljs-title">ICommand</span></span> { <span class="hljs-comment"><span class="hljs-comment">// implicit interface method implementation // =&gt; public implementation // implicit base class method hiding (warning here) public void Run() { base.Run(); } // explicit interface method implementation // =&gt; private implementation void ICommand.Execute() {} }</span></span></code> </pre><br><br>  This allows you to use implementations of individual interface methods as native class methods and they are available, for example, through IntelliSense, in contrast to the explicit implementation of methods that are private and visible only after the cast to the corresponding interface. <br><br>  On the other hand, the possibility of private implementation of methods allows you to hide a number of interface methods, while fully implementing it.  Returning to our very first example with arrays in .Net, you can see that the array hides, for example, the implementation of the Count property of the ICollection interface, exposing this property under the name Length (probably this is an attempt to maintain compatibility with C ++ STL and Java).  Thus, we can hide certain methods of the implemented interface and not hide (= make public) others. <br><br>  Here, however, such a problem arises that in many cases it is completely impossible to guess which interfaces are implemented by the class ‚Äúimplicitly‚Äù, since neither the methods nor the properties of these interfaces are visible in IntelliSense (the example with System.Array is also indicative).  The only way to identify such implementations is to use reflection, for example, using the Object Browser in Visual Studio. <br><br><h5>  Interface refactoring </h5><br>  Since the implicit (public) implementation of the interface does not differ from the implementation of the class's public method, if the interface is refactored and any public method is removed from it (for example, when combining the Run () and Execute () methods from the above ICommand interface into a single Run method ( )) In all implicit implementations, the open access method will remain, which is very likely to be maintained even after refactoring, since this public method may already have different dependencies in other components of the system.  As a result, the principle of programming ‚Äúagainst interfaces, not implementations‚Äù will be violated, since dependencies will already be between specific (and in different classes, probably different) implementations of the former interface method. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Listing 5 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IFingers</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Thumb</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IndexFinger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-comment"><span class="hljs-comment">// an obsolete interface method // void MiddleFinger(); } public class HumanPalm : IFingers { public void Thumb() {} public void IndexFinger() {} // here is a "dangling" public method public void MiddleFinger() {} } public class AntropoidHand : IFingers { void IFingers.Thumb() {} void IFingers.IndexFinger() {} // here the compiler error void IFingers.MiddleFinger() {} }</span></span></code> </pre><br><br>  In the case of private implementation of interfaces, all classes with an explicit implementation of a nonexistent method will simply cease to compile, but after removing the implementation that has become unnecessary (or refactoring it to a new method), we will not have an ‚Äúextra‚Äù public method that is not tied to any interface.  Of course, it may be necessary to refactor dependencies on the interface itself, but here, at least, there will be no violation of the ‚Äúprogram to interfaces, not implementations‚Äù principle. <br><br>  As for properties, implicitly implemented interface properties (properties) allow them to be accessed via accessor methods (getter and setter) both from the outside and directly from the class itself, which can lead to unnecessary effects (for example, to unnecessary data validation during initialization). properties). <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/* Listing 6 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IProperty</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Amount { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ClassWithProperty</span></span> : <span class="hljs-title"><span class="hljs-title">IProperty</span></span> { <span class="hljs-comment"><span class="hljs-comment">// implicit implementation, public public int Amount { get; set; } public ClassWithProperty() { // internal invocation of the public setter Amount = 1000; } } public class ClassWithExplicitProperty : IProperty { // explicit implementation, private int IProperty.Amount { get; set; } public ClassWithExplicitProperty() { // internal invocation isn't possible // compiler error here Amount = 1000; } }</span></span></code> </pre><br><br>  With the explicit implementation of interface properties, these properties remain private and for access you have to go a ‚Äúlong‚Äù way and declare an additional private field, through which initialization takes place.  As a result, this leads to cleaner code when property access methods are used only for access from the outside. <br><br><h5>  Using explicit typing of local variables and class fields </h5><br>  In the case of an explicit implementation of interfaces, we have to explicitly indicate that we are working not with an instance of a class, but with an instance of an interface.  Thus, for example, it becomes impossible to use type inference and the declaration of local variables in C # using the service word var.  Instead, we have to use an explicit declaration specifying the type of interface when declaring local variables, as well as in the method signature and in the class fields. <br><br>  Thus, on the one hand, we make the code somewhat less flexible (for example, ReSharper, by default, always suggests using a declaration with var if possible), but avoid potential problems associated with binding to a specific implementation, as the system grows code.  This point may seem controversial to many, but in the case when several people work on the project, and even in different parts of the world, using explicit typing can be very useful, since it increases the readability of the code and reduces the cost of supporting it. <br><br><div class="spoiler">  <b class="spoiler_title">Related Sources</b> <div class="spoiler_text">  In preparing the article, information from a number of network sources was used, in particular from blogs ( <a href="http://www.dev102.com/2008/04/08/4-key-differences-between-implicit-and-explicit-interface-implementation/">[1]</a> , <a href="http://www.shafqatahmed.com/2008/02/net-basics-expl.html">[2]</a> , <a href="http://munishbansal.wordpress.com/2008/10/06/implicit-versus-explicit-interface-implementation-c/">[3]</a> and <a href="http://blogs.msdn.com/b/mhop/archive/2006/12/12/implicit-and-explicit-interface-implementations.aspx">[4]</a> ), as well as from <a href="http://stackoverflow.com/questions/598714/implicit-vs-explicit-interface-implementation">[5]</a> and <a href="http://stackoverflow.com/questions/598714/implicit-vs-explicit-interface-implementation">[6]</a> questions from StackOverflow, a <a href="http://www.codeproject.com/Articles/392516/Why-I-use-explicit-interface-implementation-as-a-d">very interesting article</a> on CodeProject and chapters 13.5 of the book Jeffrey Richter " <a href="http://my.safaribooksonline.com/book/programming/csharp/9780735640467/interfaces/implicit_and_explicit_interface_method_i">CLR via C #</a> ". <br></div></div><div class="spoiler">  <b class="spoiler_title">Small bonus: two questions on backfill (for the inquisitive)</b> <div class="spoiler_text">  These questions are not directly related to the topic of explicit implementation of interfaces, but it seems to me that here they may be of interest to someone: <br>  1. If one more line is assigned to Listing 2 <br><pre> <code class="cs hljs">(sp <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Sportsman).Run();</code> </pre><br>  What will be displayed in the console? <br><br>  2. How, using the minimal change in Listing 3 (replacing one keyword with another), achieve the console output of the phrase <i>‚ÄúI am a Sportsman‚Äù</i> in the first question? <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/156037/">https://habr.com/ru/post/156037/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../156025/index.html">Github dating</a></li>
<li><a href="../156027/index.html">Robotic wheelchair capable of stepping on steps</a></li>
<li><a href="../156029/index.html">Domain pearls or the most stupid domains</a></li>
<li><a href="../156033/index.html">CDN for 70,000 sites with one button</a></li>
<li><a href="../156035/index.html">.Net-detective: about interfaces and reflection</a></li>
<li><a href="../156039/index.html">Battle City on unity in 1 day?</a></li>
<li><a href="../156045/index.html">Determining the dominant colors: Python and the k-means method</a></li>
<li><a href="../156047/index.html">The data center is the engine of energy efficiency in the world. But in Russia?</a></li>
<li><a href="../156049/index.html">Microelectronics for space and military</a></li>
<li><a href="../156051/index.html">Circuit Switch FallBack: First Step on the Road to Voice in LTE</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>