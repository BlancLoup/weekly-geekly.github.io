<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multi-modality in Android in terms of architecture. From A to Z</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 Not so long ago, we all realized that a mobile application is not just a thin client, but this is really a large number of very different lo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multi-modality in Android in terms of architecture. From A to Z</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  Not so long ago, we all realized that a mobile application is not just a thin client, but this is really a large number of very different logic that needs to be organized.  That is why we imbued with the ideas of Clean architecture, felt what DI is, learned how to use Dagger 2, and now with closed eyes are able to break any feature into layers. <br><br>  But the world does not stand still, and with the solution of old problems new ones come.  And the name of this new problem is monomodule.  Usually you will learn about this problem when assembly time flies into space.  This is exactly how many reports about the transition to multi-modulus ( <a href="https://www.youtube.com/watch%3Fv%3DTWLkswxjSr0%26feature%3Dyoutu.be">one</a> , <a href="https://www.youtube.com/watch%3Fv%3DpMEAD6jjbaI%26feature%3Dyoutu.be">two</a> ) begin. <br>  But for some reason, all of this somehow forget that monomodularity beats strongly not only in terms of assembly time, but also in your architecture.  Here is the answer to the questions.  How big is your AppComponent?  Do you occasionally encounter in the code that the feature A is for some reason tweaking the feature B's repository, although it doesn't seem to be like this, well, or should it be somehow more top-level?  In general, features have some kind of contract?  And how do you organize communication between features?  Are there any rules? <br>  You feel that we have solved the problem with the layers, that is, vertically everything seems to be fine, but is something going horizontally wrong?  And simply dividing into packages and control into reviews does not solve the problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And a control question for the more experienced.  When you moved to multi-modularity, didn't you have to shovel half of the application, always drag and drop code from one module to another, and live a decent amount of time with an uncollected project? <br><br>  In my article I want to tell you how I came to multi-modality precisely from an architectural point of view.  What problems bothered me, and how I tried to solve them step by step.  And at the end you will find an algorithm for switching from mono-modular to multi-modular without tears and pain. <br><a name="habracut"></a><br>  Answering the first question, how big is my AppComponent, I can admit - big, really big.  And it constantly tormented me.  How did that happen?  First of all, it is because of such an organization DI.  It is with DI that we begin. <br><br><h2>  As I did DI before </h2><br>  I think many people have formed in their heads something like this dependency scheme of components and corresponding scopes: <br><img src="https://habrastorage.org/webt/f1/xm/so/f1xmsoakbmgcfys9rjuys_jmnvo.png"><br><br><h4>  What do we have here </h4><br>  <b>AppComponent</b> , which absorbed absolutely all dependencies with the <i>Singleton</i> scoop.  I think almost everybody has this component. <br><br>  <b>FeatureComponents</b> .  Each feature was with its scoop and was a subcomponent of <i>AppComponent</i> or a <i>major</i> feature. <br>  Let's dwell on the features.  First of all, what is a feature?  I will try in my own words.  <b>A feature</b> is a logically complete, maximally independent program module that solves a specific user problem, with clearly defined external dependencies, and which is relatively easy to use again in another program.  Features can be big and small.  Features may contain other features.  And they can also use or launch other features through clearly marked external dependencies.  If you take our application (Kaspersky Internet Security for Android), then features can be considered Anti-Virus, Anti-Theft, etc. <br><br>  <b>ScreenComponents</b> .  A component for a specific screen, also with its own scopes and also a subcomponent of the corresponding feature component. <br><br><h4>  Now the list of "why so" </h4><br>  <b>Why subcomponents?</b> <br>  In component dependencies, I didn‚Äôt like first of all that a component could depend on several components at once, which, it seemed to me, could ultimately lead to a chaos of components and their dependencies.  When you have a strict one-to-many relationship (component and its subcomponents), then it is safer and more obvious.  In addition, by default, all dependencies of the parent are accessible to the subcomponent, which is also more convenient. <br><br>  <b>Why for every feature your skoup?</b> <br>  Because then I proceeded from the considerations that each feature is some kind of life-cycle of its own, which is not the same as the others, so it is logical to create your own scop.  There is one more point for many meanings, which I will mention below. <br><br>  Since we are talking about Dagger 2 in the Clean section, I‚Äôll also mention the moment the dependencies were delivered.  Presenters, Interactors, Repositories and other dependency auxiliary classes were delivered through the constructor.  In tests, we then substitute stubs or moks through the designer and calmly test our class. <br>  The closure of the dependency graph usually occurs in the activation, fragments, sometimes receivers and services, in general, in the root places from which the android can start something.  The classic situation is when an activit is created for a feature, a feature component starts and lives in an activit, and there are three screens in the feature itself that are implemented in three fragments. <br><br>  So, everything seems logical.  But as always, life makes its own adjustments. <br><br><h2>  Life problems </h2><br><h3>  Example task </h3><br>  Let's look at a simple example from our application.  We have the Scanner feature and the Antitheft feature.  In both features there is a cherished "Buy" button.  Moreover, ‚ÄúBuy‚Äù is not just a request, but also a lot of different logic related to the purchase process.  This is pure business logic with some dialogs for immediate purchase.  That is, there is quite a separate feature - Purchase (Purchase).  Thus, in two features we need to enable the third feature. <br>  From the point of view of ui and navigation, we have the following picture.  The main screen starts up with two buttons: <br><img src="https://habrastorage.org/webt/ps/1o/qj/ps1oqjtlzdybdcj21pokcadin8u.png"><br><br>  By clicking on these buttons we get to the feature of the Scanner or Anti-Theft. <br>  Consider the feature of the Scanner: <br><img src="https://habrastorage.org/webt/p5/2g/yw/p52gywypiko82skvl0mn90hd5wq.png"><br><br>  By clicking on ‚ÄúStart antivirus scanning‚Äù, some scanning work is done, by clicking on ‚ÄúBuy me‚Äù we just want to buy, that is, we pull the Shopping feature, well, and by ‚ÄúHelp‚Äù we get on a simple screen with help. <br>  Antivirus feature looks almost the same. <br><br><h3>  Potential solutions </h3><br>  How do we implement this example in terms of DI?  There are several options. <br><br><h4>  First option </h4><br>  The feature of the purchase to allocate an <i><b>independent component</b></i> , depending only on the <i>AppComponent</i> . <br><img src="https://habrastorage.org/webt/ia/aq/t2/iaaqt2fi01u1lvjixbn9uspxgyi.png"><br><br>  But then we are faced with a problem: how to inject dependencies on two different graphs (components) into one class right away?  Only through dirty crutches, which, of course, is to myself. <br><br><h4>  Second option </h4><br>  We select feature of purchase in the subcomponent depending on AppComponent.  And to make the components of the Scanner and Anti-Virus subcomponents already from the Purchase component. <br><img src="https://habrastorage.org/webt/wh/sh/y3/whshy3v3buimdjy2sfo6w1de3ys.png"><br><br>  But, as you understand, such situations can be quite a lot in applications.  This means that the depth of dependencies of components can be truly enormous and complex.  And such a graph will be more confusing than to make your application more slender and understandable. <br><br><h4>  Third option </h4><br>  We <b>do not select the feature of the</b> purchase <b>in a separate component, but in a separate Dagger module</b> .  Further two ways are possible. <br><br>  <b>First way</b> <br>  Let us set all dependencies on the features of the Shopping Cart <i>Singleton</i> and connect to the <i>AppComponent</i> . <br><img src="https://habrastorage.org/webt/gx/wb/3h/gxwb3hokdqdrrcypwykypnym0n8.png"><br><br>  The option is popular, but it leads to bloating <i>AppComponent</i> .  As a result, it expands in size, contains all the classes of the application, and the whole point of using Dagger is reduced only to more convenient delivery of dependencies to the classes - through the fields or the designer, and not through the singletons.  In principle, this is DI, but we miss architectural moments, and it turns out that everyone knows about everyone. <br>  In general, at the beginning of the path, if you do not know where to include a class, to which feature, then it is easier to make it global.  This is quite common when working with Legacy and trying to bring at least some kind of architecture there, plus you don‚Äôt know all the code well.  And there really eyes run, and these actions are justified.  The error is that when everything is more or less looming, no one wants to take on this <i>AppComponent</i> . <br><br>  <b>Second way</b> <br>  This is the reduction of all features to a single skoupu, for example <i>PerFeature</i> . <br><img src="https://habrastorage.org/webt/pm/5u/og/pm5uogvwcybvetc4nrfekteyqy4.png"><br><br>  Then we can connect the Dagger Shopping module to the necessary components easily and simply. <br>  It seems convenient.  But architecturally it turns out not in isolation.  The features of the Scanner and Anti-Vigor know absolutely everything about the Purchase feature, all its offal.  By negligence, something may be involved.  That is, Shopping features do not have a clear API, the border between features is blurry, and there is no clear contract.  This is bad.  Well, in multi-modular gredlovuyu will be hard then. <br><br><h3>  Architectural pain </h3><br>  Frankly, for a long time I used the <b>third option. The first way</b> .  This was a necessary measure when we began to gradually transfer our legacy to normal rails.  But, as I mentioned, with this approach, your features begin to mix up a bit.  Everyone can know about everyone, about the implementation details and this is all.  And the swelling of <i>AppComponent</i> clearly indicated that something needs to be done. <br>  By the way, with the unloading, it is <i>AppComponent</i> that the <b>third option</b> would help well <b>. The second way</b> .  But here knowledge about implementations and mixing of features will not disappear anywhere.  Well and clear business, reuse of features between applications would be rather uneasy business. <br><br><h3>  Intermediate conclusions </h3><br>  So, what do we want in the end?  What problems do we want to solve?  Let's go straight through the points, starting from the DI and moving on to the architecture: <br><br><ul><li>  Convenient DI mechanism, which allows using features within other features (in our example, we want to use the Purchases feature as part of Scanner and Anti-Theft), without co-costing and pain. </li><li>  The finest AppComponent. </li><li>  Features do not need to know about the implementation of other features. </li><li>  Fichi should not be available by default to anyone, I want to have some kind of strict control mechanism. </li><li>  It is possible to give a feature to another application with a minimum number of gestures. </li><li>  Logical transition to multi-modularity and best practices in this transition. </li></ul><br>  I specifically said about multi-modality only at the very end.  We will reach it, we will not get ahead. <br><br><h2>  "Life in a new way" </h2><br>  Now we will try to gradually implement the wishes mentioned above. <br>  Go! <br><br><h3>  DI Improvements </h3><br>  Let's start with the same DI. <br><br><h4>  Rejection of a large number of scopes </h4><br>  As I wrote above, before my approach was this: for every feature, your scop.  In fact, there are no special profits from this.  Just get a large number of scopes and a certain amount of headache. <br>  Such a chain is quite enough: <i>Singleton</i> - <i>PerFeature</i> - <i>PerScreen</i> . <br><br><h4>  Waiver of Subcomponents in favor of Component dependencies </h4><br>  Already more interesting moment.  With <i>Subcomponents,</i> you seem to have a more strict hierarchy, but at the same time, your hands are completely tied up and there is no possibility to somehow maneuver.  In addition, <i>AppComponent</i> knows about all the features, and you also get a huge generated class <i>DaggerAppComponent</i> . <br>  With <i>Component dependencies</i> you get one super cool advantage.  In component dependencies, you can specify <b>not pure components, but pure interfaces</b> (thanks to Denis and Volodya).  Because of this, you can substitute any implementation of the interface, Dagger will eat everything.  Even if this implementation is a component with the same script: <br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>( dependencies = FeatureDependencies.class, modules = FeatureModule.class ) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } public interface FeatureDependencies { SomeDependency someDependency(); } @Component( modules = AnotherFeatureModule.class ) @PerFeature public abstract class AnotherFeatureComponent implements FeatureDependencies { // ... }</span></span></code> </pre> <br><br><h3>  From DI improvements to better architecture </h3><br>  Let's repeat the definition of features.  <b>A feature</b> is a logically complete, maximally independent program module that solves a specific user problem, with clearly defined external dependencies, and which is relatively easy to reuse in another program.  One of the key expressions in the definition of a feature is ‚Äúwith clearly defined external dependencies‚Äù.  Therefore, let's all that we want from the outside world for the features will be described in a special interface. <br>  Here, let‚Äôs say, the interface of external dependencies of the Purchase feature: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  Or the external dependency interface features of the Scanner: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">DbClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">HttpClientApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">httpClient</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">SomeUtils </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someUtils</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//       PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  As already mentioned in the section on DI, dependencies can be implemented by anyone and in any way, these are pure interfaces, and our features are freed from this extra knowledge. <br><br>  Another important component of the ‚Äúclean‚Äù feature is the presence of a clear api, according to which the outside world can refer to the feature. <br>  Here are the features of Shopping: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PurchaseFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">PurchaseInteractor </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">purchaseInteractor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  That is, the outside world can get <i>PurchaseInteractor</i> and through it try to make a purchase.  Actually, above, we saw that the Scanner needed a <i>PurchaseInteractor</i> to make a purchase. <br><br>  But api features Scanner: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureApi</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ScannerStarter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scannerStarter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br>  And immediately bring the interface and implementation of <i>ScannerStarter</i> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerStarter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScannerStarterImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span><span class="hljs-function"> </span></span>{ Class&lt;?&gt; cls = ScannerActivity.class; Intent intent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, cls); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); } }</code> </pre><br>  It's more interesting here.  The fact is that the scanner and anti-virus are quite closed and isolated features.  In my example, these features are launched on separate Activiti, with their own navigation, etc. That is, we simply need to start Activiti here.  Activity dies - dies and feature.  You can work on the principle of ‚ÄúSingle Activity‚Äù, and then through the app, transfer, say, to the FragmentManager and any callback through which the feature reports that it has ended.  There are many variations. <br>  We can also say that such features as Scanner and Anti-Theft, we are entitled to consider as independent applications.  Unlike the features of Shopping, which is a feature-addition to something and by itself somehow can not really exist.  Yes, it is independent, but it is a logical addition to other features. <br><br>  As you might guess, there must be some point that links the app, its implementation and the necessary features of dependence.  This point is the Dagger component. <br><div class="spoiler">  <b class="spoiler_title">An example of the components of the features of the Scanner:</b> <div class="spoiler_text"><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = { ScannerFeatureModule.class, ScreenNavigationModule.class <span class="hljs-comment"><span class="hljs-comment">// ScannerFeatureDependencies - api    }, dependencies = ScannerFeatureDependencies.class) @PerFeature // ScannerFeatureApi - api   public abstract class ScannerFeatureComponent implements ScannerFeatureApi { private static volatile ScannerFeatureComponent sScannerFeatureComponent; //   public static ScannerFeatureApi initAndGet( ScannerFeatureDependencies scannerFeatureDependencies) { if (sScannerFeatureComponent == null) { synchronized (ScannerFeatureComponent.class) { if (sScannerFeatureComponent == null) { sScannerFeatureComponent = DaggerScannerFeatureComponent.builder() .scannerFeatureDependencies(scannerFeatureDependencies) .build(); } } } return sScannerFeatureComponent; } //           public static ScannerFeatureComponent get() { if (sScannerFeatureComponent == null) { throw new RuntimeException( "You must call 'initAndGet(ScannerFeatureDependenciesComponent scannerFeatureDependenciesComponent)' method" ); } return sScannerFeatureComponent; } //    (   ) public void resetComponent() { sScannerFeatureComponent = null; } public abstract void inject(ScannerActivity scannerActivity); //         Moxy public abstract ScannerScreenComponent scannerScreenComponent(); }</span></span></code> </pre><br></div></div><br>  I think nothing new for you. <br><br><h3>  Transition to multi-modularity </h3><br>  So, we managed to clearly define the boundaries of the features through the API of its dependencies and the external API.  We also figured out how to turn it all in Dagger.  And now we come to the next logical and interesting step - the division into modules. <br>  Immediately open the <a href="https://github.com/matzuk/Clean-multimodel-arch">test case</a> - it will go easier. <br>  Let's look at the picture in general: <br><img src="https://habrastorage.org/webt/qq/uw/bg/qquwbgerknuk95cjefxfxqserxi.png"><br>  And look at the structure of the example packages: <br><img src="https://habrastorage.org/webt/cs/_a/4a/cs_a4ap7km-ivyxwzk615blftby.png"><br>  And now let's talk carefully about each item. <br><br>  First of all, we see four large blocks: <b>Application</b> , <b>API</b> , <b>Impl</b> and <b>Utils</b> .  In the <i>API</i> , <i>Impl</i> and <i>Utils,</i> you can notice that all modules start either at <b>core-</b> or at <b>feature-</b> .  Let's first talk about them. <br><br><h4>  Core and feature separation </h4><br>  I divide all modules into two categories: <i>core-</i> and <i>feature-</i> . <br>  In <i>feature-</i> , as you might guess, our features.  In the <b>core, there</b> are such things as utilities, work with the network, database, etc. But there are no interface features.  And the <i>core</i> is not a monolith.  I am for splitting the <i>core module</i> into logical pieces and against loading features with some other interfaces. <br>  In the module name, we first write <i>core</i> or <i>feature</i> .  Next in the module name is a logical name ( <i>scanner</i> , <i>network</i> , etc.). <br><br><h4>  Now about four big blocks: Application, API, Impl and Utils </h4><br>  <b>API</b> <br>  Each <i>feature-</i> or <i>core-module is</i> divided into <i>API</i> and <i>Impl</i> .  The <i>API</i> is an external api through which you can access the feature or core.  Only this, and nothing more: <br><img src="https://habrastorage.org/webt/8_/gz/0c/8_gz0ckdfivle1avlexldnj_mdc.png"><br>  In addition, the <i>api-module</i> does not know anything about anyone, it is an absolutely isolated module. <br><br>  <b>Utils</b> <br>  The only exception to the rule above can be considered some kind of quite utility things that are meaningless to break into api and implementation. <br><br>  <b>Impl</b> <br>  Here we have a sub-division on <i>core-impl</i> and <i>feature-impl</i> . <br>  Modules in <i>core-impl are</i> also completely independent.  Their only dependency is the <i>api-module</i> .  For example, take a look at the <i>core.db-impl</i> module <i>build.gradle</i> : <br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// bla-bla-bla dependencies { implementation project(':core-db-api') // bla-bla-bla }</span></span></code> </pre><br>  Now about <i>feature-impl</i> .  There is already the lion's share of application logic.  The modules of the <i>feature-impl group</i> may know about the modules of the <i>API</i> group or <i>Utils</i> , but they definitely don‚Äôt know anything about the other modules of the <i>Impl</i> group. <br>  As we remember, all external dependencies of a feature are accumulated in the external dependencies api.  For example, for a scan feature, this api looks like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Accordingly, the <i>build.gradle feature-scanner-impl</i> will be like this: <br><pre> <code class="hljs pgsql">// bla-bla-bla dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla-bla-bla }</code> </pre><br>  You may ask, why is api external dependencies not in the api module?  The fact is that this is an implementation detail.  That is, it is a specific implementation that needs some specific dependencies.  For the Add-on Scanner, add it here: <br><img src="https://habrastorage.org/webt/8y/7o/fj/8y7ofjd9oxd344hzqua8xcqtdci.png"><br><br>  <b>A small architectural retreat</b> <br>  Let's digest all of the above and clarify for ourselves some of the architectural aspects of <i>feature -...- impl-modules</i> and their dependencies on other modules. <br>  I met two of the most popular addiction patterns for a module: <br><br><ul><li>  The module can know about anyone.  There are no rules.  There is nothing to even comment on. </li><li>  Modules only know about the <i>core module</i> .  And in the <i>core module</i> all interfaces of all features are concentrated.  This approach is not very appealing to me, since there is a risk of turning the <i>core</i> into another garbage bin.  In addition, if we want to transfer our module to another application, we will need to copy these interfaces to another application, and also place it in the <i>core</i> .  By itself, the blunt copy-paste of interfaces is not very attractive and reusable in the future, when the interfaces can be updated. </li></ul><br>  In our example, I advocate for knowledge of api modules and api only (well, utils-groups).  Fichi absolutely do not know anything about the implementation. <br><br>  But it turns out that features can know about other features (via api, of course) and run them.  Do not end up with porridge? <br>  Fair remark.  It's hard to work out some kind of super-clear rules.  In everything there should be a measure.  We have already touched on this issue a little bit, dividing the features into independent (Scanner and Anti-Theft) - completely independent and separate, and features ‚Äúin context‚Äù, that is, always launched within something (Purchase) and usually implying business logic without ui.  That is why the Scanner and Anti-Theft are aware of Purchases. <br>  Another example.  Imagine that in Anti-Theft there is such a thing as wipe data, that is, absolutely all data cleared from the phone.  There are a lot of business logic, ui, it is completely isolated.  Therefore, it is logical to allocate wipe data into a separate feature.  And then the fork.  If wipe data is always launched only from Anti-Theft and is always present in Anti-Theft, then it is logical that Anti-Theft would know about wipe data and launch it on its own.  And the accumulating module, the app, would then know only about Anti-Theft.  But if wipe data can be run somewhere else or is not always present in Anti-Theft (that is, it can be different in different applications), then it is logical that Anti-Theft does not know about this feature and just say something external (via Router, through some kind of callback, it does not matter) that the user pressed such a button, and what to launch under it is a matter of the Consumer Anti-theft feature (a specific application, a specific app). <br><br>  Also there is an interesting question about transferring features to another application.  If we, for example, want to transfer the Scanner to another application, then we must also transfer in addition to the modules <i>: feature-scanner-api</i> and <i>: feature-scanner-impl</i> and the modules on which the scanner depends ( <i>: core-utils,: core-network- api,: core-db-api,: feature-purchase-api</i> ). <br>  Yes, but!  Firstly, all your api-modules are completely independent, and there are only interfaces and data models.  No logic.  And these modules are clearly logically separated, and <i>: core-utils</i> is usually a common module for all applications. <br>  Secondly, you can build api-modules in the form of aar and deliver them via maven to another application, or you can connect them in the form of a guitar sub-module.  But you will have versioning, there will be control, there will be integrity. <br>  Thus, the reuse of the module (more precisely, the module-implementation) in another application looks much simpler, clearer and safer. <br><br><h4>  Application </h4><br>  It seems that we have a slender and clear picture with features, modules, their dependencies, and that‚Äôs all.  Now we come to a climax - this is a combination of api and their implementations, the substitution of all the necessary dependencies, and so on, but now from the point of view of the graded modules.  The point of connection is usually the <i>app</i> itself. <br>  By the way, in our example such point is still the <i>feature-scanner-example</i> .  The above approach allows you to run each of its features as a separate application, which greatly saves assembly time during active development.  Beauty! <br><br>  Consider, for a start, how everything through the <i>app</i> happens on the example of the already beloved Scanner. <br><div class="spoiler">  <b class="spoiler_title">Quickly recall the feature:</b> <div class="spoiler_text">  Api external dependencies Scanner is: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// core-db-api DbClientApi dbClient(); // core-network-api HttpClientApi httpClient(); // core-utils SomeUtils someUtils(); // feature-purchase-api PurchaseInteractor purchaseInteractor(); }</span></span></code> </pre><br>  Therefore <i>: feature-scanner-impl</i> depends on the following modules: <br><pre> <code class="hljs pgsql">// bla-bla-bla dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) // bla-bla-bla }</code> </pre><br></div></div><br>  Based on this, we can create a Dagger component implementing the api external dependencies: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(dependencies = { CoreUtilsApi.class, CoreNetworkApi.class, CoreDbApi.class, PurchaseFeatureApi.class }) <span class="hljs-meta"><span class="hljs-meta">@PerFeature</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependenciesComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ScannerFeatureDependencies</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  I have placed this interface in <i>ScannerFeatureComponent</i> for convenience: <br><pre> <code class="hljs pgsql">@Component(modules = { ScannerFeatureModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, ScreenNavigationModule.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }, dependencies = ScannerFeatureDependencies.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>) @PerFeature <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> abstract <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ScannerFeatureComponent implements ScannerFeatureApi { // bla-bla-bla @Component(dependencies = { CoreUtilsApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreNetworkApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, CoreDbApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, PurchaseFeatureApi.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> }) @PerFeature interface ScannerFeatureDependenciesComponent extends ScannerFeatureDependencies { } }</code> </pre><br><br>  Now App.  App knows about all the modules it needs ( <i>core-, feature-, api, impl</i> ): <br><pre> <code class="hljs pgsql">// bla-bla-bla dependencies { implementation project(<span class="hljs-string"><span class="hljs-string">':core-utils'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-db-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':core-network-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-scanner-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-antitheft-impl'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-api'</span></span>) implementation project(<span class="hljs-string"><span class="hljs-string">':feature-purchase-impl'</span></span>) // bla-bla-bla }</code> </pre><br>  Next, create an auxiliary class.  For example, <i>FeatureProxyInjector</i> .  It will help to correctly initialize all the components, and it is through this class that we will turn to hardware.  Let's see how the feature of the Scanner is initialized in us: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeatureProxyInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// another... public static ScannerFeatureApi getFeatureScanner() { return ScannerFeatureComponent.initAndGet( DaggerScannerFeatureComponent_ScannerFeatureDependenciesComponent.builder() .coreDbApi(CoreDbComponent.get()) .coreNetworkApi(CoreNetworkComponent.get()) .coreUtilsApi(CoreUtilsComponent.get()) .purchaseFeatureApi(featurePurchaseGet()) .build() ); } }</span></span></code> </pre><br>  Outward, we return the features interface ( <i>ScannerFeatureApi</i> ), and inside we just initialize the entire dependency graph of implementation (via the <i>ScannerFeatureComponent.initAndGet (...)</i> method). <br>  <i>DaggerPurchaseComponent_PurchaseFeatureDependenciesComponent</i> is the <i>Dagger</i> -generated implementation of the <i>PurchaseFeatureDependenciesComponent</i> , which we discussed above, where we substitute the implementation of the api modules into the builder. <br>  That's all the magic.  Look again at the <a href="https://github.com/matzuk/Clean-multimodel-arch">example</a> . <br><br>  By the way, about <i>example</i> .  In <i>example,</i> we must also satisfy all external dependencies <i>: feature-scanner-impl</i> .  But since this is an example, we can substitute dummy classes. <br>  How will it look like: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies public class ScannerFeatureDependenciesFake implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientFake(); } @Override public HttpClientApi httpClient() { return new HttpClientFake(); } @Override public SomeUtils someUtils() { return CoreUtilsComponent.get().someUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorFake(); } } //  -  Application-   public class ScannerExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); ScannerFeatureComponent.initAndGet( // ,     =) new ScannerFeatureDependenciesFake() ); } }</span></span></code> </pre><br>  And the very feature of the Scanner in <i>example is</i> run through the manifest so as not to fence off additional empty activations: <br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:android</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">package</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner_example"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">".ScannerExampleApplication"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:allowBackup</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:icon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/app_name"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:roundIcon</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@mipmap/ic_launcher_round"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:supportsRtl</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:theme</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@style/AppTheme"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--   --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"com.example.scanner.presentation.view.ScannerActivity"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">action</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.action.MAIN"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">category</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.intent.category.LAUNCHER"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">intent-filter</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">activity</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">application</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">manifest</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><h2>  Algorithm of transition from monomodularity to multimodularity </h2><br>  Life is a harsh thing.  And the reality is that we all work with Legacy.  If someone is sawing a new project right now, where you can refill everything at once, then I envy you, bro.  But I have not, and that guy is also not so =). <br><br>  How to translate your application into multiple modules?  I heard mostly about two options. <br>  The first.  Splitting the application into modules here and now.  True, your project may not be ready for a month or two =). <br>  Second.  Try to pull features out gradually.  But at the same time all sorts of dependencies of these features stretch.  And here the most interesting begins.  The code of dependencies can be pulled by another code, the whole thing is migrating to the <i>common module</i> , to the <i>core module</i> and back, and so on in a circle.  As a result, pulling one feature can entail working with a good half of the application.  And again at the beginning of your project will not be collected a decent amount of time. <br><br>  I am in favor of a gradual transfer of the application to multi-modularity, since in parallel we still need to cut new features.  The key idea is that <b>if your module needs some of the dependencies, you should not immediately physically drag the code into the modules</b> .  Let's look at the module removal algorithm using the example of a scanner: <br><br><ul><li>  Create an apfich, put it in a new api-module.  That is, to completely create a module <i>: feature-scanner-api</i> with all interfaces. </li><li>  Create <i>: feature-scanner-impl</i> .  In this module, physically transfer all the code related to the feature.  Everything that your feature depends on, the studio will immediately highlight. </li><li>  Identify external dependencies features.  Create the appropriate interfaces.  These interfaces are divided into logical api-modules.  That is, in our example, create the modules <i>: core-utils,: core-network-api,: core-db-api,: feature-purchase-api</i> with the appropriate interfaces. <br>  I advise all the same to immediately invest in the name and meaning of the modules.  It is clear that over time, interfaces and modules may be a little shuffled, collapsed, etc., this is normal. </li><li>  Create external dependencies ( <i>ScannerFeatureDependencies</i> ).  Depending <i>: feature-scanner-impl</i> register recently created api-modules. </li><li>  Since in the <i>app</i> we have everything legacy, that's what we are doing.  In the <i>app,</i> we include all modules created for the feature (api-module features, impl-module features, api-modules of external feature dependencies). <br>  <b>Super important moment</b> .  Next, in the <i>app,</i> we create the implementation of all necessary feature dependency interfaces (Scanner in our example).  These implementations will be rather just proxy from your dependencies to the current implementation of these dependencies in the project.  When you initialize a feature, you substitute implementation data. <br>  Difficult words, want an example?  So he is already there!  In fact, something similar is already in the feature-scanner-example.  Once again I will give it a little adapted code: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//     ScannerFeatureDependencies  app- public class ScannerFeatureDependenciesLegacy implements ScannerFeatureDependencies { @Override public DbClientApi dbClient() { return new DbClientLegacy(); } @Override public HttpClientApi httpClient() { // -  // ,      return NetworkFabric.createHttpClientLegacy(); } @Override public SomeUtils someUtils() { return new SomeUtils(); } @Override public PurchaseInteractor purchaseInteractor() { return new PurchaseInteractorLegacy(); } } //  -   ScannerFeatureComponent.initAndGet( new ScannerFeatureDependenciesLegacy() );</span></span></code> </pre><br>  That is the main message here is this.  Let all the external code necessary for the feature live in the <i>app</i> , as well as lived.  And the feature itself will already work with it in a normal way, through api (meaning api dependencies and api-modules).  In the future, the implementation will gradually move to the modules.  But on the other hand, we will avoid an endless game of dragging from the module to the module the necessary external code for the feature.  We can move in clear iterations! </li><li>  Profit </li></ul><br>  Here is a simple, but working algorithm that allows you to move to your goal step by step. <br><br><h3>  Additional tips </h3><br>  <b>How big / small should features be?</b> <br>  It all depends on the project, etc.  But at the beginning of the transition to multi-modularity, I advise you to split up into large pieces.  Further, if necessary, you will select from these modules more modules.  But do not shrink.  Do not do this: one / several classes = one module. <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clean app-module</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When switching to a multi-module </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we will have a rather large one, and from there your own selected features will be twitching too. It is possible that in the course of the work you will have to make edits to it legacy, something to finish there, well, or you just have a release, and you are not up to cuts into modules. In this case, you want the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and with it all legacy, to know about the selected features only through the API, no knowledge about the implementation. But after all </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in fact, unites </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">api-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">impl-modules</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and therefore </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> knows about all. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, you can create a special module </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: adapter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which is exactly the connecting point api and impl, and then the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will only know about api. I think the idea is clear. You can see an example in the </font></font><a href="https://github.com/matzuk/Clean-multimodel-arch/tree/clean_app"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clean_app</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> branch </font><font style="vertical-align: inherit;">. I will add that with Moxy, or rather MoxyReflector, there are some problems when splitting into modules, because of which I had to create another additional module </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: stub-moxy-java</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Light pinch of magic, so far without it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only amendment. This will only work if your feature and corresponding dependencies have already been physically moved to other modules. If you learned a feature, but the dependencies still live in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as in the algorithm above, this will not work.</font></font><br><br><h2>  Afterword </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The article turned out rather big. </font><font style="vertical-align: inherit;">But I hope that it will really help you in dealing with mono-modularity, awareness of how it should be, and how to make friends with DI. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are interested in plunging into a problem with assembly speed, how to measure everything, then I recommend the reports of Denis Neklyudov and Zhenya Suvorov (Mobius 2018 Piter, videos are not publicly available yet). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About Gradle. </font><font style="vertical-align: inherit;">The difference between api and implementation in the gradle was perfectly shown by </font></font><a href="https://www.youtube.com/watch%3Fv%3DpMEAD6jjbaI%26feature%3Dyoutu.be"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vova Tagakov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you want to reduce the multi-modulus boilerplate, you can start here with </font></font><a href="https://proandroiddev.com/reducing-boilerplate-in-gradle-multi-module-projects-2ff2dde5bf95"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I would welcome comments, amendments, as well as likes! </font><font style="vertical-align: inherit;">All clean code!</font></font></div><p>Source: <a href="https://habr.com/ru/post/422555/">https://habr.com/ru/post/422555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422545/index.html">Ways to synchronize browser tabs</a></li>
<li><a href="../422547/index.html">To eliminate Specter and Meltdown, you may have to create a completely new type of processor.</a></li>
<li><a href="../422549/index.html">Corda: Kotlin</a></li>
<li><a href="../422551/index.html">How to steal money from a contactless card and Apple Pay</a></li>
<li><a href="../422553/index.html">Official browser extension Mega stole data and cryptocurrency of file sharing users</a></li>
<li><a href="../422561/index.html">How Yandex used computer vision to improve the quality of video broadcasts. DeepHD technology</a></li>
<li><a href="../422565/index.html">Friday's Skillbox webinars: everything for programmers and designers</a></li>
<li><a href="../422569/index.html">Hourly, time tracking app</a></li>
<li><a href="../422571/index.html">Parallelization of tasks with dependencies - example on .NET</a></li>
<li><a href="../422573/index.html">Reverse engineering rendering "The Witcher 3"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>