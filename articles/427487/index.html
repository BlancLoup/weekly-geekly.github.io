<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing configuration for Java developers: practical experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With tests for code, everything is clear (well, at least that they need to be written). With tests for configuration, things are much less obvious, st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing configuration for Java developers: practical experience</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/9o/r3/24/9or324raqccmfaeghrlyaagxmja.jpeg"><br><br>  With tests for code, everything is clear (well, at least that they need to be written).  With tests for configuration, things are much less obvious, starting from their very existence.  Does someone write them?  Is this important?  Is it difficult?  What kind of results can be achieved with their help? <br><br>  It turns out that this is also very useful, it is very easy to start doing this, and there are many nuances in testing the configuration.  What exactly - is written under the cut on the basis of practical experience. <br><a name="habracut"></a><br>  <i>The material is based on the interpretation of the report by <b>Ruslan <a href="https://habr.com/users/cheremin/" class="user_link">cheremin</a> Cheremin</b> (Java developer at Deutsche Bank).</i>  <i>Further - speech from the first person.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/Tk_nmV-mWOA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  My name is Ruslan, I work at Deutsche Bank.  We start with this: <br><br><img src="https://habrastorage.org/webt/vg/xr/rq/vgxrrqh1taa98cujjske1r5usa4.jpeg"><br><br>  There is a lot of text here, from afar it may seem that it is Russian.  But this is not true.  This is a very ancient and dangerous language.  I have translated into simple Russian: <br><br><ul><li>  All characters are fictional. </li><li>  Use with caution </li><li>  Funeral at his own expense </li></ul><br><br>  I will describe briefly what I‚Äôm going to talk about today.  Suppose we have the code: <br><br><img src="https://habrastorage.org/webt/qv/ip/gd/qvipgdp4a8n1bjo79z29aicqmik.jpeg"><br><br>  That is, initially we had some kind of task, we write code to solve it, and he presumably earns us money.  If this code for some reason does not work correctly, it solves the wrong problem and earns us the wrong money.  Business does not like that kind of money - they look bad in financial reports. <br><br>  Therefore, for our important code, we have tests: <br><br><img src="https://habrastorage.org/webt/0e/9g/-k/0e9g-klbunmtoyvlhf9q0-vl-4o.jpeg"><br><br>  Usually there is.  Now, probably, almost everyone has it.  Tests check that the code solves the correct problem and earns the right money.  But the service is not limited to the code, and next to the code there is also a configuration: <br><br><img src="https://habrastorage.org/webt/z7/75/sq/z775sqxlsy1nha5hrclznn6biq0.jpeg"><br><br>  At least in almost all the projects where I participated, such a configuration was, in one form or another.  (I can only remember a couple of cases from my early UI-years, where there were no configuration files, and everything was configured via UI) In this configuration, there are ports, addresses, and algorithm parameters. <br><br><h2>  Why is configuration important to test? </h2><br>  That's the thing: configuration errors harm the execution of the program no less than errors in the code.  They can also force the code to perform an incorrect task - and then look above. <br><br>  And finding errors in the configuration is even more difficult than in the code, since the configuration is usually not compiled.  I cited property files as an example, there are various options in general (JSON, XML, someone stores in YAML), but it is important that none of this is compiled and, therefore, not checked.  If you accidentally sealed in a Java file - most likely, it simply will not pass compilation.  A random typo in the property does not excite anyone, she will go to work. <br><br>  And the IDE does not highlight errors in the configuration either, because it knows about the format (for example) of the property-files only the most primitive: what should be the key and the value, and between them "equal", a colon or a space.  But the fact that the value should be a number, network port or address - IDE does not know anything. <br><br>  And even if you test the application in UAT or in a staging environment, this also does not guarantee anything.  Because the configuration, as a rule, is different in each environment, and in UAT you tested only the UAT configuration. <br><br>  Another subtlety is that, even in production, configuration errors sometimes do not appear immediately.  The service may not start at all - and this is still a good script.  But it can start, and work for a very long time - until the moment X, when exactly that parameter is needed, in which there is an error.  And here you find that the service, which recently even barely changed, suddenly stopped working. <br><br>  After all that I said, it would seem that testing configurations should be a hot topic.  But in practice it looks something like this: <br><br><img src="https://habrastorage.org/webt/9o/r3/24/9or324raqccmfaeghrlyaagxmja.jpeg"><br><br>  At least, we had it so - until a certain point.  And one of the tasks of my report is that you, too, should stop looking like this.  I hope that I can push you to this. <br><br>  Three years ago, Andrei Satarin worked for QA with us at Deutsche Bank, on my team.  It was he who brought the idea of ‚Äã‚Äãtesting configurations - that is, he simply took and committed the first such test.  Six months ago, at the previous Heisenbug, he gave a <a href="https://www.youtube.com/watch%3Fv%3DKaeEjsAjV6A">talk</a> about configuration testing, as he sees it.  I recommend to look, because there he gave a broad view of the problem: both from scientific articles and from the experience of large companies that faced configuration errors and their consequences. <br><br>  My report will be narrower - on practical experience.  I will talk about what problems I, as a developer, faced when I wrote configuration tests, and how I solved these problems.  My decisions may not be the best decisions, these are not best practices - this is my personal experience, I tried not to make broad generalizations. <br><br>  General plan of the report: <br><br><ul><li>  "What you can catch before lunch on Monday": simple, useful examples. </li><li>  ‚ÄúMonday, two years later‚Äù: where and how can you do better. </li><li>  Support for refactoring configuration: how to achieve a dense coverage;  software configuration model. </li></ul><br><br>  The first part is motivational: I will describe the simplest tests that started it all.  There will be a large variety of examples.  I hope that at least one of them is resonating with you, that is, you will see some similar problem in yourself, and its solution. <br><br>  In the first part, the tests themselves are simple, even primitive - from an engineering point of view there is no rocket science.  But exactly that they can be done quickly - especially valuable.  This is such an ‚Äúeasy entry‚Äù to configuration testing, and it is important because there is a psychological barrier before writing these tests.  And I want to show that ‚Äúthis can be done‚Äù: well, we did it, we did it well, and so far no one has died, we have been living for three years already. <br><br>  The second part is about what to do after.  When you wrote a lot of simple tests - the question of support arises.  Some of them are beginning to fall, you understand the errors that they supposedly highlighted.  It turns out that this is not always convenient.  And there is the question of writing more complex tests - because you have already covered simple cases, you want something more interesting.  And here again there are no best practices, I will simply describe some solutions that have worked for us. <br><br>  The third part is about how testing can support refactoring in a fairly complex and confusing configuration.  Again a case study - how we did it.  From my point of view, this is an example of how configuration testing can be scaled to solve larger problems, and not just for plugging small holes. <br><br><h2>  Part 1. "So do - you can" </h2><br>  Now it is difficult to understand what was the first test configuration with us.  Andrew is sitting in the hall, he can say that I lied.  But it seems to me that it all started with this: <br><br><img src="https://habrastorage.org/webt/6t/dr/d8/6tdrd8-mwyj8otcngbcjsjqi3ge.jpeg"><br><br>  The situation is this: we have n services on the same host, each of them raises its JMX server on its port, exports some monitoring JMXs.  Ports for all services are configured in the file.  But the file takes several pages, and there are many other properties there - it often turns out that the ports of different services conflict.  It is easy to make a mistake.  Then everything is trivial: some service does not rise, it does not rise beyond it dependent on it - testers are furious. <br><br>  This problem is solved in several lines.  This test, which (I think) was our first, looked like this: <br><br><img src="https://habrastorage.org/webt/ka/ln/51/kaln51onx8-1yzdr2vq0ltcmegq.jpeg"><br><br>  There is nothing complicated in it: go to the folder where the configuration files are located, load them, parse as properties, filter the values ‚Äã‚Äãwhose name contains ‚Äújmx.port‚Äù, and check that all values ‚Äã‚Äãare unique.  No need to even convert values ‚Äã‚Äãto integer.  Presumably, there are only ports. <br><br>  My first reaction when I saw this was mixed: <br><br><img src="https://habrastorage.org/webt/ka/ln/51/kaln51onx8-1yzdr2vq0ltcmegq.jpeg"><br><br>  The first feeling: what is it in my beautiful unit tests?  Why we got into the file system? <br><br>  And then came the surprise: ‚ÄúWhat, was it possible?‚Äù <br><br>  I‚Äôm talking about this because it seems to have some kind of psychological barrier that prevents you from writing such tests.  Three years have passed since then, the project is full of such tests, but I often see that my colleagues, bumping into a configuration error made, do not write tests on it.  For the code, everyone is already accustomed to writing regression tests - so that the found error is no longer reproduced.  And for the configuration they don‚Äôt do that, something hinders.  There is some kind of psychological barrier with which to cope - so I mention such a reaction that you also learn from yourself if it appears. <br><br><img src="https://habrastorage.org/webt/ka/ln/51/kaln51onx8-1yzdr2vq0ltcmegq.jpeg"><br><br>  The following example is almost the same, but slightly modified - I removed all the ‚Äújmx‚Äù.  This time we check all the properties that are called ‚Äúsomething there-port‚Äù.  They must be integer values, and be a valid network port.  The Matcher validNetworkPort () hides our custom hamcrest Matcher, which checks that the value is above the range of system ports, below the range of ephemeral ports, and we know that some of the ports we have on the servers are pre-occupied - that‚Äôs their list is also hidden in this matcher. <br><br>  This test is still very primitive.  Note that there is no indication in it, what specific property we are testing - it is massive.  A single such test can test 500 properties with the name "... port", and verify that they are all integers, in the right range, with all the necessary conditions.  Once written, a dozen lines - that's all.  This is a very convenient feature; it appears because the configuration has a simple format: two columns, a key and a value.  Therefore, it can be so massively processed. <br><br>  Another example of the test.  What are we checking here? <br><br><img src="https://habrastorage.org/webt/7j/wt/wr/7jwtwr0zn93gy0fhfaqykbeyeyy.jpeg"><br><br>  He checks that real passwords do not leak into production.  All passwords should look something like this: <br><br><img src="https://habrastorage.org/webt/yg/4_/ft/yg4_ftjvkm_bhqqzmdxppafoaii.jpeg"><br><br>  You can write a lot of such tests for property files.  I will not give more examples - I do not want to repeat, the idea is very simple, then everything should be clear. <br><br>  ... and after writing a sufficient number of such tests, an interesting question emerges: what do we mean by configuration, where is its boundary?  We consider the property file as a configuration, we covered it - and what else can be covered in the same style? <br><br><h2>  What is considered a configuration </h2><br>  It turns out that there are a lot of text files in the project that are not compiled - at least in the normal build process.  They are not verified before execution on the server, that is, errors in them occur late.  All these files - with some stretch - can be called a configuration.  At least, they will be tested approximately equally. <br><br>  For example, we have a system of SQL patches that roll onto the database during the deployment process. <br><br><img src="https://habrastorage.org/webt/jz/bk/c7/jzbkc7m5zo0k6phy-9kuzvkqkam.jpeg"><br><br>  They are written for SQL * Plus.  SQL * Plus is a tool from the 60s, and it requires anything strange: for example, the end of the file must be on a new line.  Of course, people regularly forget to put the end of the line there, because they were not born in the 60s. <br><br><img src="https://habrastorage.org/webt/nr/oj/3w/nroj3wxkhriqqeqa-iwxwus0a0a.jpeg"><br><br>  And again, it is solved by the same dozen lines: we select all the SQL files, check that there is a trailing slash at the end.  Simple, convenient, fast. <br><br>  Another example of a ‚Äútext file‚Äù is crontabs.  Our crontab services start and stop.  They most often have two errors: <br><br><img src="https://habrastorage.org/webt/02/i0/ch/02i0chpobgao-lexobckwr5ffd4.jpeg"><br><br>  First, the schedule expression format.  It is not so difficult, but no one checks it before launch, so it is easy to put an extra space, comma and the like. <br><br>  Secondly, as in the previous example, the end of the file must also be on a new line. <br><br>  And all this is pretty easy to check.  About the end of the file is clear, and to check the schedule you can find ready-made libraries that parse cron expression.  Before the report I googled: there were at least six of them.  I found this six, and in general can be more.  When we wrote, we took the simplest of the found ones, because we did not need to check the contents of the expression, but only its syntactic correctness, in order for cron to load it successfully. <br><br>  In principle, you can wind up more checks - check that you start on the right day of the week, that you do not stop services in the middle of the working day.  But it turned out to be not so useful for us, and we did not bother. <br><br>  Another idea that works fine is shell scripts.  Of course, writing a full-featured bash script parser in Java is a pleasure for the brave.  But the bottom line is that a large number of these scripts is not a full-fledged bash.  Yes, there are bash-scripts, where the direct code-code, hell and hell, where they drop in once a year and, swearing, run away.  But a lot of bash scripts are the same configurations.  There are a number of system variables and environment variables that are set to the desired value, thereby configuring other scripts that use these variables.  And such variables are easy to grep from this bash file and check something about them. <br><br><img src="https://habrastorage.org/webt/5s/4d/z_/5s4dz_wtejguewyqrat5ipxa7by.jpeg"><br><br>  For example, check that JAVA_HOME is installed on each environment, or that some jni-library used by us is located in LD_LIBRARY_PATH.  Somehow we moved from one version of Java to another, and expanded the test: we checked that JAVA_HOME contains ‚Äú1.8‚Äù exactly on that subset of enviroment, which we gradually transferred to the new version. <br><br>  Here are a few examples.  Let you down on the first part of the findings: <br><br><ul><li>  Configuration tests are confusing at first, there is a psychological barrier.  But after overcoming it, there are many places in the application that are not covered by checks and can be covered. </li><li>  Then they are written <b>easily and cheerfully</b> : a lot of ‚Äúlow-hanging fruit‚Äù, which quickly give great benefits. </li><li>  Reduces the <b>cost of</b> detecting and correcting configuration errors.  Since these are essentially unit tests, you can run them on your computer, even before committing, this greatly reduces the Feedback Loop.  Many of them, of course, would be checked at the test deployment stage, for example.  And many would not be checked - if it is a production-configuration.  And so they are checked directly on the local computer. </li><li>  Give the second youth.  In the sense that there is a feeling that you can still test a lot of interesting things.  After all, the code is not so easy to find that you can test. </li></ul><br><br><h2>  Part 2. More complex cases </h2><br>  Let's move on to more complex tests.  After covering a large part of the trivial checks, like those shown here, the question arises: is it possible to check something more complicated? <br><br>  What does ‚Äúharder‚Äù mean?  The tests that I have just described have something like this: <br><br><img src="https://habrastorage.org/webt/er/an/sx/eransxujnuprewkr1lcrk1nweui.jpeg"><br><br>  They check something against one specific file.  That is, we go through the files, we apply to each check a certain condition.  This way you can check a lot, but there are more useful scripts: <br><br><ul><li>  A UI application connects to <b>its</b> environment server. </li><li>  All services of the same environment connect to <b>the same</b> management server. </li><li>  All services of the same environment use <b>the same</b> database. </li></ul><br><br>  For example, a UI application connects to its environment server.  Most likely, the UI and the server are different modules, if not projects at all, and they have different configurations, they are unlikely to use the same configuration files.  Therefore, it is necessary to link them so that all services of one environment are connected to one key management server through which commands are distributed.  Again, most likely, these are different modules, different services and generally different teams develop them. <br><br>  Or all services use the same database, the same - services in different modules. <br><br>  In fact, there is such a picture: a lot of services, each of them has its own structure of configs, you need to reduce and check something at the intersection: <br><br><img src="https://habrastorage.org/webt/tw/et/op/twetop-jheecrf02felhlhchnvi.jpeg"><br><br>  Of course, you can do exactly that: load one, the second, pull something out somewhere, paste it in the test code.  But you can imagine how big the code will be and how readable it will be.  We started with this, but then we realized how difficult it is.  How to do better? <br><br>  If you dream, as it were more convenient, then I planned that the test would look like I explain it in human language: <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachEnvironmentIsXXX</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Environment environment )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( Server server : environment.servers() ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( Service service : server.services() ) { Properties config = buildConfigFor( environment, server, service ); <span class="hljs-comment"><span class="hljs-comment">//‚Ä¶ check {something} about config } } }</span></span></code> </pre> <br>  For each environment, some condition is met.  To check this, you need to find a list of servers, a list of services from the environment.  Next, download configs and check something at the intersection.  Accordingly, I need such a thing, I called it Deployment Layout. <br><br><img src="https://habrastorage.org/webt/cs/um/3u/csum3u7sucokbnlydgulc18cdhs.jpeg"><br><br>  We need the ability from the code to get access to how the application is deployed: on which servers which services are placed, in which Environment - to get this data structure.  And based on it, I begin to load the configuration and process it. <br><br>  Deployment Layout is specific to each team and each project.  What I have drawn is a general case: usually there is a set of servers and services, a service sometimes has a set of config files, and not one.  Sometimes additional parameters are required, which are useful for tests, they have to be added.  For example, the rack in which the server is located may be important.  Andrei in his report gave an example, when it was important for their services that Backup / Primary services were necessarily in different racks - for his case, you will need to keep an indication of the rack in the deployment layout: <br><br><img src="https://habrastorage.org/webt/gj/oh/ip/gjohipszob-edpgkekfr1zvdfp0.jpeg"><br><br>  For our purposes, the server region is important, a specific data center, in principle, too, so that Backup / Primary is in different data centers.  These are all additional properties of servers, they are project-specific, but on the slide this is such a common denominator. <br><br>  Where to get the deployment layout?  It seems that in any large company there is an Infrastructure Management system, everything is described there, it is reliable, reliable and all that ... in fact, no. <br><br>  At least, my practice in two projects has shown that it is easier to hard-code first, and then, after three years ... leave it hard. <br><br>  We have been living with this project for three years now.  In the second, it seems, we will integrate with Infrastructure Management in a year, but all these years we have lived like this.  By experience, the task of integrating with IM makes sense to postpone in order to get ready-made tests as quickly as possible, which will show that they work and are useful.  And then it may turn out that this integration may not be so necessary, because the distribution of services across servers does not change so often. <br><br>  Zakhardkodit can literally like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Environment { PROD( PROD_UK_PRIMARY, PROD_UK_BACKUP, PROD_US_PRIMARY, PROD_US_BACKUP, PROD_SG_PRIMARY, PROD_SG_BACKUP ) ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Server[] servers() {‚Ä¶} } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Server { PROD_UK_PRIMARY(‚Äúrflx-ldn-<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">"), PROD_UK_BACKUP("</span></span>rflx-ldn-<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">"), PROD_US_PRIMARY(‚Äúrflx-nyc-1"</span></span>), PROD_US_BACKUP(<span class="hljs-string"><span class="hljs-string">"rflx-nyc-2"</span></span>), PROD_SG_PRIMARY(‚Äúrflx-sng-<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">"), PROD_SG_BACKUP("</span></span>rflx-sng-<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">"), public Service[] services() {‚Ä¶} }</span></span></code> </pre><br>  The easiest way that we use in our first project is to list the Environment with a list of servers in each of them.  There is a list of servers and, it would seem, there should be a list of services, but we cheated: we have starting scripts (which are also part of the configuration). <br><br><img src="https://habrastorage.org/webt/m0/ww/jw/m0wwjwoo1xhqahbdppfbf8q5rno.jpeg"><br><br>  They start services for each Environment.  And the services () method simply grep all services from the file of your server.  This is done because there are not so many Environment's, and the servers are also not often added or removed - but there are many services, and they are shuffled quite often.  It made sense to load the actual layout of services from scripts in order not to change the hardcoded layout too often. <br><br>  After creating such a software configuration model, pleasant bonuses appear.  For example, you can write this test: <br><br><img src="https://habrastorage.org/webt/ht/-o/lk/ht-olkpuql9rl2jhdkpm23yfnlm.jpeg"><br><br>  A test that on every Environment all key services are present.  Suppose there are four key services, and the rest can be or not, but without these four there is no sense.  You can verify that you have not forgotten them anywhere, that all of them have backups within the same Environment.  Most often, such errors occur when UAT configuration of these instances, but also in PROD can leak.  In the end, errors in UAT also spend time and nerves of testers. <br><br>  The question arises of maintaining the relevance of the configuration model.  You can also write a test for this. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HardCodedLayoutConsistencyTest</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> eachHardCodedEnvironmentHasConfigFiles(Environment env){ ‚Ä¶ } <span class="hljs-meta"><span class="hljs-meta">@Theory</span></span> eachConfigFileHasHardCodedEnvironment(File configFile){ ‚Ä¶ } }</code> </pre><br>  There are configuration files, and there is a deployment layout in the code.  And you can check that for each Environment / server / etc.  there is a corresponding configuration file, and for each file of the required format - the corresponding Environment.  As soon as you forget to add something in one place, the test will fall. <br><br>  As a result, the deployment layout: <br><br><ul><li>  Simplifies writing complex tests that bring together configs from different parts of the application. </li><li>  Makes them clearer and more readable.  They look the way you think about them at a high level, and not the way they go through configs. </li><li>  In the course of its creation, when people ask questions, it turns out a lot of interesting things about deployment.  Restrictions, implicit sacred knowledge - for example, about the possibility of hosting two Environment on the same server.  It turns out that developers consider it differently and write their services accordingly.  And it is useful to settle such moments between developers. </li><li>  Well complements the documentation (especially if it is not).  Even if there is - for me, as a developer, it is more pleasant to see it in the code.  Moreover, there you can write important to me, and not to someone, comments.  And you can also zhardkodit.  That is, if you decide that there cannot be two Environments on one server, you can insert a check, and now it will not.  At least you will find out if someone tries.  That is, this documentation with the ability to enforce it.  It is very useful. </li></ul><br>  Go ahead.  After the tests have written, they are "defended" the year, some begin to fall.  Some start to fall earlier, but it's not so scary.  It is terrible, when a test written a year ago falls, you look at his error message and you do not understand. <br><img src="https://habrastorage.org/webt/gm/e1/kb/gme1kb6jzdvbvfpfxlxydbxbktw.jpeg"><br><br>  Suppose I understand and agree that this is an invalid network port - but where is it?  Before the report, I looked at the fact that in our project there are 1200 property-files scattered over 90 modules, in the total of 24,000 lines.  (Though I was surprised, but if you count, it is not such a large number ‚Äî for one service with 4 files each.) Where is this port? <br><br>  It is clear that there is a message argument in assertThat (), you can write something to it that will help identify the place.  But when you write a test, you do not think about it.  And even if you think you have to guess what description will be detailed enough so that in a year it can be understood.  I would like to automate this moment so that there is a way to write tests with automatic generation of a more or less understandable description by which you can find an error. <br><br>  Again, I dreamed and planned something like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> environment, <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, component, configLocation, propertyName, propertyValue <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> configuration(environment, <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>, component) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> propertyName <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> ‚Äú%.port%‚Äù <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> propertyValue <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> validNetworkPort()</code> </pre><br>  This is such a pseudo-SQL - well, I just know SQL, so the brain threw a solution out of what is familiar.  The idea is that most configuration tests consist of a few of the same kind.  At first, a subset of parameters is selected by the condition: <br><br><img src="https://habrastorage.org/webt/ig/om/g_/igomg_lacmbr2w7xdnuqtxgrnoc.jpeg"><br><br>  Then with respect to this subset we check something with respect to the value: <br><br><img src="https://habrastorage.org/webt/xm/zr/1p/xmzr1p3brb_ixbgiafqteeiltgg.jpeg"><br><br>  And then, if there are properties whose values ‚Äã‚Äãdo not satisfy the desire, this is the ‚Äúsheet‚Äù that we want to receive in the error message: <br><br><img src="https://habrastorage.org/webt/6d/ci/jr/6dcijrp9yesvndnn6hq2udo5fw8.jpeg"><br><br>  At one time, I even thought about writing a SQL-like type parser to me, since it‚Äôs easy now.  But then I realized that the IDE would not support and prompt it, so people would have to write on this self-made ‚ÄúSQL‚Äù blindly, without prompts from the IDE, without compiling, without checking ‚Äî this is not very convenient.  Therefore, we had to look for solutions supported by our programming language.  If we had .NET, then LINQ would help, it is almost SQL-like. <br><br>  In Java, there is no LINQ, as close as possible, that is, streams.  This is how this test should look like in streams: <br><br><pre> <code class="java hljs">ValueWithContext[] incorrectPorts = flattenedProperties( environment ) .filter( propertyNameContains( <span class="hljs-string"><span class="hljs-string">".port"</span></span> ) ) .filter( !isInteger( propertyValue ) || !isValidNetworkPort( propertyValue ) ) .toArray(); assertThat( incorrectPorts, emptyArray() );</code> </pre><br>  flattenedProperties () takes all the configurations of this environment, all the files for all servers, services and expands them into a large table.  In essence, this is a SQL-like table, but in the form of a set of Java objects.  And flattenedProperties () returns this string set as a stream. <br><br><img src="https://habrastorage.org/webt/8b/ep/jb/8bepjbpkln50gcn1hlgdizwxkxe.jpeg"><br><br>  Then you add some conditions on this set of Java objects.  In this example: we select the ‚Äúport‚Äù that contain propertyName and filter those where the values ‚Äã‚Äãare not converted to an Integer, or not from the valid range.  These are erroneous values, and in theory, they should be an empty set. <br><br><img src="https://habrastorage.org/webt/4z/8i/db/4z8idb1t_vtoprcjg3f23ct0aeq.jpeg"><br><br>  If they are not an empty set, we throw an error, which will look like this: <br><br><img src="https://habrastorage.org/webt/ia/wq/wy/iawqwytklkjtldsc-afzmw7-cui.jpeg"><br><br><h2>  Part 3. Testing as support for refactoring. </h2><br>  Typically, code testing is one of the most powerful refactoring supports.  Refactoring is a dangerous process, much is being redone, and I want to make sure that the application after it is still viable.  One way to make sure of this is to first put all the tests on all sides, and then refactor with it. <br><br>  And now I had the task of refactoring the configuration.  There is an application that is written seven years ago by one intelligent person.  The configuration of this application looks like this: <br><br><img src="https://habrastorage.org/webt/d4/vc/wz/d4vcwzxtgvecd-be0n51ysi9mho.jpeg"><br><br>  This is an example, there is still a lot of this.  Triple nesting level of substitutions, and it is used throughout the configuration: <br><br><img src="https://habrastorage.org/webt/ua/gt/t7/uagtt7xt289h6xfpc0swrmfztca.jpeg"><br><br>  In the configuration itself, there are few files, but they are included in each other.  It uses a small extension iu Properties - Apache Commons Configuration, which just supports inclusions and resolution substitutions in curly braces. <br><br>  And the author did a fantastic job using just these two things.  I think he built a Turing machine on them there.  In some places, it actually seems that he is trying to do calculations using inclusions and substitutions.  I do not know whether this system is Turing-complete, but he, in my opinion, tried to prove that this is so. <br><br>  And the man left.  I wrote, the application works, and he left the bank.  Everything works, only nobody fully understands the configuration. <br><br>  If we take a separate service, then it turns out 10 inclusions, up to triple depth, and in total, if everything is expanded, 450 parameters.  In fact, this particular service uses 10-15% of them, the remaining parameters are intended for other services, because the files are shared, used by several services.  But what exactly 10-15% of this particular service uses is not so easy to understand.  The author apparently understood.  Very smart man, very. <br><br>  The task, respectively, was to simplify the configuration, its refactoring.  At the same time, we wanted to keep the application working, because in this situation, the chances of that are low.  I want to: <br><br><ul><li>  Simplify configuration. </li><li>  So that after refactoring each service still has all its necessary parameters. </li><li>  So that he does not have extra parameters.  85% not related to it should not clutter the page. </li><li>  So that the services are still successfully connected into clusters and work together. </li></ul><br>  The problem is that it is not known how well they are connected now, because the system is with a high level of redundancy.  For example, looking ahead: during refactoring, it turned out that one of the production configurations should have four servers in the backup clip, and in fact there were two.  Due to the high level of redundancy, no one noticed this - the error accidentally surfaced, but in fact the level of redundancy was for a long time lower than we expected.  The point is that we cannot rely on the fact that the current configuration is correct everywhere. <br><br>  I lead to the fact that you can not just compare the new configuration with the old one.  It may be equivalent, but remain at the same time somewhere wrong.  It is necessary to check the logical content. <br><br>  Minimum program: each individual parameter of each service it needs to isolate and check for correctness that the port is the port, the address is the address, the TTL is a positive number, etc.  And check out the key interconnections, that the services are mainly connected at the main end points.  It wanted to achieve, at least.  That is, unlike the previous examples, the task here is not to check individual parameters, but to cover the entire configuration with a full network of checks. <br><br>  How to test it? <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleComponent</span></span></span><span class="hljs-class"> </span></span>{ ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Configuration conf )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> port = conf.getInt( <span class="hljs-string"><span class="hljs-string">"Port"</span></span>, -<span class="hljs-number"><span class="hljs-number">1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( port &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationException(); String ip = conf.getString( <span class="hljs-string"><span class="hljs-string">"Address"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ip == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConfigurationException(); ‚Ä¶ } ‚Ä¶ }</code> </pre><br>  How did I solve this problem?  There is a simple component, simplified to the maximum in the example.  (For those who have not encountered the Apache Commons Configuration: the Configuration object is like Properties, only it has typed methods getInt (), getLong (), etc .; we can assume that this is juProperties on small steroids.) Suppose a component needs two parameters: for example, a TCP address and a TCP port.  We pull them out and check.  What are four common parts here? <br><br><img src="https://habrastorage.org/webt/ou/s0/0k/ous00k4owrh8kqvf20fqqpzrfg0.jpeg"><br><br>  This is the parameter name, type, default values ‚Äã‚Äã(here they are trivial: null and -1, sometimes there are sane values) and some validations.  The port here is validated too simply, incomplete - you can specify the port that will pass it, but will not be a valid network port.  Therefore, I would like to improve this moment too.  But first of all I want these four things to collapse into one thing.  For example, such: <br><br><pre> <code class="java hljs">IProperty&lt;Integer&gt; PORT_PROPERTY = intProperty( <span class="hljs-string"><span class="hljs-string">"Port"</span></span> ) .withDefaultValue( -<span class="hljs-number"><span class="hljs-number">1</span></span> ) .matchedWith( validNetworkPort() ); IProperty&lt;String&gt; ADDRESS_PROPERTY = stringProperty( <span class="hljs-string"><span class="hljs-string">"Address"</span></span> ) .withDefaultValue( <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> ) .matchedWith( validIPAddress() );</code> </pre><br>  Such a composite object is a description of a property that knows its name, the default value, knows how to do validation (here I use hamcrest matcher again).  And this object has an interface like this: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IProperty</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* (name, defaultValue, matcher‚Ä¶) */</span></span> <span class="hljs-comment"><span class="hljs-comment">/** lookup (or use default), * convert type, * validate value against matcher */</span></span> <span class="hljs-function"><span class="hljs-function">FetchedValue&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Configuration config )</span></span></span><span class="hljs-function"> } class FetchedValue&lt;T&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String propertyName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> T propertyValue; ‚Ä¶ }</code> </pre><br>  That is, after creating an implementation-specific object, you can ask it to extract the parameter it represents from the configuration.  And he will pull out this parameter, check the process, if there is no parameter, it will give the default value, lead to the desired type, and return it immediately with the name. <br><br>  That is, here is the name of the parameter and the actual value that the service will see if it requests from this configuration.  This allows you to wrap several lines of code in one entity, this is the first simplification that I need. <br><br>  The second simplification that I needed to solve the problem is the representation of the component, which needs several properties for its configuration.  Component configuration model: <br><br><img src="https://habrastorage.org/webt/gf/rr/ku/gfrrkugkjdimk8kcunvu4vijrsu.jpeg"><br><br>  We had a component that uses these two properties, there is a model of its configuration - the IConfigurationModel interface, which this class implements.  IConfigurationModel does everything that the component does, but only the part that relates to the configuration.  If a component needs parameters in a certain order with certain default values ‚Äã‚Äã- IConfigurationModel in itself reduces this information, encapsulates.  All other actions of the component are not important to him.  This is the component model in terms of access to the configuration. <br><br><img src="https://habrastorage.org/webt/1v/-b/0d/1v-b0dpycb6qscw_n5sul8tbzec.jpeg"><br><br>  The chip of this view is that the models are combinable.  If there is a component that uses other components, and they are combined there, then just the same the model of this complex component can merge the results of calls to two subcomponents. <br><br>  That is, you can build a hierarchy of configuration models parallel to the hierarchy of the components themselves.  At the upper model, call fetch (), which will return a sheet from the parameters that he pulled out of the configuration with their names - exactly those that will be needed by the corresponding component in real-time.  If we wrote all the models correctly, of course. <br><br>  That is, the task is to write such models for each component in the application that has access to the configuration.  In my application, such components turned out to be quite a bit: the application itself is quite spreading, but it actively re-uses the code, so only 70 main classes are configured.  For them, I had to write 70 models. <br><br>  What it cost: <br><br><ul><li>  12 services </li><li>  70 configurable classes </li><li>  =&gt; 70 ConfigurationModels (~ 60 are trivial); </li><li>  1-2 man-weeks. </li></ul><br>  I just opened the screen with the code of the component that configures itself, and on the next screen I wrote the code of the corresponding ConfigurationModel.  Most of them are trivial, like the example shown.  In some cases, there are branches and conditional transitions - there the code becomes more spreading, but everything is also solved.  For one and a half to two weeks I solved this problem, for all 70 components I described models. <br><br>  As a result, when we put all this together, we get the following code: <br><br><img src="https://habrastorage.org/webt/dq/ab/vf/dqabvfz99qwfnortpempmtvaalm.jpeg"><br><br>  For each service / environment / etc.  take the configuration model, that is, the top node of this tree, and ask to get everything from the config.  At this moment, all validations pass inside, each of the properties, when it gets itself out of the config, checks its value for correctness.  If at least one does not pass, except for the inside fly out.  All code is obtained by checking that all values ‚Äã‚Äãare valid in isolation. <br><br><h2>  Service interdependencies </h2><br>  We still had a question about how to check the interdependencies of services.  This is a little more complicated, you have to look at what interdependencies are there.  It turned out that interdependencies boil down to the fact that services must ‚Äúmeet‚Äù via network endpoints.  Service A should listen to exactly the address to which Service B sends packets, and vice versa.  In my example, all the dependencies between the configurations of different services boiled down to this.  It was possible to solve this problem so straightforwardly: get ports and addresses from different services and check them.  There would be a lot of tests, they would be cumbersome.  I'm a lazy person and I did not want this.  Therefore, I did otherwise. <br><br>  First, I wanted to somehow abstract this network endpoint itself.  For example, for a TCP connection, you need only two parameters: the address and the port.  For a multicast connection, there are four parameters.  I would like to turn it into some kind of object.  I did this in the Endpoint object, which inside hides everything you need.  In the slide, an example is OutcomingTCPEndpoint, an outgoing TCP network connection. <br><br><pre> <code class="java hljs">IProperty&lt;IEndpoint&gt; TCP_REQUEST = outcomingTCP( <span class="hljs-comment"><span class="hljs-comment">// (+matchers, +default values) ‚ÄúTCP.Request.Address‚Äù, ‚ÄúTCP.Request.Port¬ª ); class OutcomingTCPEndpoint implements IEndpoint { //(localInterface, localAddress, multicastGroup, port) @Override boolean matches( IEndpoint other); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outwardly, the Endpoint interface returns a single method, matches (), to which you can give another Endpoint, and find out if this pair is similar to the server and client parts of a single connection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is it "like"? Because we do not know what will happen in reality: maybe, formally, it should connect to the address-ports, but in a real network between these nodes, the firewall is worth it - we cannot check this only by configuration. But we can find out if they are already even formally, by ports / addresses do not match. Then, most likely, in reality, they also will not connect with each other.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, instead of primitive values ‚Äã‚Äãof properties, addresses, ports-multicast groups, we now have a complex property that returns Endpoint. And in all ConfigurationModels instead of separate properties - there are such complex ones. What does this give us? This gives us the following cluster connectivity check:</font></font><br><br><pre> <code class="java hljs">ValueWithContext[] allEndpoints = flattenedConfigurationValues(environment) .filter( valueIsEndpoint() ) .toArray(); ValueWithContext[] unpairedEndpoints = Arrays.stream( allEndpoints ) .filter( e -&gt; !hasMatchedEndpoint(e, allEndpoints) ) .toArray(); assertThat( unpairedEndpoints, emptyArray() );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We choose endpoints from all the properties of this environment, and then we just clarify whether there are some that do not match anyone, do not connect with anyone. All previous machinery allows you to make such a test in a few lines. Here, the complexity of checking ‚Äúall with all‚Äù will be O (n ^ 2), but this is not so important, because there are hundreds of endpoints, you can not even optimize them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, for each Endpoint we go through all the rest and find out if at least one who connects with it. If there was not one, most likely he was supposed to be there, but because of an error, he was not there.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, it may be that the service has holes that stick outward - that is, to external services, outside the current application. </font><font style="vertical-align: inherit;">Such holes will need to be explicitly filtered. </font><font style="vertical-align: inherit;">I was lucky, in my case, external clients are connected by the same holes that the service itself uses inside. </font><font style="vertical-align: inherit;">It is so closed and economical in terms of network connections. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a solution to the problem of testing. </font><font style="vertical-align: inherit;">And the main task, I remind you, was to refactor. </font><font style="vertical-align: inherit;">And I was ready to do the refactoring with my hands, but when I did all these tests, and they stopped, I realized that I had the opportunity to do refactoring automatically. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This entire ConfigurationModel hierarchy allows:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Convert to another format </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Execute configuration requests (‚Äúall udp ports used by services on this server‚Äù) </font></font></li><li>        . </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I can draw the whole configuration into memory in such a way that each property tracks its origin. After that, I can convert this configuration in memory, and pour it into other files, in a different order, in a different format - as it suits me. So I did: I wrote a small code to transform that sheet into the kind in which I wanted to transform it. In fact, it had to be done several times, because initially it was not obvious which format would be convenient and understandable, and I had to make several visits to try. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But this is not enough. With this construct, with the help of ConfigurationModels, I can make requests to the configuration. Raise it in memory and find out which specific UDP ports are used on this server by different services, request a list of the ports used, with the instructions of the services.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, I can link services by endpoints and output it as a diagram, export to .dot. </font><font style="vertical-align: inherit;">And other similar requests are easily made. </font><font style="vertical-align: inherit;">It turned out such a Swiss knife - the cost of its construction has paid off. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this I finish. </font><font style="vertical-align: inherit;">Findings:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In my opinion, in my experience, testing the configuration is important and fun. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are a lot of low-hanging fruits, the entry threshold to start is low. </font><font style="vertical-align: inherit;">You can solve complex problems, but there are a lot of simple ones too.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you use a little brains, you can get powerful tools that allow you not only to test, but also a lot to do with the configuration. </font></font></li></ul><br><blockquote>     Heisenbug 2018 Piter ,  : <b>6-7   </b>   <b>Heisenbug</b> .  <a href="https://heisenbug-moscow.ru/"> </a>      .   1     ‚Äî        . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/427487/">https://habr.com/ru/post/427487/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427477/index.html">We are preparing hierarchical clustering or how I have identified specializations from resumes.</a></li>
<li><a href="../427479/index.html">The use of user data and the sale of big data offered to legitimize</a></li>
<li><a href="../427481/index.html">Features of building a Wi-Fi network on innovative food production</a></li>
<li><a href="../427483/index.html">School of Artificial Intelligence in Binary District</a></li>
<li><a href="../427485/index.html">Windows problem is not in the frequency of updates, but in the development process</a></li>
<li><a href="../427489/index.html">Home Data: How Data Analysis is Used in Architecture and Urbanism</a></li>
<li><a href="../427491/index.html">Do it in English: 7 western interviewers, from whom everyone takes an example</a></li>
<li><a href="../427493/index.html">Amplifiers low frequency classes: A, B, AB, D, G, H</a></li>
<li><a href="../427495/index.html">How much does Habr + earn how to find out how much other companies earn</a></li>
<li><a href="../427499/index.html">What do they write to tech-support video streamer?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>