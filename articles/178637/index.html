<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Correcting memory leaks in the Python application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I recently happened to figure out and fix a few memory leaks in the popular Tornado framework. It does not matter if you have never used it, because t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Correcting memory leaks in the Python application</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/177/bde/c82/177bdec82145a287a05e46e0044729d2.jpg" alt="image" align="right">  I recently happened to figure out and fix a few memory leaks in the popular Tornado framework.  It does not matter if you have never used it, because the described will have little to do with it.  I want to tell you about the methods I used to find and fix leaks. <br><br>  All this will be true for the most part only for the most popular Python implementation, CPython.  As you know, it has two mechanisms for freeing memory.  The first one is reference counting.  Every time you explicitly or implicitly create a new object, its reference count is one.  If you assign this object to a new variable or pass in as an argument, its reference count increases.  When the function exits, the number of references to objects that were in local variables and arguments decreases.  If for some object the number of links becomes zero, it is immediately destroyed. <br><br>  This scheme works fine until objects refer to each other appear.  The simplest example is the nodes of a tree that hold links to their child and parent nodes.  Nodes will continue to refer to each other, even when there are no other external links to any of them.  The most annoying thing is that such nodes can refer to some other data and prevent them from being released.  To eliminate such circular references, there is a second mechanism for freeing memory in Python - the garbage collector.  It runs from time to time, putting the rest of the code on a pause, and analyzes all un-freed objects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Formally, circular references cannot be called leaks: garbage collection will sooner or later destroy such objects.  The only trouble is that Python cannot determine when it is still early, and when it is too late.  In my case, the system simply nailed the process with Python if garbage collection did not start on time. <a name="habracut"></a><br><br>  As stated in <a href="http://docs.python.org/2.7/library/gc.html">the gc module</a> documentation, the frequency of garbage collection depends on the thresholds established for the number of new objects.  In all versions of Python available to me, this number is 700 by default. However, if you run a fairly simple test, you can see that the number of objects collected by the compulsory garbage collection <code>gc.collect()</code> can easily exceed this value. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> parent = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *children)</span></span></span><span class="hljs-function">:</span></span> self.children = list(children) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.children: node.parent = self @classmethod <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cls, depth=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, children=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> depth == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [cls(*cls.tree(depth<span class="hljs-number"><span class="hljs-number">-1</span></span>, children)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(children)] <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): <span class="hljs-comment"><span class="hljs-comment">#   . Node.tree(depth=5, children=6) start = time() print('{1} objects collected for n={0} in {2:3.6} msec'.format( n, gc.collect(), (time() - start) * 1000))</span></span></code> </pre><br>  With n equal to 10 and 20, I got 107 thousand unallocated objects.  So the thresholds in the gc module are soft and their achievement does not guarantee immediate garbage collection (Andrei <a href="https://habrahabr.ru/users/svetlov/" class="user_link">Svetlov corrects</a> in the comments that this is not so, and explains in detail why this is happening).  Moreover, the number of objects says nothing about the memory they occupy.  As a result, if objects in your application that occupy a lot of memory are not destroyed by reference counting, this can lead to dire consequences. <br><br>  That is exactly what happened in my application.  The code localizing the problem looked like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tornado <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> web, ioloop, gen ioloop = ioloop.IOLoop.current() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> megabyte_string = <span class="hljs-string"><span class="hljs-string">"0123456789abcdef"</span></span> * <span class="hljs-number"><span class="hljs-number">64</span></span> * <span class="hljs-number"><span class="hljs-number">1024</span></span> @web.asynchronous @gen.engine <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.write(<span class="hljs-string"><span class="hljs-string">"Hello, world&lt;br&gt;"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> gen.Task(self.some_task, self.megabyte_string * <span class="hljs-number"><span class="hljs-number">20</span></span>) self.finish() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">some_task</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, bigdata, callback)</span></span></span><span class="hljs-function">:</span></span> self.write(<span class="hljs-string"><span class="hljs-string">"some task&lt;br&gt;"</span></span>) callback() application = web.Application([(<span class="hljs-string"><span class="hljs-string">r'/'</span></span>, IndexHandler)], debug=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: print(<span class="hljs-string"><span class="hljs-string">"Start on 8888"</span></span>) application.listen(<span class="hljs-number"><span class="hljs-number">8888</span></span>) ioloop.start()</code> </pre><br>  This is where a server is created that handles the URL "/" in the <code>IndexHandler.get()</code> method.  The method is asynchronous and puts on the task, which transfers a large piece of data - 20 megabytes.  What the task does is not so important, because already in this example there is a problem: with each request, the amount of memory occupied by the Python process increases by these 20 megabytes, and far from each decreases.  The result is a simple benchmark <code><a href="http://localhost/"></a> ab -n 100 -c 4 localhost:8888/</code>  <code><a href="http://localhost/"></a> ab -n 100 -c 4 localhost:8888/</code> is able to consume gigabytes of memory in certain moments.  But it is worth changing the task call from the use of <code>yield gen.Task()</code> to a direct call with the callback transfer, as the server easily begins to withstand the load <code><a href="http://localhost/"></a> ab -n 1000 -c 100 localhost:8888/</code>  <code><a href="http://localhost/"></a> ab -n 1000 -c 100 localhost:8888/</code> , consuming no more than 50 MB of memory. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @web.asynchronous @gen.engine def get(self): self.write("Hello, world&lt;br&gt;") self.some_task(self.megabyte_string * 20, self.finish)</span></span></code> </pre><br>  How to debug such cases?  It would be nice to see what exactly is not being released.  The first thing to do is to ensure that you can manually start garbage collection to make sure that its call actually frees the memory.  I made another request to the handler, which called <code>gc.collect()</code> and displayed the number of collected objects. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HealthHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.write(<span class="hljs-string"><span class="hljs-string">'{} objects collected'</span></span>.format(gc.collect())) application = web.Application([(<span class="hljs-string"><span class="hljs-string">r'/'</span></span>, IndexHandler), (<span class="hljs-string"><span class="hljs-string">r'/health/'</span></span>, HealthHandler)], debug=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)</code> </pre><br>  Second, you need to disable automatic garbage collection.  This will allow to obtain a stable result during experiments.  Third, we need information about the collected objects.  In the gc module there is already a ready tool for this - the information will be output to the console during the <code>gc.collect()</code> call. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gc gc.disable() gc.set_debug(gc.DEBUG_LEAK)</code> </pre><br>  Now getting the objects involved in this particular leak is quite simple: you need to run the method that flows and get a list of the collected objects at <code>/health/</code> .  Then run the method that does not flow, get a list for it.  Find objects from the first list that are not in the second.  Here they are: <br><br><pre> <code class="html hljs xml">gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">cell</span></span></span><span class="hljs-tag">&gt;</span></span> √ó 4 gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> √ó 3 gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">function</span></span></span><span class="hljs-tag">&gt;</span></span> √ó 2 gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">generator</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">instancemethod</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Runner</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">set</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Task</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span><span class="hljs-tag">&gt;</span></span> √ó 3</code> </pre><br>  For clarity, I have grouped the same elements.  First of all, non-embedded types are of interest.  Here it is <code>Task</code> and <code>Runner</code> .  This proves once again that the problem is in the <code>yield gen.Task()</code> call, and the problem is in garbage collection.  It remains to figure out what the <code>Runner</code> and why they link to each other with the <code>Task</code> .  Open the source code. <br><br>  Here it should be noted that all the examples will be for the Tornado version <a href="https://github.com/facebook/tornado/tree/520b02f">3.1dev2</a> at the time of my research.  In the <a href="https://github.com/facebook/tornado/blob/520b02f/tornado/gen.py"><code>@gen.engine</code></a> decorator, <a href="https://github.com/facebook/tornado/blob/520b02f/tornado/gen.py"><code>@gen.engine</code></a> quite a lot of code, but the main thing that happens there is that the original function is called, and if the result of its execution turns out to be a generator, it is passed to the <code>Runner</code> class (got caught).  Our <code>Task</code> is what the generator will return.  Therefore, you need to look for a place in the <a href="https://github.com/facebook/tornado/blob/520b02f/tornado/gen.py">class <code>Runner</code></a> , where the generator is iterated.  This is the line <code>yielded = self.gen.send(next)</code> .  Well, then it's pretty easy to trace that <code>yielded</code> gets into <code>self.yield_point</code> .  And besides, <code>self.yield_point</code> calls the <code>.start()</code> method, which stores a reference to <code>Runner</code> .  So, after running the <code>Runner.run()</code> method, you need to break the link either from one side or the other.  Since  <code>Runner.yield_point</code> is just a pointer to the last element, and <code>Task.runner</code> is a link to the parent, it is logical to nullify the pointer to the element.  It remains only to understand where the <code>Runner.run()</code> method completes its execution.  Since  A tornado is asynchronous, and we go through the source code in its very heart, then it‚Äôs quite difficult to understand where the top is and where the bottom is.  The <code>.run()</code> method <code>.run()</code> 5 exit points, and it is re-called from all sorts of callbacks.  After several attempts, I realized that the <code>self.finished</code> flag of the <code>Runner</code> object is not <code>self.finished</code> , and where it is set to True, and self.yield_point should be <code>self.yield_point</code> . <br><br>  Check the result with <code><a href="http://localhost/"></a> ab -n 1000 -c 100 localhost:8888/</code>  <code><a href="http://localhost/"></a> ab -n 1000 -c 100 localhost:8888/</code> .  Everything is good. <br><br>  It would be possible to finish this, but this seemed strange to me.  Why does any request leave unallocated objects in memory?  Maybe something can be done about it.  It turned out that, nevertheless, not any request, but only those on which the decorator <code>@web.asynchronous</code> .  And the list of un-freed objects looked like this: <br><br><pre> <code class="html hljs xml">gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dict</span></span></span><span class="hljs-tag">&gt;</span></span> √ó 7 gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">list</span></span></span><span class="hljs-tag">&gt;</span></span> √ó 16 gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">tuple</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">instancemethod</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ChunkedTransferEncoding</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ExceptionStackContext</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HTTPHeaders</span></span></span><span class="hljs-tag">&gt;</span></span> √ó 2 gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HTTPRequest</span></span></span><span class="hljs-tag">&gt;</span></span> gc: collectable <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">IndexHandler</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  There are already 5 unbuilt objects, and it is unclear from which end to begin.  But I began by <code>IndexHandler.finish()</code> method, in which I removed references to all the objects I found. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IndexHandler</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(web.RequestHandler)</span></span></span><span class="hljs-class">:</span></span> @web.asynchronous <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.write(<span class="hljs-string"><span class="hljs-string">"Hello, world&lt;br&gt;"</span></span>) self.finish() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, chunk=None)</span></span></span><span class="hljs-function">:</span></span> super(IndexHandler, self).finish(chunk) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k, v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__dict__.iteritems(): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'"{}":'</span></span>.format(k), type(v) self.request = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self._headers = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.application = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self._transforms = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre><br>  This gave a definite result, but did not solve the problem completely.  The number of unbuilt non-freed objects decreased to two: <code>ExceptionStackContext</code> and <code>IndexHandler</code> itself.  <code>ExceptionStackContext</code> is created when the <a href="https://github.com/facebook/tornado/blob/520b02f/tornado/web.py"><code>@web.asynchronous</code></a> decorator is <a href="https://github.com/facebook/tornado/blob/520b02f/tornado/web.py"><code>@web.asynchronous</code></a> with the argument <code>self._stack_context_handle_exception</code> , where <code>self</code> is just an <code>IndexHandler</code> .  There are no links in the opposite direction.  It looks like <code>ExceptionStackContext</code> refers to itself.  We look at the <a href="https://github.com/facebook/tornado/blob/520b02f/tornado/stack_context.py">implementation</a> and see that, in the <code>.__enter__()</code> method <code>.__enter__()</code> there is a string <code>self.new_contexts = (self.old_contexts[0], self)</code> .  So you need to reset <code>self.new_contexts</code> to <code>.__exit__()</code> , and that's in the bag. <br><br>  As a result, the <a href="https://github.com/facebook/tornado/pull/767">pullrequest</a> with both changes was reviewed and adopted by the master for 2.5 hours, which motivates to continue to make useful changes.  The tornado with these two patches and <a href="https://github.com/facebook/tornado/commit/12780c1">one</a> more completely ceased to leave garbage in memory after the request.  This reduced memory consumption with multiple competitive requests, slightly accelerated it due to faster garbage collection and, most importantly, made memory consumption predictable. <br><br>  It is quite difficult to find and fix such leaks, especially if they are not in the code of the application itself, but of the libraries used.  However, it is worthwhile to at least find out if you have them in the application and make sure that no heavy objects hang in your memory because of them. </div><p>Source: <a href="https://habr.com/ru/post/178637/">https://habr.com/ru/post/178637/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178623/index.html">Recipes against deadlocks on signal variables</a></li>
<li><a href="../178625/index.html">IT Brunch Free Online Conferencing Platform - ".NET brunch" May 18</a></li>
<li><a href="../178629/index.html">Let's make "Roscosmos" a little kinder</a></li>
<li><a href="../178633/index.html">6 buttons</a></li>
<li><a href="../178635/index.html">Valve has released Portal for Linux</a></li>
<li><a href="../178639/index.html">Avatar rootkit: detailed analysis</a></li>
<li><a href="../178641/index.html">Princeton's bionic ear, capable of "hearing" radio waves</a></li>
<li><a href="../178645/index.html">At Harvard, created a miniature robot mosquito (+ video)</a></li>
<li><a href="../178647/index.html">Fresh Frozen Raspberry Pi</a></li>
<li><a href="../178649/index.html">Usability: let your mom try</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>