<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Battle for sound speed on Android x86</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the heart of the ‚Äúpyramid of needs‚Äù for those who need Android applications for working with sound is the speed of the system‚Äôs response to user ac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Battle for sound speed on Android x86</h1><div class="post__text post__text-html js-mediator-article"> <a href="https://habrahabr.ru/company/intel/blog/277569/"><img src="https://habrastorage.org/getpro/habr/post_images/275/fd3/c15/275fd3c1517ab1ccd8afe562a91effb3.jpg" alt="image" align="left" width="300"></a>  At the heart of the ‚Äúpyramid of needs‚Äù for those who need Android applications for working with sound is the speed of the system‚Äôs response to user actions.  Suppose a program starts quickly and shows a beautiful picture with a piano keyboard.  For a start it is not bad, but if the moments of touching the keys and the beginning of the sound (let‚Äôs just amazing) are separated by a noticeable time, the program will be closed and will not return to it anymore. <br><br>  Let's talk about the features of sound reproduction with high response speed on Android-devices based on Intel Atom (Bay Trail) processors.  The applied approach can be used on other platforms from Intel.  Here we are reviewing Android 4.4.4., A similar study for the Android M platform is still under construction. <br><a name="habracut"></a><br clear="left"><h2>  <font color="#0071c5">Preliminary Information</font> </h2><br>  Playing high-latency audio is one of the problems with Android, which is particularly bad for sound applications.  Long time intervals between the user's action and the beginning of the sound have a bad influence on the programs for creating sound, on games, on software for DJs and karaoke applications.  If such applications, in response to certain actions, reproduce sounds with delays that the user finds too large, this seriously spoils his impressions. <br><br>  During the study, we will use the concept of circular delay (Round-Trip Latency, RTL).  In our case, this is the time that separates the moment when the user or the system performs an action that requires creating and playing an audio signal, and the moment the sound starts. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Users are faced with a delay in audio playback in Android, the code they, for example, relate to the object, the interaction with which should cause the sound, and the sound is not played immediately.  On most ARM and x86 devices, round-trip delays range from 300 to 600 ms., Mainly in applications that use standard Android tools for audio output, which can be found in <a href="http://source.android.com/devices/audio/latency_design.html">Design For Reduced Latency</a> . <br><br>  Users do not like this.  The permissible round-trip delay should be well below 100 ms, and in most cases, below 20 ms.  Ideally, for professional use, the delay should be below 10 ms.  It is also necessary to take into account the fact that in Android applications that work with sound, the total delay consists of three components.  The first is the touch delay (Touch Latency). <br><br>  The second is the audio processing latency.  The third is the delay in queuing the buffer with audio data (Buffer Queuing). <br><br>  Here we focus on reducing the delay in sound processing, rather than on all three of the above components.  However, by improving one of the factors, we will reduce the overall delay. <br><br><h2>  <font color="#0071c5">Device sound subsystem in Android</font> </h2><br>  Like other Android mechanisms, the sound subsystem can be represented as consisting of several layers. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c8/11b/d21/9c811bd21aed6dcad2942993a123d95a.png"></div><br>  <i><font color="#999999">Android audio subsystem</font></i> <br><br>  <a href="https://source.android.com/devices/audio/index.html">Here</a> you can learn more about the above scheme. <br><br>  Note that the hardware abstraction layer (HAL) of the Android audio subsystem serves as a link between high-level APIs designed for sound processing in <a href="http://developer.android.com/reference/android/media/package-summary.html">android.media</a> and underlying audio drivers and hardware. <br><br><h2>  <font color="#0071c5">Opensl es</font> </h2><br>  Using the OpenSL ES API is the most reliable way to efficiently process an audio signal that should be played in response to a user or application.  Delays, and when using OpenSL ES, can not be avoided, but the Android documentation recommends using this particular API. <br><br>  The reason for this recommendation is that OpenSL uses a mechanism for setting buffers with audio data in a queue (Buffer Queueing), which increases efficiency when working in the Android Media Framework.  All this is implemented on the Android machine code, that is, it can give better performance, since such code is not subject to problems typical of Java or the Dalvik virtual machine. <br><br>  We believe that the use of mechanisms OpenSL ES - is a step forward in the development of audio applications for Android.  In addition, in the documentation for the Android Native Development Kit there is information that with the release of new releases of Android it is planned to improve the implementation of OpenSL. <br><br>  Here we will look at using the OpenSL ES API through NDK.  To begin with, here are three levels of code that form the basis for developing sound applications for Android using OpenSL <br><br><ul><li>  The top level is the Android SDK application development environment, which is based on Java. </li><li>  A lower level of the software environment, called the Android NDK, allows developers to write C or C ++ code that can be used in applications using the Java Native Interface (JNI) mechanism. </li><li>  The bottom level is the OpenSL ES API, which is supported on Android since version 2.3.  The API is built into the NDK. </li></ul><br>  OpenSL works like several other APIs using a callback mechanism.  In OpenSL, the callback can only be used to notify the application that a new buffer can be queued (to play or record sound).  In other APIs, callback functions also support pointers to buffers with audio data that an application can fill with or receive data from.  But in OpenSL, by choice, the API can be implemented so that the callback functions act as a signaling mechanism so that all calculations are performed in the stream responsible for processing the sound.  This process involves queuing the data buffers after receiving the assigned signals. <br><br>  Google recommends using the Sched_FIFO scheduling policy when using OpenSL.  This policy is based on the technique of applying the ring buffer. <br><br><h2>  <font color="#0071c5">Sched_FIFO scheduling policy</font> </h2><br>  Since Android is based on Linux, the Linux CFS scheduler is involved here.  CFS may allocate CPU resources unpredictably.  For example, he is able to transfer control to a flow with a higher, in his opinion, priority, depriving him of the power of a flow that seems to him less attractive.  These are the features of CFS, if similar touches the stream that is busy processing the sound, it can cause problems with the buffer timings.  The result is long delays, the appearance of which is difficult to predict. <br><br>  The main solution to this problem is not to use CFS for streams engaged in intensive work with sound and, instead of the SCHED_NORMAL scheduling policy (its other name is SCHED_OTHER), which CFS implements, to apply the SCHED_FIFO policy. <br><br><h2>  <font color="#0071c5">Planning delay</font> </h2><br>  The scheduling delay is the time that passes between the moment when the thread is ready to start and the moment when the context switch is completed, that is, the beginning of the thread execution on the processor.  The less this delay, the better, and if it is more than two milliseconds - problems with sound are guaranteed.  Long scheduling delays usually occur when changing processor modes.  These include starting or stopping, switching between a protected core and a regular core, switching power modes, or adjusting the frequency and power consumption of the processor. <br><br>  Guided by the above considerations, consider the scheme of the implementation of sound processing on Android. <br><br><h2>  <font color="#0071c5">Ring buffer interface</font> </h2><br>  The first thing to do to properly organize the work is to prepare the interface of the ring buffer, which can be used from the code.  To do this, we need four functions: <br><br><ol><li>  Function to create a ring buffer. </li><li>  Buffer write function. </li><li>  The function of reading from the buffer. </li><li>  Function to destroy the buffer. </li></ol><br>  Here is a sample code: <br><br><pre><code class="hljs cs">circular_buffer* create_circular_buffer(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bytes); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_circular_buffer_bytes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">circular_buffer *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_circular_buffer_bytes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">circular_buffer *p, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">in</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bytes</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free_circular_buffer</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">circular_buffer *p</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  The desired effect is that when performing a read operation, the requested number of bytes is read, up to the amount of information that has already been written to the buffer.  The recording function will write data to the buffer taking into account the free space left in it.  They return the number of bytes read or written - these numbers are in the range from zero to the number requested when calling the function. <br><br>  The consumer stream (the I / O callback function, in the case of playback, or the stream occupied by audio processing in the case of recording) reads the data from the ring buffer and then performs some operations with the read audio data.  At the same time, asynchronously, the provider thread is busy filling the ring buffer with data, stopping only when the buffer is full.  If you select the appropriate size of the ring buffer, these two streams will work smoothly, without interfering with each other. <br><br><h2>  <font color="#0071c5">Audio Input / Output</font> </h2><br>  Using the interface we discussed above, the audio input / output functions can be written using OpenSL callback functions.  Here is an example of the function that processes the input stream: <br><br><pre> <code class="hljs haskell">/    ,   ,      void bqRecorderCallback(<span class="hljs-type"><span class="hljs-type">SLAndroidSimpleBufferQueueItf</span></span> bq, void *context) { <span class="hljs-type"><span class="hljs-type">OPENSL_STREAM</span></span> *p = (<span class="hljs-type"><span class="hljs-type">OPENSL_STREAM</span></span> *) context; int bytes = p-&gt;inBufSamples*sizeof(short); write_circular_buffer_bytes(p-&gt;inrb, (char *) p-&gt;recBuffer,bytes); (*p-&gt;recorderBufferQueue)-&gt;<span class="hljs-type"><span class="hljs-type">Enqueue</span></span>(p-&gt;recorderBufferQueue,p-&gt;recBuffer,bytes); } //         int android_AudioIn(<span class="hljs-type"><span class="hljs-type">OPENSL_STREAM</span></span> *p,float *buffer,int size){ short *inBuffer; int i, bytes = size*sizeof(short); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(p == <span class="hljs-type"><span class="hljs-type">NULL</span></span> || p-&gt;inBufSamples == <span class="hljs-number"><span class="hljs-number">0</span></span>) return <span class="hljs-number"><span class="hljs-number">0</span></span>; bytes = read_circular_buffer_bytes(p-&gt;inrb, (char *)p-&gt;inputBuffer,bytes); size = bytes/sizeof(short); for(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++){ buffer[i] = (float) p-&gt;inputBuffer[i]*<span class="hljs-type"><span class="hljs-type">CONVMYFLT</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(p-&gt;outchannels == <span class="hljs-number"><span class="hljs-number">0</span></span>) p-&gt;time += (double) size/(p-&gt;sr*p-&gt;inchannels); return size; }</code> </pre> <br>  In the callback function (lines 2-8), which is called each time a new full buffer (recBuffer) is ready, all data is written to the ring buffer.  After this, the function is again queued for execution (line 7).  The audio processing function (lines 10-21) tries to read the requested number of samples (line 14) in inputBuffer, and then copy this data to the output (converting it to floating-point format).  The function returns the number of copied samples. <br><br>  Here is an example of a function that performs sound output. <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       int android_AudioOut(OPENSL_STREAM *p, float *buffer,int size){ short *outBuffer, *inBuffer; int i, bytes = size*sizeof(short); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(p == NULL || p-&gt;outBufSamples == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size; i++){ p-&gt;outputBuffer[i] = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(short)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(buffer[i]*CONV16BIT)</span></span></span><span class="hljs-function">; } bytes = write_circular_buffer_bytes</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p-&gt;outrb, (char *) p-&gt;outputBuffer,bytes)</span></span></span><span class="hljs-function">; p-&gt;</span></span>time += <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(double)</span></span></span><span class="hljs-function"> size/</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p-&gt;sr*p-&gt;outchannels)</span></span></span><span class="hljs-function">; return bytes/sizeof</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(short)</span></span></span><span class="hljs-function">; } //    ,   ,       void bqPlayerCallback</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SLAndroidSimpleBufferQueueItf bq, void *context)</span></span></span><span class="hljs-function"> { OPENSL_STREAM *p = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OPENSL_STREAM *)</span></span></span><span class="hljs-function"> context; int bytes = p-&gt;</span></span>outBufSamples*sizeof(short); read_circular_buffer_bytes(p-&gt;outrb, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(char *)</span></span></span><span class="hljs-function"> p-&gt;</span></span>playBuffer,bytes); (*p-&gt;bqPlayerBufferQueue)-&gt;Enqueue(p-&gt;bqPlayerBufferQueue,p-&gt;playBuffer,bytes); }</code> </pre> <br>  The audio processing function (lines 2-13) takes a certain amount of data stored in floating-point format, converts them into whole numbers, writes the full outputBufer buffer to the ring buffer, reports the number of samples recorded.  The OpenSL callback function (lines 16-22) reads all samples and puts them in a queue. <br><br>  In order for all this to work properly, you need to transfer to the output data on the number of samples read from the input, along with the buffer.  Here is a loop that transforms input data into a weekend. <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(on) samps = android_AudioIn(p,inbuffer,VECSAMPS_MONO); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; samps; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>+=<span class="hljs-number"><span class="hljs-number">2</span></span>) outbuffer[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>] = outbuffer[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>] = inbuffer[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; android_AudioOut(p,outbuffer,samps*<span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  In this code snippet, in lines 5-6, the read samples are traversed and copied to the output channels.  Here is the conversion of the input monaural signal to the output stereo, which is why the same input data is copied into two output buffer positions following one another.  Now that the buffer has been queued in the OpenSL threads, in order to start the callback mechanism, we need to queue the buffer for the recording and another one to play after we start playing the sound.  This will ensure that the callback function is triggered when buffers need to be replaced. <br><br>  We have just looked at a simple example of implementing a sound input / output stream using OpenSL.  Each implementation will be unique and will require modifications to the HAL and the ALSA driver in order to squeeze everything out of the OpenSL implementation. <br><br><h2>  <font color="#0071c5">Completion of the Android sound subsystem on the x86 platform</font> </h2><br>  Various OpenSL implementations do not guarantee that all devices will achieve the desired (up to 40 ms.) Level of delays when passing an audio signal to the Android ‚Äúfast mixer‚Äù.  However, if you make modifications to the Media Server, HAL, in the ALSA driver, various devices can, with varying success, show good results in processing audio with low latency.  In the course of a study on what is needed to increase the response speed when working with sound on Android, we implemented the corresponding solution on the Dell Venue 8 7460 tablet. <br><br>  As a result of the experiments, a hybrid system for processing media data was created.  In it, the stream that processes the input data is controlled by a dedicated fast server that processes the original audio signal.  The signal is then transmitted to a media server implemented in Android, which uses the ‚Äúfast mixer‚Äù stream.  Servers that process input and output data use the OpenSL Sched_FIFO scheduling mechanism. <br><br><div style="text-align:center;"><img src="https://lh6.googleusercontent.com/ci4IwvsFoAOx6_BRRoEBoPeOeRZAfom7mDdvMP_6IMFS820wPiC7ayOuNJzC1xKVHGOwj6oBaRBRlEwgaf-15VGvYhF6uFFKkUOZd4oPRtohqkA6BqC4J4Q57V-6sXj-ECsrAruYju7JnTu3"></div><br>  <i><font color="#999999">Implementing fast sound processing, drawing provided by Eric Serre</font></i> <br><br>  As a result of the modifications made, it is possible to achieve an acceptable RTL of 45 milliseconds.  This implementation relies on the Intel Atom SoC and on the features of the device used in the experiment.  The test was conducted on the Intel Software Development Platform and is available through the Intel Partner Software Development Program. <br><br>  The implementation of the OpenSL and scheduling policy SCHED_FIFO demonstrates efficient processing of sound generated in real time.  It should be noted that this implementation is not available on all devices, since it was created for the above-mentioned tablet computer, taking into account its software and hardware features. <br><br>  In order to figure out how the sound processing technique presented in this material will show itself on other devices, you need to carry out the appropriate tests.  After conducting such tests, we can provide the results to partner developers. <br><br><h2>  <font color="#0071c5">findings</font> </h2><br>  We discussed the features of using OpenSL to create a callback function and a buffer queue in an application that processes audio on Android.  In addition, it reflects the efforts made by Intel to achieve low-latency sound performance using the modified Media Framework. <br><br>  In order to implement such a system on your own, follow the recommendations of Google and take into account the features of building applications for fast sound processing, which we described in this material.  The results suggest that reducing delays in the processing of audio data on Android is quite a real task, but the battle for sound speed on the Android x86 platform continues. </div><p>Source: <a href="https://habr.com/ru/post/277569/">https://habr.com/ru/post/277569/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277545/index.html">Game design f2p games or how not to make mistakes</a></li>
<li><a href="../277559/index.html">How Relap.io is organized - a service that issues 30 billion recommendations per month</a></li>
<li><a href="../277563/index.html">Word2Vec: classification of text documents</a></li>
<li><a href="../277565/index.html">Framer Animation for Beginners</a></li>
<li><a href="../277567/index.html">Windows 10 application with data in the cloud using Azure Mobile Apps</a></li>
<li><a href="../277571/index.html">Security Week 07: Apple vs. FBI, global glibc vulnerability, crypto-fiber and medicine</a></li>
<li><a href="../277573/index.html">Kotlin 1.0. Ask the team a question</a></li>
<li><a href="../277575/index.html">Zero Day XSS Vulnerability Stops Cisco ASA Users Credentials</a></li>
<li><a href="../277577/index.html">Memo on the basic layout of the article for Habr without using Markdown-markup</a></li>
<li><a href="../277579/index.html">Game Industry Digest: January</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>