<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What deep neural networks look like and why they require so much memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today the graph is one of the most acceptable ways to describe the models created in the machine learning system. These computational graphs are made ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What deep neural networks look like and why they require so much memory</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/geektimes/post_images/802/6f4/eab/8026f4eab4ee028d6894159b00421c56.jpg" alt="image"><br><br>  Today the graph is one of the most acceptable ways to describe the models created in the machine learning system.  These computational graphs are made up of vertices-neurons connected by synapse edges, which describe the connections between the vertices. <br><br>  In contrast to a scalar central or vector graphics processor, an IPU ‚Äî a new type of processor designed for machine learning ‚Äî allows you to construct such graphs.  A computer that is designed to manage graphs is an ideal machine for computational graph models created as part of machine learning. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the easiest ways to describe the process of machine intelligence is to visualize it.  The Graphcore development team has created a collection of such images displayed on an IPU.  The basis lay Poplar software, which visualizes the work of artificial intelligence.  Researchers from this company also found out why deep networks require so much memory, and what solutions there are. <a name="habracut"></a><br><br>  Poplar includes a graphical compiler that was created from scratch to translate standard operations used in machine learning into highly optimized application code for IPUs.  It allows you to put these graphs together on the same principle as POPNN.  The library contains a set of different types of vertices for generalized primitives. <br><br>  Graphs are the paradigm on which all software is based.  In Poplar, graphs allow you to define a calculation process, where vertices perform operations, and edges describe the connection between them.  For example, if you want to add two numbers together, you can define a vertex with two inputs (numbers that you would like to add), some calculations (the function of adding two numbers) and an output (result). <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/708/107/2ad/7081072ad3e33d401cabae1f3914bccb.jpg" alt="image"><br><br>  Usually, operations with vertices are much more complicated than in the example described above.  Often they are defined by small programs called codelets (code names).  Graphical abstraction is attractive because it does not make assumptions about the structure of the computation and breaks the computation into components that the IPU processor can use to work. <br><br>  Poplar uses this simple abstraction to build very large graphs, which are represented as images.  Software graphics generation means that we can adapt it to the specific calculations needed to ensure the most efficient use of IPU resources. <br><br>  The compiler translates standard operations used in machine learning systems into highly optimized application code for the IPU.  The graph compiler creates an intermediate image of the computation graph, which takes place on one or more IPU devices.  The compiler can display this computational graph, therefore an application written at the level of the neural network structure displays an image of the computational graph that runs on the IPU. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/45a/eb2/4b8/45aeb24b80e244c6c16c6fc584d99678.jpg" alt="image"><br>  <i>Graph of the full cycle of training AlexNet in the forward and reverse direction</i> <br><br>  The Poplar graphics compiler turned <a href="https://en.wikipedia.org/wiki/AlexNet">AlexNet‚Äôs</a> description into a computational graph of 18.7 million vertices and 115.8 million edges.  Clearly visible clustering is the result of strong communication between processes in each layer of the network with easier communication between levels. <br><br>  Another example is a simple, fully connected network that was trained in <a href="https://ru.wikipedia.org/wiki/MNIST_(%25D0%25B1%25D0%25B0%25D0%25B7%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">MNIST</a> , a simple data set for computer vision, a kind of ‚ÄúHello, world‚Äù in machine learning.  A simple network to explore this dataset helps you understand the graphs that Poplar applications manage.  By integrating graph libraries with environments such as TensorFlow, the company presents one of the easiest ways to use IPU in machine learning applications. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/f07/3bd/4e3/f073bd4e334225380ae51b16fb2e94b6.jpg" alt="image"><br><br>  After the graph has been constructed using the compiler, it needs to be executed.  This is possible using the Graph Engine.  The example of ResNet-50 demonstrates his work. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/5d7/cb1/ce5/5d7cb1ce55a80f2b8e4ebefe38681710.jpg" alt="image"><br>  <i>ResNet-50 graph</i> <br><br>  The ResNet-50 architecture allows you to create deep networks from repetitive partitions.  The processor only needs to once define these partitions and re-invoke them.  For example, the conv4 level cluster is executed six times, but only once is applied to the graph.  The image also demonstrates the variety of forms of convolutional layers, since each of them has a graph constructed in accordance with the natural form of the calculation. <br><br>  The engine creates and manages the execution of the machine learning model using the graph created by the compiler.  Once deployed, the Graph Engine monitors and responds to IPUs or devices used by applications. <br><br>  Image ResNet-50 shows the entire model.  At this level, it is difficult to isolate connections between individual vertices, so it‚Äôs worth looking at enlarged images.  Below are a few examples of sections within layers of a neural network. <br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/dbf/166/408/dbf166408a0b1626a4bd720e1be1dbe9.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/d69/9c1/fb6/d699c1fb6f2e43b9f4d03b405c543186.jpg" alt="image"><br><br><img src="https://habrastorage.org/getpro/geektimes/post_images/802/6f4/eab/8026f4eab4ee028d6894159b00421c56.jpg" alt="image"><br><br><h3>  Why do deep networks need so much memory? </h3><br>  Large amounts of occupied memory is one of the biggest problems of deep neural networks.  Researchers are trying to deal with the limited bandwidth capacity of DRAM devices, which should be used by modern systems to store a huge amount of weights and activations in a deep neural network. <br><br>  The architectures were developed using processor chips designed for sequential processing and optimization of DRAM for high-density memory.  The interface between these two devices is a bottleneck that imposes bandwidth limitations and adds significant overhead in power consumption. <br><br>  Although we still do not have a complete understanding of the human brain and how it works, it is generally understood that there is not a large separate storage of memory.  It is believed that the function of long-term and short-term memory in the human brain is built into the structure of neurons + synapses.  Even simple organisms like <a href="https://en.wikipedia.org/wiki/Caenorhabditis_elegans">worms</a> with a neural structure of the brain, consisting of just over 300 neurons, <a href="https://geektimes.ru/post/242981/">have a</a> function of memory to some degree. <br><br>  Building memory in conventional processors is one of the ways to get around the problem of memory bottlenecks, opening up a huge bandwidth with much less power consumption.  However, on-chip memory is an expensive thing that is not designed for really large amounts of memory that are connected to the central and graphics processors currently used to prepare and deploy deep-seated neural networks. <br><br>  Therefore, it is useful to look at how memory is used today in CPUs and deep learning systems on graphics accelerators, and ask yourself: why do they need such large memory storage devices when the human brain works well without them? <br><br>  Neural networks need memory in order to store input data, weight parameters and activation functions, as input is distributed through the network.  In training, input activation should be maintained until it cannot be used to calculate the output gradient errors. <br><br>  For example, the 50-layer ResNet network has about 26 million weight parameters and calculates 16 million activations in the forward direction.  If you use a 32-bit floating point number to store each weight and activate, then this will take about 168MB of space.  Using a lower accuracy value for storing these weights and activations, we could double or even quadruple this storage requirement. <br><br>  A serious memory problem arises from the fact that GPUs rely on data presented in the form of dense vectors.  Therefore, they can use a single command flow (SIMD) to achieve a high computation density.  The central processor uses similar vector blocks for high-performance computing. <br><br>  In GPUs, the synapse width is 1024 bits, so they use 32-bit floating point data, so they often break them up into parallel mini-batch of 32 samples to create data vectors of 1024 bits.  This approach to the organization of vector parallelism increases the number of activations by 32 times and the need for local storage with a capacity of more than 2 GB. <br><br>  Graphic processors and other machines designed for matrix algebra are also subject to memory load from the weights or neural network activations.  GPUs cannot efficiently perform small convolutions used in deep neural networks.  Therefore, the transformation, called ‚Äúdown‚Äù, is used to convert these convolutions into matrix-matrix multiplications (GEMM) that graphics accelerators can efficiently handle. <br><br>  Additional memory is also required to store input data, temporary values, and program instructions.  Measuring memory usage when learning ResNet-50 on a high-performance graphics processor has shown that it requires more than 7.5 GB of local DRAM. <br><br>  It is possible that someone decides that lower computational accuracy may reduce the required amount of memory, but this is not the case.  When you switch data to half-precision for weights and activations, you fill only half the vector width of the SIMD, spending half the available computing resources.  To compensate for this, when you switch from full accuracy to half the accuracy on a GPU, then you have to double the mini-batch size to cause sufficient data parallelism to use all the available calculations.  Thus, the transition to a lower accuracy of weights and activations on the graphics processor still requires more than 7.5 GB of free-access dynamic memory. <br><br>  With such a large amount of data that needs to be stored, it is simply impossible to fit all this into the graphics processor.  On each layer of the convolutional neural network, it is necessary to preserve the state of external DRAM, load the next layer of the network and then load the data into the system.  As a result, the external memory interface already limited by bandwidth by memory latency suffers from the additional burden of constantly reloading the scales, as well as storing and retrieving activation functions.  This significantly slows down the learning time and significantly increases energy consumption. <br><br>  There are several ways to solve this problem.  First, operations such as activation functions can be performed ‚Äúon the ground,‚Äù allowing you to overwrite input data directly at the output.  Thus, the existing memory can be reused.  Secondly, the ability to reuse memory can be obtained by analyzing the dependence of data between operations in the network and the distribution of the same memory for operations that do not use it at this moment. <br><br>  The second approach is especially effective when the entire neural network can be analyzed at the compilation stage in order to create a fixed allocated memory, since the cost of managing the memory is reduced almost to zero.  It turned out that a combination of these methods reduces the memory use of a neural network by two to three times. <br>  The third significant approach was recently discovered by the Baidu Deep Speech team.  They applied various memory saving techniques to get a 16-fold reduction in memory consumption by activation functions, which allowed them to train networks with 100 layers.  Previously, with the same amount of memory, they could train networks with nine layers. <br><br>  Combining memory and processing resources in a single device has significant potential for improving the performance and efficiency of convolutional neural networks, as well as other forms of machine learning.  You can make a trade-off between memory and computing resources in order to achieve a balance of capabilities and performance in the system. <br><br>  Neural networks and knowledge models in other methods of machine learning can be viewed as mathematical graphs.  In these graphs a huge amount of parallelism is concentrated.  A parallel processor designed to use parallelism in graphs does not rely on mini-batch and can significantly reduce the amount of local storage required. <br><br>  Modern research results have shown that all these methods can significantly improve the performance of neural networks.  Modern graphics and CPUs have very limited internal memory, only a few megabytes in total.  New processor architectures, specifically designed for machine learning, provide a balance between memory and on-chip computing, providing significant improvements in performance and efficiency compared to modern CPUs and graphics accelerators. </div><p>Source: <a href="https://habr.com/ru/post/402641/">https://habr.com/ru/post/402641/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../402631/index.html">Which heart rate monitor to choose in the new season: compromise solutions within three or four thousand rubles</a></li>
<li><a href="../402633/index.html">The tale of Battlefield 1 in Full HD on the integrated graphics and assembly console for the "netlenok"</a></li>
<li><a href="../402635/index.html">Uber suspends robots after a crash</a></li>
<li><a href="../402637/index.html">17-year-old schoolboy fixed NASA error</a></li>
<li><a href="../402639/index.html">Peter Watts on the game SOMA</a></li>
<li><a href="../402643/index.html">"Thin World". Chapter 10</a></li>
<li><a href="../402645/index.html">With the help of the ServoStudio 12 program and the Arduino board, you can create your robot without writing a single line of code</a></li>
<li><a href="../402647/index.html">Microsoft will respond in court for data loss when upgrading to Windows 10</a></li>
<li><a href="../402649/index.html">The most accurate in the world: Valencell heart rate monitor for Jabra, Suunto, Atlas, Sony and others</a></li>
<li><a href="../402651/index.html">Ultra high molecular weight polyethylene implant replaced bone tissue or ‚ÄúIron‚Äù polymer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>