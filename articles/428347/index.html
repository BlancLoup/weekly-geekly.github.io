<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The future of WebAssembly as a ‚Äúskill tree‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some people somehow misunderstood WebAssembly. There are those who believe that once browsers already support WebAssembly execution (since 2017), then...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The future of WebAssembly as a ‚Äúskill tree‚Äù</h1><div class="post__text post__text-html js-mediator-article">  Some people somehow misunderstood WebAssembly.  There are those who believe that once browsers already support WebAssembly execution (since 2017), then everything is ready.  Not even close yet, only MVP is ready (minimally viable product).  I can guess where this error comes from: after the release of MVP, its developers have promised to maintain backward compatibility at the level of ‚Äúany code written now <b>will</b> work in the future.‚Äù  But this does not mean that the development of WebAssembly is completed, not at all!  Many features are being developed right now and are planned for development in the near future.  And when they are implemented - everything will change very much. <br><br>  All these features you can try to imagine in the form of a tree of skills in any game.  We have a couple of ‚Äúbasic‚Äù (already implemented features) and a whole tree with a lot of branches and leaves that will eventually open, giving us more and more power. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c6f/7a8/30f/c6f7a830f86adac22fb26212840d79e6.png" alt="image"></a> <br>  Let's look at what we already have now and what we still have to open. <br>  ( <b>Under the cat a lot of pictures, traffic</b> ) <br><a name="habracut"></a><br><h2>  Minimally Viable Product (MVP) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/e24/fc2/578/e24fc257831cdd6a1e1ff997eb6e31a4.png" alt="image"><br>  At the very beginning of the creation of WebAssembly is <a href="http://kripken.github.io/emscripten-site/">Emscripten</a> , which made it possible to compile C ++ code into JavaScript code.  This made it possible to transfer to the world of the web a large number of C ++ libraries, without which the launch of higher-level code would be impossible.  The generated JS code was far from ideal and worked slowly (compared to its native version).  But still, Mozilla engineers found a couple of ways <a href="https://blog.mozilla.org/luke/2014/01/14/asm-js-aot-compilation-and-startup-performance/">to make</a> it faster.  The main one was the selection of a subset of the language that could be performed at speeds comparable to the speeds of native code execution.  This subset was called <a href="http://asmjs.org/">asm.js.</a> <br><br>  Developers of other browsers noticed and appreciated the speed of asm.js, all major browsers <a href="https://hacks.mozilla.org/2015/03/asm-speedups-everywhere">received</a> support for it.  But this was not the end of the story.  This was just the beginning.  There were still opportunities to work faster.  But they have already gone beyond Javascript.  It turned out that the native code (for example, in C ++) needed to be compiled not into Javascript, but into something else.  In something new, created specifically as a quick alternative to JS.  And so it appeared WebAssembly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is included in the first version of WebAssembly?  What was enough to get the proud title of "minimally viable product"? <br><br><h3>  Skill: target compiler platform </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/8a4/363/557/8a43635574df19b6115ac43061f809ab.png" alt="image"><br><br>  The programmers who worked on WebAssembly understood that their task was not to support C or C ++ alone.  The task was to enable compiling code in any language in WebAssembly.  This was supposed to be such an ‚Äúassembler‚Äù that should be executed in the browser, just like the computer code of the desktop application is executed, for example, on the x86 platform.  But this new language should not rely on any specific platform; its goal should be a higher level abstract platform, the concrete implementations of which would already depend on the instruction set used on this hardware. <br><br><h3>  Skill: fast code execution </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/1de/2ef/f15/1de2eff156f50e2791dee8b2fbf6c794.png" alt="image"><br><br>  Everything had to work fast.  Otherwise, why bother to plot this whole story?  In the end, the user should be able to run really ‚Äúheavy‚Äù applications, be able to play top games in the browser, etc. <br><br><h3>  Skill: compactness </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a9f/38c/906/a9f38c9069761e4e6c5619641b159399.png" alt="image"><br><br>  It is important not only the speed of the code, but also the speed of its loading.  Users are accustomed to desktop applications that run very quickly (after all, they are installed locally and have all the necessary resources at hand).  Web applications also run relatively quickly, because they do not load so many resources at once.  And this gives us a new task: if we want to create a new type of web application with a code base as large as the classic desktop, but downloadable from the Internet, the code should be as compact as possible. <br><br><h3>  Skill: memory access </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/350/e55/239/350e55239fe24dc00799045dce0bb36e.png" alt="image"><br><br>  Our new applications will also need to work with memory a little differently than JavaScript code does.  Need direct access to memory blocks.  This is due to the peculiarity of the work of languages ‚Äã‚ÄãC and C ++, in which there are pointers.  A pointer is, roughly speaking, a variable that contains an address in memory.  An application can read the data at this address, change it, and even use pointer arithmetic to ‚Äúwalk‚Äù through memory forward from the specified address.  A huge amount of code in C / C ++ uses pointers to improve the efficiency of its work, creating a target platform for such code is impossible without the support of pointers. <br><br>  But we cannot allow a piece of code downloaded from the Internet to have direct access to the memory of our process - this is too dangerous.  We will have to create an environment that, on the one hand, allows native code compiled in WebAssembly to believe that it has direct memory access, but on the other, to strictly restrict the area in which it is allowed to manipulate data. <br><br>  For this, WebAssembly uses a ‚Äúlinear memory model‚Äù.  This is implemented using TypedArrays - something like an array in JavaScript, but containing only a sequential set of bytes in memory.  When you want to put something in it, you use the access to the element by index (which can be an address in memory).  Thus, this array "pretends" as a block of memory for C ++ code. <br><br><h3>  New achievement! </h3><br>  So, with all of the above, people will finally be able to launch a desktop application in a browser with about the same performance as if it were native.  That's about this set of features and was called the ‚Äúminimally viable product‚Äù (MVP). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3a9/c6e/ac9/3a9c6eac96976ad0cd5c5893b47e9ccc.png" alt="image"><br><br>  At this stage, some applications really could already be built for WebAssembly and earn in the browser.  But there was still a long way ahead. <br><br><h2>  Heavyweight desktop applications </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/393/bfe/b91/393bfeb91e6a174d57e9a8896fd2f912.png" alt="image"><br><br>  The next important step should be the ability to run really large desktop applications.  Do you already have a full version of Photoshop running in a browser?  And you did not install it, just opened the link - and now you are 100% full of the power of this product, at native speed, the latest version with all updates and patches, on any device. <br><br>  And we are not so far from this - examples are already beginning to appear.  For example, AutoCAD.  And also Adobe Lightroom.  But let's be frank - not everything is still ready in the current implementation of WebAssembly to run truly large applications.  Bottlenecks are examined and corrected right here at the moment when you are reading this article. <br><br><h3>  Skill: multithreading </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/7c2/779/cac/7c2779cac9e06ed2a7ea21469efcb54e.png" alt="image"><br><br>  Obviously, we need multithreading.  Modern computers have many cores.  We need to be able to use them. <br><br><h3>  Skill: SIMD </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c98/11c/2ecc9811c01888acb643fb14fe70c7b3.png" alt="image"><br><br>  In addition to multi-threading, there is another technology that allows for more efficient implementation of parallel data processing.  This is SIMD: processing one instruction of several data blocks at once.  An important aspect for a really fast WebAssembly operation. <br><br><h3>  Skill: 64-bit addressing </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0fd/e7e/26d/0fde7e26d23106765832788445d65f88.png" alt="image"><br><br>  Another important feature of modern hardware architecture, which is not yet present in WebAssembly, is support for 64-bit memory addressing.  Everything is simple: with 32-bit addresses you can use only 4 GB of memory (which is very small for large programs), but with 64-bit addresses - already up to 16 exabytes (this is very much for modern software).  Of course, not only the theoretical maximum is important, but also practical (how much memory the OS will give you).  But on most modern devices already 4 or more GB of RAM and this number will grow. <br><br><h3>  Skill: streaming compilation </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/477/392/ade/477392ade953503f39a7f98214190ef1.png" alt="image"><br><br>  We need not only to quickly execute applications.  We also need to reduce the time lag between the start of its download over the network and its start.  Stream compilation allows you to start processing a WebAssembly file even before it is completely loaded.  We parse the instructions on how they are loaded over the network.  Thus loading and compilation go in parallel.  In the Firefox code, we managed to achieve a compilation speed <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">higher than the download speed</a> ‚Äî that is, the processing time of some N-byte code turned out to be less than the loading time of this code over the network.  Other browser developers are also working on streaming compilation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c7a/ad8/71f/c7aad871f04688b8f1d93480c48e6a74.png" alt="image"><br><br>  A thing related to streaming compilation is using <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">two compilers</a> .  One of them (above) works quickly and allows you to immediately run the downloaded code.  He, however, does not perform all of his theoretically possible optimizations, since it takes more time.  Such optimizations are performed by another compiler running in the background.  As soon as he finishes his work, one version in memory replaces the other and then works instead of it. <br><br>  So we get a quick start of the application, and its effective work. <br><br><h3>  Skill: caching </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/287/101/9b4/2871019b4d4d50c27713f67c9fe6ccd9.png" alt="image"><br><br>  If we have once downloaded and compiled some WebAssembly code with an optimizing compiler, then it does not make sense to do the same when loading this code in another tab (or the next time you open the browser, provided the application remains unchanged).  Compiled code can (and should) be cached and then used from the cache. <br><br><h3>  Skill: other improvements </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/85f/14f/157/85f14f1575ad1327cb1d0afa9e3ed353.png" alt="image"><br><br>  Now there are a lot of discussions about what other improvements are possible and what the efforts of the developers should be focused on.  Something will definitely be implemented, something will not immediately, something will not at all.  I, with your permission, will identify all these points in the general class ‚Äúother improvements‚Äù, and what will be included in it will be understood over time. <br><br><h3>  Where are we now? </h3><br>  Somewhere around here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a04/e7b/b13/a04e7bb13ef5b52fd1f0a5a1af4c298d.png" alt="image"><br><br><h4>  Multithreading </h4><br>  For multithreading, we have an almost complete <a href="https://github.com/WebAssembly/threads">plan</a> , but one of its key parts ( <a href="https://hacks.mozilla.org/2017/06/a-cartoon-intro-to-arraybuffers-and-sharedarraybuffers/">SharedArrayBuffers</a> ) was forced <a href="https://blog.mozilla.org/security/2018/01/03/mitigations-landing-new-class-timing-attack/">off</a> at the beginning of this year.  It will be turned on soon and we can continue. <br><br><h4>  SIMD </h4><br>  Actively <a href="">developed</a> right now. <br><br><h4>  64-bit addressing </h4><br>  For <a href="">wasm-64</a> , we have a fairly clear idea of ‚Äã‚Äãhow everything should work.  We were based on the approaches of x86 and ARM architectures. <br><br><h4>  Stream compilation </h4><br>  In Firefox, it was <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">added</a> back in 2017, other browsers are working on it. <br><br><h4>  Using two compilers </h4><br>  In Firefox, this was added back in 2017, and in other browsers in 2018. <br><br><h4>  Implicit HTTP caching </h4><br>  In Firefox, development is <a href="https://bugzilla.mozilla.org/show_bug.cgi%3Fid%3D1487113">almost complete</a> , there will be a release soon. <br><br><h4>  Other improvements </h4><br>  There is a discussion <br><br>  As you can see, most of the items are still under active development.  And nevertheless, we can already see applications running on WebAssembly today, since there are already enough opportunities for someone else.  As soon as all the above features are ready - we will open another ‚Äúnew achievement‚Äù and even more new applications will receive support for WebAssembly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/994/53c/36b/99453c36b420ead1b724c7a7e415c689.png" alt="image"><br><br><h2>  Javascript Interaction </h2><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/42e/383/372/42e383372c2216891576c4cdda6ae193.png" alt="image"></a> <br><br>  WebAssembly was created not only as a platform for games and heavyweight applications.  It can be used for regular web development.  We realize that today there are very large web applications written in Javascript and very few people will decide to take and completely rewrite them to WebAssembly.  The important point here is that it is not needed.  Most likely, most of these applications work quite well and only in some bottlenecks, there may be a lack of performance in calculations, or throughput of data processing, or lack of functionality due to the lack of a JS version of some library.  We want to give developers the opportunity to rewrite only these ‚Äúbottlenecks‚Äù in WebAssembly, leaving the rest of the code in the usual JS.  And this is already possible.  For example, by rewriting the Gutenberg parser on Rust and gathering it under WebAssebly, we managed to achieve a performance increase of <a href="https://mnt.io/2018/08/22/from-rust-to-beyond-the-webassembly-galaxy/">86 times</a> . <br><br>  But in order to make such a practice mass and comfortable, we need to implement something else. <br><br><h3>  Skill: quick calls between JS and WebAssembly </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/557/618/0ec/5576180eca50ce1736a684aa32575524.png" alt="image"><br><br>  Calling a WebAssembly from JS should work very quickly.  By adding a small WebAssembly module, the programmer should not feel any performance loss, even if this module is called very often.  This is not the case in MVP (since the goal of MVP was not to maximize the performance of such calls).  This problem has yet to be fixed.  In Firefox, we have already ensured that some JS-&gt; WebAssembly calls are <a href="https://hacks.mozilla.org/2018/10/calls-between-javascript-and-webassembly-are-finally-fast/">already faster than non-line JS-&gt; JS calls</a> .  The developers of other browsers are also working on this task. <br><br><h3>  Skill: fast data exchange </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/606/f9c/445/606f9c44570c6a3a4f64b008be4e5eda.png" alt="image"><br><br>  This task is related to the previous one: it is important not only to quickly call the WebAssembly code from JS, but also to quickly transfer data between them.  There are certain problems with this.  For example, the fact that WebAssembly understands only numbers.  There are no objects in it, but they are in JS.  So, we need some kind of broadcast layer.  It already exists, but is not yet productive. <br><br><h3>  Skill: integration with ES modules </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/15f/db4/b4f15fdb4151fccd40d509e675e3363e.png" alt="image"><br><br>  Now using a WebAssembly module looks like a special API call that will return a module for you to use.  But this means that a WebAsse assembly is not really part of the JS module graph of a web application.  To have all the functions available to the ES module (such as export and import), the WebAssembly module must be able to integrate with the ES modules. <br><br><h3>  Skill: integration into development </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/60a/a00/b26/60aa00b2662dcb635ff336ad09319e85.png" alt="image"><br><br>  Just to be able to import and export - does not mean yet to become a full-featured module.  We need a place where WebAsse modules could be distributed.  What will be analog of npm for WebAssembly?  Hmm ... what about the npm itself?  And what will be the equivalent of a webpack or Parcel for WebAssembly?  Hmm ... how about webpack and parcel? <br><br>  WebAssembly modules should not be different from regular modules, which means they can be distributed through the same infrastructure.  But we need tools for their integration into this infrastructure. <br><br><h3>  Skill: Backward Compatibility </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/e1e/86f/b36/e1e86fb36b5c6f28e1084613b8acd24f.png" alt="image"><br><br>  There is one more important thing that we must provide.  Everything should work well even in older versions of browsers.  Even in those that have no clue about WebAssembly.  We have to guarantee that by writing once the code for WebAssembly, the developer will not have to write the second version of that same code in Javascript simply because the site must open in IE11 too. <br><br><h3>  Where are we now? </h3><br>  Somewhere here: <br><img src="https://habrastorage.org/getpro/habr/post_images/49e/46e/ff9/49e46eff987d5d8de4984576f954847c.png" alt="image"><br><br><h4>  Quick calls between JS and WebAssembly </h4><br>  Already <a href="https://hacks.mozilla.org/%3Fp%3D32717">implemented</a> in Firefox, is working in other browsers. <br><br><h4>  Fast data exchange </h4><br>  There are several suggestions.  For example, extend the type system in WebAssembly with references to JS objects.  This is possible, but will cause the need to write additional code (for example, to call JS methods), which does not work too fast.  To solve this problem, in turn, there are also several suggestions. <br><br>  There is one more aspect concerning data exchange.  This includes tracking how long data can be stored in memory.  If you have any data in memory that the JS code should have access to, then you should leave it there until the JS code reads it.  But if you leave them there forever, then we will get a memory leak.  How to know that data can already be deleted (JS-code has already read them)?  To date, this responsibility lies with the programmer - everything is released manually.  As soon as the JS code has finished reading the data, it should call something like the ‚Äúfree‚Äù function.  But this approach is morally obsolete and often leads to mistakes.  To solve this problem, we introduced the concept of <a href="https://github.com/tc39/proposal-weakrefs">WeakRef</a> in Javascript.  This makes it possible to read the data on the side of the JS code, and when the garbage collector is triggered, it is possible to correctly clear the memory in the WebAssembly module. <br><br>  All this is still in development.  Meanwhile, in the Rust ecosystem <a href="https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/">, tools</a> were <a href="https://hacks.mozilla.org/2018/03/making-webassembly-better-for-rust-for-all-languages/">created</a> that automate the writing of such code for you, replacing the parts that have not yet been implemented with their own implementation.  One of these tools deserves special mention.  It is called <a href="https://rustwasm.github.io/wasm-bindgen/">wasm-bindgen</a> .  When he notices that your code on Rust is trying to get or return JS objects or DOM objects - it automatically creates a JS layer that will be able to interact with your Rust code.  This layer can also interact with the WebAssembly module written in any other language, so not only Rust programmers can use this tool. <br><br><h4>  Integration with ES-modules </h4><br>  <a href="https://github.com/WebAssembly/esm-integration/tree/master/proposals/esm-integration">The plan of</a> work in this area has been around for quite some time.  We are actively working on it in conjunction with the developers of other browsers. <br><br><h4>  Development integration </h4><br>  Already, there are tools like the <a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a> in the Rust ecosystem, allowing you to automatically pack everything you need for release into npm.  And there are people using this tool to create their own modules. <br><br><h4>  backward compatibility </h4><br>  For backward compatibility, we have the wasm2js tool.  It allows you to turn a wasm file into an equivalent .js file.  This Javascript code will not be fast, but it will work on any browser (including one that does not support WebAssembly). <br><br>  As you see, we are very close to receiving this ‚Äúachievement‚Äù.  And as soon as we do this, the path will open to two more. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/4cd/f82/ac3/4cdf82ac3ee88090ba897f2ca4b339da.png" alt="image"></a> <br><br><h2>  JS frameworks and JS compiled languages </h2><br>  The first of these is the ability to rewrite popular heavyweight JS frameworks on WebAssebly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/794/e65/121/794e6512119d46d55953dba013ed3273.png" alt="image"><br><br>  The second is to enable programming languages ‚Äã‚Äãthat compile into Javascript to replace it with WebAssembly.  We are talking about languages ‚Äã‚Äãlike <a href="https://www.scala-js.org/">Scala.js</a> , <a href="https://reasonml.github.io/">Reason</a> , <a href="https://elm-lang.org/">Elm</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31c/1ce/750/31c1ce750e3bfefe906d372292e8dfdb.png" alt="image"><br><br>  For both of these tasks, WebAssembly must support a number of new high-level features. <br><br><h3>  Skill: garbage collector </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/c3e/8eb/160/c3e8eb1609af4cde10a08081ee63f046.png" alt="image"><br><br>  We need integration with the browser garbage collector for a variety of reasons.  First, recall the task of rewriting JS frameworks (or their parts).  This may be necessary.  For example, in React we have an algorithm for comparing DOM-trees, which can be rewritten to Rust with effective multithreading.  We can also speed up something better by allocating and freeing memory.  In a virtual DOM, instead of creating a set of small objects that the garbage collector would later need to track and delete, one could use a special memory allocation scheme.  For example, allocate a block of memory at once, place all objects in it, and then delete it with one call.  This will both speed up code execution and save memory. <br><br>  But we also have to constantly interact with the JS-code.  You can't just copy data back and forth all the time, it will be inefficient.  So, you need to be able to integrate with the garbage collector running in the browser in order to be able to work with objects whose lifetime is determined by the Javascript virtual machine.  Some JS objects will need to refer to linear memory blocks created in WebAssembly modules, and some linear memory blocks will contain references to JS objects. <br><br>  If at the same time cycles are created (and they will be), then this will create problems for the garbage collector.  He will not be able to determine what else is used and what is no longer.  WebAssembly needs tighter integration with the browser's garbage collector to avoid this. <br><br>  It will also help languages ‚Äã‚Äãsuch as Scala.js, Reason, Kotlin and Elm - they can be compiled into Javascript, which means they use its garbage collector.  If WebAssembly will use it, it means that the code in these languages ‚Äã‚Äãcan be compiled for WebAssembly and should not notice any difference in terms of the nuances of the garbage collector (it will be the same). <br><br><h3>  Skill: exception handling </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/f2f/98a/88d/f2f98a88dd8f91735a5572950606811e.png" alt="image"><br><br>  We need exception handling.  Yes, some languages, like Rust, do not use exceptions.  But many others use it.  At the moment, you can replace exception handling with a code with no exceptions - but it works slowly.  Thus, now when developing for WebAssembly, it is better not to use exceptions initially. <br><br>  In addition, there are exceptions in Javascript.  Even if you don‚Äôt use them in your code, some standard function can throw it away and you need to do something about it.  If your WebAssembly-code will cause a JS-code, and that will throw an exception - we cannot process it correctly.  The code on Rust, for example, will simply crash.  This needs to be changed, we need a normally working exception handling script. <br><br><h3>  Skill: debugging </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/0dc/5f2/b8a/0dc5f2b8a7da6d533192464f6258c314.png" alt="image"><br><br>  Another thing that JS developers are used to is good debugging tools.  All modern browsers have tools for convenient analysis of Javascript code.  We need the same level of support for WebAssembly. <br><br><h3>  Skill: tail calls </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/365/d07/1d8/365d071d8415b5510f45f70982edee2e.png" alt="image"><br><br>  To support functional languages, we need a thing called <a href="https://en.wikipedia.org/wiki/Tail_call">tail calls</a> .  I will not delve into this topic, somewhat simplifying it can be said that the tail call is a way in some cases to call a function without allocating a frame for it in the stack.  Since this feature is crucial for functional languages, we want to have its support in WebAssembly. <br><br><h3>  Where are we now? </h3><br>  Somewhere here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f5/b0d/853/8f5b0d8534744ec21059f27231fa080b.png" alt="image"><br><br><h4>  Garbage collection </h4><br>  To implement garbage collection, there is currently work in two directions: it is <a href="https://github.com/tschneidereit/typed-objects-explainer">Typed Objects</a> for JS and, in fact, <a href="https://github.com/WebAssembly/gc">the garbage collector for WebAssembly</a> .  Typed Objects will allow to describe the clear structure of the object.  There is already a vision of how this should work, and it will be discussed at the upcoming TC39 meeting.  Accordingly, the GC for WebAssembly will be able to access the above structure for its own purposes.  Work is already underway on its implementation. <br><br>  As soon as both parts are completed, we will get a system from interacting JS and WebAssembly, which is able to understand at all levels what the object consists of and effectively use its internal data.  We already have a working prototype.  The prototype, however, cannot simply be taken and released - we have to spend some time on standardization and editing.  We expect that it will come to release somewhere in the 2019th year. <br><br><h4>  Exception Handling </h4><br>  Work on <a href="">exceptions is</a> now at the research and development stage.    ,   ,     . <br><br><h4>  Debugging </h4><br>           Firefox.     .            ,     .        ,         .   <a href=""> </a>    . <br><br><h4>   </h4><br> <a href=""> </a> . <br><br>      ‚Äî   ,    ¬´JS-    JS ¬ª <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/8cb/651/7b4/8cb6517b4483f2b4f566783157f9511d.png" alt="image"></a> <br><br> ,     ¬´¬ª  .      ? <br><br><h2>   </h2><br> ,      ¬´ ¬ª.     -  ,     ?   ¬´¬ª      ¬´WebAssembly¬ª.     HTML, CSS  JavaScript ‚Äî   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c4/c11/606/9c4c1160641ee4014f7317b71711f3d2.png" alt="image"><br><br> ,    ,      .          ‚Äî  .    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f34/d7b/4f4/f34d7b4f4d2fdfe6487614b4d1530416.png" alt="image"><br><br>         .      -  .     ,     . -     ‚Äî     ,    .             ,   .         , ,  ,   ¬´¬ª   -: , ,   .. <br><br>          . <br><br> -,     ?    -      ,        ‚Äî     .     -    ,  Windows,  . .    ‚Äî     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b38/d74/4c1/b38d744c118cebfdff5d8cd198f8a490.png" alt="image"><br><br>       .  ,        .     ,       .    ?    - .       -  .   ,      ,   -    ,          . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0bf/1d6/0c6/0bf1d60c6df0e2a76b4afb83e3dffe42.png" alt="image"><br><br> ,    ¬´¬ª:   .  ,            .                     HTML, CSS  Javascript?          ,   WebAssembly. <br><br>   ,    WebAssembly   ¬´  ,    ¬ª.   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1df/51f/fe5/1df51ffe596ea6f2f45543f913ca7911.png" alt="image"><br><br>            . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5da/71e/e98/5da71ee982b4cb6a126d14aa962ed491.png" alt="image"><br><br><h2> Node.js </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/b5c/643/c55/b5c643c55f8c180e50e1a24ee4122ef6.png" alt="image"><br><br>  WebAssembly   Node?  . <br><br> Node      ,   Javascript.      ,   JS-        JS-,     .   Node   .              ,     Node. <br><br>       ,          .   ,        :     ,   . <br><br>   ,      WebAssembly,       .       , ,  Javascript-.        . <br><br>     Node         .    Node-  Linux  Windows ‚Äî      - .    WebAssembly-       (    ).   (  )  Node    ,      ‚Äî   Node.  ,  WebAssembly-     ‚Äî       . -  <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a> - (   ,             ). <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/a08/e88/688/a08e88688da9312cf9b0821ea1ebd9de.png" alt="image"><br><br> ,    Node-   WebAssembly-? -     .    . ,    Node    ,    -.   WebAssembly-    ‚Äî   . -  ¬´POSIX  WebAssembly¬ª. PWSIX (portable WebAssembly system interface)? <br><br><h3>   ? </h3><br>  <a href="https://github.com/domenic/package-name-maps"></a> ,         . , ,      Nod (    ).     ,    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/69c/74f/63f/69c74f63fd64008d91dbf31a18dce24e.png" alt="image"><br><br>       - .  ,     . <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/ae2/750/50f/ae275050f12b82aba399d26d50656c0f.png" alt="image"></a> <br><br><h2> CDN, Serverless,  Edge Computing </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/c16/77d/224/c1677d22458933b7f3c07cdf47b9bf12.png" alt="image"><br><br>     ,  CDN, Serverless, Edge Computing. ,        ,       .     WebAssembly?    <a href="https://www.youtube.com/watch%3Fv%3DFkM1L8-qcjU"></a>   .   ‚Äî            (   ) .          .     JS (SpiderMonkey  V8) - ,       .  WebAssembly ‚Äî . <br><br>   ,    ? <br><br><h3> :   </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/965/16f/e4c/96516fe4ccb30f39a885d1f460033e0c.png" alt="image"><br><br>         .      WebAssembly ( <a href="https://github.com/CraneStation/cranelift">Cranelift</a> ) ‚Äî      .          ‚Äî    - , -    .   ,  Fastly,     .       ‚Äî              ,   .       ,    ‚Äî     . <br><br><h3>   ? </h3><br> -  : <br><img src="https://habrastorage.org/getpro/habr/post_images/bba/460/2be/bba4602be78c2f8132a7106d7463218f.png" alt="image"><br><br>     .           ,     . , <a href="https://github.com/WAVM/WAVM">WAVM</a>  wasmjit. <br><br>      ,   Cranelift,    wasmtime.       -   ,       , , , ‚Ä¶ <br><br><h2>     </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/90a/f8f/a14/90af8fa14441a34a3652478d0bd9b948.png" alt="image"><br><br> WebAssembly      ,      .      (  <a href="https://github.com/nebulet/nebulet"></a> ,     ),  WebAssembly-      .        , ,   ,      . <br><br><h2>   </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/18f/10a/dcd/18f10adcda7bfa676d90b6e92cb2bb30.png" alt="image"><br><br>  ¬´ ¬ª       (    /  ¬´ ¬ª).               JS-,   WebAssembly ‚Äî   .    Cranelift     wasmtime     ,   -     .     WebAssembly           .      ‚Äî   IoT-         .  WebAssembly        ‚Äî    . <br><br><h2>  findings </h2><br>          ¬´ ¬ª. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/0c6/201/71f/0c620171f0b0c2b880e730e84ee9f1b4.png" alt="image"></a> <br><br>      ,       WebAssembly   .      ‚Äî    . , MVP    .    -   WebAssembly     .      ‚Äî        ,  JS-     ¬´ ¬ª,    .      ‚Äî    . ,  ,  .      ,        : , ,  ,    ‚Äî  . <br><br> WebAssembly  .   . </div><p>Source: <a href="https://habr.com/ru/post/428347/">https://habr.com/ru/post/428347/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428337/index.html">Entertaining javascript: no braces</a></li>
<li><a href="../428339/index.html">Do not automate it: bad business advice</a></li>
<li><a href="../428341/index.html">RAID EE technology in Qsan storage</a></li>
<li><a href="../428343/index.html">Interesting problem in C</a></li>
<li><a href="../428345/index.html">Covering the requirements of cases. The realities of SuperJob</a></li>
<li><a href="../428349/index.html">Cucumber in the cloud: using BDD scripts for load testing a product</a></li>
<li><a href="../428351/index.html">I see you: machine learning and artificial neural networks in the study of the sight of fruit flies</a></li>
<li><a href="../428353/index.html">How we made a system for mobile rounds at SIBUR</a></li>
<li><a href="../428355/index.html">Mechanics of gamification: rating</a></li>
<li><a href="../428357/index.html">Absorption in practice: life story</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>