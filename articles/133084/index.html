<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ Variadic templates. Currying and partial application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear Habrasoobschestvo. 
 Recently, we had to observe a discussion about currying and partial application. The essence of this controversy w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ Variadic templates. Currying and partial application</h1><div class="post__text post__text-html js-mediator-article"> Good day, dear Habrasoobschestvo. <br>  Recently, we had to observe a discussion about currying and partial application.  The essence of this controversy was that it is better, for practical purposes, to have in a programming language: embedded partial applications (for example, as in <a href="http://ru.wikipedia.org/wiki/Nemerle">Nemerle</a> ) or embedded curries (as, for example, in <a href="http://ru.wikipedia.org/wiki/Haskell">Haskell</a> ). <a name="habracut"></a><br>  <b>Nemerle:</b> <br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">x:</span></span></span></span><span class="hljs-function"><span class="hljs-params"> int, </span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">y:</span></span></span></span><span class="hljs-function"><span class="hljs-params"> int, </span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">z:</span></span></span></span><span class="hljs-function"><span class="hljs-params"> int)</span></span></span></span>: int /<span class="hljs-regexp"><span class="hljs-regexp">/   { x + y + z; }; def sum3y = sum3(_, 5, _); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     def sum3yz = sum3y(_, 5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    def sum3yzx = sum3yz(5); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ‚Ä¶ ,  15</span></span></code> </pre> <br>  <b>Haskell:</b> <br><pre> <code class="hljs pgsql">sum3 xyz = x + y + z <span class="hljs-comment"><span class="hljs-comment">--   sum3x = sum3 5 --     sum3xy = sum3x 5 --   sum3xyz = sum3xy 5 -- ‚Ä¶ ,  15</span></span></code> </pre> <br>  Personally, I think you need to implement both entities.  Especially since enough time has passed since that moment when gcc features appeared from the upcoming C ++ standard, namely Variadic templates.  As you understand, the article proposes the implementation of currying and partial application for C ++ using Variadic templates.  During the work, MinGW gcc 4.6.1 and Code :: Blocks 10.05 were used. <br><br><h4>  Currying </h4><br>  Let's start with currying, especially since it is intuitive.  The goal will be considered a higher order function, which takes a function and returns its curried version.  Next, you can pass an arbitrary number of arguments to this function, resulting in another function that takes the remaining arguments and returns the final result. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) &gt; f = [] ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y + z; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f1 = carry(f); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f2 = f1(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v15 = f2(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br>  We need an object that will store the objective function, and will behave as a function itself, which takes an unfixed number of arguments.  And the result of the action of this function object on its arguments must be another object, which in addition to the function still saves the passed arguments, because in C ++ the data that is on the stack does not live forever, they need to be copied, that is, for such a case, copyable objects .  Addresses, of course, no one forbade.  It is possible to philosophize in this direction for a very long time and, I think, for each case to find the optimal solution.  You can even, in the future, designate somehow whether you need to copy one or another argument, and maybe the link will suffice. <br>  Further, this object should behave as a simple function and take a specific number of arguments, namely the remaining ones.  So, we need a template class that depends on the type of the objective function.  Further, to save the passed arguments, their number and types are needed, and the number and types of the remaining arguments are needed to determine the resulting function.  Experimentally, it was determined that it is best to pass a type of function and two sets of indices to the pattern: transferred and remaining.  The implementation focused on the std :: function wrapper, and the arguments were stored in std :: tuple.  A number of auxiliary templates were also used to manipulate numbers and types during compilation ‚Äî I hope their names will be a good explanation of their essence, since they themselves can claim to be a separate library, and it is not possible to describe them here. <br>  Below is the class code that stores the function and data, as well as the class code that behaves like a function that takes an uncommitted number of arguments.  I want to draw attention to the abundant use of <b><a href="http://en.wikipedia.org/wiki/Variadic_template">pack expansion</a></b> for templates. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarryHolder</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OUT_TYPE</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IN_TYPES</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uint32_t</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CAP_INDEXES</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uint32_t</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RES_INDEXES</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CarryHolder</span></span></span><span class="hljs-class">&lt; std::function&lt; OUT_TYPE ( IN_TYPES... ) &gt;, UintContainer&lt; CAP_INDEXES... &gt;, //    UintContainer&lt; RES_INDEXES... &gt; &gt; //    {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; OUT_TYPE ( IN_TYPES... ) &gt; FuncType; <span class="hljs-comment"><span class="hljs-comment">//    typedef std::tuple&lt; typename UnQualify&lt; //  const  &amp; typename GetNthType&lt; CAP_INDEXES, TypeContainer&lt;IN_TYPES...&gt; &gt;::Result &gt;::Result... &gt; CleanCapTupleType; //      typedef std::function&lt; OUT_TYPE ( typename GetNthType&lt; RES_INDEXES, TypeContainer&lt;IN_TYPES...&gt; &gt;::Result... ) &gt; ReturnFuncType; //    public: CarryHolder( FuncType const&amp; f, typename UnQualify&lt; typename GetNthType&lt; CAP_INDEXES, TypeContainer&lt;IN_TYPES...&gt; &gt;::Result &gt;::Result const&amp;... capturedValues ): _function(f), _capturedData( capturedValues... ) { }; CarryHolder( CarryHolder const&amp; other ): _function(other._function), _capturedData( other._capturedData ) { }; //    inline OUT_TYPE operator()( typename GetNthType&lt; RES_INDEXES, TypeContainer&lt;IN_TYPES...&gt; &gt;::Result... other_values ) { //        return _function( std::get&lt; CAP_INDEXES &gt; (_capturedData)..., other_values ... ); }; private: CarryHolder(); FuncType _function; CleanCapTupleType _capturedData; }; template&lt; class &gt; class Carry; template&lt; class OUT_TYPE, class... IN_TYPES &gt; class Carry&lt; std::function&lt; OUT_TYPE (IN_TYPES...) &gt; &gt; { public: typedef typename std::function&lt; OUT_TYPE (IN_TYPES...) &gt; FuncType; constexpr static uint32_t ArgsCount = GetTypesLength&lt; TypeContainer&lt;IN_TYPES...&gt; &gt;::Result; Carry( Carry const&amp; carry ): _function( carry._function ) { }; Carry( FuncType const&amp; f ): _function( f ) { }; template&lt; class... INNER_IN_TYPES &gt; inline auto operator()( INNER_IN_TYPES const&amp; ... values ) -&gt; typename CarryHolder&lt; FuncType, //      typename UintRange&lt; GetTypesLength&lt; TypeContainer&lt;INNER_IN_TYPES...&gt; &gt;::Result &gt;::Result, //      typename UintRangeFromTo&lt; GetTypesLength&lt; TypeContainer&lt;INNER_IN_TYPES...&gt; &gt;::Result, ArgsCount &gt;::Result &gt;::ReturnFuncType //  CarryHolder   std::function { typedef CarryHolder&lt; FuncType, typename UintRange&lt; GetTypesLength&lt; TypeContainer&lt;INNER_IN_TYPES...&gt; &gt;::Result &gt;::Result, typename UintRangeFromTo&lt; GetTypesLength&lt; TypeContainer&lt;INNER_IN_TYPES...&gt; &gt;::Result, ArgsCount &gt;::Result &gt; CarryHolderSpec; return CarryHolderSpec( _function, values... ); }; private: Carry(); FuncType _function; }; template&lt; class FUNC_TYPE &gt; Carry&lt;FUNC_TYPE&gt; carry( FUNC_TYPE const&amp; f ) //    { return Carry&lt;FUNC_TYPE&gt;(f); };</span></span></code> </pre> <br><br><h4>  Rearrangement of arguments </h4><br>  To implement partial application, you can use the approach of rearranging arguments with further currying.  It will look like this: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) &gt; f = [] ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y + z; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f1 = permute&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;(f);</code> </pre> <br>  We, as before, need an object that will hold the target function, but it will behave like a normal function that takes a specific number of arguments, or rather, the rearranged arguments of the target function.  For this, a template class is needed, which depends on the type of the function and on the sequence of indices - permutations of the arguments.  A template will also be necessary to supplement the permutation (explained below) and search for the inverse permutation (inverse index).  Direct permutation is needed to form a sequence of types of input parameters, and the inverse to insert arguments during a function call.  An internal class is also used to expand the inverse index type.  Below is the class code that implements this functionality. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Permutation</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OUT_TYPE</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IN_TYPES</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uint32_t</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">INDEXES</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Permutation</span></span></span><span class="hljs-class">&lt; std::function&lt; OUT_TYPE (IN_TYPES...) &gt;, //    UintContainer&lt; INDEXES... &gt; &gt; //   {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; OUT_TYPE (IN_TYPES...) &gt; FuncType; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; OUT_TYPE (<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> GetNthType&lt; INDEXES, TypeContainer&lt;IN_TYPES...&gt; &gt;::Result...) &gt; NewFuncType; Permutation( Permutation <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; perm ): _function( perm._function ) { }; Permutation( FuncType <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&amp; f ): _function( f ) { }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//        template&lt; uint32_t... INVERSE &gt; inline OUT_TYPE apply( UintContainer&lt; INVERSE... &gt;, //    , ..  typename GetNthType&lt; INDEXES, TypeContainer&lt;IN_TYPES...&gt; &gt;::Result... values ) { //    std::tuple    std::tuple&lt; typename GetNthType&lt; INDEXES, TypeContainer&lt;IN_TYPES...&gt; &gt;::Result... &gt; data( values... ); //    std::tuple    return _function( std::get&lt; INVERSE &gt; (data)... ); }; public: inline OUT_TYPE operator()( typename GetNthType&lt; INDEXES, TypeContainer&lt;IN_TYPES...&gt; &gt;::Result... values ) { //    typename InversePermutation&lt; UintContainer&lt;INDEXES...&gt; &gt;::Result inverse; return apply( inverse, values... ); }; private: Permutation(); FuncType _function; }; //   ;  Permutation  std::function template&lt; uint32_t... INDEXES, class FUNC_TYPE &gt; auto permute( FUNC_TYPE const&amp; f ) -&gt; typename Permutation&lt;FUNC_TYPE, //  , ..      typename ComplementRange&lt; GetArgumentsCount&lt;FUNC_TYPE&gt;::Result, UintContainer &lt; INDEXES... &gt; &gt;::Result &gt;::NewFuncType { typedef Permutation&lt;FUNC_TYPE, typename ComplementRange&lt; GetArgumentsCount&lt;FUNC_TYPE&gt;::Result, UintContainer &lt; INDEXES... &gt; &gt;::Result &gt; PermutationType; return PermutationType(f); };</span></span></code> </pre> <br>  Now a partial application, having the described functionality, becomes trivial - the code below. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>... INDEXES, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FUNC_TYPE</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">partApply</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FUNC_TYPE</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> ) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">decltype</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">carry</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">permute</span></span></span><span class="hljs-class">&lt;INDEXES...&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">))) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> carry(permute&lt;INDEXES...&gt;(f)); };</code> </pre> <br>  And given the possibility of supplementing indices, this can be used to indicate not all indices: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) &gt; f = [] ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y + z; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f1 = permute&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;(f); <span class="hljs-comment"><span class="hljs-comment">//  &lt;2, 0, 1&gt; -  "   "</span></span></code> </pre> <br>  These are the possibilities offered by Variadic templates.  Later, if interested, lay out the code. <br>  Actually, the currying was not quite classic, since it is one-step and ‚Äúmandatory‚Äù, that is, passing all the arguments to the curried (in the sense of a realized functional) function, we still get a <i>function</i> that does not accept arguments.  Also, the non-classical essence is noticeable during the manipulation of qualifiers.  But all of these are C ++ features. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>UPDATE:</b> <br>  I found that the CarryHolderSpec in Carry :: operator () does not need to be wrapped unnecessarily in the std :: function, since the arguments are being copied again.  But, I think, references to temporary objects will help to bypass it. <br><br>  <b>UPDATE:</b> <br>  Transferred the topic to ‚ÄúAbnormal programming‚Äù, I think it will be more comfortable here. </div><p>Source: <a href="https://habr.com/ru/post/133084/">https://habr.com/ru/post/133084/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133079/index.html">Another grumble about Yandex Market</a></li>
<li><a href="../133080/index.html">An economic BitCoin tasting sauce or what BitCoin and Lady Gaga have in common?</a></li>
<li><a href="../133081/index.html">LG GT540: Increase partition size / data due to / system</a></li>
<li><a href="../133082/index.html">http: // (Any_word) .jpg.to</a></li>
<li><a href="../133083/index.html">We are looking for unused PHP extensions</a></li>
<li><a href="../133085/index.html">Sending SMS from 3G / GSM modem</a></li>
<li><a href="../133086/index.html">Multisiting in Drupal</a></li>
<li><a href="../133087/index.html">HelloWorld - is it easy?</a></li>
<li><a href="../133088/index.html">Arduino in Chinese or Arduinski vernier caliper</a></li>
<li><a href="../133089/index.html">Lean startup on the turn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>