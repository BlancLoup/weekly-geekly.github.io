<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How virtual reality came to the project on Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Fashion trends bring new problems to life make change" Probably it was from this thought that the decision was made to connect to the project on Unit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How virtual reality came to the project on Unity</h1><div class="post__text post__text-html js-mediator-article">  <i>"Fashion trends <s>bring new problems to life</s> make change"</i> Probably it was from this thought that the decision was made to connect to the project on Unity, the virtual reality helmet, the well-known Oculus Rift DK2.  Contrary to the harsh probing of the financial bottom by the ruble, we managed to order the Oculus Rift with delivery to St. Petersburg at an adequate price.  Quickly, in less than two weeks, the order arrived at the walls of our office. <br><br><img src="https://habrastorage.org/files/863/c71/113/863c7111362e49d58c724cec26339b34.png"><br><a name="habracut"></a><br><h4>  Overall impression </h4><br>  In the box, as expected, the helmet itself was lying, a set of necessary cables, 2 sets of lenses and a helmet positioning camera in space.  After unpacking and connecting to the test computer, the first oddity was immediately revealed.  The helmet refused to work in Direct Display mode, feeling great in the second monitor mode.  Moreover, this feature was observed only on the test computer.  As a solution, a lot of adequate and not very decisions were made in the form of reinstalling drivers, installing missing Microsoft Visual C ++ Redistributable and other ‚Äúnecessary‚Äù applications and libraries.  After reinstalling Windows, the helmet still only worked in the advanced display mode.  But a wise colleague installed all the Windows updates available at that time on the test computer, for which many thanks to him.  And one, but the most necessary, out of more than a thousand installed updates solved the problem, the helmet started working in Direct Mode. <br><br>  At last, it was possible to get down to the delicious - opportunity testing <s>games</s> .  The first impression is ‚ÄúWOW‚Äù.  The brain actively claimed that everything is real and can even be touched.  Words can not describe it, it is better to try. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Project Integration </h4><br>  Let's skip the lyrics, it's time to get down to serious things - the integration of the helmet into the project on the Unity engine. <br>  The first step is to download the official package of <a href="https://developer.oculus.com/downloads/">Oculus Unity 4 Integration</a> , the most current version.  The developers of the package really want to say, thank you, the player‚Äôs prefab is done perfectly, with a few clicks you can immerse yourself in the virtual reality of your project.  Only here the image and the definition of the position and turn the head for a full-fledged project is not enough, you need to do a few things: <br><ul><li>  display user interface; </li><li>  show the cursor; </li><li>  calculate the beam from the cameras; </li></ul><br>  Getting to the implementation as the source prefab was taken - OvrCameraRig, located in the official package to Unity. <br><br><h5>  User Interface Display </h5><br>  After experiments and reworking the entire interface used, and there is plenty of it, the most optimal direction is chosen - to receive an image from the interface camera into a texture, then display it in front of the player.  Adding a new class, responsible for the integration of the helmet in the project.  The first lines of code appeared in it, which allows you to find the desired camera by the interface layer mask and get an image from it. <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> guiLayerName; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> guiLayerPlaneName; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Color backgroundColor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.5f</span></span>); [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject guiPlanePrefab = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RenderTexture _guiRenderTexture = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RenderTexture guiRenderTexture { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == _guiRenderTexture) { _guiRenderTexture = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RenderTexture(Screen.width, Screen.height, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _guiRenderTexture; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Transform centerEyeAnchor = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Camera guiCamera = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guiLayer = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> guiLayerPlane = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject guiPlane = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { guiLayer = LayerMask.NameToLayer(guiLayerName); guiLayerPlane = LayerMask.NameToLayer(guiLayerPlaneName); guiCamera = NGUITools.FindCameraForLayer(guiLayer); centerEyeAnchor = GetComponent&lt;OVRCameraRig&gt;().centerEyeAnchor; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> != guiCamera) { guiRootPanel = guiCamera.GetComponentInParent&lt;UIPanel&gt;(); guiCamera.targetTexture = guiRenderTexture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> != guiPlanePrefab) { guiPlane = Instantiate(guiPlanePrefab) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> GameObject; guiPlane.layer = guiLayerPlane; guiPlane.renderer.material.mainTexture = guiRenderTexture; Vector3 ls = guiPlane.transform.lossyScale; Vector3 lp = guiPlane.transform.position; Quaternion lr = guiPlane.transform.rotation; guiPlane.transform.parent = transform; guiPlane.transform.localScale = ls; guiPlane.transform.localPosition = lp; guiPlane.transform.localRotation = lr; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnityException(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Camera for layer {0} not found"</span></span>, guiLayer)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RenderTexture previousActive = RenderTexture.active; RenderTexture.active = guiRenderTexture; GL.Clear(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, backgroundColor ); RenderTexture.active = previousActive; guiCamera.Render(); }</code> </pre> <br>  Initially, the picture with the interface was displayed on a regular rectangular plane, but when using a helmet, discomfort arose.  Were tried various options for the shape of the surface, the most pleasing to the eye was a curved plane, similar to modern curved TVs.  The plane with the necessary values ‚Äã‚Äãwas moved to a separate prefab, but you can not do this and skip a section of the code with the position of the plane.  I recommend to choose such parameters of the position of the plane in front of the player, so that the user, by bringing his head closer, could not see what the plane looks like from behind, but not too far, so that in case you can bring your head closer and read what is written.  As a result, when you start it turned out about this picture. <br><br><img src="https://habrastorage.org/files/3bb/b8a/6a7/3bbb8a6a7eab46a08cbd13586a481369.png"><br><br>  To display the plane with the image of the menu on top of all objects of the environment, you need to <s>google</s> to write a shader that will always draw itself on top of all.  The manual for writing shaders to the Unity engine in the article <a href="http://docs.unity3d.com/Manual/SL-CullAndDepth.html">‚ÄúShaderLab syntax: Culling &amp; Depth Testing‚Äù</a> describes what to add to the shader pass the ZTest Always parameter and there <s>will be happiness the</s> shader will draw as planned.  Choosing the first unshadowed shader, I used the shader that came with NGUI, copy it, give it a new name, and add the ZTest parameter. <br><br><pre> <code class="cpp hljs">Pass { Cull Off Lighting On ZWrite Off ZTest Always Fog { Mode Off } Offset <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span> Blend SrcAlpha OneMinusSrcAlpha CGPROGRAM <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> vertex vert #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> fragment frag #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"UnityCG.cginc"</span></span></span><span class="hljs-meta"> ... }</span></span></code> </pre><br>  The view from the editor allows you to see that even though the plane crosses the wall of the building, the image is still drawn last. <br><br><img src="https://habrastorage.org/files/394/f5a/e17/394f5ae176a1423ca996f04410bcfa50.png"><br><br>  And so it looks in a helmet: <br><br><img src="https://habrastorage.org/files/85c/cb1/28b/85ccb128bf8a4069a40c0dc3f0738164.png"><br><br>  I liked the result of the work, both in terms of resources and in appearance.  Throwing aside virtual reality, you can pour yourself another cup of coffee and chat with colleagues about being worldly. <br><br><h5>  Cursor </h5><br>  <i>‚ÄúWhere does all this why is unclear.</i>  <i>I would sit drinking coffee, look at a flat monitor, I don‚Äôt really need this virtual reality.</i>  <i>Although I am deceiving whom, of course, I need "</i> <br>  I never thought that it would be difficult to display the cursor, but for the helmet it turned out to be a very interesting task.  The first and most obvious thing is to draw the cursor on a normal interface and display it on the plane in front of the player. <br>  <a href="http://tasharen.com/ngui/docs/class_u_i_panel.html">UIPanel</a> , <a href="http://www.tasharen.com/ngui/docs/class_u_i_sprite.html">UISprite</a> or <a href="http://www.tasharen.com/ngui/docs/class_u_i_texture.html">UITexture</a> , it turns out the cursor.  Beautiful, elegant, simple.  But the helmet is completely different.  Moving the cursor with the mouse - moving, pointing at the interface element - responds, great, I can't even believe it.  We hover the cursor on an empty menu area, look into space and the brain tries to focus on the object in space, but some kind of fly on the glass, the cursor, prevents it from doing, either the cursor splits, or the space ahead.  Of course, you can make the menu disappear and appear at the request of the user.  This is done by adding a couple of lines of code and several additional properties. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> KeyCode showMenuKey = KeyCode.None; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> displayTime = <span class="hljs-number"><span class="hljs-number">0.61f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alphaCalculate = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> UIPanel guiRootPanel = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ guiRootPanel = guiCamera.GetComponentInParent&lt;UIPanel&gt;(); ‚Ä¶ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RenderTexture previousActive = RenderTexture.active; RenderTexture.active = guiRenderTexture; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> != guiRootPanel) guiRootPanel.alpha = alphaCalculate; Color color = backgroundColor * <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Color(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, alphaCalculate); GL.Clear(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, color); RenderTexture.active = previousActive; guiCamera.Render(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LateUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKeyDown(showMenuKey)) { menuIsShow = !menuIsShow; StopCoroutine(<span class="hljs-string"><span class="hljs-string">"LerpAlpha"</span></span>); StartCoroutine(‚ÄúLerpAlpha‚Äù, (menuIsShow ? <span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LerpAlpha</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> endAlpha</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> time = Mathf.Abs(endAlpha - alphaCalculate) / displayTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t &lt; time) { t += Time.deltaTime; alphaCalculate = Mathf.Lerp(alphaCalculate, endAlpha, t / time); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre><br>  Perhaps this will be enough in those projects where the menu is not used in the game world.  But the current project meant a different use of the menu and the search for solutions continued. <br>  The idea of ‚Äã‚Äãa ‚Äúlaser pointer‚Äù was tested.  Attach a new object to the player with a light source, set the following parameters. <br><br><img src="//habrastorage.org/files/6df/867/e8d/6df867e8d4714c4b84fd2a81c5525636.png"><br><br>  And the cat's dream, the glowing point, moves through the virtual world.  In the helmet, the eyes can not rejoice.  Point exactly on the object where it points and no discomfort.  Having played enough with the <i>‚Äúlaser pointer‚Äù</i> in the virtual world, I return to the real one and I understand that the decision is not entirely suitable.  Replacing the light source on the spotlight turns a beautiful cursor, it can be not only a luminous point, but also any picture that is available. <br><br><img src="//habrastorage.org/files/ccd/708/f94/ccd708f94a304207a92e23a64bd38674.PNG"><br><br>  Plus, the following shader must be inserted into the spotlight material: <br><br><pre> <code class="cpp hljs">Shader<span class="hljs-string"><span class="hljs-string">"Projector/Additive"</span></span>{ Properties{ _ShadowTex(<span class="hljs-string"><span class="hljs-string">"Cookie"</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>D)=<span class="hljs-string"><span class="hljs-string">""</span></span>{TexGenObjectLinear} } Subshader{ Pass{ CullBack ZWriteOff Color[_Color] ColorMaskRGB BlendSrcAlphaOneMinusSrcAlpha Offset0,<span class="hljs-number"><span class="hljs-number">0</span></span> SetTexture[_ShadowTex]{ constantColor(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) combinetexture*constant,texture Matrix[_Projector] } } } }</code> </pre><br>  The searchlight has a small limitation, it is invisible on the skybox.  To correct this feature, I decided to do the following: <br><ol><li>  added a new child object to the searchlight; </li><li>  On this object added components: <a href="http://docs.unity3d.com/ScriptReference/MeshRenderer.html">MeshRenderer</a> , <a href="http://docs.unity3d.com/ScriptReference/Mesh.html">Mesh</a> ; </li><li>  chose a non-illuminated material with a cursor; </li><li>  set according to the length and size of the spotlight. </li></ol><br>  This result was the result: <br><br><img src="//habrastorage.org/files/42a/434/216/42a43421609942b79183e18e1888404c.png"><br><br><img src="//habrastorage.org/files/4d2/8cd/d62/4d28cdd628b04edfb13db6cb061e0eee.png"><br><br>  As a result, there is a cursor that is visible in space, but not visible in the menu and vice versa, is in the menu, but causes discomfort when it is displayed in space. <br><br>  <i>There was an idea to write for the cameras a shader drawing a picture of the cursor for the eye with a shift to the nose, depending on ZDepth.</i>  <i>But the idea ended on the fact that my knowledge in the field of writing shaders is limited, and I cannot imagine how to do this.</i>  <i>Maybe someone in the comments will suggest how to implement this idea.</i> <br><br>  Leaving everything as it is, I took up the definition of the position of the cursor.  There is a cursor position according to the mouse pointer, there are values ‚Äã‚Äãof rotation and position of the head.  How to most adequately manage the cursor is completely unclear.  <i>‚ÄúTruth is born in a dispute.‚Äù</i> After a brief discussion with colleagues, their opinions were divided, one half said that moving the cursor is better with the mouse, the other - better with the head.  <i>"It is better to try once and then discuss."</i> <br><br>  The first option is easier to make for the cursor in the menu. <br>  The position of the <a href="http://docs.unity3d.com/ScriptReference/Input-mousePosition.html">Input.mousePosition</a> cursor is translated into coordinates and the cursor moves according to these coordinates. <br>  The second option is well suited for the cursor in space. <br>  Searchlight to make a child to look, and the cursor is now controlled by the head. <br>  The result, the ability to use two cursors, one is controlled by the mouse and used in the menu, the other is controlled by the head and used in space.  It seems not bad, I save each cursor into separate prefabs for dynamic creation and use in the future and add the following code to the helmet integration class. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject cursor3dPrefab = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject cursor2dPrefab = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject cursor3d = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject cursor2d = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> != cursor3dPrefab) { cursor3d = Instantiate(cursor3dPrefab) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> GameObject; cursor3d.transform.parent = centerEyeAnchor; cursor3d.transform.localPosition = Vector3.zero; cursor3d.transform.localRotation = Quaternion.identity; cursor3d.transform.localScale = Vector3.one; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> != cursor2dPrefab) { cursor2d = Instantiate(cursor2dPrefab) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> GameObject; cursor2d.transform.parent = guiCamera.transform; cursor2d.transform.localPosition = Vector3.zero; cursor2d.transform.localRotation = Quaternion.identity; cursor2d.transform.localScale = Vector3.one; UITexture texture = cursor2d.GetComponentInChildren&lt;UITexture&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> != texture) cursor2d = texture.gameObject; } ... }</code> </pre><br>  But two different cursors, and even that are controlled differently, it seemed to me careless execution. <br><br><h5>  ScreenPointToRay for Raycast </h5><br>  <i>‚ÄúThat we should build a house, we will draw life‚Äù</i> <br>  Half way traveled.  It is necessary to calculate and return the beam.  One very good idea, instantly, visited my poor head, it is a pity it happens not regularly.  You must write an extension for the camera that had the following call, Camera.main.ExternalScreenPointToRay, and returned a new beam.  This requires the code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExternalCamera</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RayExternalScreenPointToRay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">thisCameracamera,Vector3position</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> camera.ScreenPointToRay(position); } }</code> </pre><br>  Added static flag about the ability to use the calculations of the position of the helmet. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> useOVR { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  As well as adding a static reference to an instance of a class. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ExtensionOVR instance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  Do not forget to assign values ‚Äã‚Äãto them in the Start () function <br><br><pre> <code class="cs hljs">instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; useOVR = <span class="hljs-literal"><span class="hljs-literal">true</span></span>;</code> </pre><br>  Such a singleton turned out. <br><br>  To switch by the mode of calculating the value of the beam, I created the following enumeration.  Oh, and I love to do it, to produce transfers. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> CameraRay { Head, Cursor }</code> </pre><br>  As a starting point, I decided to take the following condition: if the camera is three-dimensional, the beam is where the spotlight is directed, if two-dimensional, the beam is the position where the spotlight intersects and the plane on which the render menu is displayed.  Those.  calculations will take about the following form: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Ray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScreenPointToRay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Camera camera, Vector2 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> camera.orthographic ? guiPointToRay : headPointToRay; }</code> </pre><br>  And the camera extension code will look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Ray </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExternalScreenPointToRay</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Camera camera, Vector3 position</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExtensionOVR.useOVR ? ExtensionOVR.instance.ScreenPointToRay(camera, position) : camera.ScreenPointToRay(position); }</code> </pre><br>  To calculate the beam of a three-dimensional cursor, everything is extremely clear: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Ray headPointToRay { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (cameraRay == CameraRay.Cursor &amp;&amp; <span class="hljs-literal"><span class="hljs-literal">null</span></span> != cursor3d) ? <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ray(cursor3d.transform.position, cursor3d.transform.forward) : <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ray(centerEyeAnchor.position, centerEyeAnchor.forward); } }</code> </pre><br>  To calculate the position of the two-dimensional beam, it is necessary to find the intersection of the searchlight and the plane.  This is easy to calculate using <a href="http://docs.unity3d.com/ScriptReference/RaycastHit-textureCoord.html">RaycastHit.textureCoord</a> .  <a href="http://docs.unity3d.com/Manual/class-MeshCollider.html">Mesh Collider is</a> added to the plane <a href="http://docs.unity3d.com/Manual/class-MeshCollider.html">beforehand</a> and it is highlighted in a separate layer. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 cursorPosition { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Ray guiPointToRay { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(headPointToRay, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit, <span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; guiLayerPlane)) { cursorPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2(hit.textureCoord.x * Screen.width, hit.textureCoord.y * Screen.height); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> guiCamera.ScreenPointToRay(cursorPosition); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ray(); } } }</code> </pre><br>  Slightly added change the cursor position according to the selected mode in the Update () function. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cameraRay == CameraRay.Cursor &amp;&amp; <span class="hljs-literal"><span class="hljs-literal">null</span></span> != cursor3d) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); cursor3d.transform.LookAt(cursor3d.transform.position + ray.direction); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> != cursor2d) { cursor2d.transform.localPosition = cursorPositionOffset; }</code> </pre><br>  Well, and another property for convenience: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 cursorPositionOffset { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cursorPosition + offsetCursor; } }</code> </pre><br>  Now replacing all calls of ScreenPointToRay with ExternalScreenPointToRay, the cursor synchronously moves in the menu and in space, to watch one sight.  True, there is a small minus.  The cursor is now visible on the plane and in space at the same time.  Slightly transforming the code of the Shader plane with the image of the interface, remove the translucency. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">v2f </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">appdata_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span></span>{ ... o.color.a = v.color.a &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-number"><span class="hljs-number">3</span></span> : <span class="hljs-number"><span class="hljs-number">0</span></span>; ... }</code> </pre><br>  And the final stroke, in the interface where the cursor should be displayed, the collider hangs up and checking whether the two-dimensional cursor is over the interface collider display it, or hide it otherwise. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> enable2DCursor { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Physics.Raycast(guiCamera.ScreenPointToRay(cursorPosition), <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>.MaxValue, <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; guiLayer); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enable2DCursor) { cursor2d.transform.localPosition = cursorPositionOffset; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cursor2d.transform.localPosition = Vector3.up * <span class="hljs-number"><span class="hljs-number">10000</span></span>; } ... }</code> </pre><br>  That's all, there is the ability to navigate through the menu, it is possible to display the cursor where the vision will focus, it is possible to calculate the ray for Raycast. <br><br><h4>  Total </h4><br>  What I want to give recommendations for optimizing the project for the virtual world based on the experience gained. <br><ul><li>  Use a large font, just look at the billboard when you start the helmet, despite the fact that someone would say that a large font does not look.  It is better to hear from the user that looks ugly, than what is incomprehensible what is written and he can not work with it. </li><li>  All the two-dimensional menu to try to move to the center, it is better to make it three-dimensional.  But it is better to do it from scratch, and not to redo the existing one. </li><li>  The use of a virtual reality helmet significantly improves product presentation. </li><li>  To use a virtual reality helmet you need a very well optimized scene.  Otherwise, at high settings, the image blurs and the body feels not very well. </li><li>  This is written in the manual, but I‚Äôll add on my own do not use MSAA 8x, the size of the RenderTexture for the eye weighs&gt; 100 Mb in memory, which can not but grieve. </li></ul><br>  PS Probably some will think that this is nonsense and why for the spatial cursor I did not use a cheaper method with raycast and drawing a billboard directed towards the player with calculation of its size relative to the distance.  On the stage in the project used, colliders are not everywhere and some colliders do not correspond to the size of the object and as a result it turns out that the cursor sometimes hangs incomprehensibly where and how. </div><p>Source: <a href="https://habr.com/ru/post/249053/">https://habr.com/ru/post/249053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249039/index.html">How I implemented multilingualism on the site and in the project</a></li>
<li><a href="../249041/index.html">YouTube abandoned Flash in favor of HTML5 by default.</a></li>
<li><a href="../249045/index.html">C # for AS3 developers. Part 4: Abstract Classes and Functions</a></li>
<li><a href="../249047/index.html">Sass-architecture of your project</a></li>
<li><a href="../249051/index.html">Do not use MediaPlayer and MediaMetadataRetriever in Android</a></li>
<li><a href="../249055/index.html">Universal way to monitor Asterisk using Zabbix</a></li>
<li><a href="../249057/index.html">What should be said instead of ‚Äúfool himself!‚Äù Or 4 stories about the power of one question</a></li>
<li><a href="../249061/index.html">(Kiev) Recruitment for the course ‚ÄúIT-Project Management IT.Projects‚Äù using PMBOK standards</a></li>
<li><a href="../249063/index.html">(Kiev) In March, the Linux troubleshooting course starts.</a></li>
<li><a href="../249065/index.html">Creating MVPP: a minimally viable product to be proud of</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>