<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Qt wrapper around gRPC framework in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. Today we will look at how to link the gRPC framework in C ++ and the Qt library. The article provides a code summarizing the use of all four in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Qt wrapper around gRPC framework in C ++</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello.  Today we will look at how to link the gRPC framework in C ++ and the Qt library.  The article provides a code summarizing the use of all four interaction modes in gRPC.  In addition, there is a code that allows gRPC to be used through Qt signals and slots.  The article may be of interest primarily to Qt developers interested in using gRPC.  However, a summary of the four gRPC modes of operation is written in C ++ without using Qt, which will allow developers to adapt the code to non-Qt developers.  All interested in asking under the cat. </p><a name="habracut"></a><br><h2>  Prehistory </h2><br><p>  About half a year ago, two projects hung on me, using the client and server parts of gRPC.  Both projects fell into production.  These projects were written by developers who have already quit.  I was glad only that I was actively involved in writing the gRPC server and client code.  But that was about a year ago.  Therefore, as usual, I had to deal with everything from scratch. </p><br><p>  The gRPC server code was written with the expectation that it will be further generated from the .proto file.  The code was written well.  However, the server had one big disadvantage: only one client could connect to it. </p><br><p>  The gRPC client was written terribly. </p><br><p>  I figured out the client and server code for gRPC only a few days later.  And I realized that if I had taken a project for a couple of weeks, I would have to deal with the gRPC server and client again. </p><br><p>  It was then that I decided that it‚Äôs time to write and debug the gRPC client and server so that: </p><br><ul><li><p>  You could sleep at night; </p></li><li><p>  There was no need to remember how this works every time you need to write a gRPC client or server; </p></li><li><p>  It was possible to use the written client and server gRPC in other projects. </p></li></ul><br><p>  When writing code, I was guided by the following requirements: </p><br><ul><li><p>  Both the gRPC client and server can work using the signals and slots of the Qt library in a natural way; </p></li><li><p>  The gRPC client and server code does not need to be corrected when the .proto file is changed; </p></li><li><p>  The gRPC client must be able to tell the client code the status of the connection to the server. </p></li></ul><br><p>  The structure of the article is as follows.  First, there will be a brief overview of the results of working with client code and small explanations to it.  At the end of the review link to the repository.  Next will be general things about architecture.  Then a description of the server and client code (what is under the hood) and the conclusion. </p><br><h2>  Short review </h2><br><p>  The simplest pingproto.proto file was used as the .proto file, which defines the RPC of all types of interaction: </p><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> pingpong; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> ping { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> SayHello (PingRequest) returns (PingReply) {} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeMe(PingRequest) returns (stream PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> GladToSeeYou(stream PingRequest) returns (PingReply){} <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> BothGladToSee(stream PingRequest) returns (stream PingReply){} } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingRequest { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> PingReply { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> message = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  The pingpong.proto file repeats the file helloworld.proto from the article about the <a href="https://habr.com/post/340758/">asynchronous modes of gRPC in C ++,</a> up to names. </p><br><p>  As a result, the written server can be used like this: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT; QpingServerService pingservice; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A() { <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> is_ok; is_ok = connect(&amp;pingservice, SIGNAL(SayHelloRequest(SayHelloCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onSayHello(SayHelloCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeMeRequest(GladToSeeMeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeMe(GladToSeeMeCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(GladToSeeYouRequest(GladToSeeYouCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onGladToSeeYou(GladToSeeYouCallData*))); assert(is_ok); is_ok = connect(&amp;pingservice, SIGNAL(BothGladToSeeRequest(BothGladToSeeCallData*)), <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, SLOT(onBothGladToSee(BothGladToSeeCallData*))); assert(is_ok); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSayHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SayHelloCallData* cd)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; cd-&gt;peer() &lt;&lt; <span class="hljs-string"><span class="hljs-string">"][11]: request: "</span></span> &lt;&lt; cd-&gt;request.name() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; cd-&gt;reply.set_message(<span class="hljs-string"><span class="hljs-string">"hello "</span></span> + cd-&gt;request.name()); cd-&gt;Finish(); } <span class="hljs-comment"><span class="hljs-comment">//etc. };</span></span></code> </pre><br><p>  When a client calls an RPC, the gRPC server notifies the client code (in this case, class A) with the appropriate signal. </p><br><p>  The gRPC client can be used like this: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> B : <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> QObject { Q_OBJECT QpingClientService pingPongSrv; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: B() { <span class="hljs-type"><span class="hljs-type">bool</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(SayHelloResponse(SayHelloCallData*)), this, SLOT(onSayHelloResponse(SayHelloCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeMeResponse(GladToSeeMeCallData*)), this, SLOT(onGladToSeeMeResponse(GladToSeeMeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(GladToSeeYouResponse(GladToSeeYouCallData*)), this, SLOT(onGladToSeeYouResponse(GladToSeeYouCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(BothGladToSeeResponse(BothGladToSeeCallData*)), this, SLOT(onBothGladToSeeResponse(BothGladToSeeCallData*))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); c = <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span>(&amp;pingPongSrv, SIGNAL(channelStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>)), this, SLOT(onPingPongStateChanged(<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>))); <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(c); } <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">usage</span></span>() { //Unary PingRequest request; request.set_name("user"); request.set_message("user"); pingPongSrv.SayHello(request); //<span class="hljs-keyword"><span class="hljs-keyword">Server</span></span> streaming PingRequest request2; request2.set_name("user"); pingPongSrv.GladToSeeMe(request2); //etc. } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> slots: <span class="hljs-type"><span class="hljs-type">void</span></span> SayHelloResponse(SayHelloCallData* response) { std::cout &lt;&lt; "[11]: reply: " &lt;&lt; response-&gt;reply.message() &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; } //etc. };</code> </pre><br><p>  The gRPC client allows you to call RPC directly, and subscribe to the server's response using the appropriate signals. </p><br><p>  The gRPC client also has a signal: <br><br></p><pre> <code class="hljs objectivec">channelStateChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>);</code> </pre><br>  which reports past and current connection status to the server.  All code with examples of use is in <a href="https://github.com/Mityuha/qgrpc">the qgrpc repository</a> . <br><br><h2>  How it works </h2><br><p>  The principle of including the client and gRPC server in the project is shown in the figure. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/i3/h9/ad/i3h9ad3c3joddotb7akq1iagpnc.jpeg"></div><br><p>  The .pro project file contains the .proto files on which gRPC will work.  The grpc.pri file contains commands for generating gRPC and QgRPC files.  The protoc compiler generates [protofile] .grpc.pb.h and [protofile] .grpc.pb.cc files.  [protofile] is the name of the .proto file passed to the input of the compiler. </p><br><p>  The generation of QgRPC files [protofile] .qgrpc. [Config] .h is handled by the script genQGrpc.py.  [config] is either "server" or "client". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The generated QgRPC files contain a Qt wrapper around the gRPC classes and calls with the appropriate signals.  In previous examples, the QpingServerService and QpingClientService classes are declared respectively in the generated pingpong.qgrpc.server.h and pingpong.qgrpc.client.h files.  The generated QgRPC files are added to moc processing. </p><br><p>  In the generated QgRPC files, QGrpc [config] .h files are included, in which all the main work takes place.  Read more about this below. </p><br><p>  To connect all this construction to the project, in the .pro project file you need to include the grpc.pri file and specify three variables.  The GRPC variable defines the .proto files to be transferred to the inputs of the protoc compiler and the genQGrpc.py script.  The variable QGRPC_CONFIG determines the configuration value of the generated QgRPC files and may contain the values ‚Äã‚Äã‚Äúserver‚Äù or ‚Äúclient‚Äù.  You can also define an optional variable GRPC_VERSION to indicate the version of gRPC. </p><br><p>  For more information on all this, read the grpc.pri file and the .pro sample files. </p><br><h2>  Server architecture </h2><br><p>  The class diagram of the server is shown in the figure. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nd/ec/ae/ndecaezqpvmh1kn9iviw6yuic9i.jpeg"></div><br><p>  Thick arrows show the class inheritance hierarchy, and thin ones show class members and methods belonging.  In general, a service is generated for the service class Q [servicename] ServerService, where servicename is the name of the service declared in the .proto file.  RPCCallData are control structures generated for each RPC in the service.  In the constructor of the QpingServerService class, the base class QGrpcServerService is initialized by the asynchronous service gRPC pingpong :: ping :: AsyncService.  To start the service, you need to call the Start () method with the address and port on which the service will run.  The Start () function implements the standard service start procedure. </p><br><p>  At the end of the Start () function, the pure virtual function makeRequests () is called, which is implemented in the generated QpingServerService class: </p><br><pre> <code class="hljs xml">void makeRequests() { needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHello_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">SayHelloCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMe_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeMeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYou_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">GladToSeeYouCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); needAnotherCallData<span class="hljs-tag"><span class="hljs-tag">&lt; </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSee_RPCtypes</span></span></span><span class="hljs-tag">, </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">BothGladToSeeCallData</span></span></span><span class="hljs-tag"> &gt;</span></span>(); }</code> </pre><br><p>  The second template parameter of the needAnotherCallData function is the generated RPCCallData structures.  These same structures are the parameters of the signals in the generated class of the Qt service. </p><br><p>  The generated RPCCallData structures are inherited from the ServerCallData class.  In turn, the ServerCallData class is inherited from the ServerResponder responder.  Thus, the creation of an object of generated structures leads to the creation of a responder object. </p><br><p>  The constructor for the ServerCallData class takes two parameters: signal_func and request_func.  signal_func is a generated signal that is called after the tag has been received from the queue.  request_func is a function that should be called when creating a new responder.  For example, in this case, it could be the RequestSayHello () function.  The call to request_func occurs exactly in the needAnotherCallData () function.  This is done so that responder management (creation and deletion) takes place in the service. </p><br><p>  The needAnotherCallData () function code consists of creating a responder object and calling a function that associates a responder with an RPC call: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCCallData</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RPCTypes</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">needAnotherCallData</span></span></span><span class="hljs-class">() {</span></span> RPCCallData* cd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RPCCallData(); <span class="hljs-comment"><span class="hljs-comment">//... RequestRPC&lt;RPCTypes::kind, ...&gt; (service_, cd-&gt;request_func_, cd-&gt;responder, ..., (void*)cd); }</span></span></code> </pre><br><p>  RequestRPC () functions are template functions for four kinds of interactions.  As a result, the RequestRPC () call is reduced to a call: </p><br><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">cd-&gt;request_func_</span></span>)(...,cd-&gt;responder, (<span class="hljs-name"><span class="hljs-name">void*</span></span>)cd)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  where service_ is a gRPC service.  In this case, it is pingpong :: ping :: AsyncService. </p><br><p>  To synchronously or asynchronously check the event queue, you must call the CheckCQ () or AsyncCheckCQ () functions, respectively.  The function code CheckCQ () is reduced to calls to the function of synchronous retrieval of a tag from a queue and processing of this tag: </p><br><pre> <code class="hljs pgsql">virtual <span class="hljs-type"><span class="hljs-type">void</span></span> CheckCQ() override { <span class="hljs-type"><span class="hljs-type">void</span></span>* tag; <span class="hljs-type"><span class="hljs-type">bool</span></span> ok; server_cq_-&gt;Next(&amp;tag, &amp;ok); //tagActions_ <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tag) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; AbstractCallData* cd = (AbstractCallData*)tag; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!started_.<span class="hljs-keyword"><span class="hljs-keyword">load</span></span>()) { destroyCallData(cd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } cd-&gt;cqReaction(this, ok); }</code> </pre><br><p>  After receiving the tag from the queue, the validity of the tag and the start of the server are checked.  If the server is turned off, then the tag is no longer needed - you can delete it.  After that, the cqReaction () function is called, defined in the ServerCallData class: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqReaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> QGrpcServerService* service_, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!first_time_reaction_) { first_time_reaction_ = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; service_-&gt;needAnotherCallData&lt;RPC, RPCCallData&gt;(); } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> genRpcCallData = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(genRpcCallData); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;CouldBeDeleted()) { service_-&gt;destroyCallData(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//call generated service signal with generated call data argument service_-&gt;(*signal_func_)(genRpcCallData); }</span></span></code> </pre><br><p>  The flag first_time_reaction_ says that you need to create a new responder for the called RPC.  The CouldBeDeleted () and ProcessEvent () functions are inherited from the corresponding type of Responder ServerResponder class.  The CouldBeDeleted () function returns a sign that the responder object can be deleted.  The processEvent () function processes the tag and the ok flag.  So, for example, for the Client Streaming view responder, the function looks like this: </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* tag, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;tag_ = tag; read_mode_ = ok; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  The ProcessEvent () function, regardless of the type of responder, always returns true.  The return value of this function is left for possible extension of the functionality and, theoretically, to eliminate errors. </p><br><p>  After processing the event, the call follows: <br><br></p><pre> <code class="hljs lisp">service_-&gt;(<span class="hljs-name"><span class="hljs-name">*signal_func_</span></span>)(<span class="hljs-name"><span class="hljs-name">genRpcCallData</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><p>  The variable service_ is an instance of the generated service, in our case QpingServerService.  The variable signal_func_ is a service signal corresponding to a specific RPC.  For example, SayHelloRequest ().  The variable genRpcCallData is the responder object of the corresponding type.  From the perspective of the calling code, the genRpcCallData variable is an object of one of the generated RPCCallData structures. <br></p><br><h2>  Client architecture </h2><br><p>  Whenever possible, the names of the classes and functions of the client coincide with the names of the classes and functions of the server.  The client class diagram is shown in the figure. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4u/ak/xe/4uakxee1iettn1zm_7fooerdosc.jpeg"></div><br><p>  Thick arrows show the class inheritance hierarchy, and thin ones show class members and methods belonging.  In the general case, a Q [servicename] ClientService class is generated for the service, where servicename is the name of the service declared in the .proto file.  RPCCallData are control structures generated for each RPC in the service.  For an RPC call, the generated class provides functions whose names exactly match the RPC declared in the .proto file.  In our example, in the .proto file, the RPC SayHello () is declared as: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SayHello</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingRequest</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">PingReply</span></span></span><span class="hljs-function">)</span></span> {}</code> </pre><br><p>  In the generated QpingClientService class, the corresponding RPC function looks like this: </p><br><pre> <code class="hljs vbscript">void SayHello(PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!connected()) return; SayHelloCallData* <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SayHelloCallData; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;<span class="hljs-built_in"><span class="hljs-built_in">request</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder = stub_-&gt;AsyncSayHello(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;context, <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>, &amp;cq_); <span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;responder-&gt;Finish(&amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;reply, &amp;<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>-&gt;status, (void*)<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>); }</code> </pre><br><p>  The generated RPCCallData structures, as in the case of the server, are ultimately inherited from the ClientResponder class.  Therefore, creating an object of the generated structure leads to the creation of a responder.  After the responder is created, an RPC call is made and the responder is bound to the event of receiving a response from the server.  From the point of view of client code, the RPC call looks like this: </p><br><pre> <code class="hljs vbscript">void ToSayHello() { PingRequest <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_name(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">request</span></span>.set_message(<span class="hljs-string"><span class="hljs-string">"user"</span></span>); pingPongSrv.SayHello(<span class="hljs-built_in"><span class="hljs-built_in">request</span></span>); }</code> </pre><br><p>  Unlike the generated QpingServerService server class, the QpingClientService class is inherited from two template classes: ConnectivityFeatures and MonitorFeatures. </p><br><p>  The ConnectivityFeatures class is responsible for connecting the client to the server and provides three functions for use: grpc_connect (), grpc_disconnect (), grpc_reconnect ().  The grpc_disconnect () function simply deletes all the data structures responsible for interacting with the server.  A call to the grpc_connect function is reduced to calls to the grpc_connect_ () function, which creates control data structures: </p><br><pre> <code class="hljs php">void grpc_connect_() { channel_ = grpc::CreateChannel(target_, creds_); stub_ = GRPCService::NewStub(channel_); channelFeatures_ = std::make_unique&lt;ChannelFeatures&gt;(channel_); channelFeatures_-&gt;checkChannelState(); }</code> </pre><br><p>  The ChannelFeatures class monitors the state of the <em>channel_</em> communication <em>channel</em> with the server.  The ConnectivityFeatures class encapsulates an object of the ChannelFeatures class and uses this object to implement the abstract functions channelState (), checkChannelState () and connected ().  The channelState () function returns the last observed state of the communication channel with the server.  The checkChannelState () function, in fact, returns the current state of the channel.  The connected () function returns the sign of the client connecting to the server. <br></p><br><p>  The MonitorFeatures class is responsible for receiving and processing events from the server and provides the CheckCQ () function for use: </p><br><pre> <code class="hljs ruby">bool CheckCQ() { auto service<span class="hljs-number"><span class="hljs-number">_</span></span> = dynamic_cast&lt; SERVICE* &gt;(this); <span class="hljs-regexp"><span class="hljs-regexp">//connection</span></span> state auto old_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;channelState(); auto new_state = conn<span class="hljs-number"><span class="hljs-number">_</span></span>-&gt;checkChannelState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (old_state != new_state) service-&gt;*channelStateChangedSignal<span class="hljs-number"><span class="hljs-number">_</span></span>(old_state, new_state); <span class="hljs-regexp"><span class="hljs-regexp">//end</span></span> of connection state void* tag; bool ok = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; grpc::CompletionQueue::NextStatus st; st = cq<span class="hljs-number"><span class="hljs-number">_</span></span>.AsyncNext(&amp;tag, &amp;ok, deadlineFromMSec(<span class="hljs-number"><span class="hljs-number">100</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((st == grpc::CompletionQueue::SHUTDOWN) <span class="hljs-params"><span class="hljs-params">||</span></span> (st == grpc::CompletionQueue::TIMEOUT)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; (AbstractCallData&lt; SERVICE &gt;*)(tag)-&gt;cqActions(service<span class="hljs-number"><span class="hljs-number">_</span></span>, ok); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br><p>  The code structure is the same as in the server case.  Unlike the server, a block of code is added to the client that is responsible for handling the current state.  If the link status has changed, the signal is called channelStateChangedSignal_ ().  In all generated services, this is a signal: <br><br></p><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelStateChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  Also, unlike the server, here the AsyncNext () function is used instead of Next ().  This was done for several reasons.  First, when using AsyncNext (), the client code has the ability to learn about the change in the state of the communication channel.  Secondly, when using AsyncNext (), it is possible to call various RPCs in the client code any number of times.  Using the Next () function in this case will result in blocking the thread before receiving the event from the queue and, as a result, in losing the two possibilities described. <br><br><p>  After receiving the event from the queue, as in the case of the server, the cqReaction () function, defined in the ClientCallData class, is called: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cqActions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPC::Service* service, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ok)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> response = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;RPCCallData*&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* tag = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt;(response); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;processEvent(tag, ok)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; service-&gt;*func_( response ); }</code> </pre><br><p>  As with the server, the processEvent () function processes the tag and the ok flag and always returns true.  As in the case of the server, after the event is handled, the signal of the generated service is called.  However, there are two significant differences from the eponymous server function.  The first difference is that the creation of responders does not occur in this function.  Creation of responders, as shown above, occurs when calling RPC.  The second difference is that in this function the responders are not deleted.  The lack of deletion of responders is done for two reasons.  First, client code can use pointers to the generated RPCCallData structures for their own purposes.  Deleting the contents of this pointer, hidden from the client code, can lead to unpleasant consequences.  Secondly, deleting the responder will cause the data signal not to be generated.  Consequently, the client code will not receive the last server message.  Among several alternative solutions to the indicated problems, a solution was chosen to shift the deletion of the responder (generated structures) to the client code.  Thus, signal handler functions (slots) must contain the following code: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResponseHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RPCCallData* response)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response-&gt;CouldBeDeleted()) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> response; <span class="hljs-comment"><span class="hljs-comment">//process response }</span></span></code> </pre><br><p>  Failure to delete the responder in the client code will lead not only to a memory leak, but also to possible problems with the communication channel.  Signal handlers of all types of RPC interactions are implemented in the example code. </p><br><h2>  Conclusion </h2><br><p>  In conclusion, we note two points.  The first point is related to calling the CheckCQ () functions of the client and server.  They work, as shown above, according to one principle: if there is an event in the queue, a signal with the corresponding generated RPCCallData structure is ‚Äúemitted‚Äù.  You can call this function manually and check (in the case of a client) the presence of an event.  But initially the idea was to transfer the entire network portion associated with gRPC to another stream.  For these purposes, QGrpcSrvMonitor auxiliary classes for the gRPC server and QGrpcCliServer for the gRPC client were written.  Both classes work on the same principle: they create a separate stream, put the generated service into this stream, and periodically call the CheckCQ () function of this service.  Thus, when using both auxiliary classes, there is no need to call CheckCQ () functions in the client code.  The signals of the generated service, in this case, "come" from another thread.  Client and server examples are implemented using these helper classes. </p><br><p>  The second point concerns the majority of developers who do not use the Qt library in their work.  Qt classes and macros in QgRPC are used only in two places: in the generated service files, and in files containing helper classes: QGrpcServerMonitor.h and QGrpcClientMonitor.h.  The rest of the files with the Qt library are not related.  It was planned to add an assembly using cmake, and stub some Qt directives.  In particular, the QObject class and the Q_OBJECT macro.  But this simply did not reach the hands.  Therefore, any suggestions are welcome. </p><br><p>  That's all.  Thanks to all! </p><br><h2>  Links </h2><br><ul><li><p>  <a href="https://github.com/Mityuha/qgrpc">Repository with QgRPC code</a> </p></li><li><p>  <a href="https://habr.com/post/340758/">Asynchronous gRPC in C ++</a> </p></li></ul></div><p>Source: <a href="https://habr.com/ru/post/420237/">https://habr.com/ru/post/420237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420225/index.html">Infinite algorithmic melody based on prime numbers</a></li>
<li><a href="../420227/index.html">Turkish President announced a ban on the import of electronics from the US</a></li>
<li><a href="../420229/index.html">Can children in villages become programmers if they are taught only to railway workers? Talk with "Circle"</a></li>
<li><a href="../420233/index.html">UE4 | Inventory for multiplayer # 5 | Information transfer between Server and Client</a></li>
<li><a href="../420235/index.html">Zenject: How an IoC container can kill Dependency Injection on your project</a></li>
<li><a href="../420239/index.html">Mobile development. Swift: the mystery of the protocols</a></li>
<li><a href="../420243/index.html">Breakthrough Philanthropy: Breakthrough projects on a scale of Humanity</a></li>
<li><a href="../420245/index.html">How to prevent memory overruns when using Java collections</a></li>
<li><a href="../420247/index.html">Is it worth it to go to a specialist in the Far East</a></li>
<li><a href="../420251/index.html">Apple claims that the company's headquarters complex costs only $ 200.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>