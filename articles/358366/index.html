<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Natural Motion Simulation: Steering Behaviors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Steering behaviors help autonomous characters to move realistically through the use of simple forces, the combination of which creates a natural-looki...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Natural Motion Simulation: Steering Behaviors</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/5f7/74f/2f35f774f25e0415fbe497a2eda4dfd0.png" alt="image"></div><br>  Steering behaviors help autonomous characters to move realistically through the use of simple forces, the combination of which creates a natural-looking and improvised movement around the environment.  In this tutorial, I will talk about the basics of the theory of steering behaviors, as well as their implementation. <br><br>  The ideas on which such behaviors are built are proposed by <a href="http://www.red3d.com/cwr/">Craig Reindolds</a> ;  they are not based on complex strategies using path planning or global computing, but use local information, such as the strength of neighboring objects.  Because of this, they are easy to understand and implement, but at the same time capable of creating very complex patterns of movement. <br><a name="habracut"></a><br>  <em><strong>Note:</strong> although this tutorial was written in AS3 and Flash, the same techniques and concepts can be used in almost any game development environment.</em>  <em>You will need a basic understanding of math vectors.</em> <br><br><hr><br><h2>  Part 1. Behavior Seek (search) </h2><br><h2>  Position, speed and movement </h2><br>  Realization of all forces involved in steering behaviors is possible using mathematical vectors.  Since these forces affect the speed and position of the character, it will also be logical to use vectors to represent them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Although the vector has a <em>direction</em> , we will ignore it when it comes to the position (we assume that the position vector indicates the character‚Äôs current location). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a52/70a/1a1/a5270a1a190b739db3a8f670c47918c4.png"></div><br>  The image above shows a character in <code>(x, y)</code> and having speed <code>(a, b)</code> .  Motion is calculated using <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25AD%25D0%25B9%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0">the Euler method</a> : <br><br><pre> <code class="actionscript hljs">position = position + velocity</code> </pre> <br>  The direction of the velocity vector will control the direction of movement of the character, and its length (or value) will control the amount of movement for each frame.  The greater the length, the faster the character moves.  The velocity vector can be truncated so that it does not exceed a certain value (usually this is the maximum speed).  The image below shows this approach. <br><br>  Red square moves towards the goal.  The motion pattern illustrates the behavior of <em>seek</em> , but so far <strong>without</strong> control forces applied.  The green line indicates the velocity vector, calculated as follows: <br><br><pre> <code class="actionscript hljs">velocity = normalize(target - position) * max_velocity</code> </pre> <br>  It is important to note that without a controlling force, the character describes the direct routes and instantly changes its direction as the target moves, thus making a sharp transition between the current and the new routes. <br><br><hr><br><h2>  Force calculation </h2><br>  If only the force of speed is involved, the character will move only in a straight line defined by the direction of this vector.  One of the principles of steering behaviors is to influence the movement of the character by adding forces (called <em>controlling forces</em> ).  Thanks to these forces, the character will move in one direction or another. <br><br>  In the case of seek behavior, adding a character in each frame of control forces causes him to smoothly change speed, avoiding abrupt changes of route.  If the target moves, the character will <em>gradually</em> change its speed vector, trying to reach the target in its new location. <br><br>  Two forces are involved in the seek behavior: the <em>required speed</em> and the <em>controlling</em> force: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/330/78d/db5/33078ddb5d7db3e776cd56543fdbc01d.png"></div><br>  <em>The required speed</em> is the force directing the character to the target along the shortest possible path (in a straight line between them - previously it was the only force acting on the character).  <em>The control</em> force is the result of subtracting the current speed from the desired speed;  she also directs the character to the goal. <br><br>  These forces are calculated as follows: <br><br><pre> <code class="actionscript hljs">desired_velocity = normalize(target - position) * max_velocity steering = desired_velocity - velocity</code> </pre> <br><hr><br><h2>  Force application </h2><br>  After calculating the control force, it must be applied to the character (it will be added to the force of speed).  The frame-by-frame addition of the control force to the speed causes the character to smoothly leave the old straight route and head towards the target, describing <strong>the search trajectory</strong> (the orange curve in the figure below): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a6/865/7df/2a68657dfb6280a8eebc2a80e874ee2f.png"></div><br>  The application of these forces and the calculation of the final velocity / position are as follows: <br><br><pre> <code class="actionscript hljs">steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering , max_speed) position = position + velocity</code> </pre> <br>  The control force is truncated so that it cannot exceed the amount of permissible forces that the character can handle.  In addition, the control force is divided by the mass of the character, which creates different speeds for characters with different weights. <br><br>  Each time the target moves, the vector of the <em>required speed of</em> each character changes accordingly.  However, the change in the <em>velocity</em> vector and the fact that he again pointed to the target, takes some time.  The result is smooth motion transitions. <br><br><hr><br><h2>  Part 2. Flee and Arrival Conduct </h2><br><h2>  Runaway </h2><br>  The behavior of seek described above is based on two forces that guide the character to the goal: the required speed and control force. <br><br><pre> <code class="actionscript hljs">desired_velocity = normalize(target - position) * max_velocity steering = desired_velocity - velocity</code> </pre> <br>  In this case, <code>desired_velocity</code> is the shortest path between the character and the target.  It is obtained by subtracting the position of the target from the position of the character.  The result is a force vector passing from the <em>character</em> to the <em>target</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/330/78d/db5/33078ddb5d7db3e776cd56543fdbc01d.png"></div><br>  In the behavior of the flee, the same two forces are used, but they are configured so that the character <em>runs away</em> from the target: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/815/17f/3db/81517f3dbf04cc6c632e9cc59e41512b.png"></div><br>  <i>Flee Behavior</i> <br><br>  This new <code>desired_velocity</code> vector <code>desired_velocity</code> calculated by subtracting the <em>character</em> 's position from the <em>target's</em> position, which gives us a vector directed from the <em>target</em> to the <em>character</em> . <br><br>  The resulting strengths are calculated almost the same as in seek behavior: <br><br><pre> <code class="actionscript hljs">desired_velocity = normalize(position - target) * max_velocity steering = desired_velocity - velocity</code> </pre> <br>  In this case, <code>desired_velocity</code> represents the shortest escape route that a character can use to get away from the goal.  The controlling force causes the character to leave the current route, pushing it in the direction of the vector of the desired speed. <br><br>  When comparing the vector of the required speed in the behavior of flee with the same vector in the behavior of seek, we can derive the following relationship: <br><br><pre> <code class="actionscript hljs">flee_desired_velocity = -seek_desired_velocity</code> </pre> <br>  In other words, one vector is negative with respect to the other. <br><br><hr><br><h2>  Application of avoidance forces </h2><br>  After calculating the control force, it must be added to the character's velocity vector.  Since this force pushes the character away from the target, the character will no longer move to the target in each frame and will move away from it, creating an <strong>escape trajectory</strong> (the orange curve in the figure below): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a2/468/c64/7a2468c6463e67a8040dfbf621a17b7d.png"></div><br>  The addition of these forces and the calculation of the final speeds / positions are performed in the same way as before. <br><br>  The application of all forces forces each character to smoothly leave the current route and avoid the goal. <br><br>  While the goal affects each character, not taking into account the distance between them;  You can limit its "area of ‚Äã‚Äãinfluence", so that the character runs away only if it is too close to the goal. <br><br><hr><br><h2>  Arrival </h2><br>  As we have seen, the behavior of seek makes the character move towards the goal.  When he reaches his goal, the control force continues to act on him in accordance with the same rules, causing the character to ‚Äúbounce‚Äù back and forth around the target. <br><br>  The <em>arrival</em> behavior does not allow the character to move through the target.  When approaching the end point, it causes the character to slow down and stop when it reaches the goal. <br><br>  This behavior consists of two stages.  The first stage is when the character is far from the goal;  it works just like the behavior of seek (the character at full speed moves to the goal). <br><br>  The second stage begins when the character is close to the target, is inside its ‚Äúslowdown area‚Äù (a circle centered at the target location): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08f/d48/702/08fd4870236801b12ad76c5ceca2957f.png"></div><br>  When a character enters a circle, he slows down until he stops at the target. <br><br><hr><br><h2>  Slowdown </h2><br>  When a character enters a slowdown area, his speed drops linearly to zero.  This can be achieved by applying a new control force ( <em>arrival force</em> ) to the character's velocity vector.  The result of this addition will sooner or later be equal to zero, that is, in every frame nothing will be added to the character‚Äôs position (that is, there will be no movement): <br><br><pre> <code class="actionscript hljs"><span class="hljs-comment"><span class="hljs-comment">//  (velocity + steering)  ,    velocity = truncate(velocity + steering, max_speed) position = position + velocity function truncate(vector:Vector3D, max:Number) :void { var i :Number; i = max / vector.length; i = i &lt; 1.0 ? i : 1.0; vector.scaleBy(i); }</span></span></code> </pre> <br>  To slow down the character before stopping, the speed should not instantly drop to zero.  The process of gradual deceleration is calculated based on the radius of the deceleration area and the distance between the character and the target: <br><br><pre> <code class="actionscript hljs"><span class="hljs-comment"><span class="hljs-comment">//    desired_velocity = target - position distance = length(desired_velocity) //     ,    //    if (distance &lt; slowingRadius) { //    desired_velocity = normalize(desired_velocity) * max_velocity * (distance / slowingRadius) } else { //    desired_velocity = normalize(desired_velocity) * max_velocity } //       steering = desired_velocity - velocity</span></span></code> </pre> <br>  If the distance is greater than <code>slowingRadius</code> , then the character is far from the target and his speed should remain equal to <code>max_velocity</code> . <br><br>  If the distance is less than <code>slowingRadius</code> , then the character entered the area of ‚Äã‚Äãslowing down and his speed should decrease. <br><br>  The value of <code>distance / slowingRadius</code> varies from <code>1</code> (when <code>distance</code> is <code>slowingRadius</code> ) to <code>0</code> (when <code>distance</code> almost zero).  A linear change causes the speed to decrease smoothly: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/03b/b2c/9a0/03bb2c9a0709fba4c43bbc05b720f7ee.png"></div><br>  As stated above, character movement is as follows: <br><br><pre> <code class="actionscript hljs">steering = desired_velocity - velocity velocity = truncate (velocity + steering , max_speed) position = position + velocity</code> </pre> <br>  If the required speed is reduced to zero, then the control force becomes equal to <code>-velocity</code> .  Therefore, when this control force is added to the speed, we get a zero, which causes the character to stop. <br><br>  Essentially, the arrival behavior computes a force that must be equal to <code>-velocity</code> , not allowing the character to move while this force is applied.  The original velocity vector of the character does not change and continues to work, but is reset by the addition of the control force. <br><br>  If the arrival control power is removed, the character starts moving again using the original velocity vector. <br><br><hr><br><h2>  Conclusion </h2><br>  The behavior of the flee makes the character move away from the target, and the behavior of the arrival causes him to slow down and stop at the target position.  Both behaviors can be used to create smooth runaway or follow patterns.  In addition, they can be combined to create even more complex movements. <br><br><h2>  Part 3. Behavior Wander </h2><br><h2>  Wandering </h2><br>  In games, it is often necessary that characters randomly wander around their surroundings.  Usually such characters are just waiting for some event (for example, a fight with a player) or are looking for something.  When a player is able to see this behavior, the function of the character wandering should be quite realistic and beautiful looking. <br><br>  If the player sees clearly defined routes or unrealistic movements, this will lead to irritation.  In the worst case, the player will understand how to predict the movement of the character, and then the gameplay will become boring for him. <br><br>  The <em>wander</em> control behavior <em>is</em> designed to create a realistic ‚Äúnatural‚Äù movement that will convince the player that the character is actually alive and walking independently. <br><br><hr><br><h2>  Search and accident </h2><br>  There are several ways to implement a wandering pattern using steering behaviors.  The simplest is the previously described seek behavior.  When a character performs a search, he moves to the goal. <br><br>  If the position of this goal changes every few seconds, the character will never be able to achieve it (and if they can, the goal will move again).  If we place the goal in the game area at random, the character will move around the environment, pursuing the goal. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/DxPaDljx2as" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Flash <a href="">online</a> demo is <a href="">here</a> . <br><br>  You can implement this with the following code: <br><br><pre> <code class="actionscript hljs"><span class="hljs-comment"><span class="hljs-comment">//    private function wander() :Vector3D { var now :Number = (new Date()).getTime(); if (now &gt;= nextDecision) { //     "" } //   ,   //   ( seek) return seek(target); } //        //   ,   : public function update() :void { steering = wander() steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering , max_speed) position = position + velocity }</span></span></code> </pre> <br>  This is a simple and good approach, but its end result does not look quite believable.  Sometimes a character completely changes his route, because the target is placed behind his back.  Then the character's behavior is more perceived as <em>"Damn, I forgot the keys!"</em> , And not <em>"So, now I will go in this direction</em> . <em>"</em> <br><br><hr><br><h2>  Wandering </h2><br>  Another implementation of the wander behavior was proposed by <a href="http://www.red3d.com/cwr/">Craig Reynolds</a> when he invented these behaviors.  The main idea is to create small random shifts and attach them in each game frame to the vector of the current direction of the character (in our case, to speed).  Since the velocity vector determines the direction of movement of the character and the speed of his movement, any impact on this vector will lead to a change in the current route. <br><br>  The use of small offsets in each frame allows you to avoid abrupt changes in the character's route.  For example, if a character moves up and turns to the right, then in the next frame of the game he will still move up and turn to the right, but slightly from a different angle. <br><br>  This approach can also be implemented in different ways.  One of them is to place a circle in front of the character and use it to calculate all the influencing forces: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d5a/803/2cd/d5a8032cd059243abb37698ea6964647.png"></div><br>  The starting point of <strong>the displacement force</strong> is in the center of the circle and is limited by its radius.  The greater the radius and distance from the character to the circle, the stronger the impulse received by the player in each frame of the game. <br><br>  This bias force will be used to influence the character‚Äôs route.  It is used to calculate the <strong>power of the wander</strong> . <br><br><hr><br><h2>  Calculation of the position of the circle </h2><br>  The first component needed to calculate the wandering power is the position of the center of the circle.  Since the circle must be placed in front of the character, the velocity vector can be used as a guide: <br><br><pre> <code class="actionscript hljs"><span class="hljs-comment"><span class="hljs-comment">//  CIRCLE_DISTANCE - //  ,  -    . //    : var circleCenter :Vector3D; circleCenter = velocity.clone(); circleCenter.normalize(); circleCenter.scaleBy(CIRCLE_DISTANCE);</span></span></code> </pre> <br>  The <code>circleCenter</code> vector is a clone (copy) of the velocity vector, that is, it points in the same direction.  It is normalized and multiplied by the scalar value (in our case, <code>CIRCLE_DISTANCE</code> ), which will give us the following vector: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/986/119/773/98611977321a505344a9c1ac8cdbea59.png"></div><br><hr><br><h2>  Displacement force </h2><br>  The next component is the bias force responsible for turning left and right.  Since this force is used to create deviations, it can be sent anywhere.  Let's use a vector aligned with the Y axis: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> displacement :Vector3D; displacement = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); displacement.scaleBy(CIRCLE_RADIUS); <span class="hljs-comment"><span class="hljs-comment">// //     //     setAngle(displacement, wanderAngle); // //   wanderAngle,  //       //    . wanderAngle += (Math.random() * ANGLE_CHANGE) - (ANGLE_CHANGE * .5);</span></span></code> </pre> <br>  The offset force is created and scaled by the radius of the circle.  As stated above, the larger the radius, the stronger the power of the walk.  <code>wanderAngle</code> is a scalar value that determines the amount of ‚Äúslope‚Äù of the bias force;  after using it, a random value is added to it, so that in the next frame of the game it will be different.  This creates the necessary randomness in motion. <br><br>  To understand this, let's imagine that the offset force calculated above is located in the center of the circle.  Since it is scaled to the radius of a circle, it will look something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c9/6c4/aee/6c96c4aee45a5d78d9a98661d277c4a2.png"></div><br><blockquote>  <strong>Hint:</strong> do not forget that mathematical vectors do not have a position in space, they only have a direction and a magnitude (length).  Therefore, they can be located anywhere. </blockquote><br><hr><br><h2>  Power of wandering </h2><br>  After calculating the center of the circle and the displacement vector, they must be connected to get the <strong>strength of the walk</strong> .  This force is calculated by adding these two vectors: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wanderForce :Vector3D; wanderForce = circleCenter.add(displacement);</code> </pre> <br>  Visually, we can imagine these forces as follows: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f83/fc0/bff/f83fc0bff3d212051c297d89b3d1096f.png"></div><br>  The power of wandering can be represented as a vector, emanating from the character to a point on the circle circumference.  Depending on the location of this point, the wandering power will push the character left or right, strongly or weakly: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8f9/159/179/8f9159179ae9734a5b867b224dda623d.png"></div><br>  The more the power of the walk is aligned with the velocity vector, the less the character will change the current route.  The wandering power will act exactly like the seek and flee powers: it will push the character in the right direction. <br><br>  Just as the direction of force in the seek and flee behaviors is calculated based on the target, the wandering direction is calculated based on a random point on the circle of the circle.  The final code for the wandering power is: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wander</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    var circleCenter :Vector3D; circleCenter = velocity.clone(); circleCenter.normalize(); circleCenter.scaleBy(CIRCLE_DISTANCE); // //    var displacement :Vector3D; displacement = new Vector3D(0, -1); displacement.scaleBy(CIRCLE_RADIUS); // //     //     setAngle(displacement, wanderAngle); // //   wanderAngle,  //       //    . wanderAngle += Math.random() * ANGLE_CHANGE - ANGLE_CHANGE * .5; // //      var wanderForce :Vector3D; wanderForce = circleCenter.add(displacement); return wanderForce; } public function setAngle(vector :Vector3D, value:Number):void { var len :Number = vector.length; vector.x = Math.cos(value) * len; vector.y = Math.sin(value) * len; }</span></span></code> </pre> <br><hr><br><h2>  Bonding </h2><br>  After calculating the power of wandering, it must be added to the character‚Äôs speed so that she can influence his movement.  The addition of this force is exactly the same as before: <br><br><pre> <code class="actionscript hljs">steering = wander() steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering , max_speed) position = position + velocity</code> </pre> <br>  The power of wandering will affect the character‚Äôs route in the same way as the behaviors described above.  The difference is that in every frame of the game, it pushes the character in a random direction. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/kr8JHaZGp28" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Flash <a href="">online</a> demo is <a href="">here</a> . <br><br><hr><br><h2>  Conclusion </h2><br>  Behavior Wander - a great way to implement random movement.  It is driven by an imaginary circle located in front of the character, which can be changed to create the necessary pattern of movement. <br><br><h2>  Part 4. Pursuit and Evade </h2><br><h2>  What is pursuit? </h2><br>  Pursuit (pursuit) - the process of following the goal with the desire to <em>catch it</em> .  It is important to note that all the difference here is the word "catch."  If the object simply follows the target, then it is enough for it to repeat the movement of the target, therefore, it will follow its tracks. <br><br>  When pursuing someone, the pursuer should follow the goal, but also predict where the goal will be in the near future.  If we can predict (or estimate) where the target will be in the next few seconds, we will be able to change the current trajectory to avoid unnecessary routes: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8c/568/9f9/d8c5689f994bda486ab7663427bed7ed.png"></div><br><hr><br><h2>  Future forecasting </h2><br>  As stated in the first part of the tutorial, the motion is calculated using <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25AD%25D0%25B9%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0">the Euler method</a> : <br><br><pre> <code class="actionscript hljs">position = position + velocity</code> </pre> <br>  From this it follows directly that if the character‚Äôs current position and speed are known, then we can predict where he will be through <code>T</code> game updates.  Suppose a character moves in a straight line and the position we want to predict is located after three updates ( <code>T=3</code> ).  Then the character‚Äôs future position will be: <br><br><pre> <code class="actionscript hljs">position = position + velocity * T</code> </pre> <br>  For correct prediction, you must select the correct value of <code>T</code>  If the value is too large, the pursuer will chase the ghost.  If <code>T</code> too close to zero, then the pursuer does not really pursue, but simply follows the target (no prediction). <br><br>  If the forecast is calculated for each frame of the game, then it will work, even if the goal is constantly changing its direction.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> With each update, a new ‚Äúfuture position‚Äù is generated, based on the character‚Äôs current speed vector (which also controls the direction of movement). </font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pursuing </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The behavior of Pursuit works about the same as Seek; </font><font style="vertical-align: inherit;">the only difference is that the pursuer is not striving for the goal itself, but for its position in the near future. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose all the characters in the game are represented by a class </font></font><code>Boid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then in the following pseudocode, the basic idea of ‚Äã‚Äãpursuit behavior is implemented:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pursuit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t :Boid)</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ T :int = <span class="hljs-number"><span class="hljs-number">3</span></span>; futurePosition :Vector3D = t.position + t.velocity * T; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seek(futurePosition); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After calculating the power of pursuit, it must be added to the velocity vector, as in all previous control forces: </font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :void </span></span>{ steering = pursuit(target) steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering , max_speed) position = position + velocity }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The figure below shows this process: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f3/5f7/74f/2f35f774f25e0415fbe497a2eda4dfd0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The pursuer (the character below) tends to the future position of the target, following the trajectory described by the orange curve. </font><font style="vertical-align: inherit;">The finished result is shown below. </font><font style="vertical-align: inherit;">Here pursuit behavior is used </font></font><code>T=30</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/S766A81HOBU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interactive Flash demo is </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Improve prosecution accuracy </font></font></h2><br>   <code>T</code> ,   :      .   ,    ,       ,    <code>T</code>  ¬´¬ª. <br><br>        ,    ,              . <br><br>   ,            .   :    <code>T</code>   : <br><br><pre> <code class="actionscript hljs">T = distanceBetweenTargetAndPursuer / MAX_VELOCITY</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The new value is </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculated based on the distance between the two characters and the maximum speed that the target can reach. </font><font style="vertical-align: inherit;">Simply put, a new one </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">means </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúhow many updates does a target need to move from the current position to the pursuer position‚Äù</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The greater the distance, the greater will be </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, the pursuer will tend to a point far ahead of the goal. </font><font style="vertical-align: inherit;">The shorter the distance, the smaller it will be </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, it will tend to a point that is very close to the target. </font><font style="vertical-align: inherit;">The new code for this implementation will look like this:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pursuit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t :Boid)</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> distance :Vector3D = t.position - position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> T :int = distance.length / MAX_VELOCITY; futurePosition :Vector3D = t.position + t.velocity * T; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> seek(futurePosition); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Behavior Pursuit uses dynamic </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/DmzCz1Ki0ks" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flash </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">online</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> demo is </font><a href=""><font style="vertical-align: inherit;">here</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Evading </font></font></h2><br>  Evade   Pursuit.         Evade     : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fda/475/95e/fda47595e44b10b0e53e08ffa75db428.png"></div><br>    ,    : <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t :Boid)</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> distance :Vector3D = t.position - position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updatesAhead :int = distance.length / MAX_VELOCITY; futurePosition :Vector3D = t.position + t.velocity * updatesAhead; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flee(futurePosition); }</code> </pre> <br>    Flash  <a href=""></a> . <br><br><hr><br><h2>  Conclusion </h2><br>       Pursuit  Evade,        , ,  ,    . <br><br><h2>  5.   </h2><br> Steering behaviors       ,    ,    ,    .              . <br><br><hr><br><h2>  Steering Forces </h2><br>   ,  steering behavior    ( ¬´ ¬ª),     .       ,      (seek, flee, wander   ).      : <br><br><pre> <code class="actionscript hljs">steering = seek(); <span class="hljs-comment"><span class="hljs-comment">//      steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering , max_speed) position = position + velocity</span></span></code> </pre> <br>      ,        ( ,    ).   ¬´¬ª   ,       .   : <br><br><pre> <code class="actionscript hljs">steering = nothing(); <span class="hljs-comment"><span class="hljs-comment">//  ,  "  " steering = steering + seek(); steering = steering + flee(); (...) steering = truncate (steering, max_force) steering = steering / mass velocity = truncate (velocity + steering , max_speed) position = position + velocity</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we add the governing forces, we get a vector representing </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">all</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> these forces. </font><font style="vertical-align: inherit;">In the code snippet shown above, the resulting control force will force the character to search for something, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while at the same time</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avoiding something </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following are examples of combined controlling forces creating a single controlling force:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/c2b/a7c/f07c2ba7c3d0253143b74bde088c3abe.png"></div><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Easy creation of complex patterns </font></font></h2><br>           . ,           ,    - ,    ? <br><br>    , , ,     .   ,        ,     . <br><br>  steering behaviors    <em></em> . ,        ,        . <br><br><hr><br><h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To use several steering behaviors simultaneously, it will be useful to create </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a motion manager</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The idea is to write a ‚Äúblack box‚Äù that can be connected to any existing entity, which will allow it to carry out these behaviors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The manager has a link to the entity to which it is connected (to the "host"). </font><font style="vertical-align: inherit;">The manager passes a set of methods to the host, such as </font></font><code>seek()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>flee()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">With each call of such methods, the manager updates its internal properties to create a vector of controlling force. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After processing all calls, the manager adds the resulting control force to the host speed vector. </font><font style="vertical-align: inherit;">This changes the magnitude and direction of the host velocity vector in accordance with active behaviors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The figure below shows the architecture:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/884/29f/fec/88429ffec9850bf16485c62ed11aa23a.png"></div><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summarize the elements </font></font></h2><br>     ,       .           . <br><br> ,  Seek    ,     ,    ;  Pursuit      ,      .        <code>Point</code>  <code>Vector2D</code> .         . <br><br>     Pursuit   ,  .      ,    , ,     ,     ¬´¬ª,  " <em>   ?</em> ".  <a href="http://gamedev.tutsplus.com/tutorials/implementation/quick-tip-the-oop-principle-of-abstraction/">  - </a>      <em></em> . <br><br> ,  <code>IBoid</code>  ,     ,        steering behaviors,    <code>IBoid</code> .      : <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBoid</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVelocity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMaxVelocity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Number</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Vector3D</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> :Number</span></span>; }</code> </pre> <br><hr><br><h2>    </h2><br> ,           ,     .      (      ),      ,     : <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SteeringManager</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> steering :Vector3D; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> host :IBoid; <span class="hljs-comment"><span class="hljs-comment">//  public function SteeringManager(host :IBoid) { this.host = host; this.steering = new Vector3D(0, 0); } //  API (     ) public function seek(target :Vector3D, slowingRadius :Number = 20) :void {} public function flee(target :Vector3D) :void {} public function wander() :void {} public function evade(target :IBoid) :void {} public function pursuit(target :IBoid) :void {} //  . //       public function update() :void {} //    . public function reset() :void {} //  API private function doSeek(target :Vector3D, slowingRadius :Number = 0) :Vector3D {} private function doFlee(target :Vector3D) :Vector3D {} private function doWander() :Vector3D {} private function doEvade(target :IBoid) :Vector3D {} private function doPursuit(target :IBoid) :Vector3D {} }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When creating an instance of a manager, it should receive a link to the host to which it is connected. </font><font style="vertical-align: inherit;">It will allow the manager to change the speed vector of the host in accordance with active behaviors. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each behavior is represented by two methods - public and private. </font><font style="vertical-align: inherit;">Take for example the behavior of Seek:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target :Vector3D, slowingRadius :Number = 20)</span></span></span><span class="hljs-function"> :void </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSeek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target :Vector3D, slowingRadius :Number = 0)</span></span></span><span class="hljs-function"> :Vector3D </span></span>{}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The public </font></font><code>seek()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be called to instruct the manager to apply this particular behavior. </font><font style="vertical-align: inherit;">This method has no return value, and its parameters are associated with the behavior itself, for example, a point in space. </font><font style="vertical-align: inherit;">Inside the private method will be called </font></font><code>doSeek()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and its return value, i.e. </font><font style="vertical-align: inherit;">the calculated control power of this particular behavior will be added to the </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manager </font><font style="vertical-align: inherit;">property </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following code shows the implementation of seek:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-comment"><span class="hljs-comment">//  . //    slowingRadius (   Arrival). public function seek(target :Vector3D, slowingRadius :Number = 20) :void { steering.incrementBy(doSeek(target, slowingRadius)); } //   Seek (   Arrival) private function doSeek(target :Vector3D, slowingRadius :Number = 0) :Vector3D { var force :Vector3D; var distance :Number; desired = target.subtract(host.getPosition()); distance = desired.length; desired.normalize(); if (distance &lt;= slowingRadius) { desired.scaleBy(host.getMaxVelocity() * distance/slowingRadius); } else { desired.scaleBy(host.getMaxVelocity()); } force = desired.subtract(host.getVelocity()); return force; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All other behaviors are implemented in a very similar way. </font><font style="vertical-align: inherit;">For example, the method </font></font><code>pursuit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">would look like this:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pursuit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target :IBoid)</span></span></span><span class="hljs-function"> :void </span></span>{ steering.incrementBy(doPursuit(target)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doPursuit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target :IBoid)</span></span></span><span class="hljs-function"> :Vector3D </span></span>{ distance = target.getPosition().subtract(host.getPosition()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> updatesNeeded :Number = distance.length / host.getMaxVelocity(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tv :Vector3D = target.getVelocity().clone(); tv.scaleBy(updatesNeeded); targetFuturePosition = target.getPosition().clone().add(tv); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> doSeek(targetFuturePosition); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can use the code from the previous parts of the tutorial. </font><font style="vertical-align: inherit;">The only thing that needs to be done is to adapt it in the form </font></font><code>behavior()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>doBehavior()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it can be added to the motion manager.</font></font><br><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Application and updating of the controlling forces </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With each invocation of a behavior method, the resulting force calculated by it is added to the property of the </font></font><code>steering</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">manager. </font><font style="vertical-align: inherit;">Consequently, all control forces accumulate in this property. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After calling all the behaviors, the manager must apply the current controlling force to the speed of the host so that it moves in accordance with the active behaviors. </font><font style="vertical-align: inherit;">This is done in the </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">motion manager </font><font style="vertical-align: inherit;">method </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> velocity :Vector3D = host.getVelocity(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> position :Vector3D = host.getPosition(); truncate(steering, MAX_FORCE); steering.scaleBy(<span class="hljs-number"><span class="hljs-number">1</span></span> / host.getMass()); velocity.incrementBy(steering); truncate(velocity, host.getMaxVelocity()); position.incrementBy(velocity); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method shown above should be called by the host (or any other game entity) after invoking all the behaviors. </font><font style="vertical-align: inherit;">Otherwise, the host will never be able to change its velocity vector so that it matches active behaviors.</font></font><br><br><hr><br><h2>  Application </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose we have a class </font></font><code>Prey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that should move using steering behavior, but so far it has neither a control code nor a motion manager. </font><font style="vertical-align: inherit;">Its structure will look like this:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Prey</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> position :Vector3D; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> velocity :Vector3D; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mass :Number; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Prey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(posX :Number, posY :Number, totalMass :Number)</span></span></span><span class="hljs-function"> </span></span>{ position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(posX, posY); velocity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>); mass = totalMass; x = position.x; y = position.y; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ velocity.normalize(); velocity.scaleBy(MAX_VELOCITY); velocity.scaleBy(<span class="hljs-number"><span class="hljs-number">1</span></span> / mass); truncate(velocity, MAX_VELOCITY); position = position.add(velocity); x = position.x; y = position.y; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this structure, class instances can move using </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25AD%25D0%25B9%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Euler method</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In order for us to use the manager, the class needs a property that refers to the motion manager, and it also has to use the interface </font></font><code>IBoid</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Prey</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBoid</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> position :Vector3D; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> velocity :Vector3D; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mass :Number; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> steering :SteeringManager; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Prey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(posX :Number, posY :Number, totalMass :Number)</span></span></span><span class="hljs-function"> </span></span>{ position = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(posX, posY); velocity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3D(<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>); mass = totalMass; steering = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SteeringManager(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); x = position.x; y = position.y; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ velocity.normalize(); velocity.scaleBy(MAX_VELOCITY); velocity.scaleBy(<span class="hljs-number"><span class="hljs-number">1</span></span> / mass); truncate(velocity, MAX_VELOCITY); position = position.add(velocity); x = position.x; y = position.y; } <span class="hljs-comment"><span class="hljs-comment">//   ,   IBoid. public function getVelocity() :Vector3D { return velocity; } public function getMaxVelocity() :Number { return 3; } public function getPosition() :Vector3D { return position; } public function getMass() :Number { return mass; } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">needs to be changed accordingly so that the manager can also be updated:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,  prey   ... steering.wander(); //  ,       prey. //      ,  //  "". steering.update(); //      ,   //        "". x = position.x; y = position.y; }</span></span></code> </pre> <br>     ,        <code>update()</code> ,          . <br><br>        <code>update()</code> Prey,        (seek)       (evade)   (   ): <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> destination :Vector3D = getDestination(); <span class="hljs-comment"><span class="hljs-comment">// ,    var hunter :IBoid = getHunter(); //  ,     //       (!) steering.seek(destination); steering.evade(hunter); //  ,      prey. //     ,  //  "". steering.update(); //      ,    //      "". x = position.x; y = position.y; }</span></span></code> </pre> <br><hr><br><h2>  Example </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The example below shows a complex motion pattern that combines several behaviors. In the scene there are two types of characters: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hunter</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (hunter) and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prey</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (victim). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The hunter will </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pursue the</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> victim if he gets close enough. He pursues her while he has energy (stamina). When the energy ends, the pursuit stops and the hunter begins to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wander</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> until he regains the energy level. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Hunter class </font><font style="vertical-align: inherit;">method </font><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (resting &amp;&amp; stamina++ &gt;= MAX_STAMINA) { resting = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prey != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !resting) { steering.pursuit(prey); stamina -= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stamina &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { prey = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; resting = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { steering.wander(); prey = getClosestPrey(position); } steering.update(); x = position.x; y = position.y; }</code> </pre> <br>    <em></em> .     ,    <em></em> .        ,   <em></em>  . <br><br>     <code>update()</code> Prey: <br><br><pre> <code class="actionscript hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:void </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> distance :Number = Vector3D.distance(position, Game.mouse); hunter = getHunterWithinRange(position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hunter != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { steering.evade(hunter); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance &lt;= <span class="hljs-number"><span class="hljs-number">300</span></span> &amp;&amp; hunter == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { steering.seek(Game.mouse, <span class="hljs-number"><span class="hljs-number">30</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hunter == <span class="hljs-literal"><span class="hljs-literal">null</span></span>){ steering.wander(); } steering.update(); x = position.x; y = position.y; }</code> </pre> <br><hr><br><h2>  Conclusion </h2><br>         steering behaviors.         ,           . <br><br> ,                . <br><br>    <a href="https://habr.com/post/358460/"></a> . </div><p>Source: <a href="https://habr.com/ru/post/358366/">https://habr.com/ru/post/358366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358356/index.html">How and why we made our ATMs</a></li>
<li><a href="../358358/index.html">7 tools that help us beat procrastination</a></li>
<li><a href="../358360/index.html">The Frontend Conf program for those who do not have a flywheel of time</a></li>
<li><a href="../358362/index.html">Finnish province: immigration and life</a></li>
<li><a href="../358364/index.html">The main aspects of the legality of the processing of personal data in an employment relationship</a></li>
<li><a href="../358368/index.html">Industrial IoT: Demand Study</a></li>
<li><a href="../358370/index.html">[Friday] Chewie, we are wrapped</a></li>
<li><a href="../358372/index.html">From Augmented Reality to Kotlin: How Mobius 2018 Piter Passed</a></li>
<li><a href="../358374/index.html">As I built the year extension for the browser that reads articles by voice (with synchronization in the podcast)</a></li>
<li><a href="../358376/index.html">How we organized data storage cheaper than Amazon Simple Storage Service by 35%</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>