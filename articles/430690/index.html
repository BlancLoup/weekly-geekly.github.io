<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Deterministic exceptions and error handling in the ‚ÄúC ++ future‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It is strange that on Habr√© until now it was not mentioned about the clause to the C ++ standard called "Zero-overhead deterministic exceptions". I co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Deterministic exceptions and error handling in the ‚ÄúC ++ future‚Äù</h1><div class="post__text post__text-html js-mediator-article"><iframe width="560" height="315" src="https://www.youtube.com/embed/cbUTAoHy6Ls" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  It is strange that on Habr√© until now it was not mentioned about the clause to the C ++ standard called "Zero-overhead deterministic exceptions".  I correct this annoying omission. </p><br><p>  If you are worried about the overhead of exceptions, or you had to compile code without exception support, or just wondering what will happen with error handling in C ++ 2b (referring to a <a href="https://habr.com/post/426965/">recent post</a> ), please under the cat.  You are waiting for squeeze out of everything that now can be found on the topic, and a couple of polls. </p><a name="habracut"></a><br><p>  The conversation will continue to be conducted not only about static exceptions, but also about related proposals to the standard, and about any other ways of handling errors.  If you came here to look at the syntax, then here it is: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (y == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_error::divide_by_zero; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> as_double(x) / y; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; safe_divide(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (arithmetic_error e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  If the specific type of error is unimportant / unknown, then you can simply use <code>throws</code> and <code>catch (std::error e)</code> . </p><br><h2 id="polezno-znat">  Good to know </h2><br><h3 id="stdoptional-i-stdexpected">  <code>std::optional</code> and <code>std::expected</code> </h3><br><p>  Suppose we decided that an error that could potentially arise in a function is not ‚Äúfatal‚Äù enough to throw an exception from it.  Traditionally, error information is returned using the out parameter.  For example, <a href="https://en.cppreference.com/w/cpp/experimental/fs">Filesystem TS</a> offers a number of similar functions: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p, error_code&amp; ec);</code> </pre> <br><p>  (Do not throw an exception due to the fact that the file is not found?) However, the handling of error codes is cumbersome and prone to bugs.  Error code is easy to forget to check.  Modern code styles <a href="">prohibit the</a> use of output parameters; instead, it is recommended to return a structure containing the entire result. </p><br><p>  Boost has been offering an elegant solution for some time to handle such ‚Äúnon-fatal‚Äù errors, which in certain scenarios can occur in the hundreds in the correct program: </p><br><pre> <code class="cpp hljs">expected&lt;<span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span>, error_code&gt; file_size(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> path&amp; p);</code> </pre> <br><p>  The <code>expected</code> type is similar to <code>variant</code> , but provides a convenient interface for working with "result" and "error."  By default, the ‚Äúresult‚Äù is stored in <code>expected</code> .  The implementation of <code>file_size</code> might look something like this: </p><br><pre> <code class="cpp hljs">file_info* info = read_file_info(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (info != null) { <span class="hljs-keyword"><span class="hljs-keyword">uintmax_t</span></span> size = info-&gt;size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> size; <span class="hljs-comment"><span class="hljs-comment">// &lt;== } else { error_code error = get_error(); return std::unexpected(error); // &lt;== }</span></span></code> </pre> <br><p>  If we are not interested in the cause of the error, or the error can only consist in the ‚Äúabsence‚Äù of the result, then you can use <code>optional</code> : </p><br><pre> <code class="cpp hljs">optional&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; parse_int(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; s); optional&lt;U&gt; get_or_null(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;T, U&gt; m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T&amp; key);</code> </pre> <br><p>  In C ++ 17 from Boost, <a href="https://en.cppreference.com/w/cpp/utility/optional">optional</a> got into std (without support <code>optional&lt;T&amp;&gt;</code> );  in C ++ 20, they will probably add the <a href="https://github.com/TartanLlama/expected">expected</a> (this is only Proposal, thanks to <a href="https://habr.com/users/ramzesxi/" class="user_link">RamzesXI</a> for the amendment). </p><br><h3 id="contracts">  Contracts </h3><br><p>  <a href="https://en.cppreference.com/w/cpp/language/attributes/contract">Contracts</a> (not to be confused with concepts) - a new way to impose restrictions on the parameters of a function added in C ++ 20.  Added 3 annotations: </p><br><ul><li>  <strong>expects</strong> checking function parameters </li><li>  <strong>ensures ensures that</strong> the return value of the function is checked (takes it as an argument) </li><li>  <strong>assert</strong> - a civilized replacement for the macro assert </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unsafe_at</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i)</span></span></span><span class="hljs-function"> [[expects: i &lt; v.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">]]</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sqrt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> [[expects: x &gt;</span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>]] [[ensures ret: ret &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-function"><span class="hljs-function">value </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_single</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(key e)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value&gt; result = fetch(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;key&gt;{e}); [[assert result.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v[<span class="hljs-number"><span class="hljs-number">0</span></span>]; }</code> </pre> <br><p>  You can configure breach of contract: </p><br><ul><li>  Called Undefined Behaviour, or </li><li>  The user handler was checked and called, and then <code>std::terminate</code> </li></ul><br><p>  It is impossible to continue the work of the program after a breach of contract, because compilers use guarantees from contracts to optimize the function code.  If there is the slightest doubt that the contract will be fulfilled, it is worth adding an additional check. </p><br><h3 id="stderror_code">  std :: error_code </h3><br><p>  The <code>&lt;system_error&gt;</code> library added in C ++ 11 allows you to unify the handling of error codes in your program.  <a href="https://en.cppreference.com/w/cpp/error/error_code">std :: error_code</a> consists of an error code of type <code>int</code> and a pointer to an object of some class <a href="https://en.cppreference.com/w/cpp/error/error_category">derived from std :: error_category</a> .  This object, in fact, plays the role of a table of virtual functions and determines the behavior of this <code>std::error_code</code> . </p><br><p>  To create your own <code>std::error_code</code> , you must define your own <code>std::error_category</code> and implement virtual methods, the most important of which is: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">message</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><p>  You also need to create a global variable for your <code>std::error_category</code> .  Error handling with error_code + expected looks like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> result = expected&lt;T, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code&gt;; my::<span class="hljs-function"><span class="hljs-function">file_handle </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_internal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; error)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">open_file</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; name)</span></span></span><span class="hljs-function"> -&gt; result&lt;my::file&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> raw_error = <span class="hljs-number"><span class="hljs-number">0</span></span>; my::file_handle maybe_result = open_internal(name, &amp;raw_error); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error_code error{raw_error, my::filesystem_error}; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unexpected{error}; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> my::file{maybe_result}; } }</code> </pre> <br><p>  It is important that in <code>std::error_code</code> value of 0 means no error.  If this is not the case for your error codes, then before converting the system error code to <code>std::error_code</code> , you must replace code 0 with SUCCESS code, and vice versa. </p><br><p>  All system error codes are described in <a href="https://en.cppreference.com/w/cpp/error/errc">errc</a> and <a href="https://en.cppreference.com/w/cpp/error/system_category">system_category</a> .  If at a certain stage the manual forwarding of error codes becomes too dreary, then you can always wrap the error code in the exception <code>std::system_error</code> and throw it away. </p><br><h3 id="destructive-move--trivially-relocatable">  Destructive move / Trivially relocatable </h3><br><p>  Suppose you need to create another class of objects that own any resources.  Most likely, you will want to make it uncopyable, but moveable, because it is inconvenient to work with unmoveable objects (they could not be returned from a function before C ++ 17). </p><br><p>  But here's the problem: in any case, the moved object must be deleted.  Therefore, a special "moved-from" state, that is, an "empty" object that does not remove anything, is necessary.  It turns out that every C ++ class must have an empty state, that is, it is impossible to create a class with an invariant (guarantee) of correctness, from the constructor to the destructor.  For example, it is impossible to create a correct class <code>open_file</code> file, which is open throughout the lifetime.  It is strange to observe this in one of the few languages ‚Äã‚Äãthat actively use RAII. </p><br><p>  Another problem - dropping old objects when moving adds an overhead: filling <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> can be up to 2 times slower than <code>std::vector&lt;T*&gt;</code> because of the heap of old pointers when moving , with the subsequent removal of baby's dummies. </p><br><p>  C ++ developers have long licked to Rust, where destructors are not called on displaced objects.  This feature is called Destructive move.  Unfortunately, Proposal <a href="https://wg21.link/P1144">Trivially relocatable</a> does not offer to add it to C ++.  But the problem of the overhead projector will solve. </p><br><p>  A class is considered trivially relocatable if two operations: moving and deleting an old object are equivalent to memcpy from the old object to a new one.  The old object is not deleted, the authors call it "drop it on the floor". </p><br><p>  The type is Trivially relocatable from the compiler's point of view if one of the following (recursive) conditions is true: </p><br><ol><li>  It is trivially moveable + trivially destructible (for example, an <code>int</code> or POD structure) </li><li>  This is a class marked with the <code>[[trivially_relocatable]]</code> attribute <code>[[trivially_relocatable]]</code> </li><li>  This is a class whose members are all Trivially relocatable. </li></ol><br><p>  You can use this information using <code>std::uninitialized_relocate</code> , which executes move init + delete in the usual way, or accelerated, if possible.  It is proposed to mark as <code>[[trivially_relocatable]]</code> most types of the standard library, including <code>std::string</code> , <code>std::vector</code> , <code>std::unique_ptr</code> .  The overhead <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> with this Proposal disappears. </p><br><h2 id="chto-ne-tak-s-isklyucheniyami-seychas">  What is wrong with the exceptions now? </h2><br><p>  The C ++ exception mechanism was developed in 1992.  Various implementation options have been proposed.  As a result, the mechanism of exclusion tables was chosen, which guarantee the absence of an overhead projector for the main program execution path.  Because from the very moment of their creation, it was assumed that <em>exceptions should be thrown very rarely</em> . </p><br><p>  Disadvantages of dynamic (that is, ordinary) exceptions: </p><br><ol><li>  In the case of a thrown exception, the overhead head averages on the order of 10,000‚Äì100,000 CPU cycles, and in the worst case, can reach on the order of milliseconds. </li><li>  Increasing the size of a binary file by 15-38% </li><li>  Incompatibility with software interface C </li><li>  Implicit support for forwarding exceptions in all functions except <code>noexcept</code> .  An exception can be thrown almost anywhere in the program, even where the author of the function does not expect it. </li></ol><br><p>  Because of these shortcomings, the scope of exceptions is significantly limited.  When exceptions cannot apply: </p><br><ol><li>  Where determinism is important, that is, where it is unacceptable that the code "sometimes" worked 10, 100, 1000 times slower than usual </li><li>  When they are not supported in ABI, for example, in microcontrollers </li><li>  When much of the code is written in C </li><li>  In companies with a large load of Legacy code ( <a href="https://google.github.io/styleguide/cppguide.html">Google Style Guide</a> , <a href="https://doc.qt.io/qt-5/exceptionsafety.html">Qt</a> ).  If there is at least one non-exception-safe function in the code, then, according to the law of meanness, an exception will be thrown through it sooner or later and create a bug </li><li>  In companies that recruit programmers who have no idea about exception safety </li></ol><br><p>  According to surveys, at work sites, 52% (!) Of developers are prohibited by corporate rules. </p><br><p>  But exceptions are an integral part of C ++!  Including the <code>-fno-exceptions</code> flag, developers lose the ability to use much of the standard library.  This further incites companies to impose their own "standard libraries" and yes, reinvent their own class strings. </p><br><p>  But this is not the end.  Exceptions are the only standard way to cancel the creation of an object in the constructor and give an error.  When they are disabled, an abomination such as two-phase initialization appears.  Operators cannot use error codes either, so they are replaced by functions like <code>assign</code> . </p><br><h2 id="proposal-isklyucheniya-buduschego">  Proposal: future exceptions </h2><br><h3 id="novyy-mehanizm-peredachi-isklyucheniy">  New Exception Transfer Mechanism </h3><br><p>  Coat of arms Sutter (Herb Sutter) in P709 described a new mechanism for the transfer of exceptions.  Ideally, the function returns <code>std::expected</code> , but instead of a separate discriminator of the <code>bool</code> type, which together with alignment will occupy up to 8 bytes on the stack, this bit of information is transferred in some faster way, for example, to Carry Flag. </p><br><p>  Functions that do not touch CF (most of them) will be able to use static exceptions for free - both in the case of a normal return, and in the case of an exception pass!  Functions that will be forced to save and restore it will receive a minimum overhead, and it will still be faster than <code>std::expected</code> and any normal error codes. </p><br><p>  Static exceptions look like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_divide</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::divide_by_zero; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == INT_MIN &amp;&amp; j == <span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> arithmetic_errc::integer_divide_overflows; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i / j; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i + safe_divide(j, k); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> j, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; foo(i, j, k); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (erithmetic_errc e) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; e; } }</code> </pre> <br><p>  In the alternative version, it is proposed to require the <code>try</code> keyword in the same expression as the call to the <code>throws</code> function: <code>try i + safe_divide(j, k)</code> .  This will reduce the number of instances of using <code>throws</code> functions in code, which is not safe for exceptions, to almost zero.  In any case, unlike dynamic exceptions, the IDE will have the ability to somehow highlight expressions that throw exceptions. </p><br><p>  The fact that the thrown exception is not stored separately, but is placed directly in place of the return value, imposes restrictions on the type of exception.  First, it must be Trivially relocatable.  Secondly, its size should not be very large (but it could be something like <code>std::unique_ptr</code> ), otherwise all functions will reserve more space on the stack. </p><br><h3 id="status_code">  status_code </h3><br><p>  The <code>&lt;system_error2&gt;</code> library developed by Niall Douglas will contain <code>status_code&lt;T&gt;</code> - ‚Äúnew, better‚Äù <code>error_code</code> .  The main differences from <code>error_code</code> : </p><br><ol><li>  <code>status_code</code> is a template type that can be used to store almost any conceivable error code (along with a pointer to <code>status_code_category</code> ), without using static exceptions. </li><li>  <code>T</code> must be Trivially relocatable and replicable (the latter, IMHO, should not be mandatory).  When copying and deleting, virtual functions are called from <code>status_code_category</code> </li><li>  <code>status_code</code> can store not only error data, but also additional information about a successfully completed operation. </li><li>  The ‚Äúvirtual‚Äù function <code>code.message()</code> does not return <code>std::string</code> , but <code>string_ref</code> is a rather heavy string type, which is a virtual ‚Äúpossibly owning‚Äù <code>std::string_view</code> .  There you can <code>string_view</code> or <code>string</code> , or <code>std::shared_ptr&lt;string&gt;</code> , or some other crazy way to own a string.  Niall claims that <code>#include &lt;string&gt;</code> would make the <code>&lt;system_error2&gt;</code> header impermissibly ‚Äúheavy‚Äù </li></ol><br><p>  Next, <code>errored_status_code&lt;T&gt;</code> is entered - a wrapper over <code>status_code&lt;T&gt;</code> with the following constructor: </p><br><pre> <code class="cpp hljs">errored_status_code(status_code&lt;T&gt;&amp;&amp; code) [[expects: code.failure() == <span class="hljs-literal"><span class="hljs-literal">true</span></span>]] : code_(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(code)) {}</code> </pre> <br><h3 id="error">  error </h3><br><p>  The default exception type ( <code>throws</code> without a type), as well as the base exception type, to which all others are thrown (like <code>std::exception</code> ) is an <code>error</code> .  It is defined like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> error = errored_status_code&lt;<span class="hljs-keyword"><span class="hljs-keyword">intptr_t</span></span>&gt;;</code> </pre> <br><p>  That is, an <code>error</code> is such an ‚Äúerroneous‚Äù <code>status_code</code> for which the value is placed in 1 pointer.  Since the <code>status_code_category</code> mechanism provides correct deletion, movement and copying, theoretically, any data structure can be saved as an <code>error</code> .  In practice, this will be one of the following options: </p><br><ol><li>  Integers (int) </li><li>  <code>std::exception_handle</code> , that is, a pointer to the thrown dynamic exception </li><li>  <code>status_code_ptr</code> , that is, <code>unique_ptr</code> to an arbitrary <code>status_code&lt;T&gt;</code> . </li></ol><br><p>  The problem is that case 3 does not plan to allow the <code>error</code> to be brought back to <code>status_code&lt;T&gt;</code> .  The only thing you can do is get the <code>message()</code> packed <code>status_code&lt;T&gt;</code> .  To be able to get back the value wrapped in <code>error</code> , you need to throw it away as a dynamic exception (!), Then catch and wrap it in <code>error</code> .  In general, Niall believes that only error codes and string messages should be stored in <code>error</code> , which is enough for any program. </p><br><p>  To distinguish between different types of errors, it is proposed to use a ‚Äúvirtual‚Äù comparison operator: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { open_file(name); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::error e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == filesystem_error::already_exists) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> my_exception(<span class="hljs-string"><span class="hljs-string">"Unknown filesystem error, unable to continue"</span></span>); } }</code> </pre> <br><p>  Using multiple catch blocks or <code>dynamic_cast</code> to select the type of exception will not work! </p><br><h3 id="vzaimodeystvie-s-dinamicheskimi-isklyucheniyami">  Interaction with dynamic exceptions </h3><br><p>  A function can have one of the following specifications: </p><br><ul><li>  <code>noexcept</code> : throws no exceptions </li><li>  <code>throws(E)</code> : throws only static exceptions </li><li>  (nothing): throws only dynamic exceptions </li></ul><br><p>  <code>throws</code> implies <code>noexcept</code> .  If a dynamic exception is thrown from a ‚Äústatic‚Äù function, then it is wrapped in <code>error</code> .  If a static exception is thrown from a ‚Äúdynamic‚Äù function, then it is wrapped in a <code>status_error</code> exception.  Example: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throws</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arithmetic_errc)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> erithmetic_errc::divide_by_zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> throws </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  arithmetic_errc   intptr_t //     error foo(); } void baz() { // error    status_error bar(); } void qux() throws { // error    status_error baz(); }</span></span></code> </pre> <br><h3 id="isklyucheniya-v-c">  Exceptions in C ?! </h3><br><p>  The proposal provides for the addition of exceptions to one of the future C standards, and these exceptions will be ABI-compatible with static C ++ exceptions.  A structure similar to <code>std::expected&lt;T, U&gt;</code> , the user will have to declare independently, although redundancy can be removed using macros.  The syntax consists of (for simplicity, we will assume so) the keywords fails, failure, catch. </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x != <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> / x; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> failure(<span class="hljs-number"><span class="hljs-number">2.0f</span></span>); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">expected_int_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> error; }; <span class="hljs-keyword"><span class="hljs-keyword">_Bool</span></span> failed; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">caller</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expected_int_float result = <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(invert(<span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.failed) { print_error(result.error); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } print_success(result.value); }</code> </pre> <br><p>  In C ++, it will also be possible to call the <code>fails</code> functions from C, declaring them in <code>extern C</code> blocks.  Thus, in C ++ there will be a whole constellation of keywords for dealing with exceptions: </p><br><ul><li>  <code>throw()</code> - removed in C ++ 20 </li><li>  <code>noexcept</code> - the function specifier, the function does not throw dynamic exceptions </li><li>  <code>noexcept(expression)</code> is a function specifier, the function does not throw dynamic exceptions provided </li><li>  <code>noexcept(expression)</code> - does the expression throw dynamic exceptions? </li><li>  <code>throws(E)</code> - function specifier, function throws static exceptions </li><li>  <code>throws</code> = <code>throws(std::error)</code> </li><li>  <code>fails(E)</code> - a function imported from C throws static exceptions. </li></ul><br><p>  So, in C ++, a cart of error-handling tools was delivered (more precisely, delivered).  Then a logical question arises: </p><br><h2 id="kogda-chto-ispolzovat">  When what to use? </h2><br><h3 id="napravlenie-v-celom">  Overall direction </h3><br><p>  Errors are divided into several levels: </p><br><ul><li>  Programmer errors.  Processed through contracts.  They lead to collecting logs and shutting down the program in accordance with the concept of <a href="https://en.wikipedia.org/wiki/Fail-fast">fail-fast</a> .  Examples: null pointer (when this is not allowed);  division by zero;  memory allocation errors not provided by the programmer. </li><li>  Irreparable errors provided by the programmer.  They are thrown a million times less often than a normal return from a function, which makes the use of dynamic exceptions for them justified.  Usually in such cases it is required to restart the whole subsystem of the program or to give an error when performing the operation.  Examples: suddenly lost connection to the database;  memory allocation errors provided by the programmer. </li><li>  Recoverable errors, when <em>something</em> prevented the function from performing its task, but the calling function probably knows what to do with it.  Processed with static exceptions.  Examples: working with the file system;  other input / output errors (IO);  incorrect user data;  <code>vector::at()</code> . </li><li>  The function successfully completed its task, albeit with an unexpected result.  Returns <code>std::optional</code> , <code>std::expected</code> , <code>std::variant</code> .  Examples: <a href="https://ru.cppreference.com/w/cpp/string/basic_string/stol"><code>stoi()</code></a> ;  <code>vector::find()</code> ;  <a href="https://en.cppreference.com/w/cpp/container/map/insert"><code>map::insert</code></a> . </li></ul><br><p>  In the standard library, it will be most reliable to completely abandon the use of dynamic exceptions in order to make the compilation "without exceptions" legal. </p><br><h3 id="errno">  errno </h3><br><p>  Functions that use <code>errno</code> to work quickly and minimally with the C and C ++ error codes should be replaced by <code>fails(int)</code> and <code>throws(std::errc)</code> , respectively.  For some time the old and the new versions of the standard library functions will coexist, then the old ones will be declared obsolete. </p><br><h3 id="out-of-memory">  Out of memory </h3><br><p>  Memory allocation errors are handled by the <code>new_handler</code> global hook, which can: </p><br><ol><li>  Eliminate out of memory and continue execution </li><li>  Throw an exception </li><li>  Emergency end the program </li></ol><br><p>  Now <code>std::bad_alloc</code> thrown by default.  It is proposed to call <code>std::terminate()</code> by default.  If you need the old behavior, replace the handler with the one you need at the beginning of <code>main()</code> . </p><br><p>  All existing functions of the standard library will become <code>noexcept</code> and will crash the program with <code>std::bad_alloc</code> .  At the same time, new APIs will be added, such as <code>vector::try_push_back</code> , which allow memory allocation errors. </p><br><h3 id="logic_error"> <code>logic_error</code> </h3> <br><p>  Exceptions <code>std::logic_error</code> , <code>std::domain_error</code> , <code>std::invalid_argument</code> , <code>std::length_error</code> , <code>std::out_of_range</code> , <code>std::future_error</code> report a violation of the function precondition.  In the new error model, contracts should be used instead.  The listed exception types will <strong>not</strong> be declared obsolete, but almost all cases of their use in the standard library will be replaced by <code>[[expects: ‚Ä¶]]</code> . </p><br><h2 id="tekuschee-sostoyanie-proposal">  Current Proposal Status </h2><br><p>  Proposal is now in draft.  He has already changed quite a lot, and he can still change a lot.  Some developments did not have time to publish, so the proposed API <code>&lt;system_error2&gt;</code> not entirely relevant. </p><br><p>  The offer is described in 3 documents: </p><br><ol><li>  <a href="https://wg21.link/P709">P709</a> - the original document from the coat of arms of Sutter </li><li>  <a href="https://wg21.link/P1095">P1095</a> - Deterministic exceptions in Niall Douglas vision, some moments are changed, compatibility with C language is added </li><li>  <a href="https://wg21.link/P1028">P1028</a> - API from the <a href="https://github.com/ned14/status-code">test implementation of</a> <code>std::error</code> </li></ol><br><p>  There is currently no compiler that supports static exceptions.  Accordingly, it is not yet possible to make them benchmarks. </p><br><p>           C++23.   , , ,   C++26,    ,  ,  . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>            ,     ,     .    ,            .   . </p><br><p>  ,   ^^ </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430690/">https://habr.com/ru/post/430690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430680/index.html">Writing a simple processor and environment for it</a></li>
<li><a href="../430682/index.html">Three years of the lunar microsatellite project: stages of maturation</a></li>
<li><a href="../430684/index.html">Scanning Live Ethereum of Unchecked-Send Error Contracts. Part 2</a></li>
<li><a href="../430686/index.html">Review: WAZER, the first desktop waterjet cutting machine</a></li>
<li><a href="../430688/index.html">Data transfer via animated QR to Gomobile and GopherJS</a></li>
<li><a href="../430694/index.html">A brief guide to learning C ++: what, when and what to create</a></li>
<li><a href="../430700/index.html">A unified online movie viewing system will start working in Russia</a></li>
<li><a href="../430702/index.html">Very strange training</a></li>
<li><a href="../430704/index.html">How artificial intelligence technologies help Aviasales grow: seven examples</a></li>
<li><a href="../430706/index.html">New theory of evolution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>