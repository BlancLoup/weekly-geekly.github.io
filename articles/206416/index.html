<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ruby: cheatsheet to explore</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a roadmap-cheatsheet article for Ruby learners. Instead of telling the next how-to, I will try to paint all those things that, in my opinion, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ruby: cheatsheet to explore</h1><div class="post__text post__text-html js-mediator-article">  This is a roadmap-cheatsheet article for Ruby learners.  Instead of telling the next how-to, I will try to paint all those things that, in my opinion, can be summarized briefly and succinctly, with the emphasis that the programmer who came from other languages ‚Äã‚Äãand platforms may not seem obvious, anti-search and simply expensive. on time to study without prompts - just give the rest for the rest.  Despite the fact that in nature there are many tutorials / castes / books / anything on anything, I myself always lack this format.  And in fact, these are the things that I most often talk about with questions like ‚Äúhow is it at all?‚Äù, ‚ÄúWhere to start?‚Äù, ‚ÄúHow is such a thing done?‚Äù, ‚ÄúAnd which gem is better?‚Äù.  By the way, while I was working on this article <a href="http://habrahabr.ru/post/205944/">on Habr√©, a similar one about Python appeared</a> - apparently, the idea is in the air. <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">About Ruby - Rumors, Intrigues, Investigations</b> <div class="spoiler_text">  I‚Äôll just say that the text under this spoiler is different from the main ‚Äúobjective‚Äù part of the article, because  here is my personal opinion and impression. <br><br>  A programming language is not only syntax, garbage collector, not only the paradigm of the language, and not even so much its philosophy, first of all - it is the community and the code base that this community has created.  Especially now, in the era of OpenSource.  And here at Ruby the first fat plus in karma.  One of the features is pragmatic laziness in everything, starting with the optional brackets when calling methods and semicolons at the end of the line, continuing with a meaningful and expressive syntax, and ending with the general feeling of the projects - many of them are made out of the box and require minimal effort to configure them. <br><br>  Many people choose Ruby, because it is comfortable and enjoyable.  The pleasure and joy of programming can be obtained in different languages ‚Äã‚Äã- and in Ruby it looks like riding a good car, sitting behind the wheel of which you will think not so much about the road, as about more important things - at least about the route and the final goal of the trip. <br>  You can also compare with the game in Lego (and this is largely due to Gems).  Although someone loves welding fittings, and someone enough cardboard and glue. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are several statements that can sometimes be found about Ruby and Rails - I will try to clarify them. <br><br>  It is known that Ruby is slow.  And it's hard to argue, because Ruby is an interpreted language.  And that is typical, most often I hear it from those who write (exclusively) in PHP, which we also interpret, and in terms of speed in synthetic tests is approximately at the same level.  Most likely, these are echoes of the notoriety of old versions.  In fact, I had to work with both Rails and Symfony - on real Rails applications, with the same level of optimization faster (and in both, proper caching is the key to success).  If you need speed and compactness in memory - <s>write in assembly language,</s> use Node.js.  But the paradox is that rubists often write on it when it is truly justified.  And the thing is this: not only the speed of work is important, but also the speed of writing the application.  And Ruby, and all that can be found on github in every way helps to achieve a really high productivity of the programmer - including in the application optimization capabilities.  And we should not forget that the main load and bottlenecks are often databases, and web applications are just a layer of business logic.  And such a layer scales well. <br><br>  There is also a peculiar myth about the high salaries of Ruby-developers, on the one hand, and on the other, that there is little work on Ruby.  Usually compared with salaries with the average market for PHP, and the amount of work on it.  The average level of wages for PHP is the classic ‚Äúaverage wage temperature in a hospital‚Äù.  If we compare the specialists in Yii / Symfony / Zend and Rails (you can also add Django to Python) - the picture will be completely different, namely: both salaries and market size are about the same.  Indeed, good programmers are paid well.  And what's more, when you start a project from scratch - often the choice of platform is yours and your team, and not the customer / boss. <br><br>  So, there are a lot of great languages ‚Äã‚Äãand frameworks for writing web applications, and Ruby with Rails is not a silver bullet that will kill all werewolf rabbits at once.  Simply, in my opinion, if you take a set of important criteria, and not try to choose one or two of them, RoR is really gaining a lot of points.  Including maturity is no longer a hipster platform, in which there is only potential, but also not an old man (there are a lot of examples of those and others).  And I‚Äôm not going to be an old man for a long time, because  Ruby and Rails still have potential for growth and development - but this is a topic for a separate article. <br><br>  And of course, despite the focus of the article on Rails, and the popularity of this particular platform - Ruby is not only Rails. <br><br>  In any case, I am convinced that a programmer should not sit in his own little world of what he is paid for today.  In this sense, Ruby provides not only +1 language in the summary, but also, due to its focus and the wide possibilities of metaprogramming, experience that is useful in different languages ‚Äã‚Äãand platforms. <br><br>  <a href="http://habrahabr.ru/post/131661/">Ruby language: history of development and development prospects</a> <br></div></div><br><br><h4>  Ruby </h4><br><br><div class="spoiler">  <b class="spoiler_title">Start</b> <div class="spoiler_text"><h5>  How to install Ruby on # {os_name}? </h5><br>  The links themselves: <br><ul><li>  <a href="http://www.rubyinstaller.org/downloads/">Win</a> .  For the same link you can find DevKit, which is useful for working with databases and installing Native Extensions. </li><li>  <a href="http://railsinstaller.org/">The Rails Installer</a> installs Ruby + DevKit, Git, Rails, Bundler, and SQLite right away on Windows or MacOS.  Ruby, however, is 1.9.3, and the installer with 2.0 is still in alpha.  (on the advice of <a href="https://habr.com/users/jabher/" class="user_link">Jabher</a> ) </li><li>  * nix - search in your repositories, or <a href="http://www.ruby-lang.org/ru/downloads/">legacy</a> </li></ul><br>  In addition, there is such a thing as <a href="https://rvm.io/rvm/install">RVM</a> .  It allows you to install multiple versions of Ruby on the same OS and switch between them.  At the start, there is no need for it, but it is useful if there are already several projects on the local machine or on the server - it‚Äôs not particularly great to update at once to the new version.  For now - just keep in mind that it is. <br>  <a href="http://habrahabr.ru/post/120504/">Details about RVM</a> on Habr√©. <br><br>  It is also worth mentioning the development environment.  I‚Äôm an adherent of JetBrains products, so I recommend <a href="http://www.jetbrains.com/ruby/">RubyMine</a> , but due to the fact that a free <a href="http://www.aptana.com/">Aptana Studio</a> may suit someone‚Äôs commercial product.  If it is more pleasant to use lightweight text editors, Ruby syntax is supported by many. <br><br>  Directly in the browser in the interactive mode of Ruby you can try on <a href="http://tryruby.org/">tryruby.org</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">All - object</b> <div class="spoiler_text">  Including numbers, strings, and even nil ‚Äî they are all inherited from the Object class.  Can anything call methods like nil ?, class, methods and respond_to ?: <br><pre><code class="ruby hljs"><span class="hljs-string"><span class="hljs-string">'Hello world'</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-comment"><span class="hljs-comment"># String nil.class # NilClass String.class # Class String.ancestors # [String, Comparable, Object, Kernel, BasicObject];    nil.nil? # true Object.new.methods #     Object;        -    nil.respond_to?('nil?') # true</span></span></code> </pre>  Regarding the latter: it is important for <a href="http://ru.wikipedia.org/wiki/%25D0%25A3%25D1%2582%25D0%25B8%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">duck typing</a> . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Syntax and Powder</b> <div class="spoiler_text">  Ruby is heavily seasoned with ‚Äúsyntactic sugar‚Äù, due to which it is often not necessary to make porridge out of various brackets, semicolons, and so on.  And under it is simple and logical, and preserves the paradigm ‚Äúeverything is an object‚Äù. <br><pre> <code class="ruby hljs">a == b <span class="hljs-comment"><span class="hljs-comment">#  ,   a.==(b) #   .==() -  </span></span></code> </pre><br>  In method calls, in if you can not put brackets, if there is no ambiguity <br><pre> <code class="ruby hljs"><span class="hljs-literal"><span class="hljs-literal">nil</span></span>.respond_to?(<span class="hljs-string"><span class="hljs-string">'nil?'</span></span>) <span class="hljs-comment"><span class="hljs-comment"># true nil.respond_to? 'nil?' # true #  : if nil.respond_to? 'nil?' puts 'ok' end #  if 10.between? 1, 5 puts 'ok' end #        ,    if 10.between?(1, 50) &amp;&amp; 20.between?(1, 50) puts 'ok' end</span></span></code> </pre><br>  And yet - there are <a href="http://habrahabr.ru/post/48993/">symbols</a> .  In essence, characters are immutable strings.  For example, they are often used as keys in hashes. <br><pre> <code class="ruby hljs">a = <span class="hljs-symbol"><span class="hljs-symbol">:nil?</span></span> <span class="hljs-comment"><span class="hljs-comment">#  b = 'nil?' #  nil.respond_to? a # true nil.respond_to? b # true #  a == b # false a.to_s == b &amp;&amp; a == b.to_sym # true;       </span></span></code> </pre><br>  A little more powder is connected with them: <br><pre> <code class="ruby hljs">a = {<span class="hljs-symbol"><span class="hljs-symbol">:key1</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'value1'</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:key2</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'value2'</span></span>} <span class="hljs-comment"><span class="hljs-comment">#   ( ) a = {key1: 'value1', key2: 'value2'} #   - ,    (Ruby &gt;= 1.9.3)</span></span></code> </pre>  Since the topic has come: <br><pre> <code class="ruby hljs">a = [<span class="hljs-string"><span class="hljs-string">'value1'</span></span>, <span class="hljs-string"><span class="hljs-string">'value2'</span></span>] <span class="hljs-comment"><span class="hljs-comment">#   s = 'String' s = "Double-quoted #{s}" # "Double-quoted String" - , , </span></span></code> </pre><br>  And we will finish off the dusting topic with a slightly ugly, but convenient way of recording: <br><pre> <code class="ruby hljs"><span class="hljs-string"><span class="hljs-string">%w[value1 value2]</span></span> <span class="hljs-comment"><span class="hljs-comment"># ["value1", "value2"] -   ,    %i[value1 value2] # [:value1, :value2] -  , (Ruby &gt;= 2.0) s = %q(String) s = %Q(Double-quoted #{s}) %x('ls') #   `ls` #    %r(.*) == /.*/ # true;     </span></span></code> </pre><br>  By the way, in Ruby there are many painfully familiar semicolons - it can be useful to write several expressions in one line. <br><pre> <code class="ruby hljs">a = <span class="hljs-number"><span class="hljs-number">10</span></span>; puts a <span class="hljs-comment"><span class="hljs-comment">#    10 if nil.respond_to? 'nil?'; puts 'ok'; end #    -   </span></span></code> </pre>  But it is better to write single-line if <br><pre> <code class="ruby hljs">puts <span class="hljs-string"><span class="hljs-string">'ok'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>.respond_to? <span class="hljs-string"><span class="hljs-string">'nil?'</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Introductory articles and docks</b> <div class="spoiler_text">  It is worth reading <a href="http://www.ruby-lang.org/ru/documentation/ruby-from-other-languages/">In Ruby from other languages</a> and <a href="http://www.ruby-lang.org/ru/documentation/quickstart/">Ruby in twenty minutes</a> , well, and the main friend and helper <a href="http://ruby-doc.org/">ruby-doc.org</a> . <br>  It is better to immediately see the methods of the base classes (in all - which are each_ and to_). <br>  <a href="http://ruby-doc.org/core-2.0.0/String.html">String</a> (here - first thing match, sub) <br>  <a href="http://ruby-doc.org/core-2.0.0/Array.html">Array</a> (map, join, include?) <br>  <a href="http://ruby-doc.org/core-2.0.0/Hash.html">Hash</a> (has_key ?, has_value ?, merge) <br>  Rather simple examples are parsed in <a href="http://habrahabr.ru/post/48559/">Pokor Ruby together!</a>  <a href="http://habrahabr.ru/post/48559/">Drop the first</a> <a href="http://habrahabr.ru/post/48607/">Drop the second</a> <a href="http://habrahabr.ru/post/48667/">Drop the third</a> <br>  If you want to continue the banquet: <a href="http://vk.com/rgrimoire">An interesting public with a selection of magic on Ruby</a> . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Classes, Modules, and Metaprogramming</b> <div class="spoiler_text">  Classes in Ruby are quite obvious, but in the possibilities of working with them lies all the power and beauty of Ruby. <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class"> 10 </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#     -     end def baz(a) bar + 20 end end puts Foo.new.baz(10) # 30</span></span></span></span></code> </pre><br>  Module - it can be treated as an impurity, and as a namespace.  Suddenly?  In fact, it is a set of classes, methods and constants, and you can use it at your discretion. <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#    class Foo #  def initialize(k) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@k</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = k end #      def bar; </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@k</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> + 20 end end end puts B.Foo.new(3).bar # 23 puts B::Foo.new(3).bar # 23;   ,    module C #   def bar; </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@k</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> + 25 end end class Foo include C; def initialize(k) </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@k</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = k end end puts Foo.new(3).bar # 28</span></span></span></span></code> </pre><br><br>  In Ruby, classes are mutable and can be patched after they are created.  And be careful here: here the very opportunities begin, with the help of which you can ‚Äúshoot yourself in the foot‚Äù - so, doing something like this you should always give an account: why, what will happen, <s>who is to blame and what to do</s> and if anything - are to blame yourself. <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#  def baz; bar + 2 end end puts Foo.new.baz # 22 #   - :      Foo.class_eval do def bazz; bar + 3 end end puts Foo.new.bazz # 23 #        -     class Boo &lt; Foo def boo; bar + 2 end end puts Boo.new.boo # 22 #   -    ,     a = Foo.new a.instance_eval do #   def booo; bar + 3 end end puts a.booo # 23 puts Foo.new.booo rescue puts 'error' # error; ,    puts a.respond_to? :booo # true puts Foo.new.respond_to? :booo # false #  -       def a.booboo bar + 4 end puts a.booboo # 24</span></span></span></span></code> </pre>  And what if to make instance_eval for a class?  Of course, static methods will be added. <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-comment"><span class="hljs-comment">#    end puts Foo.bar # 10 Foo.instance_eval do def baz; bar + 1 end end puts Foo.baz # 11</span></span></code> </pre>  You can play with it enough, just remember - take care of your feet. <pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">self</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">add_bar</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#   ,    self.class_eval do def bar; 'bar' end end end end puts Foo.new.respond_to? :bar # false class Boo &lt; Foo #  add_bar #  end puts Boo.new.bar # bar #      ,      Foo.instance_eval do def add_baz self.class_eval do def baz; 'baz' end end end end class Baz &lt; Foo add_baz end puts Baz.new.baz # baz</span></span></span></span></code> </pre><br>  Just this approach is used in practice - in fact, it turns out something like an impurity, in which you can transfer parameters.  It seems like magic if you don‚Äôt know how to do it.  Patching is possible and base classes are especially loved by Array and String - but you should always think three times before torturing them: are methods like .blank one thing?  (it is added by Rails: something like def blank ?; nil? || empty? end), another - when the method code is specific to the project, then it is logical to assume that it belongs to some classes within the project. <br><br>  This principle works, for example, accessor.  What will we do to add a public parameter to the Ruby class? <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#  </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@bar</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> #   end def bar=(val) #  </span></span><span class="hljs-doctag"><span class="hljs-class"><span class="hljs-comment"><span class="hljs-doctag">@bar</span></span></span></span><span class="hljs-class"><span class="hljs-comment"> = val #    end end</span></span></span></span></code> </pre><br>  Imagine writing for a dozen or two parameters?  In Ruby, a lot of code on the thumb - a mortal sin: <a href="http://ru.wikipedia.org/wiki/Don%25E2%2580%2599t_repeat_yourself">DRY</a> .  So, you can make it shorter. <br><pre> <code class="ruby hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">attr_accessor</span></span></span><span class="hljs-class"> :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bar</span></span></span><span class="hljs-class">, :</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">baz</span></span></span><span class="hljs-class"> </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">#     attr_reader :boo #   attr_writer :booo #   end</span></span></span></span></code> </pre><br><br>  Ready to go further?  Then: <br>  <a href="http://habrahabr.ru/post/143990/">Understanding Ruby Metaclasses</a> <br>  <a href="http://habrahabr.ru/post/50819/">Metaprogramming patterns - about monkey patching</a> , <a href="http://habrahabr.ru/post/50169/">Reuse in small - bang!</a>  , <a href="http://habrahabr.ru/post/49951/">eval</a> <br>  <a href="http://habrahabr.ru/post/143483/">We delve into include and extend</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Arguments of methods</b> <div class="spoiler_text">  Ruby 2.0 supports named method arguments: <br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment"># bar  # barr     0 # baz -       true def foo(bar, barr = 0, baz: true) baz &amp;&amp; bar + barr end p foo 1 # 1 p foo 1, 2 # 3 p foo 1, baz: false # false</span></span></code> </pre><br>  In previous versions, you can achieve the same behavior by parsing attributes: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar, *args)</span></span></span></span> args <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> p foo2 <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">:baz</span></span> =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment"># [2, {:baz=&gt;false}] def foo3(bar, *args) options = args.extract_otions! #     args p bar p args p options end foo3 1, 2, 3, :baz =&gt; false # 1 # [2, 3] # {:baz=&gt;false}</span></span></code> </pre><br>  Starting with Ruby 2.1, you can now add mandatory named arguments. <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bar, </span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">baz:</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; bar <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> foo4 <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">#  foo4 1, baz: 2 # 1</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Closures and Blocks</b> <div class="spoiler_text">  At first, blocks, closures, and the Proc class cause some confusion - why so much?  In short - in fact, there is only Proc. <br>  Details - links below, and now - what you should pay attention. <br>  First consider the blocks.  A block is just a piece of where, and not even an object, just part of the Ruby syntax.  A block is used to pass some code to a method.  And already in the method it turns out to be wrapped in a class Proc. <br>  In the section on classes and methods they have already been used: <br><pre> <code class="ruby hljs">Foo.instance_eval <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">#    instance_eval     def baz; bar + 1 end end</span></span></code> </pre><br>  But let's take a more basic example, it's ‚Äúhow to make foreach in Ruby‚Äù: <br><pre> <code class="ruby hljs">[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>].each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|val|</span></span> p val <span class="hljs-comment"><span class="hljs-comment"># , p(val) -  shortcut  puts(val.inspect) end #  1 2 3 #  ,    [1,2,3].each { |val| p val } #  1 2 3 [1,2,3].each_with_index { |val, i| puts val.to_s + ' ' + i.to_s } #  </span></span></code> </pre><br>  If we want to pass a block to our own method: <br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">puts</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">yield</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#   puts yield + yield #  ,    end foo { 2 } # 2 4 def bar(&amp;block) # ,    puts yield block #   end bar { 3 } # 3</span></span></span></span></code> </pre><br>  It is worth noting that the block is always the last parameter, and if you need to transfer several blocks, you need to transfer them as usual parameters, which means to create Proc.new, or lambda. <br><br>  An object of the Proc class is always obtained from the block, but the block itself is a part of the syntax: we can pass it to the method, where it will become Proc, we can pass it to the Proc constructor, or use lambda, but we cannot just write the block to a variable. <br><pre> <code class="ruby hljs">proc = Proc.new { <span class="hljs-params"><span class="hljs-params">|a|</span></span> a - <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-comment"><span class="hljs-comment">#   p proc.call(10) #9 p proc.class # Proc l = lambda { |a| a + 1 } #   p l.call(10) #11 p l.class # Proc new_l = -&gt;(a) { a + 2 } #   (Ruby &gt;= 2.0) p new_l.call(10) #12</span></span></code> </pre><br><br>  There are differences in the behavior of Proc in different ways, <a href="http://habrahabr.ru/post/85578/">we read the article</a> . <br>  <a href="http://innig.net/software/ruby/closures-in-ruby">Here the closures and blocks in Ruby are parted up and down</a> <br>  On Habr√© <a href="http://habrahabr.ru/post/86882/">about blocks</a> , <a href="http://habrahabr.ru/post/50665/">about closures</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Style</b> <div class="spoiler_text">  Regarding how to write in Ruby, <a href="https://github.com/bbatsov/ruby-style-guide">there is a whole guide on GitHub</a> <br>  In short, frequently used: <br><ul><li>  2 spaces indent </li><li>  Lower-case method names with underscores: def method_name </li><li>  Names of classes and modules with capital letters: class ClassName </li><li>  If the method returns true / false, the name should end with the question (same, nil?) </li><li>  If there are two methods, one of which modifies the object, and the other returns a new one - the first ends in '!'  (for example, downcase and downcase methods! for a string - the first one will return a new one, and the second one will change the string itself) </li><li>  Instead of if (! Value) it is better to use the alias unless (value) </li><li>  A single-line block is taken in brackets {...}, and a multi-line block is taken in do ... end </li></ul><br></div></div><br><div class="spoiler">  <b class="spoiler_title">RubyGems - batch manager</b> <div class="spoiler_text">  The Ruby world would probably be completely different if it were not for RubyGems. <br>  With them, the process of supplementing the project with libraries looks very simple: <br><ul><li>  choose what we need with <a href="http://rubygems.org/">rubygems.org</a> (or through <a href="https://www.ruby-toolbox.com/">ruby-toolbox.com</a> ), for example, json_pure - JSON parser on pure Ruby (without C) </li><li>  we enter in the console gem install json_pure </li><li>  and in our rb-file: <pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'json/pure'</span></span> <span class="hljs-comment"><span class="hljs-comment">#         ,   github</span></span></code> </pre> </li></ul><br><br>  For the convenience of dependency management there is a <a href="http://bundler.io/">bundler</a> : <br><ul><li>  gem install bundler </li><li>  bundler init </li><li>  in the appeared Gemfile we add dependencies: <pre> <code class="ruby hljs">source <span class="hljs-string"><span class="hljs-string">'https://rubygems.org'</span></span> gem <span class="hljs-string"><span class="hljs-string">'json_pure'</span></span></code> </pre></li><li>  bundler install </li><li>  And in your rb file <pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'rubygems'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'bundler/setup'</span></span></code> </pre></li></ul><br>  In real projects, the list of dependencies can grow into several screens, so when transferring a project to a server, it is much more convenient to perform bundle install than manually watching what you need and doing gem install for each gem.  Well, in Rails bundler is used out of the box. <br><br>  The Gems themselves will definitely be covered in the Rails article. <br><br>  <a href="http://habrahabr.ru/post/120188/">RubyGems - detail</a> <br>  <a href="http://habrahabr.ru/post/120259/">Manage Versions with Bundler</a> <br>  <a href="http://habrahabr.ru/post/134609/">Meet the Gem.</a>  <a href="http://habrahabr.ru/post/134609/">Part One</a> <a href="http://habrahabr.ru/post/134878/">Part Two</a> <br>  <a href="http://habrahabr.ru/post/128378/">We write your first gem</a> <br>  <a href="http://habrahabr.ru/post/57829/">Making a gem for RubyGems</a> <br>  <a href="http://habrahabr.ru/post/138582/">Creating Gems - Guide</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Ruby and C</b> <div class="spoiler_text">  Not the least important feature of RubyGems is Native Extensions.  Everything is simple - the accompanying C code can be compiled together with the gem and called from the heme code itself.  Due to this, there are quite nimble parsers among them, you can install JavaScript V8 in the form of heme, and many other goodies. <br><br>  And it just needs to be borne in mind: <a href="https://github.com/seattlerb/rubyinline">Inline C</a> , it can be useful.  In short, in Ruby code, you can execute code in C, which is useful, for example, when implementing numerical algorithms. <br><br>  <a href="http://bitsofmind.wordpress.com/2008/07/21/ruby_extensions_in_c/">Introduction to Ruby C Extensions</a> <br>  <a href="http://habrahabr.ru/post/48928/">Ruby and C. Part 1</a> , <a href="http://habrahabr.ru/post/49202/">Part 2</a> , <a href="http://habrahabr.ru/post/50039/">Part 3</a> . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Streams</b> <div class="spoiler_text">  A simple example with a stream: <br><pre> <code class="ruby hljs">thread = Thread.new <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">#    a = 0 1000000.times { a+= 1 } #      puts a #   end puts 'thread started' #       thread.join #    </span></span></code> </pre><br>  The code will display ‚Äúthread started 100000‚Äù in the console. <br><br>  Lower-level fibers offer a slightly different syntax that allows you to control the sequence of execution, and also have lower memory and initialization costs than threads. <br><br><pre> <code class="ruby hljs">fiber = Fiber.new <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">#    Fiber.yield "fiber 1" #     'fiber 2' #   end puts fiber.resume #   puts 'context' puts fiber.resume #   </span></span></code> </pre><br>  The code will output ‚Äúfiber 1 context fiber 2‚Äù. <br><br><div class="spoiler">  <b class="spoiler_title">About GIL and true multithreading</b> <div class="spoiler_text">  Ruby supports multithreading, and different versions of the interpreter differ in its implementation.  GIL in the main branch negates the parallelization of calculations to nothing, but the use of threads in it makes sense for the implementation of asynchrony.  The simplest example: we can listen to the user interface while performing some operations in parallel.  Or we can send a request to the database and wait for a response in one thread, send an email in another, and without waiting for completion to send a response to the user.  But in the total execution time there will be no winnings, since  in fact, only one core will be loaded at a time. <br><br>  To circumvent this limitation, you can use versions without GIL - jRuby or Rubinius (and at the same time remember that thread safety is much lower in them - GIL is needed for it).  Another option is to run several separate copies of the program, or use <a href="http://ru.wikipedia.org/wiki/Fork">UNIX forks</a> (of course, a pool of such workers is quite possible to manage the Ruby script). <br><br>  Having learned all this, a novice rubist can be confused (wanting to use the full power of his 48-line server without an extra headache).  In practice, real multithreading is not always needed (and sometimes, if needed, sometime later).  In addition, for many tasks there are corresponding gems that implement different approaches, including ready-made HTTP servers (which will be discussed in the article on gems) and asynchronous frameworks. <br></div></div><br><br>  GIL is needed for this: <br><pre> <code class="ruby hljs">a = <span class="hljs-number"><span class="hljs-number">0</span></span> threads = [] <span class="hljs-number"><span class="hljs-number">10</span></span>.times <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">#  10  threads &lt;&lt; Thread.new do #      100000.times { a+= 1 } # 100 000 end end threads.each(&amp;:join) #     puts a #  </span></span></code> </pre><br>  The code will print 1,000,000 in the MRI, and the devil knows what (from 100,000 to 1,000,000) in jRuby and Rubinius. <br><br>  <a href="http://habrahabr.ru/post/180741/">We use flows in Ruby</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Zoo versions</b> <div class="spoiler_text">  MRI (Matz's Ruby Interpreter) is the main Ruby thread from its creator, Yukihiro Matsumoto, or simply, Matz.  Implemented in C. When they simply say ‚ÄúRuby‚Äù they usually mean it.  Starting with version 1.9 combined with the project YARV (Yet another Ruby VM).  One of its main features is the so-called GIL (Global Interpreter Lock), on Habr√© they <a href="http://habrahabr.ru/post/189320/">wrote</a> about it ( <a href="http://habrahabr.ru/post/189486/">with continuation</a> ).  Now the current version of <s>Ruby 2.0</s> <b>UPD:</b> <a href="http://habrahabr.ru/post/207394/">Ruby 2.1 has been released</a> .  <a href="http://habrahabr.ru/post/195844/">What can we expect from Ruby 2.1?</a> <br><br>  <a href="http://jruby.org/">jRuby</a> , which is written in Java and works in the JVM, and accordingly integrates with Java code.  Unfortunately, the language version lags behind MRI (Ruby 1.9.3 is now implemented), but the same Rails starts up with half a turn. <br><br>  <a href="http://rubini.us/">Rubinius</a> , which is based on MRI, but uses operating system threads, as well as being written to the maximum on Ruby itself.  According to the version usually up do date. <br><br>  The speed of all three realizations relative to each other differs from task to task, and the most gluttonous in terms of memory consumption from the trinity is jRuby. <br><br>  MacRuby - works in conjunction with Objective-C on LLVM, thereby replacing the earlier RubyCocoa project.  For development for iOS there is a fork MacRuby - <a href="http://habrahabr.ru/post/143332/">RubyMotion</a> . <br><br>  IronRuby - implementation on the .NET platform.  Throughout his life, then abandoned, then resumes development. <br><br>  <a href="http://opalrb.org/">Opal</a> is a Ruby to JavaScript translator.  But you don‚Äôt have to expect anything extraordinary from it, it‚Äôs not jRuby for Node.js - it just gives you the opportunity to write your jQuery-code in Ruby.  Or Express code under Node.js.  In general, a variation on the theme of CoffeeScript. <br><br>  <a href="http://www.rubyenterpriseedition.com/">Ruby Enterprise Edition</a> (REE) - Ruby on steroids.  The project has completed its existence, because  new versions and no drugs run well. <br><br>  <a href="http://maglev.github.io/">MagLev</a> can be mentioned - a specific version that can be useful for deploying cloud infrastructure. <br><br>  Also interesting is the <a href="https://github.com/mruby/mruby">mruby</a> project, in which Matz participates.  This is embedded Ruby.  The project is not finished yet, but looks very promising.  <s>So, we wait for ruby ‚Äã‚Äãon Arduino.</s>  <a href="https://github.com/kyab/mruby-arduino">mruby-arduino</a> .  <a href="http://mobiruby.org/">MobiRuby</a> for mobile application development is based on it. <br><br>  Well, for a snack, <a href="http://kidsruby.com/">KidsRuby</a> , the meaning resembles the old man Logo. <br></div></div><br><br>  <strong>upd:</strong> <br>  <a href="https://learnxinyminutes.com/docs/ruby/">learnxinyminutes.com/docs/ruby</a> - code examples on Ruby. </div><p>Source: <a href="https://habr.com/ru/post/206416/">https://habr.com/ru/post/206416/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../206404/index.html">How and how fast do you feel in your mind at the elementary level?</a></li>
<li><a href="../206408/index.html">5000 mAh Battery Case Cover for HTC One</a></li>
<li><a href="../206410/index.html">Original Tomb Raider released for iOS</a></li>
<li><a href="../206412/index.html">C ++ tricks and tips from Boost for every day</a></li>
<li><a href="../206414/index.html">Split testing of the landing page. results</a></li>
<li><a href="../206418/index.html">What to do with Bitcoin us, ordinary people</a></li>
<li><a href="../206420/index.html">Python interpreter: what does a snake think? (part I-III)</a></li>
<li><a href="../206422/index.html">Four HeadHunter experiences in social networks</a></li>
<li><a href="../206424/index.html">ASUS Review The New PadFone Infinity</a></li>
<li><a href="../206426/index.html">What else can you do on the e-ink book with Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>