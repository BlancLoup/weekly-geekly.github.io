<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Private dynamic IP - come, see, hide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I did not have to communicate with DynDNS services from the very first day of our acquaintance. The rake came across at every step: registering, downl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Private dynamic IP - come, see, hide</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/92e/0b0/7f9/92e0b07f9080958de23a3b2e3980e6dd.gif" alt="image"><br>  I did not have to communicate with DynDNS services from the very first day of our acquaintance.  The rake came across at every step: registering, downloading and launching a client, setting up a client or a router ‚Äî everywhere there were some minor nuances, misunderstandings, shortcomings, or just bugs, which led to the inoperability of the service.  In the appendage to everything, after a while, ‚Äúthese guys‚Äù suddenly cease to be white, fluffy and free - they begin to send spam, to demand to solve a captcha once a month, or to make them perform some other movements to prove that you are still alive.  All this led to a general dislike for all services of this kind.  And so the idea arose to create something of their own, and so that the ‚Äúwhite and fluffy‚Äù is necessary. <br><a name="habracut"></a><br>  A lot of time passed from idea to implementation.  Mainly due to the misunderstanding of ‚Äúwhat do I really need?‚Äù.  I read articles at my leisure, I thought about it, and gradually a list of basic requirements for a bicycle appeared in my head. <br><br><h4>  The main provisions. </h4><br>  <u>Purpose</u> : find the IP address of the remote computer (for example, home computer). <br>  <u>Level of paranoia</u> : above average!  (i.e., only authorized representatives should know the IP address).  This is the main difference from similar services - I don‚Äôt want anybody to get the address of my computer just by typing something like ‚Äúping supercomp.dyndns.org‚Äù on the command line. <br>  <u>Mandatory conditions of "fluffiness"</u> : <br><ol><li>  Free (do not forget that time is also money). </li><li>  Stability. </li><li>  Simplicity of the ready decision for the end user. </li></ol><br>  Based on the clarification to the first condition, it was decided to use technology only those that I personally know more or less - Windows, c #, ASP.NET. <br>  Influenced by the article ‚Äú <a href="http://habrahabr.ru/post/188598/">Your Simple DynDNS Server</a> ‚Äù, an attempt was made to write a small proxy site.  But, looking at the surprisingly stable instability of free ASP.NET hosting, it was decided to abandon this idea and use free mail services and cloud storages as intermediaries.  By the way, it was from this article that the sensible idea with the ‚Äúability to store the IP addresses of all client interfaces‚Äù was taken. <br>  Somehow it happened that this should be a common Windows B-Sharpe application. <br><br><h4>  The choice of "storage" </h4><br>  Under the repository means a place where our information will lie.  This place must be protected from prying eyes, be easily accessible from any point and must comply with the three "fluffy" requirements. <br>  In order not to strain too much, it was decided to focus on the following options: <br><ul><li>  The file system of the computer (for example, a folder synchronized by some cloud client) - there is absolutely no saving or reading of problems, all work with the network lies on the cloud client. </li><li>  Mail - letters are sent without problems, but you have to read through a third-party free library. </li><li>  Cloud storage (meaning interaction with the cloud without installing a client) is quite feasible. </li></ul><br>  On the third paragraph we will stop, and we will consider possible options. <br>  A preliminary survey of friends and acquaintances showed that most have nothing against Yandex-Disk and Sky-Drive.  Therefore, they were initially considered as the main applicants.  But after spending half a day in ‚Äúactive search‚Äù, it turned out that not every cloud service provides a sane means of interaction.  For example, the Sky-Drive API cannot be used in desktop applications for some time, the Google-Drive API is not possible to understand without a bottle, and I haven‚Äôt found the Windows SDK at all in DropBox.  The use of unofficial or outdated ‚ÄúAPIs‚Äù was not even considered, as there is no guarantee that they will work tomorrow.  Maybe I was looking badly, or not there, or looking for something else - I don‚Äôt know if someone has examples, I will be happy to help.  The last nail in the problem of choosing a cloud service was the fact that no third-party libraries are needed at all to work with the Yandex disk from c #. <br>  I didn‚Äôt stop at one of these three types of storage / transfer.  It was decided to make support for all three, and what specifically to use - leave the choice of the user.  For situations are different - someone has closed ports and mail does not work, someone can not put the program of cloud clients, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  The overall algorithm of the application. </h4><br>  The general algorithm of work is simple as two kopeks: <br><ol><li>  Periodically save text messages with all the necessary information in the "repository" </li><li>  Periodically we read messages, and we show in a convenient form. </li></ol><br>  Let us turn to the implementation of ideas in the program code. <br><br><h5>  Getting an external address. </h5><br>  It's simple.  In the "Internet" is full of all sorts of services that show your external address.  If there are few existing ones, then creating a couple of dozen will not be difficult.  Sample code for such a page on ASP.NET: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Page_Load</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { LabelIp.Text = HttpContext.Current.Request.UserHostAddress; }</code> </pre> <br>  Let's return to our application.  Using the System.Net.WebClient class, we download a page with this address into a string, parse it with a regular expression, and get the information we need: <br><pre> <code class="cs hljs">WebClient webClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebClient(); <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> strExternalIp = webClient.DownloadString(<span class="hljs-string"><span class="hljs-string">"http://checkip.dyndns.org/"</span></span>); strExternalIp = (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(<span class="hljs-string"><span class="hljs-string">@"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"</span></span>)).Matches(strExternalIp)[<span class="hljs-number"><span class="hljs-number">0</span></span>].ToString();</code> </pre><br><h5>  Getting the properties of network interfaces. </h5><br>  The System.Net.NetworkInformation.NetworkInterface class, and its static method GetAllNetworkInterfaces (), which returns an array of elements of its own NetworkInterface [] type, will help us with this.  After going through this array, we can get all the information we need from the IPInterfaceProperties object - IP addresses, masks, gateways, dns servers, etc .: <br><pre> <code class="cs hljs">NetworkInterface[] adapters = NetworkInterface.GetAllNetworkInterfaces(); <span class="hljs-comment"><span class="hljs-comment">//     foreach (NetworkInterface nic in adapters) { string strInterfaceName = nic.Name; //   string strPhysicalAddress = nic.GetPhysicalAddress().ToString(); // -  string strAddr = string.Empty; //  IP  IPInterfaceProperties properties = nic.GetIPProperties(); foreach (UnicastIPAddressInformation unicast in properties.UnicastAddresses) { strAddr = unicast.Address.ToString() + " / " + unicast.IPv4Mask; } //  - foreach (IPAddress dnsAddress in properties.DnsAddresses) { strAddr = dnsAddress.ToString(); } //   foreach (GatewayIPAddressInformation gatewayIpAddressInformation in properties.GatewayAddresses) { strAddr = gatewayIpAddressInformation.Address.ToString(); } }</span></span></code> </pre><br><h5>  Sending a text message in the "repository". </h5><br>  After collecting all the necessary information, we send it to the ‚Äúrepository‚Äù as a plain text file (in the case of mail, just a message). <br>  With ordinary files, everything is simple: <br><pre> <code class="cs hljs">System.IO.File.WriteAllText(<span class="hljs-string"><span class="hljs-string">"MyInterfaces.txt"</span></span>, strInterfaces);</code> </pre><br>  With mail, too, everything is solved by a couple of lines of code (the method is easily on the Internet).  One of the possible variations: <br><pre> <code class="cs hljs">MailMessage mail = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MailMessage { From = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MailAddress(strMailAddress), <span class="hljs-comment"><span class="hljs-comment">//   Subject = strSubject, //   Body = strBody, //   IsBodyHtml = false }; mail.To.Add(new MailAddress(Settings.Default.strMailTo)); //  SmtpClient client = new SmtpClient { Host = strSmtpServer, //  SMTP  Port = nSmtpServerPort, //  SMTP  EnableSsl = isSmtpSsl, //    SSL Credentials = new NetworkCredential(strEmailUserName, strMailPassword), //   DeliveryMethod = SmtpDeliveryMethod.Network }; client.Send(mail); //  mail.Dispose();</span></span></code> </pre><br>  But with the clouds a little more difficult, the general sense is to create the correct web request in which to cram the transmitted text: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// strFilePath -        HttpWebRequest web = (HttpWebRequest)WebRequest.Create("https://webdav.yandex.ru/" + strFilePath); //     (!!!   ) web.Credentials = new NetworkCredential("mail@yandex.ru", "password"); web.Headers.Add("Authorization: Basic " + Convert.ToBase64String(Encoding.Unicode.GetBytes("mail@yandex.ru" + ":" + "password"))); web.Accept = "*/*"; web.Method = "PUT"; web.ContentType = "application/binary"; web.ContentLength = buffer.Length; using (Stream myReqStream = web.GetRequestStream()) { // strContent -    byte[] buffer = Encoding.UTF8.GetBytes(strContent); myReqStream.Write(buffer, 0, buffer.Length); myReqStream.Flush(); } HttpWebResponse resp = (HttpWebResponse)web.GetResponse();</span></span></code> </pre><br>  Here I had to dance a little with encodings, but it was found by the ‚Äúscientific tyke‚Äù method that everything works fine with UTF8. <br><br><h5>  Reading messages from the "repository" </h5><br>  Regular files from a regular file system are read in one line.  But we don‚Äôt just need one file, and its name may not be known in advance, so we look through the entire contents of the folder, look for files using the specified mask and process them in turn: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//          var files = Directory.EnumerateFiles("  ", "*.txt"); strFileNames = files as string[] ?? files.ToArray(); foreach (string strFileName in strFileNames) { string message = File.ReadAllText(strFileName); //    // -    }</span></span></code> </pre><br>  With reading the mail had to tinker.  The code was sharpened for Google-mail, so it may be incorrect work on other mailers.  It was Google Mail that led to the use of the IMAP server (at present, hotmail does not support this protocol).  Many advised to use a pseudo-free library (I will not give the name), which periodically instead of the body of the letter returned its advertisement.  But this directly violates the "second fluffy requirement" - stability, and if you pay, the "first fluffy" - free of charge.  Therefore, I chose a completely free and fully working library in which there is work with IMAP servers - ‚Äú <a href="http://mailsystem.codeplex.com/">MailSystem.NET</a> ‚Äù.  Examples of use can be found on the project page, but here I will give a small piece of code to receive a letter: <br><pre> <code class="cs hljs">Imap4Client imap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Imap4Client(); imap.ConnectSsl(<span class="hljs-string"><span class="hljs-string">"imap.gmail.com"</span></span>, <span class="hljs-number"><span class="hljs-number">993</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  imap.Login("mail@google.com", "password");//  Mailbox inbox = imap.SelectMailbox("inbox");//    int[] nIdsUnread = inbox.Search("UNSEEN"); //    int nUnreadCount = nIdsUnread.Length; //    for (int i = 0; i &lt; nUnreadCount; i++) { int idx = nIdsUnread[i]; //       //    Message message = inbox.Fetch.MessageObject(idx); // message.Subject -    // message.BodyText.Text -    //    }</span></span></code> </pre><br>  This is how you can read the letter - only ten lines of code, but they pull five libraries (DLL) into the program folder, and then you have to carry them everywhere. <br><br>  Reading files from cloud storage is even easier than sending them there: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// strFilePath -        HttpWebRequest web = (HttpWebRequest)WebRequest.Create("https://webdav.yandex.ru/" + strFilePath); //     web.Credentials = new NetworkCredential("mail@yandex.ru", "password"); web.Headers.Add("Authorization: Basic " + Convert.ToBase64String(Encoding.Unicode.GetBytes("mail@yandex.ru" + ":" + "password"))); web.Accept = "*/*"; web.Method = "GET"; HttpWebResponse resp = (HttpWebResponse)web.GetResponse(); using (StreamReader sr = new StreamReader(resp.GetResponseStream())) { string text = sr.ReadToEnd(); // text -        }</span></span></code> </pre><br>  But this example will read only one file, and we need to read all the files from the specified directory.  This task is solved by preliminary request of the file list.  The server will return the XML file to us, and going over the contents of the &lt;d: displayname&gt; tags we will get a list of files: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">// strPath -      HttpWebRequest web = (HttpWebRequest)WebRequest.Create("https://webdav.yandex.ru/" + strPath); //     web.Credentials = new NetworkCredential("mail@yandex.ru", "password"); web.Headers.Add("Authorization: Basic " + Convert.ToBase64String(Encoding.Unicode.GetBytes("mail@yandex.ru" + ":" + "password"))); web.Accept = "*/*"; web.Headers.Add("Depth: 1"); web.Method = "PROPFIND"; List&lt;string&gt; retValue = new List&lt;string&gt;(); //          HttpWebResponse resp = (HttpWebResponse)web.GetResponse(); using (StreamReader sr = new StreamReader(resp.GetResponseStream())) { //   XML .   : XmlDocument xmlDoc = new XmlDocument(); xmlDoc.LoadXml(sr.ReadToEnd()); XmlNodeList displaynames = xmlDoc.GetElementsByTagName("d:displayname"); int nCount = displaynames.Count; for (int i = 1; i &lt; nCount; i++) { retValue.Add(displaynames[i].InnerText); } }</span></span></code> </pre><br><h5>  DNS </h5><br>  After receiving all the information from the repository, the question arises - what next?  And there are not many options: <br><ol><li>  Show the user everything received in a convenient way. </li><li>  To organize the ability to access remote computers by name </li></ol><br>  With the first one everything is simple - a regular list and a couple of columns.  But the second is more difficult.  You can implement in two ways: <br><ol><li>  Editing the% windir% \ system32 \ drivers \ etc \ hosts file </li><li>  Create your local DNS server </li></ol><br>  The first is implemented quite simply, the hosts file is a plain text file that is easily read / changed / saved, the main thing is just to have rights to it.  And the usual user doesn‚Äôt have them, so we increase the ‚ÄúWindows Account Management Level‚Äù for our application by setting the value for requestedExecutionLevel = requireAdministrator in the app.manifest file.  Read more about this <a href="http://msdn.microsoft.com/en-us/library/bb756929.aspx">here</a> .  We work with the hosts file like this: <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   string strHosts = File.ReadAllText(Environment.SystemDirectory + "\\drivers\\etc\\hosts"); string[] linesHostsOld = Regex.Split(strHosts, "\r\n|\r|\n"); //    StringBuilder sbHostsNew = new StringBuilder(); //    foreach (string lineHosts in linesHostsOld) { sbHostsNew.AppendLine(lineHosts); } //       sbHostsNew.AppendLine("127.0.0.1 hello.world.com"); //    File.WriteAllText(Environment.SystemDirectory + "\\drivers\\etc\\hosts", sbHostsNew.ToString());</span></span></code> </pre><br>  The second option I did not manage to test well, since so far everyone is fully satisfied with the performance of the first method.  DNS server is implemented using a third-party library " <a href="https://arsofttoolsnet.codeplex.com/">ARSoft.Tools.Net</a> ".  Strongly not wise, and <a href="https://docs.ar-soft.de/arsoft.tools.net/DNS%2520Server.html">these</a> examples make our functions, something like this: <br><pre> <code class="cs hljs">DnsServer _server = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DnsServer(IPAddress.Any, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, ProcessQuery); _server.Start(); <span class="hljs-comment"><span class="hljs-comment">//   //    DNS  private static DnsMessageBase ProcessQuery( DnsMessageBase message, IPAddress clientAddress, ProtocolType protocol) { message.IsQuery = false; DnsMessage query = message as DnsMessage; if (query != null) { if (query.Questions.Count == 1) { if (query.Questions[0].RecordType == RecordType.A) { if (query.Questions[0].Name.Equals("hello.world.com", StringComparison.InvariantCultureIgnoreCase)) { IPAddress ip; if (IPAddress.TryParse("127.0.0.1", out ip)) { query.ReturnCode = ReturnCode.NoError; DnsRecordBase rec = new ARecord(strHostName, 0, ip); query.AnswerRecords.Add(rec); return message; } } } } } message.ReturnCode = ReturnCode.ServerFailure; return message; }</span></span></code> </pre><br><h4>  Ready application. </h4><br>  By bringing together all the above, and adding a call to the necessary procedures on a timer, you get some semblance of a conceived program.  It remains only to modify all the file, bring in the divine form and can be shown to people. <br>  All the settings (and they turned out quite a few) the application stores in the file% PROGRAM_NAME% .exe.config and the file itself lies somewhere in the area:% USERPROFILE% \ AppData \ Local \% PROGRAM_NAME% \ ***.  This is implemented using the standard features of <a href="http://msdn.microsoft.com/ru-ru/library/a65txexh(v%3Dvs.100).aspx">Properties.Settings.Default</a> .  Passwords are stored there, but in encrypted form.  Encryption is done using <a href="http://msdn.microsoft.com/en-us/library/system.security.cryptography.protecteddata.protect.aspx">DPAPI</a> (there is <a href="http://habrahabr.ru/post/148602/">an article</a> and a <a href="http://habrahabr.ru/qa/6927/">question</a> on a hard disk on this topic). <br>  I will not describe in detail the work with the settings of the form, with encryption, with timers, with parallel processes and everything else that does not concern the original topic.  Who is very interesting - you can always see the source code. <br><br><h5>  The appearance of the resulting bike: </h5><br><img src="http://habrastorage.org/storage3/2fb/10b/55c/2fb10b55c1bf008342228048ef224217.png"><br><div class="spoiler">  <b class="spoiler_title">Four screenshots of the program</b> <div class="spoiler_text"><img src="http://habrastorage.org/storage2/8fa/d82/775/8fad827750b96d3cfcd6e116ba10f2d4.png"><br><img src="http://habrastorage.org/storage2/e90/421/3fd/e904213fd7b13f08376be87e043b0dcf.png"><br><img src="http://habrastorage.org/storage2/f9d/3ff/bdd/f9d3ffbdd26e1aed0deb21f6e8878aea.png"><br><img src="http://habrastorage.org/storage2/979/782/c15/979782c15395c4b133ade4ba7afc3ff0.png"></div></div><br><br>  When you first start you will need to carefully configure all the necessary parameters. <br>  In the minimum version: on the first computer (with a dynamic address) you will need to configure the "interfaces", and on the second computer (on which we need to know the dynamic address) you will need to carefully configure the "hosts". <br><br><h4>  Development plans. </h4><br><ul><li>  Increase in supported cloud storage. </li><li>  Increase in supported mail protocols </li><li>  Encryption of transmitted information. </li></ul><br><br>  The source code of the project and the program itself has yet been uploaded to Yandex.Disk. <br>  Sources can be downloaded here: <a href="http://yadi.sk/d/iZNy9wA28E0-E">http://yadi.sk/d/iZNy9wA28E0-E</a> <br>  Binary files are here: <a href="http://yadi.sk/d/kYpZIqdn8E-ui">http://yadi.sk/d/kYpZIqdn8E-ui</a> <br><br>  That's all.  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/191172/">https://habr.com/ru/post/191172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191158/index.html">Give a man a fish, and he will be full all day. Offer him to learn programming, and he ...</a></li>
<li><a href="../191162/index.html">IT Jam 2013</a></li>
<li><a href="../191164/index.html">Many tests do not happen</a></li>
<li><a href="../191168/index.html">How to start using DI</a></li>
<li><a href="../191170/index.html">Fluent interface and Delphi</a></li>
<li><a href="../191174/index.html">Tenders from the inside by the participant</a></li>
<li><a href="../191176/index.html">Encoding and decoding PHP code</a></li>
<li><a href="../191178/index.html">.NET dynamic, Unity and RuntimeBinder error</a></li>
<li><a href="../191180/index.html">Dell u2412m: getting rid of shima without losing the ability to adjust the brightness</a></li>
<li><a href="../191182/index.html">Experience with GPS-logger Holux M-241. We work from under Windows, Mac OS X, Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>