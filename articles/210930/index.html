<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I classes in Vim wrote</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Foreword 
 For about four years, I have been fascinated with the JS language, and especially attracted to him the prototype implementation of object o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I classes in Vim wrote</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/671/067/f1c/671067f1cd35997c0beec86a405b6049.png" alt="image"><br><h4>  Foreword </h4><br>  For about four years, I have been fascinated with the JS language, and especially attracted to him the prototype implementation of object orientation and closure.  Since I am a big fan of ‚Äúexercise bikes‚Äù in programming and I love to learn something new with practical examples, I have long wanted to try to implement this on my own, and quite recently I had a chance.  One cold winter day, I was fascinated by the Vim editor, and studying its scripting language, I drew attention to some important features, namely associative arrays and passing functions by reference.  I could not pass by and realized my prototype object orientation in Vim with inheritance and polymorphism. <br><br>  I want to immediately please those who are not familiar with the syntax of the Vim scripting language, I will try to accompany the code with detailed comments.  I‚Äôll make a reservation that the goal of this work was not to create a full-fledged object orientation in Vim, but to practice the implementation of the object paradigm through prototyping.  Of course, I tried to make the implementation as light and fast as possible, but I still doubt that the result can be effectively applied in ‚Äúcombat‚Äù scripts, so please treat this accordingly. <br><br><a name="habracut"></a><br><h4>  What had to start </h4><br>  First, a few words about what is out of the box in Vim and what we will use for work. <br>  <b>Typing</b> - where without it, has 6 data types: Integers, Fractional Numbers, Strings, Function Pointer, Arrays, Associative Arrays.  Here the most interesting for us is the latter type.  Associative arrays are created in the same way as in JS: <br><pre><code class="bash hljs"><span class="hljs-string"><span class="hljs-string">''</span></span>  ¬´¬ª      <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> Obj = {<span class="hljs-string"><span class="hljs-string">'foo'</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>}</code> </pre> <br>  at the same time functions can be values.  Perfect base for future objects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Variables</b> - nothing special, except for the important "syntactic sugar" - the ability to access the elements of an associative array through a dot: <br><pre> <code class="bash hljs"><span class="hljs-string"><span class="hljs-string">''</span></span>      foo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> Obj.foo</code> </pre><br>  comfortable, not the word! <br><br>  <b>Functions</b> - an important feature is that you can assign a function to an ‚Äúobject‚Äù, that is, when you call a function from an associative array, you can access it through the self variable: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! Obj.getFoo() dict <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> self.foo endfunction</code> </pre><br>  Also, the possibility of adding functions directly to objects should not be overlooked. <br><br>  <b>Standard structures, such as if, for, and so on</b> - what a scripting language without them ?! <br><br><h4>  Theory </h4><br>  Having studied in detail the possibilities of the Vim scripting language (hereinafter, I‚Äôll simply write Vim), I began to think about what must necessarily be for the prototype object orientation, and this is what I thought: <br><ul><li>  Classes - or rather, prototypes, that is, certain objects, on the basis of which other objects are created (instances of these classes); </li><li>  Inheritance - without this great opportunity, it will be hard to expand the existing classes; </li><li>  Strong typing and polymorphism - I would like the properties of future objects to be strongly typed, and if the property expects a certain class, then objects of the child classes can be written to it; </li><li>  Packages, namespace and use - otherwise we will get cluttering up the global scope and unreasonable memory consumption. </li></ul><br><br>  Ideally, everything should look like this: <br><pre> <code class="bash hljs">use foo\bar\Class as Class <span class="hljs-string"><span class="hljs-string">''</span></span>   MyClass    Class     foo  bar <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> MyClass = Class.expand({<span class="hljs-string"><span class="hljs-string">'foo'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>: Class}) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj = new MyClass() call obj.set(<span class="hljs-string"><span class="hljs-string">'prop'</span></span>, <span class="hljs-string"><span class="hljs-string">'val'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> obj.get(<span class="hljs-string"><span class="hljs-string">'prop'</span></span>) call obj.set(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>, obj)</code> </pre><br><br>  Pay attention to the process of creating a new class.  We extend some base class by adding its properties, while the foo property is of type string, and the bar property is the type corresponding to the base class itself, that is, Class.  What this should mean in practice - using the set method, we can write only a string to the foo property, and only an object of the Class class or its subclasses (including MyClass for obvious reasons) to the bar property.  In the second case, if we try to write an object of the class MyClass into the bar property, then it should be ‚Äúrestricted‚Äù to the structure of the Class class, that is, it should not have the foo and bar properties.  It should also be possible to re-expand the object to the class MyClass, but only if necessary (by analogy with Java). <br><br>  Let's not forget about the constructor, we need the ability to determine the state of the object when it is created, for example: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj = new MyClass(<span class="hljs-string"><span class="hljs-string">'val'</span></span>)</code> </pre><br><br>  Add here the possibility of defining methods and redefining them, and we get a real prototype object orientation. <br><br><h4>  The first steps </h4><br>  Of course, in practice, everything is not the same as in theory, many things cannot be realized in Vim because of the peculiarities of the language; something had to be abandoned due to its high bulkiness, and as a result I received the following: <br><pre> <code class="bash hljs">Use D/base/Object <span class="hljs-string"><span class="hljs-string">"   A     Object let A = Object.expand('A', {'x': 1}) "</span></span>    A  . <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! A.new(x) dict <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj = self._construct() call obj.set(<span class="hljs-string"><span class="hljs-string">'x'</span></span>, a:x) <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> obj endfunction <span class="hljs-string"><span class="hljs-string">"   B    A let B = A.expand('B', {'y': Object}) "</span></span>    B   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! B.new(x, y) dict <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj = self._construct() <span class="hljs-string"><span class="hljs-string">" ,      call obj.set('x', a:x) call obj.set('y', a:y) return obj endfunction "</span></span>   <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:a = A.new(2) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:b = B.new(3, s:a) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:b.get(<span class="hljs-string"><span class="hljs-string">'x'</span></span>) <span class="hljs-string"><span class="hljs-string">"       Object,       echo s:b.get('y') "</span></span>         <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:b.get(<span class="hljs-string"><span class="hljs-string">'y'</span></span>).instancedown(<span class="hljs-string"><span class="hljs-string">'A'</span></span>).get(<span class="hljs-string"><span class="hljs-string">'x'</span></span>)</code> </pre><br><br>  The case began with the following idea: you need to divide all objects into two types, those that represent classes and contain information about the structure of their instances and special methods, such as inheritance and constructor, and those that represent objects.  I liked the idea and started to implement it, and I started with the Object base class and the two main methods expand and _construct: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> Object = {<span class="hljs-string"><span class="hljs-string">'class'</span></span>: <span class="hljs-string"><span class="hljs-string">'Object'</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! Object.expand(className, properties) dict endfunction <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! Object._construct() dict endfunction</code> </pre><br><br>  Due to the fact that objects in Vim do not have names, it was necessary to somehow store the name of the class in order to be able to typify their properties with these classes.  For this, the class property has been added, which stores the name of the class, and for one it distinguishes the associative arrays of Vim from my classes (if this property is present, it means we are dealing with a class or its instance).  The expand method takes two parameters, the name of the new class and its properties, and returns an object representing the new class created from the class being called (that is, the prototype).  The _construct method simply creates an object of the called class and returns it. <br><br>  Let's start with the first method.  Its algorithm is quite simple: create a new object, add a class property to it with the value passed in the first parameter, so that the future class has a name;  add a reference to the parent class using the parent property;  for convenience, we create references in the current object to all methods of the parent class;  We supplement the resulting object with properties based on the second parameter.  The last step is the most important, the fact is that we do not just copy the properties from the parameter, but create the structure of the future class.  In particular, we define the type of property and its default value. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! Object.expand(className, properties) dict <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj = {<span class="hljs-string"><span class="hljs-string">'class'</span></span>: a:className} <span class="hljs-string"><span class="hljs-string">"  . "</span></span>           parent. <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj.parent = self <span class="hljs-string"><span class="hljs-string">"  . "</span></span>             . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> keys(self) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> t = <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(self[k]) <span class="hljs-string"><span class="hljs-string">"      if t == 2 let obj[k] = self[k] endif endfor "</span></span>  . <span class="hljs-string"><span class="hljs-string">"          . for k in keys(a:properties) "</span></span>          class  parent,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> k == <span class="hljs-string"><span class="hljs-string">'class'</span></span> || k == <span class="hljs-string"><span class="hljs-string">'parent'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span> endif <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> t = <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(a:properties[k]) <span class="hljs-string"><span class="hljs-string">"     ,     if t == 0 || t == 1 || t == 5 let obj[k] = {'value': a:properties[k], 'type': t} "</span></span>   ,     elseif t == 3 <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj[k] = {<span class="hljs-string"><span class="hljs-string">'value'</span></span>: deepcopy(a:properties[k]), <span class="hljs-string"><span class="hljs-string">'type'</span></span>: t} <span class="hljs-string"><span class="hljs-string">"   ,        elseif t == 4 "</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> has_key(a:properties[k], <span class="hljs-string"><span class="hljs-string">'class'</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj[k] = {<span class="hljs-string"><span class="hljs-string">'value'</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'type'</span></span>: a:properties[k].class} <span class="hljs-string"><span class="hljs-string">"     elseif let obj[k] = {'value': a:properties[k], 'type': 4} endif endif endfor return obj endfunction</span></span></code> </pre><br><br>  Thanks to the link to the parent class, we don‚Äôt need to copy all of its properties to the child class, and the lack of the parent property indicates that this is the root class Object. <br><br>  Now let's talk about the constructor.  The _construct method creates and returns an object based on a class by copying the property values ‚Äã‚Äãof the class into an object.  Copying methods does not make sense, since they are the same for all objects, therefore, for convenience, we will add only references from objects to class methods: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! Object._construct() dict <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj = {} <span class="hljs-string"><span class="hljs-string">"     let obj.class = self if has_key(self, 'parent') "</span></span>            <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj.parent = self.parent._construct() <span class="hljs-string"><span class="hljs-string">"       ,       let obj.parent.child = obj endif for property in keys(self) let type = type(self[property]) "</span></span>          ,     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> == 2 &amp;&amp; property != <span class="hljs-string"><span class="hljs-string">'expand'</span></span> &amp;&amp; property != <span class="hljs-string"><span class="hljs-string">'_construct'</span></span> &amp;&amp; property != <span class="hljs-string"><span class="hljs-string">'new'</span></span> <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj[property] = self[property] <span class="hljs-string"><span class="hljs-string">"    elseif type == 4 &amp;&amp; has_key(self[property], 'type') let propertyType = self[property].type if propertyType == 0 || propertyType == 1 || propertyType == 5 let obj[property] = self[property].value elseif propertyType == 3 let obj[property] = deepcopy(self[property].value) elseif propertyType == 4 if has_key(self[property].value, 'class') let obj[property] = self[property].value._construct() else let obj[property] = deepcopy(self[property].value) endif endif endif endfor return obj endfunction</span></span></code> </pre><br><br>  Notice how the object is built according to the inheritance hierarchy.  For each class, a separate object (subobject) is created, after which they are all glued into one object by reference.  This allows you to regress objects when you write an object to a property with the type of the parent class, and also makes the process of creating an object more elegant (copy all the properties of all classes to an object? Fuu!) <br>  Some properties of prototypes are already manifest, namely: everything is an object;  objects are implemented by copying properties to other objects.  In other words, prototype object orientation is the simplest approach to implementing objects in programming languages. <br><br><h4>  Expanding </h4><br>  In essence, the methods described are the foundation of the entire implementation.  Next you just need to add some additional methods for convenience, namely: <br><ol><li>  new - constructor with parameters; </li><li>  get - getting the property value; </li><li>  set - setting the value of the property with type checking; </li><li>  has - whether the object has the specified property with regard to the inheritance hierarchy; </li><li>  instanceup - getting the subobject up the inheritance hierarchy (regression); </li><li>  instancedown - getting a subobject down the inheritance hierarchy (progression); </li><li>  instanceof - whether the object belongs to the specified class or its subclasses. </li></ol><br><br>  Before describing the implementation of these methods (I think you yourself already know how to implement them), let me show you how to work with them: <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">let</span></span> A = Object.expand(<span class="hljs-string"><span class="hljs-string">'A'</span></span>, {<span class="hljs-string"><span class="hljs-string">'a'</span></span>: 1}) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> B = Object.expand(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, {<span class="hljs-string"><span class="hljs-string">'b'</span></span>: A}) <span class="hljs-string"><span class="hljs-string">''</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! B.new(b) dict <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> obj = self._construct() obj.set(<span class="hljs-string"><span class="hljs-string">'b'</span></span>, b) <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> obj endfunction <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:a = A.new() call s:a.set(<span class="hljs-string"><span class="hljs-string">'a'</span></span>, 2) <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:b = B.new(s:a) <span class="hljs-string"><span class="hljs-string">''</span></span>   ,     <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:b.class.class <span class="hljs-string"><span class="hljs-string">''</span></span> B <span class="hljs-string"><span class="hljs-string">''</span></span>   ,      b <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:b.get(<span class="hljs-string"><span class="hljs-string">'b'</span></span>).class.class <span class="hljs-string"><span class="hljs-string">''</span></span> A <span class="hljs-string"><span class="hljs-string">''</span></span>    b   B.  ,    B       A.     call s:b.set(<span class="hljs-string"><span class="hljs-string">'b'</span></span>, s:b) <span class="hljs-string"><span class="hljs-string">''</span></span>   ,     A <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:b.get(<span class="hljs-string"><span class="hljs-string">'b'</span></span>).class.class <span class="hljs-string"><span class="hljs-string">''</span></span> A <span class="hljs-string"><span class="hljs-string">''</span></span>    s:a,     a   2 (   ),  1 (   s:b) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:b.get(<span class="hljs-string"><span class="hljs-string">'b'</span></span>).get(<span class="hljs-string"><span class="hljs-string">'a'</span></span>) <span class="hljs-string"><span class="hljs-string">''</span></span> 1 <span class="hljs-string"><span class="hljs-string">''</span></span>  ,      b ,       B <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:b.get(<span class="hljs-string"><span class="hljs-string">'b'</span></span>).instancedown(<span class="hljs-string"><span class="hljs-string">'B'</span></span>).class.class <span class="hljs-string"><span class="hljs-string">''</span></span> B</code> </pre><br><br>  Interesting, isn't it?  I will not give detailed listings of the methods, they are on GitHub with detailed comments, I will describe only the algorithms of each method: <br><ol><li>  new - why extra constructor?  The fact is that when redefining the standard constructor, the called class will not trigger the mechanism of copying the level properties of this class, but we do not need it; </li><li>  get - nowhere is easier, if the property is present in this object or subobjects higher in the inheritance hierarchy, we return, otherwise we report an error; </li><li>  set is also nothing complicated, check the type and write to the current object or subobjects.  It is only important to identify the objects of our classes and regress if necessary; </li><li>  has is also pretty simple, look for the property in the current object and subobjects; </li><li>  Instanceup - go up the hierarchy of subobjects using the parent property and check the class name with the requested one, if found, return the object; </li><li>  instancedown - similar to the previous one, just use the child property; </li><li>  instanceof - cause instanceup and if an object is returned, then return true. </li></ol><br><br><h4>  Use and namespace </h4><br>  Unfortunately, for the time being we have failed to implement an intelligent namespace  I tried by analogy with the namespace in YUI 3, but it turned out not very nice.  Use implemented quite simply: <br><pre> <code class="bash hljs">comm! -nargs=1 Use so <span class="hljs-variable"><span class="hljs-variable">$HOME</span></span>/.vim/ftplugin/vim/&lt;args&gt;.vim</code> </pre><br><br>  We define the Use command, which includes the .vim / ftplugin / vim / File.vim file address, with each class located in a separate file, that is: <br><pre> <code class="bash hljs">Use D/base/Object</code> </pre><br>  This is an Object.vim file located in the .vim / ftplugin / vim / D / base directory. <br>  Usage example <br><br>  In order to test the resulting base class, implemented the Stack class, which represents sets with the Stack access type.  Below is an example of use: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> exists(<span class="hljs-string"><span class="hljs-string">'Stack'</span></span>) finish endif Use D/base/Object <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> Stack = Object.expand(<span class="hljs-string"><span class="hljs-string">'Stack'</span></span>, {<span class="hljs-string"><span class="hljs-string">'_val'</span></span>: [], <span class="hljs-string"><span class="hljs-string">'_index'</span></span>: 0}) <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! Stack.push(el) dict ‚Ä¶ endfunction <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! Stack.pop() dict ‚Ä¶ endfunction <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>! Stack.length() dict ‚Ä¶ endfunction <span class="hljs-built_in"><span class="hljs-built_in">let</span></span> s:stack = Stack.new() call s:stack.push(1) call s:stack.push(2) call s:stack.push(3) <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:stack.length() <span class="hljs-string"><span class="hljs-string">''</span></span> 3 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:stack.pop() <span class="hljs-string"><span class="hljs-string">''</span></span> 3 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:stack.pop() <span class="hljs-string"><span class="hljs-string">''</span></span> 2 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:stack.pop() <span class="hljs-string"><span class="hljs-string">''</span></span> 1 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> s:stack.pop() <span class="hljs-string"><span class="hljs-string">''</span></span> ERROR</code> </pre><br><br>  In my opinion quite nice, and most importantly functional.  Full (hopefully) object orientation based on prototypes in Vim, weighing only 4 kilos. <br><br><h4>  References and resources </h4><br><ol><li>  <a href="https://github.com/Bashka/DVim">GitHub project</a> </li><li>  <a href="http://rus-linux.net/MyLDP/BOOKS/Vim/prosto-o-vim.pdf">The book "Just about Vim"</a> </li><li>  <a href="http://jenyay.net/Programming/VimScript1">About creating scripts in Vim clearly and with examples</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/210930/">https://habr.com/ru/post/210930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210918/index.html">DevCon 2014 Conference - What Can We Tell Now</a></li>
<li><a href="../210920/index.html">Stored functions. Pros and cons</a></li>
<li><a href="../210922/index.html">The new head of Microsoft will be Satya Nadella</a></li>
<li><a href="../210924/index.html">North Korean Red Star OS goes to Macs</a></li>
<li><a href="../210926/index.html">Development for Android in NetBeans IDE without plug-ins. Part 2</a></li>
<li><a href="../210932/index.html">ODR - On-Demand Routing</a></li>
<li><a href="../210934/index.html">Data migration between different e-commerce engines</a></li>
<li><a href="../210936/index.html">Is it necessary to make a client a friend, and a friend a client?</a></li>
<li><a href="../210938/index.html">Dislocker Or find a common language with BitLocker in Linux Mint</a></li>
<li><a href="../210942/index.html">How I invent a method of simulating annealing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>