<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming "for the soul"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Full, pigeon, sin not! 
 Take away your pennies. 
 I'm not for money. 
 I'm after all this for the soul. 

 Leonid Filatov " The Tale of Fedot-Archer,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming "for the soul"</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/87b/46b/0cb/87b46b0cb8c89f77895c30c6b47da5e8.png">  <i><b>Full, pigeon, sin not!</b></i> <i><b><br></b></i>  <i><b>Take away your pennies.</b></i> <i><b><br></b></i>  <i><b>I'm not for money.</b></i> <i><b><br></b></i>  <i><b>I'm after all this for the soul.</b></i> <i><b><br><br></b></i>  <i><b>Leonid Filatov " <a href="http://lyakhov.kz/library/filatov/fedot.shtml">The Tale of Fedot-Archer, Daring Fellow</a> "</b></i> <i><b><br><br></b></i>  <i><b>Just for Fun.</b></i> <i><b>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </b></i>  <i><b>Linus torvalds</b></i> <br><br>  It's no secret that people enjoy themselves in different ways.  One likes to watch TV, others collect quadrocopters.  I want to share my recipe.  It is unlikely that it will be useful to everyone, but perhaps someone will be interested.  I like to write programs (and I think that this is not uncommon, even among professional programmers), but I don‚Äôt really like it when this process turns into a dull routine. <br><br>  To be interesting, programming has to be a kind of ‚Äúcharge for the mind‚Äù.  A well-known example of such (useful) entertainment is a well-known <a href="http://www.sql-ex.ru/">resource</a> dedicated to improving SQL query writing skills.  But not a single programmer alive in SQL!  Recently, I have found a great way to improve my <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D1%2582_(%25D1%258F%25D0%25B7%25D1%258B%25D0%25BA_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Fort</a> skills.  <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom</a> allows you to program on the Forte ad libitum! <br><br>  My recipe for getting fun with Axiom is simple: <br><br><ol><li>  Choose <a href="http://www.iggamecenter.com/info/en/rules.html">any</a> game, with the rules of pozakovyristee, from among those not yet implemented ZoG-community </li><li>  We are trying to bring it to life, using Axiom </li><li>  We <b>enjoy</b> in the process of solving the problems arising in this case. </li><li>  In the event that it is interesting to play the resulting application, Fun produced automatically doubles! </li></ol><br><a name="habracut"></a><br>  With the implementation of the first paragraph of this plan, I usually help the Internet.  This time, I chose <a href="http://www.toco.be/splut/">Splut!</a> As the object for my inhuman experiments <a href="http://www.toco.be/splut/">.</a>  .  Here is its <a href="http://www.iggamecenter.com/info/en/splut.html">description</a> on the IG Game Center.  Without going into the retelling of the rules, I will try to explain how this game attracted me: <br><br><ul><li>  It is played by more than two players (which is, to a certain extent, a challenge for AI algorithms) </li><li>  A player's move involves the sequential movement of several (from 1 to 3) pieces. </li><li>  The moves leading to the winnings are not straightforward (you can‚Äôt just take a piece and eat it, you need to complete a sequence of moves united by one goal) </li><li>  The rules of this game are very thoughtful and very original. </li></ul><br><div class="spoiler">  <b class="spoiler_title">Remark</b> <div class="spoiler_text">  Here is what the author writes about the rights to his game: <br><br><blockquote>  The SPLUT game idea and design are copyrighted.  It is not a good idea to have a tommy de coninck. </blockquote><br>  Since I'm not going to use the idea or design of the game for commercial purposes, this item is fine. <br></div></div><br><h4>  Exposure Magic </h4><br>  Let's get down to making fun.  Let's start with the simple - with the moves of the Troll.  The usual course of the figure is no difficulty.  Its implementation is obvious and well suited to explain the concepts of Axiom: <br><br><div class="spoiler">  <b class="spoiler_title">Quiet running</b> <div class="spoiler_text"><pre><code class="hljs tex">: one-step ( 'dir -- ) EXECUTE verify <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>  empty? verify <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>? from <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>   here <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span> move <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span> add-move <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>  ;</code> </pre> <br></div></div><br>  Just want to advise, pay attention to the comments (in parentheses).  They will help not to get confused in what is happening on the stack (this is really important in Forte).  Also worth paying attention to the spaces.  A space, <b>not</b> set, in a bad place, can make you spend a lot of time. <br><br>  By the code itself, I think everything is clear.  We perform the transition in the direction (taken from the stack), using the <b>EXECUTE</b> command, and then we check the boolean result of the transition (if not <b>TRUE</b> , we finish the calculation of the course).  Then, we check that the target cell is empty, after which we move the shape.  The <b>move</b> command that performs the move takes two values ‚Äã‚Äãfrom the stack ‚Äî the starting point ( <b>from</b> ) and the position we are in after moving ( <b>here</b> ).  The <b>add-move</b> command completes the formation of a move. <br><br>  A little more complicated move, with the movement of the stone: <br><br><div class="spoiler">  <b class="spoiler_title">Stone dragging</b> <div class="spoiler_text"><pre> <code class="hljs mel">: <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span> ( <span class="hljs-string"><span class="hljs-string">'dir '</span></span>opposite -- ) EXECUTE verify \   is-stone? verify \  ? piece-type \   SWAP here SWAP \   DUP EXECUTE DROP EXECUTE verify \     empty? verify \ ? from \    here \  <span class="hljs-keyword"><span class="hljs-keyword">move</span></span> \   capture-at \    ,   from create-piece-type-at \    ,    add-<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> \  ! ; : <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span>-to-north ( -- ) [<span class="hljs-string"><span class="hljs-string">'] north ['</span></span>] south <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span> ; : <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span>-to-south ( -- ) [<span class="hljs-string"><span class="hljs-string">'] south ['</span></span>] north <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span> ; : <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span>-to-east ( -- ) [<span class="hljs-string"><span class="hljs-string">'] east ['</span></span>] west <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span> ; : <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span>-to-west ( -- ) [<span class="hljs-string"><span class="hljs-string">'] west ['</span></span>] east <span class="hljs-keyword"><span class="hljs-keyword">drag</span></span> ;</code> </pre><br></div></div><br>  Here we put two directions on the stack at once - the direction of movement and the opposite to it.  The code itself looks more complicated due to stack manipulations, but you can get used to this.  It is very important that all ‚Äúside‚Äù actions for capturing or creating shapes should be performed <b>after</b> moving the main shape.  It is also important to remember that and in what order is on the stack after each command.  A detailed description of the teams themselves can always be found in the Axiom manual. <br><br>  At one point, however, it is worth staying particularly.  The check that the figure in the current cell is a stone is performed by the <b>is-stone</b> predicate <b>?</b>  .  Of course, this is not the built-in Axiom function, but ours.  Here is how its implementation looks like: <br><br><div class="spoiler">  <b class="spoiler_title">A rock?</b> <div class="spoiler_text"><pre> <code class="hljs delphi">DEFER SSTONE DEFER NSTONE DEFER WSTONE DEFER ESTONE : <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>-stone? ( -- ? ) piece-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> SSTONE = piece-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NSTONE = <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> piece-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> WSTONE = <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> piece-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ESTONE = <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> ; ... <span class="hljs-comment"><span class="hljs-comment">{pieces {piece}</span></span> lock <span class="hljs-comment"><span class="hljs-comment">{moves}</span></span> pass-moves <span class="hljs-comment"><span class="hljs-comment">{piece}</span></span> sstone <span class="hljs-comment"><span class="hljs-comment">{drops}</span></span> stone-drops <span class="hljs-comment"><span class="hljs-comment">{piece}</span></span> nstone <span class="hljs-comment"><span class="hljs-comment">{drops}</span></span> stone-drops <span class="hljs-comment"><span class="hljs-comment">{piece}</span></span> wstone <span class="hljs-comment"><span class="hljs-comment">{drops}</span></span> stone-drops <span class="hljs-comment"><span class="hljs-comment">{piece}</span></span> estone <span class="hljs-comment"><span class="hljs-comment">{drops}</span></span> stone-drops <span class="hljs-comment"><span class="hljs-comment">{piece}</span></span> wizard <span class="hljs-comment"><span class="hljs-comment">{moves}</span></span> wizard-moves <span class="hljs-comment"><span class="hljs-comment">{piece}</span></span> dwarf <span class="hljs-comment"><span class="hljs-comment">{moves}</span></span> dwarf-moves <span class="hljs-comment"><span class="hljs-comment">{piece}</span></span> troll <span class="hljs-comment"><span class="hljs-comment">{moves}</span></span> troll-moves pieces} <span class="hljs-string"><span class="hljs-string">' sstone IS SSTONE '</span></span> nstone <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> NSTONE <span class="hljs-string"><span class="hljs-string">' wstone IS WSTONE '</span></span> estone <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> ESTONE</code> </pre><br></div></div><br>  Remember, in the last <a href="http://habrahabr.ru/post/226235/">article</a> , I complained that it was not possible to use the names of objects (in this case, figures) before they were defined?  <b>DEFER</b> allows <b>you</b> to cope with this problem.  The only bad thing is that this important pattern is not described in the Axiom documentation. <br><br>  But why do we have four types of stone?  Couldn't one do without one?  Alas, the rules of Splut!  arranged in such a way that we can not do without the "individuality" of stones.  I will show later what it is for. <br><br>  Now the Troll can move and (optionally) carry the Stone along, but it seems that we have forgotten something.  The fact is that the only way to natural loss of figures in Splut!  due to the fact that the Trolls will throw stones at them!  Add the missing functionality, putting the code together: <br><br><div class="spoiler">  <b class="spoiler_title">Troll moves</b> <div class="spoiler_text"><pre> <code class="hljs dos">DEFER CONTINUE-<span class="hljs-built_in"><span class="hljs-built_in">TYPE</span></span> : one-step ( '<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> -- ) check-continue? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> EXECUTE <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> empty? <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> from here <span class="hljs-built_in"><span class="hljs-built_in">move</span></span> add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP ENDIF ; : step-to-north ( -- ) ['] north one-step ; : step-to-south ( -- ) ['] south one-step ; : step-to-east ( -- ) ['] east one-step ; : step-to-west ( -- ) ['] west one-step ; : drag ( '<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> 'opposite -- ) check-continue? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> EXECUTE <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> is-stone? <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> SWAP here SWAP DUP EXECUTE DROP EXECUTE <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> empty? <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> from here <span class="hljs-built_in"><span class="hljs-built_in">move</span></span> capture-<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> DUP lock-stone from create-piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">at</span></span> add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP DROP ENDIF ; : drag-to-north ( -- ) ['] north ['] south drag ; : drag-to-south ( -- ) ['] south ['] north drag ; : drag-to-east ( -- ) ['] east ['] west drag ; : drag-to-west ( -- ) ['] west ['] east drag ; : take-stone ( '<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> -- ) check-continue? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> EXECUTE <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> is-stone? <span class="hljs-built_in"><span class="hljs-built_in">verify</span></span> CONTINUE-<span class="hljs-built_in"><span class="hljs-built_in">TYPE</span></span> partial-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> from here <span class="hljs-built_in"><span class="hljs-built_in">move</span></span> add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP ENDIF ; : take-to-north ( -- ) ['] north take-stone ; : take-to-south ( -- ) ['] south take-stone ; : take-to-east ( -- ) ['] east take-stone ; : take-to-west ( -- ) ['] west take-stone ; : drop-stone ( 'opposite '<span class="hljs-built_in"><span class="hljs-built_in">dir</span></span> -- ) check-edge? check-wizard? OR on-board? AND <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> check-troll? piece-is-<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-present? AND <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> player piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> drop WIZARD = <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> drop-team <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP ENDIF lock-continue current-piece-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> lock-stone add-<span class="hljs-built_in"><span class="hljs-built_in">move</span></span> ENDIF ENDIF ; : drop-to-north ( -- ) ['] north ['] south drop-stone ; : drop-to-south ( -- ) ['] south ['] north drop-stone ; : drop-to-east ( -- ) ['] east ['] west drop-stone ; : drop-to-west ( -- ) ['] west ['] east drop-stone ; {moves troll-moves {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} step-to-north {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} step-to-south {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} step-to-east {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} step-to-west {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} drag-to-north {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} drag-to-south {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} drag-to-east {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} drag-to-west {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} take-to-north {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} take-to-south {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} take-to-east {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} take-to-west {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} normal-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> moves} {moves stone-drops {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} drop-to-north {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} continue-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} drop-to-south {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} continue-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} drop-to-east {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} continue-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>} drop-to-west {<span class="hljs-built_in"><span class="hljs-built_in">move</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span>} continue-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> moves} ' continue-<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> IS CONTINUE-<span class="hljs-built_in"><span class="hljs-built_in">TYPE</span></span></code> </pre><br></div></div><br>  I will not describe auxiliary functions.  Their implementation can be found <a href="">here</a> .  I will stop only on throws.  A troll can take a stone with a <b>take-stone</b> move (the implementation of this function is trivial), after which the <b>partial-move-type</b> command enables the move to continue, with the specified type ( <b>continue-type</b> ).  Under this type, the only type of move registered is a throw ( <b>drop</b> ) of a stone on the board. <br><br>  You can not throw anyhow, but in strictly defined places!  According to the rules, the stone flies from the Troll in a straight line (vertical or horizontal), flying over the head of the Dwarfs, to an obstacle (Mage, edge of the board or another Troll).  The magician knocks down immediately, in other cases, falls to the board.  If there was a Gnome in this place - he simply had no luck.  This is a difficult rule to implement and it will be more convenient to bring it to life, starting from the other end.  We will search for the fields bordering on the obstacle and move away from them, in the opposite direction, along empty cells or cells occupied by Dwarves.  If we meet our Troll on the way, it means that you can throw a stone at the place where we started to move. <br><br>  In addition, the code implements the associated rules.  For example, the fact that when you kill a magician, his entire team is removed from the field, and also that after throwing a stone, the move immediately passes to another player.  I will not dwell on this in detail. <br><br>  A slightly different puzzle is the special move of the Gnome.  A dwarf, under its own power, can move any number of figures (including Stones) in front of it in a row.  In order to store all these figures, we obviously need a stack.  For everything else, you can use variables: <br><br><div class="spoiler">  <b class="spoiler_title">Gnome's move</b> <div class="spoiler_text"><pre> <code class="hljs delphi">VARIABLE <span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> VARIABLE backward VARIABLE step-count VARIABLE here-pos : push-step ( <span class="hljs-string"><span class="hljs-string">'opposite '</span></span>dir -- ) check-<span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> step-count ! <span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> ! backward ! <span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> @ EXECUTE verify <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-empty? verify step-count ++ player piece-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> here here-pos ! <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">forward</span></span> @ EXECUTE <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> empty? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> TRUE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> step-count ++ player piece-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> FALSE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> step-count @ <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> step-count -- DROP DROP FALSE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> TRUE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">UNTIL</span></span> TRUE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">UNTIL</span></span> step-count @ <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; verify from here-pos @ move <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> step-count @ <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> step-count -- DUP <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>-stone-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP lock-stone ENDIF create-player-piece-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> backward @ EXECUTE DROP FALSE <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> TRUE ENDIF <span class="hljs-keyword"><span class="hljs-keyword">UNTIL</span></span> add-move <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP DROP ENDIF ;</code> </pre><br></div></div><br>  Yes, it is more difficult to understand this than in the previous code, but the essence of the action performed is simple.  We move in one direction, putting the pieces on the stack, to an empty cell, and then return, recreating them on the board, shifted by one step (since there can be no more than one piece on one cell, you can not take care of deleting the figures - ZoG will remove them independently).  Try to understand how this code works, this is a good ‚Äúmind gymnastics‚Äù. <br><br>  Of course, Mages would not be Mages if they didn‚Äôt give us the most trouble.  Mages can levitate stones.  Any, but ... under certain conditions.  For example, you cannot levitate a stone that moved (in any way) on a previous turn.  Here the question immediately arises: what is considered the previous move?  Unfortunately, the rules do not decipher this moment.  In my code, I implemented the clearing of signs of moving stones (this is where individuality is needed, each stone has its own flag) immediately before passing the turn to the first player.  Of course, this gives him a significant advantage (he can move any Stones, and the following players are only those that he did not move), but other possible implementations of this rule are also not perfect. <br><br><div class="spoiler">  <b class="spoiler_title">Levitating Stones</b> <div class="spoiler_text"><pre> <code class="hljs cmake">: fly-stone ( 'dir -- ) check-<span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP EXECUTE empty? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> a5 to BEGIN is-stone? <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-locked? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here here-pos ! DUP piece-type SWAP EXECUTE SWAP can-fly? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> from to DUP EXECUTE DROP from here move here-pos @ to DUP piece-type SWAP capture EXECUTE DROP DUP lock-stone DUP begin-fly create-piece-type add-move <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> here-pos @ to <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> DUP next <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> UNTIL <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ;</code> </pre><br></div></div><br>  It is easy to make a mistake here, considering that we have implemented everything you need.  But not all features are realized!  Can the Magician move to the cell occupied by the Stone, if there is an empty cell next to the Stone?  The rules of the game say that yes, and the code considers otherwise.  In fact, the magician can also "push" the stones in front of him.  This is just a type of levitation! <br><br><div class="spoiler">  <b class="spoiler_title">Pushing the stones in front of you</b> <div class="spoiler_text"><pre> <code class="hljs cmake">: push-stone ( 'dir -- ) check-<span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP EXECUTE is-stone? <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-locked? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> piece-type can-fly-lock? <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> here SWAP piece-type SWAP EXECUTE empty? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> SWAP from SWAP move DUP lock-stone DUP begin-fly create-piece-type add-move <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP DROP DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> ;</code> </pre><br></div></div><br>  This code is simpler because you don‚Äôt have to search for Stones around the field  If we want to get on the field occupied by the Stone, then the only Stone that can be levitated is it. <br><br><h4>  A and B were sitting on the pipe </h4><br>  As I said above, the implementation of AI, for games with more than two players, is associated with some difficulties.  Problems begin when determining the condition of the completion of the game.  For example, in the recently developed game <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2273">Yonin Shogi</a> (a variant of Japanese chess for 4 people) developed by me, it would be tempting to define the defeat condition as follows: <br><br><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">loss-condition</span></span> (<span class="hljs-name"><span class="hljs-name">South</span></span> North West East) (<span class="hljs-name"><span class="hljs-name">checkmated</span></span> King))</code> </pre><br>  This record means that the game must be played before the mat to the King of any player.  Alas, this approach does not work!  I already <a href="http://habrahabr.ru/post/221779/">wrote</a> that the <b>checkmated</b> command carries too much ‚Äúmagic‚Äù.  In particular, she determines that the King must always leave the check (and never stand under the check).  In general, it works ... as long as two players participate in the game.  The video illustrates the problem: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/OR74gUlfQNY%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700191,15700253&amp;usg=ALkJrhgoymLwRkli9mAkfipXy-Q_z5ZVbA" frameborder="0" allowfullscreen=""></iframe><br><br>  As you can see, <b>checkmated</b> works fine for only one of 4 players.  For the rest of the players, protection from the shah is not considered a mandatory move!  Of course, in the next move, such a king <b>may be</b> eaten, but this fact only aggravates the situation.  Anyway, a normal mat in this game will not be able to deliver. <br><br>  In Splut!  the situation is even worse.  The game must be played until only one team remains on the board.  But ZoG does not allow you to change the order of turns during the game!  This means that each retired team must make its move when it comes to its turn (of course, it will fold, since there is no other way to make a move).  Also in Splut!  Each team makes several moves in a row (1-2 at the beginning of the game and 3 in the middle of the game).  In general, it did not come as a surprise to me that the staff AI Axiom did not cope with this game. <br><br>  Of course, it works, the program makes moves (rather stupid in my opinion), but after one of the players is eliminated, problems begin.  When calculating each skip move, the program begins to "think" longer and longer, not fitting into any of the specified time frames.  The addition of its evaluation function ( <b>OnEvaluate</b> ) does not fix the situation.  In general, I considered this to be a sufficient reason to try to implement my own AI algorithm, since there is such an opportunity in Axiom (looking ahead, I‚Äôll say that it wasn‚Äôt very good, but it was worth trying). <br><br>  I took as a basis the following algorithm known to many from the book ‚ÄúProgramming Chess and Other Logic Games‚Äù by Evgeny Kornilov: <br><br><div class="spoiler">  <b class="spoiler_title">Alpha-Beta bounce cuts</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AlphaBeta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> color, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Depth, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beta)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Depth == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Evaluate(color); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> score = -INFINITY; PMove move = GenerateAllMoves(color); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (move) { MakeMove(move); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp = -AlphaBeta(color==WHITE?BLACK:WHITE, Depth - <span class="hljs-number"><span class="hljs-number">1</span></span>, -beta, -alpha); UnMakeMove(move); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmp &gt; score) score = tmp; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (score &gt; alpha) alpha = score; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (alpha &gt;= beta) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> alpha; move = move -&gt; next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> score; }</code> </pre><br></div></div><br>  As is easy to see, in its original form, this algorithm does not suit us at all.  We have more than two players, and with the alternation of moves everything is much more complicated.  But this algorithm is a good starting point for developing your own version. <br><br>  Thinking a little, you can understand that in the worst case, the three players who are opposed to the one for which we are counting the move will combine their efforts.  In other words, for us this is <b>one</b> hostile player (if they do not unite, so much the worse for them).  Another important point is the calculation of the evaluation function.  When calculating a move, the evaluation function should always be calculated ‚Äúfrom the point of view‚Äù of the same player (the one for which the turn is calculated).  For hostile players, the score must be taken with the opposite sign (the better for us, the worse for them).  Taking these considerations into account, you can rewrite the algorithm as follows: <br><br><div class="spoiler">  <b class="spoiler_title">Generalized Alpha-Beta Clipping</b> <div class="spoiler_text"><pre> <code class="hljs php">VARIABLE Depth MaxDepth [] CurrMove[] MaxDepth [] CurrTurn[] MaxDepth [] CurrScore[] : Score ( alpha beta turn -- score ) Depth -- Depth @ <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> EvalCount ++ SWAP DROP SWAP DROP <span class="hljs-keyword"><span class="hljs-keyword">Eval</span></span> SWAP turn-offset-to-player current-player &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> NEGATE <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DUP turn-offset-to-player <span class="hljs-keyword"><span class="hljs-keyword">FALSE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> $GenerateMoves Depth @ CurrTurn[] ! $FirstMove Depth @ CurrMove[] ! <span class="hljs-number"><span class="hljs-number">-10000</span></span> Depth @ CurrScore[] ! BEGIN $CloneBoard Depth @ CurrMove[] @ .moveCFA EXECUTE <span class="hljs-number"><span class="hljs-number">2</span></span>DUP Depth @ CurrTurn[] @ next-turn-offset RECURSE $DeallocateBoard $Yield DUP Depth @ CurrScore[] @ &gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> Depth @ CurrScore[] ! <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> Depth @ CurrTurn[] @ turn-offset-to-player current-player &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> NEGATE SWAP NEGATE <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> OVER Depth @ CurrScore[] @ &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> SWAP DROP Depth @ CurrScore[] @ SWAP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>DUP &gt;= <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> OVER Depth @ CurrScore[] ! <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> Depth @ CurrTurn[] @ turn-offset-to-player current-player &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> NEGATE SWAP NEGATE <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> Depth @ CurrMove[] @ $NextMove DUP Depth @ CurrMove[] ! NOT <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> UNTIL $DeallocateMoves DROP DROP Depth @ CurrScore[] @ Depth @ CurrTurn[] @ turn-offset-to-player current-player &lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> NEGATE <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> Depth ++ ;</code> </pre><br></div></div><br>  There are a lot of ‚Äúmagic‚Äù of the Fort and Axioms associated with the generation of moves and positions, but, with a certain voltage, the original algorithm is quite visible.  To unload the stack, we had to emulate several stacks with variables used in recursive calls.  On the stack itself, in the process of computing, there are only two <b>alpha</b> and <b>beta</b> values.  In recursive calls ( <b>RECURSE</b> ), they are always transmitted in the same order, but if the calculation is performed for a hostile player, we change their sign, then, change these values ‚Äã‚Äãin places.  We also change the mark of the assessment obtained in assessing the position of a hostile player. <br><br>  This function is called from the Custom Engine implementation already familiar to us, according to the previous article: <br><br><div class="spoiler">  <b class="spoiler_title">Custom engine</b> <div class="spoiler_text"><pre> <code class="hljs php"><span class="hljs-number"><span class="hljs-number">3</span></span> CONSTANT MaxDepth VARIABLE BestScore VARIABLE Nodes : Custom-Engine ( -- ) <span class="hljs-number"><span class="hljs-number">-10000</span></span> BestScore ! <span class="hljs-number"><span class="hljs-number">0</span></span> Nodes ! $FirstMove BEGIN $CloneBoard DUP $MoveString CurrentMove! DUP .moveCFA EXECUTE MaxDepth Depth ! <span class="hljs-number"><span class="hljs-number">0</span></span> EvalCount ! BestScore @ <span class="hljs-number"><span class="hljs-number">10000</span></span> turn-offset next-turn-offset Score <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> $RAND-WITHIN + BestScore @ OVER &lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> DUP BestScore ! Score! <span class="hljs-number"><span class="hljs-number">0</span></span> Depth! DUP $MoveString BestMove! <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> DROP <span class="hljs-keyword"><span class="hljs-keyword">ENDIF</span></span> $DeallocateBoard Nodes ++ Nodes @ Nodes! $Yield $NextMove DUP NOT UNTIL DROP ;</code> </pre><br></div></div><br>  It can be noted that in this code we add a random number from 1 to 5 to the value of the evaluation. This is done so that the program does not always go the same way when the scores of the moves differ slightly. <br><br>  As usual, the main difficulty lies in the construction of the evaluation function.  I will not download the article by listing the current version of it (anyone can always look at the code on <a href="">GitHub</a> ), I will only say that the following points are now taken into account in it: <br><br><ul><li>  The number of enemy Mages (our main goal is to reduce this value) </li><li>  The number of friendly Mages (if this value changes from 1 to 0, the game will end for us) </li><li>  The number of enemy Gnomes (it is always pleasant to tie the opponent's hands) </li><li>  The number of friendly Dwarfs (not that we could not do without him, but his figure still) </li><li>  The penalty for finding a friendly magician on the same line with the Stone (this is really dangerous) </li><li>  Bonuses for finding enemy Mages on the same lines with Stones (for the same reason) </li><li>  The total number of steps from the trolls to the stones (try to reduce for their own and increase for others) </li></ul><br>  This is certainly not ideal.  Weight values ‚Äã‚Äãshould be chosen more optimally, and the fact itself, for example, finding the Magician in one line with the Stone, in itself, does not mean anything.  The cast line can be blocked, for example, by the Troll, and even the stone must also be reached to throw it.  Anyway, we wrote the code and can see how it works: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/QSAjpj-j6KQ%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700191,15700253&amp;usg=ALkJrhjEk2l0STlJ80AmdWUp4Z00z4tzxw" frameborder="0" allowfullscreen=""></iframe><br><br>  As expected, AI does not shine with intelligence (and works terribly slowly), but at least tries to ‚Äúpass for clever‚Äù.  At least you can play it. <br><br><h4>  Counted - wept </h4><br>  Of course, to assess the quality of AI, you can play with it many times and build an ‚Äúexpert assessment‚Äù, but this is not our method.  Included with Axiom comes a great utility AutoPlay, allowing you to automate this process.  Unfortunately, she still does not know how to work with games designed for more than 2 players, but this is not a problem.  Especially for her, we will create a configuration with two players (we will leave 4 pieces of stones): <br><br><div class="spoiler">  <b class="spoiler_title">Duel</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">LOAD</span></span> <span class="hljs-type"><span class="hljs-type">Splut</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>th ( <span class="hljs-type"><span class="hljs-type">Load</span></span> the base <span class="hljs-type"><span class="hljs-type">Splut</span></span> game ) {players {player} <span class="hljs-type"><span class="hljs-type">South</span></span> {search-engine} <span class="hljs-type"><span class="hljs-type">Custom</span></span>-<span class="hljs-type"><span class="hljs-type">Engine</span></span> {neutral} <span class="hljs-type"><span class="hljs-type">West</span></span> {player} <span class="hljs-type"><span class="hljs-type">North</span></span> {search-engine} <span class="hljs-type"><span class="hljs-type">Custom</span></span>-<span class="hljs-type"><span class="hljs-type">Engine</span></span> {neutral} <span class="hljs-type"><span class="hljs-type">East</span></span> {player} ?<span class="hljs-type"><span class="hljs-type">Cleaner</span></span> {random} players} {turn-order {turn} <span class="hljs-type"><span class="hljs-type">South</span></span> {turn} <span class="hljs-type"><span class="hljs-type">North</span></span> {turn} <span class="hljs-type"><span class="hljs-type">North</span></span> {repeat} {turn} ?<span class="hljs-type"><span class="hljs-type">Cleaner</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">} clear-</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> turn-order} {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">board</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> sstone e1 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> wizard d2 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> dwarf e2 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> troll f2 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> lock f1 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">West</span></span></span><span class="hljs-class"> wstone a5 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> nstone e9 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> wizard f8 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> dwarf e8 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> troll d8 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> lock h1 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">East</span></span></span><span class="hljs-class"> estone i5 board-setup}</span></span></code> </pre><br></div></div><br>  Also, we need a configuration in which players make random moves: <br><br><div class="spoiler">  <b class="spoiler_title">Random</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">LOAD</span></span> <span class="hljs-type"><span class="hljs-type">Splut</span></span><span class="hljs-number"><span class="hljs-number">.4</span></span>th ( <span class="hljs-type"><span class="hljs-type">Load</span></span> the base <span class="hljs-type"><span class="hljs-type">Splut</span></span> game ) {players {player} <span class="hljs-type"><span class="hljs-type">South</span></span> {random} {neutral} <span class="hljs-type"><span class="hljs-type">West</span></span> {player} <span class="hljs-type"><span class="hljs-type">North</span></span> {random} {neutral} <span class="hljs-type"><span class="hljs-type">East</span></span> {player} ?<span class="hljs-type"><span class="hljs-type">Cleaner</span></span> {random} players} {turn-order {turn} <span class="hljs-type"><span class="hljs-type">South</span></span> {turn} <span class="hljs-type"><span class="hljs-type">North</span></span> {turn} <span class="hljs-type"><span class="hljs-type">North</span></span> {repeat} {turn} ?<span class="hljs-type"><span class="hljs-type">Cleaner</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">of</span></span>-<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">} clear-</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">turn</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> turn-order} {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">board</span></span></span><span class="hljs-class">-</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class"> {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> sstone e1 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> wizard d2 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> dwarf e2 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> troll f2 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">South</span></span></span><span class="hljs-class"> lock f1 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">West</span></span></span><span class="hljs-class"> wstone a5 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> nstone e9 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> wizard f8 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> dwarf e8 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> troll d8 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">North</span></span></span><span class="hljs-class"> lock h1 {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">setup</span></span></span><span class="hljs-class">} </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">East</span></span></span><span class="hljs-class"> estone i5 board-setup}</span></span></code> </pre><br></div></div><br>  The results were surprisingly good (although it took an entire night to calculate 100 batches): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Final</span></span> results: Player <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-string"><span class="hljs-string">"Random"</span></span>, wins = <span class="hljs-number"><span class="hljs-number">13</span></span>. Player <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-string"><span class="hljs-string">"Duel"</span></span>, wins = <span class="hljs-number"><span class="hljs-number">87</span></span>. Draws = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span> game(s) played</code> </pre><br>  Why does the program work so long?  Let's see how many times, when calculating the course, the evaluation function is called (data of calculation for 5 moves deep): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b9e/0be/896/b9e0be896f8d868ca25062ec5e940a71.jpg"><br><br>  Yes, there are certainly a lot of 8,000 calls to the evaluation function, but why are there three rows here?  I'll try to explain.  Here is how we count the number of calls to Eval: <br><br><div class="spoiler">  <b class="spoiler_title">Statistics collection</b> <div class="spoiler_text"><pre> <code class="hljs vbscript">$gameLog <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> VARIABLE EvalCount : Score ( alpha beta turn -- score ) Depth -- Depth @ <span class="hljs-number"><span class="hljs-number">0</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> EvalCount ++ ... <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> ... ; : Custom-Engine ( -- ) ... BEGIN ... <span class="hljs-number"><span class="hljs-number">0</span></span> EvalCount ! BestScore @ <span class="hljs-number"><span class="hljs-number">10000</span></span> turn-offset <span class="hljs-keyword"><span class="hljs-keyword">next</span></span>-turn-offset Score <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> $RAND-WITHIN + EvalCount @ . CR ... UNTIL DROP CR ;</code> </pre><br></div></div><br>  At the output, the following sequence is obtained: <br><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text">  992 <br>  655 <br>  147 <br><br>  3749 <br>  22 <br>  one <br>  22 <br>  22 <br>  22 <br>  22 <br>  one <br>  one <br><br>  336 <br>  132 <br>  50 <br><br>  382 <br>  42 <br>  213 <br>  35 <br>  392 <br>  21 <br>  62 <br>  40 <br>  49 <br><br>  1465 <br>  189 <br>  one <br>  one <br>  one <br>  one <br>  one <br>  one <br>  one <br>  52 <br>  91 <br><br>  122 <br>  75 <br>  50 <br><br>  1509 <br>  2074 <br>  637 <br>  492 <br>  249 <br>  800 <br>  415 <br>  877 <br>  963 <br><br>  5608 <br>  90 <br>  four <br>  four <br>  four <br>  four <br>  four <br>  four <br>  four <br>  four <br></div></div><br>  Each group of numbers (separated by an empty line) contains the results of viewing all possible moves of a player from the current position.  In the graph presented above, the first row shows the minimum value in the group, the second - the average, the third - the maximum.  The difference between the maximum and minimum value is determined by the effectiveness of alpha-beta clipping.  Average - determines the performance on which we can count at a given depth of search. <br><br>  It can be noted that the numbers in the groups generally decrease, but sometimes there are ‚Äúbursts‚Äù breaking the monotonous decrease.  Let's try to count their number: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca1/a65/4e2/ca1a654e2fb825c3d36c9a2d51351da1.jpg"><br><br>  Too much!  In some groups, more than 16 violations monotonous decrease.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it were possible to view the moves in a more optimal sequence, it would certainly be possible to improve the performance indicators (and it is possible to achieve a greater depth of enumeration). </font><font style="vertical-align: inherit;">Unfortunately, the following two points prevent me from doing this:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I do not have heuristics that allow to make a preliminary assessment of the "quality" of moves in the game Splut! </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Even if such heuristics were, a preliminary assessment and sorting of the list of moves in Axiom is associated with certain technical difficulties (and performance costs) </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another method of increasing the depth of the search could be the ‚Äúin-depth‚Äù search of the ‚Äúforced‚Äù moves. Also, it would be nice to cut off repetitive positions ( </font></font><a href="https://en.wikipedia.org/wiki/Zobrist_hashing"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zobrist hashing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> could help a </font><a href="https://en.wikipedia.org/wiki/Zobrist_hashing"><font style="vertical-align: inherit;">lot</font></a><font style="vertical-align: inherit;"> with this </font><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see how the number of viewed positions changes as the depth of enumeration increases: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/20e/df3/179/20edf317997bc278310005176143b272.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the average waiting time for the completion of moves of all opponents (with a depth of 5 moves) is about 1 minute, it is obvious that this is the maximum search depth that you can count on during the current implementation of the algorithm (any increase in it will make a person‚Äôs game with the program completely uncomfortable). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But let's think about what 5 moves are in the game </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Splut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">This is not even enough to calculate the possible moves of all players! </font><font style="vertical-align: inherit;">Even in Duel mode. </font><font style="vertical-align: inherit;">It's like counting the game of Chess just 1 turn ahead! </font><font style="vertical-align: inherit;">It is difficult to expect special intelligence from such a program. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course in Splut! </font><font style="vertical-align: inherit;">There are far fewer pieces than in Chess, but the moves are more complicated! </font><font style="vertical-align: inherit;">To win, the program must be able to make long-term plans for many moves ahead. </font><font style="vertical-align: inherit;">While I do not know how to achieve this, using the Axiom, but probably as it is possible.</font></font><br>  I'm working on it. <br><br><div class="spoiler">  <b class="spoiler_title">PS</b> <div class="spoiler_text">      Axiom. <b>Greg Schmidt</b> ‚Äî      .    Axiom   10 ,        .   ,    Axiom-    ZoG,      ,      Axiom.  ,   ,           -.      ! <br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pps</font></font></b> <div class="spoiler_text">   ,      - <b> </b> . <br></div></div><br></div><p>Source: <a href="https://habr.com/ru/post/227835/">https://habr.com/ru/post/227835/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227811/index.html">"Rescue" container PowerCube</a></li>
<li><a href="../227817/index.html">Choosing secure IM for Android</a></li>
<li><a href="../227821/index.html">Tizen Developer Summit Russia Conference in Moscow July 10, 2014</a></li>
<li><a href="../227823/index.html">Registration with Google Wallet Merchant is open to Belarus and Kazakhstan.</a></li>
<li><a href="../227827/index.html">Creating audio plug-ins, part 12</a></li>
<li><a href="../227837/index.html">The future of the ECM systems market: a view from Europe</a></li>
<li><a href="../227841/index.html">Framework-independent controllers. Finishing touches</a></li>
<li><a href="../227843/index.html">Everything you know about conversion optimization is not true.</a></li>
<li><a href="../227845/index.html">Experimental video post: two excavators, drones and railgun</a></li>
<li><a href="../227847/index.html">Moto 360: smart and beautiful watch from Motorola</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>