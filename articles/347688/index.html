<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Performance comparison of C and C ++ using the example of Huffman compression</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 When the IT forums ask the question "Is the X programming language of the Y language faster," this usually causes a flow of emotions an...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Performance comparison of C and C ++ using the example of Huffman compression</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  When the IT forums ask the question "Is the X programming language of the Y language faster," this usually causes a flow of emotions and is considered incorrect.  With related questions about religion or the preference of a particular political party.  Indeed, language is a way of expressing thoughts, ideas.  In this case, the ideas of the software system.  He is neither fast nor slow.  It may be more or less concise, more or less accurate.  And the speed is determined not so much by the language as by the final code generated by the compiler of this language.  Or the speed of the interpreter in the case of the interpreted language. <br><br>  But this is all philosophy.  But in practice there is usually a practical task of software development.  And, indeed, you can implement this software in a dozen different programming languages.  Therefore, even though this is a ‚Äúreligious issue‚Äù in the case of a public discussion, this question often arises in the head of an IT specialist who is facing a specific task.  ‚ÄúHow much time will it take for me to accomplish the task in the X language and what characteristics of the received software will have the speed characteristics.  Compared with the implementation of this task in the language Y ".  Understandably, there is no exact answer to this question, the specialist relies on his personal experience and responds somehow like "with a 95% probability, written in assembler, this task will work faster than in php".  But, in all honesty, this experience is rarely based on the exact numbers of real-world tasks that this specialist himself realized.  No, well, who in his right mind would write complex software first in php, and then rewrite it in assembler, only to measure the characteristics?  Mainly limited to synthetic tests such as sorting an array, building and traversing a binary tree, and so on. <a name="habracut"></a><br><br>  As a specialist writing 90% in C ++, I often come across ‚Äúholly‚Äù topics of comparing this language with others.  And one of them is the progenitor - the C language. On the same quora.com, this question is often raised ‚ÄúIs the C language of C ++ faster‚Äù (which is incorrect, as I explained above), or ‚ÄúWhy is the Linux kernel or a ton of GNU utilities written in C and not in C ++ ‚Äù(which is a completely correct question).  I answered the second question for myself: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Mastering the C language requires an order of magnitude less effort, which means that more people can participate in the development of this software. </li><li>  Complicated actions that are potentially costly in memory or speed in C will probably take more lines of code and will require effort from the author.  So, the non-optimality in the program will be easier to notice in the course of writing or review.  A C ++ program can be much more concise and, apparently, easy to understand.  But notice that the operator ‚Äú+‚Äù, for example, is hiding the launch of a spacecraft to the moon, will be more difficult to notice. </li></ul><br>  Since C is part of C ++, I have to decide in my everyday tasks whether to express some part of the logic ‚Äúmore in C style‚Äù (with working with ‚Äúraw‚Äù pointers, clearing memory through memset, passing context through void * ), or type safe in C ++ style (the pointers are wrapped in unique_ptr / shared_ptr, the memory is cleaned up with normally written constructors, the context is passed as a typed object: either with a pointer to the base class with virtual functions, or as a template in general). <br><br><h2>  Problem </h2><br>  In order to answer this question a little more thoroughly, I decided to write one more (yes, also a little synthetic) test - data coding using the Huffman method.  The article ‚ÄúThe Huffman algorithm on the fingers‚Äù ( <a href="https://habrahabr.ru/post/144200/">https://habrahabr.ru/post/144200/</a> ) suggested the idea. <br><br>  First, I implemented coding on pure C. If you remember, its implementation requires a priority queue, because to build a coding tree, you need to quickly find characters ordered by the number of repetitions.  I omit the algorithmic details, referring the reader to the link above (sorry for the tautology).  Actually, this would all end, and there would be no article, because the coding I implemented only as a workout in the algorithms.  But in the course of the work, I noticed how quickly the C program is compiled compared to C ++ source code of similar size.  And mentioned this to a colleague.  Having suggested that compiling in C ++ includes, probably, many more optimization methods.  So, similarly written code in C ++ should probably be faster - the magic of the most-most gurus in the field of writing optimizing compilers will work in the same place.  Grinning, a colleague replied: "Check." <br><br>  And then I rewrote Huffman coding in C ++.  For the purity of the experiment, I did not change the fundamental principles, for example, did not insert a user memory allocator.  This can be done both in C (more ‚Äúcustom‚Äù) and in C ++ (more ‚Äúnative‚Äù).  What is then ‚ÄúC ++ - ness‚Äù? <br><br><h3>  Priority queue </h3><br>  The first thing that makes sense to express through patterns in C ++ is the priority queue.  In C, it is represented as a structure, the main element of which is a pointer to an array of pointers to data nodes: <br><br><pre><code class="cpp">struct priority_queue
{
    // A number of active (carrying data) nodes currently in the queue
    unsigned int size;
    // A total number of nodes in "nodes" array
    unsigned int capacity;
    // An array of pointers to nodes
    struct priority_queue_node** nodes;
};
</code></pre><br>
      ,        :<br>
<br>
<pre><code class="cpp">struct priority_queue_node
{
    unsigned int weight;
};
</code></pre><br>
         ,   ,     . ,    ,    : ((struct priority_queue_node*) node_ptr)‚Üíweight.            :<br>
<br>
<pre><code class="cpp">int priority_queue_push(struct priority_queue* queue, struct priority_queue_node* node)
{
    if (queue-&gt;size &gt;= queue-&gt;capacity)
    {   
        int new_capacity = queue-&gt;capacity * 2;
        if (new_capacity == 0)
            new_capacity = 1;
        struct priority_queue_node** new_nodes = (struct priority_queue_node**) malloc(sizeof(struct priority_queue_node*) * new_capacity);
        if (! new_nodes)
        {
            return 0;
        }
        memcpy(new_nodes, queue-&gt;nodes, sizeof(struct priority_queue_node*) * queue-&gt;size);
        if (queue-&gt;capacity)
            free(queue-&gt;nodes);
        queue-&gt;nodes = new_nodes;
        queue-&gt;capacity = new_capacity;
    }

    queue-&gt;nodes[queue-&gt;size++] = node;
    heapify(queue);
    return 1;
}
</code></pre><br>
         ‚Äî        C++ ,  . ,    C++   ( ‚Äî   ):<br>
<br>
<pre><code class="cpp">template &lt;class T&gt; class priority_queue
{
    struct node
    {   
        unsigned int m_weight;
        T m_data;
    };

    using node_ptr = std::unique_ptr&lt;node&gt;;

    std::size_t m_capacity;
    std::size_t m_size;
    std::unique_ptr&lt;node_ptr[]&gt; m_nodes;

    void heapify() noexcept;
    void increase_capacity();
public:
    explicit priority_queue(std::size_t capacity = 16) ;
    // ‚Ä¶
};
</code></pre><br>
       ,    C  ‚Äî   ,    , ,    ,     ‚Äî  ,    ,      .         ‚Äî  m_nodes      .<br>
<br>
  ‚Äî            (  ‚Äî    increase_capacity,    ):<br>
<br>
<pre><code class="cpp">template &lt;class U&gt;
push(unsigned int weight, U&amp;&amp; obj)
{   
    if (m_size &gt;= m_capacity)
        increase_capacity();

    m_nodes[m_size++].reset(new node({weight, std::forward&lt;U&gt;(obj)}));
    heapify();
}

void increase_capacity()
{
    const auto new_capacity = m_capacity ? m_capacity * 2 : 1;
    std::unique_ptr&lt;node_ptr[]&gt; new_nodes(new node_ptr[new_capacity]);

    for (auto src = m_nodes.get(), dest = new_nodes.get(); src != m_nodes.get() + m_size; ++src, ++dest)
        *dest = std::move(*src);

    m_nodes = std::move(new_nodes);
    m_capacity = new_capacity;
}
</code></pre><br>
<h3>  ( )</h3><br>
       ,            ,      .  C        ,       :<br>
<br>
<pre><code class="cpp">#define NODE_TYPE_TERM 1
#define NODE_TYPE_NODE 2

struct char_node_base
{
    int type;
};

struct char_node_terminal
{
    struct char_node_base base;
    char c;
};

struct char_node
{
    struct char_node_base base;
    struct char_node_base* left;
    struct char_node_base* right;
};
</code></pre><br>
         ,   ,  ,  ‚Äî   :<br>
<pre><code class="cpp">struct char_node_root
{
    struct priority_queue_node pq_node;
    int height;
    struct char_node_base* node;
};
</code></pre><br>
 C++     :<br>
<pre><code class="cpp">struct char_node_base
{
    virtual ~char_node_base() = default;
};

using char_node_ptr = std::unique_ptr&lt;char_node_base&gt;;

struct char_node_terminal : char_node_base
{
    const unsigned char m_c;
    char_node_terminal(char c) noexcept : m_c(c) {}
};

struct char_node : char_node_base
{
    char_node_ptr m_left;
    char_node_ptr m_right;
};

struct nodes_root
{
    int m_height;
    char_node_ptr m_node;
};
</code></pre><br>
    C++ ‚Äî         .   ,     .  C        .<br>
<br>
<h3>    </h3><br>
      C  C++ .          ,     256 .       -,      .         ,    ,     ,   .<br>
<br>
 C ( ‚Äî    )    :<br>
<br>
<pre><code class="cpp">static struct priority_queue* build_priority_queue(
    char* buffer, unsigned int size)
{
    unsigned char table[256];

    memset(table, 0, sizeof(table));

    for (unsigned int i = 0; i &lt; size; ++i)
        if (table[(unsigned char)buffer[i]] != 255)
            ++table[(unsigned char)buffer[i]];

    struct priority_queue* queue = priority_queue_create(16);

    for (unsigned short i = 0; i &lt; 256; ++i)
    {
        if (table[i])
        {
            struct char_node_root* node = (struct char_node_root*) malloc(sizeof(struct char_node_root));

            struct char_node_terminal* term = (struct char_node_terminal*) malloc(sizeof(struct char_node_terminal));

            term-&gt;base.type = NODE_TYPE_TERM;
            term-&gt;c = (char)i;
            node-&gt;node = (struct char_node_base*) term;
            node-&gt;height = 0;
            node-&gt;pq_node.weight = table[i];
            priority_queue_push(queue, (struct priority_queue_node*) node);
        }
    }
    return queue;
}

static struct char_node_root* queue_to_tree(struct priority_queue* queue)
{
    while (priority_queue_size(queue) &gt; 1)
    {
        struct char_node_root* node1 = (struct char_node_root*) priority_queue_pop(queue);
        struct char_node_root* node2 = (struct char_node_root*) priority_queue_pop(queue);
        struct char_node_base* int_node1 = node1-&gt;node;
        struct char_node_base* int_node2 = node2-&gt;node;

        struct char_node* join_node = (struct char_node*) malloc(sizeof(struct char_node));
        join_node-&gt;base.type = NODE_TYPE_NODE;
        join_node-&gt;left = int_node1;
        join_node-&gt;right = int_node2;

        int new_weight = node1-&gt;pq_node.weight;
        if (new_weight + node2-&gt;pq_node.weight &lt;= 65535)
            new_weight += node2-&gt;pq_node.weight;
        else
            new_weight = 65535;
        node1-&gt;pq_node.weight = new_weight;

        if (node1-&gt;height &gt; node2-&gt;height)
            ++node1-&gt;height;
        else
            node1-&gt;height = node2-&gt;height + 1;
        free(node2);

        node1-&gt;node = (struct char_node_base*) join_node;
        priority_queue_push(queue, (struct priority_queue_node*) node1);
    }

    return (struct char_node_root*) priority_queue_pop(queue);
}
</code></pre><br>
 C++ ‚Äî      ,              :<br>
<br>
<pre><code class="cpp">void fill_priority_queue(
    const unsigned char* buffer,
    std::size_t buffer_size,
    queue_t&amp; queue)
{
    unsigned char counts_table[256]{};

    for (auto ptr = buffer; ptr != buffer + buffer_size; ++ptr)
        if (counts_table[*ptr] != 255)
            ++counts_table[*ptr];

    for (unsigned short i = 0; i != 256; ++i)
        if (counts_table[i])
            queue.push(counts_table[i], nodes_root {0, char_node_ptr(new char_node_terminal(i))});
}

void queue_to_tree(queue_t&amp; queue)
{
    while (queue.size() &gt; 1)
    {
        auto old_root1_node = std::move(queue.top());
        const auto old_root1_weight = queue.top_weight();
        queue.pop();
        auto old_root2_node = std::move(queue.top());
        const auto old_root2_weight = queue.top_weight();
        queue.pop();

        auto joined_node = std::unique_ptr&lt;char_node&gt;(new char_node);
        joined_node-&gt;m_left = std::move(old_root1_node.m_node);
        joined_node-&gt;m_right = std::move(old_root2_node.m_node);

        const auto new_weight = std::min(old_root1_weight + old_root2_weight, 65535U);
        const auto new_height = std::max(old_root1_node.m_height, old_root2_node.m_height) + 1;
        queue.push(new_weight, nodes_root {new_height, std::move(joined_node)});
    }
}
</code></pre><br>
<h3> </h3><br>
       ,        ,   ,   ,     .      ¬´¬ª       .     ,        .       ,    .      ,   ,           .<br>
<br>
 C      ,           . -       .           ,  ,    ,  .  ,   ‚Äî        .<br>
<br>
<pre><code class="cpp">struct bits_line
{
    unsigned char bits_count;
    unsigned char* bits;
};

static int build_encoding_map_node(struct char_node_base* node, struct bits_line* bits_table, unsigned char* bits_pattern, int bits_count)
{
    if (node-&gt;type == NODE_TYPE_TERM)
    {
        unsigned char index = (unsigned char)((struct char_node_terminal*)node)-&gt;c;
        bits_table[index].bits_count = bits_count;
        bits_table[index].bits = (unsigned char*) malloc(bytes_count_from_bits(bits_count + 1));
        if (! bits_table[index].bits)
            return 0;
        memcpy(bits_table[index].bits, bits_pattern, bytes_count_from_bits(bits_count));
        return 1;
    }

    static const unsigned char bit_mask[] = {1, 2, 4, 8, 16, 32, 64, 128};
    bits_pattern[bits_count &gt;&gt; 3] &amp;= ~bit_mask[bits_count &amp; 7];
    if (! build_encoding_map_node(((struct char_node*)node)-&gt;left, bits_table, bits_pattern, bits_count + 1))
        return 0;
    bits_pattern[bits_count &gt;&gt; 3] |= bit_mask[bits_count &amp; 7];
    if (! build_encoding_map_node(((struct char_node*)node)-&gt;right, bits_table, bits_pattern, bits_count + 1))
        return 0;

    return 1;
}
</code></pre><br>
 C++       ,      ,   ,  ,     .<br>
<br>
<pre><code class="cpp">using unique_bytes_ptr = std::unique_ptr&lt;unsigned char[]&gt;;

class bit_ostream
{
    std::size_t m_capacity;
    unsigned long m_bits_count = 0;
    unique_bytes_ptr m_data;
public:
    explicit bit_ostream(std::size_t initial_capacity = 0) noexcept
        : m_capacity(initial_capacity)
    {
    }

    bit_ostream&amp; push(const unsigned char* bits, unsigned long const bits_count)
    {
        if (bits_count == 0)
            return *this;

        const auto new_bits_count = m_bits_count + bits_count;
        if (covered_bytes(new_bits_count) + 1 &gt; m_capacity || m_bits_count == 0)
        {
            decltype(m_capacity) new_capacity = m_capacity * 2;
            const auto cov_bytes = static_cast&lt;decltype(m_capacity)&gt;(covered_bytes(new_bits_count) + 1);
            if (new_capacity &lt; cov_bytes)
                new_capacity = cov_bytes;
            unique_bytes_ptr new_data(new unsigned char[new_capacity]);
            std::memcpy(new_data.get(), m_data.get(), covered_bytes(m_bits_count));
            m_capacity = new_capacity;
            m_data = std::move(new_data);
        }

        unsigned char* curr = m_data.get() + (m_bits_count &gt;&gt; 3);
        if ((m_bits_count &amp; 7) == 0)
        {
            // All it's simple when current output data size is integer number of bytes
            std::memcpy(curr, bits, covered_bytes(bits_count));
        }
        else
        {
            const unsigned char shift = m_bits_count &amp; 7;
            for (auto bytes_count = covered_bytes(bits_count); bytes_count &gt; 0; ++curr, ++bits, --bytes_count)
            {
                unsigned short val = static_cast&lt;unsigned short&gt;(*bits) &lt;&lt; shift;
                val |= static_cast&lt;unsigned short&gt;(*curr &amp; g_bits_fill_mask[shift]);
                *curr = static_cast&lt;unsigned char&gt;(val &amp; 0xff);
                *(curr + 1) = static_cast&lt;unsigned char&gt;(val &gt;&gt; 8);
            }
        }
        m_bits_count += bits_count;

        assert(covered_bytes(m_bits_count) &lt;= m_capacity);
        return *this;
    }

    bit_ostream&amp; push(const bit_ostream&amp; other)
    {
        return push(other.data(), other.bits_count());
    }

    bit_ostream&amp; clear_tail() noexcept
    {
        if (m_bits_count &amp; 7)
            m_data.get()[m_bits_count &gt;&gt; 3] &amp;= g_bits_fill_mask[m_bits_count &amp; 7];

        return *this;
    }

    unsigned long bits_count() const noexcept { return m_bits_count; }
    bool empty() const noexcept { return ! m_bits_count; }
    unsigned char* data() noexcept { return m_data.get(); }
    const unsigned char* data() const noexcept { return m_data.get(); }
};

template &lt;class T&gt;
constexpr inline std::size_t covered_bytes(T bits_count) noexcept
{
    return (bits_count &gt;&gt; 3) + (bits_count &amp; 7 ? 1 : 0); 
}
</code></pre><br>
<h3>  </h3><br>
,      .      .   ,             .          ,  ,  ‚Äî    CPU    rdtsc.<br>
<br>
<ol>
<li>    ts1   rdtsc.</li>
<li>        .</li>
<li>      .   .</li>
<li>   t1,    ts1,     ts2.</li>
<li>  ,   .   .</li>
<li>   t2,    ts2,     ts3.</li>
<li>    ,         .</li>
<li>   t3,    ts3.</li>
</ol><br>
         ,      ,  posix  clock_gettime.<br>
<br>
<h2>  </h2><br>
 ,    ,    ,  : ¬´    ?¬ª.    ,   gcc-5.4.0    ¬´O3¬ª,      31 .  ,            .    64 .  ,   31  / 64  ,     .<br>
<br>
<pre><code class="bash">&gt; build-c/pack-c -m3 ../sample-1.dat data-c.dat
File packing is done. Read 31962362 bytes, written 32031809 bytes. Total ticks = 1053432 (0.754 seconds), t1 = 209957, t2 = 31023, t3 = 811377.

&gt; build-cpp/pack-cpp -m3 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 32031809 bytes. Total ticks = 1182005 (0.846 seconds), t1 = 228527, t2 = 52680, t3 = 894081
</code></pre><br>
  ¬´-m3¬ª    ,   ,   .<br>
<br>
 -, -   .  , C++   ,     12%.     ,   C .      , , 1 ?<br>
<br>
<pre><code class="bash">&gt; build-c/pack-c -m3 -b1024 ../sample-1.dat data-c.dat
File packing is done. Read 31962362 bytes, written 31160081 bytes. Total ticks = 9397894 (6.731 seconds), t1 = 5320910, t2 = 1943422, t3 = 2094688.

&gt; build-cpp/pack-cpp -m3 -b1024 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 31160081 bytes. Total ticks = 11586220 (8.3 seconds), t1 = 6399593, t2 = 3125111, t3 = 1663035
</code></pre><br>
 ,  ,         .  C    ‚Äî   23%!<br>
<br>
<h3> ¬´ ¬ª</h3><br>
    C++ ?   ,      .     ,      ,     .  bit_ostream  .         ,     ,  push?            ,      .    ,   256   ,    ,  256  bits_line  C .        .<br>
<br>
<pre><code class="cpp">class small_bit_ostream
{
    unique_bytes_ptr m_data;
    unsigned short m_bits_count = 0;
public:
    small_bit_ostream&amp; push(const unsigned char* bits, const unsigned short bits_count)
    {   
        const auto cov_bytes {covered_bytes(bits_count)};
        m_data.reset(new unsigned char[cov_bytes]);
        std::memcpy(m_data.get(), bits, cov_bytes);
        m_bits_count = bits_count;
        return *this;
    }   

    unsigned long bits_count() const noexcept { return m_bits_count; }
    bool empty() const noexcept { return ! m_bits_count; }
    unsigned char* data() noexcept { return m_data.get(); }
    const unsigned char* data() const noexcept { return m_data.get(); }
};
</code></pre><br>
. .  .     -? (  C    .)<br>
<br>
<pre><code class="bash">&gt; build-cpp/pack-cpp -m3 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 32031809 bytes. Total ticks = 1173692 (0.84 seconds), t1 = 229942, t2 = 46677, t3 = 890323

&gt; build-cpp/pack-cpp -m3 -b1024 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 31160081 bytes. Total ticks = 11198578 (8.02 seconds), t1 = 6404650, t2 = 2752852, t3 = 1641317
</code></pre><br>
 ,     ‚Äî   .       ‚Äî  C++    19%.    t2,      .<br>
<br>
<h3></h3><br>
  ,    CPU.      valgrind'   ¬´cachegrind¬ª.     C .<br>
<br>
<pre><code class="bash">==2794== I   refs:      2,313,382,347
==2794== I1  misses:           14,482
==2794== LLi misses:            1,492
==2794== I1  miss rate:          0.00%
==2794== LLi miss rate:          0.00%
==2794== 
==2794== D   refs:        601,604,444  (472,330,278 rd   + 129,274,166 wr)
==2794== D1  misses:        3,966,884  (  2,279,553 rd   +   1,687,331 wr)
==2794== LLd misses:            7,030  (      3,034 rd   +       3,996 wr)
==2794== D1  miss rate:           0.7% (        0.5%     +         1.3%  )
==2794== LLd miss rate:           0.0% (        0.0%     +         0.0%  )
==2794== 
==2794== LL refs:           3,981,366  (  2,294,035 rd   +   1,687,331 wr)
==2794== LL misses:             8,522  (      4,526 rd   +       3,996 wr)
==2794== LL miss rate:            0.0% (        0.0%     +         0.0%  )
==2794== 
==2794== Branches:        299,244,261  (298,085,895 cond +   1,158,366 ind)
==2794== Mispredicts:       8,779,093  (  8,778,920 cond +         173 ind)
==2794== Mispred rate:            2.9% (        2.9%     +         0.0%   )
</code></pre><br>
     C++     :<br>
<br>
<pre><code class="bash">==2994== I   refs:      2,464,681,889
==2994== I1  misses:            2,032
==2994== LLi misses:            1,888
==2994== I1  miss rate:          0.00%
==2994== LLi miss rate:          0.00%
==2994== 
==2994== D   refs:        633,267,329  (491,590,332 rd   + 141,676,997 wr)
==2994== D1  misses:        3,992,071  (  2,298,593 rd   +   1,693,478 wr)
==2994== LLd misses:            8,292  (      3,173 rd   +       5,119 wr)
==2994== D1  miss rate:           0.6% (        0.5%     +         1.2%  )
==2994== LLd miss rate:           0.0% (        0.0%     +         0.0%  )
==2994== 
==2994== LL refs:           3,994,103  (  2,300,625 rd   +   1,693,478 wr)
==2994== LL misses:            10,180  (      5,061 rd   +       5,119 wr)
==2994== LL miss rate:            0.0% (        0.0%     +         0.0%  )
==2994== 
==2994== Branches:        348,146,710  (346,241,481 cond +   1,905,229 ind)
==2994== Mispredicts:       6,977,260  (  6,792,066 cond +     185,194 ind)
==2994== Mispred rate:            2.0% (        2.0%     +         9.7%   )
</code></pre><br>
 ,            C++  ,     ,  C .     .      ? ,        ‚Äî 2 464 .  2 313.        ,       .<br>
<br>
   ¬´callgrind¬ª ,         ‚Äî malloc  free.     C++     ,    ,   new  delete.     ?      ,    ,      unique_ptr,       new[]. ,       C- malloc,        .        .    ?  bit_ostream       ,    .     .    ,      .         malloc / free,    unique_ptr,         .<br>
<br>
<pre><code class="cpp">struct free_deleter
{
    void operator()(void* p) const noexcept { std::free(p); }
};

template &lt;class T&gt; inline T* allocate_with_malloc(std::size_t size)
{
    T* res = static_cast&lt;T*&gt;(std::malloc(sizeof(T) * size));
    if (! res)
        throw std::bad_alloc();
    return res;
}

template &lt;class T&gt;
using unique_malloc_array_ptr = std::unique_ptr&lt;T[], free_deleter&gt;;

template &lt;class T&gt;
inline unique_malloc_array_ptr&lt;T&gt; unique_allocate_with_malloc(std::size_t size)
{
    return unique_malloc_array_ptr&lt;T&gt;(allocate_with_malloc&lt;T&gt;(size));
}

// Typedefs for byte arrays
using unique_bytes_ptr = unique_malloc_array_ptr&lt;std::uint8_t&gt;;

inline unique_bytes_ptr allocate_bytes(std::size_t size)
{
    return unique_bytes_ptr(unique_allocate_with_malloc&lt;std::uint8_t&gt;(size));
}
</code></pre><br>
            (  , C   ,     ).<br>
<br>
<pre><code class="bash">&gt; build-cpp/pack-cpp -m3 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 32031809 bytes. Total ticks = 1042665 (0.746 seconds), t1 = 250480, t2 = 45393, t3 = 740163

&gt; build-cpp/pack-cpp -m3 -b1024 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 31160081 bytes. Total ticks = 11068384 (7.93 seconds), t1 = 6488100, t2 = 2694562, t3 = 1501027
</code></pre><br>
 -,    C++   C!      ,  ,    .      ‚Äî 2 430 .  2 464.        633 .  536. ,           ‚Äî         ,     .<br>
<br>
<h3>  </h3><br>
     ,         C++. ,    ,      .     m_nodes,       .          ,  ,  ptr1 = std::move(ptr2).   ¬´¬ª?  ptr1  ,       ,     .  ptr2    ,     . ,    ,      . !       ,      .        .       (!) .               .<br>
<br>
<pre><code class="bash">&gt; build-cpp/pack-cpp -m3 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 32031809 bytes. Total ticks = 1008990 (0.722 seconds), t1 = 221001, t2 = 44870, t3 = 736557

&gt; build-cpp/pack-cpp -m3 -b1024 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 31160081 bytes. Total ticks = 10683068 (7.65 seconds), t1 = 6101534, t2 = 2689178, t3 = 1505929
</code></pre><br>
 -,    C++   4,3%,   ‚Äî    13,6%.   2 413 .,    ‚Äî 531 .<br>
<br>
<h2></h2><br>
               ?<br>
<br>
<ol>
<li>      ¬´ ¬ª,     -  .   ,  C    ,  C++  ¬´¬ª  , ,   . .          . ( ,        ¬´¬ª,    ¬´¬ª  .)     ,       C ¬´ ¬ª     ,    C++    .</li>
<li>,    C++,     ,   C.         ,     C.      C      (  C++)    ,    ,   .    C++      ‚Äî ,  .        ‚Äî  ,          (     ),       ¬´ ¬ª.</li>
<li>,  -       ,     .     ,      .       ,         ¬´XYZ¬ª.  ,   ,  ?     .      C++     ,    31   0.85 ,    ,    !</li>
<li>          ,    .     ¬´¬ª,          ,      C ,  /  ,    , .          .           ,    ¬´  A, B, C  ¬ª,         C++.              ¬´       ¬ª,           .        .      ¬´ ¬ª     ,           C    .      ¬´¬ª  ,   ,    ,  ,    ,  .    .</li>
</ol><br>
<br>
P.S.     : <a href="">http://corosan.ru/data-exp/haffman_pack_for_article.tar.bz2</a><br>
<br>
Update 1.        ,   clang-3.8.0.  .<br>
<br>
C :<br>
<pre><code class="bash">&gt; build-c/pack-c -m3 ../sample-1.dat data-c.dat
File packing is done. Read 31962362 bytes, written 32031809 bytes. Total ticks = 1139373 (0.816 seconds), t1 = 206305, t2 = 29559, t3 = 902493.
</code></pre><br>
 C++ :<br>
<pre><code class="bash">&gt; build-cpp/pack-cpp -m3 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 32031809 bytes. Total ticks = 1417576 (1.01 seconds), t1 = 223441, t2 = 53057, t3 = 1134400
</code></pre><br>
 C++ :<br>
<pre><code class="bash">&gt; build-cpp/pack-cpp -m3 ../sample-1.dat data-cpp.dat
File packing is done. Read 31962362 bytes, written 32031809 bytes. Total ticks = 1174028 (0.84 seconds), t1 = 215059, t2 = 59738, t3 = 892821
</code></pre><br>
    ,     clang   - ,  gcc.</div><p>Source: <a href="https://habr.com/ru/post/347688/">https://habr.com/ru/post/347688/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347676/index.html">Static analysis and property-based testing: together we are powerful</a></li>
<li><a href="../347678/index.html">Creating cognitive connections with players</a></li>
<li><a href="../347680/index.html">Interview with Jasi2169</a></li>
<li><a href="../347684/index.html">Telephony for hotels: review of the hotel module PBX 3CX</a></li>
<li><a href="../347686/index.html">The theory of "broken" warnings</a></li>
<li><a href="../347692/index.html">The digest of interesting materials for the mobile developer # 238 (January 22 - January 28)</a></li>
<li><a href="../347694/index.html">What indie developers can learn from indie writers</a></li>
<li><a href="../347696/index.html">Apply CatBoost models inside ClickHouse. Yandex lecture</a></li>
<li><a href="../347698/index.html">Programmer Unknown's BattleGround: an open area for programmer battles</a></li>
<li><a href="../347700/index.html">Taming SphinxSearch with an Elephant</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>