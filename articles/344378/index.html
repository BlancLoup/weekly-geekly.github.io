<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The fastest and most energy-efficient implementation of the BFS algorithm on various parallel architectures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Offtop 


 The title of the article did not fit - these results are considered as such according to the version of Graph500 rating. I would also like ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The fastest and most energy-efficient implementation of the BFS algorithm on various parallel architectures</h1><div class="post__text post__text-html js-mediator-article"><h1>  Offtop </h1><br><p>  <i>The title of the article did not fit - these results are considered as such according to the version of <a href="http://graph500.org/">Graph500</a> rating.</i>  <i>I would also like to thank IBM and RSC companies for providing resources for conducting experimental launches during the study.</i> <i><br></i> </p><br><h1>  Introduction </h1><br><p>  Wide Search (BFS) is one of the main graph traversal algorithms and the base for many higher-level graph analysis algorithms.  A wide search on graphs is a task with irregular memory access and irregular data dependence, which greatly complicates its parallelization on all existing architectures.  The article will discuss the implementation of a wider search algorithm (the main test of the <a href="http://graph500.org/">Graph500</a> rating) for processing large graphs on various architectures: Intel x86, IBM Power8 +, Intel KNL and NVidia GPU.  The features of the implementation of the algorithm on shared memory will be described, as well as graph transformations, which allow achieving record-high performance and energy efficiency indicators for this algorithm among all single-site <a href="http://graph500.org/">Graph500</a> and <a href="http://green.graph500.org/">GreenGraph500</a> rating systems. </p><a name="habracut"></a><br><p>  Recently, graphic accelerators (GPU) in non-graphical calculations play an increasing role.  The need for their use is due to their relatively high performance and lower cost.  As you know, on the GPU and central processing units (CPUs), problems are well solved on structural, regular grids, where parallelism is somehow easily distinguished.  But there are tasks that require high power and use unstructured grids or data.  Examples of such tasks are: Single Shortest Source Path problem ( <a href="https://link.springer.com/article/10.1007%252FBF02592101%3FLI%3Dtrue">SSSP</a> ) - the task of finding the shortest paths from a given vertex to all others in a weighted graph, the Breadth First Search (BFS [1]) problem - the task of finding a width in an undirected graph, Minimum Spanning Tree (MST, for example, <a href="https://www.cs.princeton.edu/~chazelle/pubs/mst.pdf">foreign</a> and <a href="https://vestnik.susu.ru/cmi/article/view/4793">my</a> implementation) - the task of finding strongly related components and others. </p><br><p>  These tasks are basic in a number of algorithms on graphs.  Currently, the BFS and SSSP algorithms are used to rank computers in the Graph500 and GreenGraph500 ratings.  The BFS algorithm (breadth-first search or search wide) is one of the most important graph analysis algorithms.  It is used to obtain some properties of links between nodes in a given graph.  BFS is mainly used as a link, for example, in such algorithms as finding connected components [2], finding the maximum flow [3], finding central components (between centrality) [4, 5], clustering [6], and many others. </p><br><p>  The BFS algorithm has a linear computational complexity O (n + m), where n is the number of vertices and m is the number of edges of the graph.  This computational complexity is optimal for consistent implementation.  But this estimate of computational complexity is not applicable for parallel implementation, since the sequential implementation (for example, using the <a href="http://www.cs.cornell.edu/~wdtseng/icpc/notes/graph_part2.pdf">Dijkstra algorithm</a> ) has data dependencies, which prevents its parallelization.  Also, the performance of this algorithm is limited by the memory performance of a particular architecture.  Therefore, the most important are the optimization aimed at improving the work with memory of all levels. </p><br><h1>  Review of existing solutions and Graph500 rating </h1><br><h3>  Graph500 and GreenGraph500 </h3><br><p>  The Graph500 rating was created as an alternative to the <a href="https://www.top500.org/">Top500</a> rating.  This rating is used to rank computers in applications that use irregular memory access, as opposed to the latter.  For the tested application in the Graph500 rating, the memory and communication network bandwidth play the most important role.  The GreenGraph500 rating is an alternative to the <a href="https://www.top500.org/green500/">Green500</a> rating and is used in addition to Graph500. </p><br><p>  Graph500 uses the metric - the number of processed edges of the graph per second (TEPS - traversed edges per second), while GreenGraph500 uses the metric - the number of processed edges of the graph per second per watt.  Thus, the first rating ranks the computers according to the speed of computation, and the second according to the energy efficiency.  These ratings are updated every six months. </p><br><h3>  Existing solutions </h3><br><p>  The width search algorithm was invented more than 50 years ago.  And research is still being conducted for effective parallel implementation on various devices.  This algorithm shows how well the work with memory and communication environment of calculators is organized.  There are a lot of works on parallelization of this algorithm on x86 systems [7-11] and on the GPU [12-13].  Also, detailed results of the implementation of the implemented algorithms can be seen in the ratings of Green500 and GreenGraph500.  Unfortunately, the algorithms of many effective implementations are not published in foreign sources. </p><br><p>  If you select only single-node systems in the Graph500 rating, then we will get the following some data, which are presented in the table below.  The results described in this paper are marked in bold.  The table included graphs with more than 2 <sup>25</sup> vertices.  From the data obtained it can be seen that currently there is no more efficient implementation using only one node than the one proposed in this article.  A more detailed analysis is presented in the <strong>Analysis</strong> section of <strong>the results</strong> . </p><br><table><tbody><tr><th>  Position </th><th>  System </th><th>  Size 2 <sup>n</sup> </th><th>  GTEPS </th><th>  Watt </th></tr><tr><td>  50 </td><td>  <b>GPU NVidia Tesla P100</b> </td><td>  26 </td><td>  204 </td><td>  175 </td></tr><tr><td>  67 </td><td>  NVidia GTX Titan GPU </td><td>  25 </td><td>  114 </td><td>  212 </td></tr><tr><td>  76 </td><td>  4x Intel Xeon E7-4890 v2 </td><td>  32 </td><td>  55.9 </td><td>  1153 </td></tr><tr><td>  86 </td><td>  <b>GPU NVidia Tesla P100</b> </td><td>  thirty </td><td>  41.7 </td><td>  235 </td></tr><tr><td>  103 </td><td>  NVidia GTX Titan GPU </td><td>  25 </td><td>  17.2 </td><td>  233.8 </td></tr><tr><td>  104 </td><td>  <b>Intel Xeon E5 2699 v3</b> </td><td>  thirty </td><td>  16.3 </td><td>  145 </td></tr><tr><td>  106 </td><td>  4x AMD Radeon R9 Nano GPUs </td><td>  25 </td><td>  15.8 </td><td></td></tr><tr><td>  112 </td><td>  <b>IBM POWER8 +</b> </td><td>  thirty </td><td>  13.2 </td><td>  200 </td></tr></tbody></table><br><h1>  Graph storage format </h1><br><p>  To evaluate the performance of the BFS algorithm, undirected <a href="https://faculty.mccombs.utexas.edu/deepayan.chakrabarti/mywww/papers/siam04.pdf">RMAT graphs are used</a> .  RMAT graphs model real graphs from social networks and the Internet well.  In this case, RMAT graphs are considered with an average degree of connectivity of a vertex 16, and the number of vertices is a power of two.  In such a RMAT graph, there is one large connected component and a number of small connected components or hanging vertices.  The strong connectivity of the components does not allow in any way to divide the graph into such subgraphs that would fit in the cache memory. </p><br><p>  To build the graph, a generator is used which is provided by the developers of the Graph500 rating.  This generator creates an undirected graph in the RMAT format, with the output data presented as a set of graph edges.  Such a format is not very convenient for an efficient parallel implementation of graph algorithms, since it is necessary to have aggregated information for each vertex, namely, which vertices are neighbors for a given one.  A convenient format for this view is called CSR (Compressed Sparse Rows). </p><br><p>  This format is widely used to store sparse matrices and graphs.  For an undirected graph with N vertices and M edges, two arrays are needed: X (an array of pointers to adjacent vertices) and A (an array of a list of adjacent vertices).  Array X of size N + 1, and array A is 2 * M, since in an undirected graph for any pair of vertices it is necessary to store forward and backward arcs.  The array X stores the beginning and the end of the list of neighbors located in array A, that is, the entire list of neighbors of the vertex J is in array A from the index X [J] to X [J + 1], not including it.  For illustration, the figure below shows a graph of 4 vertices on the left, written using an adjacency matrix, and on the right, in CSR format. </p><br><img src="https://habrastorage.org/webt/86/m-/6e/86m-6eozgybaeyijgc3kkurogfw.jpeg"><br><p><br>  After converting the graph to the CSR format, it is necessary to do some more work on the input graph to improve the efficiency of the cache and memory of computing devices.  After performing the transformations described below, the graph remains in the same CSR format, but acquires some properties related to the transformations performed. </p><br><p>  The transformations introduced allow constructing the graph in the optimal form for most of the algorithms for traversing the graph in the CSR format.  Adding a new vertex to the graph will not re-execute all transformations; it is enough to follow the rules entered and add a vertex so that the general order of the vertices is not violated. </p><br><h3>  Local Sorting Vertex List </h3><br><p>  For each vertex, we will sort by ascending its neighbor list.  As a key for sorting, we will use the number of neighbors for each vertex to be sorted.  After performing this sorting, performing a traversal of the list of neighbors at each vertex, we will process first the heaviest vertices ‚Äî vertices that have a large number of neighbors.  This sorting can be performed independently for each vertex and in parallel.  After performing this sorting, the number of vertices of the graph in memory does not change. </p><br><h3>  Global vertex list sorting </h3><br><p>  For a list of all the vertices of the graph, sort by ascending.  As the key, we will use the number of neighbors for each of the vertices.  Unlike local sorting, this sorting requires renumbering the received vertices, since the position of the vertex in the list changes.  The sorting procedure has O (N * log (N)) complexity and is performed sequentially, and the vertex renumbering procedure can be performed in parallel and is comparable in speed to the copying time of one memory section to another. </p><br><h3>  Renumbering all vertices of the graph </h3><br><p> Enumerate the vertices of the graph in such a way that the most connected vertices have the closest numbers.  This procedure is arranged as follows.  First the first vertex from the list is rendered for renumbering.  It gets the number 0. Then all adjacent vertices with the vertex under consideration are added to the queue for renumbering.  The next vertex from the renumbering list gets the number 1 and so on.  As a result of this operation, in each connected component, the difference between the maximum and minimum vertex numbers will be the smallest, which will make the best use of the small cache of computing devices. </p><br><h1>  Algorithm implementation </h1><br><p>  The width search algorithm in an undirected graph is organized as follows.  At the entrance is the initial for the previously undefined vertex in the graph (root vertex for the search).  The algorithm must determine at what level, starting from the root vertex, each of the vertices in the graph is located.  The level is understood as the minimum number of edges that must be overcome in order to get from the root vertex to the vertex other than the root.  Also for each of the vertices, except the root, it is necessary to determine the vertex of the parent.  Since one vertex can have several parent vertices, any of them is taken as the answer. </p><br><p>  The wide search algorithm has several implementations.  The most effective implementation is an iterative traversal of a graph with level synchronization.  Each step is an iteration of the algorithm in which information from level J is transferred to level J + 1.  The pseudocode of the sequential algorithm is presented <a href="https://en.wikipedia.org/wiki/Breadth-first_search">by reference</a> . </p><br><p>  A parallel implementation is based on a hybrid algorithm consisting of top-down (TD) and bottom-up (BU) procedures, which was proposed by the author of this article [11].  The essence of this algorithm is as follows.  The TD procedure allows you to bypass the vertices of the graph in a direct order, that is, going through the vertices, we consider the connection <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>V</mi><mn>1</mn><mtext>&amp;#xA0;</mtext><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>V</mi><mn>2</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.46ex" height="2.419ex" viewBox="0 -780.1 7948 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-56" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMAIN-31" x="769" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-52" x="1520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-69" x="2279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-67" x="2625" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-68" x="3105" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-74" x="3682" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-61" x="4043" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-72" x="4573" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-72" x="5024" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-6F" x="5476" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-77" x="5961" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-56" x="6678" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMAIN-32" x="7447" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>V</mi><mn>1</mn><mtext>&nbsp;</mtext><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>V</mi><mn>2</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> V1 \ Rightarrow V2 </script>  as a parent-child.  The second BU procedure allows you to bypass the vertices in the reverse order, that is, going through the vertices, we consider the connection <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>V</mi><mn>1</mn><mtext>&amp;#xA0;</mtext><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>V</mi><mn>2</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="18.46ex" height="2.419ex" viewBox="0 -780.1 7948 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-56" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMAIN-31" x="769" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-52" x="1520" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-69" x="2279" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-67" x="2625" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-68" x="3105" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-74" x="3682" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-61" x="4043" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-72" x="4573" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-72" x="5024" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-6F" x="5476" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-77" x="5961" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMATHI-56" x="6678" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/344378/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgNsVNJieYq_Ophe7cLeZwopBy64Q#MJMAIN-32" x="7447" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>V</mi><mn>1</mn><mtext>&nbsp;</mtext><mi>R</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi><mi>V</mi><mn>2</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> V1 \ Rightarrow V2 </script>  as a descendant parent. </p><br><p>  Consider a sequential implementation of a hybrid TD-BU algorithm, the pseudo-code of which is shown below.  To process the vertex graph, we need to create two additional queue arrays that will contain a set of vertices at the current level - Q <sub>curr</sub> , and a set of vertices at the next level - Q <sub>next</sub> .  To perform faster checks for the existence of a vertex in the queue, you must enter an array of visited vertices.  But since, as a result of the algorithm, we need to get information about the level at which each of the vertices is located, this array can also be used as an indicator of visited and marked vertices. </p><br><p>  <strong>Sequential BFS hybrid algorithm:</strong> </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bfs_hybrid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(G, N, M, Vstart)</span></span></span><span class="hljs-function"> </span></span>{ Levels &lt;- (<span class="hljs-number"><span class="hljs-number">-1</span></span>); Parents &lt;- (N + <span class="hljs-number"><span class="hljs-number">1</span></span>); Qcurr+=Vstart; CountQ=lvl=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (CountQ) { CountQ = <span class="hljs-number"><span class="hljs-number">0</span></span>; vis = <span class="hljs-number"><span class="hljs-number">0</span></span>; inLvl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == TD) foreach Vi in Qcurr foreach Vk in G.Edges(Vi) inLvl++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Levels[Vk] == <span class="hljs-number"><span class="hljs-number">-1</span></span>) Qnext += Vk; Levels[Vk] = lvl; Parents[Vk] = Vi; vis++; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == BU) foreach Vi in G <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Levels[Vi] == <span class="hljs-number"><span class="hljs-number">-1</span></span>) foreach Vk in G.Edges(Vi) inLvl++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Levels[Vk] == lvl - <span class="hljs-number"><span class="hljs-number">1</span></span>) Qnext += Vi; Levels[Vi] = lvl; Parents[Vi] = Vk; vis++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; change_state(Qcurr, Qnext, vis, inLvl, G); Qcurr &lt;- Qnext; CountQ = Qnext.size(); } }</code> </pre> <br><p>  The main loop of the algorithm consists of the sequential processing of each vertex in the Q <sub>curr</sub> queue.  If there are no more vertices left in the Q <sub>curr</sub> queue, the algorithm stops and the answer is received. </p><br><p>  At the very beginning of the algorithm, the TD procedure starts working, since the queue contains only one vertex.  In the TD procedure, for each vertex V <sub>i</sub> from the Q <sub>curr</sub> queue, we look at the list of neighbors with this vertex V <sub>k</sub> and add to the Q <sub>next</sub> queue those that have not yet been marked as visited.  Also, all such vertices V <sub>k</sub> get the number of the current level and the parent vertex V <sub>i</sub> .  After reviewing all vertices from the Q <sub>curr</sub> queue, the procedure for selecting the next state is started, which can either remain on the TD procedure for the next iteration, or change the procedure to BU. </p><br><p>  In the BU procedure, we view the vertices not from the Q <sub>curr</sub> queue, but those vertices that have not yet been marked.  This information is contained in the Levels Level Array.  If such vertices V <sub>i</sub> have not yet been labeled, then we pass through all its neighbors V <sub>k</sub> and if these vertices, which are parents for V <sub>i</sub> , are at the previous level, then the vertex V <sub>i</sub> falls into the queue Q <sub>next</sub> .  Unlike the TD procedure, in this procedure, you can interrupt the viewing of neighboring vertices V <sub>k</sub> , since it is enough for us to find any parent vertex. </p><br><p>  If we perform the search only with the TD procedure, then at the last iterations of the algorithm, the list of vertices that needs to be processed will be very large, and there will be quite a few unmarked vertices.  Thus, the procedure will perform unnecessary actions and unnecessary memory accesses.  If the search is performed only by the BU procedure, then at the first iterations of the algorithm there will be a lot of unmarked vertices and, similarly to the TD procedure, unnecessary actions and unnecessary memory accesses will be performed. </p><br><p>  It turns out that the first procedure is effective at the first iterations of the BFS algorithm, and the second at the last ones.  It is clear that the greatest effect will be achieved when we use both procedures.  In order to automatically determine when it is necessary to perform switching from one procedure to another, let us use the algorithm (change_state procedure), which was proposed by the authors of this article [11].  This algorithm, according to the information on the number of processed vertices on two adjacent iterations, tries to understand the behavior of the traversal.  The algorithm introduces two coefficients that allow you to customize switching from one procedure to another, depending on the graph being processed. </p><br><p>  The state transition procedure can translate not only TD into BU, but also back BU into TD.  The last state change is useful in the case when the number of vertices that need to be viewed is quite small.  To this end, the concept of a growing front and a decaying front of labeled and unmarked vertices is introduced.  The following pseudo-code, presented below, performs a state change depending on the characteristics obtained at a specific iteration of the graph traversal depending on the adjusted <strong>alpha</strong> and <strong>beta</strong> coefficients.  This function can be configured to any input graph depending on the <strong>factor</strong> (factor is the average connectivity of a graph vertex). </p><br><p>  <strong>State change function:</strong> </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">state </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">change_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Qcurr, Qnext, vis, inLvl, G)</span></span></span><span class="hljs-function"> </span></span>{ new_state = old_state; factor = GM / GN / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Qcurr.size() &lt; Qnext.size()) <span class="hljs-comment"><span class="hljs-comment">// Growing phase if(old_state == TOP_DOWN) if(inLvl &lt; ((GN - vis) * factor + GN) / alpha) new_state = TOP_DOWN; else new_state = BOTTOM_UP; else // Shrinking phase if (Qnext.size() &lt; ((GN - vis) * factor + GN) / (factor * beta)) new_state = TOP_DOWN; else new_state = BOTTOM_UP; return new_state; }</span></span></code> </pre> <br><p>  The concepts of the hybrid implementation of the BFS algorithm described above were used for parallel implementation for both the CPU of similar systems and for the GPU.  But there are some differences that will be discussed further. </p><br><h3>  Parallel implementation on a shared memory CPU </h3><br><p>  A parallel implementation for CPU systems (Power 8+, Intel KNL and Intel x86) was performed using <a href="http://www.openmp.org/">OpenMP</a> .  The same code was used for the launch, but each platform was configured for OpenMP directives, for example, different load balancing modes were set between threads (schedule).  To implement on the CPU using OpenMP, you can perform another graph conversion, namely, compressing the list of neighbors' vertices. </p><br><p>  Compression consists in removing the insignificant zero bits of each element from array A, and this conversion is done separately for each range [X <sub>i</sub> , X <sub>i + 1</sub> ).  The elements of array A are compacted. This compression reduces the amount of memory used to store the graph by about 30% for large graphs of the order of 2 <sup>30</sup> vertices and 2 <sup>34</sup> edges.  For smaller graphs, the savings from such a conversion increase proportionally due to the fact that the number of bits that occupy the maximum vertex number in a graph decreases. </p><br><p>  Such a graph conversion imposes some restrictions on vertex processing.  First, all adjacent vertices must be processed sequentially, since they are a compressed, coded in a certain way sequence of elements.  Secondly, it is necessary to perform additional actions on unpacking compressed items.  This procedure is not trivial and for the Power8 + CPU did not allow to get the effect.  The reason may be poor compiler optimization or non-Intel hardware operation. </p><br><p>  In order to execute one iteration of the algorithm in parallel, you need to create your own queues Q <sub>th_next</sub> for each OpenMP stream.  And after all the cycles are completed, merge the received queues.  It is also necessary to localize all the variables for which there is a reduction dependence.  As an optimization, the TD procedure is performed in a sequential mode if the number of vertices in the Q <sub>curr</sub> queue is less than a specified threshold (for example, less than 300).  For a graph of different sizes, as well as depending on the architecture, this threshold may have different values.  Parallel directives were placed before the cycles (foreach Vi in Qcurr) in the case of the TD procedure, and (foreach Vi in G) in the case of the BU procedure. </p><br><h3>  Parallel implementation on the GPU </h3><br><p>  A parallel implementation for the GPU was performed using <a href="http://docs.nvidia.com/cuda/">CUDA</a> technology.  The implementation of the TD and BU procedures differ significantly in the case of using the GPU, since the data access algorithm differs significantly during the execution of a procedure. </p><br><p>  The TD procedure was implemented using <a href="https://devblogs.nvidia.com/parallelforall/cuda-dynamic-parallelism-api-principles/">CUDA dynamic concurrency</a> .  This feature allows you to shift some work related to load balancing to GPU hardware.  Each vertex V <sub>i</sub> from the Q <sub>curr</sub> queue may contain a completely different number of previously unknown number of neighbors.  Because of this, with a direct mapping of the entire cycle onto a set of threads, there is a strong load imbalance, since CUDA allows the use of a block of threads of a fixed size. </p><br><p>  The described problem is solved by using dynamic concurrency.  At the beginning, the master threads start.  There will be as many threads as there are vertices in the Q <sub>curr</sub> queue.  Then each master thread runs as many additional threads as there are neighbors at the top of V <sub>i</sub> .  Thus, the number of threads used is formed over time during program execution, depending on the input data. </p><br><p>  This procedure is not convenient for execution on the GPU because of the need to use dynamic parallelism.  With a large total number of threads that need to be created from master threads, there are large overhead costs.  Therefore, switching to the BU procedure is performed earlier than on the CPU. </p><br><p>  The BU procedure is more favorable for execution on the GPU, if we do some additional data transformations.  This procedure differs significantly from the TD procedure in that the passage is performed on all consecutive vertices of the graph.  Thus, an organized cycle allows you to perform some data preparation for good memory access. </p><br><p>  The conversion is as follows.  It is known that adjacent threads of one warp perform instructions synchronously and in parallel.  Also, for effective memory access, it is required that the neighboring threads in the warp refer to the neighboring cells in the memory.  For example, we set the number of threads in the warp equal to 2. If each thread matches one vertex of the cycle (foreach Vi in G), then during the processing of neighbors in the cycle (foreach Vk in G.Edges (Vi)), each thread will turn into its own memory area , which will negatively affect the performance, since the neighboring threads will process the far located cells in the memory.  In order to correct the situation, we mix the elements of array A so that the first two neighbors from V <sub>0</sub> and V <sub>1 are</sub> accessed in the best possible way - the neighboring elements are located in the neighboring cells in the memory.  Further, in memory in the same way will be the second, third, etc.  items. </p><br><p>  This alignment rule applies to a group of warp threads (32 threads): the neighbors are mixed ‚Äî first the first 32 elements are located, then the second 32 elements, and so on.  Since the graph is sorted by decrease in the number of neighbors, the groups of vertices that are located next to each other will have a fairly close number of vertices of neighbors. </p><br><p>  It is not possible to mix elements in the whole graph in this way, since during the BU procedure, there is an early exit in the internal cycle.  The global and local sorts of vertices described above allow getting out of this cycle rather early.  Therefore, only 40% of all vertices of the graph are mixed.  This transformation requires additional memory to store the mixed graph, but we get a noticeable increase in performance.  Below is the pseudo-code of the kernel for the BU procedure using a mixed arrangement of elements in memory. </p><br><p>  <strong>Parallel core for the BU procedure:</strong> </p><br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bu_align</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span><span class="hljs-function"> </span></span>{ idx = blockDim.x * blockIdx.x + threadIdx.x; countQNext = <span class="hljs-number"><span class="hljs-number">0</span></span>; inlvl = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = idx; i &lt; N; i += stride) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (levels[i] == <span class="hljs-number"><span class="hljs-number">0</span></span>) start_k = rowsIndices[i]; end_k = rowsIndices[i + N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(k = start_k; k &lt; start_k + <span class="hljs-number"><span class="hljs-number">32</span></span> * end_k; k += <span class="hljs-number"><span class="hljs-number">32</span></span>) inlvl++; <span class="hljs-keyword"><span class="hljs-keyword">vertex_id_t</span></span> endk = endV[k]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (levels[endk] == lvl - <span class="hljs-number"><span class="hljs-number">1</span></span>) parents[i] = endk; levels_out[i] = lvl; countQNext++; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; atomicAdd(red_qnext, countQNext); atomicAdd(red_lvl, inlvl); }</code> </pre> <br><h1>  Analysis of the results </h1><br><p>  The tested programs were made on four different platforms at once: Intel Xeon Phi (Xeon KNL 7250), Intel x86 (Xeon E5 2699 v3), IBM Power8 + (Power 8+ s822lc) and NVidia Tesla P100 GPU.  The characteristics of these devices for comparison are presented in <br>  table below. </p><br><p>  The following compilers were used.  For Intel Xeon E5 - gcc 5.3, for Intel KNL - icc v17, for IBM - gcc for Power architecture, for NVidia - CUDA 9.0. </p><br><table><tbody><tr><th>  Vendor </th><th>  Cores / Threads </th><th>  Frequency, GHz </th><th>  RAM, GB / s </th><th>  Max.  TDP, W </th><th>  Trans., Billion </th></tr><tr><td>  Xeon KNL 7250 </td><td>  68/272 </td><td>  1.4 </td><td>  115/400 </td><td>  215 </td><td>  ~ 8 </td></tr><tr><td>  Xeon E5 2699 v3 </td><td>  18/36 </td><td>  2.3 </td><td>  68 </td><td>  145 </td><td>  ~ 5.69 </td></tr><tr><td>  Power 8+ s822lc </td><td>  10/80 </td><td>  3.5 </td><td>  205 </td><td>  270 </td><td>  ~ 6 </td></tr><tr><td>  Tesla P100 </td><td>  56/3584 </td><td>  1.4 </td><td>  40/700 </td><td>  300 </td><td>  ~ 15.3 </td></tr></tbody></table><br><p>  Recently, manufacturers are increasingly thinking about the memory bandwidth.  As a result of this, there are various solutions to the problem of slow access to RAM.  Among the platforms under consideration, two have a two-level structure of RAM. </p><br><p>  The first one is Intel KNL, which contains fast memory on a chip, the access speed to which is about 400 GB / s, and a slower DDR4 that we are used to, the access speed to which is no more than 115 GB / s.  Fast memory is quite small - only 16GB, while normal memory can be up to 384 GB.  The test server was installed 96 GB of memory.  The second platform with a hybrid solution - Power + NVidia Tesla.  This solution is based on <a href="http://www.nvidia.com/object/nvlink.html">NVlink</a> technology, which allows access to conventional memory at 40 GB / s, while fast memory is accessed at 700 GB / s.  The amount of fast memory is the same as in Intel KNL - 16GB. </p><br><p>  These solutions are similar in terms of organization ‚Äî there is a fast, small memory, and a slow, large memory.  The scenario of using two-level memory when processing large graphs is obvious: fast memory is used to store the result and intermediate arrays, whose dimensions are quite small compared to the input data, and the original graph is read from slow memory. </p><br><p>  From the point of view of implementation, the following tools are available to the user.  For Intel KNL, it is enough to use other memory allocation functions - <strong>hbm_malloc</strong> , instead of the usual <strong>malloc</strong> .  If the program used <strong>malloc</strong> statements, it is enough to declare one <strong>define</strong> in order to use this feature.  For NVidia Tesla, you must also use other memory allocation functions ‚Äî use <strong>cudaMallocHost</strong> instead of <strong>cudaMalloc</strong> .  These code modifications are sufficient and do not require any modifications in the computational part of the program. </p><br><p>  The experiments were carried out for graphs of different sizes, ranging from 2 <sup>25</sup> (4 GB) to 2 <sup>30</sup> (128 GB).  The average degree of connectivity and the type of graph were taken from the graph generator for the Graph500 rating.  This generator creates Kronecker graphs with an average degree of connectivity 16 and coefficients <strong>A = 0.57, B = 0.19, C = 0.19</strong> . </p><br><p>  This type of column is used by all participants in the rating table, which allows to correctly compare implementations with each other.  The performance value is calculated by the TEPS metric for the Graph500 table and TEPS / w for the GreenGraph500 table.  To calculate this characteristic, 64 runs of the BFS algorithm from different starting vertices are performed and the average value is taken.  To calculate the consumption of the algorithm, the current consumption of the system is taken at the time of the algorithm, taking into account the memory consumption. </p><br><p>  The following table illustrates the performance obtained in GTEPS on all graphs tested.  The table indicates two values ‚Äã‚Äã- the minimum / maximum achieved performance on each of the graphs.  Also, in the case of using Intel KNL, the results of executing the algorithm were obtained using only DDR4 memory.  Unfortunately, even with the use of all data compression algorithms, it was not possible to start a graph with 2 <sup>30</sup> vertices on Intel KNL on the server provided.  But given the stability of the Intel processors and the manufacturability of Intel compilers, it can be assumed that the performance will not change with increasing graph size (as can be seen for Intel Xeon E5). </p><br><p>  <strong>The resulting performance in GTEPS:</strong> </p><br><table><tbody><tr><th>  Graph: </th><th>  2 <sup>25</sup> </th><th>  2 <sup>26</sup> </th><th>  2 <sup>27</sup> </th><th>  2 <sup>28</sup> </th><th>  2 <sup>29</sup> </th><th>  2 <sup>30</sup> </th></tr><tr><td>  KNL 7250 </td><td>  10.7 / 30.6 </td><td>  12.9 / 41 </td><td>  8.4 / 43.3 </td><td>  4.6 / 40.2 </td><td>  6.2 / 42.6 </td><td>  N / A </td></tr><tr><td>  KNL 7250 DDR4 </td><td>  6.7 / 25.2 </td><td>  4.3 / 27 </td><td>  4.9 / 28.4 </td><td>  5.7 / 31.6 </td><td>  10.8 / 38.8 </td><td>  N / A </td></tr><tr><td>  E5 2699 v3 </td><td>  11 / 16.5 </td><td>  11.8 / 17.3 </td><td>  12.7 / 18.5 </td><td>  13.1 / 18.3 </td><td>  12.1 / 18.0 </td><td>  12.4 / 21.1 </td></tr><tr><td>  P8 + s822lc </td><td>  8.8 / 22.5 </td><td>  9.02 / 23.3 </td><td>  7.98 / 23.4 </td><td>  10.4 / 23.7 </td><td>  10.1 / 24.6 </td><td>  7.59 / 14.8 </td></tr><tr><td>  Tesla P100 </td><td>  41/282 </td><td>  99/333 </td><td>  34/324 </td><td>  50/274 </td><td>  7.2 / 61 </td><td>  6.5 / 52 </td></tr></tbody></table><br><p>  The graph below shows the average performance of the tested platforms.  You can see that Power 8+ showed not very good stability when switching from a 64 GB to 128 GB graph.  Perhaps this is due to the fact that used two socket node of two similar processors, and each processor had 128 GB of memory.  And when processing a larger graph, part of the data was placed in a memory that did not belong to the socket.  The graph also does not display the performance of the Tesla P100 on smaller graphs, since the difference between the fastest CPU device and the GPU is about 10 times.  This acceleration is sharply reduced when the graphs become so large that they do not fit in the cache and the graph is accessed via NVlink.  But, despite this limitation, the performance of the GPU still remains the most CPU of the devices.  This behavior is explained by the fact that CUDA allows better control of computing and memory access, as well as better adaptability of graphics processors to parallel computing. </p><br><img src="https://habrastorage.org/webt/4r/4h/nq/4r4hnqgljwwvone7jxs3me8l7q4.jpeg"><br><p><br>  The table below illustrates the performance obtained in GTEPS / w on all test graphs.  The table indicates the average power consumption with the average achieved performance on each of the graphs.  The sharp drop in performance and energy efficiency during the transition from graph 2 <sup>28</sup> to graph 2 <sup>29</sup> on the NVidia Tesla P100 is due to the fact that there is not enough fast memory to place the aligned part of the graph that is most frequently accessed.  If you use more memory (for example, 32 GB) and an increased communication channel with the NVlink 2.0 CPU, you can significantly improve the efficiency of processing large graphs. </p><br><p>  <strong>Energy efficiency obtained in MTEPS / w:</strong> </p><br><table><tbody><tr><th>  Graph size </th><th>  2 <sup>25</sup> </th><th>  2 <sup>26</sup> </th><th>  2 <sup>27</sup> </th><th>  2 <sup>28</sup> </th><th>  2 <sup>29</sup> </th><th>  2 <sup>30</sup> </th></tr><tr><td>  KNL 7250 </td><td>  121.4 </td><td>  149.3 </td><td>  142.33 </td><td>  136.56 </td><td>  130.96 </td><td>  N / A </td></tr><tr><td>  E5 2699 v3 </td><td>  95.56 </td><td>  98.65 </td><td>  100 </td><td>  101.9 </td><td>  91.12 </td><td>  84.46 </td></tr><tr><td>  P8 + s822lc </td><td>  93.8 </td><td>  97.04 </td><td>  93.2 </td><td>  95.28 </td><td>  92.41 </td><td>  53.23 </td></tr><tr><td>  Tesla P100 </td><td>  1228.57 </td><td>  1165.71 </td><td>  1235.96 </td><td>  1016.57 </td><td>  195.61 </td><td>  177.45 </td></tr></tbody></table><br><h1>  And finally </h1><br><p>  As a result of the work done, two parallel BFS algorithms were implemented for the CPU of similar systems and for the GPU.  A study was conducted of the performance and energy efficiency of the implemented algorithms on various platforms, such as IBM Power8 +, Intel x86, Intel Xeon Phi (KNL) and NVidia Tesla P100.  These platforms have different architectural features.  Despite this, the first three of them are very similar in structure.  Due to this, it is possible to run OpenMP applications on these platforms without any significant changes.  On the contrary, the architecture of the GPU is very different from the CPU of similar platforms and uses a different concept for the implementation of computational code - the CUDA architecture. </p><br><p>  Were considered graphs that are obtained after the generator for the Graph500 rating.  The performance of each architecture on two data classes was investigated.  The first class includes the graphs that are placed in the fastest memory of the calculator.  The second class includes large graphs that cannot be placed in fast memory as a whole.  To demonstrate energy efficiency, GreenGraph500 metrics were used.  The minimal graph, which is taken into account in the GreenGraph500 rating in the big data class, contains 2 <sup>30</sup> vertices and 2 <sup>34</sup> edges and occupies 128 GB of memory in its original form.           2 <sup>30</sup>   2 <sup>34</sup> ,        ,     . </p><br><p>          Graph500  GreenGraph500    NVidia Tesla P100         (  220 GTEPS   1235.96 MTEPS/w),       (  41.7 GTEPS   177.45 MTEPS/w).               NVLink,                 IBM   Power8+. </p><br><p>            NVidia Volta     NVlink 2.0,         . </p><br><div class="spoiler"> <b class="spoiler_title">,      (    =)</b> <div class="spoiler_text"><p> <strong>[1]</strong> EF Moore. The shortest path through a maze. In Int. Symp. on Th. <br> of Switching, pp. 285‚Äì292, 1959 <br> <strong>[2]</strong> Cormen, T., Leiserson, C., Rivest, R.: Introduction to Algorithms. MIT Press, <br> Cambridge (1990) <br> <strong>[3]</strong> Edmonds, J., Karp, RM: Theoretical improvements in algorithmic efficiency for <br> network flow problems. Journal of the ACM 19(2), 248‚Äì264 (1972) <br> <strong>[4]</strong> Brandes, U.: A Faster Algorithm for Betweenness Centrality. J. Math. Sociol. 25(2), <br> 163‚Äì177 (2001) <br> <strong>[5]</strong> Frasca, M., Madduri, K., Raghavan, P.: NUMA-Aware Graph Mining Techniques <br> for Performance and Energy Efficiency. In: Proc. ACM/IEEE Int. Conf. High Performance <br> Computing, Networking, Storage and Analysis (SC 2012), pp. 1‚Äì11. IEEE <br> Computer Society (2012) <br> <strong>[6]</strong> Girvan, M., Newman, MEJ: Community structure in social and biological networks. <br> Proc. Natl. Acad. Sci. USA 99, 7821‚Äì7826 (2002) <br> <strong>[7]</strong> DA Bader and K. Madduri. Designing multithreaded algorithms for <br> breadth-first search and st-connectivity on the Cray MTA-2. In ICPP, <br>  pp. 523‚Äì530, 2006. <br> <strong>[8]</strong> RE Korf and P. Schultze. Large-scale parallel breadth-first search. <br> In AAAI, pp. 1380‚Äì1385, 2005. <br> <strong>[9]</strong> A. Yoo, E. Chow, K. Henderson, W. McLendon, B. Hendrickson, and <br> U. Catalyurek. A scalable distributed parallel breadth-first search <br> algorithm on BlueGene/L. In SC '05, p. 25, 2005. <br> <strong>[10]</strong> Y. Zhang and EA Hansen. Parallel breadth-first heuristic search on a shared-memory architecture. In AAAI Workshop on Heuristic <br> Search, Memory-Based Heuristics and Their Applications, 2006. <br> <strong>[11]</strong> Yasui Y., Fujisawa K., Sato Y. (2014) Fast and Energy-efficient Breadth-First Search on a Single NUMA System. In: Kunkel JM, Ludwig T., Meuer HW (eds) Supercomputing. ISC 2014. Lecture Notes in Computer Science, vol 8488. Springer, Cham <br> <strong>[12]</strong> Hiragushi T., Takahashi D. (2013) Efficient Hybrid Breadth-First Search on GPUs. In: Aversa R., Ko≈Çodziej J., Zhang J., Amato F., Fortino G. (eds) Algorithms and Architectures for Parallel Processing. ICA3PP 2013. Lecture Notes in Computer Science, vol 8286. Springer, Cham <br> <strong>[13]</strong> Merrill, D., Garland, M., Grimshaw, A.: Scalable GPU graph traversal. In: Proc. 17th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming (PPoPP 2012), pp. 117‚Äì128 (2012) </p></div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/344378/">https://habr.com/ru/post/344378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344368/index.html">React, Drag & Drop and performance</a></li>
<li><a href="../344370/index.html">Check Point Instructions and Useful Documentation</a></li>
<li><a href="../344372/index.html">Overview of Fujitsu PRIMERGY TX1330 M3 floor server</a></li>
<li><a href="../344374/index.html">Case SMS working on customer loyalty</a></li>
<li><a href="../344376/index.html">Vulnerability found in all versions of Windows, which does not close any antivirus</a></li>
<li><a href="../344380/index.html">Introducing dependencies in .Net Mark Siman 2 - Implementing a constructor, lifetime</a></li>
<li><a href="../344382/index.html">How we created a password manager with strong cryptography and a master password. Experience team Yandex. Browser</a></li>
<li><a href="../344384/index.html">Authentication and authorization in Ember, Part 1: ember library simple auth</a></li>
<li><a href="../344386/index.html">Formula 1 for drones: ITMO University team ranked first at Robotex-2017</a></li>
<li><a href="../344388/index.html">ASO Monthly # 19 November 2017</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>