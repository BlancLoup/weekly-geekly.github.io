<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The art of writing simple and short functions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The software is constantly becoming more complex. The stability and ease of extending the application is directly dependent on the quality of the code...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The art of writing simple and short functions</h1><div class="post__text post__text-html js-mediator-article"><p>  The software is constantly becoming more complex.  The stability and ease of extending the application is directly dependent on the quality of the code. </p><br><p>  Unfortunately, almost every developer, including myself, in his work faces a code of poor quality.  And this is a swamp.  This code has toxic signs: </p><br><ul><li>  Functions too long and too many tasks </li><li>  Often functions have side effects that are difficult to determine, and sometimes even difficult to debug. </li><li>  Unclear names for functions and variables </li><li>  Fragile code: a small modification unexpectedly breaks other components of the application. </li><li>  Bad test code coverage or none at all </li></ul><br><p>  Everyone is familiar with the statements ‚ÄúI don‚Äôt understand how this code works,‚Äù ‚Äúcrazy code‚Äù, ‚Äúthis code is difficult to change‚Äù and others. </p><br><p>  One day, my colleague quit because he was trying to cope with a Ruby REST API that was difficult to maintain.  He received this project from a previous development team. </p><br><p>  Correction of current errors created new ones, adding new functions gave rise to a new series of errors, and so on (fragile code).  The client did not want to rebuild the application, make it a convenient structure, and the developer made the right decision - to quit. </p><br><p><img src="https://habrastorage.org/files/71d/da6/7ae/71dda67ae918424b933c7fd217cd8a47.jpg"></p><br><p>  Such situations happen often, and this is sad.  But what to do? <a name="habracut"></a></p><br><p>  First, remember: create a working application and take care of the quality of the code - different tasks. </p><br><p>  On the one hand, you implement the requirements of the application.  But on the other hand, you have to spend time and check if too many tasks hang on any function, give meaningful names to variables and functions, avoid functions with side effects and so on. </p><br><p>  Functions (including object methods) are small gears that make an application work.  At the beginning you should focus on their structure and composition.  The article covers the best approaches, how to write simple, understandable and easily testable functions. </p><br><h1>  1. Functions must be small.  Very small. </h1><br><p>  Avoid bloated functions that have a lot of tasks, it is better to do a few small functions.  Bloated functions with hidden meaning are difficult to understand, modify, and, especially, test. </p><br><p>  Imagine a situation where a function must return the sum of the elements of an array, a map, or a simple JavaScript object.  The amount is calculated by folding the property values: </p><br><ul><li> 1 point for <code>null</code> or <code>undefined</code> </li><li>  2 points for the primitive type </li><li>  4 points for an object or feature </li></ul><br><p>  For example, the sum of the array <code>[null, 'Hello World', {}]</code> calculated as follows: <code>1</code> (for <code>null</code> ) + <code>2</code> (for the string, primitive type) + <code>4</code> (for the object) = <code>7</code> . </p><br><h2>  Step 0: Primary Large Function </h2><br><p>  Let's start with the worst method.  The idea is to write code with one big function <code>getCollectionWeight()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCollectionWeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">collection</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> collectionValues; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collection <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>) { collectionValues = collection; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collection <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>) { collectionValues = [...collection.values()]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { collectionValues = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(collection).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection[key]; }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collectionValues.reduce(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sum, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (item == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> item === <span class="hljs-string"><span class="hljs-string">'object'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> item === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum + <span class="hljs-number"><span class="hljs-number">4</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum + <span class="hljs-number"><span class="hljs-number">2</span></span>; }, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myArray = [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, { }, <span class="hljs-number"><span class="hljs-number">15</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>([ [<span class="hljs-string"><span class="hljs-string">'functionKey'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}] ]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myObject = { <span class="hljs-string"><span class="hljs-string">'stringKey'</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello world'</span></span> }; getCollectionWeight(myArray); <span class="hljs-comment"><span class="hljs-comment">// =&gt; 7 (1 + 4 + 2) getCollectionWeight(myMap); // =&gt; 4 getCollectionWeight(myObject); // =&gt; 2</span></span></code> </pre> <br><p>  The problem is clearly visible.  The <code>getCollectionWeight()</code> function is too bloated and looks like a black box full of surprises. </p><br><p>  Most likely, at first glance it is difficult for you to understand what her task is.  And imagine a set of such functions in the application. </p><br><p>  When you work with such a code, you waste time and effort.  A quality code will not cause you discomfort.  High-quality code with short and silent functions is nice to read and easy to maintain. </p><br><p><img src="https://habrastorage.org/files/81b/ccb/167/81bccb16759d4540903f69f4601e146f.png"></p><br><h2>  Step 1: Extract the weight by type and eliminate the magic numbers </h2><br><p>  Now the goal is to break the long function into small, independent and reusable ones.  The first step is to extract the code that determines the sum of the value by its type.  This new function will be called <code>getWeight()</code> . </p><br><p>  Also note the magic numbers of this amount: <code>1</code> , <code>2</code> and <code>4</code> .  Just reading these numbers, without understanding the whole story, does not provide useful information.  Fortunately, ES2015 allows you to declare <code>const</code> as read-only, so you can easily create constants with meaningful names and eliminate magic numbers. </p><br><p>  Let's create a small <code>getWeightByType()</code> function and at the same time improve <code>getCollectionWeight()</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Code extracted into getWeightByType() function getWeightByType(value) { const WEIGHT_NULL_UNDEFINED = 1; const WEIGHT_PRIMITIVE = 2; const WEIGHT_OBJECT_FUNCTION = 4; if (value == null) { return WEIGHT_NULL_UNDEFINED; } if (typeof value === 'object' || typeof value === 'function') { return WEIGHT_OBJECT_FUNCTION; } return WEIGHT_PRIMITIVE; } function getCollectionWeight(collection) { let collectionValues; if (collection instanceof Array) { collectionValues = collection; } else if (collection instanceof Map) { collectionValues = [...collection.values()]; } else { collectionValues = Object.keys(collection).map(function (key) { return collection[key]; }); } return collectionValues.reduce(function(sum, item) { return sum + getWeightByType(item); }, 0); } let myArray = [null, { }, 15]; let myMap = new Map([ ['functionKey', function() {}] ]); let myObject = { 'stringKey': 'Hello world' }; getCollectionWeight(myArray); // =&gt; 7 (1 + 4 + 2) getCollectionWeight(myMap); // =&gt; 4 getCollectionWeight(myObject); // =&gt; 2</span></span></code> </pre> <br><p>  Does it look better? </p><br><p>  The <code>getWeightByType()</code> function is an independent component that simply determines the sum by type.  And it is reusable because it can be executed within any other function. </p><br><p>  <code>getCollectionWeight()</code> becomes a bit more lightweight </p><br><p>  <code>WEIGHT_NULL_UNDEFINED</code> , <code>WEIGHT_PRIMITIVE</code> and <code>WEIGHT_OBJECT_FUNCTION</code> are non-explanatory constants that describe types of sums.  You do not need to guess what the numbers <code>1</code> , <code>2</code> and <code>4</code> mean. </p><br><h2>  Step 2: Continue the separation and make the functions extensible. </h2><br><p>  The updated version still has flaws. </p><br><p>  Imagine that you have a plan to implement a comparison of the values ‚Äã‚Äãof a Set or another arbitrary collection.  <code>getCollectionWeight()</code> will quickly grow in size, as its logic is to collect values. </p><br><p>  Let's extract the code that collects the values ‚Äã‚Äãfrom the <code>getMapValues‚Äã‚Äã()</code> map and simple <code>getMapValues‚Äã‚Äã()</code> JavaScript objects into separate functions.  Look at the improved version: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeightByType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WEIGHT_NULL_UNDEFINED = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WEIGHT_PRIMITIVE = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WEIGHT_OBJECT_FUNCTION = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEIGHT_NULL_UNDEFINED; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">'object'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEIGHT_OBJECT_FUNCTION; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEIGHT_PRIMITIVE; } <span class="hljs-comment"><span class="hljs-comment">// Code extracted into getMapValues() function getMapValues(map) { return [...map.values()]; } // Code extracted into getPlainObjectValues() function getPlainObjectValues(object) { return Object.keys(object).map(function (key) { return object[key]; }); } function getCollectionWeight(collection) { let collectionValues; if (collection instanceof Array) { collectionValues = collection; } else if (collection instanceof Map) { collectionValues = getMapValues(collection); } else { collectionValues = getPlainObjectValues(collection); } return collectionValues.reduce(function(sum, item) { return sum + getWeightByType(item); }, 0); } let myArray = [null, { }, 15]; let myMap = new Map([ ['functionKey', function() {}] ]); let myObject = { 'stringKey': 'Hello world' }; getCollectionWeight(myArray); // =&gt; 7 (1 + 4 + 2) getCollectionWeight(myMap); // =&gt; 4 getCollectionWeight(myObject); // =&gt; 2</span></span></code> </pre> <br><p>  <code>getCollectionWeight()</code> reading <code>getCollectionWeight()</code> it's much easier for you to understand what this function does.  Looks like an interesting story. </p><br><p>  Each function is obvious and intelligible.  You do not waste time trying to understand what such code does.  That's how clean it should be. </p><br><h3>  Step 3: Never stop improving </h3><br><p>  Even at this stage you have many opportunities for quality improvement! </p><br><p>  You can create a separate <code>getCollectionValues‚Äã‚Äã()</code> that contains if / else statements and differentiates the types of collections: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCollectionValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">collection</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collection <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collection <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMapValues(collection); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPlainObjectValues(collection); }</code> </pre> <br><p>  Then <code>getCollectionWeight()</code> becomes really simple, because the only thing to do is to get the values ‚Äã‚Äãof the <code>getCollectionValues‚Äã()</code> collection and apply a sum reducer to it. </p><br><p>  You can also create a separate shortcut function: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceWeightSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sum, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum + getWeightByType(item); }</code> </pre> <br><p>  Because ideally, <code>getCollectionWeight()</code> should not define functions. </p><br><p>  In the end, the initial big function turns into small: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWeightByType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WEIGHT_NULL_UNDEFINED = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WEIGHT_PRIMITIVE = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WEIGHT_OBJECT_FUNCTION = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEIGHT_NULL_UNDEFINED; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">'object'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> value === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEIGHT_OBJECT_FUNCTION; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WEIGHT_PRIMITIVE; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMapValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [...map.values()]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPlainObjectValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(object).map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">key</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> object[key]; }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCollectionValues</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">collection</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collection <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collection <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getMapValues(collection); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPlainObjectValues(collection); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reduceWeightSum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">sum, item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum + getWeightByType(item); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCollectionWeight</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">collection</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getCollectionValues(collection).reduce(reduceWeightSum, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myArray = [<span class="hljs-literal"><span class="hljs-literal">null</span></span>, { }, <span class="hljs-number"><span class="hljs-number">15</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myMap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Map</span></span>([ [<span class="hljs-string"><span class="hljs-string">'functionKey'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}] ]); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myObject = { <span class="hljs-string"><span class="hljs-string">'stringKey'</span></span>: <span class="hljs-string"><span class="hljs-string">'Hello world'</span></span> }; getCollectionWeight(myArray); <span class="hljs-comment"><span class="hljs-comment">// =&gt; 7 (1 + 4 + 2) getCollectionWeight(myMap); // =&gt; 4 getCollectionWeight(myObject); // =&gt; 2</span></span></code> </pre> <br><p>  This is the art of creating small and simple functions! </p><br><p>  After all the optimization of the quality of the code, a handful of good benefits appear: </p><br><ul><li>  <strong>Readability</strong> <code>getCollectionWeight()</code> simplified thanks to the code that does not require explanation </li><li>  <code>getCollectionWeight()</code> <strong>size</strong> has decreased significantly </li><li>  The <code>getCollectionWeight()</code> function is now <strong>protected from rapid growth</strong> if you want to implement work with other types of collections. </li><li>  The extracted functions are now <strong>ungrouped and reusable</strong> components.  Your colleague may ask you to import these nice features into another project, and you can easily do this. </li><li>  If by chance a function generates an error, <strong>the call stack will be more accurate</strong> because it contains the names of the functions.  Almost immediately you can find a function that creates problems. </li><li>  Separated functions are much <strong>easier to test</strong> and achieve a high level <strong>of</strong> code <strong>coverage with</strong> tests.  Instead of testing one bloated function with all possible scenarios, you can structure the tests and test each small function separately. </li><li>  You can use the CommonJS or ES2015 module format.  Create <strong>separate modules</strong> from extracted functions.  This will make your project files light and structured. </li></ul><br><p>  These benefits will help you survive in the complex structure of applications. <br><img src="https://habrastorage.org/files/6ba/cc8/e5b/6bacc8e5bf674432ba20421af70d2c97.png"><br>  The general rule is that functions should not exceed 20 lines of code.  Less is better. </p><br><p>  I think you now have a fair question: <em>‚ÄúI don‚Äôt want to create a function for each line of code.</em>  <em>Are there any criteria when to stop? ‚Äù</em> This is the topic of the next chapter. </p><br><h1>  2. Functions should be simple </h1><br><p>  Let's get a little distracted and think about what an application is? </p><br><p>  Each application implements a set of requirements.  The task of the developer is to divide these requirements into small executable components (scopes, classes, functions, blocks of code) that perform well-defined operations. </p><br><p>  The component consists of other smaller components.  If you want to write code for a component, you need to create it from components of only the previous level of abstraction. </p><br><p>  In other words, it is necessary to decompose the function into smaller steps, but all of them should be on the same, previous, level of abstraction.  This is important because the function becomes simple and implies "the accomplishment of one task, and the execution is qualitative." </p><br><p>  What is the need?  Simple functions are obvious.  Evidence means easy reading and modification. </p><br><p>  Let's try to follow the example.  Suppose you want to implement a function that stores only the prime numbers (2, 3, 5, 7, 11, etc.) of the array and removes the rest (1, 4, 6, 8, etc.).  The function is called like this: </p><br><pre> <code class="javascript hljs">getOnlyPrime([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// =&gt; [2, 3, 5, 11]</span></span></code> </pre> <br><p>  What steps of the previous level of abstraction are needed to implement the <code>getOnlyPrime()</code> function?  Let's formulate this: </p><br><blockquote>  To implement <code>getOnlyPrime()</code> filter the array of numbers using the <code>IsPrime()</code> function. </blockquote><p>  Simply apply the <code>IsPrime()</code> filter <code>IsPrime()</code> to the array. </p><br><p>  Is it necessary to implement <code>IsPrime()</code> details at this level?  No, because then the <code>getOnlyPrime()</code> function will have steps from a different level of abstractions.  The function will take on too many tasks. </p><br><p>  Without forgetting this simple idea, let's implement the body of the <code>getOnlyPrime()</code> function: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOnlyPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">numbers</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> numbers.filter(isPrime); } getOnlyPrime([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// =&gt; [2, 3, 5, 11]</span></span></code> </pre> <br><p>  As you can see, <code>getOnlyPrime()</code> is an elementary function.  It contains steps from one level of abstraction: the <code>.filter()</code> method and <code>IsPrime()</code> . </p><br><p>  Now it's time to move to the previous level of abstraction. </p><br><p>  The array <code>.filter()</code> method is included in JavaScript and is used as is.  Of course, the standard describes exactly what the method does. </p><br><p>  Now you can specify how <code>IsPrime()</code> will be implemented: </p><br><blockquote>  To implement the <code>IsPrime()</code> function, which checks whether the number n is simple, you need to check whether n is divisible by any number from <code>2</code> to <code>Math.sqrt(n)</code> without a remainder. </blockquote><p>  Let's write the code for the <code>IsPrime()</code> function using this algorithm (it's not efficient yet, I used it for simplicity): </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">number</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number === <span class="hljs-number"><span class="hljs-number">3</span></span> || number === <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number === <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> divisor = <span class="hljs-number"><span class="hljs-number">2</span></span>; divisor &lt;= <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(number); divisor++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (number % divisor === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOnlyPrime</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">numbers</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> numbers.filter(isPrime); } getOnlyPrime([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>]); <span class="hljs-comment"><span class="hljs-comment">// =&gt; [2, 3, 5, 11]</span></span></code> </pre> <br><p>  <code>getOnlyPrime()</code> is small and elementary.  It only strictly necessary steps of the previous level of abstraction. </p><br><p>  Reading complex functions can be greatly simplified by following the rule to make them obvious.  If the code of each level of abstraction is written pedantically, it will prevent the generation of large pieces of uncomfortable code. </p><br><h1>  3. Use compact function names. </h1><br><p>  Function names must be compact: no more and no less.  Ideally, the name should clearly indicate what the function does, without having to rummage through the implementation details. </p><br><p>  For function names, use the camel case format, which begins with a small letter: <code>addItem()</code> , <code>saveToStore()</code> or <code>getFirstName()</code> . </p><br><p>  Since a function is an action, its name must contain at least one verb.  For example, <code>deletePage()</code> , <code>verifyCredentials()</code> .  To get or set a property, use the prefixes set and get: <code>getLastName()</code> or <code>setLastName()</code> . </p><br><p>  In production, avoid confusing names like <code>Foo()</code> , <code>bar()</code> , <code>()</code> , <code>fun()</code> and the like.  Such names do not make sense. </p><br><p>  If the functions are small and simple, and the names are compact: the code reads like a good book. </p><br><h1>  4. Conclusion </h1><br><p>  Of course, the examples given are straightforward.  Applications that exist in reality are more complex.  You can complain that writing simple functions of the previous level of abstraction is a tedious task.  But it is not so laborious if you do it from the very beginning of the project. </p><br><p>  If the application already has functions that are too bloated, it will most likely be difficult to rebuild the code.  And in many cases it is impossible in reasonable time intervals.  Begin, at least with small: extract what you can. </p><br><p>  Of course, the right decision is to implement the application correctly from the very beginning.  And invest time not only in the implementation, but also in the correct structure of functions: to make them small and simple. </p><br><blockquote>  Seven times measure cut once. </blockquote><p><img src="https://habrastorage.org/files/b35/e1a/104/b35e1a104bfc474c95118978003969e0.jpg"></p><br><p>  In ES2015, a good modular system is implemented, which clearly shows that small functions are good practice. </p><br><p>  Just remember that clean and organized code <strong>always takes an investment of time</strong> .  You may be difficult.  You may need to practice for a long time.  You can go back and change functions several times. </p><br><p>  There is nothing worse than a dirty code. </p><br><p>  What methods do you use to make the code organized? </p><br><p>  <em>(Translation by <a href="https://www.instagram.com/minotauria/">Natalia Bass</a> )</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/310590/">https://habr.com/ru/post/310590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310580/index.html">September 24, we invite you to the conference MIXAR 2016 - non-classical conference on the latest technologies</a></li>
<li><a href="../310582/index.html">Automation of measurement of generator harmonic ratio using a digital oscilloscope and MATLAB</a></li>
<li><a href="../310584/index.html">Mission is feasible: how to develop DevOps in a company with many projects</a></li>
<li><a href="../310586/index.html">Use the ‚ÄúGame of Thrones‚Äù lessons when developing strategies for your startup.</a></li>
<li><a href="../310588/index.html">Alan Kay: The future of "reading" depends on the future of "learning difficult to understand things"</a></li>
<li><a href="../310592/index.html">A series of interface updates "Habrahabra" and Geektimes</a></li>
<li><a href="../310594/index.html">Authorization using Facebook and Vkontakte in a one-page application on Backbonejs + Express</a></li>
<li><a href="../310596/index.html">Distributed monitoring: the next expansion of the HostTracker service network</a></li>
<li><a href="../310598/index.html">To the question of the order of operators</a></li>
<li><a href="../310600/index.html">What colors use the most popular sites?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>