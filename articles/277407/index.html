<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Evaluation and optimization of computing performance on multi-core systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This publication is a translation of the first part of the article Characterization and Optimization Methodology of Applied to Stencil Computations of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Evaluation and optimization of computing performance on multi-core systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/2b6/cc6/bb8/2b6cc6bb87784080898e3068efb458a3.jpg"><br>  This publication is a translation of the first part of the article <a href="https://www.researchgate.net/publication/285433271_Characterization_and_Optimization_Methodology_Applied_to_Stencil_Computations">Characterization and Optimization Methodology of Applied to Stencil Computations</a> of Intel engineers.  This part is devoted to analyzing the performance and building a roofline model on the example of a fairly common computing core, which allows you to evaluate the prospects for optimizing the application on this platform. <br><a name="habracut"></a><br>  <a href="https://habrahabr.ru/company/intel/blog/279669/">The next part</a> will describe what optimizations have been applied in order to get closer to the expected performance value.  The optimization techniques described in this article include, for example: <br><ul><li>  scalable parallelization (collaborative thread blocking) </li><li>  memory bandwidth increase (cache blocking, register reuse) </li><li>  increase in processor performance (vectorization, repartitioning cycles). </li></ul><br>  In the third part of the article, an algorithm will be described that allows you to automatically select the optimal parameters for launching and building an application.  These parameters are usually associated with changes in the source code of the program (for example, loop blocking values), with parameters for the compiler (for example, the cycle sweep factor) and characteristics of the computing system (for example, cache sizes).  The resulting algorithm turned out to be faster than traditional heavyweight search techniques.  From the simplest implementation to the most optimized, a 6-fold performance improvement was obtained on the Intel Xeon E5-2697v2 processor and approximately 3-fold on the first-generation Intel Xeon Phi coprocessors.  In addition to this, the above automatic tuning methodology chooses the optimal launch parameters for any set of input data. <br><br><img src="https://habrastorage.org/files/916/ae7/22c/916ae722c647478187364db7ff027d91.png" alt="image"><br>  <i>Figure 1. Roofline model Iso3DFD for Ivy Bridge 2S E5-2697 v2.</i>  <i>Red and light green lines represent the upper theoretical and achievable limit on the current platform, respectively.</i>  <i>The horizontal blue line reflects the maximum achievable memory bandwidths taking into account a certain imbalance between additions and multiplications (#ADD; #MUL) and averaged with the help of Stream triad benchmark (horizontal brown line).</i>  <i>The vertical dark green line corresponds to the arithmetic intensity for the core of the Iso3DFD algorithm.</i>  <i>Intersections with the remaining lines give the corresponding achievable limits.</i> <br><br><h2>  <font color="#0071c5">Short review</font> </h2><br>  The article describes the characterization (note of the translator - characterization - identification of characteristic features) and the optimization methodology of the 3D finite difference algorithm (3DFD), which is used to solve an acoustic wave equation with a constant or variable density of an isotropic medium (Iso3DFD).  Starting with the simplest implementation of 3DFD, we describe a methodology for estimating the best performance that can be obtained for a given algorithm, using its characterization on a specific computing system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#0071c5">Introduction</font> </h2><br>  The finite difference method in the time domain is a widely used technique for modeling waves, for example, for the analysis of wave phenomena and seismic exploration.  This method is popular when using seismic analysis techniques such as reverse time migration and full waveform inversion.  Varieties of the method include treating the waves as acoustic or elastic, and the propagation medium may be anisotropic, while the density may also vary. <br><br>  As is known, the choice of a specific numerical scheme for approximation of partial derivatives has a strong influence on the performance of the implementation [1].  In particular, this affects the arithmetic intensity (the number of operations with a floating point per each transmitted machine word) of the 3DFD algorithm.  This arithmetic intensity can be further linked to the expected performance using the roofline modeling methodology [2].  This methodology allows us to estimate the level of performance of the implementation with respect to the maximum achievable on a specific computing system.  That is, the roofline model sets the framework for productivity growth that can be achieved by optimizing the source code of the program.  After the performance of the implementation has reached a certain level, a further increase in productivity can only be obtained by changing the algorithm itself. <br><br>  For any given computer, its specification defines <u>peak</u> values ‚Äã‚Äãfor the number of floating-point operations (FLOP / s) and for sending data from memory to memory (memory bandwidth).  The corresponding maximum <u>achievable</u> performance can be obtained by running standard benchmarks like LINPACK [3] and STREAM triad [4]. <br><br>  The first part of the article will be aimed at assessing the maximum achievable performance of the Iso3DFD algorithm core on a two-socket server and coprocessor.  Next, we describe several techniques that can have an important impact on performance.  As usual, such optimizations may require some effort and modification of the source code.  After that, we will show an auxiliary tool for finding, if not the best, then to some extent the optimal set of parameters for compiling and running the application. <br><br><img src="https://habrastorage.org/files/a1c/e71/c27/a1ce71c27bb74b6ea212d68e5bf51489.png" alt="image"><br>  <i>Figure 2. Roofline model Iso3DFD for the Xeon Phi 7120P coprocessor.</i>  <i>Red and light green lines represent the upper theoretical and achievable limit on the current platform, respectively.</i>  <i>The horizontal blue line reflects the maximum achievable memory bandwidths, taking into account a certain imbalance between additions and multiplications (#ADD; #MUL) and averaged using Stream triad benchmark (horizontal brown line).</i>  <i>The vertical dark green line corresponds to the arithmetic intensity for the core of the Iso3DFD algorithm.</i>  <i>Intersections with the remaining lines give the corresponding achievable limits.</i> <br><br><h2>  <font color="#0071c5">Performance evaluation</font> </h2><br>  Our core of the Iso3DFD algorithm solves the acoustic isotropic wave equation 16 of the order of discretization in space and 2 of the order of discretization in time.  The standard implementation of this 3DFD kernel usually reaches less than 10% of the peak performance of the computing system on floating point operations per second (FLOP / s).  We will consider a method for obtaining the roofline model [2] for the Iso3DFD computational core on the CPU and on the Xeon Phi coprocessor.  To find the maximum performance of this application, we need to find: <br><ul><li>  Peak performance and memory bandwidths (theoretical): 2420 GFLOP / s in single precision and 352 GB / s for Intel Xeon Phi 7120A;  1036 GFLOP / s in single precision and 119 GB / s for 2 Intel Xeon E5-2697v2 processors with 1866 MHz DDR3 memory. </li><li>  The values ‚Äã‚Äãobtained on Linpack (or GEMM) and STREAM triad benchmarks give us the corresponding maximum performance on the platform: 2178 GFLOP / s and 200 GB / s for Intel Xeon Phi 7120A;  930 GFLOP / s and 100 GB / s for 2 Intel Xeon E5-2697v2 processors with 1866 MHz DDR3 memory. </li><li>  The arithmetic intensity of the application is calculated based on the number of additions and multiplications (ADD, MUL) of floating-point numbers and the number of bytes sent from memory and a certain number of downloads and records in memory (LOAD, STORE). </li></ul><br><br>  The last point follows from the assumption that the computing system has a cache with infinite memory bandwidth and size, and also has zero latency for data access.  This defines a kind of flawless memory subsystem, where any array is fully loaded, even if only 1 item is required. <br><br>  Several other factors may also affect the performance of the entire application using the 3DFD core ‚Äî the choice of boundary conditions, the IO scheme when addressed in time, and the technology or model of parallel programming.  However, in the analysis presented here, we do not consider the boundary conditions and IO.  A parallel implementation of the solution to this problem uses the domain decomposition method for distributed systems using the MPI standard along with parallelism on threads on a compute node using OpenMP.  In this paper, we consider computations in a subdomain on a single node of a computer system. <br><br><h6>  Platform arithmetic intensity </h6><br>  Our test system consists of two Xeon E5-2697 CPUs (2S-E5) with 12 cores per CPU, each running at 2.7 GHz without turbo mode.  These processors support the AVX extension of a 256-bit wide vector register instruction set.  These instructions can perform calculations with 8 single-point floating-point numbers (32 bits) simultaneously (per CPU clock cycle).  Thus, the theoretical peak performance can be calculated as 2.7 (GHz) x 8 (SP FP) x 2 (ADD / MULL) x 12 (cores) x 2 (CPUs) = 1036.8 GFLOP / s.  Peak bandwidth is calculated using the memory frequency (1866 GHz), the number of memory channels [4], the number of bytes sent per cycle (8), which gives 1866 x 4 x 8 x 2 (CPUs) = 119 GB / s for a dual-processor node 2S-E5.  Also, we need to evaluate the achievable values ‚Äã‚Äãof throughput and performance to characterize the behavior of the application.  As a first approximation, let us assume that the performance of any real application can be limited by the memory bandwidth (totally bandwidth bound), which in this paper is estimated using Stream triad or processor speed (totally FLOP / s bound or compute bound or CPU bound), which shows the linpack benchmark.  The choice of these two benchmarks is purely hypothetical, but we can argue that if they are far from ideal estimates, then surely they are better suited as an approximation than the peak theoretical values ‚Äã‚Äãof the computing system. <br><br>  On the 2S-E5, the Linpack system gives 930 GFLOP / s, and a Stream triad 100 GB / s.  Then we can calculate the arithmetic intensity (AI) for theoretical and real maximum indicators, respectively, as: <br>  AI (theoretical, CPU) = 1036.8 / 119 = 8.7 FLOP / byte <br>  AI (achievable, CPU) = 930/100 = 9.3 FLOP / byte <br><br>  With these values, we can characterize any computational core as follows: if the arithmetic intensity of the core is more (less) than 9.3 FLOP / byte, we can say that this core is limited by the processor speed - CPU bound (memory bandwidth). <br><br>  Similar calculations for Linpack and Stream triad for Xeon Phi give 2178 GFLOP / s and 200 GB / s, respectively.  The theoretical peak ratings are 2420 GFLOP / s and 352 GB / s.  Thus, the arithmetic intensity will be equal to: <br>  AI (theoretical, Phi) = 2420.5 / 352 = 6.87 FLOP / byte <br>  AI (achievable, Phi) = 2178/200 = 10.89 FLOP / byte <br><br><h6>  Arithmetic intensity of the computational core </h6><br>  Roofline model also requires the calculation of the arithmetic intensity of this application.  It can be obtained by counting the number of arithmetic operations and memory accesses by visually inspecting the code or using special tools that have access to the counters of the computing system.  In the framework of the standard computational kernel of the finite difference scheme [5], we can find 4 downloads (coeff, prev, next, vel), 1 entry (next), 51 addition (calculations of indices are not taken into account) and 27 multiplications (Figure 3). <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bz=HALF_LENGTH; bz&lt;n3; bz+=n3_Tblock) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> by=HALF_LENGTH; by&lt;n2; by+=n2_Tblock) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bx=HALF_LENGTH; bx&lt;n1; bx+=n1_Tblock) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> izEnd = MIN(bz+n3_Tblock, n3); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iyEnd = MIN(by+n2_Tblock, n2); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ixEnd = MIN(n1_Tblock, n1-bx); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iz=bz; iz&lt;izEnd; iz++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iy=by; iy&lt;iyEnd; iy++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>* next = ptr_next_base + iz*n1n2 + iy*n1 + bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>* prev = ptr_prev_base + iz*n1n2 + iy*n1 + bx; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>* vel = ptr_vel_base + iz*n1n2 + iy*n1 + bx; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ix=<span class="hljs-number"><span class="hljs-number">0</span></span>; ix&lt;ixEnd; ix++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> value = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; value += prev[ix]*coeff[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ir=<span class="hljs-number"><span class="hljs-number">1</span></span>; ir&lt;=HALF_LENGTH; ir++) { value += coeff[ir] * (prev[ix + ir] + prev[ix - ir]) ; value += coeff[ir] * (prev[ix + ir*n1] + prev[ix - ir*n1]); value += coeff[ir] * (prev[ix + ir*n1n2] + prev[ix - ir*n1n2]); } next[ix] = <span class="hljs-number"><span class="hljs-number">2.0f</span></span>* prev[ix] - next[ix] + value*vel[ix]; } }}}</code> </pre> <br>  Figure 3. Computing kernel source code with cache blocking <br><br>  Arithmetic intensity can be calculated by the formula: <br><br>  AI = (#ADD + #MUL) / ((#LOAD + #STORE) x word size) (1) <br><br>  This gives an arithmetic intensity of 3.9 FLOP / byte, which we multiply by the theoretical capacity of each platform to obtain the first estimate of the maximum achievable performance for this algorithm.  We get 1372.8 GFLOP / s on Xeon Phi and 461.1 GFLOP / s on 2S-E5.  However, the theoretical peak performance value implies the parallel use of two pipelines (one for ADD, the other for MUL), which is impossible in this computational core due to an imbalance between additions and multiplications, thus, this code cannot achieve this estimated maximum value.  This means that the achievable maximum value should be averaged using: <br><br>  (#ADD + #MUL) / (2 x max (add, mul)), (2) <br><br>  which reflects the ratio of the total possible number of operations for 16 operations with a floating point per cycle (ops / cycle) and the maximum number of additions and multiplications that are performed at 8 ops / cycle, assuming the use of one 256-bit AVX SIMD computing unit.  This will give a theoretical estimate of peak performance, taking into account the imbalance of additions and multiplications. <br>  Figures 1 and 2 show a Roofline model with upper bounds of 354.9 GFLOP / s and 1049.8 GFLOP / s for 2S-E5 and Xeon Phi, respectively, obtained using this averaged version of arithmetic intensity. <br>  A more realistic roofline model can be obtained by using the bandwidth of the Stream triad bandwidth by the arithmetic intensity of the computational core (390 GFLOP / s and 780 GFLOP / s, respectively).  An even more realistic model can be obtained if we take into account a certain imbalance of additions and multiplications (with the help of (2)), which is indicated by the red dotted line.  The new upper bound will be around 298 GFLOP / s for 2S-E5 and 596 GFLOP / s for Xeon Phi.  Since our model is based on an impeccable cache model, we assume that the resulting values ‚Äã‚Äãare still a rough estimate of the maximum achievable performance values.  As demonstrated in [2], the resulting roofline can be improved by adding some new entities to the characterization of the computing system, such as the effect and limitations of the cache memory. <br><br>  To be continued‚Ä¶ <br><br><h5>  Bibliography </h5><br><ol><li>  D. Imbert, K. Immadouedine, P. Thierry, H. Chauris, and L. Borges, ‚ÄúTips and tricks for finite difference,‚Äù in Expanded Abstracts.  Soc.  Expl.  Geophys., 2011, pp.  3174-3178. </li><li>  S. Williams, A. Waterman, and D. Patterson, ‚ÄúRoadmap to Dependable Software, vol.  52, pp.  65‚Äì76, April 2009. </li><li>  J. Dongarra, P. Luszczek, and A. Petitet, ‚ÄúThe linpack benchmark: past, present and future,‚Äù Concurrency and Computation: Practice and Experience, vol.  15, no.  9, pp.  803-820, 2003, doi: 10.1002 / cpe.728. </li><li>  JD McCalpin, ‚ÄúStream: Sustainable Memory Bandwidth,‚Äù University of Virginia, Charlottesville, Virginia, Tech.  Rep., 1991-2007, a continually updated technical report.  <a href="http://www.cs.virginia.edu/stream/">www.cs.virginia.edu/stream</a> </li><li>  L. Borges, ‚ÄúExperiences in imaging code for Intel Xeon Phi coprocessor.‚Äù, 2012. <a href="https://software.intel.com/en-us/blogs/2012/10/26/experiences-in-developing-seismic-imaging-code-for-intel-xeon-phi-coprocessor">software.intel.com/en-us/blogs/2012/10/26/experiences-in-developing-seismic-imaging-code -for-intel-xeon-phi-coprocessor</a> </li><li>  JH Holland, ‚ÄúGenetic algorithms and the optimal allocation of trials,‚Äù SIAM Journal of Computing, vol.  2, no.  2, pp.  88‚Äì105, 1973. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/277407/">https://habr.com/ru/post/277407/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277397/index.html">Introducing the Intel RealSense Driver for Linux & OS X</a></li>
<li><a href="../277399/index.html">My rules for a good interface design</a></li>
<li><a href="../277401/index.html">Storage for 100 thousand or how to save on expensive projects</a></li>
<li><a href="../277403/index.html">In-depth training in the garage - Return smiles</a></li>
<li><a href="../277405/index.html">Reverse of the AC48 RS485 protocol from Perco. Keep the lines of your access control system from invasion</a></li>
<li><a href="../277411/index.html">I have an idea: Android data protection with eCryptfs</a></li>
<li><a href="../277413/index.html">Creating ontology in Prot√©g√© 5.0</a></li>
<li><a href="../277415/index.html">Welcome to the ice rink</a></li>
<li><a href="../277417/index.html">Introducing ReactOS 0.4</a></li>
<li><a href="../277419/index.html">RESTful API Design Approaches</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>