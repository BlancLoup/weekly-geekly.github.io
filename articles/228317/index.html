<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to patch 11 different firmware and do not go crazy with diversity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If any operation turns into a routine - automate it. Even if you spend more time - but you did not do your routine, but an interesting thing. It was u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to patch 11 different firmware and do not go crazy with diversity</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fc8/a26/257/fc8a2625783ee79d81f2ba29a36df793.png" align="right" width="400">  If any operation turns into a routine - automate it.  Even if you spend more time - but you did not do your routine, but an interesting thing.  It was under this sign that instead of simply patching the new 11 versions of rtsp_streamer for cameras from <a href="http://www.tpsee.com/deviceupdate/95-1.html">TopSee</a> , I decided to draw an auto-patch.  I consider the python to be the ideal language for any knee-pieces - quite concisely, tough enough for readability (although I still manage to make it unreadable).  In general, now I will tell you how to learn how to draw auto-patches with the help of a stick and a rope in one evening. <br><a name="habracut"></a><br>  So, the main requirements for scripts on the knee - the maximum match expectations.  He must either work or report that something is not right.  The main mistake of such scripts is any actions without checking for compliance with expectations.  Since otherwise you can not notice that something has changed and requires human intervention. <br><br>  So, remember what we <a href="http://habrahabr.ru/post/219537/">did last time</a> , and go through the whole path again manually: <br>  1) Ship the file to disassembler <br>  2) Find the function fctnl <br>  3) Pass by calls in search of using fcntl with O_NONBLOCK - we find two functions, makeSocketBlocking and makeSocketNonBlocking <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Boolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeSocketNonBlocking</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sock)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__WIN32__) || defined(_WIN32) unsigned long arg = 1; return ioctlsocket(sock, FIONBIO, &amp;arg) == 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(VXWORKS) int arg = 1; return ioctl(sock, FIONBIO, (int)&amp;arg) == 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> int curFlags = fcntl(sock, F_GETFL, 0); return fcntl(sock, F_SETFL, curFlags|O_NONBLOCK) &gt;= 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> } Boolean makeSocketBlocking(int sock) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__WIN32__) || defined(_WIN32) unsigned long arg = 0; return ioctlsocket(sock, FIONBIO, &amp;arg) == 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(VXWORKS) int arg = 0; return ioctl(sock, FIONBIO, (int)&amp;arg) == 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> int curFlags = fcntl(sock, F_GETFL, 0); return fcntl(sock, F_SETFL, curFlags&amp;(~O_NONBLOCK)) &gt;= 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre> </div></div><br>  4) We are looking for the sendPacket () function in the code (we know from the past that debug printfs are entered into it, for which it is easy to find) <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Boolean RTPInterface::sendPacket(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* packet, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> packetSize) { Boolean success = True; <span class="hljs-comment"><span class="hljs-comment">// we'll return False instead if any of the sends fail for (tcpStreamRecord* streams = fTCPStreams; streams != NULL; streams = streams-&gt;fNext) { if (!sendRTPOverTCP(packet, packetSize, streams-&gt;fStreamSocketNum, streams-&gt;fStreamChannelId)) { printf("%s(): ", "sendPacket"); printf("sendRTPOverTCP failed, sock: %d, chn: %d\r\n", streams-&gt;socket, streams-&gt;fStreamChannelId); success = False; } } return success; }</span></span></code> </pre></div></div><br>  5) Patch function <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs">Boolean RTPInterface::sendPacket(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* packet, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> packetSize) { Boolean success = True; <span class="hljs-comment"><span class="hljs-comment">// we'll return False instead if any of the sends fail for (tcpStreamRecord* streams = fTCPStreams; streams != NULL; streams = streams-&gt;fNext) { makeSocketBlocking(streams-&gt;socket); Boolean res = sendRTPOverTCP(packet, packetSize, streams-&gt;fStreamSocketNum, streams-&gt;fStreamChannelId); makeSocketNonBlocking(streams-&gt;socket); if (!res) { success = False; } } return success; }</span></span></code> </pre></div></div><br><br>  So, that's all we need to automate so that launched and received.  Moreover, in different versions of the firmware used somewhere fcntl, somewhere fcntl64;  Depending on the compiler options, different registers are used, small other differences in the translated code are observed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, let's start writing our script.  Understandably, since the patch will be different versions, the name of the file being patched must be passed as an argument.  So the script started: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys fname = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre><br><br>  Since we are making a script for ourselves, the files are small (~ meter weighing), there is a lot of memory, so we will not bother with running through the file - we will load everything into memory at once: <br><pre> <code class="python hljs">f = open(fname, <span class="hljs-string"><span class="hljs-string">"r+b"</span></span>) f.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) size = f.tell() f.seek(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) fw = f.read(size) f.close()</code> </pre><br><br>  Let's start looking for the makeSocketBlocking / makeSocketNonBlocking functions.  The fcntl functions are used a lot where, so the real hook is O_NONBLOCK (= 0x800).  On the other hand, these are library functions that nobody touches, they go in a row, you can simply find the functions "as is": <br><pre> <code class="hljs mel">.<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C554 makeSocketBlocking .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C554 <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>D E9 STMFD SP!, {R4,LR} .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C558 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> A0 E3 MOV R1, #F_GETFL ; cmd .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C55C <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> A0 E3 MOV R2, #<span class="hljs-number"><span class="hljs-number">0</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C560 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> A0 E1 MOV R4, R0 .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C564 <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span> FF EB BL fcntl .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C568 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> A0 E3 MOV R1, #F_SETFL ; cmd .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C56C <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>B C0 E3 BIC R2, R0, #O_NONBLOCK .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C570 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> A0 E1 MOV R0, R4 ; fd .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C574 <span class="hljs-number"><span class="hljs-number">2</span></span>E <span class="hljs-number"><span class="hljs-number">39</span></span> FF EB BL fcntl .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C578 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> E0 E1 MVN R0, R0 .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C57C A0 <span class="hljs-number"><span class="hljs-number">0</span></span>F A0 E1 MOV R0, R0,LSR#<span class="hljs-number"><span class="hljs-number">31</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C580 <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> BD E8 LDMFD SP!, {R4,PC} .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C580 ; End of function makeSocketBlocking .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C584 makeSocketNonblocking ; CODE XREF: sub_43524+<span class="hljs-number"><span class="hljs-number">40</span></span> p .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C584 ; .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">00043608</span></span> p ... .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C584 <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>D E9 STMFD SP!, {R4,LR} .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C588 <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> A0 E3 MOV R1, #<span class="hljs-number"><span class="hljs-number">3</span></span> ; cmd .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C58C <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> A0 E3 MOV R2, #<span class="hljs-number"><span class="hljs-number">0</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C590 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">40</span></span> A0 E1 MOV R4, R0 .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C594 <span class="hljs-number"><span class="hljs-number">26</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span> FF EB BL fcntl .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C598 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> A0 E3 MOV R1, #<span class="hljs-number"><span class="hljs-number">4</span></span> ; cmd .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C59C <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>B <span class="hljs-number"><span class="hljs-number">80</span></span> E3 ORR R2, R0, #<span class="hljs-number"><span class="hljs-number">0x800</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C5A0 <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> A0 E1 MOV R0, R4 ; fd .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C5A4 <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">39</span></span> FF EB BL fcntl .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C5A8 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> E0 E1 MVN R0, R0 .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C5AC A0 <span class="hljs-number"><span class="hljs-number">0</span></span>F A0 E1 MOV R0, R0,LSR#<span class="hljs-number"><span class="hljs-number">31</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C5B0 <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> BD E8 LDMFD SP!, {R4,PC} .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0003</span></span>C5B0 ; End of function makeSocketNonblocking</code> </pre><br><br>  We copy this opcodes in the forehead, and replace all the parameters that differ from the version, address, compiler settings and so on. <br><pre> <code class="python hljs">blockMask = <span class="hljs-string"><span class="hljs-string">""" ; makeSocketBlocking mm ?? ?? 2D E9 ; STMFD SP!, .... 03 10 A0 E3 ; MOV R1, #3 ; cmd 00 20 A0 E3 ; MOV R2, #0 00 ?? A0 E1 ; MOV Rx, R0 ; save fd ?? ?? FF EB ; BL fcntl 04 10 A0 E3 ; MOV R1, #4 ; cmd 02 2B C0 E3 ; clear O_NONBLOCK ?? 00 A0 E1 ; restore fd ?? ?? FF EB ; BL fcntl 00 00 E0 E1 ; MVN R0, R0 A0 0F A0 E1 ; MOV R0, R0,LSR#31 ?? ?? BD E8 ; LDMFD SP!, .... mm ; makeSocketNonblocking ?? ?? 2D E9 03 10 A0 E3 00 20 A0 E3 00 ?? A0 E1 ?? ?? FF EB 04 10 A0 E3 02 2B 80 E3 ?? 00 A0 E1 ?? ?? FF EB 00 00 E0 E1 A0 0F A0 E1 ?? ?? BD E8 """</span></span></code> </pre><br><br>  I additionally put labels ("mm") to the beginning of the functions;  all non-opcodes commented out ";"  and left it in the code as it is (for the future, to remember what is what). <br>  Now we need to turn this line into a search mask.  Of course, I‚Äôm not ready to search manually at all, so we‚Äôll search through regexps, since they are debugged and optimized, don‚Äôt indulge in the most.  And we read the entire file in memory as one big line - which is also convenient.  Therefore, we write a function that converts this mask to regexp: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> re <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maskToRegex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mask)</span></span></span><span class="hljs-function">:</span></span> mask = re.sub( <span class="hljs-string"><span class="hljs-string">";.*$"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, mask, flags=re.MULTILINE) mask = re.sub( <span class="hljs-string"><span class="hljs-string">"\s+"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, mask, flags=re.MULTILINE) masks = re.findall( <span class="hljs-string"><span class="hljs-string">".."</span></span>, mask) rgx = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> masks: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m == <span class="hljs-string"><span class="hljs-string">"??"</span></span>: rgx += <span class="hljs-string"><span class="hljs-string">"."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> m == <span class="hljs-string"><span class="hljs-string">"mm"</span></span>: rgx += <span class="hljs-string"><span class="hljs-string">"()"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: rgx += <span class="hljs-string"><span class="hljs-string">"\\x"</span></span>+m <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rgx</code> </pre><br>  The behavior is simple - we delete all comments (everything from; to the end of the line), remove all spaces, cut the remaining characters into pairs, and see - if it is ??  - then we replace it with a point (any character), if ‚Äúmm‚Äù we insert a label for which we will memorize the position, otherwise we generate a character code (by assigning ‚Äú\ x‚Äù to this pair). <br><br>  So, we have a mask and we can get a retex from it, let's finally find these functions: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">### 1. Find offset of makeSocketBlocking and makeSocketNonblocking makeBlock = None makeNonBlock = None for find in re.finditer(maskToRegex(blockMask), fw, re.DOTALL): if makeBlock is None and makeNonBlock is None: makeBlock = find.start(1) makeNonBlock = find.start(2) print "Found makeNonBlock at ", hex(makeNonBlock) print "Found makeBlock at ", hex(makeBlock) else: print "Non-unqiue makeNonBlock/makeBlocking functions found" break if makeBlock is None or makeNonBlock is None: print "makeNonBlock/makeBlocking functions not found"</span></span></code> </pre><br><br>  In this code there are two important points.  First, global, meeting expectations.  We check that only one block of code has fallen under this mask, and that it has really fallen.  At the time of debugging, we add a printout of the offset of the places found.  Secondly, it is important not to forget about re.DOTALL, so that any byte should fall under the dot, we work with a binary string. <br><br>  So, now we need to find the sendPacket function.  Let's look at the disassembly: <br><pre> <code class="hljs mel">.<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>C9A0 SendPacket ; CODE XREF: sub_69FB8+<span class="hljs-number"><span class="hljs-number">144</span></span> p .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>C9A0 ; .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>D144 p ... .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>C9A0 F0 <span class="hljs-number"><span class="hljs-number">4</span></span>F <span class="hljs-number"><span class="hljs-number">2</span></span>D E9 STMFD SP!, {R4-R11,LR} .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>C9A4 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span> A0 E1 MOV R6, R0 ..... .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB78 C3 FF FF <span class="hljs-number"><span class="hljs-number">1</span></span>A BNE loc_6CA8C .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB7C E2 FF FF EA B loc_6CB0C .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB7C ; End of function SendPacket .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB80 BC <span class="hljs-number"><span class="hljs-number">92</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>A <span class="hljs-number"><span class="hljs-number">00</span></span> off_6CB80 DCD aS_10 ; DATA XREF: SendPacket+<span class="hljs-number"><span class="hljs-number">7</span></span>C r, SendPacket+F0 r .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB80 ; <span class="hljs-string"><span class="hljs-string">"%s(): "</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB84 E4 <span class="hljs-number"><span class="hljs-number">6</span></span>B <span class="hljs-number"><span class="hljs-number">0</span></span>A <span class="hljs-number"><span class="hljs-number">00</span></span> off_6CB84 DCD aSendpacket ; DATA XREF: SendPacket+<span class="hljs-number"><span class="hljs-number">80</span></span> r, SendPacket+F4 r .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB84 ; <span class="hljs-string"><span class="hljs-string">"sendPacket"</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB88 <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>B <span class="hljs-number"><span class="hljs-number">0</span></span>A <span class="hljs-number"><span class="hljs-number">00</span></span> off_6CB88 DCD aSendrtpovert_0 ; DATA XREF: SendPacket+<span class="hljs-number"><span class="hljs-number">98</span></span> r .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB88 ; <span class="hljs-string"><span class="hljs-string">"sendRTPOverTCP failed, sock: %d, chn: %"</span></span>... .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB8C <span class="hljs-number"><span class="hljs-number">2</span></span>C <span class="hljs-number"><span class="hljs-number">9</span></span>B <span class="hljs-number"><span class="hljs-number">0</span></span>A <span class="hljs-number"><span class="hljs-number">00</span></span> off_6CB8C DCD aRemovestreamso ; DATA XREF: SendPacket+<span class="hljs-number"><span class="hljs-number">110</span></span> r .<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>:<span class="hljs-number"><span class="hljs-number">0006</span></span>CB8C ; <span class="hljs-string"><span class="hljs-string">"removeStreamSocket, sock: %d, chnid: %d"</span></span>...</code> </pre><br><br>  Aha, the link to this line lies right after the function code.  So, to find a function, we need to: find the line with the name of the function (thanks to the debugging macros, it is a separate independent line), convert the offset to the address, find this address, in the code, from this address unwind up to the STMFD SP! ..., LR}. <br>  Immediately the question arises - to find the string is not a problem, but how to convert the offset in the file into a virtual address?  Do not parse the file manually.  This is where all-powerful Google comes to the rescue: there is a pyelftools package.  So "pip install pyelftools", and smoke the attached documentation.  There is nothing useful there.  OK, we stupidly climb into the elffily.py file and see what is tasty there.  We find there a function that does the reverse task - it finds an offset in the virtual address: <br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">address_offsets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, start, size=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Yield a file offset for each ELF segment containing a memory region. A memory region is defined by the range [start...start+size). The offset of the region is yielded. """</span></span> end = start + size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> seg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.iter_segments(): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start &gt;= seg[<span class="hljs-string"><span class="hljs-string">'p_vaddr'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> end &lt;= seg[<span class="hljs-string"><span class="hljs-string">'p_vaddr'</span></span>] + seg[<span class="hljs-string"><span class="hljs-string">'p_filesz'</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> start - seg[<span class="hljs-string"><span class="hljs-string">'p_vaddr'</span></span>] + seg[<span class="hljs-string"><span class="hljs-string">'p_offset'</span></span>]</code> </pre><br><br>  Everything is clear, with a flick of the wrist these pants turn into elegant shorts: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#  f.close(),      from elftools.elf.elffile import ELFFile f.seek(0, 0) Elf = ELFFile(f) def offToVA(offset): for k in Elf.iter_segments(): if offset &gt;= k['p_offset'] and offset &lt;= k['p_offset']+k['p_filesz']: return k['p_vaddr']+(offset-k['p_offset'])</span></span></code> </pre><br><br>  Now we can find the string and its place of use: <br><pre> <code class="python hljs"> s = <span class="hljs-string"><span class="hljs-string">"sendPacket"</span></span> <span class="hljs-comment"><span class="hljs-comment">## Find string itself offStr = re.findall(s+"\x00", fw) if len(offStr)==1: offStr = re.search(s+"\x00", fw) offStrVA = offToVA(offStr.start(0)) print "offStr["+s+"] =", hex(offStrVA) elif len(offStr)==0: print s, "string marker not found" else: print "Too many", s, "string markers found"</span></span></code> </pre><br><br>  Then, due to laziness, I used another method of checking expectations - I just try to find everything first, and I think that everything is ok if she is alone.  Otherwise, I report an error.  The same method is not convenient, + unnecessary searches, but I personally understand, so I will not repeat the experiments with finditer. <br>  Well, now we find the offset where the string is used: <br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment">## Find offset to string reStrLink = "\\x%02X\\x%02X\\x%02X\\x%02X" % ( (offStrVA)%256, (offStrVA/256)%256, (offStrVA/256/256)%256, (offStrVA/256/256/256)%256 ) offLink = re.findall(reStrLink, fw) if len(offLink)==1: offLink = re.search(reStrLink, fw) offLink = offLink.start(0) if DE</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">BUG:</span></span></span><span class="hljs-comment"> print "offLink["+s+"] = ", hex(offToVA(offLink)) return offLink else: print "Can't find usage of", s</span></span></code> </pre><br><br>  As you already guessed, instead of <code>s = "sendPacket"</code> , <code>def findStringLink(s):</code> is actually written <code>def findStringLink(s):</code> since we will need to find the function more than once. <br>  Well, now we need to find another beginning of the function - let's walk back 4 bytes in search of STMFD SP !, {..., LR}.  Because of laziness, I limited myself to searching for STMFD SP !, {...} (so as not to analyze the bits).  The reason is that if you don‚Äôt find the beginning of the function, the search will still break further, which I‚Äôll find out, and then I can decide how to fix it better. <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Find previous function begin offset (nearest STMFD SP!, {...} instruction) def findFuncBegin(offset, maxLen = 0x1000): maxStart = max(0, offset-maxLen) offset -= 4 while offset &gt; maxStart: if fw[offset+2:offset+4]=="\x2D\xE9": return offset offset -= 4 return None</span></span></code> </pre><br><br>  So, we have everything we need, finally we will find the sendPacket function: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">### 2. Find sendPacket function sendPacketEnd = findStringLink("sendPacket") sendPacketStart = findFuncBegin(sendPacketEnd) if sendPacketStart is not None: print "sendPacketStart = ", hex(offToVA(sendPacketStart)) else: print "Can't find start of sendPacket"</span></span></code> </pre><br><br>  Now we are closer to the most interesting part - we need to find a loop inside sendPacket, and make sure that it is it.  We make up the mask as we learned earlier: <br><pre> <code class="python hljs">sendLoopMask = <span class="hljs-string"><span class="hljs-string">""" ?? 00 00 EA ; B loopBody ; --------------------------------------------------------------------------- mm ;loopNext ; CODE XREF: SendPacket+74j ?? ?? ?? E5 ; LDR R4, [R4,#4] (or R5) 00 00 ?? E3 ; CMP R4, #0 (or R5) ?? 00 00 0A ; BEQ loc_6CA74 ;loopBody ; CODE XREF: SendPacket+4Cj mm ; ; SendPacket+D0nj ?? ?? A0 E1 ; MOV R3, R4 (or R5) ?? ?? A0 E1 ; MOV R1, R5 ?? ?? A0 E1 ; MOV R2, R7 ?? ?? A0 E1 ; MOV R0, R6 mm ?? ?? ?? EB ; BL SendRTPOverTCP 00 00 50 E3 ; CMP R0, #0 F5 FF FF AA ; BGE loopNext """</span></span></code> </pre><br><br>  But we need to check that the BL inside the loop is exactly to SendRTPOverTCP, otherwise it either changed the function strongly, or the loop has already been patched by us, therefore we will also find SendRTPOverTCP: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">### 3. Find sendRTPOverTCP function sendRTPOverTCPStart = findFuncBegin(findStringLink("sendRTPOverTCP")) if sendRTPOverTCPStart is not None: print "sendRTPOverTCPStart = ", hex(offToVA(sendRTPOverTCPStart)) else: print "Can't find start of sendPacket"</span></span></code> </pre><br><br>  So, but we should be able to check whether the link is there.  All transitions in ARM are not absolute, but relative, plus the addresses are given by calculating +2 instructions from the current one, and even specified in the quanta of instructions (that is, divided by 4).  In general, the opcode is drawn <a href="http://www.heyrick.co.uk/armwiki/B">something like this</a> : <br> <code>TargetAddr = Opcode*(4 bytes/word) + CurAddr + 8</code> <br> <br>  As a result, we obtain such functions, for calculating the address where some instruction refers, and for calculating which operand will be instructions for a certain address to go to where it should be: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BinArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(off)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ord(fw[off])+ord(fw[off+<span class="hljs-number"><span class="hljs-number">1</span></span>])*<span class="hljs-number"><span class="hljs-number">256</span></span>+ord(fw[off+<span class="hljs-number"><span class="hljs-number">2</span></span>])*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArgToBin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> chr(arg%<span class="hljs-number"><span class="hljs-number">256</span></span>)+chr(arg/<span class="hljs-number"><span class="hljs-number">256</span></span>%<span class="hljs-number"><span class="hljs-number">256</span></span>)+chr(arg/<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">256</span></span>%<span class="hljs-number"><span class="hljs-number">256</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmdTargetOffset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cmdoff)</span></span></span><span class="hljs-function">:</span></span> d1 = BinArg(cmdoff) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d1 &gt;= <span class="hljs-number"><span class="hljs-number">0x800000</span></span>: d1 -= <span class="hljs-number"><span class="hljs-number">0x1000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (cmdoff+(d1+<span class="hljs-number"><span class="hljs-number">1</span></span>)*<span class="hljs-number"><span class="hljs-number">4</span></span>+<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cmdTargetArg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cmdoff, target)</span></span></span><span class="hljs-function">:</span></span> d1 = (target - (cmdoff+<span class="hljs-number"><span class="hljs-number">4</span></span>))/<span class="hljs-number"><span class="hljs-number">4</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d1 &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>: d1 += <span class="hljs-number"><span class="hljs-number">0x1000000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d1</code> </pre><br><br>  Now that the bricks are set aside, let's build another bulkhead: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">### 4. find loop in sendPacket sendPacketLoopRx = maskToRegex(sendLoopMask) sendPacketLoop = re.findall(sendPacketLoopRx, fw, re.DOTALL) if len(sendPacketLoop)==1: sendPacketLoop = re.search(sendPacketLoopRx, fw, re.DOTALL) sendPacketLoopNext = sendPacketLoop.start(1) sendPacketLoopBL = sendPacketLoop.start(3) sendPacketLoop = sendPacketLoop.start(2) if DE</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">BUG:</span></span></span><span class="hljs-comment"> print "sendPacket loop at ", hex(offToVA(sendPacketLoop)) elif len(sendPacketLoop)==0: print "Loop inside sendPacket not found" else: print "Non-unqiue loops masks for sendPacket found" ## 4.1. check that loop link is really to sendRTPOverTCP if cmdTargetOffset(sendPacketLoopBL) != sendRTPOverTCPStart: print "Loop's first call is not sendRTPOverTCP" if cmdTargetArg(sendPacketLoopBL, sendRTPOverTCPStart)!=BinArg(sendPacketLoopBL): print "BUG! cmdTargetArg inconsistent with cmdTargetOffset!" if ArgToBin(cmdTargetArg(sendPacketLoopBL, sendRTPOverTCPStart)) != fw[sendPacketLoopBL:sendPacketLoopBL+3]: print "BUG! ArgToBin inconsistent with cmdTargetOffset!"</span></span></code> </pre><br><br>  So, we found a loop, checked that the BL in it refers specifically to sendRTPOverTCP, and at the same time checked the address functions that they are consistent.  All this allows you to protect yourself from typos and get rid of unnecessary coverages with function tests ‚Äî we are writing a script, not a software product, therefore only the necessary maximum of gestures. <br><br>  But in order to patch, we need to add 6 new instructions, and for this we need a place.  Since we have two extra prints in the cycle, as we already know, we use them.  The first print 5 instructions, it means you will have to wipe both.  To do this, they will have to find and make sure that they: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">### 5. Find next two printfs printf1 = sendPacketLoopBL+4 while printf1 &lt; sendPacketEnd: if fw[printf1+3]=="\xEB": printfStart = cmdTargetOffset(printf1) break printf1 += 4 printf1 += 4 printf2 = printf1 + 4 while printf2 &lt; sendPacketEnd: if fw[printf2+3]=="\xEB": if cmdTargetOffset(printf2) != printfStart: print "ERROR! After loop not two printfs!" break printf2 += 4 printf2 += 4 if (printf1-sendPacketLoop)/4-7 != 5: print "WARN! First printf not 5 instructions" if (printf1-sendPacketLoop)/4-7 &gt; 5: printf2 = printf1 # no need to cleanup 2nd printf</span></span></code> </pre><br>  Again, we go the simplest way - we take the two closest BL after BL sendRTPOverTCP, check that they both refer to the same function, and check their sizes.  If anything goes wrong, we will immediately curse.  If everything is in line with expectations, then everything is fine. <br><br>  Well, now put all this together, add three buckets of foolishness, and generate a patch: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">### 6. Generate new loop body PatchSendPacket = "" ## 6.1. LDR R0, Socket(Rx#8) ldrSock = "\x08\x00"+fw[sendPacketLoopNext+2]+"\xE5" PatchSendPacket += ldrSock ## 6.2. BL makeSocketBlocking tgtSocketBlock = cmdTargetArg(sendPacketLoop+len(PatchSendPacket), makeBlock) PatchSendPacket += ArgToBin(tgtSocketBlock)+"\xEB" ## 6.3. Copy 4 MOVs PatchSendPacket += fw[sendPacketLoop:sendPacketLoopBL] ## 6.4. BL sendRTPOverTCP tgtSendRTPOverTCP = cmdTargetArg(sendPacketLoop+len(PatchSendPacket), sendRTPOverTCPStart) PatchSendPacket += ArgToBin(tgtSendRTPOverTCP)+"\xEB" ## 6.5. STMFD SP!, {R0} PatchSendPacket += "\x01\x00\x2D\xE9" ## 6.6. LDR R0, Socket PatchSendPacket += ldrSock ## 6.7. BL makeSocketNonBlocking tgtSocketNonBlock = cmdTargetArg(sendPacketLoop+len(PatchSendPacket), makeNonBlock) PatchSendPacket += ArgToBin(tgtSocketNonBlock)+"\xEB" ## 6.8. LDMFD SP!, {R0} PatchSendPacket += "\x01\x00\xBD\xE8" ## 6.9. CMP R0, #0 PatchSendPacket += "\x00\x00\x50\xE3" ## 6.A. BGE loopNext tgtLoopNext = cmdTargetArg(sendPacketLoop+len(PatchSendPacket), sendPacketLoopNext) PatchSendPacket += ArgToBin(tgtLoopNext)+"\xAA" ## 6.B. Fill up to printf2 with NOPs Nops = (printf2 - (sendPacketLoop + len(PatchSendPacket))) / 4 PatchSendPacket += "\x00\x00\xA0\xE1" * Nops ## 6.C. Save generated patch patches = [] patches.append( (sendPacketLoop, PatchSendPacket) ) print "Successfully patched"</span></span></code> </pre><br><br>  Now that we have all the patches (as long as there is a whole one, but first and foremost), we will generate a new file: <br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">### FIN: save patched file if True: f = open(fname+".fixed", "w+b") patches.sort() last = 0 for p in patches: f.write( fw[last:p[0]] ) f.write( p[1] ) last = p[0]+len(p[1]) f.write(fw[last:]) f.close()</span></span></code> </pre><br><br>  So, using a stick, a rope, a python and a gram of the brain, we easily and easily patched all 11 streamers I needed at once, and the time was spent one evening, which is approximately equal to the time it would take to manually patch them all.  That's just the next update, no longer need to spend time at all! <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> `(<span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> todo; ls -1)`; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> g=$(<span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$k</span></span> | perl -pe <span class="hljs-string"><span class="hljs-string">'s/.*?([TV][^-]+).*?-V(2[^_]+).*/$1_$2/'</span></span>); mv todo/<span class="hljs-variable"><span class="hljs-variable">$k</span></span> .; ../repack/unpack.sh <span class="hljs-variable"><span class="hljs-variable">$k</span></span>; cp <span class="hljs-variable"><span class="hljs-variable">$k</span></span>.unpack/root/opt/topsee/rtsp_streamer rtsp_streamer_<span class="hljs-variable"><span class="hljs-variable">$g</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rtsp_streamer_*.[0-9]; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> python tcpfix.py <span class="hljs-variable"><span class="hljs-variable">$k</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> ...</code> </pre><br><br>  Ps: to everyone who needs something else from these firmware, put the scripts in a more convenient place - <a href="https://github.com/datacompboy/tpsee_hack">on the githab</a> . </div><p>Source: <a href="https://habr.com/ru/post/228317/">https://habr.com/ru/post/228317/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../228301/index.html">Console Audio Tools - a package of utilities for checking and converting audio files</a></li>
<li><a href="../228305/index.html">The determinant of the type of blocking sites at the provider</a></li>
<li><a href="../228309/index.html">GUI in the game World of Tanks. Part One: The Evolution of Game Interfaces</a></li>
<li><a href="../228311/index.html">Get & Check - we deliver content and send push notifications to mobile devices</a></li>
<li><a href="../228315/index.html">How I overcame DDoS in 15 minutes</a></li>
<li><a href="../228321/index.html">Samsung has introduced a high-capacity, productive SSD with a vertical structure of memory cells.</a></li>
<li><a href="../228323/index.html">Sony SmartWatch 2 Review</a></li>
<li><a href="../228325/index.html">FnDelay awaiting function</a></li>
<li><a href="../228327/index.html">We parse ACID in NoSQL</a></li>
<li><a href="../228331/index.html">Building your own communication network over I2P</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>