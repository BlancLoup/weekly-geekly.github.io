<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Asynchronous UI: the future of web interfaces</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="While Ajax has become mainstream, user interfaces still cannot boast of instant responsiveness to user actions. The reason is that many developers are...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Asynchronous UI: the future of web interfaces</h1><div class="post__text post__text-html js-mediator-article">  While Ajax has become mainstream, user interfaces still cannot boast of instant responsiveness to user actions.  The reason is that many developers are accustomed to thinking in terms of "request / response" and think that the UI should work in parallel with the front-end, waiting for a response from the server to each request.  But why not update the interface before the answer came? <br><br>  The problem is quite acute, because speed is a critical characteristic of the UI.  For example, according to Amazon, a delay in loading a page of only 0.1 seconds leads to a decrease in store turnover by 1%.  According to Google, a delay of 0.5 seconds reduces the number of search queries by 20%. <br><br>  Ruby / JavaScript developer Alex MacCaw of Twitter <a href="http://alexmaccaw.co.uk/posts/async_ui">offers a</a> logical solution: extend Ajax principles not only to the front end, but also to the user interface.  He developed the appropriate framework for what is called AUI (Asynchronous User Interface). <br><a name="habracut"></a><br>  According to McCaw, the interface does not have to wait for the server to respond, because it leads to completely unnecessary delays.  For example, what does the interface expect in this screenshot, why does it block user actions? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage1/601a0206/63b9a5eb/042d8e5e/76b270fa.png"><br><br>  After all, the letter can be safely sent in the background, and the user does not have to wait for the message about the successful sending.  Of course, with the exception of those rare cases when you send a <i>really important</i> letter and want to know for sure that it has gone to the addressee.  But in reality this is an illusion of reliability, because the sender's server cannot guarantee that the addressee will indeed receive this letter. <br><br>  Anyway, the delayed interface example in Gmail refers to hundreds and thousands of other web applications where the user interface waits for a response from the server before allowing any action to be taken. <br><br>  Alex McCaw developed the <a href="http://spinejs.com/">Spine</a> JavaScript framework.  It implements a conceptually new approach in which the UI works independently of the server part of the application, that is, asynchronously. <br><br>  As a result, you can significantly increase the speed of UI.  Alex gives an example of a simple <a href="http://spine-rails3.herokuapp.com/">web application</a> where you can evaluate the speed of Spine (ruby backend).  Note that all actions are performed instantly, while Ajax REST calls are sent in the background. <br><br>  To implement an asynchronous UI, you need to follow three basic principles: <br><ul><li>  Migrating state and rendering to client side </li><li>  Intelligent data preloading </li><li>  Asynchronous communication with the server </li></ul> On the first two points, Alex McCaw refers everyone to his book <a href="http://oreilly.com/catalog/0636920018421">Javascript Web Applications</a> , and the third point explains in more detail using the following example.  Suppose a user wants to change the title of a page while working with a CMS.  When working in an asynchronous UI, he can do it instantly and continue working with the application, without waiting for a response from the server.  In Spine terminology, we are dealing with a <a href="http://spinejs.com/docs/models">model</a> called <code>Page</code> .  When changing the model name in the controller, the following happens: <br><br><pre> <code class="hljs swift">page = <span class="hljs-type"><span class="hljs-type">Page</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">find</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) page.name = <span class="hljs-string"><span class="hljs-string">"Hello World"</span></span> page.save()</code> </pre> <br>  As soon as the <code>save()</code> call occurs, Spine performs the following actions: <br><ul><li>  Checking callbacks and saving changes to memory </li><li>  Change event and user interface update </li><li>  Sending an Ajax PUT request to the server with a message about the change </li></ul>  Note that the Ajax request is sent to the server <i>after</i> the user interface is updated. <br><br>  Since Alex McCaw has been working with such technologies for a long time, he worked out various synchronization with the server in order to avoid mistakes.  For example, he implemented client-side data validation.  Of course, this is not always possible (for example, checking the uniqueness of an attribute requires access to the database).  There is no simple solution, so the discussion continues.  It is easier to deal with network errors: to avoid closing the browser before sending a request to the server, it is enough to monitor the occurrence of the <code>window.onbeforeunload</code> event and notify the user if there is an unsent request. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.onbeforeunload = -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Spine.Ajax.pending <span class="hljs-string"><span class="hljs-string">'''Data is still being sent to the server; you may lose unsaved changes if you close the page.'''</span></span></code> </pre> <br>  Similarly, if the server returns an error, it can be passed on to the user.  Such errors are relatively rare, so do not particularly dwell on them.  It is enough to notify the user, record the event in the log and synchronize again. <br><br>  Requests to the server are sent in the background strictly in turn to avoid any errors (when the request to update the data comes before the request to create a new item). <br><br>  Another trick that Alex McCaw offers, following the example of <a href="http://documentcloud.github.com/backbone">Backbone,</a> is the generation of temporary CIDs on the client side, which are a replacement for the unique IDs generated on the server side.  This approach eliminates delays and preserves an instant response for any JavaScript functions that need to generate an ID. <br><br>  Backbone uses different APIs for different types of ids. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Users</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getByCid</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">internalID</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Users</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.get</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">serverID</span></span>)</code> </pre> <br>  To get rid of such "duplicity", Spine takes a slightly different approach.  Here, temporary identifiers (pseudo GUIDs) are used until a response from the server with a real ID is received, and after that Spine switches to it, but both identifiers remain accessible through a single API. <br><br>  It is clear that in some cases the use of AUI is inappropriate.  For example, in financial applications or Internet banking, the interface should accurately reflect the movement of funds, receiving a response from the server.  But in most cases, AUI has distinct advantages over traditional Ajax application interfaces. </div><p>Source: <a href="https://habr.com/ru/post/132834/">https://habr.com/ru/post/132834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../132823/index.html">PROhq for legal freelance: each freelancer can apply for IE for free</a></li>
<li><a href="../132826/index.html">Simultaneous cross-site authentication without a bike</a></li>
<li><a href="../132828/index.html">Plugin Detector - jQuery plugin catalog and rating</a></li>
<li><a href="../132830/index.html">Bicyclist robot</a></li>
<li><a href="../132832/index.html">‚ÄúDouble‚Äù StartUp or how the customer became a performer</a></li>
<li><a href="../132835/index.html">TechCrunch Moscow 2011</a></li>
<li><a href="../132836/index.html">Released 2.0.2, soon rally of users and 2.0.3</a></li>
<li><a href="../132837/index.html">Atlassian Confluence and JIRA Expansion with Speakeasy</a></li>
<li><a href="../132839/index.html">We use Google Docs on iOS and Android. Almost without mat</a></li>
<li><a href="../132840/index.html">What you did not expect from the calculator. Solitaire on bc</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>