<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Are relational databases doomed?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's note: although the article is quite old (published 2 years ago) and has a loud title, it still gives a good idea of ‚Äã‚Äãthe differences bet...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Are relational databases doomed?</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <i>Translator's note: although the article is quite old (published 2 years ago) and has a loud title, it still gives a good idea of ‚Äã‚Äãthe differences between relational databases and NoSQL databases, their advantages and disadvantages, and also provides a brief overview of non-relational repositories.</i> </blockquote><br><img src="https://habrastorage.org/storage/habraeffect/46/96/469677e4332cb0fc7c37d0b44a295e1d.jpg" alt="image" align="right"><br>  Recently, many non-relational databases have appeared.  This suggests that if you need almost unlimited scalability on demand, you need a non-relational database. <br><br>  If this is true, does this mean that powerful relational databases have become vulnerable?  Does this mean that the days of relational databases pass and soon will pass?  In this article we will look at the popular course of non-relational databases in relation to various situations and see if this will affect the future of relational databases. <br><a name="habracut"></a><br>  <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25B0%25D0%25B7%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">Relational databases</a> have been around for about 30 years.  During this time, several revolutions broke out that were supposed to put an end to relational repositories.  Of course, none of these revolutions took place, and one of them did not shake the position of relational databases one iota. <br><br><h4>  Let's start with the basics </h4><br>  A relational database is a set of tables (entities).  Tables consist of columns and rows (tuples).  Restrictions can be defined inside the tables, relations exist between the tables.  Using SQL, you can execute queries that return data sets derived from one or more tables.  Within a single query, data is obtained from several tables by joining them (JOIN), most often the same columns are used for joining, which define the relationships between the tables.  <a href="http://ru.wikipedia.org/wiki/%25D0%259D%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0">Normalization</a> is the process of structuring the data model, ensuring connectivity and lack of redundancy in the data. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/04/54/0454561718d9d348472e7b5a2381a188.png" alt="image"></div><br>  Access to relational databases is provided through <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25A1%25D0%25A3%25D0%2591%25D0%2594">relational database management systems</a> (RDBMS).  Almost all the database systems we use are relational, such as Oracle, SQL Server, MySQL, Sybase, DB2, TeraData, and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The reasons for this dominance are not obvious.  Throughout the existence of relational databases, they have consistently offered the best mix of simplicity, robustness, flexibility, performance, scalability, and compatibility in data management. <br><br>  However, to provide all these features, relational storage is incredibly complex inside.  For example, a simple SELECT query can have hundreds of potential execution paths that the optimizer will evaluate directly during query execution.  All this is hidden from users, but inside the RDBMS it creates an execution plan based on things like cost estimation algorithms and best responding to the request. <br><br><h4>  Relational Database Problems </h4><br>  Although relational storage and provide the best mix of simplicity, stability, flexibility, performance, scalability and compatibility, their performance on each of these items is not necessarily higher than that of similar systems, focused on any one feature.  This was not a big problem, since the overall dominance of relational DBMS outweighed any shortcomings.  However, if ordinary RBD did not meet the needs, alternatives always existed. <br><br>  Today the situation is a bit different.  A variety of applications is growing, and with it growing and the importance of these features.  And with the increasing number of databases, one feature begins to overshadow all others.  This is scalability.  Since more and more applications are working under high load conditions, such as web services, for example, their scalability requirements can change very quickly and grow dramatically.  The first problem can be very difficult to resolve if you have a relational database located on your own server.  Suppose the server load overnight has tripled.  How fast can you upgrade your hardware?  The solution of the second problem also causes difficulties in the case of using relational databases. <br><br>  Relational databases scale well only if they are located on a single server.  When resources of this server run out, you will need to add more machines and distribute the load between them.  And here the complexity of relational databases starts to play against scalability.  If you try to increase the number of servers not to a few pieces, but to a hundred or thousands, the complexity will increase by an order of magnitude, and the characteristics that make relational databases so attractive quickly reduce to zero the chances of using them as a platform for large distributed systems. <br><br>  To remain competitive, cloud service vendors have to somehow deal with this limitation, because what kind of cloud platform is there without a scalable data warehouse.  Therefore, vendors are left with only one option if they want to provide users with a scalable place to store data.  It is necessary to use other types of databases that have a higher ability to scale, albeit at the price of other features available in relational databases. <br><br>  These advantages, as well as the existing demand for them, led to a wave of new database management systems. <br><br><h4>  New wave </h4><br>  This type of database is usually called a key-value store.  In fact, there is no official name, so you can meet it in the context of document-oriented, attribute-oriented, <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D1%2591%25D0%25BD%25D0%25BD%25D1%258B%25D0%25B5_%25D0%25B1%25D0%25B0%25D0%25B7%25D1%258B_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">distributed databases</a> (although they can also be relational), shard sorted arrays, <a href="http://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D1%2591%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2585%25D0%25B5%25D1%2588-%25D1%2582%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25B8%25D1%2586%25D0%25B0">distributed hash tables</a> and storages. type key value  And although each of these names indicates specific features of the system, all of them are variations on a topic that we will call a key-value type repository. <br><br>  However, no matter how you call it, this ‚Äúnew‚Äù type of database is not so new and has always been used mainly for applications for which the use of relational databases would be unsuitable.  However, without the need of the web and the "cloud" in scalability, these systems were not much in demand.  Now the task is to determine which type of storage is more suitable for a particular system. <br>  Relational databases and key-value storages differ radically and are designed to solve different tasks.  Comparison of characteristics will allow only to understand the difference between them, but let's start with this: <br><br>  Storage Characteristics <br><table><tbody><tr><th>  Relational database </th><th>  Key-value store </th></tr><tr><td>  The database consists of tables, the tables contain columns and rows, and the rows consist of column values.  All rows of one table have a single structure. <br></td><td>  For domains it is possible to draw an analogy with tables, but unlike tables for domains, the data structure is not defined.  Domain - this is a box in which you can put anything.  Entries within one domain can have different structure. <br></td></tr><tr><td>  Data model <sup>1</sup> is predefined.  It is strongly typed, contains constraints and relationships to ensure data integrity. <br></td><td>  Records are identified by key, with each record having a dynamic set of attributes associated with it. <br></td></tr><tr><td>  The data model is based on the natural representation of the data contained, and not on the functionality of the application. <br></td><td>  In some implementations, attributes can only be string.  In other implementations, attributes have simple data types that reflect the types used in programming: integers, an array of strings, and lists. <br></td></tr><tr><td>  The data model undergoes normalization to avoid data duplication.  Normalization generates relationships between tables.  Relationships link data from different tables. <br></td><td>  Between the domains, as well as within the same domain, the relationship is not clearly defined. <br></td></tr></tbody></table><br><h4>  No join'ov </h4><br>  Key-value storages are oriented to work with records.  This means that all information relating to this record is stored with it.  A domain (which you can think of as a table) can contain countless different entries.  For example, a domain may contain information about customers and orders.  This means that data is usually duplicated between different domains.  This is an acceptable approach because disk space is cheap.  The main thing is that it allows you to store all related data in one place, which improves scalability, since there is no need to join data from different tables.  When using a relational database, you would need to use connections to group the information you need into one place. <br><div style="text-align:center;"><img src="https://habrastorage.org/storage/habraeffect/c7/99/c79994fa85704dd2408d0ec96e9d8f8b.png" alt="image"></div><br>  Although the need for relationships drops sharply to store key-value pairs, relationships are still needed.  Such relationships usually exist between core entities.  For example, an ordering system would have records that contain data about customers, products, and orders.  It does not matter if the data is in the same domain or in several.  The bottom line is that when a buyer places an order, you most likely will not want to store information about the buyer and the order in one record. <br>  Instead, the order record must contain keys that indicate the corresponding customer and item records.  Since any information can be stored in records, and relations are not defined in the data model itself, the database management system will not be able to control the integrity of the relations.  This means that you can delete buyers and products that they ordered.  Ensuring data integrity rests entirely on the application. <br><br>  Data access <br><table><tbody><tr><th>  Relational database </th><th>  Key-value store </th></tr><tr><td>  Data is created, updated, deleted, and queried using the Structured Query Language (SQL). <br></td><td>  Data is created, updated, deleted, and queried using API call methods. <br></td></tr><tr><td>  SQL queries can retrieve data from a single table or from several tables, using joins. <br></td><td>  Some implementations provide SQL-like syntax for specifying filter conditions. <br></td></tr><tr><td>  SQL queries can include aggregations and complex filters. <br></td><td>  Often, you can only use the basic comparison operators (=,! =, &lt;,&gt;, &lt;= And =&gt;). <br></td></tr><tr><td>  A relational database usually contains embedded logic, such as triggers, stored procedures, and functions. <br></td><td>  All business logic and logic to maintain data integrity is contained in the application code. <br></td></tr></tbody></table><br>  Interaction with applications <br><table><tbody><tr><th>  Relational database </th><th>  Key-value store </th></tr><tr><td>  The most commonly used proprietary APIs, or generic ones, such as OLE DB or ODBC. <br></td><td>  The most commonly used are SOAP and / or REST API, which is used to access data. <br></td></tr><tr><td>  Data is stored in a format that displays their natural structure, therefore, mapping of application structures and relational database structures is necessary. <br></td><td>  Data can be more effectively displayed in the structure of the application, you need only the code to write data to objects. <br></td></tr></tbody></table><br><h4>  Key-Value Storages: Benefits </h4><br>  There are two clear advantages of such systems over relational repositories. <br><br><h5>  Suitable for cloud services </h5><br>  The first advantage of key-value storages is that they are simpler, and therefore have greater scalability than relational databases.  If you place your own system together, and plan to place a dozen or a hundred servers that need to cope with the increasing load, behind your data storage, then your choice is key-value storage. <br><br>  Due to the fact that such storage is easily and dynamically expanded, they will also be useful to vendors who provide a multi-user web storage platform.  Such a database is a relatively cheap data storage facility with great potential for scalability.  Users usually pay only for what they use, but their needs may increase.  The vendor will be able to dynamically and practically without restrictions increase the size of the platform, based on the load. <br><br><h5>  More natural integration with code </h5><br>  The relational data model and code object model are usually built differently, which leads to some incompatibility.  Developers solve this problem by writing code that <a href="http://ru.wikipedia.org/wiki/ORM">maps the</a> relational model to the object model.  This process has no clear and fast achievable value and can take quite a long time, which could be spent on developing the application itself.  Meanwhile, many key-value storages store data in a structure that maps to objects more naturally.  This can significantly reduce development time. <br><br>  Other arguments in favor of using key-value storages, like ‚ÄúRelational bases can become clumsy‚Äù (by the way, I have no idea what this means) are less convincing.  But before you become a supporter of such repositories, read the following section. <br><br><h4>  Key-value storages: disadvantages </h4><br>  Constraints in relational databases guarantee data integrity at the lowest level.  Data that does not satisfy the constraints cannot physically enter the database.  In the key-value storages there are no such restrictions, therefore the integrity control of the data lies entirely on applications.  However, in any code there are errors.  If errors in a properly designed relational database usually do not lead to data integrity problems, then errors in key-value storages usually lead to such problems. <br><br>  Another advantage of relational databases is that they force you to go through the process of developing a data model.  If you have a well-designed model, then the database will contain a logical structure that fully reflects the structure of the stored data, but it is at odds with the structure of the application.  Thus, the data becomes independent of the application.  This means that another application can use the same data and the application logic can be changed without any changes in the base model.  To do the same with a key-value type repository, try replacing the design process of the relational model with a class design that creates common classes based on a natural data structure. <br><br>  And do not forget about compatibility.  Unlike relational databases, cloud-oriented storage has far less common standards.  Although conceptually they are not different, they all have different APIs, query interfaces, and their own specifics.  Therefore, you better trust your vendor, because if something happens, you can not easily switch to another service provider.  And given the fact that almost all modern key-value storages are in beta <sup>2</sup> , trusting becomes even more risky than using relational databases. <br><br><h5>  Limited data analytics </h5><br>  Typically, all cloud storage is built on the type of <a href="http://ru.wikipedia.org/wiki/Multitenancy">multiple leases</a> , which means that a large number of users and applications use the same system.  To prevent the system from ‚Äúcapturing‚Äù, vendors usually somehow limit the execution of requests.  For example, in SimpleDB, a request cannot be executed for more than 5 seconds.  In Google AppEngine Datastore for one request can not get more than 1000 records <sup>3</sup> . <br><br>  These restrictions are not terrible for simple logic (creating, updating, deleting and extracting a small number of records).  But what if your application becomes popular?  You have received a lot of new users and a lot of new data, and now you want to make new opportunities for users or somehow benefit from the data.  Here you can break off hard with even simple queries for data analysis.  Features like tracking application usage patterns or a recommendation system based on user history can be difficult to implement at best.  And at worst - simply impossible. <br><br>  In this case, for analytics, it is better to make a separate database that will be populated with data from your key-value storage.  Think in advance how this can be done.  Will you host the server in the cloud or at home?  Will there be problems due to signal delays between you and your provider?  Does your repository support such data transfer?  If you have 100 million records, and you can take 1000 records at a time, how much will it take to transfer all the data? <br><br>  However, do not put scalability above all else.  It will be useless if your users decide to use the services of another service, because it provides more features and settings. <br><br><h4>  Cloud Storage </h4><br>  Many web service providers offer multiuser key-value storages.  Most of them meet the criteria listed above, but each has its own distinctive features and differs from the standards described above.  Let's take a look at specific sample repositories, such as SimpleDB, Google AppEngine Datastore, and SQL Data Services. <br><br><h5>  Amazon: SimpleDB </h5><br>  <a href="http://aws.amazon.com/simpledb/">SimpleDB</a> is an attribute-oriented key-value store included in Amazon WebServices.  SimpleDB is in beta;  users can use it for free - until their needs exceed a certain limit. <br><img src="https://habrastorage.org/storage/habraeffect/62/a1/62a17a501e51bb8fd80550bbb1116546.jpg" alt="image" align="right"><br>  SimpleDB has several limitations.  The first is that the query execution time is limited to 5 seconds.  The second is that there are no data types other than strings.  Everything is stored, retrieved and compared as a string, so in order to compare dates, you will need to convert them to ISO8601 format.  Third - the maximum size of any string is 1024 bytes, which limits the size of the text (for example, the description of the goods), which you can store as an attribute.  However, since the data structure is flexible, you can circumvent this limitation by adding the attributes ‚ÄúDescription of the Product1‚Äù, ‚ÄúDescription of the Product2‚Äù, etc.  But the number of attributes is also limited - a maximum of 256 attributes.  While SimpleDB is in beta, the domain size is limited to 10 gigabytes, and the entire database cannot occupy more than 1 terabyte. <br><br>  One of the key features of SimpleDB is the use of the <a href="http://www.allthingsdistributed.com/2008/12/eventually_consistent.html">eventual consistency model</a> .  This model is suitable for multi-threaded work, but it should be borne in mind that after you change the value of an attribute in a record, these changes may not be visible on subsequent read operations.  The probability of such a development is quite low, however, it must be remembered.  You do not want to sell the last ticket to five customers just because your data was inconsistent at the time of sale. <br><br><h5>  Google AppEngine Data Store </h5><br>  <a href="http://code.google.com/appengine/docs/python/datastore/">Google's AppEngine Datastore</a> is based on BigTable, <a href="http://code.google.com/appengine/docs/python/datastore/">Google‚Äôs</a> internal structured data storage system.  AppEngine Datastore does not provide direct access to BigTable, but can be perceived as a simplified interface for interacting with BigTable. <br><img src="https://habrastorage.org/storage/habraeffect/0b/e2/0be2572009e5b92d60feb1c703411d56.jpg" alt="image" align="left"><br>  AppEngine Datastore supports more data types within one record than SimpleDB.  For example, lists that may contain collections within an entry. <br><br>  Most likely you will use this particular data warehouse when developing using Google AppEngine.  However, unlike SimpleDB, you cannot use AppEngine Datastore (or BigTable) outside of Google‚Äôs web services. <br><br><h5>  Microsoft: SQL Data Services </h5><br><img src="https://habrastorage.org/storage/habraeffect/80/31/8031f921773f47d994dab23761f9d92f.jpg" alt="image" align="right"><br>  SQL Data Services is part of the Microsoft <a href="http://www.microsoft.com/windowsazure/">Azure</a> platform.  SQL Data Services is free, is in beta, and has a database size limit.  SQL Data Services is a separate application - an add-on over a variety of SQL servers that store data.  These storages can be relational, but for you SDS is a key-value store, just like the products described above. <br><br><h4>  Cloud storage </h4><br>  There are also a number of repositories that you can use outside the cloud by installing them.  Almost all of these projects are young, are in alpha or beta, and are open source.  With open source, you may be more aware of the potential problems and limitations than if you use unopened products. <br><br><h5>  Couchdb </h5><br>  <a href="http://couchdb.apache.org/">CouchDB</a> is a free, open source, document-oriented database.  JSON is used as a data storage format.  CouchDB is designed to fill the gap between document-oriented and relational databases using ‚Äúviews‚Äù.  Such views contain data from documents in a form similar to tabular, and allow you to build indexes and execute queries. <br><img src="https://habrastorage.org/storage/habraeffect/5d/e5/5de5f978794f9d05c50feffc5cc29a46.jpg" alt="image" align="left"><br>  <a href="http://wiki.apache.org/couchdb/Configuring_distributed_systems">Currently CouchDB is</a> not a truly distributed database.  It has replication functions that allow you to synchronize data between servers, but this is not the distribution that is needed to build a highly scalable environment.  However, CouchDB developers are working on this. <br><br><h5>  Voldemort Project </h5><br>  <a href="http://project-voldemort.com/">The Voldemort project</a> is a distributed key-value database designed for horizontal scaling across a large number of servers.  It was born in the development process of LinkedIn and was used for several systems that have high scalability requirements.  The Voldemort project also uses the final consistency model. <br><br><h5>  Mongo </h5><br><img src="https://habrastorage.org/storage/habraeffect/14/ad/14ad57b09ca5a45f097018cced63deec.gif" alt="image" align="right"><br>  <a href="http://www.mongodb.org/">Mongo</a> is a database developed in 10gen by Geir Magnusson and Dwight Merriman (which you may know from DoubleClick).  Like CouchDB, Mongo is a document-oriented database that stores data in JSON format.  However, Mongo is more of an object base than a pure key-value store. <br><br><h5>  Drizzle </h5><br><img src="https://habrastorage.org/storage/habraeffect/dc/69/dc69cb218a71ae8cb9067dbc7c3f4040.png" alt="image" align="left"><br>  <a href="https://launchpad.net/drizzle">Drizzle</a> represents a completely different approach to solving problems that key-value storages are designed to combat.  Drizzle began as one of the MySQL 6.0 branches.  Later, developers removed a number of functions (including views, triggers, compiled expressions, stored procedures, query cache, ACL, and some data types) in order to create a simpler and faster DBMS.  However, Drizzle can still be used to store relational data.  The goal of the developers is to build a semi-relational platform designed for web and cloud applications running on systems with 16 or more cores. <br><br><h4>  Decision </h4><br>  Ultimately, there are four reasons why you can choose a non-relational key-value store for your application: <br><ol><li>  Your data is very document-oriented, and more suitable for a key-value data model than for a relational model. </li><li>  Your domain model is strongly object-oriented, so using a key-value store will reduce the size of additional code for data conversion. </li><li>  Data storage is cheap and easy to integrate with your vendor's web services. </li><li>  Your main problem is high scalability on demand. </li></ol><br>  However, when making a decision, keep in mind the limitations of specific databases and the risks that you will encounter when you follow the path of using non-relational databases. <br><br>  For all other requirements it is better to choose good old relational DBMS.  So are they doomed?  Of course not.  At least for now. <br><br><hr><br>  <sup>1</sup> - in my opinion, the term ‚Äúdata structure‚Äù is more appropriate here, but left the original data model. <br>  <sup>2</sup> - most likely, the author had in mind that non-relational databases are inferior in their capabilities to relational databases. <br>  <sup>3</sup> - the data may already be outdated, the article dates back to February 2009. </div><p>Source: <a href="https://habr.com/ru/post/103021/">https://habr.com/ru/post/103021/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../103009/index.html">Problems of the .local zone in modern Linux distributions</a></li>
<li><a href="../103010/index.html">Audio processing via Audio Data API</a></li>
<li><a href="../103013/index.html">Google will launch the movie pay-per-view service again.</a></li>
<li><a href="../103014/index.html">Treasury: Diamond Idol - postmortem project</a></li>
<li><a href="../103016/index.html">High-performance sorting (radix) on CUDA</a></li>
<li><a href="../103022/index.html">Some statistics on e-books</a></li>
<li><a href="../103023/index.html">Brazil conducted a population census using 150,000 smartphones</a></li>
<li><a href="../103026/index.html">Report on the second eBukovka - meeting of electronic reading lovers in Kharkov</a></li>
<li><a href="../103027/index.html">Security and Virtualization</a></li>
<li><a href="../103030/index.html">Doctor Web has released a new product for protecting mobile devices - Dr.Web for Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>