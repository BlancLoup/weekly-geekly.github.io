<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optional types? Only if very necessary</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As Rob Napier wrote, we do not know Swift . And that's okay - in fact, it is even great: we have the opportunity to decide for ourselves what this you...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optional types? Only if very necessary</h1><div class="post__text post__text-html js-mediator-article"> As <a href="http://twitter.com/cocoaphony">Rob Napier</a> wrote, <a href="http://robnapier.net/i-dont-know-swift">we do not know Swift</a> .  And that's okay - in fact, it is even great: we have the opportunity to decide for ourselves what this young world will be next.  We can (and should) look to similar languages ‚Äã‚Äãin search of ideas, although many good-practice practices are more preferences of the community than objective truth.  Judging by the <a href="https://devforums.apple.com/thread/236155">long</a> and <a href="https://devforums.apple.com/message/1005132">tense</a> <a href="https://devforums.apple.com/message/1002435">conversations in the developer forums</a> about when and how best to use optional types, I increasingly prefer not to get involved with them. <br><br>  Optional types are the same tool as everyone else.  According to the habit that has been fixed on Objective C, we use <code>nil</code> where it doesn‚Äôt get - as an argument, default values, boolean values, and so on.  Using the <a href="http://commandshift.co.uk/blog/2014/06/11/understanding-optionals-in-swift/">nice syntax for optional types</a> , which Swift gives, you can turn almost anything into an optional type, and work with it almost the same.  Since the optional types are <a href="http://commandshift.co.uk/blog/2014/07/20/swift-implicitly-unwrapped-optionals/">unpacked implicitly</a> , everything is even simpler: you can use them and not even guess about it.  But the question arises - is it reasonable? <br><br>  I would say no.  Even seeming ease of use is deceptive ‚Äî Swift was designed as a language without <code>nil</code> support, and the concept of ‚Äúlack of meaning‚Äù was added as an enumeration.  <code>nil</code> not an object of the first kind.  Moreover, working with several values ‚Äã‚Äãof an optional type in one method often leads to a code that you cannot look at without tears.  When something was so fundamental in Objective C, and now it is being expelled from the list of objects of the first kind, it is interesting to understand the reasons. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start with an example where optional types fall into place.  Here is long known to us error handling in Objective C: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *writeError; <span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> written = [myString writeToFile:path atomically:<span class="hljs-literal"><span class="hljs-literal">NO</span></span> encoding:<span class="hljs-built_in"><span class="hljs-built_in">NSUTF8StringEncoding</span></span> error:&amp;writeError] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!written) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (writeError) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"write failure: %@"</span></span>, [writtenError localizedDescription]) } }</code> </pre><br>  This is a confusing situation, which optional types help clarify.  In Swift, we could write better: <br><br><pre> <code class="hljs pgsql">//       var writeError:NSError? = myString.writeToFile(<span class="hljs-type"><span class="hljs-type">path</span></span>, atomically:<span class="hljs-keyword"><span class="hljs-keyword">NO</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">encoding</span></span>:NSUTF8StringEncoding) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let error = writeError { println("write failure: \(error.localizedDescription)") }</code> </pre><br>  Here the value of the optional type perfectly describes the situation - either there was an error or nothing.  Although ... is this true? <br><br>  In fact, not ‚Äúnothing happened‚Äù, but quite successful data writing to the file took place.  Using the <code>Result</code> listing I <a href="http://habrahabr.ru/post/244575/">wrote about earlier</a> , the code value would correspond to the record: <br><br><pre> <code class="hljs pgsql">//       var outcome:Result&lt;()&gt; = myString.writeToFile(<span class="hljs-type"><span class="hljs-type">path</span></span>, atomically:<span class="hljs-keyword"><span class="hljs-keyword">NO</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">encoding</span></span>:NSUTF8StringEncoding) switch outcome { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Error(reason): println("Error: \(reason)") <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: break }</code> </pre><br>  There is more text, but it is clearer: we check the <i>result of the operation</i> , but it can be successful or unsuccessful <a href="https://habr.com/ru/post/244711/"><sup>1</sup></a> .  When I see an optional type and stop thinking in categories of Objective C, I increasingly understand that its abstractness hides the essence of what is happening from us. <br><br>  In my understanding, the type system is a way to give states a meaning.  Each type has a value ‚Äî an array conveys a data sequence, a dictionary ‚Äî a relationship between two views, and so on.  When viewed from this point of view, the optional types describe one rather specific case ‚Äî when the presence of a value and its absence are important in their own right.  Interactive I / O can be a good example: a user can enter data, but can not, and both states are equally important.  But more often it happens that the lack of meaning says something more <a href="https://habr.com/ru/post/244711/"><sup>2</sup></a> . <br><br>  When I get the idea to use a generic type, I meet her skeptically.  Often, the lack of meaning that I am trying to express really means something else, and the code gets better if a special type is described for this absence. <br><br>  ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ <br><br>  On the other hand, Swift code can interact with Objective-C code, and there the transfer of <code>nil</code> prohibited only by a convention, notes in the documentation and unexpected drops during the operation of the program.  Such is life, and the ability to use the wonderful Cocoa library more than compensates for these inconveniences ‚Äî but this does not mean that optional types should be thoughtlessly released beyond the interactivity layer. <br><br>  For example, let's try to write an extension for <code>NSManagedObjectContext</code> .  In Objective-C, the signature would be something like this: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">NSArray</span></span> *)fetchObjectsForEntityName:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)newEntityName sortedOn:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)sortField sortAscending:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)sortAscending withFilter:(<span class="hljs-built_in"><span class="hljs-built_in">NSPredicate</span></span>)predicate;</code> </pre><br>  If you try to access this method from Swift, the signature would look like this: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchObjectsForEntityName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name:String?, sortedOn:String?, sortAscending:Bool?, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">filter</span></span></span></span><span class="hljs-function"><span class="hljs-params">:NSPredicate?)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">AnyObject</span></span>]?</code> </pre><br>  This is an absolutely absurd signature.  To understand, let's start with a few assumptions: <br><br><ul><li>  Entity name is always needed </li><li>  We always want to get a result, even if it turns out to be empty. </li></ul><br><br>  Knowing that Core Data always returns <code>NSManagedObject</code> us, we can make the signature more meaningful: <br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchObjectsForEntityName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name:String, sortedOn:String?, sortAscending:Bool?, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">filter</span></span></span></span><span class="hljs-function"><span class="hljs-params">:NSPredicate?)</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">NSManagedObject</span></span>]</code> </pre><br>  Now let's take a look at the two parameters responsible for sorting.  The two optional types are a terrible choice, since their values ‚Äã‚Äãare somehow related.  We, maybe, want to sort something, but we still have to specify the sorting order.  To do this, turn to the good old listing and write the following: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SortDirection</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Ascending</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Descending</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SortingRule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SortOn</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">SortDirection</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">SortWith</span></span>(<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NSComparator</span></span>, <span class="hljs-type"><span class="hljs-type">SortDirection</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Unsorted</span></span> }</code> </pre><br>  Of the five optional types left alone.  In addition, the sorting rule has become more expressive, since now it is possible to use a closure.  The last remaining optional type conveys exactly what is required - the filter is either there or not.  It is possible, of course, to rewrite it as a separate type (at first I did that), but the advantages turned out to be insignificant. <br><br>  After rethinking our understanding of the principle of the code, we threw out four unnecessary optional types, simultaneously making the code more visual.  This is an undoubted success. <br><br>  ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ <br><br>  To summarize: I believe that optional types are needed, but not at all as often as it might seem in terms of their ease of use.  The reason for this ease is that you need to interact with the code in Objective C. If you wrap up every single parameter of an optional type in enums, you will not be able to use it, but do not write in Swift as if you are still writing in Objective C. It is better to take the most useful concepts. , which we learned in Objective C, and improve them with what Swift offers.  Then the result will be something really powerful - with optional types only in those places where they are really needed, but not beyond that. <br><br>  <i>Notes</i> <br><br>  1. In the <a href="https://github.com/maxpow4h/swiftz">Swiftz</a> project <a href="https://github.com/maxpow4h/swiftz">,</a> a more competent Result type has <a href="https://github.com/maxpow4h/swiftz">been</a> declared for interacting with Cocoa, in which an error is represented by an object of type <code>NSError</code> , and not just a string.  I would think that they use a less meaningful <code>Value</code> label instead of <code>Success</code> , but if you want to write real code, you should probably use this library. <br><br>  2. There would be an excellent example of implicitly unpacking optional types for <code>IBOutlets</code> : if no value is specified, then the entire application closes as a result of the error, and that should be so.  Therefore, it is logical to use <code>IBOutlets</code> as if this value is not optional at all. </div><p>Source: <a href="https://habr.com/ru/post/244711/">https://habr.com/ru/post/244711/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244699/index.html">We integrate AutoMapper with DI-containers on the example of Unity</a></li>
<li><a href="../244701/index.html">New version of RubyMine: Chef, Puppet, EditorConfig and more</a></li>
<li><a href="../244705/index.html">OpenVPN Denial of Service Vulnerability</a></li>
<li><a href="../244707/index.html">How to create a DbContext inside Visual Studio, or ‚ÄúWhat if you want something strange?‚Äù</a></li>
<li><a href="../244709/index.html">Saving "many to many" in Yii2 through behavior</a></li>
<li><a href="../244713/index.html">10 opportunities to be more productive with Eclipse for Java developers</a></li>
<li><a href="../244715/index.html">The script collapsing comments on Habr√©</a></li>
<li><a href="../244721/index.html">Revised Grunt Beginner's Guide</a></li>
<li><a href="../244723/index.html">Hacker's guide to neural networks. Schemes of real values. Strategy # 1: Random local search</a></li>
<li><a href="../244725/index.html">Grunt quick setup for comfortable development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>