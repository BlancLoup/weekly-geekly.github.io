<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Certificate revocation does not work</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Right now we have a small problem, but in my opinion, over time, the situation can only get worse. More and more sites are receiving certificates - th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Certificate revocation does not work</h1><div class="post__text post__text-html js-mediator-article">  Right now we have a small problem, but in my opinion, over time, the situation can only get worse.  More and more sites are receiving certificates - the necessary documents for implementing HTTPS - but we do not have a mechanism to protect against abuse. <br><br><h2>  Certificates </h2><br>  We are now seeing a real gold rush around certificates, as more and more websites are adopting HTTPS.  In addition to the obvious advantages of security and privacy, there are other benefits from the introduction of secure connections, which I listed in the article ‚Äú <a href="https/">Do you still think that you do not need HTTPS?</a>  ".  Usually referred to as "SSL certificates" or "HTTPS certificates" fly away at a speed that we have never seen in the history of the Internet.  Every day I research sites from the first million in attendance and analyze various aspects of their security, and every 6 months I publish a report.  You can study these reports <a href="https://scotthelme.co.uk/tag/crawl/">here</a> , but for now let's take a look at the pace of HTTPS implementation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f0f/fdb/0e1/f0ffdb0e1e2decdd9231f25891747a27.png"><br>  <font color="gray">Percentage of sites from the first million of the most popular sites according to Alexa statistics, where there is a redirect to the HTTPS version</font> <br><a name="habracut"></a><br>  We do not just continue to implement HTTPS, but the speed of implementation also increases.  This is what real progress looks like.  The process of obtaining a certificate over time becomes more simple, thanks to the great <a href="https://letsencrypt.org/">Let's Encrypt</a> , moreover, certificates have also become free.  In short, we simply send a request for a certificate (Certificate Signing Request, CSR) to a certificate authority (CA), and he offers to prove the fact of ownership of the domain.  This is usually done by changing the DNS TXT record or placing a special code somewhere at a random URL on our domain.  Once the task is completed, CA issues a certificate, and we can show it to browsers and enjoy the green lock and an indication of HTTPS in the address bar. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/3de/db9/36b/3dedb936b4ba9695fd7a3fb6c7f5bdda.png"><br><br>  I wrote a few instructions on this process, including <a href="https://scotthelme.co.uk/setting-up-le/">where to start</a> , how to <a href="https://scotthelme.co.uk/lets-encrypt-smart-renew/">correctly update</a> and how to use <a href="https://scotthelme.co.uk/hybrid-rsa-and-ecdsa-certificates-with-nginx/">double certificates</a> .  It's all great, isn't it?  But what's the problem?  And the problem will arise when everything goes wrong and you have a bad day. <br><br><h2>  Hacked us </h2><br>  No one would ever want to hear these words, but the reality is that we have to hear them more often than we would like.  Hackers can get anything when they have access to our server, and often they need a secret key.  HTTPS certificates are public documents that we send to each visitor to our site, but the only thing that prevents others from using the same certificate is the lack of our private key.  When the browser establishes a secure connection to the site, it checks that the server has a secret key for the certificate used.  That is why no one can use our certificate.  If a hacker gets a secret key, the situation changes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25d/f54/126/25df54126deb7386bef27a74f783cfd1.png"><br><br>  If the attacker has taken possession of our secret key, then he can impersonate us.  To repeat it: someone on the Internet can <i>prove</i> that he is you, although in reality he is not.  This is a real problem, and before you think, ‚ÄúThis will never happen to me,‚Äù remember <a href="http://heartbleed.com/">Heartbleed</a> .  This tiny bug in the OpenSSL library allowed an attacker to steal your secret key, even if you complied with all security measures.  In addition, there were countless cases in which secret keys flowed due to chance or negligence.  The reality is that we may lose our secret key, and when this happens, we need a way to prevent an attacker from using our certificate.  We need to withdraw it. <br><br><h2>  Feedback </h2><br>  In the event of compromise, we must revoke the certificate in order to eliminate the possibility of abuse.  As soon as the certificate is marked as revoked, the browser knows that it cannot be trusted, even if it has not expired.  The owner requested a review, and no client should accept this certificate anymore. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/439/a0d/43f/439a0d43f15e3111086257d1044c2367.png"><br><br>  As soon as we learn about the hacking fact, we contact the CA and ask to revoke our certificate.  You need to prove ownership of the certificate, and as soon as we have done this, the CA marks the certificate as revoked.  Now we need a way to communicate this fact to every client who may need this information.  Right at this moment the browser, of course, knows nothing, and this is a problem.  There are two mechanisms that are used to disseminate information: these are the Certificate Revocation List (CRL) and the Online Certificate Status Protocol (OCSP). <br><br><h2>  Certificate Revocation Lists </h2><br>  The CRL is really a very simple concept; it‚Äôs just a list of all the certificates that CA has marked as revoked.  The client can send a request to the CRL server and download a copy of the list.  Having a copy of this list, the browser verifies with him the certificate presented.  If it is present there, then the browser knows that the certificate is invalid and cannot be trusted, it will then issue an error and break the connection.  If the certificate is not listed, then everything is fine - and the browser will continue to work. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90d/747/ead/90d747ead78a371fd51d2f5003a34648.png"><br><br>  The CRL problem is that the lists contain many certificates from specific certificate authorities.  Without going into unnecessary details, they are broken up into intermediate CA certificates, and the certificate authority can issue lists in smaller parts, but the problem remains the same.  The CRL has a sizeable size.  Another problem is that the client does not have a fresh copy of the CRL, he needs to request it during the initial connection to the site, which can make the whole procedure much slower.  All this doesn‚Äôt look very nice, so let's take a look at OCSP. <br><br><h2>  Certificate status verification protocol </h2><br>  OCSP offers a much more beautiful solution to the problem and has a significant advantage over the CRL.  Here we ask CA for the status of a single, specific certificate.  This means that the CA should return only a simple answer: the certificate is either good or revoked, and this answer is much smaller than the CRL.  Fine! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd0/8ef/e61/bd08efe61d826104cec151791829b331.png"><br><br>  Indeed, OCSP exceeds the CRL in the speed of receiving an answer, but you have to pay for this advantage (do you also hate when this happens?).  The price is quite high - this is your privacy ... If you think about the essence of an OCSP request, this is a very specific request for a single HTTPS certificate.  In fact, there is a leak.  When you send an OCSP request, you literally ask the certificate authority: <br><br><blockquote>  Is the certificate for pornhub.com valid? </blockquote><br>  So this is not a perfect scenario.  You now give out the history of visited sites to a certain third party, about which you don‚Äôt even know anything, and all for the sake of HTTPS, which seems to be supposed to increase your privacy and security.  But hey, there's more. <br><br><h2>  Complete failure </h2><br>  Above, I talked about CRL and OCSP, two mechanisms for checking certificates by the browser, and they look that way. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac9/55d/ffa/ac955dffa3c6ada7ab0894d446f10af2.png"><br><br>  After receiving the certificate, the browser will contact one of these services and send a request for the final status of the certificate.  And what if your CA has a bad day and its infrastructure is offline?  What if the situation looks like this? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f04/f88/db4/f04f88db483b4356d76ca49ae71550dc.png"><br><br>  Here the browser has only two options.  He may refuse to accept the certificate because he is unable to verify his status.  Or take the risk and accept the certificate, not knowing its status, whether it is withdrawn or not.  Both options have their advantages and disadvantages.  If the browser refuses to accept the certificate, then every time the CA infrastructure goes offline, your websites also go there.  If the browser continues to accept certificates, it risks accepting a certificate that has been stolen and puts the user at risk.  This is a difficult choice, but right now, today, nothing really happens ... <br><br><h2>  Partial failure </h2><br>  In fact, today browsers perform a so-called certificate revocation check with a partial failure.  That is, the browser will try to check the status of the certificate, but if the answer did not come at all or did not come in a short period of time, the browser simply forgets about it.  Even worse, Chrome is not even trying to verify the certificate.  Yes, you read it correctly, Chrome does <i>not</i> even <i>try to</i> check the status of the certificate that it receives.  You may find this strange, but I completely agree with their approach and I am pleased to announce that Firefox is also likely to start working the same way soon.  Let me explain.  The problem with a complete failure is obvious: if CA has a bad day, then we too will have it, and this is how we came to the logic of partial failure.  The browser is now trying to verify the certificate for revocation, but completely abandons it if it takes too much time or if it seems that CA has gone offline.  Wait, what were the last words?  Certificate verification for revocation is canceled, ‚Äúif it seems that CA has gone offline.‚Äù  I wonder if the attacker can imitate such conditions? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f01/2ee/240/f012ee240f0df04f6cd86ea8836c1391.png"><br><br>  If you are performing a MiTM attack, then you only need to block the certificate verification request and create the impression that the CA is not working.  The browser will then encounter a partial verification failure and continue to happily use the revoked certificate.  If no one attacks you, then each time you verify this particular certificate, you spend time and resources on verifying that the certificate has not been revoked.  And once, when you are attacked - the only time you really need such a check - the attacker simply blocks the connection, and the browser goes through a partial crash.  Adam Langley from Google best described what a certificate revocation is: this is a safety belt that breaks at the time of the accident, and he is right.  Every day you get into the car and fasten your seat belt - and it gives you a pleasant and comfortable feeling of security.  And then one day something is not going according to plan - you get into an accident, and here you fly out into the windshield.  The one time you really need it, the seat belt lets you down. <br><br><h2>  Problem fix </h2><br>  Right now at this particular moment in time, the reality is that we cannot remedy the situation.  However, something can be done and, possibly, in the future, the mechanism for revoking certificates will become truly reliable. <br><br><h2>  Proprietary mechanisms </h2><br>  If the site is compromised and the attacker received a secret key, then he can fake this site and cause some harm.  There is nothing good here, but it could be worse.  What if the CA is compromised and the attacker received the secret key for the intermediate certificate?  This would be a disaster, because then an attacker can fake literally any site that he wants by signing his own certificate.  Therefore, instead of checking online intermediate certificates for revocation, Chrome and Firefox have their own mechanisms for the same task. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5f/416/c7b/e5f416c7b912b82528041cc234f36427.png"><br><br>  In Chrome, it's called <a href="https://dev.chromium.org/Home/chromium-security/crlsets">CRLsets</a> , and in Firefox, it's <a href="https://blog.mozilla.org/security/2015/03/03/revoking-intermediate-certificates-introducing-onecrl/">OneCRL</a> .  These mechanisms check certificate revocation lists by combining the available CRLs and selecting certificates from there.  So especially valuable certificates like intermediate are checked, but what about usual, ours with you? <br><br><h2>  OCSP Must-Staple </h2><br>  To explain what OCSP Must-Staple is, you must first briefly understand what OCSP Stapling is.  I do not want to go into unnecessary details here, you can get comprehensive information from my blog on <a href="https://scotthelme.co.uk/ocsp-stapling-speeding-up-ssl/">OCSP Stapling</a> , but here‚Äôs the gist.  OCSP Stapling eliminates the need for the browser to send an OCSP request by issuing an OCSP response along with the certificate itself.  This is called OCSP Stapling, because the server must ‚Äústaple‚Äù the OCSP response with the certificate and issue them together. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/375/10c/6c7/37510c6c7ff121d7878197d1ee454e0f.png"><br><br>  At first glance, this seems a bit strange, because the server seems to be ‚Äúself certifying‚Äù its own certificate as unrecognized, but everything works correctly.  The OCSP response is valid only for a short time and is signed by the CA in the same way as the certificate.  So if the browser can make sure that the certificate is signed by the CA, then just so it can make sure that the OCSP response is also signed by this CA.  This eliminates the big privacy problem and relieves the client of the burden of executing an external request.  The best way!  But really not the best, sorry.  OCSP Stapling is a great thing, and we all have to support this technology on our sites, but do we really think that the attacker will be supported by an attacker?  No, I do not think so, of course he will not do that.  What we really need is to make the server support OCSP Stapling, and this is what OCSP Must-Staple is for.  When requesting our certificate from CA, we ask it to set the OCSP Must-Staple flag on it.  This flag indicates to the browser that the certificate <i>should</i> come with an OCSP response or it will be rejected.  Installing a flag is easy. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6bd/7c5/197/6bd7c5197c8f6c3cc98a5fcc19b71a42.png"><br><br>  After setting this flag, we must ensure that OCSP Staple is used, otherwise the browser will reject the certificate.  In the case of compromise, if an attacker receives our key, he will also have to use OCSP Staple along with our certificate, and if he does not enable OCSP Staple, the OCSP response will say that the certificate has been revoked and the browser will not accept it.  TA-dah! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/908/742/9a0/9087429a0aaea50543bbee2e7244048e.png"><br><br><h2>  OCSP Expect-Staple </h2><br>  Although Must-Staple seems like a great solution for checking certificate revocation, this is not the case.  In my opinion, one of the biggest problems is that I, as a site operator, cannot precisely know how reliable the OCSP Staple tags are and how the client accepts them.  Without OCSP Must-Staple enabled, this is not a problem, but if you enable OCSP Must-Staple and we are not sure if OCSP Staple is reliable or correct, this is a problem for the site.  To try and get some feedback on the quality of OCSP Staple tags, we can activate a feature called OCSP Expect-Staple.  I‚Äôve written about it before, and you can find out all the details on the <a href="https://scotthelme.co.uk/ocsp-expect-staple/">OCSP Expect-Staple</a> blog, but here I‚Äôll also explain in brief.  In addition to <a href="https://scotthelme.co.uk/hsts-preloading/">the HSTS preload list,</a> you ask the browser to send a report if it is satisfied with the OCSP Staple tag.  You can collect the reports yourself or use my service <a href="https://report-uri.io/">report-uri.io</a> , in both cases you will know exactly when your site has encountered problems when running OCSP Must-Staple.  Since the use of the HSTS preload list is not as obvious as I would like, I also wrote a specification for defining a new security header called <a href="https://scotthelme.co.uk/designing-a-new-security-header-expect-staple/">Expect-Staple</a> to provide the same functionality at the cost of less effort.  The idea is that now you can set this heading and enable the function of sending reports that we need, even before the activation of Must-Staple.  Setting the header will be as simple as all other security headers: <br><br><pre><code class="hljs lua">Expect-Staple: <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>-age=<span class="hljs-number"><span class="hljs-number">31536000</span></span>; report-uri=<span class="hljs-string"><span class="hljs-string">"https://scotthelme.report-uri.io/r/d/staple"</span></span>; includeSubDomains; <span class="hljs-built_in"><span class="hljs-built_in">preload</span></span></code> </pre> <br><h2>  Fake certificates </h2><br>  If we are talking about the revocation of certificates, we must consider the topic of their falsification.  If someone tries to compromise the CA or somehow get a certificate that he was not supposed to, then how will he act?  If I hack a CA right now and get a certificate to your site, then you won‚Äôt know about it until you‚Äôll get it in the news.  Your company may even have an insider who will receive a certificate in circumvention of internal procedures, and he will do whatever he wants with him.  We need one hundred percent transparency, and soon we will get it.  This is <a href="https://scotthelme.co.uk/certificate-transparency-an-introduction/">Certificate Transparency</a> . <br><br><h2>  Certificate Transparency </h2><br>  CT is a new requirement that will become mandatory at the beginning of next year.  It provides that all certificates must be entered in a public journal in order for the browser to trust them.  You can read the <a href="https://scotthelme.co.uk/certificate-transparency-an-introduction/">article</a> with a more detailed description of the CT, but the point is that the CA logs all the issued certificates in the CT log. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26e/786/979/26e786979f406fabe020878d56fd9811.png"><br><br>  These magazines are completely open, and anyone can see them, so if someone gets a certificate on your site, then you will know about it.  For example, <a href="https://crt.sh/%3Fq%3Dscotthelme.co.uk">here</a> you can see all the certificates issued for my domain and search for your own.  There is also a <a href="https://sslmate.com/certspotter/">CertSpotter</a> service from sslmate for the same purpose, and I use the <a href="https://developers.facebook.com/tools/ct/">Facebook Certificate Transparency Monitoring</a> tool, which sends you an email every time a certificate is issued for a given domain.  The CT standard is a fantastic idea, and I can‚Äôt wait for it to become mandatory, but there is one reservation.  The fact is that CT is only the first step.  It‚Äôs good to know about these certificates, but we still have all the mentioned problems with their revocation.  However, we can solve only one problem at a time, and even the best revocation mechanisms in the world are ineffective if we don‚Äôt know which certificates to revoke.  CT at least gives us this information. <br><br><h2>  Authorization of certification authorities </h2><br>  Preventing the issuance of a certificate is much easier than trying to revoke it, and this is why <a href="https://scotthelme.co.uk/certificate-authority-authorization/">authorization of certificate authorities</a> (CAA) is needed.  Again, there are details in the article by reference, but the bottom line is that we can only authorize specific certificate authorities to issue certificates to us, in contrast to the current situation, when we cannot specify any preferences at all.  Authorization is as simple as creating a DNS record: <br><br> <code>scotthelme.co.uk. IN CAA 0 issue "letsencrypt.org"</code> <br> <br>  Although CA authorization is not a particularly strong mechanism, and it is not able to help in all situations of incorrect issuance of certificates, but in some cases it is useful, so you should declare your preferences by creating a CAA record. <br><br><h2>  Conclusion </h2><br>  At the moment there is a real problem that we can not revoke a certificate if someone received our private key.  Just imagine what this will mean when you unleash the next global Heartbleed scale vulnerability!  One thing you can try to do is limit the amount of leakage damage by shortening the validity of your certificate.  Replace three years with one year or less.  Let's Encrypt issue only certificates that are valid for only 90 days!  With a shorter lifetime for your certificate, the attacker will have less time for abuse.  In addition, we can do little. <br><br>  To demonstrate the problem and how real it is, try logging in to a new subdomain that I opened on my site, <a href="https://revoked.scotthelme.co.uk/">revoked.scotthelme.co.uk</a> .  As you can probably guess, a revoked certificate is attached to this subdomain, and it is likely that it will load normally in your browser.  If not, if your browser issues an expired warning, it means that your browser is still sending OCSP requests and you just informed CA that you visited my site.  To prove that such a soft fail check is useless, you can add the domain <code>ocsp.int-x3.letsencrypt.org</code> to the <code>hosts</code> with the IP address <code>127.0.0.1</code> or block it in some other way - and try to connect again.  This time, the page will load normally, because checking a revoked certificate will not work, and the browser will continue to load the page.  Sense from such a test ... <br><br>  I would like to end the article with a question: should we correct the procedure for revoking certificates?  However, this is a topic for another article. </div><p>Source: <a href="https://habr.com/ru/post/332730/">https://habr.com/ru/post/332730/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332718/index.html">Android Architecture Components. Part 2. Lifecycle</a></li>
<li><a href="../332722/index.html">PLC from manufacturers Aries, Segnetics and Schneider Electric for HVAC</a></li>
<li><a href="../332724/index.html">Cost of quality in software development</a></li>
<li><a href="../332726/index.html">University or technical school: where to enter in order to successfully find a job and earn good money?</a></li>
<li><a href="../332728/index.html">Technical support 3CX responds: the client configuration file for Android and poor sound quality on Android do not open</a></li>
<li><a href="../332732/index.html">The Machine and Exaflops for the Big Data era</a></li>
<li><a href="../332734/index.html">Is robots revolt canceled?</a></li>
<li><a href="../332736/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ270 (July 3 - 9, 2017)</a></li>
<li><a href="../332738/index.html">Oracle Data Integrator. SubstitutionAPI: The order of the substitutions. Part 2</a></li>
<li><a href="../332740/index.html">Linux still not cake</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>