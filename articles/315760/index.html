<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>React Testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Each JS developer sooner or later begins to write tests and regret that he did not do this before. Since over the past couple of years everyone has gr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>React Testing</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a82/42e/727/a8242e727085fbe44fe031108f7f015a.jpg" alt="image"><br><br>  Each JS developer sooner or later begins to write tests and regret that he did not do this before.  Since over the past couple of years everyone has gradually moved to component development based on React, Angular or, for example, Vue, this gave another impetus to popularize testing, since the components are usually small and testing them is much easier.  In this article, we will look at component testing in React. <a name="habracut"></a><br><br>  I apologize in advance for having to use English terms in this article.  Translation of some phrases that have become the standard in the field of testing would lead to a loss of understanding and complication in the search for additional information. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start by looking at the utilities that are needed to organize testing in a JS project: <br><br><ul><li>  Test Runner is a utility that takes files with our tests, runs them and displays test results.  The most popular tools in this area are Mocha and Karma. </li><li>  Assertion library - a library with a set of functions to check the conditions of your tests.  Chai and Expect are the most used libraries from this field. </li><li>  The mock library is the library used to create mocks during testing.  The utility allows you to replace the connected parts of the component under test with ‚Äúplugs‚Äù that mimic the desired behavior.  Here the most popular choice is Sinon. </li></ul><br>  Consider existing testing tools for React, and give examples of simple tests using these tools.  I‚Äôll say right away that I‚Äôm not going to describe how to set up the project‚Äôs build, ES6 transpaling, and so on: if you want, you can study all this yourself or find the articles you need in Habr√©.  As a last resort - write, and I will try to help you. <br><br>  Also within the framework of this article, we will not follow the path of ‚Äúblind‚Äù use of the most popular libraries that is common in the field of testing, but we will look at those that have appeared recently and try to understand whether they deserve attention. <br><br><h3>  Act 1 </h3><br>  The first thing we need is a TestRunner for our future tests.  As promised, this review will not consider popular utilities, such as Karma or Mocha.  Consider a new tool: Jest from Facebook.  Unlike Mocha, Jest is quite simple to configure, integrate into a project and is quite functional.  This is a young project that a year ago was quite ‚Äúsad‚Äù to use: it lacked much of the functionality required for tests, for example, there was no testing of asynchronous functions or a watch-mode that would monitor changed files.  Now this product is already pretty "devoured" and can be with such monsters as Mocha or Karma.  In addition, the maintainers began to promptly correct defects, which was completely lacking several years ago.  So let's take a look at what Jest can do: <br><br><ul><li>  <b>Amazingly easy to integrate into a project.</b> <br>  No need to put a dozen small libraries and customize their interaction with each other, since Jest already contains everything you need.  I understand those who at least once used the popular Karma + Mocha + Sinon bundle for tests, the rest will have to take my word for it. <br><br></li><li>  <b>Running tests and displaying test results</b> <br>  The jest contains enough parameters to customize the search and run tests, so you can always customize it for your project and tasks. <br><br></li><li>  <b>Contains an assert library, which, however, can be replaced by any other</b> <br>  The jest is based on the second version of the Jasmine library, so if you have once worked with it, the syntax will seem familiar.  If you don't like Jasmine, you can use your favorite library. <br><br></li><li>  <b>Able to run each test in a separate process, thereby accelerating the execution of tests</b> <br><br></li><li>  <b>Able to work with asynchronous code and test code using timers</b> <br><br></li><li>  <b>Able to automatically create "plugs" for imported components</b> <br><br>  In fact, this is one of the killer features of Jest, but rather difficult to configure.  It is because of it that many people at the time refused to use Jest, and in new versions it is now disabled by default. </li><li>  <b>Able to work in interactive watch-mode</b> <br><br>  Jest has a pretty cool interactive mode that allows you to run not only tests for changed components, but also, for example, from the last commit in git, the latest tests that failed, or using the pattern to search by name. </li><li>  <b>Able to collect the coverage of the project tests (coverage)</b> <br><br></li><li>  <b>Contains jsdom and, as a result, can run tests without a browser</b> <br><br></li><li>  <b>Can test components using snapshots</b> </li></ul><br>  This is not all that can Jest.  For more information on this utility, you can read on their official website - <a href="https://facebook.github.io/jest/">facebook.github.io/jest</a> .  However, Jest also contains some drawbacks that I noted for myself: <br><br><ul><li>  The Jest documentation is rather "scant", often you have to look for the answer yourself, rummaging through github or stack overflow. <br><br></li><li>  Cannot run tests in browsers <br>  Yes, its plus is also its minus.  True, for me this is not a critical minus, because  I try to avoid situations where the display may differ in different browsers. <br><br></li><li>  Slow start of tests. </li></ul><br>  About the slow start.  The Jest development team is constantly making improvements that speed test execution.  After Dmitrii Abramov joined them, the situation has greatly improved, this is <a href="https://twitter.com/abramov_dmitrii/status/761434371781824512/photo/1%3Fref_src%3Dtwsrc%255Etfw">confirmed</a> .  Nevertheless, according to my personal feelings, the tests that I wrote using Karma + Mocha, nevertheless, started and worked out faster than those written using Jest.  Hopefully, over time, the guys will eliminate this disadvantage. <br><br>  So let's write some tests and see how they look in practice.  First, take a simple function that calculates the sum of two numbers: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + b; }</code> </pre> <br>  The test for this function will be as follows: <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'function tests'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'should return 3 for arguments 1 and 2'</span></span>, () =&gt; { expect(sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)).toBe(<span class="hljs-number"><span class="hljs-number">3</span></span>); }); });</code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e8/23e/e6c/8e823ee6c66e875778ec2fc11fb21ab0.png" alt="image"><br><br>  Everything is simple and familiar.  Let's now complicate our function by adding a call to another function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> initial() + a + b; }</code> </pre><br>  A properly constructed test for an atomic element should exclude all dependencies on the rest of the code.  Therefore, we need to exclude the possible incorrect operation of the initial function from our test of the sum function.  To do this, we will make a ‚Äústub‚Äù for the initial function, which will return the value we need.  The test will be as follows: <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'function tests'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'should return 4 for arguments 1 and 2'</span></span>, () =&gt; { initial = jest.fn(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cb</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>); expect(sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>)).toBe(<span class="hljs-number"><span class="hljs-number">4</span></span>); }); });</code> </pre><br>  Now let's complicate our function and suppose that, first, our sum function must be asynchronous, and second, it must think before returning the desired result to us: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initial</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">salt</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ resolve({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: initial(<span class="hljs-number"><span class="hljs-number">1</span></span>) + a + b, <span class="hljs-attr"><span class="hljs-attr">param1</span></span>: a, <span class="hljs-attr"><span class="hljs-attr">param2</span></span>: b, }); }, <span class="hljs-number"><span class="hljs-number">100</span></span>); }); }</code> </pre><br>  Let's refine the test so that it takes into account our changes: <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">'function tests'</span></span>, () =&gt; { beforeAll(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { jest.useFakeTimers(); }); afterAll(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { jest.useRealTimers(); }); it(<span class="hljs-string"><span class="hljs-string">'should return 4 for arguments 1 and 2'</span></span>, () =&gt; { initial = jest.fn(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cb</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = sum(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); result.then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { expect(result).not.toEqual({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">param1</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">param2</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, }); expect(initial).toHaveBeCalledWith(<span class="hljs-number"><span class="hljs-number">1</span></span>); }); jest.runTimersToTime(<span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }) });</code> </pre><br>  In this test, we applied several new Jest features: <br><br><ul><li>  First, we asked him to use fake-timers so that we could manage the time ourselves. </li><li>  Secondly, we saw how to test asynchronous functions </li><li>  Third, we saw how to use negatives and comparison of objects in verifying tests. </li><li>  Fourth, we saw how to test that our mock function was called with the right parameters. </li></ul><br>  Let's see how to test React components.  Suppose we have a simple component that displays a greeting to the user and catches a click on the displayed text: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Wellcome</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ onClick() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.someFunction(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.username); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.onClick.bind(this)}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Wellcome {this.props.username}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); } }</code> </pre><br>  Let's test it: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TestUtils <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-addons-test-utils'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Wellcome <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./welcome.jsx'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'&lt;Welcome /&gt;'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'Renders wellcome message to user'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onClickSpy = jest.fn(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = <span class="hljs-string"><span class="hljs-string">'Alice'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = ReactTestUtils.renderIntoDocument( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Wellcome</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">username</span></span></span></span><span class="xml"><span class="hljs-tag">= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{username}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFunction</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClickSpy}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ); const span = TestUtils.findRenderedDOMComponentWithTag( component, 'span' ); TestUtils.Simulate.click(span); expect(span.textContent).toBe('Wellcome Alice'); expect(onClickSpy).toBeCalledWith(username); }); });</span></span></code> </pre><br>  As we can see, there is nothing complicated here.  We use React Test Utils to render our component and search for Dom nodes.  Otherwise, the test is no different from the usual test for Jest. <br><br>  So, we looked at how you can use Jest to create and run tests, but before going further, let's take a little more of one of its features, namely, testing on the basis of snapshots.  Snapshot testing is the ability to save a React tree nugget as a JSON object and compare it on subsequent test runs with the resulting structure. <br><br>  Roughly speaking, the first time you run a test to form such an impression, check its validity with your hands and commit it to the code repository.  And - voila - all subsequent runs of the test will compare your snapshot from the repository with what happened. <br><br>  This feature appeared in Jest quite recently, personally, my innovation caused mixed feelings.  On the one hand, I found a useful application for it - some tests really became simpler (where there is no interactivity and you need, in fact, just to check the structure), now I don‚Äôt need to duplicate the code in the tests.  On the other hand, I also saw a minus: tests for me are the documentation of my code, and testing on the basis of the impressions, in fact, gives me the opportunity to "skimp" and, without thinking about assert, simply compare the two component trees.  In addition, this approach deprives me of the possibility of classic TDD, when I first write component tests, and then write the code itself.  But I think that this feature will definitely find its fans. <br><br>  Let's see how it works for our component: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> renderer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-test-renderer'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Wellcome <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./welcome.jsx'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'&lt;Welcome /&gt;'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'Renders wellcome message to user'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onClickSpy = jest.fn(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = <span class="hljs-string"><span class="hljs-string">'Alice'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = renderer.create( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Wellcome</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">username</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{username}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFunction</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClickSpy}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ); const json = component.toJSON(); expect(json).toMatchSnapshot(); expect(onClickSpy).toHaveBeCalledWith(username); }); });</span></span></code> </pre><br>  We note that our test specifically did not simplify much (we already had it easy).  For a component that is more voluminous in structure, the test can be reduced by half and simplified many times.  Let's run our test and see what happens: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/543/436/cdd/543436cddeb33391b17ab4a6e5f9a919.png" alt="image"><br><br>  So jest has created a cast for us.  Here's what's inside the cast: <br><br><pre> <code class="javascript hljs">exports[<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Welcome</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> Renders wellcome message to user 1] = ` </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{[Function]}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Wellcome Alice </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> `;</span></span></code> </pre><br>  The cast is an html structure of the component and is convenient for ‚Äúeye‚Äù validation. <br><br>  In addition to the above disadvantages, I came across another drawback of testing on the basis of casts.  If you are using HOC components (for example, a redux-form), the impression will not contain the component you are testing, but a wrapper from the redux-form.  Therefore, to test just the component, I have to export it as well, and also to imitate a contract that requires a redux-form. <br><br>  Basically, it's okay if you have one HOC component.  But, for example, I can have three in some cases: one from react-redux, the second from redux-from and the third from react-intl.  With the latter, by the way, it is quite difficult to test the code, since it is not possible to simply lay a component over the ‚Äúplugs‚Äù; you need to put an honest localization API to the component.  How this is done - you can see <a href="https://github.com/yahoo/react-intl/wiki/Testing-with-React-Intl">here</a> . <br><br>  Summarize.  Now we have everything we need to run tests of our components.  But let's look again at how to simplify and improve our tests. <br><br><h3>  Act 2 </h3><br>  When you first think about testing React components and start looking for information on how to do this, you will most likely come across the React Test Utilites package of test utilities.  This package was developed by the Facebook team and allows you to write component tests.  This package provides the following features: <br><br><ul><li>  Component Rendering in DOM </li><li>  Simulating events for DOM elements </li><li>  "Mock-ing" components </li><li>  Find items in the DOM </li><li>  Shallow rendering component </li></ul><br>  As we can see, the set of possibilities is quite wide, sufficient for writing tests for any components.  An example of what our test would look like using React Test Utilites was covered in the previous section: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TestUtils <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-addons-test-utils'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Wellcome <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./welcome.jsx'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'&lt;Welcome /&gt;'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'Renders wellcome message to user'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onClickSpy = jest.fn(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> username = <span class="hljs-string"><span class="hljs-string">'Alice'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> component = ReactTestUtils.renderIntoDocument( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Wellcome</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">username</span></span></span></span><span class="xml"><span class="hljs-tag">= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{username}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">someFunction</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClickSpy}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ); const span = TestUtils.findRenderedDOMComponentWithTag( component, 'span' ); TestUtils.Simulate.click(span); expect(span.textContent).toBe('Wellcome Alice'); expect(onClickSpy).toBeCalledWith(username); }); });</span></span></code> </pre><br>  But we will not go "standard way" and will not use React Test Utilites for our tests for several reasons.  First of all, this library has very poor documentation, and in order to deal with it, the newcomer will have to actively use the search for answers on the Internet.  Secondly, the most ‚Äútasty‚Äù feature for us is the shallow rendering of components that has long been in the experimental stage and does not come out of it.  Instead, we will use the wonderful Enzyme library, which was developed by the Arbnb team and has already become quite popular when testing React applications.  In fact, Enzyme is a library that is an add-on to three other libraries: React TestUtils, JSDOM and CheerIO: <br><br><ul><li>  TestUtils is a library created by Facebook for testing React components. </li><li>  JSDOM is a JS implementation of the DOM.  Allows us to emulate a browser. </li><li>  CheerIO - Jquery equivalent for working with DOM elements </li></ul><br>  Combining everything together and adding a little more, Enzyme allows you to easily and clearly build tests for React components and, besides the functionality of Test Utilites, also gives us: <br><br><ul><li>  Three options for rendering the component: shallow, mount and render </li><li>  JQuery-like component search syntax </li><li>  Search for a component using the component name (only if you specified this name using the DisplayName parameter) </li><li>  Search for a component using its parameter values ‚Äã‚Äã(props) </li></ul><br>  Yes, Enzyme does not contain a TestRunner, and also does not know how to make "plugs" for the components, but for this we already have a Jest. <br><br>  Let's take a closer look at three options for rendering the component and what it gives us.  So, Enzyme has three methods that render a component and return similar wrappers with a set of methods in the jquery style: <br><br><ul><li>  Shallow rendering - Enzyme will only render the component itself, ignoring the rendering of the components nested in it. </li><li>  Full Dom Rendering - full rendering of the component and all its nested components </li><li>  Static rendering - renders static HTML for the passed component </li></ul><br>  I will not give the whole list of methods Enzyme gives us, I will only say that with its help you will be able to: <br><br><ul><li>  Find components or DOM elements </li><li>  Compare component content with JSX markup </li><li>  Check component properties </li><li>  Update component status </li><li>  Emulate events </li></ul><br>  This is not all Enzyme features.  A complete list can be found in the library documentation, and we will focus on the differences between the three types of rendering. <br><br>  What gives us shallow-rendering and what are its charms?  And it gives us the opportunity to concentrate when testing only on the component itself and not to think about nested components.  We absolutely do not care how the structure produced by the nested components will change: this should not break our tests for us.  Thus, we can test our component in isolation from other components.  But this does not mean that we are not testing nested components at all.  No, we can check in tests that we correctly transfer properties to nested components.  In addition, another plus of such testing is that the speed of such tests is much higher than when using Full Dom rendering, since it does not require the presence of a DOM.  But unfortunately, not always we can only use surface rendering.  For example, let, besides the Wellcome component we use, we also have the Home component with the following contents: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { PropTypes, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Wellcome <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Wellcome'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Home</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ onChangeUsername(e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.changeUsername(e.target.value); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;section className='home'&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;Wellcome username={this.props.username} /&gt; &lt;input type="text" name="username" value={this.props.username} onChange={this.onChangeUsername.bind(this)} /&gt; &lt;/section&gt; ) } } Home.propTypes = { changeUsername: PropTypes.func.isRequired } export default Home</code> </pre><br>  Let's write now the test for this component: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { shallow } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'enzyme'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Home <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Home'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Wellcome <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Wellcome'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'&lt;Home /&gt;'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'should render self and Wellcome'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderedComponent = shallow( &lt;Home username={'Alice'} changeUsername={jest.fn()} /&gt; ); //    console.log(renderedComponent.debug()); expect(renderedComponent.find('section').hasClass('home')).toBe(true); expect(renderedComponent.find('h1').text()).toBe('Home'); expect(renderedComponent.find('input').length).toBe(1); expect(renderedComponent.find(Wellcome).props().username).toBeDefined(); expect(renderedComponent.contains(&lt;Wellcome username={'Alice'} /&gt;)).toBe(true); }); it('should call changeUsername on input changes', () =&gt; { const changeUsernameSpy = jest.fn(); const renderedComponent = shallow( &lt;Home username={'Alice'} changeUsername={changeUsernameSpy} ); renderedComponent.find('input').simulate('change', { target: { value: 'Test' } }); expect(changeUsernameSpy).toBeCalledWith('Test'); }); });</code> </pre><br>  In order to see how shallow-rendering works in Enzyme, we will use the debug function and see what the following code will output to us. <br><br><pre> <code class="javascript hljs">&lt;section className=<span class="hljs-string"><span class="hljs-string">"home"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Home </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;Wellcome username=<span class="hljs-string"><span class="hljs-string">"Alice"</span></span> /&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Alice"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{[Function]}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  As we see, Enzyme has rendered our component, but did not render the nested components.  However, he formed the right parameters for them and we can check them if necessary. <br><br>  Now let's analyze the option when surface rendering does not suit us and you may need to use full rendering via a call to the mount method.  And surface rendering does not suit us if: <br><br><ul><li>  our component contains logic in lifecycle methods, such as componentWillMount and componentDidMount.  We, of course, can call them manually, but not sure that this is always a good way; </li><li>  our component must interact with the DOM.  The fact is that surface rendering does not use JSDOM and all interaction with the DOM simply will not work; </li><li>  we need to check the integration of several components among themselves - for example, we use the ToDo creation component and the ToDo list component on one page </li></ul><br>  In these cases, we will have to use mount instead of shallow, which, unfortunately, will make our tests slower, since it already needs DOM and the loading of the Jsdom library.  So, I give an example when we need full rendering: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { PropTypes, Component } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Wellcome <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Wellcome'</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Home</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ componentWillMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.fetchUsername(); } onChangeUsername(e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.changeUsername(e.target.value); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;section className='home'&gt; &lt;h1&gt;Home&lt;/h1&gt; &lt;Wellcome username={this.props.username} /&gt; &lt;input type="text" name="username" value={this.props.username} onChange={this.onChangeUsername.bind(this)} /&gt; &lt;/section&gt; ); } } Home.propTypes = { changeUsername: PropTypes.func.isRequired, fetchUsername: PropTypes.func, }; export default Home;</code> </pre><br>  And our test: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { mount } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'enzyme'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Home <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Home'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Wellcome <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./Wellcome'</span></span>; describe(<span class="hljs-string"><span class="hljs-string">'&lt;Home /&gt;'</span></span>, () =&gt; { it(<span class="hljs-string"><span class="hljs-string">'should fetch username on mount'</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fetchUsernameSpy = jest.fn(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cb</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-string"><span class="hljs-string">'Alie'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> renderedComponent = mount( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Home</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">username</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Ali</span></span></span></span><span class="xml"><span class="hljs-tag"></span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">e</span></span></span></span><span class="xml"><span class="hljs-tag">'} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">changeUsername</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{jest.fn()}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ); //    console.log(renderedComponent.debug()); expect(fetchUsernameSpy).toBeCalled(); }) })</span></span></code> </pre><br>  Let's see what the debug call returned to us: <br><br><pre> <code class="javascript hljs">&lt;Home username=<span class="hljs-string"><span class="hljs-string">"Alise"</span></span> changeUsername={[<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>]} fetchUsername={[<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>]}&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"home"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Home </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Wellcome</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">username</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Alie"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{[Function]}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> Wellcome Alise </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Wellcome</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"username"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"Alie"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{[Function]}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">section</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Home</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br>  As we can see, with full rendering, Enzyme also rendered nested components, and all methods of the LifeCycle component were launched. <br><br>  It remains for us to consider the last type of rendering that Enzyme has: static rendering.  It renders the component into an HTML string using the Cherio library, and returns us back an object that is similar to the one given to us by the shallow and mount methods.  The test will differ from the previous one only by replacing the mount call with a render, so you can write it yourself, if anything. <br><br>  I see only one application to this method, when it is necessary to analyze only the HTML structure of the component and the speed of the test is important.  When using static rendering, the test will work faster than when using full rendering.  I did not find other uses for this type of rendering. <br><br><h3>  Intermission </h3><br>  So, in this article we looked at testing React components, ‚Äúfelt‚Äù new utilities used for testing, and put together a ready-made ‚Äúcombine‚Äù to create tests.  If this topic is interesting, then in the following articles we will try to seriously test a more complex application that uses redux, redux-saga, react-intl, modal windows and other elements that complicate testing. <br><br>  Green to you tests and passing 100% coverage! </div><p>Source: <a href="https://habr.com/ru/post/315760/">https://habr.com/ru/post/315760/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315750/index.html">ITMO University Developments: Blockchain-Based Drone Management</a></li>
<li><a href="../315752/index.html">Type paper dissertation without allocations</a></li>
<li><a href="../315754/index.html">Selection of useful slides about Linux</a></li>
<li><a href="../315756/index.html">Protect the diploma. Five minutes of shame or decent performance</a></li>
<li><a href="../315758/index.html">The ‚ÄúUltimate‚Äù SSL Digest: The best practical materials on Habr√© and not only</a></li>
<li><a href="../315762/index.html">Crowd funding will help develop an ATX motherboard for IBM's Power8</a></li>
<li><a href="../315764/index.html">7 Tips for Unity Indie Game Localization</a></li>
<li><a href="../315766/index.html">Microsoft SQL Server for Linux: a bridge between the worlds of Linux and Windows</a></li>
<li><a href="../315768/index.html">Dart Developer Summit 2016: Top Dart News</a></li>
<li><a href="../315770/index.html">JIT-enabled Qemu.js: minced meat can still be turned back</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>