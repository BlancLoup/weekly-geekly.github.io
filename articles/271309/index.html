<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Component-oriented C # engine [part 2]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Independent components, minimally aware of each other, able to fulfill only the set goal - this is incredibly cool! I wrote about the initial sketches...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Component-oriented C # engine [part 2]</h1><div class="post__text post__text-html js-mediator-article">  Independent components, minimally aware of each other, able to fulfill only the set goal - this is incredibly cool!  I wrote about the initial sketches and ideas in a <a href="http://habrahabr.ru/post/270825/">previous post</a> . <br><br>  Since then, it was possible to face new problems that forced to expand and modify the system. <br><br>  All the advantages and disadvantages, as well as a small accumulated experience, I will consider on the example of a very simple 2D physics with gravity, forces and collisions.  Welcome under the cat, friends! <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  In my spare time I work hard on my own project, which was created solely for the sake of training, and therefore I‚Äôm directly infested with bicycles.  Probably, this ‚Äúengine‚Äù is one of them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Note: Naturally, I understand that in the framework of real-life tasks, it is advisable to take a ready-made solution and use it as a woodcutter takes an ax and cuts a tree with it.</i>  <i>Simply, sometimes you want to understand how these axes, hell, arranged.</i> <br><br><h4>  Current state </h4><br>  Not so much time has passed since the last story, but in a few evenings I realized that there are a number of tasks that the system <i>has</i> not yet been able to solve. <br><br>  So let's take a quick look at what we can already do: <br><ul><li>  create independent components; </li><li>  store components in containers and access them; </li><li>  use <i>interaction</i> layer, providing "communication" between containers; </li><li>  impose preconditions for the presence of certain components in containers involved in the methods of attachment ( <i>Attach</i> ) and interaction ( <i>Interaction</i> ). </li></ul><br><h4>  New problems </h4><br>  I thought for a long time how to proceed: first, to tell a task, during which problems arose, or to show problems, their solution, and then the task itself.  In the end, he stopped at the second version.  First, we learn about innovations and extensions, consider them in detail, and then, armed with fresh data, we will solve the problem. <br><br>  <i>And yet, what kind of gear is not enough to work at full power?</i> <br><br>  First, in the previous part I did not mention that I plan to introduce a message mechanism by which one component can send (within the parent container) messages to another.  As readers have already noticed, an event-based approach will allow flexibility to be won without hitting the architecture.  Moreover, no one imposes it: " <i>I send messages to all components, and you want - listen, you don't want - don't</i> ." <br><br>  Secondly, there was uncertainty with preconditions.  What if sometimes, in case of non-compliance with the precondition, it is necessary to completely break the execution of the program under the pretext of breaking the contract (the texture rendering component does not make sense at all without a texture component), and in other cases it can be ignored?  " <i>Now you do not have this component, but once it will appear!</i> ". <br><br>  In addition, there were minor flaws, which, most likely, remained as is. <br><br><h4>  Preconditions </h4><br>  Very quickly I will tell about the preconditions, because  The solution is very simple.  New listing: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OnValidationFail { Throw, Skip }</code> </pre> <br>  And that's it!  Now you can use it like this: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">AttachHandler(OnValidationFail.Skip)</span></span>]</code> </pre><br><h4>  Forwarding messages </h4><br>  With the forwarding of messages more interesting.  First, each component can now position itself as a sender and receiver. <br><br>  You can send messages that are generally described as very simple: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Message</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">Message</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Sender { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Message</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T sender</span></span></span><span class="hljs-function">)</span></span> { Sender = sender; } }</code> </pre><br>  To get it, I used the same approach again (for the third time) using reflection, which gives me very intrusive ease and flexibility. <br><br>  Every component in the class body can describe methods that take any <i>Message</i> as a parameter.  The <i>[MessageReceiver]</i> attribute helps to make it a valid recipient.  For example: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SimpleComponent</span></span> : <span class="hljs-title"><span class="hljs-title">Component</span></span> { [MessageReceiver] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageFromFriend</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DetachMessage&lt;FriendComponent&gt; message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// , ,      . //    ? _container.RemoveComponent(this); } [MessageReceiver] public void MessageFromSomeComponent(DetachMessage&lt;SomeComponent&gt; message) { //  ,   ,   . // - ,   . //_container.RemoveComponent(this); } }</span></span></code> </pre><br>  Since  it is obvious that there are such stages of the component life cycle as adding and deleting, smartly wrote <i>protected</i> utility methods in the <i>Component</i> class, which allow successors, if desired, to very briefly inform all ‚Äúneighbors‚Äù about the current state. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SendAttachMessage&lt;TSender, TContainer&gt; (TSender sender, TContainer container) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> TSender : Component { SendMessage( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ComponentAttachMessage&lt;TSender, TContainer&gt;(sender, container)); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SendDetachMessage&lt;T&gt;(T sender) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : Component { SendMessage(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ComponentDetachMessage&lt;T&gt;(sender)); }</code> </pre><br>  On this with the main "major" modifications (only one, in fact) everything.  Now I‚Äôll tell you about the scope of not only the new functionality, but, in general, the system. <br><br><h4>  Gravity Problem </h4><br>  At the initial stage of development, the following trivial task arose: to do <i>at least in</i> such a way that two types of ‚Äúboxes‚Äù could be put on the scene: <br><ul><li>  those that fall but can land on others; </li><li>  those that cannot fall;  the first land on them. </li></ul><br>  It sounds very simple, but it is not clear whether a freshly designed system can do this? <br><br>  I will expand the general sketch of the solution into a logical sequence, without reference to the implementation <br>  1. Suppose there are <i>game objects</i> that can be positioned on the scene at coordinates X, Y and drawn. <br>  2. We introduce the concept of a <i>solid body</i> - the properties of a game object, which allows you to set the speed of change of the corresponding coordinates. <br>  3. In principle, the game object has everything for movement: coordinates, a mechanism that makes it possible to change them.  Not enough push, in other words, <i>strength</i> . <br>  4. Something else?  Being able to move objects around the stage is fine, but we still need to teach them how to collide.  To do this, we define the concept of the <i>shell of an object responsible for collisions.</i> <br><br><h4>  Game objects </h4><br>  Following the above sketch, select the original entity - the <i>game object</i> , which will, in combination, the container of components. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameObject</span></span> : <span class="hljs-title"><span class="hljs-title">ComponentContainer</span></span> { }</code> </pre><br>  Not every game object can be placed on the scene, so we introduce the heir - <i>the scene object</i> . <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SceneObject</span></span> : <span class="hljs-title"><span class="hljs-title">GameObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> X { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Y { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;TimeSpan&gt; Updating; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action&lt;TimeSpan&gt; Drawing; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TimeSpan deltaTime</span></span></span><span class="hljs-function">)</span></span> { Updating(deltaTime); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Updated</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TimeSpan deltaTime</span></span></span><span class="hljs-function">)</span></span> { Drawing(deltaTime); } }</code> </pre><br>  <i>Note: in order not to write a lot of unnecessary code, I will omit some implementation details, since</i>  <i>the most important is the idea, and the fact that it did not check Updated and Drawn for null or did not sign the dummy is a minor issue.</i> <br><br><h4>  Solids </h4><br>  Since solids are properties of game objects (whether they may or may not be), they can be encapsulated into components.  Let's see the code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">RigidBody</span></span> : <span class="hljs-title"><span class="hljs-title">Component</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SceneObject _sceneObject; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _newX; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _newY; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> VelocityX { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> VelocityY { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [AttachHandler] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSceneObjectAttach</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SceneObject sceneObject</span></span></span><span class="hljs-function">)</span></span> { _sceneObject = sceneObject; _sceneObject.Updating += OnUpdate; _sceneObject.Drawing += OnDraw; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TimeSpan deltaTime</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//          //  . if (VelocityX != 0.0f) _newX = (float) (_sceneObject.X + (VelocityX * deltaTime.TotalSeconds)); if (VelocityY != 0.0f) _newY = (float) (_sceneObject.Y + (VelocityY * deltaTime.TotalSeconds)); } private void OnDraw(TimeSpan deltaTime) { //     . _sceneObject.X = _newX; _sceneObject.Y = _newY; } }</span></span></code> </pre><br>  I hope I'm so stupid as to come up with some really significant and complex physical constructs, that everyone understands how the previous piece of code works. <br><br><h4>  Forces </h4><br>  So we got to the last key to the "eternal" movement.  Strength is, after all, essentially just something that changes the speed of a solid body.  It remains to understand what speed to change and how. <br><br>  <i>Note: most likely, someone has already solved this problem a thousand times in exactly the same way, but I remind you that the project is educational - I really like to get to all sorts of decisions myself.</i> <br><br>  What did you manage to come up with? <br><br>  Let's look at the so-called "unit circle", where the values ‚Äã‚Äãon the axes oX and oY are represented on the range from [-1 to 1]. <br><img src="https://habrastorage.org/files/2c9/f2b/03a/2c9f2b03aa364f8f85f05431eabb0bff.jpg"><br>  Suppose the blue arrow is the vector of the force acting on the body, and the center of the circle is the center of gravity of the body.  And, let's say, the conditional value of the force itself is 100. <br>  If the force changes the speed of the object, then it must change its speed both vertically and horizontally, and how much - the green and orange lines will answer us.  They are equal to approximately 0.9 and 0.5, respectively. <br>  Consequently, the object speed vertically changes to 100 * 0.9, and horizontally - to 100 * 0.5. <br>  I will fix these very simple conclusions with the code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Force</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Angle { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Power { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RigidBody rigidBody</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     ( ). var radians = GeometryUtil.DegreesToRadians(Angle); var horizontalCoefficient = GetHorizontalCoefficient(radians); var verticalCoefficient = GetVerticalCoefficient(radians); rigidBody.VelocityX += Power * horizontalCoefficient; rigidBody.VelocityY += Power * verticalCoefficient; } private float GetHorizontalCoefficient(double radians) { var scaleX = Math.Cos(radians); if (Math.Abs(scaleX) &lt;= 0) return 0; return (float) scaleX; } private float GetVerticalCoefficient(double radians) { //     -1, ..      oY . var scaleY = Math.Sin(radians) * -1; if (Math.Abs(scaleY) &lt;= 0) return 0; return (float) scaleY; } }</span></span></code> </pre><br>  I want to note that the <i>Force</i> class is not a component, and not a container.  This is a primitive type, which later will be reused by others. <br><br>  One feels that there is not enough someone who could impose force on solid bodies, right? <br><br><h4>  Gravity </h4><br>  That which caused the most difficulties.  I wanted to do something like a gravitational field, but it was unclear where it comes from and how it is applied to objects.  Is it a component or a container? <br><br>  In the end, having collected his thoughts, he decided that the component.  Component that is added to any object that is present in the gravitational field. <br>  The task of the component is to apply a force of 270 degrees (bottom) with a magnitude of 9.83 each update cycle. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">RequiredComponent(typeof(RigidBody))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Gravitation</span></span> : <span class="hljs-title"><span class="hljs-title">Component</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SceneObject _sceneObject; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> RigidBody _rigidBody; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Force _gravitationForce = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Force(<span class="hljs-number"><span class="hljs-number">270</span></span>, <span class="hljs-number"><span class="hljs-number">9.83</span></span>); [AttachHandler(OnValidationFail.Skip)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSceneObjectAttach</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SceneObject sceneObject</span></span></span><span class="hljs-function">)</span></span> { _sceneObject = sceneObject; _rigidBody = GetComponent&lt;RigidBody&gt;(); _sceneObject.Updating += OnUpdate; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">TimeSpan deltaTime</span></span></span><span class="hljs-function">)</span></span> { _gravitationForce.Add(_rigidBody); } <span class="hljs-comment"><span class="hljs-comment">//  ,   ,    - . [MessageReceiver] public void OnRigidBodyAttach( ComponentAttachMessage&lt;RigidBody, SceneObject&gt; message) { _rigidBody = message.Sender; _sceneObject = message.Container; _sceneObject.Updating += OnUpdate; } [MessageReceiver] public void OnRigidBodyDetach(ComponentDetachMessage&lt;RigidBody&gt; message) { _sceneObject.Updating -= OnUpdate; } }</span></span></code> </pre><br>  Thus, now, even if an object does not have a solid component, gravity will not break.  It simply will not work until the above component is added to the container. <br><br>  The example turned out to be indicative, clearly illustrating the situation when one component sends messages to another within the parent container. <br><br><h4>  Collisions </h4><br>  Remains the most interesting part of any physics engine, on which the universe is based. <br><br>  From the sketch of the solution to the problem, it follows that the <i>shell responsible for the collisions</i> is also a property of the object, just like a solid body.  Therefore, without thinking, we define it as a component. <br><br>  Next, I figured that the shells are different: the simplest are rectangular, but there are still round ones, which are also easy to count, and, finally, shells of arbitrary shape with N vertices. <br><br>  It is necessary at some point to calculate the collision between two different shells.  For example, a circle fell on a rectangular ground. <br><br>  We describe the abstract shell class: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Collider</span></span> : <span class="hljs-title"><span class="hljs-title">Component</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> SceneObject SceneObject; [AttachHandler] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSceneObjectAttach</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SceneObject sceneObject</span></span></span><span class="hljs-function">)</span></span> { SceneObject = sceneObject; } <span class="hljs-comment"><span class="hljs-comment">//    . public abstract bool ResolveCollision(Collider collider); public abstract bool ResolveCollision(BoxCollider collider); }</span></span></code> </pre><br>  The main idea is that the ResolveCollision method will be used to calculate collisions, which takes a parameter of the base type <i>Collider</i> , but inside this method each specific version of the shell will redirect the call to another method that can work with a specific type.  Ball runs Ad-hoc polymorphism. <br><br>  I will show on a simple example of a rectangle: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BoxCollider</span></span> : <span class="hljs-title"><span class="hljs-title">Collider</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Width { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Height { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> RectangleF </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBounds</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RectangleF(SceneObject.X, SceneObject.Y, Width, Height); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolveCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Collider collider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collider.ResolveCollision(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolveCollision</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">BoxCollider boxCollider</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bounds = GetBounds(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colliderBounds = boxCollider.GetBounds(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!bounds.IntersectsWith(colliderBounds)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// :         bounds. // ..    ,     "" //  ,       - . //         (    ). bounds.Intersect(colliderBounds); if (bounds.Height &lt;= 1f) return false; SceneObject.Y -= bounds.Height; return true; } }</span></span></code> </pre><br>  You have dealt with the main problems: now you can create game objects, allocate them with various properties, move, push together.  What is missing is the last small detail: where to calculate the collisions? <br><br><h4>  Scene </h4><br>  If there is a <i>SceneObject</i> , then there must be a scene where they are all located.  She is responsible for updating the state of objects and their drawing.  She will consider collisions. <br><br>  This will help the layer <i>Interaction</i> , which still has not found application in solving the problem of gravity.  We describe the class <i>Interactor</i> , which is responsible for the miscalculation of the collision between two objects of the scene: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CollisionDetector</span></span> : <span class="hljs-title"><span class="hljs-title">Interactor</span></span> { [InteractionMethod] [RequiredComponent(<span class="hljs-string"><span class="hljs-string">"first"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Collider))] [RequiredComponent(<span class="hljs-string"><span class="hljs-string">"second"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Collider))] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SceneObjectsInteraction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SceneObject first, SceneObject second</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstCollider = first.GetComponent&lt;Collider&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> secondCollider = second.GetComponent&lt;Collider&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!firstCollider.ResolveCollision(secondCollider)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,           ,   . first.IfContains&lt;RigidBody&gt;(TryAddInvertedForce); second.IfContains&lt;RigidBody&gt;(TryAddInvertedForce); } private void TryAddInvertedForce(RigidBody rigidBody) { var lastAddedForce = rigidBody.ForceHistory.Last(); var invertedForce = new Force { Angle = GeometryUtil.GetOppositeAngle(lastAddedForce.Angle), Power = rigidBody.GetKineticEnergyY() }; invertedForce.Add(rigidBody); } }</span></span></code> </pre><br>  <i>Note: this example is not an illustrative application of knowledge from the field of physics.</i>  <i>It does not work for two bodies colliding in the air that were moving at a certain speed, but clearly shows the idea of ‚Äã‚Äãhow it looks for a simple fall.</i> <br><br>  The general concept is as follows: when an object falls on the ground and collides with it, the earth compensates for the speed of a fall by a new force, which acts in the opposite direction from the fall and is equal to the current kinetic energy of the object. <br><br>  <i>Interactor</i> itself is called from the scene in the update method that runs each frame. <br>  In the collision prediction mechanism, for the <i>time being</i> , <i>I</i> use the rough O (n <sup>2</sup> ) method. <br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   . public void Update(TimeSpan deltaTime) { foreach (var sceneObject in _sceneObjects) { sceneObject.Update(deltaTime); foreach (var anotherSceneObject in _sceneObjects) { if (ReferenceEquals(sceneObject, anotherSceneObject)) continue; sceneObject.Interact(anotherSceneObject).Using&lt;CollisionDetector&gt;(); } } }</span></span></code> </pre><br><h4>  Conclusion </h4><br>  Honestly, the small structure of the physics engine, in fact, seemed at first not so obvious.  Especially collisions and gravity.  I‚Äôm sure that the physical engines are hardly written that way, but it was interesting to try and ‚Äúfeel‚Äù myself. <br><br>  In the process, we managed to isolate some obvious advantages of the component-oriented approach, which are based both on my observations and on common sense: <br>  1. It is very easy to write code when you clearly see what a component does and from whom it depends (this is evident). <br>  2. The code is very flexible and independent.  Each component has an observable and unambiguous degree of influence on the container. <br><br>  The probability is high that the task was relatively simple, and at higher loads, the system would crash and begin to introduce unnecessary complexity into the code.  I think I will check it soon. <br><br>  Thanks to all! </div><p>Source: <a href="https://habr.com/ru/post/271309/">https://habr.com/ru/post/271309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271299/index.html">CsConsoleFormat: Console formatting in a new way (.NET)</a></li>
<li><a href="../271301/index.html">What's new in Ruby 2.3</a></li>
<li><a href="../271303/index.html">Interview: Brian Kernigan and Alan Donovan</a></li>
<li><a href="../271305/index.html">Basic implementation of INotifyPropertyChanged</a></li>
<li><a href="../271307/index.html">Sorting the goods and displaying the quantity of goods selected by the user in 1C-Bitrix</a></li>
<li><a href="../271311/index.html">Organization of buttons on the site using Sass</a></li>
<li><a href="../271315/index.html">Game cycle</a></li>
<li><a href="../271317/index.html">As ICQ face changed: the visual evolution of the interface ICQ</a></li>
<li><a href="../271319/index.html">Ossim. Creating a simple plugin for parsing logs</a></li>
<li><a href="../271321/index.html">How to solve the problem of machine understanding of natural language</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>