<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Magvik filter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preface from the translator 
 Here is one of the newest methods for calculating the orientation in space according to the accelerometer, gyroscope and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Magvik filter</h1><div class="post__text post__text-html js-mediator-article"><h4>  <b>Preface from the translator</b> </h4><br>  Here is one of the newest methods for calculating the orientation in space according to the accelerometer, gyroscope and compass sensors ‚Äî the Majwick filter, which, according to the author, gives better results than using a Kalman-based filter in results and performance.  Author - <a href="https://uk.linkedin.com/in/sebmadgwick">Sebastian Madzhvik</a> (his <a href="http://www.x-io.co.uk/">online store</a> ).  The method is described in the <a href="http://www.x-io.co.uk/res/doc/madgwick_internal_report.pdf">article</a> in English.  This work is protected at the <a href="https://www.linkedin.com/edu/school%3Fid%3D12689%26trk%3Dppro_sprof">University of Bristol</a> Translation, I did not find.  Translator from me so-so, especially such complex texts.  But we are also interested in that method? <br><br>  In some places I will add on my own - there the text <i>is in italics</i> .  I found more than 10 misprints in the original text.  In general, it was quite difficult, so help is welcome - write in the comments where you need to rephrase, in general, where something is wrong. <br><br><img src="https://habrastorage.org/files/9b3/9c7/2b1/9b39c72b1ea3471fb3745ee96eed1327.png"><br><a name="habracut"></a><br><h4>  <b>Filter data arrays of inertial and inertial magnetic sensors to determine the orientation</b> </h4><br>  April 30, 2010 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>From the author</b> </h4><br>  This article describes a new filter sensor readings for determining the orientation <i>in space in two ways</i> .  The first option is applicable to inertial navigation systems (INS), including an accelerometer and gyroscope.  <i>The second option is applicable to ANNs, which include an additional</i> 3-axis magnetometer ( <i>abbreviation MARG - stands for ‚ÄúMagnetic, Angular Rate and Gravity‚Äù</i> ).  Implementing an ANN with a magnetometer involves compensating for magnetic distortion and compensating for the gyroscope offset.  As a tool, quaternions are used, which allow the accelerometer and magnetometer data to be used for analytical calculations and optimization <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D0%25B4%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2581%25D0%25BF%25D1%2583%25D1%2581%25D0%25BA">by the gradient descent method</a> in obtaining the error of the gyroscope direction as a derived quaternion.  Benefits include: <br><ul><li>  low cost of computing resources - 277 simple arithmetic operations each filter update (109 operations without a magnetometer); </li><li>  efficiency at low sampling rates (for example 10 Hz); </li><li>  Contains 1 (without magnetometer) or 2 adjustable parameters, determined on the observed characteristics of the system. </li></ul><br>  Accuracy was evaluated empirically using commercially available orientation sensors.  Reference orientation values ‚Äã‚Äãare obtained using an optical measurement system.  A simple calibration method for using optical measuring equipment is presented in this paper. <br><br>  Accuracy is also compared with a proprietary Kalman filter for orientation sensors.  The results show that this filter reaches an accuracy level exceeding the filter based on the Kalman method: <br>  &lt;0.6 degrees standard deviation at rest; <br>  &lt;0.8 degrees standard deviation in a moving state. <br>  As a result of low computational load and the ability to operate at low sampling rates, new opportunities for the use of ANNs for real-time devices with low computational capabilities and requirements for high sampling rates open up. <br><br><h4>  <b>1. Introduction</b> </h4><br>  Accurate determination of orientation <i>in space</i> plays an important role in many areas, including: <br><ul><li>  Aerospace [1, 2, 3]; </li><li>  Robotics [4, 5]; </li><li>  Navigation [6, 7]; </li><li>  Analysis of human movements [8, 9] </li><li>  The interaction of human and machine movements [10]. </li></ul><br>  While various technologies can measure orientation, inertial sensor systems have the advantage of complete autonomy - the object being measured is not limited in movement, not limited to any particular environment or location.  The inertial measurement unit ( <i>BII, or from the English IMU - Inertial Measurement Unit</i> ) consists of gyroscopes and accelerometers that allow you to track rotational and translational movements.  In order to make 3D measurements, it is required that the sensor axes are mutually perpendicular.  AGM is a hybrid BII, which includes a triaxial magnetometer.  A system without a magnetometer can determine the orientation relative to the direction of gravity, which is sufficient for many applications [4, 2, 8, 1].  Inertial navigation systems use a reporting system known as ‚Äúcourse, pitch, roll‚Äù <i>(AHRS - Attitude and Heading Reference Systems)</i> , and are able to provide a complete measurement of orientation relative to gravity and the earth's magnetic field. <br><br>  The gyroscope measures the angular velocity, which, under known initial conditions, can be integrated over time to obtain the orientation of the sensor [11, 12].  Exact gyros, such as a ring laser, are too expensive and cumbersome for most applications.  On the other hand, less accurate MEMS sensors (Micro Electrical Mechanical System - micromechanical electronic systems) are used in most applications [13].  Integration of measurement errors will lead to an accumulation of errors in orientation calculations. Thus, gyroscopes, by themselves, cannot provide an absolute measure of orientation.  Accelerometer and magnetometer measure the gravitational and magnetic fields of our planet, and, accordingly, can determine the absolute value of orientation in space. <br><br>  However, they are also likely to be exposed to high levels of noise.  For example, acceleration due to movement will lead to a shift in the controlled direction of gravity.  The task of the orientation filter is to calculate a single assessment of the orientation obtained by measuring the accelerometer, gyroscope and magnetometer. <br><br>  The Kalman filter [14] has become the recognized basis for building most of the orientation determination algorithms [4, 15, 16, 17] and commercial orientation systems and inertial modules: <br><ul><li>  <a href="http://en.wikipedia.org/wiki/Xsens">xsens</a> [18], </li><li>  <a href="http://www.microstrain.com/">Microstrain</a> [19], </li><li>  <a href="http://www.vectornav.com/">VectorNav</a> [20], </li><li>  <a href="http://www.intersense.com/">InterSense</a> [21], </li><li>  <a href="http://www.pnicorp.com/">PNI</a> [22], </li><li>  <a href="http://www.moog-crossbow.com/">Crossbow</a> [23], </li></ul><br>  - they are all based on its use.  The widespread use of Kalman solutions are proof of their accuracy and efficiency, but they have several disadvantages.  They can be difficult to implement, as shown in the available literature [3, 4, 15, 16, 17, 24, 25, 26, 27, 28, 29, 30, 31, 32].  Linear regression of iteration, is fundamental to the Kalman processes, the requirements for the sampling rate, significantly exceeding the capacity of the object.  For example, a sampling frequency between 512 Hz and 30 kHz can be used in <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D1%2585%25D0%25B2%25D0%25B0%25D1%2582_%25D0%25B4%25D0%25B2%25D0%25B8%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">motion capture</a> applications.  The state of a relation describing rotating kinematics in three dimensions, as a rule, requires more state vectors and the implementation of an extended Kalman filter [4, 17, 24] for linearizing the problem. <br><br>  These problems require a large computational load to implement Kalman solutions, but also to provide clear motives for the implementation of alternative approaches.  Many previous approaches to solving these issues were based either on fuzzy processing [2, 5] or on fixing the filter [33] in favor of an accelerometer to determine orientation at low angular velocities and integrating gyro measurements when high angular velocities are detected.  This approach is simple, but can be effective only under limited operating conditions.  Bachmann and others [34] proposed an alternative approach in which the filter achieves an optimal synthesis of measurement data at all angular velocities.  However, the process requires the least squares approximation, which also adds to the computational load.  Mahoney and others [35] developed a complimentary filter, which, as practice shows, is an effective and efficient solution.  However, accuracy is only suitable for ANNs without a magnetometer. <br><br>  This article describes a new orientation filter that is applicable to an ANN without a magnetometer as well as to an ANN with a magnetometer.  The filter is engaged in processing arrays of data received from sensors and eliminates the problems of accuracy and tuning of filter parameters based on Kalman approaches.  The filter uses a quaternion to represent the orientation (for example [34, 17, 24, 30, 32]) to describe the position in space in three dimensions and does not contain problems associated with the description of the position by Euler angles (folding the frame).  The article presents a complete conclusion and empirical evaluation of the new filter.  Its accuracy is compared with existing industrial filters and verified by an optical measurement system.  Innovative aspects of the proposed filter include: <br><ul><li>  two adjustable parameters (one for implementation without a magnetometer) determined by the observed characteristics of the system; </li><li>  analytical calculations and optimization by the gradient descent method, which improves accuracy at low sampling rates; </li><li>  magnetic distortion compensation and gyroscope zero offset in real time. </li></ul><br><br><h4>  <b>2. Quaternions</b> </h4><br>  <i>This section of the article is not so interesting - it describes what a quaternion is and some basic operations.</i>  <i>All this can be seen in the <a href="http://habrahabr.ru/post/255005/">article with pictures</a> .</i>  <i>It is important for us to pay attention to the notation used by the author.</i> <br><img src="https://habrastorage.org/files/8c9/4eb/4e8/8c94eb4e8db04f9bb070de01ea7c2277.png"><br>  Fig.  1. The orientation of the axes B is achieved by rotating the axes A around the axis <img src="https://habrastorage.org/files/f21/d0d/5af/f21d0d5af5104b23bbeedcc8763b0127.png">  in report system A at an angle Œ∏. <br><br>  A quaternion is a four-dimensional complex number that can be used to represent the orientation of a pointed body or coordinates in three-dimensional space.  It is possible to describe the orientation of the reporting system B with respect to the reporting system A by turning the angle Œ∏ around the axis <img src="https://habrastorage.org/files/f21/d0d/5af/f21d0d5af5104b23bbeedcc8763b0127.png">  in the report system A. This is depicted in Figure 1, where mutually orthogonal <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D1%258F%25D0%25BC%25D0%25BE%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BA%25D0%25BE%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582">orths</a> <img src="https://habrastorage.org/files/5bc/fdb/c94/5bcfdbc9492545d8873bed0b1fb03fe4.png">  , <img src="https://habrastorage.org/files/570/c22/3eb/570c223eb7ad4998a249ec50654f4ac0.png">  and <img src="https://habrastorage.org/files/eab/bd3/8b2/eabbd38b20e4467d92388357faedc412.png">  defined by the main axis of the coordinate systems A and B, respectively.  Quaternion describing this orientation <img src="https://habrastorage.org/files/442/609/5a4/4426095a4d84422182d7c115dae1e14b.png">  defined by equation (1), where Rx, Ry and Rz are components of the vector <img src="https://habrastorage.org/files/f21/d0d/5af/f21d0d5af5104b23bbeedcc8763b0127.png">  in the corresponding X, Y, and Z axes of the report system A. For the naming of variables, report systems, and vectors, the notation used is the superscript and subscript indices according to Craig [37]. <br><br>  Ahead, the standing subscript indicates the target report system, and the ahead subscript indicates the reporting system with respect to which the variable is set.  <i>Further in the text, the S index denotes the sensor report system, and the E index the Earth report system.</i>  For example, <img src="https://habrastorage.org/files/442/609/5a4/4426095a4d84422182d7c115dae1e14b.png">  describes the orientation of the B axes with respect to the A axes, and <img src="https://habrastorage.org/files/f21/d0d/5af/f21d0d5af5104b23bbeedcc8763b0127.png">  is a vector in the report system A. Quaternion arithmetic often requires that the quaternion be normalized to unity.  Therefore, usually all quaternions describing the orientation have a length equal to one. <br><br><img src="https://habrastorage.org/files/4e4/3f0/817/4e43f0817b7e4ea78bf45b10d54c1efb.png"><br><br>  <i>Please note - in this article, the W component of the quaternion goes first (it is often placed at the end).</i> <br>  Counterdirectional quaternions are denoted by * <i>(asterisk)</i> and are used to change the reporting system.  for example <img src="https://habrastorage.org/files/4b0/c76/23e/4b0c7623e6b149b0b65e3a34abe16df3.png">  opposed to <img src="https://habrastorage.org/files/442/609/5a4/4426095a4d84422182d7c115dae1e14b.png">  * and describes the orientation of the reporting system A with respect to B. The opposite direction vector to <img src="https://habrastorage.org/files/442/609/5a4/4426095a4d84422182d7c115dae1e14b.png">  determined by equation (2). <br><br><img src="https://habrastorage.org/files/3e7/d42/076/3e7d42076e6f4351b204b6d6580a3e4b.png"><br><br>  Quaternion resulting from the operation <img src="https://habrastorage.org/files/012/6f1/159/0126f1159f014e4090ac9388f370e2d1.png">  can be used to determine composite orientations <i>(a series of turns)</i> .  For example, for two orientations <img src="https://habrastorage.org/files/442/609/5a4/4426095a4d84422182d7c115dae1e14b.png">  and <img src="https://habrastorage.org/files/2dd/9c3/193/2dd9c31935374cdc9cb6fdc0795a33f3.png">  can be found <img src="https://habrastorage.org/files/306/7bd/04e/3067bd04e9e64912b488a40e98ee581d.png">  according to the formula (3). <br><br><img src="https://habrastorage.org/files/8ee/715/23e/8ee71523e73e4291a587d26cc30c2de0.png"><br><br>  The result of multiplication for two quaternions a and b can be found using the Hamilton rule and is determined by formula (4).  When changing places of factors, the result is different (multiplication of quaternions is associative, but not commutative). <br><br><img src="https://habrastorage.org/files/8f8/e7c/d92/8f8e7cd9260a4e259e145de1937441c6.png"><br><br>  A three-dimensional vector can be rotated to a quaternion using the relationship described in equation (5) [36]. <img src="https://habrastorage.org/files/7b0/05b/3ab/7b005b3ab5ea4d0f9bedc3c4e989f78f.png">  and <img src="https://habrastorage.org/files/b1c/5c9/690/b1c5c9690e554ed3adae1cabd83d1295.png">  these are vectors in the coordinate systems A and B, respectively, where each vector contains 0 as a component of W, to make them 4 component vectors <i>(quaternions)</i> . <br><img src="https://habrastorage.org/files/ee8/037/b00/ee8037b00366426f8e3f38986e1c6ec3.png"><img src="https://habrastorage.org/files/b44/237/7bb/b442377bbeff40e282b7932b8db86989.png"><br><br>  Orientation described by quaternion <img src="https://habrastorage.org/files/442/609/5a4/4426095a4d84422182d7c115dae1e14b.png">  can be described as a rotation matrix <img src="https://habrastorage.org/files/a88/81c/4b3/a8881c4b3cab43c2bb8be46488a5da5a.png">  determined by the formula (6) [36]. <br><br><img src="https://habrastorage.org/files/911/059/8e4/9110598e4bdd447ab8d3d75ac359f303.png"><br><br>  Euler angles œà, Œ∏ and œÜ in the so-called aerospace sequence [36] describe the orientation of the axes achieved by successive rotations about the reporting system A, using the angle around the Z axis, Œ∏ around the Y axis, and œÜ around the X axis. Such Euler angles can be obtained from quaternion <img src="https://habrastorage.org/files/442/609/5a4/4426095a4d84422182d7c115dae1e14b.png">  using equations (7), (8) and (9). <br><br><img src="https://habrastorage.org/files/b65/424/f94/b65424f943e5432185bdc29631cd5d37.png"><br><br><h4>  <b>3. Filter</b> </h4><br><h5>  3.1.  Orientation of angular velocity </h5><br>  A three-axis gyroscope measures the angular velocities œâx, œây and œâz with respect to the axes X, Y, Z, respectively, in the sensor's report system.  If the values ‚Äã‚Äãof these speeds (rad / sec) are converted to quaternion <img src="https://habrastorage.org/files/fff/75f/405/fff75f405b3d40fcb6bba288e9c40e20.png">  defined by equation (10), then a derived quaternion describing the velocity in the Earth‚Äôs reporting system with respect to the sensor‚Äôs reporting system <img src="https://habrastorage.org/files/558/e71/010/558e71010b694a7fa1abffce4741e8b2.png">  can be calculated [38] by equation (11): <br><img src="https://habrastorage.org/files/b3a/7f9/ea7/b3a7f9ea7113413fbcc8b9fe91b0797b.png"><br><div class="spoiler">  <b class="spoiler_title">Where did 1/2 come from?</b> <div class="spoiler_text">  <i>How long could not understand - where did the 1/2-I?</i>  <i>This is related to the definition of a <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D1%2580%25D0%25BD%25D0%25B8%25D0%25BE%25D0%25BD%25D1%258B_%25D0%25B8_%25D0%25B2%25D1%2580%25D0%25B0%25D1%2589%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BD%25D1%2581%25D1%2582%25D0%25B2%25D0%25B0">quaternion</a> : ... a quaternion q is defined as q = w + xi + yj + zk = w + (x, y, z) = cos (a / 2) + u * sin (a / 2),</i> <i><br></i>  <i>where u is the unit vector.</i> <i><br></i>  <i>In the article on the <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25B3%25D0%25BB%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D1%2581%25D0%25BA%25D0%25BE%25D1%2580%25D0%25BE%25D1%2581%25D1%2582%25D1%258C">angular velocity,</a> there is a formula that is expressed from (11):</i> <i><br></i>  <i>If a quaternion is used to describe the rotation, expressed through the angle a and ort of the axis of rotation v as q = (cos (a / 2), v * sin (a / 2)), then the angular velocity is found from the expression:</i> <i><br><img src="https://habrastorage.org/files/e15/08a/6e5/e1508a6e53fd4e00bbb722b187c82610.png"></i>  <i>,</i> <i><br></i>  <i>where the notation in the formula coincides with the notation in the article ‚Äî a quaternion with a dot describes the angular velocity in the Earth‚Äôs reporting system, and a quaternion with a dash describes the rotation required to combine the sensor‚Äôs reporting system with the Earth‚Äôs reporting system.</i> <br></div></div><br>  The orientation in the global reporting system with respect to the local sensor reporting system at time t is <img src="https://habrastorage.org/files/8d3/92b/578/8d392b5784224ba8a721edfe0c891ef4.png">  , can be calculated by numerical integration of quaternion derivatives <img src="https://habrastorage.org/files/49c/b73/419/49cb734192c44c1ebde1579cd1c19aa8.png">  , as described in equations (12) and (13), provided that the initial orientation in space is known. <br><img src="https://habrastorage.org/files/c3e/ed4/ff7/c3eed4ff75504c75b59bd30ec0a1f2e9.png"><br>  Where <img src="https://habrastorage.org/files/07f/c2a/7d4/07fc2a7d422345af8c8cd155e8f93a24.png">  - the angular velocity measured by the sensor at time t; <br>  ‚àÜt is the delay between measurements (sampling period); <br><img src="https://habrastorage.org/files/8ae/db4/882/8aedb4882648459fb7160fd6e6e982e9.png">  - previous result of orientation assessment. <br>  The index œâ indicates that the quaternion is calculated from angular velocities. <br><br><h4>  3.2.  Orientation from vector observations </h4><br>  The three-axis accelerometer measures the magnitude and direction of the field of the local coordinate system along with linear accelerations due to the movement of the sensor.  Similarly, a three-axis magnetometer measures the magnitude and direction of the earth‚Äôs magnetic field in a local reporting system along with local magnetic distortions.  In the context of the orientation filter, at the initial moment of time it will assume that the accelerometer will measure only gravity, the magnetometer measures only the magnetic field of the Earth <i>(the device must be stationary for a while)</i> . <br><br>  If the direction of the earth's field is known in its coordinate system, then measuring the direction in the coordinate system of the sensor will allow you to calculate the position of the coordinate system of the sensor relative to the coordinate system of the Earth.  However, for any such measurement there will not be a single solution, but there will be an infinite number of solutions represented by all those orientations achieved by rotating the orientation around the rotation parallel to the field direction <i>(magnetic or gravity)</i> .  In some cases, the solution can be represented in the form of Euler angles, where there will be two known angles and one unknown.  An unknown angle will rotate around an axis parallel to the direction of the field.  To represent a solution as a quaternion, a complex solution is required.  This can be achieved by an optimization problem, where the sensor orientation <img src="https://habrastorage.org/files/1dd/773/68a/1dd77368ac884518bf94b4c058ec3b4c.png">  this is what aligns the predefined field direction in the earth's coordinate system <img src="https://habrastorage.org/files/35d/2a9/e26/35d2a9e263bb494287850091c90e1d62.png">  , with measured direction in sensor coordinate system <img src="https://habrastorage.org/files/7e8/6c0/21a/7e86c021ab684a47b343e3848c291254.png">  using the rotation operation defined by equation (5).  therefore <img src="https://habrastorage.org/files/a90/613/e89/a90613e89e5940a69b8861d719a24852.png">  can be found as a solution to equation (14), where equation (15) defines the objective function.  The components of each vector are defined in equations (16), (17) and (18). <br><img src="https://habrastorage.org/files/84e/750/8cf/84e7508cf5564357b4a39c91b50c353f.png"><br>  There are many optimization algorithms, but the gradient descent method is one of the simplest to implement and calculate.  Equation (19) describes this method for n iterations as a result of an orientation estimate. <img src="https://habrastorage.org/files/679/896/424/679896424d394ccb82ffcba10027252d.png">  based on "initial approximation" orientation <img src="https://habrastorage.org/files/bd4/e12/7d1/bd4e127d1e194a289206e506435d79af.png">  and step size ¬µ.  Equation (20) calculates the gradient of the surface of the solutions defined by the objective function and its <a href="https://ru.wikipedia.org/wiki/%25D0%25AF%25D0%25BA%25D0%25BE%25D0%25B1%25D0%25B8%25D0%25B0%25D0%25BD">Jacobian</a> , simplified to three-component vectors, defined in equations (21) and (22), respectively. <br><img src="https://habrastorage.org/files/e56/cb6/410/e56cb6410f4842fab3dbb8575891f085.png"><br><img src="https://habrastorage.org/files/894/995/b66/894995b667e8435aaff12c069dc135f0.png"><br>  Equations (19) - (22) describe the general form of the algorithm applicable to the field, originally oriented in any direction.  However, if the field direction can be considered only in one or two axes of the global coordinate system, the equation is simplified.  The corresponding agreement will assume that the direction of gravity is directed vertically, along the Z axis, as shown in equation (23).  Substituting the quaternion <img src="https://habrastorage.org/files/c4b/2a8/f3e/c4b2a8f3ea5a413497199005cee3fdbf.png">  and normalized accelerometer measurements <img src="https://habrastorage.org/files/307/49b/b81/30749bb81a884d74aeb85344f08fed06.png">  , <img src="https://habrastorage.org/files/8cf/021/cca/8cf021ccaa564c04b64b1e9a7d67a953.png">  and <img src="https://habrastorage.org/files/a7e/6de/c4c/a7e6dec4cdd3487da74ca1525c9fd928.png">  respectively, in equations (21) and (22) we obtain equation (25) and (26). <br><img src="https://habrastorage.org/files/511/fed/be2/511fedbe2fb14478a1d1d7a07de50ed9.png"><br><br>  The direction of the earth's magnetic field can also be considered to be located in one plane and measured in the horizontal and vertical axes.  The vertical component depends on the point on the globe in which the measurement takes place.  For England, this value is between 65 and 70 degrees with respect to the horizon [39].  This can be represented by equation (27).  Substituting <img src="https://habrastorage.org/files/4ef/cc3/494/4efcc34942c941728b54bab286c91cd1.png">  and normalized measurement values <img src="https://habrastorage.org/files/464/c18/493/464c18493349485490a1a9414ea21ba4.png">  , <img src="https://habrastorage.org/files/083/64a/d9e/08364ad9ec704d16914b83a0155c701b.png">  and <img src="https://habrastorage.org/files/405/c54/6b8/405c546b86274fd18f60aeeae8503f1e.png">  respectively, in equations (21) and (22) we obtain equations (29) and (30). <br><img src="https://habrastorage.org/files/ce8/2ba/b8d/ce82bab8de38484cac9aa7878e3455cf.png"><br><br>  As already discussed, the measurement of gravity or the magnetic field of the earth alone does not provide a unique sensor orientation.  To do this, the measurements and directional relationships of both fields must be combined, as described in equations (31) and (32).  While the surface of the solutions created by the objective functions in equations (25) and (29) have, at least, determined in accordance with the surface of the solutions defined by equation (31), and at least determined by one point, provided that <img src="https://habrastorage.org/files/c70/92f/26f/c7092f26f9444d8b8a3050fd6868269a.png">  . <br><img src="https://habrastorage.org/files/50f/944/c83/50f944c83a5a4087b51c2e5b83c15f13.png"><br><br>  The traditional approach to optimization will require several iterations of equation (19) to calculate the result for each new orientation and corresponding sensor measurements.  Efficient algorithms also require step size Œº to adjust the result at each iteration to the optimal value, usually derived from the second derivative of the objective function, Hesse.  However, these requirements significantly increase the computational load of the algorithm and are not necessary in our business.  It is acceptable for us to calculate one iteration per time count provided that the rate of convergence controlled by ¬µt is equal to or greater than the physical rate of change of orientation.  Equation (33) calculates the approximate direction <img src="https://habrastorage.org/files/fcc/a61/9ec/fcca619ec30d4933a246da47d0cd9b15.png">  calculated at time t based on previous orientation estimate <img src="https://habrastorage.org/files/138/61c/360/13861c36071342948694e9aa0ed3ce9e.png">  and the objective function of the gradient ‚àáf determined by measuring the sensors <img src="https://habrastorage.org/files/b79/e3c/077/b79e3c07759c4266b5a43f02bc1f3320.png">  and <img src="https://habrastorage.org/files/aa5/135/6d5/aa51356d570d4b3baa07278a3f3101f7.png">  at time t.  The shape ‚àáf is selected according to the sensors in use, as shown in equation (34).  The index ‚àá means that the quaternion is calculated using the gradient descent method. <br><img src="https://habrastorage.org/files/a33/479/55d/a3347955d4564772ba840a1577f246ae.png"><br><br>  The optimal value of ¬µt can be defined as that which ensures the rate of convergence <img src="https://habrastorage.org/files/b61/6e2/c9e/b616e2c9e8ba4fa8b613fb7c31abb890.png">  and is limited by the physical orientation speed, since it allows you to avoid exceeding due to excessively large step size.  Therefore, ¬µt can be calculated using equation (35), where ‚àÜt is the time between measurements, <img src="https://habrastorage.org/files/756/21f/2ad/75621f2adef84ab198555cc9bc08c6a3.png">  Is the physical rate of change of orientation measured by the gyroscope; Œ± is the increase in ¬µ to account for noise when measured with an accelerometer and a magnetometer. <br><img src="https://habrastorage.org/files/af7/37b/8a0/af737b8a04f7452eb187035de67e8b05.png"><br><br><h5>  3.3.  Algorithm of the uniting filter </h5><br>  We see that the orientation of the sensor in relation to the Earth <img src="https://habrastorage.org/files/48e/140/337/48e1403370e540819c01f51af5e5027f.png">  is obtained by combining orientation calculations <img src="https://habrastorage.org/files/275/dc1/d6b/275dc1d6bddd4c45b25ea715298326ac.png">  and <img src="https://habrastorage.org/files/4e5/868/bd5/4e5868bd5e9d4d749c408956301ea0f7.png">  calculated using equations (13) and (33), respectively.  Union <img src="https://habrastorage.org/files/275/dc1/d6b/275dc1d6bddd4c45b25ea715298326ac.png">  and <img src="https://habrastorage.org/files/4e5/868/bd5/4e5868bd5e9d4d749c408956301ea0f7.png">  described by equation (36), where Œ≥t and (1 - Œ≥t) are the weights applied to each orientation calculation. <br><img src="https://habrastorage.org/files/837/7ab/1fc/8377ab1fc4b04ecdb88c96498ebd0af7.png"><br><br>  The optimal value of Œ≥t can be defined as that at which the weighted divergence <img src="https://habrastorage.org/files/4d3/20c/d3a/4d320cd3afd64afdad60b1e9546f25fc.png">  equals weighted convergence <img src="https://habrastorage.org/files/31c/cf3/73c/31ccf373c38348d295592461d46dfa09.png">  .  This is represented by equation (37), where <img src="https://habrastorage.org/files/d06/938/aa1/d06938aa14054a6493042eb47c7bae4a.png">  Is the speed of convergence <img src="https://habrastorage.org/files/31c/cf3/73c/31ccf373c38348d295592461d46dfa09.png">  and Œ≤ is the rate of divergence. <img src="https://habrastorage.org/files/4d3/20c/d3a/4d320cd3afd64afdad60b1e9546f25fc.png">  , expressed as the quaternion value, derived from the corresponding measurement error of the gyroscope.  Equation (37) can be modified to determine Œ≥t in equation (38). <br><img src="https://habrastorage.org/files/95c/225/8a7/95c2258a7a454887bb3ff2ea6fe7f597.png"><br><br>  Equations (36) and (38) provide the optimal combination. <img src="https://habrastorage.org/files/4e5/868/bd5/4e5868bd5e9d4d749c408956301ea0f7.png">  and <img src="https://habrastorage.org/files/275/dc1/d6b/275dc1d6bddd4c45b25ea715298326ac.png">  provided that the rate of convergence <img src="https://habrastorage.org/files/31c/cf3/73c/31ccf373c38348d295592461d46dfa09.png">  Œ± is regulated, which is greater than or equal to the physical rate of change of orientation.  Therefore, Œ± has no upper bound.  If we assume that Œ± is very large, then ¬µt is determined by expression (35), and it also becomes very large values ‚Äã‚Äãin the simplified orientation filter equation.  Large values ‚Äã‚Äãof ¬µt used in equation (33) mean that <img src="https://habrastorage.org/files/0b6/677/d13/0b6677d13fc64a38bee844460712b44b.png">  becomes negligible and the equation can be rewritten in the form of expression (39). <br><img src="https://habrastorage.org/files/1ff/de4/989/1ffde49892e74e8d9b8bda5ad3084a34.png"><br><br>  Equation (38), which calculates Œ≥t, can be further simplified by taking the insignificance of Œ≤ values ‚Äã‚Äãin the denominator and the expression can then be rewritten as equation (40).  From equation (40), it is quite possible that Œ≥t ‚âà 0. <br><img src="https://habrastorage.org/files/dbd/9bd/0fc/dbd9bd0fc1514921b9bf0664a24e02d4.png"><br><br>  Substituting equations (13), (39) and (40) into equation (36), we directly obtain equation (41).  Note that Œ≥t in equation (41) is replaced both as expression (39) and as 0. <br><img src="https://habrastorage.org/files/495/6e4/66e/4956e466ed8247fab016640943c4cf69.png"><br><br>  Equation (41) can be simplified to equation (42), where <img src="https://habrastorage.org/files/dbd/f67/987/dbdf67987eef4438ab8a375aa8e67647.png">  - this is the calculated rate of change of orientation, determined by the expression (43); <img src="https://habrastorage.org/files/5c0/338/c72/5c0338c721cb45038aee64cbb228043d.png">  Is the direction of the error <img src="https://habrastorage.org/files/dbd/f67/987/dbdf67987eef4438ab8a375aa8e67647.png">  determined by the expression (44). <br><br><img src="https://habrastorage.org/files/5ca/53f/9ee/5ca53f9ee23e40ea9e217debf0a283a9.png"><br><br>  From equations (42), (43) and (44), we see that the filter calculates the orientation <img src="https://habrastorage.org/files/9c0/408/787/9c04087877094d168e7fbda25482b8f3.png">  by numerical integration of the estimated orientation speed <img src="https://habrastorage.org/files/42f/f1b/286/42ff1b286cd74a62bdcfd6da72581fe6.png">  .  Filter computes <img src="https://habrastorage.org/files/42f/f1b/286/42ff1b286cd74a62bdcfd6da72581fe6.png">  as the rate of change of orientation measured by the gyroscope, <img src="https://habrastorage.org/files/28f/b7f/279/28fb7f27912243d3a9548c4552bdbf23.png">  the same, but still with the error of the measurement of the gyroscope, Œ≤ - this is compensation in the direction of the alleged error; <img src="https://habrastorage.org/files/2b6/bab/a73/2b6baba7324f41098380bebf6f902340.png">  calculated on the basis of accelerometer and magnetometer measurements.  Fig.  2 shows a block diagram of a complete implementation of an orientation filter for an ANN. <br><br><img src="https://habrastorage.org/files/727/c1b/f93/727c1bf9379744008ccd98d4c6fcf46e.png"><br>  Fig.  2. Block diagram representing the complete implementation of the orientation filter for ANN <br><br><h4>  3.4.  Magnetic distortion compensation </h4><br>  Measurements of the Earth‚Äôs magnetic field will be distorted by the presence of ferromagnetic sources near the sensor.  Studies on the effect of magnetic distortions on the effectiveness of an orientation sensor showed that electrical appliances, metal furniture and metal structures used in the construction of buildings [40, 41] make a significant error.  Interference sources in the sensor's report system can be compensated by its calibration [42, 43, 44, 45].  Interference sources in the Earth‚Äôs reporting system, such as those caused by iron deposits, cause errors in the controlled direction of the Earth‚Äôs magnetic field.  Declination errors that are horizontal with respect to the earth's surface cannot be compensated without additional information about the course.  Tilt errors in the vertical plane can be compensated for by the accelerometer, which provides an additional measurement relative to the sensor. <br><br>  Controlled direction of the Earth‚Äôs magnetic field in terrestrial coordinates at time t, <img src="https://habrastorage.org/files/09d/8ed/89b/09d8ed89be0c484198ae84073a1e7868.png">  can be calculated as the normalized measurement value of the magnetometer <img src="https://habrastorage.org/files/d9a/2a7/49c/d9a2a749c8ed441085eec485d67bbcf0.png">  rotated by the orientation obtained by combining filter <img src="https://habrastorage.org/files/5c7/6ed/de9/5c76edde9b3c464da85cf80338410cd2.png">  as described in equation (45).  The effect of mistakenly tilting the magnetic field in the controlled direction of the Earth <img src="https://habrastorage.org/files/09d/8ed/89b/09d8ed89be0c484198ae84073a1e7868.png">  can be corrected if the relative direction of the earth‚Äôs magnetic field <img src="https://habrastorage.org/files/bd5/2f2/485/bd52f2485ff7466bb533fa0ae6fa5030.png">  <i>all the time</i> has the same slope.  This is achieved by calculating the normals. <img src="https://habrastorage.org/files/bd5/2f2/485/bd52f2485ff7466bb533fa0ae6fa5030.png">  and <img src="https://habrastorage.org/files/09d/8ed/89b/09d8ed89be0c484198ae84073a1e7868.png">  only on the X and Y axes in the Earth‚Äôs reporting system, as described in equation (46). <br><br><img src="https://habrastorage.org/files/5a5/7e3/d8e/5a57e3d8e2554d1c8b67e4c33e21fa5f.png"><br><br>  Compensation of magnetic distortion in this case ensures that magnetic disturbances affect only the course.  The approach also eliminates the need to preset the direction of the Earth‚Äôs magnetic field, which is a potential disadvantage of other approaches in orientation filters [17, 24]. <br><br><h4>  3.5.  Gyro zero drift compensation </h4><br>  The zero drift of the gyroscope will occur from changes in temperature, from movement, and simply with time.  Any practical implementation of the INS should take this into account.  The advantage of Kalman-like solutions is that they are able to estimate the gyroscope offset as an additional state within the framework of the system model [26, 30, 15, 24].  However, Mahoney et al. [35] showed that the zero drift of the gyroscope can also be compensated for by simple orientation filters, presenting it as part of the error of the orientation change rate.  A similar approach will be used here. <br><br>  The normalized direction of the calculated error in the rate of change of orientation <img src="https://habrastorage.org/files/b01/eb2/153/b01eb21537024b7b9af317ced0acbc02.png">  can be expressed as the angular error along each axis of the gyroscope using equation (47) and is obtained as the inverse relation from equation (11).  Gyro offset <img src="https://habrastorage.org/files/be8/2df/243/be82df2433ee4ac391f07bfd71959fc0.png">  represented as a DC component <img src="https://habrastorage.org/files/e84/7f0/a0f/e847f0a0f13040b8bfdae5dd43bcf851.png">  and therefore can be removed since the part <img src="https://habrastorage.org/files/e84/7f0/a0f/e847f0a0f13040b8bfdae5dd43bcf851.png">  weighted average by the corresponding gain Œ∂.  This compensates for the gyro measurement. <img src="https://habrastorage.org/files/adf/b91/e66/adfb91e666e8417c9b3b204527002d69.png">  as shown in equations (48) and (49).  It is assumed that the first element <img src="https://habrastorage.org/files/adf/b91/e66/adfb91e666e8417c9b3b204527002d69.png">  always 0 <br><br><img src="https://habrastorage.org/files/4b4/b1f/609/4b4b1f6094384b5a8495a5e14976af0d.png"><br><br>  Gyro compensated measurements <img src="https://habrastorage.org/files/adf/b91/e66/adfb91e666e8417c9b3b204527002d69.png">  can be used instead of the original gyro measurements <img src="https://habrastorage.org/files/fff/75f/405/fff75f405b3d40fcb6bba288e9c40e20.png">  in equation (11).  The magnitude of the angular error in each axis <img src="https://habrastorage.org/files/e84/7f0/a0f/e847f0a0f13040b8bfdae5dd43bcf851.png">  equal to the quaternion of unit length.  Therefore, the built-in gain Œ∂ directly determines the rate of convergence of the expected gyroscope bias <img src="https://habrastorage.org/files/be8/2df/243/be82df2433ee4ac391f07bfd71959fc0.png">  expressed as a derived quaternion.  Since this process requires a complete assessment of the filter orientation. <img src="https://habrastorage.org/files/9d4/f9b/f47/9d4f9bf476bb4c7ebf2e59d67a1c7f63.png">  this applies only to the implementation of a filter with a magnetometer.  Fig.  3 shows a block diagram of a representation of a full filter implementation for an ANN with a magnetometer, including compensation for magnetic distortion and gyroscope drift. <br><br><img src="https://habrastorage.org/files/795/27a/4b3/79527a4b3ea64b7abac861d53fa9007f.png"><br>  Fig.  3. A block diagram representing the complete INS filter with a magnetometer including magnetic distortion compensation (group 1) and gyro drift compensation (group 2). <br><br><h4>  3.6.  Filter gains </h4><br>  The gain of the filter Œ≤ represents all the measurement errors of the gyroscope zero, expressed as the value of the derived quaternion.  Sources of error: sensor noise, smoothing filter, quantization errors, calibration errors, sensor alignment and sensor alignment errors, non-orthogonal sensor axes, and frequency characteristics.  The filter gain Œ∂ is the convergence rate for removing gyro measurement errors that are not related to zero and is also expressed as the value of the derived quaternion.  These errors represent the gyroscope offset.  It is convenient to determine Œ≤ and Œ∂ using angular values <img src="https://habrastorage.org/files/32e/4cc/5a1/32e4cc5a14ad49c18c2b1565b5139e7d.png">  and <img src="https://habrastorage.org/files/710/6b0/3f6/7106b03f69d44e8b89d7a3a21f418116.png">  accordingly, where <img src="https://habrastorage.org/files/32e/4cc/5a1/32e4cc5a14ad49c18c2b1565b5139e7d.png">  represents an estimate of the average measurement error of zero on each axis, and <img src="https://habrastorage.org/files/710/6b0/3f6/7106b03f69d44e8b89d7a3a21f418116.png">  represents the calculated drift velocity of the gyroscope in each axis.  Using the relationship described by equation (11), Œ≤ can be defined by equation (50), where <img src="https://habrastorage.org/files/bc6/90c/99f/bc690c99fb454a5b8e910897228bf30b.png">  represents every single quaternion.  Similarly, Œ∂ can be described using equation (51). <br><br><img src="https://habrastorage.org/files/190/6b5/c2e/1906b5c2e699425ea78a3fc83c8d080d.png"><br><br><h4>  <b>4. Testing</b> </h4><br><h4>  4.1 Equipment </h4><br>  The filter was tested using the xsens MTX orientation sensor unit [18], containing a 16-bit three-axis: gyroscope, accelerometer and magnetometer.  The device and associated software use an operation mode where raw sensor data is received at a frequency of 512 Hz and then processed to provide calibrated sensor measurements.  Calibrated sensor measurements can be processed using the proposed filter to ensure the calculated orientation of the sensor.  The software also includes the computation of an additional estimation of the orientation with a Kalman-like filter.  Both filters - Calman-like and proposed, can work using the same sensor output data.  The accuracy of each algorithm is evaluated with respect to each other as the accuracy of independent sensors. <br><br>  The Vicon system, consisting of 8 MX3 + cameras, connected to the MXultranet [46] server and Nexus [47] software was used to provide reference measurements of the actual orientation of the orientation sensor.  The system of the array of IR (infrared) sensitive cameras with included IR illuminators.  Cameras are fixed on calibrated positions and orientations so that the object of measurement is in the field of view of several cameras.  The Cartesian positions of IR reflecting optical markers attached to the measurement object can be calculated in the coordinate system of the camera array.  The cameras were installed at a height of approximately 2.5 m and were evenly distributed around the perimeter of the site 4 m by 4 m. Each camera was oriented towards the center of the room, approximately from 30‚ó¶ to 60‚ó¶ to the horizontal.  The experiments were carried out with the object of measurement in the center of the room at a height of about 1 m. To measure the orientation of the sensor, it was attached to an optical orientation measurement platform specially designed for this experiment.  The system was used to record the positions of optical markers with a speed of 120 Hz. <br><br><h4>  4.2 Determination of orientation from optical measurements </h4><br>  The orientation measurement platform consists of 3.5 m, mutually orthogonal rods rigidly connected in the center. Optical markers are fixed at each end of the rod and a platform with an orientation sensor is fixed at their intersection.  The platform was made of aluminum, carbon fiber rods and all assembled using adhesives to ensure that the structure did not have magnetic properties that could interfere with the magnetometer.  Additional optical markers were placed in arbitrary positions along the length of the rods breaking the axial symmetry in order to help identify each bar in a given dimension.  In fig.  4 shows a photograph of the orientation measurement platform, where <img src="https://habrastorage.org/files/c28/912/16b/c2891216b5c042e397fb84b623447cb3.png">  , <img src="https://habrastorage.org/files/75e/738/813/75e7388132ef422a843adec895f4f10d.png">  , <br><img src="https://habrastorage.org/files/d0d/e08/b14/d0de08b147264cee84fdaae7516cd65e.png">  , <img src="https://habrastorage.org/files/128/334/bdc/128334bdcc324db98d72d16b16f969fd.png">  , <img src="https://habrastorage.org/files/3c0/7fe/cc1/3c07fecc175b428d9d05e7b228287f61.png">  and <img src="https://habrastorage.org/files/256/11e/9f2/25611e9f2c234eb7b6c3ada87f67e54e.png">  - this is the measured position of each frame marker within the visibility of the camera.  These positions can be used to define 3 mutually orthogonal vectors. <img src="https://habrastorage.org/files/748/7df/09c/7487df09c1a1469396f4ff42e8aa0b54.png">  , <img src="https://habrastorage.org/files/71c/38c/680/71c38c6808a54631bbee82ee3249c3d4.png">  and <img src="https://habrastorage.org/files/ce5/9b9/8ab/ce59b98ab5b44a8cb0cc462aca5faf30.png">  in the coordinate system of the camera, getting the directions of the axes of the platform X, Y, Z so.  as shown in equations (52), (53) and (54).  These vectors define a rotation matrix that describes the orientation of the measurement platform in the camera's coordinate system, as shown in equation (55). <br><br><img src="https://habrastorage.org/files/096/d22/4c4/096d224c441f4719bf8705de1d4de4b2.png"><br>  Fig.  4. Photo of orientation measurement platform <br><br><img src="https://habrastorage.org/files/d80/9d0/889/d809d0889da3407cb3b67c0b7efcff7d.png"><br><br>  Due to measurement errors and tolerances in the frame with markers, the rotation matrix defined by equation (55) cannot be considered orthogonal and therefore does not constitute pure rotation.  Bar-Yitzhak presents us with method (48), where, according to the optimal ‚Äúbest fit,‚Äù a quaternion can be extracted from a non-exact and non-orthogonal rotation matrix.  The method requires the construction of a 4x4 symmetric matrix, <b>K</b> , defined by equation (56), where <img src="https://habrastorage.org/files/d43/d82/f7f/d43d82f7f3834fd5b6217f6c4b203ad6.png">  matches the mth row of the nth column <img src="https://habrastorage.org/files/3e9/f92/be4/3e9f92be4e40411e8f140b123e8a33ec.png">  .  Optimal Quaternion <img src="https://habrastorage.org/files/008/90f/e73/00890fe738984f92a73896a17870a67d.png">  is found as a normalized <a href="http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">eigenvector</a> corresponding to the maximum <a href="http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">eigenvalue of the</a> matrix <b>K.</b>  Equation (57) defines the optimal alternative.  Equation (57) determines the optimal alternative quaternion, as conventionally assumed by the method, where V1, V2, V3 and V4 define the elements of the normalized <a href="http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors">eigenvector</a> . <br><br><img src="https://habrastorage.org/files/deb/709/092/deb709092709441586fdaacd2ad421fc.png"><br><br><h4>  4.3 Calibration of the combination of report systems </h4><br>  In order to compare the optical measurements of the orientation of the platform in the frame of the camera, <img src="https://habrastorage.org/files/8ab/b73/082/8abb73082502430c9f1eea44e6ac1bf0.png">  , and the proposed filter orientation relative to the Earth, <img src="https://habrastorage.org/files/c04/063/1ae/c040631aed3447eb914164f333f722e8.png">  , it is required to know the alignment of the Earth‚Äôs reporting system with respect to the camera‚Äôs reporting system, <img src="https://habrastorage.org/files/8d5/ec1/350/8d5ec135067a4087804788544025f872.png">  , and alignment of the measuring platform, relative to the sensor report system <img src="https://habrastorage.org/files/32e/ffa/bf4/32effabf4c8e44a1ae013b4a397b907d.png">  .  Once these values ‚Äã‚Äãhave been found, the optical measurement of the orientation of the sensor in the Earth‚Äôs reporting system, <img src="https://habrastorage.org/files/2c5/866/e66/2c5866e66d5d4f7dbd73c336c1b89d6d.png">  , is determined by the formula (58).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although the use of optical equipment is described in the annexes to documents [26, 24, 41], there is a proposal to discuss a little about the calibration of these two quantities. </font></font><br><br><img src="https://habrastorage.org/files/dfd/9dc/101/dfd9dc101129458ebc8e1cd88ce340e2.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The X and Z axes of the Earth‚Äôs reporting system are determined by its magnetic field and gravity. </font><font style="vertical-align: inherit;">Measurement of these fields in the camera report system can be used to align</font></font><img src="https://habrastorage.org/files/8d5/ec1/350/8d5ec135067a4087804788544025f872.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The direction of gravity is determined using a thread with a weight (pendulum) with a length of 1 meter attached to the platform. The optical marker is placed on the weight and the end of the wobble is reached </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, i.e. the weight is brought to a stationary state</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An additional optical marker is required at an arbitrary fixed location relative to a static pendulum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(weight)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in order to break the axial symmetry of the ‚Äúconstellation‚Äù of optical markers.</font></font> Fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5 shows a commented photo of the pendulum, where </font></font><img src="https://habrastorage.org/files/753/f46/a5d/753f46a5dae74dcbb2d03099840969ba.png">  and <img src="https://habrastorage.org/files/0c7/e1b/b73/0c7e1bb7331743f186e4d9c5d67020ce.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">determine the position of markers in the camera's report system. </font><font style="vertical-align: inherit;">The average position of each marker for a certain period of time determines the direction of the pendulum in the camera‚Äôs reporting system,</font></font><img src="https://habrastorage.org/files/9ff/e0b/676/9ffe0b6760b4480dab4e477b902ecc2b.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This directly determines the Z axis of the Earth‚Äôs reporting system in the camera‚Äôs reporting system </font></font><img src="https://habrastorage.org/files/fbb/262/47e/fbb26247ef5947828bbb38bb5b548068.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as shown in equation (59).</font></font><br><br><img src="https://habrastorage.org/files/971/358/b68/971358b6804e4659bd3437e0347ca59d.png"><br><br><img src="https://habrastorage.org/files/61e/ec6/b6e/61eec6b6e2c441e0b7a75d2f0794a08a.png"><br>  Fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5: Photograph of a pendulum and optical markers used to measure the direction of gravity in the camera‚Äôs reporting system The </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direction of the earth‚Äôs magnetic field was measured using a magnetic compass made from a meter-long carbon fiber rod with neodymium magnets attached to each end. </font><font style="vertical-align: inherit;">The direction of the north and south poles of the magnets is the same. </font><font style="vertical-align: inherit;">The compass is suspended on a cotton thread and brought to rest. </font><font style="vertical-align: inherit;">Optical markers are placed at the ends of the rod, as well as asymmetrically elsewhere along the rod, in order to break the axial symmetry of the ‚Äúconstellation‚Äù </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(probably to identify each end)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font> In fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6 shows a commented photograph of the compass, where </font></font></font></font><img src="https://habrastorage.org/files/753/f46/a5d/753f46a5dae74dcbb2d03099840969ba.png">  and <img src="https://habrastorage.org/files/0c7/e1b/b73/0c7e1bb7331743f186e4d9c5d67020ce.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I determine the position of optical markers in the camera's report system. The average position of each marker over a period of time determines the position of the compass in the camera's reporting system </font></font><img src="https://habrastorage.org/files/901/943/c95/901943c950b54e0cbca20b29e6b7eeb2.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as shown in expression (60). </font></font><br><br><img src="https://habrastorage.org/files/2c2/698/022/2c269802285141c9aae5a99c8ab9cdde.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 6: Photograph of a magnetic compass and optical markers used to measure the direction of the Earth‚Äôs magnetic field in the camera‚Äôs reporting system </font></font><br><br><img src="https://habrastorage.org/files/ad1/922/084/ad1922084dab42d1b2b5acb4d96e839c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to measurement errors and an imbalance of a suspended magnetic compass, </font></font><img src="https://habrastorage.org/files/901/943/c95/901943c950b54e0cbca20b29e6b7eeb2.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it cannot be considered orthogonal towards gravity defined as </font></font><img src="https://habrastorage.org/files/9ff/e0b/676/9ffe0b6760b4480dab4e477b902ecc2b.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and therefore </font></font><img src="https://habrastorage.org/files/901/943/c95/901943c950b54e0cbca20b29e6b7eeb2.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cannot be used for direct determination of the X axis of the Earth. Non-orthogonality </font></font><img src="https://habrastorage.org/files/901/943/c95/901943c950b54e0cbca20b29e6b7eeb2.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be calculated as a projection </font></font><img src="https://habrastorage.org/files/901/943/c95/901943c950b54e0cbca20b29e6b7eeb2.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the axis</font></font><img src="https://habrastorage.org/files/9ff/e0b/676/9ffe0b6760b4480dab4e477b902ecc2b.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This component can be removed from </font></font><img src="https://habrastorage.org/files/901/943/c95/901943c950b54e0cbca20b29e6b7eeb2.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to determine the direction of the X-axis of the Earth in the camera's reporting system </font></font><img src="https://habrastorage.org/files/149/6d3/be1/1496d3be1b594b31b76a1bd87791caf5.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as shown in expression (61). </font><font style="vertical-align: inherit;">After normalization, we obtain the X axis of the Earth,, </font></font><img src="https://habrastorage.org/files/678/10f/68d/67810f68d3b444cf94758347c803639f.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as shown in expression (62). </font></font><br><br><img src="https://habrastorage.org/files/c36/0ed/0a0/c360ed0a0bbd4c4ca69232171bdbf127.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Y axis of the Earth‚Äôs reporting system in the camera‚Äôs reporting system </font></font><img src="https://habrastorage.org/files/0be/2b0/a9a/0be2b0a9a0f544b6bbd7ef1792dc8921.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be calculated as the perpendicular to</font></font><img src="https://habrastorage.org/files/678/10f/68d/67810f68d3b444cf94758347c803639f.png">  and <img src="https://habrastorage.org/files/fbb/262/47e/fbb26247ef5947828bbb38bb5b548068.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as defined in equation (63) and where the signs are chosen so that the direction of the axes is consistent with the agreement </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(meaning the right and left coordinate systems)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The alignment of the terrestrial reporting system can be defined as a rotation matrix </font></font><img src="https://habrastorage.org/files/dac/22c/2e6/dac22c2e6f2e4d878c281692ed1db5e8.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constructed from</font></font><img src="https://habrastorage.org/files/678/10f/68d/67810f68d3b444cf94758347c803639f.png">  , <img src="https://habrastorage.org/files/0be/2b0/a9a/0be2b0a9a0f544b6bbd7ef1792dc8921.png">  and <img src="https://habrastorage.org/files/fbb/262/47e/fbb26247ef5947828bbb38bb5b548068.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The quaternion representation </font></font><img src="https://habrastorage.org/files/618/968/2d5/6189682d526543ddabf6c669b16d1ca1.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be obtained by the method of Bar-Yitzchak [48]. </font></font><br><br><img src="https://habrastorage.org/files/858/e6a/036/858e6a03616b48c7968d30b4b6732a85.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to find the alignment </font></font><img src="https://habrastorage.org/files/799/946/1ac/7999461ac9f340ac99efecd81e351ee0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is assumed that the static error of the filter based on the Kalman method is equal to zero on average. </font><font style="vertical-align: inherit;">The average output </font></font><img src="https://habrastorage.org/files/d46/8d1/971/d468d19717b749c4be9309f33c5ee812.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was calculated by measuring the platform, which is stationary for about 10 seconds. </font><font style="vertical-align: inherit;">This was used with alignment </font></font><img src="https://habrastorage.org/files/b0d/467/af8/b0d467af8fd7432392ba59903063b089.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and optical measurement </font></font><img src="https://habrastorage.org/files/8ab/b73/082/8abb73082502430c9f1eea44e6ac1bf0.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to determine the alignment of the platform in the sensor report system </font></font><img src="https://habrastorage.org/files/32e/ffa/bf4/32effabf4c8e44a1ae013b4a397b907d.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as defined in expression (65).</font></font><br><br><img src="https://habrastorage.org/files/f61/32e/bd6/f6132ebd668b4a7f8e502105f1db079c.png"><br><br><h4>  4.4.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The procedure for conducting experiments </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optical measurement data and raw orientation sensor data were recorded simultaneously. Then, the raw data of the orientation sensors were processed by an appropriate program to calibrate the sensor data and the filter output based on Kalman. This data is then synchronized with the data of optical measurements, while the data of optical measurements are interpolated due to the higher frequency of measurements of orientation sensors. Then the calibrated sensor data is processed using both variants of the proposed method: with and without a magnetometer. Optical data is extracted by the methods described in 4.2 and 4.3.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The gain Œ≤ of the proposed filter was set to 0.033 for implementation without a magnetometer and 0.041 for implementation with a magnetometer. The generalizations from section 5.3 show that the coefficients found provide maximum accuracy. However, during the first 10 seconds, a factor of 2.5 was used to ensure the convergence of the algorithm under the initial conditions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gain Œ∂, applicable only to the version with a gyroscope, was set to 0, since the calibration of orientation sensors does not imply a gyroscope bias drift.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data was obtained for a sequence of turns made by hand. </font><font style="vertical-align: inherit;">The measurement platform is at rest for 20-30 seconds to allow the algorithm to stabilize time. </font><font style="vertical-align: inherit;">Then the platform is rotated 90‚ó¶ around its axis X, and then 180‚ó¶ in the opposite direction, and then it is rotated 90‚ó¶ to bring the platform to its original position. </font><font style="vertical-align: inherit;">The platform between each rotation is held stationary for 3 to 5 seconds. </font><font style="vertical-align: inherit;">This sequence is then repeated for the Y and Z axes. The peak of the angular velocity measured during each turn ranged from 110‚ó¶ / s to 190‚ó¶ / s. </font><font style="vertical-align: inherit;">The experiment was repeated 8 times to get an idea of ‚Äã‚Äãthe accuracy of the system.</font></font><br><br><h4> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Results</font></font></b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Among the generally accepted methods for quantifying the characteristics of the orientation filter [24, 26, 18, 19, 20, 21], we see the root-mean-square errors in the mobile (dynamic) and stationary (static) states apart from Euler angles describing the course, roll, pitch. The pitch œÜ, roll Œ∏ and heading œà correspond to rotation around the X, Y, Z axes, respectively, in the sensor report system. The corners mentioned above are detached from Euler angles and can be more easily interpreted and visualized. The disadvantage of the Euler angles is that they do not describe the relationship between the parameters, and they are also subject to large unstable errors when the values ‚Äã‚Äãof some angles reach the poles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Euler angles were calculated directly from the resulting quaternion using equations (7), (8) and (9).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In total, 4 sets of Euler parameters were calculated, they correspond to calibrated optical orientation measurements, orientation estimation by the filter based on the Kalman method, and the proposed orientation estimation filter for implementations with and without a sensor. </font><font style="vertical-align: inherit;">The errors of the estimated Euler parameters: œÜ, Œ∏ and œà, were calculated as the difference between the Euler parameters of the calibrated optical measurements and the corresponding parameters at the output of the filter.</font></font><br><br><h4>  5.1.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Average results </font></font></h4><br>  In fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7, 8 and 9 show the average results for 8 experiments for both the filter based on the Kalman method and the proposed implementation of the filter with a magnetometer. </font><font style="vertical-align: inherit;">In each figure there are 3 graphics. </font><font style="vertical-align: inherit;">The upper plot represents the optically measured angle. </font><font style="vertical-align: inherit;">Further, the angle estimate by the filter based on the Kalman method, and finally the angle estimate by the represented filter. </font><font style="vertical-align: inherit;">The two graphs below represent the calculated error in each of the proposed angles. </font></font><br><br><img src="https://habrastorage.org/files/82b/f04/d22/82bf04d22d0044048dc20bef72d881c2.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 7. Average results of measurements and estimates of the angle œÜ (above) and estimation errors (below) </font></font><br><br><img src="https://habrastorage.org/files/44c/85e/8a5/44c85e8a5f774666afcc914440f30da3.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 8. Average results of measurements and estimates of the angle Œ∏ (above) and estimation errors (below) </font></font><br><br><img src="https://habrastorage.org/files/a26/2a4/b02/a262a4b024ea49e98e815e36a79d502e.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 9. Average results of measurements and estimates of the angle (above ) and evaluation errors (below)</font></font><br><br><h4>  5.2.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Static and dynamic characteristics </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Standard deviations of angles </font></font><img src="https://habrastorage.org/files/36e/b5f/fe0/36eb5ffe094a42d7b0c6962607790464.png">  , <img src="https://habrastorage.org/files/016/8cf/4e7/0168cf4e7798460ca349612944efbc1a.png">  and <img src="https://habrastorage.org/files/ca1/fc9/51a/ca1fc951a1f2425cbd5f482d2b8e62c4.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">were calculated on the assumption that the angular velocity in the stationary state was &lt;5 / s, and in the moving state ‚â• 5 / s. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This threshold was chosen to be high enough relative to the noise level of the input data. Each value of the standard deviation was calculated in the time interval in which the corresponding Euler angle was rotated, as shown in Fig. 7, 8 and 9. This was done in order to prevent errors due to the initial convergence or features in the representation of Euler angles, that is, when Œ∏ = ¬± 90 </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(talking about </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25BB%25D0%25B0%25D0%25B4%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BE%25D0%25BA"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">folding the frame</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The results are shown in Table 1. Each value represents the average of all 8 experiments. The values ‚Äã‚Äãof the standard deviation</font></font><img src="https://habrastorage.org/files/ca1/fc9/51a/ca1fc951a1f2425cbd5f482d2b8e62c4.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">were not calculated for implementation without a magnetometer, since this implementation is not intended to accurately determine the course and cannot compensate for the accumulation of errors in this parameter. </font></font><br><br><img src="https://habrastorage.org/files/053/acb/125/053acb125f9d4056ba36bcfa1da773db.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table 1. Standard deviations for filters: based on the Kalman method and the proposed method in realizations with and without a magnetometer</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The results show that the proposed filter achieves higher accuracy than the filter based on the Kalman method. Orientation sensor manufacturers indicate average deviations of filters based on the Kalman method in the range &lt;0.5‚ó¶ for the angles œÜ and Œ∏ and &lt;1‚ó¶ for [18]. These values ‚Äã‚Äãdo not correspond to those given in Table 1. Other studies [49] showed that the accuracy can be significantly lower than those given by the manufacturers and that the level of accuracy indicated by them is achieved only during calibration. The low accuracy levels in heading measurement are caused by the low level of sensor accuracy in measuring the Earth‚Äôs magnetic field. The slope of the Earth‚Äôs magnetic field during testing was between 65 ¬∞ and 70 ¬∞ with respect to the horizon [39]. As a consequence, the component of the flux vector for determining the course is relatively small. The larger component of the vector,along with the measurement of gravity, serves as an additional criterion for determining the roll Œ∏ and pitch œÜ. Hence the standard deviation of pitch</font></font><img src="https://habrastorage.org/files/ca1/fc9/51a/ca1fc951a1f2425cbd5f482d2b8e62c4.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and roll </font></font><img src="https://habrastorage.org/files/016/8cf/4e7/0168cf4e7798460ca349612944efbc1a.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be less than the course</font></font><img src="https://habrastorage.org/files/36e/b5f/fe0/36eb5ffe094a42d7b0c6962607790464.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The magnetometer, as indicated in [18], has a bandwidth of 10 Hz, which, compared with the bandwidth of the accelerometer and gyroscope, which ranges from 30 to 40 Hz, also implies an increased error in determining the course </font></font><img src="https://habrastorage.org/files/36e/b5f/fe0/36eb5ffe094a42d7b0c6962607790464.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a stationary state.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.3. </font><font style="vertical-align: inherit;">The effect of filter gain on accuracy</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The results of the study of the effect of the gain Œ≤ on the filter accuracy are displayed as a graph in Fig. </font><font style="vertical-align: inherit;">10. The experimental data were processed by limiting Œ≤ values ‚Äã‚Äãbetween 0 and 0.5. </font><font style="vertical-align: inherit;">Each filter implementation has its own optimal value Œ≤, which is high enough to compensate for the accumulation of errors and low enough so that unnecessary noise does not fall into large steps of the gradient descent.</font></font><br><br><img src="https://habrastorage.org/files/72e/c68/52a/72ec6852adcb4bf0b6e18937b2bf9f83.png"><br>  Fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. The effect of filter gain Œ≤ on accuracy </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.4. </font><font style="vertical-align: inherit;">The effect of measurement frequency on accuracy</font></font></h4><br>  In fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11 presents the results of a study of the effect of the measurement frequency on the filter accuracy. The experiments were carried out using the optimal value of the gain Œ≤ for both realizations (with and without a magnetometer). The change in the frequency of measurements was simulated by skipping part of the measurements and ranged from 1 Hz to 512 Hz. From fig. 11 it can be seen that the proposed filter achieves the same level of accuracy at a sampling frequency of 50 Hz, as at a frequency of 512 Hz. Both implementations of the filter achieve a reduction in static error </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(in a stationary state)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;2  and dynamic error </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(in the moving state of the platform)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;7‚ó¶ already at a sampling frequency of 10 Hz. This level of accuracy is sufficient for use in human capture applications.</font></font><br><br><img src="https://habrastorage.org/files/d4b/381/cac/d4b381cacc7449b1bf063e30b4d7ff07.png"><br>  Fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Effect of measurement frequency on filter accuracy for implementations with and without a magnetometer </font></font><br><br><h4>  5.5.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gyro zero drift </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The calibrated gyro data used in the proposed filter does not contain any bias errors. </font><font style="vertical-align: inherit;">In order to investigate the ability of the proposed filter to offset drift compensation, errors were artificially entered into the data of all 8 experiments. </font><font style="vertical-align: inherit;">A constant drift of 0.2‚ó¶ / s / s was added to the measurements of the gyroscope on the X axis </font></font><img src="https://habrastorage.org/files/57c/f75/4b4/57cf754b4468498a9e6986bd79e1ac43.png"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and a constant bias error of ‚àí0.2 / s / s to the measurements of the gyroscope on the Y axis</font></font><img src="https://habrastorage.org/files/1d3/341/0ae/1d33410ae326470d8a2a21feb9244524.png">  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The gain Œ∂ was set to 0 for the first 10 seconds during each experiment, while the filter converged with the initial conditions. </font><font style="vertical-align: inherit;">After that, the value was set to 0.015 as the corresponding maximum gyroscope displacement rate of 1‚ó¶ / s / s.</font></font> Fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12 shows the average results of 8 experiments, showing the gyro zero offset according to the filter estimates from the actual position along the gyroscope axes X and Y. The filter accuracy under these conditions is described in table 1. </font></font><br><br><img src="https://habrastorage.org/files/3cc/954/ec4/3cc954ec4ef14194b0b404b975b68d52.png"><br>  Fig.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12 Tracking gyro zero drift filter </font></font><br><br><h4> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Discussion</font></font></b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the beginning of work on the filter, it was assumed that the accelerometer and magnetometer would measure only the force of gravity and the magnetic field of the Earth. </font><font style="vertical-align: inherit;">In practice, due to the acceleration of the movement, this leads to an erroneous observed direction of gravity </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(especially if the overload created by the movement is commensurate or more than the magnitude of the force of gravity)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which gives a potentially incorrect estimate of the height, and the distortion of the magnetic field gives an incorrect estimate of the course. In many filter implementations, the authors make the assumption that the acceleration of motion and magnetic distortion are present only for a short period of time. Therefore, the magnitude of the filter gain Œ≤ can be chosen low enough so that the deviation caused by erroneous ideas about the gravitational and magnetic distortions observed in the field is reduced to an acceptable level for the period. The minimum allowable value of Œ≤ is limited by the measurement accuracy of the gyroscope.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In many applications, it may be useful to use the dynamic increment of Œ≤ and Œ≤ values. This will reduce the effect of the accelerometer or magnetometer on the assessment of the current position during problem periods, for example, when a large overload is detected. Using large filter gains during initialization can also improve filter convergence in initial conditions. For example, it was found that increasing Œ≤ and Œ∂ by 10 allows for 5 seconds from the moment the filter was turned on to compensate for the gyroscope bias error of 1000 degrees / s in each axis.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The filter structure for the installation of an INS sensor array with a magnetometer is similar to that proposed by Bachmann and others [34]. Both implementations of the filter estimate the measurement error of the gyroscope as the gradient of the error surface created by the measurements of the accelerometer and the magnetometer. The Bachmann filter calculates this using the Gauss-Newton approach, which requires numerical differentiation and matrix inversion. The filter proposed in this report uses Jacobi‚Äôs analytical derivation and works on a normalized error surface gradient. As a result, the filter proposed in this article provides for a significant reduction in the computational load and allows the filter to optimally amplify the source based on the observed characteristics of the system.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The experimental procedure used to assess the accuracy of the filter has several limitations. </font><font style="vertical-align: inherit;">The filter was not evaluated for simultaneous rotation around more than one axis and rotation speeds were limited in magnitude and time. </font><font style="vertical-align: inherit;">These limitations were necessary for repeatability and quantification to be possible.</font></font><br><br><h4> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7. Conclusions</font></font></b> </h4><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Essentially the repetition of the text from the introduction.</font></font></i> <br><br><h4> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix A. Implementing a filter on C without a magnetometer</font></font></b> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following source code is an implementation of an orientation filter without a magnetometer. </font><font style="vertical-align: inherit;">C-code has been optimized to minimize the required number of arithmetic operations due to RAM. </font><font style="vertical-align: inherit;">Each filter update requires 109 scalar arithmetic operations (18 addition operations, 20 subtractions, 57 multiplications, 11 divisions and 3 square root). The implementation requires 40 bytes of RAM for global variables and 100 bytes of RAM for local variables during each call filter update functions.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Appendix A. Implementing a filter on C without a magnetometer</font></font></b> <div class="spoiler_text"><pre><script type="text/javascript">function gtElInit() {var lib = new google.translate.TranslateService();lib.translatePage('ru', 'en', function () {});}</script><script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=gtElInit&amp;client=wt"></script><code class="hljs pgsql">// Math library required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'sqrt'</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;math.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> constants #define deltat <span class="hljs-number"><span class="hljs-number">0.001</span></span>f // sampling period <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seconds (shown <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ms) #define gyroMeasError <span class="hljs-number"><span class="hljs-number">3.14159265358979</span></span>f * (<span class="hljs-number"><span class="hljs-number">5.0</span></span>f / <span class="hljs-number"><span class="hljs-number">180.0</span></span>f) // gyroscope measurement error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rad/s (shown <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> deg/s) #define beta sqrt(<span class="hljs-number"><span class="hljs-number">3.0</span></span>f / <span class="hljs-number"><span class="hljs-number">4.0</span></span>f) * gyroMeasError // compute beta // <span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> variables <span class="hljs-type"><span class="hljs-type">float</span></span> a_x, a_y, a_z; // accelerometer measurements <span class="hljs-type"><span class="hljs-type">float</span></span> w_x, w_y, w_z; // gyroscope measurements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rad/s <span class="hljs-type"><span class="hljs-type">float</span></span> SEq_1 = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f, SEq_2 = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, SEq_3 = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f, SEq_4 = <span class="hljs-number"><span class="hljs-number">0.0</span></span>f; // estimated orientation quaternion elements <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> initial conditions <span class="hljs-type"><span class="hljs-type">void</span></span> filterUpdate(<span class="hljs-type"><span class="hljs-type">float</span></span> w_x, <span class="hljs-type"><span class="hljs-type">float</span></span> w_y, <span class="hljs-type"><span class="hljs-type">float</span></span> w_z, <span class="hljs-type"><span class="hljs-type">float</span></span> a_x, <span class="hljs-type"><span class="hljs-type">float</span></span> a_y, <span class="hljs-type"><span class="hljs-type">float</span></span> a_z) { // <span class="hljs-keyword"><span class="hljs-keyword">Local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> variables <span class="hljs-type"><span class="hljs-type">float</span></span> norm; // vector norm <span class="hljs-type"><span class="hljs-type">float</span></span> SEqDot_omega_1, SEqDot_omega_2, SEqDot_omega_3, SEqDot_omega_4; // quaternion derrivative <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gyroscopes elements <span class="hljs-type"><span class="hljs-type">float</span></span> f_1, f_2, f_3; // objective <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> elements <span class="hljs-type"><span class="hljs-type">float</span></span> J_11or24, J_12or23, J_13or22, J_14or21, J_32, J_33; // objective <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Jacobian elements <span class="hljs-type"><span class="hljs-type">float</span></span> SEqHatDot_1, SEqHatDot_2, SEqHatDot_3, SEqHatDot_4; // estimated direction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the gyroscope error // Axulirary variables <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> avoid reapeated calcualtions <span class="hljs-type"><span class="hljs-type">float</span></span> halfSEq_1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * SEq_1; <span class="hljs-type"><span class="hljs-type">float</span></span> halfSEq_2 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * SEq_2; <span class="hljs-type"><span class="hljs-type">float</span></span> halfSEq_3 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * SEq_3; <span class="hljs-type"><span class="hljs-type">float</span></span> halfSEq_4 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * SEq_4; <span class="hljs-type"><span class="hljs-type">float</span></span> twoSEq_1 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_1; <span class="hljs-type"><span class="hljs-type">float</span></span> twoSEq_2 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_2; <span class="hljs-type"><span class="hljs-type">float</span></span> twoSEq_3 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_3; // Normalise the accelerometer measurement norm = sqrt(a_x * a_x + a_y * a_y + a_z * a_z); a_x /= norm; a_y /= norm; a_z /= norm; // Compute the objective <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Jacobian f_1 = twoSEq_2 * SEq_4 - twoSEq_1 * SEq_3 - a_x; f_2 = twoSEq_1 * SEq_2 + twoSEq_3 * SEq_4 - a_y; f_3 = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f - twoSEq_2 * SEq_2 - twoSEq_3 * SEq_3 - a_z; J_11or24 = twoSEq_3; // J_11 negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_12or23 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_4; J_13or22 = twoSEq_1; // J_12 negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_14or21 = twoSEq_2; J_32 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * J_14or21; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_33 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * J_11or24; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication // Compute the gradient (matrix multiplication) SEqHatDot_1 = J_14or21 * f_2 - J_11or24 * f_1; SEqHatDot_2 = J_12or23 * f_1 + J_13or22 * f_2 - J_32 * f_3; SEqHatDot_3 = J_12or23 * f_2 - J_33 * f_3 - J_13or22 * f_1; SEqHatDot_4 = J_14or21 * f_1 + J_11or24 * f_2; // Normalise the gradient norm = sqrt(SEqHatDot_1 * SEqHatDot_1 + SEqHatDot_2 * SEqHatDot_2 + SEqHatDot_3 * SEqHatDot_3 + SEqHatDot_4 * SEqHatDot_4); SEqHatDot_1 /= norm; SEqHatDot_2 /= norm; SEqHatDot_3 /= norm; SEqHatDot_4 /= norm; // Compute the quaternion derrivative measured <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> gyroscopes SEqDot_omega_1 = -halfSEq_2 * w_x - halfSEq_3 * w_y - halfSEq_4 * w_z; SEqDot_omega_2 = halfSEq_1 * w_x + halfSEq_3 * w_z - halfSEq_4 * w_y; SEqDot_omega_3 = halfSEq_1 * w_y - halfSEq_2 * w_z + halfSEq_4 * w_x; SEqDot_omega_4 = halfSEq_1 * w_z + halfSEq_2 * w_y - halfSEq_3 * w_x; // Compute <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> integrate the estimated quaternion derrivative SEq_1 += (SEqDot_omega_1 - (beta * SEqHatDot_1)) * deltat; SEq_2 += (SEqDot_omega_2 - (beta * SEqHatDot_2)) * deltat; SEq_3 += (SEqDot_omega_3 - (beta * SEqHatDot_3)) * deltat; SEq_4 += (SEqDot_omega_4 - (beta * SEqHatDot_4)) * deltat; // Normalise quaternion norm = sqrt(SEq_1 * SEq_1 + SEq_2 * SEq_2 + SEq_3 * SEq_3 + SEq_4 * SEq_4); SEq_1 /= norm; SEq_2 /= norm; SEq_3 /= norm; SEq_4 /= norm; }</code> </pre> <br></div></div><br><br><h4>  <b>Appendix A. Implementing a C filter with a magnetometer</b> </h4><br>  The following source code is an implementation of an orientation filter with a magnetometer and a gyroscope drift compensation system.  C-code has been optimized to minimize the required number of arithmetic operations due to RAM.  Each filter update requires 277 scalar arithmetic operations (51 addition operations, 57 subtractions, 155 multiplications, 14 divisions and 5 square root derivations). The implementation requires 72 bytes of RAM for global variables and 260 bytes of RAM for local variables during each call filter update functions. <br><br><div class="spoiler">  <b class="spoiler_title">Appendix B. Implementing a C filter with a magnetometer</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">// Math library required <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'sqrt'</span></span> #<span class="hljs-keyword"><span class="hljs-keyword">include</span></span> &lt;math.h&gt; // <span class="hljs-keyword"><span class="hljs-keyword">System</span></span> constants #define deltat <span class="hljs-number"><span class="hljs-number">0.001</span></span>f // sampling period <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> seconds (shown <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ms) #define gyroMeasError <span class="hljs-number"><span class="hljs-number">3.14159265358979</span></span> * (<span class="hljs-number"><span class="hljs-number">5.0</span></span>f / <span class="hljs-number"><span class="hljs-number">180.0</span></span>f) // gyroscope measurement error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rad/s (shown <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> deg/s) #define gyroMeasDrift <span class="hljs-number"><span class="hljs-number">3.14159265358979</span></span> * (<span class="hljs-number"><span class="hljs-number">0.2</span></span>f / <span class="hljs-number"><span class="hljs-number">180.0</span></span>f) // gyroscope measurement error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rad/s/s (shown <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-number"><span class="hljs-number">0.2</span></span>f deg/s/s) #define beta sqrt(<span class="hljs-number"><span class="hljs-number">3.0</span></span>f / <span class="hljs-number"><span class="hljs-number">4.0</span></span>f) * gyroMeasError // compute beta #define zeta sqrt(<span class="hljs-number"><span class="hljs-number">3.0</span></span>f / <span class="hljs-number"><span class="hljs-number">4.0</span></span>f) * gyroMeasDrift // compute zeta // <span class="hljs-keyword"><span class="hljs-keyword">Global</span></span> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> variables <span class="hljs-type"><span class="hljs-type">float</span></span> a_x, a_y, a_z; // accelerometer measurements <span class="hljs-type"><span class="hljs-type">float</span></span> w_x, w_y, w_z; // gyroscope measurements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rad/s <span class="hljs-type"><span class="hljs-type">float</span></span> m_x, m_y, m_z; // magnetometer measurements <span class="hljs-type"><span class="hljs-type">float</span></span> SEq_1 = <span class="hljs-number"><span class="hljs-number">1</span></span>, SEq_2 = <span class="hljs-number"><span class="hljs-number">0</span></span>, SEq_3 = <span class="hljs-number"><span class="hljs-number">0</span></span>, SEq_4 = <span class="hljs-number"><span class="hljs-number">0</span></span>; // estimated orientation quaternion elements <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> initial conditions <span class="hljs-type"><span class="hljs-type">float</span></span> b_x = <span class="hljs-number"><span class="hljs-number">1</span></span>, b_z = <span class="hljs-number"><span class="hljs-number">0</span></span>; // reference direction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> flux <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> earth frame <span class="hljs-type"><span class="hljs-type">float</span></span> w_bx = <span class="hljs-number"><span class="hljs-number">0</span></span>, w_by = <span class="hljs-number"><span class="hljs-number">0</span></span>, w_bz = <span class="hljs-number"><span class="hljs-number">0</span></span>; // estimate gyroscope biases error // <span class="hljs-keyword"><span class="hljs-keyword">Function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> compute one <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> iteration <span class="hljs-type"><span class="hljs-type">void</span></span> filterUpdate(<span class="hljs-type"><span class="hljs-type">float</span></span> w_x, <span class="hljs-type"><span class="hljs-type">float</span></span> w_y, <span class="hljs-type"><span class="hljs-type">float</span></span> w_z, <span class="hljs-type"><span class="hljs-type">float</span></span> a_x, <span class="hljs-type"><span class="hljs-type">float</span></span> a_y, <span class="hljs-type"><span class="hljs-type">float</span></span> a_z, <span class="hljs-type"><span class="hljs-type">float</span></span> m_x, <span class="hljs-type"><span class="hljs-type">float</span></span> m_y, <span class="hljs-type"><span class="hljs-type">float</span></span> m_z) { // <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> <span class="hljs-keyword"><span class="hljs-keyword">system</span></span> variables <span class="hljs-type"><span class="hljs-type">float</span></span> norm; // vector norm <span class="hljs-type"><span class="hljs-type">float</span></span> SEqDot_omega_1, SEqDot_omega_2, SEqDot_omega_3, SEqDot_omega_4; // quaternion rate <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gyroscopes elements <span class="hljs-type"><span class="hljs-type">float</span></span> f_1, f_2, f_3, f_4, f_5, f_6; // objective <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> elements <span class="hljs-type"><span class="hljs-type">float</span></span> J_11or24, J_12or23, J_13or22, J_14or21, J_32, J_33, // objective <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Jacobian elements J_41, J_42, J_43, J_44, J_51, J_52, J_53, J_54, J_61, J_62, J_63, J_64; // <span class="hljs-type"><span class="hljs-type">float</span></span> SEqHatDot_1, SEqHatDot_2, SEqHatDot_3, SEqHatDot_4; // estimated direction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the gyroscope error <span class="hljs-type"><span class="hljs-type">float</span></span> w_err_x, w_err_y, w_err_z; // estimated direction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the gyroscope error (angular) <span class="hljs-type"><span class="hljs-type">float</span></span> h_x, h_y, h_z; // computed flux <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the earth frame // axulirary variables <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> avoid reapeated calcualtions <span class="hljs-type"><span class="hljs-type">float</span></span> halfSEq_1 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * SEq_1; <span class="hljs-type"><span class="hljs-type">float</span></span> halfSEq_2 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * SEq_2; <span class="hljs-type"><span class="hljs-type">float</span></span> halfSEq_3 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * SEq_3; <span class="hljs-type"><span class="hljs-type">float</span></span> halfSEq_4 = <span class="hljs-number"><span class="hljs-number">0.5</span></span>f * SEq_4; <span class="hljs-type"><span class="hljs-type">float</span></span> twoSEq_1 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_1; <span class="hljs-type"><span class="hljs-type">float</span></span> twoSEq_2 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_2; <span class="hljs-type"><span class="hljs-type">float</span></span> twoSEq_3 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_3; <span class="hljs-type"><span class="hljs-type">float</span></span> twoSEq_4 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_4; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_x = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_x; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_z = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_z; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_xSEq_1 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_x * SEq_1; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_xSEq_2 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_x * SEq_2; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_xSEq_3 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_x * SEq_3; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_xSEq_4 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_x * SEq_4; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_zSEq_1 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_z * SEq_1; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_zSEq_2 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_z * SEq_2; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_zSEq_3 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_z * SEq_3; <span class="hljs-type"><span class="hljs-type">float</span></span> twob_zSEq_4 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * b_z * SEq_4; <span class="hljs-type"><span class="hljs-type">float</span></span> SEq_1SEq_2; <span class="hljs-type"><span class="hljs-type">float</span></span> SEq_1SEq_3 = SEq_1 * SEq_3; <span class="hljs-type"><span class="hljs-type">float</span></span> SEq_1SEq_4; <span class="hljs-type"><span class="hljs-type">float</span></span> SEq_2SEq_3; <span class="hljs-type"><span class="hljs-type">float</span></span> SEq_2SEq_4 = SEq_2 * SEq_4; <span class="hljs-type"><span class="hljs-type">float</span></span> SEq_3SEq_4; <span class="hljs-type"><span class="hljs-type">float</span></span> twom_x = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * m_x; <span class="hljs-type"><span class="hljs-type">float</span></span> twom_y = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * m_y; <span class="hljs-type"><span class="hljs-type">float</span></span> twom_z = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * m_z; // normalise the accelerometer measurement norm = sqrt(a_x * a_x + a_y * a_y + a_z * a_z); a_x /= norm; a_y /= norm; a_z /= norm; // normalise the magnetometer measurement norm = sqrt(m_x * m_x + m_y * m_y + m_z * m_z); m_x /= norm; m_y /= norm; m_z /= norm; // compute the objective <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Jacobian f_1 = twoSEq_2 * SEq_4 - twoSEq_1 * SEq_3 - a_x; f_2 = twoSEq_1 * SEq_2 + twoSEq_3 * SEq_4 - a_y; f_3 = <span class="hljs-number"><span class="hljs-number">1.0</span></span>f - twoSEq_2 * SEq_2 - twoSEq_3 * SEq_3 - a_z; f_4 = twob_x * (<span class="hljs-number"><span class="hljs-number">0.5</span></span>f - SEq_3 * SEq_3 - SEq_4 * SEq_4) + twob_z * (SEq_2SEq_4 - SEq_1SEq_3) - m_x; f_5 = twob_x * (SEq_2 * SEq_3 - SEq_1 * SEq_4) + twob_z * (SEq_1 * SEq_2 + SEq_3 * SEq_4) - m_y; f_6 = twob_x * (SEq_1SEq_3 + SEq_2SEq_4) + twob_z * (<span class="hljs-number"><span class="hljs-number">0.5</span></span>f - SEq_2 * SEq_2 - SEq_3 * SEq_3) - m_z; J_11or24 = twoSEq_3; // J_11 negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_12or23 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * SEq_4; J_13or22 = twoSEq_1; // J_12 negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_14or21 = twoSEq_2; J_32 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * J_14or21; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_33 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * J_11or24; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_41 = twob_zSEq_3; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_42 = twob_zSEq_4; J_43 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * twob_xSEq_3 + twob_zSEq_1; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_44 = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * twob_xSEq_4 - twob_zSEq_2; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_51 = twob_xSEq_4 - twob_zSEq_2; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_52 = twob_xSEq_3 + twob_zSEq_1; J_53 = twob_xSEq_2 + twob_zSEq_4; J_54 = twob_xSEq_1 - twob_zSEq_3; // negated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> matrix multiplication J_61 = twob_xSEq_3; J_62 = twob_xSEq_4 - <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * twob_zSEq_2; J_63 = twob_xSEq_1 - <span class="hljs-number"><span class="hljs-number">2.0</span></span>f * twob_zSEq_3; J_64 = twob_xSEq_2; // compute the gradient (matrix multiplication) SEqHatDot_1 = J_14or21 * f_2 - J_11or24 * f_1 - J_41 * f_4 - J_51 * f_5 + J_61 * f_6; SEqHatDot_2 = J_12or23 * f_1 + J_13or22 * f_2 - J_32 * f_3 + J_42 * f_4 + J_52 * f_5 + J_62 * f_6; SEqHatDot_3 = J_12or23 * f_2 - J_33 * f_3 - J_13or22 * f_1 - J_43 * f_4 + J_53 * f_5 + J_63 * f_6; SEqHatDot_4 = J_14or21 * f_1 + J_11or24 * f_2 - J_44 * f_4 - J_54 * f_5 + J_64 * f_6; // normalise the gradient <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> estimate direction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the gyroscope error norm = sqrt(SEqHatDot_1 * SEqHatDot_1 + SEqHatDot_2 * SEqHatDot_2 + SEqHatDot_3 * SEqHatDot_3 + SEqHatDot_4 * SEqHatDot_4); SEqHatDot_1 = SEqHatDot_1 / norm; SEqHatDot_2 = SEqHatDot_2 / norm; SEqHatDot_3 = SEqHatDot_3 / norm; SEqHatDot_4 = SEqHatDot_4 / norm; // compute angular estimated direction <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the gyroscope error w_err_x = twoSEq_1 * SEqHatDot_2 - twoSEq_2 * SEqHatDot_1 - twoSEq_3 * SEqHatDot_4 + twoSEq_4 * SEqHatDot_3; w_err_y = twoSEq_1 * SEqHatDot_3 + twoSEq_2 * SEqHatDot_4 - twoSEq_3 * SEqHatDot_1 - twoSEq_4 * SEqHatDot_2; w_err_z = twoSEq_1 * SEqHatDot_4 - twoSEq_2 * SEqHatDot_3 + twoSEq_3 * SEqHatDot_2 - twoSEq_4 * SEqHatDot_1; // compute <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> remove the gyroscope baises w_bx += w_err_x * deltat * zeta; w_by += w_err_y * deltat * zeta; w_bz += w_err_z * deltat * zeta; w_x -= w_bx; w_y -= w_by; w_z -= w_bz; // compute the quaternion rate measured <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> gyroscopes SEqDot_omega_1 = -halfSEq_2 * w_x - halfSEq_3 * w_y - halfSEq_4 * w_z; SEqDot_omega_2 = halfSEq_1 * w_x + halfSEq_3 * w_z - halfSEq_4 * w_y; SEqDot_omega_3 = halfSEq_1 * w_y - halfSEq_2 * w_z + halfSEq_4 * w_x; SEqDot_omega_4 = halfSEq_1 * w_z + halfSEq_2 * w_y - halfSEq_3 * w_x; // compute <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> integrate the estimated quaternion rate SEq_1 += (SEqDot_omega_1 - (beta * SEqHatDot_1)) * deltat; SEq_2 += (SEqDot_omega_2 - (beta * SEqHatDot_2)) * deltat; SEq_3 += (SEqDot_omega_3 - (beta * SEqHatDot_3)) * deltat; SEq_4 += (SEqDot_omega_4 - (beta * SEqHatDot_4)) * deltat; // normalise quaternion norm = sqrt(SEq_1 * SEq_1 + SEq_2 * SEq_2 + SEq_3 * SEq_3 + SEq_4 * SEq_4); SEq_1 /= norm; SEq_2 /= norm; SEq_3 /= norm; SEq_4 /= norm; // compute flux <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the earth frame SEq_1SEq_2 = SEq_1 * SEq_2; // recompute axulirary variables SEq_1SEq_3 = SEq_1 * SEq_3; SEq_1SEq_4 = SEq_1 * SEq_4; SEq_3SEq_4 = SEq_3 * SEq_4; SEq_2SEq_3 = SEq_2 * SEq_3; SEq_2SEq_4 = SEq_2 * SEq_4; h_x = twom_x * (<span class="hljs-number"><span class="hljs-number">0.5</span></span>f - SEq_3 * SEq_3 - SEq_4 * SEq_4) + twom_y * (SEq_2SEq_3 - SEq_1SEq_4) + twom_z * (SEq_2SEq_4 + SEq_1SEq_3); h_y = twom_x * (SEq_2SEq_3 + SEq_1SEq_4) + twom_y * (<span class="hljs-number"><span class="hljs-number">0.5</span></span>f - SEq_2 * SEq_2 - SEq_4 * SEq_4) + twom_z * (SEq_3SEq_4 - SEq_1SEq_2); h_z = twom_x * (SEq_2SEq_4 - SEq_1SEq_3) + twom_y * (SEq_3SEq_4 + SEq_1SEq_2) + twom_z * (<span class="hljs-number"><span class="hljs-number">0.5</span></span>f - SEq_2 * SEq_2 - SEq_3 * SEq_3); // normalise the flux vector <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> components <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the x <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> z b_x = sqrt((h_x * h_x) + (h_y * h_y)); b_z = h_z; }</code> </pre><br></div></div><br><br><h4>  <b>Bibliography</b> </h4><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mark Euston, Paul Coote, Robert Mahony, Jonghyuk Kim, and Tarek Hamel. </font><font style="vertical-align: inherit;">A fixed-wing filter with a low-cost imu. </font><font style="vertical-align: inherit;">In 6th International Conference on Field and Service Robotics, July 2007.</font></font></li><li> Sung Kyung Hong. Fuzzy logic based closed-loop strapdown attitude system for unmanned aerial vehicle (uav). Sensors and Actuators A: Physical, 107(2):109 ‚Äì 118, 2003. </li><li> A. Kallapur, I. Petersen, and S. Anavatti. A robust gyroless attitude estimation scheme for a small fixed-wing unmanned aerial vehicle. pages 666 ‚Äì671, aug.  2009 </li><li> B. Barshan and HF Durrant-Whyte. Inertial navigation systems for mobile robots. 11(3):328‚Äì342, June 1995. </li><li> L. Ojeda and J. Borenstein. Flexnav: fuzzy logic expert rule-based position estimation for mobile robots on rugged terrain. In Proc. IEEE International Conference on Robotics and Automation ICRA '02, volume 1, pages 317‚Äì322, May 11‚Äì15, 2002. </li><li> David H. Titterton and John L. Weston. Strapdown inertial navigation technology. The Institution of Electrical Engineers, 2004. </li><li> S. Beauregard. Omnidirectional pedestrian navigation for first responders. In Proc. 4th Workshop on Positioning, Navigation and Communication WPNC '07, pages 33‚Äì36, March 22‚Äì22, 2007. </li><li> HJ Luinge and PH Veltink. Inclination measurement of human movement using a 3-d accelerometer with autocalibration. 12(1):112‚Äì121, March 2004. [9] Huiyu Zhou and Huosheng Hu. Human motion tracking for rehabilitation‚Äìa survey. volume 3, pages 1 ‚Äì 18, 2008. </li><li> EA Heinz, KS Kunze, M. Gruber, D. Bannach, and P. Lukowicz. Using wearable sensors for real-time recognition tasks in games of martial arts ‚Äî an initial experiment. In Proc. IEEE Symposium on Computational Intelligence and Games, pages 98‚Äì102, May 22‚Äì24, 2006. </li><li> JE Bortz. A new mathematical formulation for strapdown inertial navigation. (1):61‚Äì 66, January 1971. </li><li> MB Ignagni. Optimal strapdown attitude integration algorithms. In Guidance, Control, and Dynamics, volume 13, pages 363‚Äì369, 1990. </li><li> N. Yazdi, F. Ayazi, and K. Najafi. Micromachined inertial sensors. 86(8):1640‚Äì1659, August 1998. </li><li> RE Kalman. A new approach to linear filtering and prediction problems. Journal of Basic Engineering, 82:35‚Äì45, 1960. </li><li> E. Foxlin. Inertial head-tracker sensor fusion by a complementary separate-bias kalman filter. In Proc. Virtual Reality Annual International Symposium the IEEE 1996, pages 185‚Äì194,267, March 30‚ÄìApril 3, 1996. </li><li> HJ Luinge, PH Veltink, and CTM Baten. Estimation of orientation with gyroscopes and accelerometers. In Proc. First Joint [Engineering in Medicine and Biology 21st Annual Conf. and the 1999 Annual Fall Meeting of the Biomedical Engineering Soc.] BMES/EMBS Conference, volume 2, page 844, October 13‚Äì16, 1999. </li><li> JL Marins, Xiaoping Yun, ER Bachmann, RB McGhee, and MJ Zyda. An extended kalman filter for quaternion-based orientation estimation using marg sensors. In Proc. IEEE/RSJ International Conference on Intelligent Robots and Systems, volume 4, pages 2003‚Äì2011, October 29‚ÄìNovember 3, 2001. </li><li> Xsens Technologies BV MTi and MTx User Manual and Technical Documentation. Pantheon 6a, 7521 PR Enschede, The Netherlands, May 2009. </li><li> MicroStrain Inc. 3DM-GX3 -25 Miniature Attutude Heading Reference Sensor. 459 Hurricane Lane, Suite 102, Williston, VT 05495 USA, 1.04 edition, 2009. </li><li> VectorNav Technologies, LLC. VN -100 User Manual. College Station, TX 77840 USA, preliminary edition, 2009. </li><li> InterSense, Inc. InertiaCube2+ Manual. 36 Crosby Drive, Suite 150, Bedford, MA 01730, USA, 1.0 edition, 2008. </li><li> PNI sensor corporation. Spacepoint Fusion. 133 Aviation Blvd, Suite 101, Santa Rosa, CA 95403-1084 USA. </li><li> Crossbow Technology, Inc. AHRS400 Series Users Manual. 4145 N. First Street, San Jose, CA 95134, rev. c edition, February 2007. </li><li> AM Sabatini. Quaternion-based extended kalman filter for determining orientation by inertial and magnetic sensing. 53(7):1346‚Äì1356, July 2006. </li><li> HJ Luinge and PH Veltink. Measuring orientation of human body segments using miniature gyroscopes and accelerometers. Medical and Biological Engineering and Computing, 43(2):273‚Äì282, April 2006. </li><li> David Jurman, Marko Jankovec, Roman Kamnik, and Marko Topic. Calibration and data fusion solution for the miniature attitude and heading reference system. Sensors and Actuators A: Physical, 138(2):411‚Äì420, August 2007. </li><li> Markus Haid and Jan Breitenbach. Low cost inertial orientation tracking with kalman filter. Applied Mathematics and Computation, 153(4):567 575, June 2004. </li><li> D. Roetenberg, HJ Luinge, CTM Baten, and PH Veltink. Compensation of magnetic disturbances improves inertial and magnetic sensing of human body segment orientation. 13(3):395‚Äì405, September 2005. </li><li> John L. Crassidis and Landis F. Markley. Unscented filtering for spacecraft attitude estimation. Journal of guidance, control, and dynamics, 26(4):536‚Äì542, 2003. </li><li> D. Gebre-Egziabher, RC Hayward, and JD Powell. Design of multi-sensor attitude determination systems. Aerospace and Electronic Systems, IEEE Transactions on, 40(2):627 ‚Äì 649, april 2004. </li><li> NHQ Phuong, H.-J. Kang, Y.-S. Suh, and Y.-S. Ro. A DCM based orientation estimation algorithm with an inertial measurement unit and a magnetic compass. Journal of Universal Computer Science, 15(4):859‚Äì876, 2009. </li><li> Daniel Choukroun. Novel methods for attitude determination using vector observations. PhD thesis, Israel Institute of Technology, May 2003. </li><li> RA Hyde, LP Ketteringham, SA Neild, and RJS Jones. Estimation of upperlimb orientation based on accelerometer and gyroscope measurements. 55(2):746‚Äì754, February 2008. </li><li> ER Bachmann, I. Duman, UY Usta, RB McGhee, XP Yun, and MJ Zyda. Orientation tracking for humans and robots using inertial sensors. In Proc. IEEE International Symposium on Computational Intelligence in Robotics and Automation CIRA </li><li> '99, pages 187‚Äì194, November 8‚Äì9, 1999. </li><li> R. Mahony, T. Hamel, and J.-M. Pflimlin. Nonlinear complementary filters on the special orthogonal group. Automatic Control, IEEE Transactions on, 53(5):1203 ‚Äì1218, june 2008. </li><li> JB Kuipers. Quaternions and Rotation Sequences: A Primer with Applications to Orbits, Aerospace and Virtual Reality. Princeton University Press, 1999. </li><li> John J. Craig. Introduction to Robotics Mechanics and Control. Pearson Education International, 2005. </li><li> David R. Pratt Robert B. McGhee Joseph M. Cooke, Michael J. Zyda. Npsnet: Flight simulation dynamic modelling using quaternions. Presence, 1:404‚Äì420, 1994. </li><li> John Arthur Jacobs. The earth's core, volume 37 of International geophysics series. Academic Press, 2 edition, 1987. </li><li> ER Bachmann, Xiaoping Yun, and CW Peterson. An investigation of the effects of magnetic variations on inertial/magnetic orientation sensors. In Proc. IEEE International Conference on Robotics and Automation ICRA '04, volume 2, pages 1115‚Äì1122, April 2004. </li><li> CTM Baten FCT van der Helm WHK de Vries, HEJ Veeger. Magnetic distortion in motion labs, implications for validating inertial magnetic sensors. Gait &amp; Posture, 29(4):535‚Äì541, 2009. </li><li> Speake &amp; Co Limited. Autocalibration algorithms for FGM type sensors. Application note. </li><li> Michael J. Caruso. Applications of Magnetoresistive Sensors in Navigation Systems. Honeywell Inc., Solid State Electronics Center, Honeywell Inc. 12001 State Highway 55, Plymouth, MN 55441. </li><li> JF Vasconcelos, G. Elkaim, C. Silvestre, P. Oliveira, and B. Cardeira. A geometric approach to strapdown magnetometer calibration in sensor frame. In Navigation, Guidance and Control of Underwater Vehicles, volume 2, 2008. </li><li> Demoz Gebre-Egziabher, Gabriel H. Elkaim, J. David Powell, and Bradford W. Parkinson. Calibration of strapdown magnetometers in magnetic field domain. Journal of Aerospace Engineering, 19(2):87‚Äì102, 2006. </li><li> Vicon Motion Systems Limited. Vicon MX Hardware. 5419 McConnell Avenue, Los Angeles, CA 90066, USA, 1.6 edition, 2004. </li><li> Vicon Motion Systems Limited. Vicon Nexus Product Guide ‚Äî Foundation Notes. 5419 McConnell Avenue, Los Angeles, CA 90066, USA, 1.2 edition, November 2007. </li><li> Itzhack Y Bar-Itzhack. New method for extracting the quaternion from a rotation matrix. AIAA Journal of Guidance, Control and Dynamics, 23(6):10851087, Nov.Dec 2000. (Engineering Note). </li><li> MA Brodie, A. Walmsley, and W. Page. The static accuracy and calibration of inertial measurement units for 3D orientation. Computer Methods in Biomechanics and Biomedical Engineering, 11(6):641‚Äì648, December 2008. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/255661/">https://habr.com/ru/post/255661/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255651/index.html">Create a beautiful date / time / data picker in android</a></li>
<li><a href="../255653/index.html">Developing a cross-platform application using the Ionic Framework</a></li>
<li><a href="../255655/index.html">Video surveillance through 3 / 4G (part 1)</a></li>
<li><a href="../255657/index.html">Our devices to control the lighting in the smart home</a></li>
<li><a href="../255659/index.html">We pump over Stream API, or we need more sugar.</a></li>
<li><a href="../255663/index.html">Interview with Stanislav Shalunov - developer of technology used in BitTorrent and Apple</a></li>
<li><a href="../255665/index.html">PHP Digest number 60 - interesting news, materials and tools (March 30 - April 13, 2015)</a></li>
<li><a href="../255667/index.html">We do the IR remote control for the camera</a></li>
<li><a href="../255669/index.html">Bubot: Scout - a machine with control through a web interface without a line of code</a></li>
<li><a href="../255675/index.html">Fuel cells as a reliable source of energy for the data center?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>