<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Web components. Part 1: Custom Elements</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 


 This article is the first part of a small series of articles on creating web components using native HTML and JS tools. 


 The compo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Web components. Part 1: Custom Elements</h1><div class="post__text post__text-html js-mediator-article"><h6>  Introduction </h6><br><p>  This article is the first part of a small series of articles on creating web components using native HTML and JS tools. </p><br><p>  The component approach to the development of web applications relies on the creation of independent code modules that can be reused, combined on a common basis, and also have the ability to store and restore their states, interact with other components and do not depend on other components. </p><br><p>  To implement this approach, three specifications are currently being developed, the first of which will be discussed in this article.  So, we get acquainted - the <a href="https://www.w3.org/TR/custom-elements/">specification of custom elements (custom elements)</a> , the working draft of which is republished on 13.10.2016 and the latest version of which is dated 12/04/2017. <br></p><br><p>  The user element is the most important part of the API, included in the web component package, because it provides the key features, namely: </p><br><ul><li>  definition (actually, creation) of a new element </li><li>  packaging of non-standard functionality and data in one tag </li></ul><a name="habracut"></a><br><h3>  In outline </h3><br><p>  The CustomElementRegistry interface is responsible for creating custom web page elements, which allows you to register elements, returns information about registered elements, etc.  This interface is available to us as a window.customElement object, which has three methods that interest us: </p><br><ul><li>  <b>define (name, constructor [, options])</b> , the method defining the user element, its operation and parameters will be discussed in the ‚ÄúDefinition‚Äù section of this article; </li><li>  <b>get (name)</b> method that returns the user element constructor by the passed name, or undefined if no such element is specified; </li><li>  <b>whenDefined (name)</b> method that returns a Promise, which is resolved when the element with the specified name is defined (or an already completed promise if such an element is already defined). </li></ul><br><p>  The published version of the specification offers the creation of custom elements in one of two forms: an autonomous custom element (autonomous custom element) and a customized built-in element. </p><br><h3>  About the differences </h3><br><p>  An autonomous user element has no features, its use, according to the specification, is expected in phrase and streaming content, it can receive any attributes, except for the is attribute, which will be discussed later.  The DOM interface of such an element should be determined by the author, since  element inherits from HTMLElement. <br></p><br><p>  In turn, a custom inline element must be defined with the extends property.  The created custom element thus has the opportunity to inherit the semantics of the element specified by the value of the extends property.  The need for this feature authors specification due to the fact that not all existing behavior of HTML elements can be duplicated using only stand-alone elements. <br>  Differences are also noticeable in the syntax of declaring elements and their use, but it is much easier to look at examples (that is, later in the text of this article). </p><br><h3>  About Attributes </h3><br><p>  Customized embedded elements have an is attribute, which takes into account the name of a customized embedded element (according to which it was declared). <br>  Naturally, the is attribute, if it is declared on an autonomous element (which, according to the specification, cannot be done), there will be no effect. <br><br>  Otherwise, the attributes for both kinds of elements can be any, provided they are XML-compatible (correspond to <a href="https://www.w3.org/TR/xml/">www.w3.org/TR/xml/#NT-Name</a> and do not contain U + 003A - colons) and do not contain ASCII capital letters ( https://html.spec.whatwg.org/multipage/infrastructure.html#uppercase-ascii-letters). </p><br><h3>  Definition </h3><br><p>  The definition of a custom item includes: </p><br><ol><li><p>  Name </p><br><p>  In accordance with the current specification, the names are valid if they correspond to the following: <br><br></p><pre><code class="hljs smalltalk">[az] (<span class="hljs-type"><span class="hljs-type">PCENChar</span></span>)* <span class="hljs-string"><span class="hljs-string">'-'</span></span> (<span class="hljs-type"><span class="hljs-type">PCENChar</span></span>)* <span class="hljs-type"><span class="hljs-type">PCENChar</span></span> ::= <span class="hljs-comment"><span class="hljs-comment">"-"</span></span> | <span class="hljs-comment"><span class="hljs-comment">"."</span></span> | [<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-9</span></span>] | <span class="hljs-comment"><span class="hljs-comment">"_"</span></span> | [az] | <span class="hljs-symbol"><span class="hljs-symbol">#xB7</span></span> | [<span class="hljs-symbol"><span class="hljs-symbol">#xC0</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#xD6</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#xD8</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#xF6</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#xF8</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#x37D</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#x37F</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#x1FFF</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#x200C</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#x200D</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#x203F</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#x2040</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#x2070</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#x218F</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#x2C00</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#x2FEF</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#x3001</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#xD7FF</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#xF900</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#xFDCF</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#xFDF0</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#xFFFD</span></span>] | [<span class="hljs-symbol"><span class="hljs-symbol">#x10000</span></span>-<span class="hljs-symbol"><span class="hljs-symbol">#xEFFFF</span></span>]</code> </pre> <br>  , in the Extended Backus-Naur Form (EBNF) notation of the XML specification (https://www.w3.org/TR/xml/#sec-notation). <br><p>  If it is easier, they start with an ASCII small letter, do not contain capital letters, and are separated by at least one hyphen. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Names cannot have the following values: annotation-xml, color-profile, font-face, font-face-src, font-face-uri, font-face-format, font-face-name, missing-glyph. </p><br></li><li><p>  Local name </p><br><p>  For a standalone user element, this name is from the definition (defined name), and for a custom built-in element, the value passed to its extends option (while the name from the definition is used as the is value of the attribute) </p><br></li><li><p>  Constructor </p><br><p>  A constructor is called when an instance is created or upgraded, suitable for initializing a state, setting observers or creating a shadow dom.  However, there are <a href="https://html.spec.whatwg.org/multipage/custom-elements.html">some limitations</a> .  So, the first call in the body of the constructor should be a call to super () with no parameters;  the return keyword should not appear in the body of the constructor, unless it is a normal early return (return or return this);  should not call document.write () or document.open (), descendants and attributes should not be created at this stage, nor should they be accessed;  there should be only the work that is really needed only once, and all other work should, if possible, be brought into connectedCallback (see below). </p><br></li><li><p>  Prototype, JS object </p><br></li><li><p>  List <b>observedAttributes</b> </p><br><p>  The list of those attributes that change will result in calling the attributeChangedCallback method (see later).  It is determined by a static getter, which should return an array of string values. </p><br></li><li><p>  Collection of life cycle methods </p><br><p>  4 methods are presented that correspond to the component life cycle: </p><br><ul><li>  <b>connectedCallback</b> <br><p>  is called every time an element is injected into the DOM.  It is appropriate to request resources and render.  Most of the work is better to put off on this method; </p><br></li><li>  <b>disconnectedCallback</b> <br><p>  it is called each time an element is removed from the DOM and is used to free memory (cancel requests, cancel intervals, timers and handlers, etc.); </p><br></li><li>  <b>adoptedCallback</b> <br><p>  called when the item was moved to a new document, for example, by calling document.adoptNode (); </p><br></li><li>  <b>attributeChangedCallback</b> <br><p>  called each time when adding, changing or replacing attributes included in the observedAttributes list - this method will be called with three arguments: the name of the attribute that has changed, its old value and its new value. </p><br></li></ul><br><p>  They may not be assigned, because  the specification provides for their value either as a function or as null.  All the set forth callbacks are called synchronously. </p><br></li><li><p>  Construction stack </p><br><p>  an initially empty list, modified by the <a href="https://www.w3.org/TR/custom-elements/">upgrade an element</a> algorithm and HTML element constructors, whose every entry will then be either an element or a marker already created. </p><br></li></ol><h3>  Read more: Standalone user elements </h3><br><p>  The minimal syntax is simple: <br>  Creates a class that extends the class HTMLElement.  The markup of the future component is specified in this.innerHTML inside the connectedCallback. <br></p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AcEl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ connectedCallback() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.innerHTML = <span class="hljs-string"><span class="hljs-string">`&lt;p&gt;I'm an autonomous custom element&lt;/p&gt;`</span></span>; } }</code> </pre><br><p>  After declaring a class, the element must be determined by calling: </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'ac-el'</span></span>, AcEl);</code> </pre><br><p>  An example with the addition of the simplest behavior: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TimerElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ connectedCallback() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.render(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval = setInterval(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.render(), <span class="hljs-number"><span class="hljs-number">1000</span></span>); } disconnectedCallback() { clearInterval(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.interval); <span class="hljs-comment"><span class="hljs-comment">// } render() { this.innerHTML = ` &lt;div&gt;${new Date().toLocaleString({hour: '2-digit', minute: '2-digit', second: '2-digit' })}&lt;/div&gt; `; } } customElements.define('timer-element', TimerElement);</span></span></code> </pre><br><p>  The use of autonomous custom elements is possible as by specifying them as a tag: </p><br><br><pre> <code class="javascript hljs">&lt;timer-element&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">timer-element</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br><p>  or </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'timer-element'</span></span>);</code> </pre><br><p>  or </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TimerElement(); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(timer);</code> </pre><br><p>  After watching the timer work in the developer's tools, you can see that the page is not overloaded, changes are made to the DOM pointwise.  Very similar to the reactor </p><br><p>  For informational purposes, I planned to create a custom tab element through the whole cycle of articles.  At this stage, the technical task looks quite simple.  Tabs must consist of an arbitrary number of tabs (provided that the number of navigation elements corresponds to the number of tabs). <br></p><br><p>  * Looking ahead, encapsulating styles, and providing more freedom in setting the contents of both tabs and shortcuts will be discussed in the next article. <br></p><br><p>  So, I plan to create three custom elements: a navigation item, a content item, and a wrapper item.  The navigation element will accept the target attribute, its contents will associate the element with the corresponding navigation element and, at the same time, will be displayed as the text of the navigation element.  Implementation: <br></p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TabNavigationItem</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-comment"><span class="hljs-comment">//      this._target = null; } connectedCallback() { this.render(); // } static get observedAttributes() { return ['target']; } //       attributeChangedCallback attributeChangedCallback(attr, prev, next) { if(prev !== next) { this[`_${attr}`] = next; this.render(); } } //         render() { if(!this.ownerDocument.defaultView) return; this.innerHTML = ` &lt;a href="#${this._target}"&gt;${this._target}&lt;/a&gt; `; } }</span></span></code> </pre><br><p>  The class for creating a taba element should have a target attribute, whose value should associate the element with the navigation element as well as the attribute where in this case the contents of the taba will be transferred (until the content is transferred to the attribute - the user is severely limited in using tabs, but the implementation of a more flexible approach we will implement in the next article). <br></p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TabContentItem</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._target = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._content = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } connectedCallback() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.render(); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get observedAttributes() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-string"><span class="hljs-string">'target'</span></span>, <span class="hljs-string"><span class="hljs-string">'content'</span></span>]; } attributeChangedCallback(attr, prev, next) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(prev !== next) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[<span class="hljs-string"><span class="hljs-string">`_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${attr}</span></span></span><span class="hljs-string">`</span></span>] = next; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.render(); } } render() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ownerDocument.defaultView) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.innerHTML = <span class="hljs-string"><span class="hljs-string">` &lt;div&gt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">._content}</span></span></span><span class="hljs-string">&lt;/div&gt; `</span></span>; } }</code> </pre><br><p>  The wrapper element itself will contain the functional logic - it will receive all the navigation elements and hang handlers on the click event, which the _target property will define and show us the desired taboo. <br></p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TabElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLElement</span></span></span><span class="hljs-class"> </span></span>{ connectedCallback() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listener = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showTab.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.init(); } disconnectedCallback(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.navs.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nav</span></span></span><span class="hljs-function"> =&gt;</span></span> nav.removeEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listener)); } showTab(e) { e.preventDefault(); e.stopImmediatePropagation(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> target = e.target.closest(<span class="hljs-string"><span class="hljs-string">'tab-nav-item'</span></span>)._target; [...this.tabs, ...this.navs].forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (el._target === target) el.classList.add(<span class="hljs-string"><span class="hljs-string">'active'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> el.classList.remove(<span class="hljs-string"><span class="hljs-string">'active'</span></span>); }); } init() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.navs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'tab-nav-item'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.tabs = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'tab-content-item'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.navs.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">nav</span></span></span><span class="hljs-function"> =&gt;</span></span> nav.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listener)); } }</code> </pre><br><p>  * update, fixed handler removal </p><br><p>  The last but most significant step is the declaration of elements: </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'tab-element'</span></span>, TabElement); customElements.define(<span class="hljs-string"><span class="hljs-string">'tab-nav-item'</span></span>, TabNavigationItem); customElements.define(<span class="hljs-string"><span class="hljs-string">'tab-content-item'</span></span>, TabContentItem);</code> </pre><br><p>  An example of working tabs can be found <a href="https://codepen.io/Tania_N/pen/QQgWrr">here</a> </p><br><h3>  Read more: Custom Embedded Items </h3><br><p>  Custom built-in elements have two differences from stand-alone custom elements: an element can inherit the built-in classes of HTML elements, and when declaring such an element, the third argument of the .define () method becomes mandatory. <br>  Consider this example: <br></p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JumpingButton</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTMLButtonElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"hover"</span></span>, () =&gt; { <span class="hljs-comment"><span class="hljs-comment">// animate here }); } } customElements.define('jumping-button', JumpingButton, { extends: 'button' });</span></span></code> </pre><br><p>  Such an element will inherit the semantics of HTMLButtonElement and will be able to expand it. <br>  When using an element, the embedded HTML element tag will be specified, in our example, a button with an is attribute that will be passed the name from the definition of the custom element, thus: <br></p><br><pre> <code class="javascript hljs">&lt;button is=<span class="hljs-string"><span class="hljs-string">"jumping-button"</span></span>&gt;Click Me!<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br><p>  and its creation by js methods will look like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> jb = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"button"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">is</span></span>: <span class="hljs-string"><span class="hljs-string">"jumping-button"</span></span> });</code> </pre><br><p>  It is advisable not to forget that the .localName of such an element will be a ‚Äúbutton‚Äù, unlike a stand-alone user element, for which .localName is equal to the name from the definition. </p><br><p>  To date, not a single browser has implemented customized built-in elements, so for the time being it is theoretically necessary to consider examples. </p><br><h3>  Instead of a conclusion or two words about the upgrade </h3><br><p>  Since adding a custom element definition to the CustomElementRegistry (on our part, it depends on calling the define () method) can occur at any time, a regular (non-custom) element can be created, after which it can later become a custom element after registering the corresponding definition (call .define ()).  The upgrade algorithm provides for the course of events in which it may be preferable to register the definition of a user element after the corresponding element was originally created.  This allows you to implement progressive enhancement of the content of custom elements.  Agrads, however, are available only for elements in the DOM tree (i.e., for the shadow DOM, the shadowRoot must be in the document). </p><br><br><p>  Next article: <a href="https://habrahabr.ru/post/350872/">Web components.</a>  <a href="https://habrahabr.ru/post/350872/">Part 2: Shadow DOM</a> </p><br><p>  The third article: <a href="https://habr.com/post/414905/">Web components.</a>  <a href="https://habr.com/post/414905/">Part 3: html templates and imports</a> </p><br><p>  <i>Please do not judge strictly.</i>  <i>Regards Tania_N</i> </p></div><p>Source: <a href="https://habr.com/ru/post/349366/">https://habr.com/ru/post/349366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349356/index.html">Sum of iconCaption points in the cluster LoadingObjectManager</a></li>
<li><a href="../349358/index.html">Apache Ignite - database cache</a></li>
<li><a href="../349360/index.html">Bitcoin will not be a new digital money: about the drug business, transaction costs and gold</a></li>
<li><a href="../349362/index.html">SVG masks and wow effects: magic with simple words</a></li>
<li><a href="../349364/index.html">OOP without "O"</a></li>
<li><a href="../349370/index.html">How I adjusted Telegram notifications for Mi Band 2</a></li>
<li><a href="../349372/index.html">How is Alice. Yandex lecture</a></li>
<li><a href="../349374/index.html">Script Editor Age of Empires 2 can be turned into a Turing machine</a></li>
<li><a href="../349376/index.html">Game development for NES in C. Chapters 11-13. We write and debug a simple platformer</a></li>
<li><a href="../349378/index.html">Security Operations: protection against cyber threats in ServiceNow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>