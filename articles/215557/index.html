<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bitcoin: Decentralized Electronic Monetary System</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I bring to the attention of the community a free translation of the original article by Satoshi Nakamoto "Bitcoin: A Peer-to-Peer Electronic Cash Syst...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bitcoin: Decentralized Electronic Monetary System</h1><div class="post__text post__text-html js-mediator-article">  I bring to the attention of the community a <b><i>free</i></b> translation of the original article by Satoshi Nakamoto <a href="https://bitcoin.org/bitcoin.pdf">"Bitcoin: A Peer-to-Peer Electronic Cash System"</a> . <br><br>  From the translator: <br>  <i>I am not a professional translator and I don‚Äôt understand cryptography, but recently I became interested in Bitcoin technology and wanted to start learning from first principles.</i>  <i>A quick search on the Internet did not give me a translation of the main article of Satoshi Nakamoto and I decided to try to translate it myself.</i> <i><br></i>  <i>Shortly after the translation was started, I realized that English is probably not native to the author of the article, since sometimes it was extremely difficult to understand what the author means and why there are so many ‚Äúand‚Äù particles in one sentence.</i>  <i>However, most of the difficulties were overcome and I decided to present this final product to the public.</i> <br><a name="habracut"></a><br><br>  <b>Short.</b> <br><pre>     Fully decentralized version of electronic payments
     will allow online payments directly without financial
     organizations.  Digital signature is only part of the solution
     from which is lost due to the fact that you still need a confidential
     a center so that you cannot spend the same money
     several times (reuse problem).  we
     offer a solution to reusable problem with
     using technology decentralized networks.  By this decision
     is sending transactions (along with a network timestamp) to
     form of hard-to-calculate hash chains that form a record, which
     Cannot be changed without computing the hash chain.  The longest 
     the chain is the most reliable evidence 
     sequence of events due to the fact that its creation
     spent the most computing power.  Insofar as
     primary computing power controlled by nodes
     networks not affiliated with intruders, these nodes will be
     generate chains faster and longer than attackers.  Herself
     the network itself requires a minimal structure.  For the best
     performance, messages are being broadcast,
     nodes can leave the network and join again, accepting and
     writing down the longest generated hash chains
     during the absence of a node.
</pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <br><h4>  1. Introduction </h4><br>  Electronic payments on the Internet are almost entirely dependent on financial institutions that are a trusted third party to make a payment.  Although the system works well for most transactions, it suffers from a congenital defect: a model based on trust. <br><br>  Completely non-refundable payments are impossible, since financial institutions cannot avoid disputes with intermediaries.  Costs associated with intermediaries increase transaction costs, which leads to the limitation of the minimum transaction size and makes it impractical to make small daily payments.  In addition, the price increases due to the impossibility of making non-refundable payments for services that provide non-refundable services.  The ability to return requires trusted intermediaries.  Sellers are forced to beware of their customers, requiring more information from them than would be required if the possibility of non-refundable payments is possible.  A certain percentage of returns is assumed as inevitable.  These costs and doubts can be avoided if the buyer uses ordinary money, but there is no mechanism for making payments on the Internet without an intermediary that is trusted. <br><br>  That is why an electronic payment system is needed, based on cryptographic complexity instead of trust, allowing any two parties to make transfers to each other without trust brokers.  Transactions that are almost impossible to undo will protect sellers from fraudsters, and the routine escrow mechanisms can be easily implemented to protect customers.  In this article, we propose a solution to the problem of reusable funds using a distributed timestamp server that generates complex-calculated transactions in chronological order.  The system is safe as long as the friendly nodes simultaneously control more computing power than any group of attackers. <br><br><h4>  2. Transactions </h4><br>  The chain of digital signatures will be called electronic coins.  Each owner sends the coins to the next one, adding a digitally signed hash of the previous transaction and <b><i>its public key</i></b> to the end of the chain.  The payee can verify the signature (coin) by checking the chain of owners. <br><div class="spoiler">  <b class="spoiler_title">From translator</b> <div class="spoiler_text">  In the original <i>.</i>  For three days I tried to correlate what was written with the one below, until I came across an article: <a href="https://habrahabr.ru/post/114642/">habrahabr.ru/post/114642</a> Only then I realized that the ‚Äúnext owner‚Äù is not ‚Äúthe next owner in relation to the current one‚Äù, but ‚Äúthe next one in relation to previous, that is, the current. " </div></div><br><img src="https://habrastorage.org/getpro/habr/post_images/f0b/a53/32e/f0ba5332ea5f9f0ec98324033be70342.jpg"><br><br>  The problem, of course, is that the payee cannot find out if someone from the previous owners had spent the same money twice.  Usually this problem is solved by using a trusted centralized intermediary organization that checks each transaction for double spending.  After each transaction, the coin must return to the intermediary who, instead of the old one, issues a new coin, then only coins issued by the intermediary are guaranteed not to be spent twice. <br>  The problem with this approach is that the fate of the entire financial system depends on the intermediary company, since all transactions go through it like a bank. <br><br>  So, you need a way by which the recipient will know that the senders have not paid the same coins with someone else.  In our case, only the previous transaction history is important; subsequent attempts to double-use coins do not bother us.  The only way to confirm the absence of a transaction is to know all the transactions.  In the intermediary model, the intermediary is aware of all transactions and their sequence.  To achieve this without a trusted intermediary, all transactions must be known to everyone, i.e.  need a system whose members will agree on a single history of all payments.  Payment recipients need to verify that during the transaction most participants agree that it was received for the first time. <br><br><h4>  3. Timestamp server </h4><br>  The solution we offer is based on a timestamp server.  The job of the timestamp server is to hash a block of records, memorize time and publish a hash.  The time stamp is evidence that the data existed at that time and in the order in which they arrived for hashing.  Each timestamp includes the previous timestamp in its hash forming a chain, in which each successive timestamp confirms the previous one. <br><img src="https://habrastorage.org/getpro/habr/post_images/8e7/6a1/593/8e76a159367dae396cbfec8afa6bfb55.jpg"><br><br><h4>  4. Complicated calculations. </h4><br>  To implement a timestamp server based on a decentralized network, you need to use an algorithm for complex calculations such as Hashcash.  Complicated calculations involve finding the value that, when SHA-256 hashes, will give a hash that will start with a large number of zero bits.  The average computation time grows exponentially with the number of zero bits, and the result can be verified by calculating a single hash. <br><br>  For our timestamp server, we implement complex calculations by increasing the special variable (nonce) inside the block by one, until a hash with the required number of zero bits is found.  As soon as time is spent for performing complex calculations, the block cannot be changed without doing the calculation again.  Since the following blocks form a chain, the work for changing the block includes the work for changing all the following blocks after it. <br><img src="https://habrastorage.org/getpro/habr/post_images/b12/e47/471/b12e4747161fa62158e458a5a13457f1.jpg"><br><br>  Checked complex calculations also solve the problem of obtaining confirmation from the majority of participants.  A confirmation based on the principle of ‚Äúone IP address - one vote‚Äù can be discredited by anyone who has a lot of IP addresses under control.  Checked calculations are essentially "one processor - one vote."  Confirmation from the majority is the longest chain, the creation of which was spent the most amount of computing power.  If the core computing power is controlled by honest participants, an honest chain will grow faster than any chain of malicious participants.  To modify any block, the attacker will have to do the complex calculations associated with this block, as well as all the blocks after it, will need to catch up and overtake honest block builders.  We will show further that in a slow attacker, the ability to catch up exponentially decreases with the addition of new blocks. <br><br><h4>  5. Network </h4><br>  The following steps describe the network operation: <br>  1) A new transaction is broadcast to all nodes. <br>  2) Each node places new transactions in a block. <br>  3) Each node performs complex calculations to find its block <br>  4) When a node finds a solution for its block, it broadcasts this block to all nodes. <br>  5) A node accepts a block only if all transactions in it are correct and not expired. <br>  6) Consent node to accept the block is expressed in the fact that the node begins work on creating the next block in the chain, using the hash of the received block as the previous hash. <br><br>  Nodes always perceive the longest chain as correct and work on increasing it.  If two nodes simultaneously broadcast different versions of the next block, the nodes may receive each of the versions at different times.  In this case, the node starts working with the block that was received earlier, but another version should be saved in case it subsequently becomes a longer chain.  Branches can be ignored when the next stage of calculations is completed and one of the branches becomes longer than the others;  nodes working with other branches will switch to the longest. <br><br>  Broadcast sending a new transaction does not have to reach all nodes.  It will be included in the block as soon as it reaches many nodes.  Broadcast parcel blocks, too, may not reach all.  If the node has not received a block, it will request it when it receives the next block to fill in the missing links of the chain. <br><br><h4>  6. Stimulus </h4><br>  We agree that the first transaction in the block will be a special transaction that starts a new coin belonging to the creator of the block.  This will add an incentive for the nodes to maintain the network and provide a way to initially put coins into circulation, since there is no central authority for their release.  The constant addition of new coins is like mining, when resources are spent to add gold to circulation.  In our case, CPU time and electricity are consumed. <br><br>  Stimulus may also be present when transactions are being carried out.  If the value at the output of the transaction is less than the value at the input, this difference is added to the stimulus value of the block containing the transaction.  When a predetermined number of coins is issued, the stimulation will be made only through transactions, i.e. inflation will completely disappear. <br><br>  Stimulus encourages nodes to stay honest.  If a greedy attacker can gather more computing power than all honest nodes, then he will have to make a choice: to deceive people by stealing their coins or by generating new coins themselves.  He will find it more profitable to play by the rules, the rules that will allow him to get more coins than any other combinations and not to undermine the system, and with it his own state. <br><br><h4>  7. Disk Space Usage </h4><br>  While the last transactions are written to the block, the declined transactions also take up disk space.  To fix this without changing block hashes, transactions are hashed into the Merkle Tree, where only the root is included in the block hash.  Old blocks can be packed by trimming tree branches.  Internal hashes can not be saved. <br><img src="https://habrastorage.org/getpro/habr/post_images/ae1/bbc/6dc/ae1bbc6dc98fa992379f545d8f54895f.jpg"><br><br>  The block header without transactions takes approximately 80 bytes.  If blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year.  In 2008, computers were mainly sold with 2GB of RAM, and Moore‚Äôs law predicts that this value will increase by 1.2GB per year, therefore disk space should not be a problem, even if block headers are stored in memory. <br><br><h4>  8. Simplified payment verification </h4><br>  The site has the ability to check payments even if there is no information about the entire network.  It is enough for the user to have a copy of the block headers of the longest chain, which he can receive by polling the network nodes until he decides that he has received the longest chain.  After that, the user gets the Merkle branch, associating the transaction with a block with the same timestamp as the transaction.  He cannot verify the transaction itself, but by comparing it with a place in the chain, he can see that the node has accepted it, and the blocks added after confirm that the network has accepted this transaction. <br><img src="https://habrastorage.org/getpro/habr/post_images/aeb/801/b49/aeb801b4954c1628513860650b9b1d41.jpg"><br><br>  Of course, such a check is possible when most of the nodes in the network are honest, but it is vulnerable if the network is controlled by an attacker.  Although network nodes can verify each other‚Äôs transactions, a simplified method can be used by attackers for false transactions if the attackers control the network.  One method of protection against this may be the processing of messages from hosts when they detect the wrong block.  A user program, upon receiving a message, can download the entire block and a suspicious transaction in order to check it in the usual way.  For a business in which payments come often, the best solution would be to have a full-fledged network node for a safer and faster verification of transactions. <br><br><h4>  9. Combining and splitting the amount </h4><br>  Although it is possible to transfer coins separately, it may be too cumbersome to make a separate transaction for each cent transferred.  In order to be able to divide and combine amounts, transactions contain multiple inputs and outputs.  Usually they have either one input from a large previous transaction, or a set of inputs combining small amounts, as well as at least two outputs: one for payment and one for returning the change, if any, back to the sender. <br><img src="https://habrastorage.org/getpro/habr/post_images/827/d78/91c/827d7891cdcc0ae405876db0949d3c55.jpg"><br><br>  It should be noted that such a fan of transactions dependent on several transactions, which depend on several more, is not a problem here, because there is never any need to restore the history of all transactions. <br><br><h4>  10. Confidentiality </h4><br>  In the traditional banking model, confidentiality is achieved by restricting access to information by all parties involved.  The need to publicly announce all transactions eliminates this approach, but confidentiality can still be maintained due to the anonymity of public keys.  Everyone can see that someone has transferred a certain amount to someone, but this information cannot be compared with a specific person.  This is like stock trading, where the time and size of transactions are known to everyone, but the parties to the transaction are not disclosed. <br><img src="https://habrastorage.org/getpro/habr/post_images/843/d32/f1f/843d32f1f9d89daf2db9d7958491d4d2.jpg"><br><br>  As an additional security screen, for each transaction a new key pair must be used that cannot be matched with the common owner.  Some comparisons are still unavoidable in transactions with many entries, since all entries are considered to belong to the same owner.  The risk is that if the owner of the key is identified, it will be possible to find out other transactions of this owner. <br><br><h4>  11. Calculations </h4><br>  Consider a scenario where an attacker tries to generate an alternative chain faster than honest nodes.  Even if he succeeds, he will not be able to make any changes in the system, for example, to create coins from the air or take coins that no one has transferred to him.  Nodes will not accept an incorrect transaction as a payment, and honest nodes will never accept a block with an incorrect transaction.  An attacker can only change one of his own transactions by returning to himself the payment he recently made. <br><br>  The race between the fair chain and the attacker's chain can be described in terms of Binomial Random Walk.  A successful event is an increase in the fair chain by one block with an approach to the goal by +1, an unsuccessful event is an increase by one block in the attacker's chain with a decrease in the gap by -1. <br><br>  The possibilities of an attacker in a race in the face of constraints are similar to the description of the Gambler's Ruin problem.  Suppose a gambler with an unlimited credit starts the game under conditions of restriction and can potentially hold an unlimited number of games to try to achieve break-even.  We can calculate the likelihood of them achieving a break-even, or that the attacker will overtake honest chain builders. <br><br>  p = probability that an honest host will find the next block <br>  q = probability that the attacker will find the next block <br>  q <sub>z</sub> = probability that the attacker will win the race if he is lagging behind by z blocks <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d14/590/d5b/d14590d5beac4af037a21c037b076ac3.jpg"><br><br>  Suppose that p&gt; q then the probability decreases exponentially with an increase in the number of blocks that the attacker is behind.  Thus, if he fails to get ahead at the very beginning, then his chances of winning in the future will become vanishingly small. <br><br>  Consider now how long the payee must wait to be sure that the sender will not be able to change the transaction.  Suppose that the sender is an attacker who wants the recipient to believe that the payment has been made, but after a while to return the payment to himself.  The recipient will be notified when this happens, but the sender hopes that it will be too late. <br><br>  The recipient generates a new key pair and gives the public key to the sender shortly after its signature.  This does not allow the sender to prepare a block chain in advance working on it ahead of time to complete the transaction at the moment.  Only when a transaction is sent, can a dishonest sender begin to work in secret on a parallel chain containing an alternative version of this transaction. <br><br>  The recipient waits for the transaction to be added to the block and Z blocks will be added after that.  He does not know at what stage of construction the attacker is, but assuming that honest blocks were built with the same average time per block, the expected value of the attacker's progress can be found through the Poisson distribution: <br><img src="https://habrastorage.org/getpro/habr/post_images/4cc/15e/bd1/4cc15ebd1385e162246e6d8fca6c020c.jpg"><br><br>  To obtain the probability with which the attacker can still come forward, multiply the Poisson distribution of each value of the attacker's progress by the probability that he will come forward from this point: <br><img src="https://habrastorage.org/getpro/habr/post_images/b56/f05/d17/b56f05d17bb89afbc216f91fe0f1239f.jpg"><br><br>  Or after regrouping: <br><img src="https://habrastorage.org/getpro/habr/post_images/c53/ab5/ccb/c53ab5ccb4eaa40d959fa00ff5721d39.jpg"><br><br>  Convert with C code: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;math.h&gt; double AttackerSuccessProbability(double q, int z) { double p = 1.0 - q; double lambda = z * (q / p); double sum = 1.0; int i, k; for (k = 0; k &lt;= z; k++) { double poisson = exp(-lambda); for (i = 1; i &lt;= k; i++) poisson *= lambda / i; sum -= poisson * (1 - pow(q / p, z - k)); } return sum; }</span></span></span></span></code> </pre> <br><br>  By running this program, it is easy to verify that the probability decreases exponentially with increasing z: <br>  q = 0.1 <br>  z = 0 P = 1.0000000 <br>  z = 1 P = 0.2045873 <br>  z = 2 P = 0.0509779 <br>  z = 3 P = 0.0131722 <br>  z = 4 P = 0.0034552 <br>  z = 5 P = 0.0009137 <br>  z = 6 P = 0.0002428 <br>  z = 7 P = 0.0000647 <br>  z = 8 P = 0.0000173 <br>  z = 9 P = 0.0000046 <br>  z = 10 P = 0.0000012 <br>  q = 0.3 <br>  z = 0 P = 1.0000000 <br>  z = 5 P = 0.1773523 <br>  z = 10 P = 0.0416605 <br>  z = 15 P = 0.0101008 <br>  z = 20 P = 0.0024804 <br>  z = 25 P = 0.0006132 <br>  z = 30 P = 0.0001522 <br>  z = 35 P = 0.0000379 <br>  z = 40 P = 0.0000095 <br>  z = 45 P = 0.0000024 <br>  z = 50 P = 0.0000006 <br><br>  Solutions for P &lt;0.001 <br><br>  P &lt;0.001 <br>  q = 0.10 z = 5 <br>  q = 0.15 z = 8 <br>  q = 0.20 z = 11 <br>  q = 0.25 z = 15 <br>  q = 0.30 z = 24 <br>  q = 0.35 z = 41 <br>  q = 0.40 z = 89 <br>  q = 0.45 z = 340 <br><br><h4>  12. Conclusion </h4><br>  We have proposed a system of electronic payments without trusted intermediaries.  It is based on the principle of using coins consisting of digital signatures, which provide reliable control on their own, but cannot prevent the problem of dual use.  The solution is to use a decentralized network that uses complex calculations to record a public transaction history, which quickly becomes inaccessible for modification by attacking if fair nodes control a large proportion of computational power.  Reliability of the network in its unstructured and simple.  Each node works independently with minimal coordination.  Nodes do not need to identify themselves, since messages go not along a specific route, but along the fastest path.  Nodes can leave the network and rejoin, accepting the chain created in the intervening past to check for new transactions.  Nodes vote with their computational time, expressing their agreement with the correctness of blocks by attaching them to their chain for further work or ignoring incorrect blocks.  With such a mechanism of agreement, you can implement any necessary rules and incentives. </div><p>Source: <a href="https://habr.com/ru/post/215557/">https://habr.com/ru/post/215557/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../215543/index.html">More than 162.000 WordPress sites were used for large-scale DDOS attacks.</a></li>
<li><a href="../215545/index.html">How "1C" loves its customers</a></li>
<li><a href="../215547/index.html">Cancellation of links in the ranking of commercial requests</a></li>
<li><a href="../215549/index.html">Robot Lucky at the contest "Miss Russia 2014"</a></li>
<li><a href="../215555/index.html">How we did the homework robot</a></li>
<li><a href="../215559/index.html">Valve has unveiled the source for the Direct3D translator in OpenGL</a></li>
<li><a href="../215567/index.html">When the star goes out: an interview with Jim Weirich</a></li>
<li><a href="../215569/index.html">Secure Active Directory management. Part 1</a></li>
<li><a href="../215573/index.html">We lift the domain controller on Ubuntu Server</a></li>
<li><a href="../215575/index.html">Sir Tim Berners-Lee: The World Wide Web is 25 years old. Keep it free and open.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>