<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Manual: writing an interpreter with JIT to PyPy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All source codes and examples from this article are available here . 

 When I first watched the PyPy project, it took me a while to figure out what i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Manual: writing an interpreter with JIT to PyPy</h1><div class="post__text post__text-html js-mediator-article">  <i>All source codes and examples from this article are available <a href="https://bitbucket.org/brownan/pypy-tutorial/">here</a> .</i> <br><br>  When I first watched the PyPy project, it took me a while to figure out what it was.  It consists of two things: <br><br>  - a set of tools for writing interpreters of programming languages; <br>  - implementation of Python using this toolkit. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Probably most people think that PyPy is only the second part, but this guide is not about the Python interpreter.  It is about how to write an interpreter of your language. <br><br>  I took this tutorial in order to better understand how PyPy works and what it is like.  It is assumed that you know very little about PyPy, so I will start from the beginning. <br><br><a name="habracut"></a><h4>  What is PyPy </h4><br>  Suppose we want to write an interpreter.  This includes writing a source code parser, a bytecode loop, and a lot of standard library code. <br><br>  Writing a parser and compiler is usually not fun at all, so there are tools that generate a parser and compiler for you. <br><br>  And even then you have to take care of the memory management in the interpreter and you will have to implement data types such as integers of arbitrary dimension, hash tables and so on.  This is enough for many people to decide not to implement their interpreter. <br><br>  Wouldn't it be great if you could implement your language in a high-level language, for example, Python?  You would get all the benefits of a high-level language, such as automatic memory management and a rich set of data types.  But the interpretation of a language in another interpreted language must be very slow, right? <br><br>  As you can guess, PyPy solves this problem.  PyPy is a sophisticated toolkit for analyzing and translating your interpreter code into C (or JVM or CLI).  This process is called ‚Äútranslation.‚Äù  He knows how to translate not the entire syntax of Python, but quite a large part of it.  All you have to do is write your interpreter in <b>RPython</b> , a subset of Python, after which you will get a very efficient interpreter. <br><br>  Because writing effective interpreters should not be a problem. <br><br><h4>  Tongue </h4><br>  The language I chose to implement is terribly simple.  The runtime of a language consists of a tape of integers initialized to zero, and one pointer to the current cell in this tape.  The language has only 8 commands: <br><br>  <b>&lt;</b> - move the pointer to the previous cell. <br><br>  <b>&gt;</b> - move the pointer to the next cell. <br><br>  <b>+</b> - increase by one number in the current cell. <br><br>  <b>-</b> - decrease by one number in the current cell. <br><br>  <b>[</b> - if the number in the current cell is 0, then skip all instructions to the corresponding instruction]. <br><br>  <b>]</b> - go back to the corresponding instruction [. <br><br>  <b>.</b>  - output to the standard output stream one byte from the current cell. <br><br>  <b>,</b> - read one byte from the standard input stream and put in the current cell. <br><br>  Any unrecognized characters should be ignored. <br><br>  Some could learn this language, this is a brainfuck. <br><br>  The language itself is already a bytecode, so it does not require a separate translation of the source code into bytecode.  This means that the main execution loop of our interpreter will work directly with the source code.  This simplifies its implementation a little. <br><br><h4>  The first steps </h4><br>  Let's start by writing an interpreter on a regular Python.  Here is a sketch of the main run cycle. <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainloop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(program)</span></span></span><span class="hljs-function">:</span></span> tape = Tape() pc = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> pc &lt; len(program): code = program[pc] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> code == <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>: tape.advance() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> code == <span class="hljs-string"><span class="hljs-string">"&lt;"</span></span>: tape.devance() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> code == <span class="hljs-string"><span class="hljs-string">"+"</span></span>: tape.inc() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> code == <span class="hljs-string"><span class="hljs-string">"-"</span></span>: tape.dec() <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> code == <span class="hljs-string"><span class="hljs-string">"."</span></span>: sys.stdout.write(chr(tape.get())) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> code == <span class="hljs-string"><span class="hljs-string">","</span></span>: tape.set(ord(sys.stdin.read(<span class="hljs-number"><span class="hljs-number">1</span></span>))) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> code == <span class="hljs-string"><span class="hljs-string">"["</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> value() == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Skip forward to the matching ] elif code == "]" and value() != 0: # Skip back to the matching [ pc += 1</span></span></code> </pre> <br><br>  As you can see, the command counter (pc) stores a pointer to the current instruction.  The first expression in the loop retrieves the instruction, then several conditional statements determine how to execute it. <br><br>  The implementation of the operators ‚Äú[‚Äù and ‚Äú]‚Äù is omitted; they must change the command counter to the position of the matching bracket. <br><br>  And now the implementation of the class Tape, which stores a tape of integers and a pointer to the current number. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tape</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.thetape = [<span class="hljs-number"><span class="hljs-number">0</span></span>] self.position = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.thetape[self.position] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, val)</span></span></span><span class="hljs-function">:</span></span> self.thetape[self.position] = val <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.thetape[self.position] += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.thetape[self.position] -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">advance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.position += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(self.thetape) &lt;= self.position: self.thetape.append(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">devance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.position -= <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><br>  As you can see, the tape increases if necessary.  In fact, it would be worthwhile to add error checking when the pointer becomes negative.  But so far it does not matter. <br><br>  If the program has many comments, they will be read by one byte, so it is better to parse the source code in advance.  At the same time we will make a dictionary for brackets, so that you can find paired brackets in it. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(program)</span></span></span><span class="hljs-function">:</span></span> parsed = [] bracket_map = {} leftstack = [] pc = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> char <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> program: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> char <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'['</span></span>, <span class="hljs-string"><span class="hljs-string">']'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span>, <span class="hljs-string"><span class="hljs-string">'.'</span></span>): parsed.append(char) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> char == <span class="hljs-string"><span class="hljs-string">'['</span></span>: leftstack.append(pc) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> char == <span class="hljs-string"><span class="hljs-string">']'</span></span>: left = leftstack.pop() right = pc bracket_map[left] = right bracket_map[right] = left pc += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.join(parsed), bracket_map</code> </pre> <br><br>  This function returns a string only from language commands and a dictionary of paired brackets. <br><br>  It remains to connect this, and we get a working brainfuck interpreter. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input)</span></span></span><span class="hljs-function">:</span></span> program, map = parse(input.read()) mainloop(program, map) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys run(open(sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'r'</span></span>))</code> </pre> <br><br>  The full interpreter code, including the implementation of square brackets, can be viewed in the first example.  <a href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example1.py">example1.py</a> <br><br>  Now you can try running the interpreter on Python to make sure that it works. <br><br>  $ python example1.py 99bottles.b <br><br><h4>  PyPy Broadcast </h4><br>  But our goal was not only to write a brainfuck interpreter.  What do you need to do so that PyPy creates a super-fast executable file from this code? <br><br>  In the PyPy source, the pypy / translator / goal folder contains simple examples that will come in handy.  First, let's take a look at targetnopstandalone.py - a simple hello world for PyPy. <br><br>  It is important that the module contains the target function, which returns the entry point.  Broadcast starts from this point. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fp)</span></span></span><span class="hljs-function">:</span></span> program_contents = <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: read = os.read(fp, <span class="hljs-number"><span class="hljs-number">4096</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(read) == <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> program_contents += read os.close(fp) program, bm = parse(program_contents) mainloop(program, bm) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">entry_point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: filename = argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> IndexError: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"You must supply a filename"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> run(os.open(filename, os.O_RDONLY, <span class="hljs-number"><span class="hljs-number">0777</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entry_point, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: entry_point(sys.argv)</code> </pre> <br><br>  The entry_point function will take command line arguments when you run the resulting executable file. <br><br><h4>  RPython </h4><br>  Let's talk about RPython.  PyPy cannot translate regular Python code, because Python is slightly too dynamic.  There are some restrictions that apply to the standard library and Python syntax so that PyPy can translate it.  I will not list them all, it is better to <a href="http://readthedocs.org/docs/pypy/en/latest/coding-guide.html">see them in the documentation</a> . <br><br>  In the above example, several things had to be changed.  Now you have to use low-level descriptors with the os.open and os.read functions instead of using file objects.  The implementation of "." And "," is also slightly modified.  These are all the changes necessary for PyPy to digest the code. <br><br>  It wasn't too hard, was it?  I continue to use dictionaries, expandable lists, and even classes with objects.  And if the file descriptors are too low-level for you, there are several useful abstractions in the rlib.streamio module that comes with the standard RPython library. <br><br>  The full code now looks like this: <a href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example2.py">example2.py</a> <br><br><h4>  Broadcast </h4><br>  If you have not done so already, merge the latest version of PyPy from the repository to bitbucket.org. <br><br>  $ hg clone <a href="https://bitbucket.org/pypy/pypy">bitbucket.org/pypy/pypy</a> <br><br>  The script to run is pypy / translator / goal / translate.py.  As a parameter, it takes a module that needs to be translated. <br><br>  $ python ./pypy/pypy/translator/goal/translate.py example2.py <br><br>  For faster translation, you can use PyPy instead of Python. <br><br>  The result of the execution will be an executable file - the brainfuck interpreter.  The repository is a generator of fractals on the brainfuck, which takes about 45 seconds to complete on my machine.  Try it yourself. <br><br>  $ ./example2-c mandel.b <br><br>  And compare the speed with that which gives the same interpreter running on Python. <br><br>  $ python example2.py mandel.b <br><br>  So, we wrote an interpreter in RPython and translated it using the PyPy toolkit. <br><br><h4>  Add JIT </h4><br>  RPython translation in C is certainly cool, but one of the main features of PyPy is the ability to generate a runtime compiler (JIT).  Using just a few tips on how your interpreter works, PyPy will generate a JIT compiler that will translate the interpreted brainfuck code into machine code. <br><br>  For this to happen, PyPy needs to know where the program execution cycle begins.  This allows you to track which instructions are executed on the brainfuck. <br><br>  We must also indicate the features of the run cycle.  Since there is no stack in our language, we only need to specify which variables relate to the program code, and which to its data.  This is called green and red variables appropriately. <br><br>  Let's return to the second example. <br><br>  Our main run loop uses four variables: pc, program, bracket_map and tape.  Of course, pc, program and bracket_map are green variables, they determine the execution of the interpreted program.  The variable tape is red, it changes when the interpreted program is executed. <br><br>  Let's tell PyPy this data.  Begin by importing the JitDriver class and creating its instance. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pypy.rlib.jit <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> JitDriver jitdriver = JitDriver(greens=[<span class="hljs-string"><span class="hljs-string">'pc'</span></span>, <span class="hljs-string"><span class="hljs-string">'program'</span></span>, <span class="hljs-string"><span class="hljs-string">'bracket_map'</span></span>], reds=[<span class="hljs-string"><span class="hljs-string">'tape'</span></span>])</code> </pre> <br><br>  And add this line to the very beginning of the execution loop: <br><br><pre> <code class="python hljs">fjitdriver.jit_merge_point(pc=pc, tape=tape, program=program, bracket_map=bracket_map)</code> </pre> <br><br>  We also need to define JitPolicy. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">jitpolicy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(driver)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pypy.jit.codewriter.policy <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> JitPolicy <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JitPolicy()</code> </pre> <br><br>  The full text of the example: <a href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example3.py">example3.py</a> <br><br>  Now let's translate the code again, but with the flag --opt = jit: <br><br>  $ python ./pypy/pypy/translator/goal/translate.py --opt = jit example3.py <br><br>  The translation will go much longer, almost 8 minutes on my machine, and the resulting executable file will be much longer.  After the end of the broadcast run the program to generate fractals again.  The difference is huge - about 12 seconds versus 45 in the previous version! <br><br>  As you can see, the JIT compiler really used machine code instead of interpretation.  The first few lines of the picture are displayed quickly enough, then the program is accelerated and the rest is displayed even faster. <br><br><h4>  Few tracing JIT compilers </h4><br>  It is worth talking about how tracing JIT compilers work at all.  Your interpretive code runs as usual.  When the JIT encounters a frequently executed loop in an interpreted language (brainfuck), the loop is marked for tracing.  The next time the same cycle is reached, logging of each executed instruction is enabled. <br><br>  The resulting log is sent to the optimizer, the result of which is converted into machine code.  This code is used for subsequent loop executions. <br><br>  The resulting machine code is correct only under certain conditions under which it was received.  Therefore, before using it, these conditions are checked.  If the check fails, the interpreter is restarted instead of the machine code. <br><br>  More information can be found on <a href="http://en.wikipedia.org/wiki/Just-in-time_compilation">Wikipedia</a> . <br><br><h4>  Debugging and trace logs </h4><br>  Can we see what JIT does? <br><br>  Let's add the function get_printable_location, which will be used to display debug information. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_location</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pc, program, bracket_map)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"%s_%s_%s"</span></span> % ( program[:pc], program[pc], program[pc+<span class="hljs-number"><span class="hljs-number">1</span></span>:] ) jitdriver = JitDriver(greens=[<span class="hljs-string"><span class="hljs-string">'pc'</span></span>, <span class="hljs-string"><span class="hljs-string">'program'</span></span>, <span class="hljs-string"><span class="hljs-string">'bracket_map'</span></span>], reds=[<span class="hljs-string"><span class="hljs-string">'tape'</span></span>], get_printable_location=get_location)</code> </pre> <br><br>  This function accepts green variables and returns a due date.  We output the brainfuck code in which the current instruction being executed is surrounded by underscores. <br><br>  Translate example code <a href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example4.py">example4.py</a> . <br><br>  Now run the test program (test.b just prints the letter ‚ÄúA‚Äù about 15 times) with the output of trace logs. <br><br>  $ PYPYLOG = jit-log-opt: logfile ./example4-c test.b <br><br>  The logfile file contains logs of all produced traces and allows you to look at what instructions were compiled into machine code.  The file is useful in that it allows you to see unnecessary instructions or ways to optimize. <br><br>  Each trace starts with a line like this: <br> <code>[3c091099e7a4a7] {jit-log-opt-loop</code> <br> <br>  And ends with this line: <br> <code>[3c091099eae17d jit-log-opt-loop}</code> <br> <br>  Immediately after the trace header is a comment with a sequence number and the number of operations.  In my case, the first trace looks like this. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span>: [<span class="hljs-number"><span class="hljs-number">3</span></span>c167c92b9118f] {jit-log-opt-loop <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Loop 0 : loop with 26 ops 3: [p0, p1, i2, i3] 4: debug_merge_point('+&lt;[&gt;[_&gt;_+&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 5: debug_merge_point('+&lt;[&gt;[&gt;_+_&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 6: i4 = getarrayitem_gc(p1, i2, descr=&lt;SignedArrayDescr&gt;) 7: i6 = int_add(i4, 1) 8: setarrayitem_gc(p1, i2, i6, descr=&lt;SignedArrayDescr&gt;) 9: debug_merge_point('+&lt;[&gt;[&gt;+_&lt;_-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 10: debug_merge_point('+&lt;[&gt;[&gt;+&lt;_-_]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 11: i7 = getarrayitem_gc(p1, i3, descr=&lt;SignedArrayDescr&gt;) 12: i9 = int_sub(i7, 1) 13: setarrayitem_gc(p1, i3, i9, descr=&lt;SignedArrayDescr&gt;) 14: debug_merge_point('+&lt;[&gt;[&gt;+&lt;-_]_&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 15: i10 = int_is_true(i9) 16: guard_true(i10, descr=&lt;Guard2&gt;) [p0] 17: i14 = call(ConstClass(ll_dict_lookup__dicttablePtr_Signed_Signed), ConstPtr(ptr12), 90, 90, descr=&lt;SignedCallDescr&gt;) 18: guard_no_exception(, descr=&lt;Guard3&gt;) [i14, p0] 19: i16 = int_and(i14, -9223372036854775808) 20: i17 = int_is_true(i16) 21: guard_false(i17, descr=&lt;Guard4&gt;) [i14, p0] 22: i19 = call(ConstClass(ll_get_value__dicttablePtr_Signed), ConstPtr(ptr12), i14, descr=&lt;SignedCallDescr&gt;) 23: guard_no_exception(, descr=&lt;Guard5&gt;) [i19, p0] 24: i21 = int_add(i19, 1) 25: i23 = int_lt(i21, 114) 26: guard_true(i23, descr=&lt;Guard6&gt;) [i21, p0] 27: guard_value(i21, 86, descr=&lt;Guard7&gt;) [i21, p0] 28: debug_merge_point('+&lt;[&gt;[_&gt;_+&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 29: jump(p0, p1, i2, i3, descr=&lt;Loop0&gt;) 30: [3c167c92bc6a15] jit-log-opt-loop}</span></span></code> </pre> <br><br>  I trimmed the debug_merge_point lines too long. <br><br>  This code segment takes four parameters: two pointers to objects (p0 and p1) and two numbers (i2 and i3). <br><br>  The first operator ‚Äú&gt;‚Äù begins on the 4th line.  It runs without instructions and looks finally optimized.  This loop always works with one part of the tape, and the pointer to the current cell remains constant. <br><br>  Fifth to eighth lines - operator ‚Äú+‚Äù.  First, the element of the array with index i2 is extracted from the pointer p1 (line 6), one is added and stored in i6 (line 7).  The result is placed back into the array (line 8). <br><br>  Line 9 corresponds to the instruction "&lt;", but it also does not require operations.  Apparently - i2 and i3 - these are two pointers to the tape cells, which are calculated in advance.  You can also see that p1 is a ribbon of commands.  It is not yet clear what p0 is. <br><br>  Lines 10 through 13 perform the ‚Äú-‚Äù operator: extract the element of the array, subtract and put it back. <br><br>  In the 14th line we come to the operator "]".  Lines 15 and 16 check if i9 is true (i.e. is non-zero).  i9 is the value that we just reduced by one and put it on tape.  Line 16 - check.  If the condition is not met, the function with the name &lt;Guard2&gt; is executed, to which one parameter is passed, p0. <br><br>  If the check is passed, lines 17 to 23 take out from the dictionary of the bracket_map the address of the instruction to which you want to go.  I'm not sure what exactly these lines do, but it is clear that they contain two external calls and 3 checks.  This is too wasteful, given that the bracket_map does not change and the result will be the same address to which to go.  But PyPy doesn't know about this, but we know, so we can optimize this place. <br><br>  Line 24 increments the pointer received from bracket_map.  Lines 25 and 26 verify that it did not exceed the length of the program. <br><br>  In addition, line 27 carries out an additional check that the pointer is strictly equal to 86. This is necessary in order to make sure that the jump must be made at the beginning of the cycle. <br><br>  At the end, the cycle closes on line 28, and on line 29 there is a jump to the beginning of the cycle with parameters p0, p1, i2, i3. <br><br><h4>  Optimization </h4><br>  As noted, at each iteration of the loop, a search is performed in the dictionary to find a matching pair.  This is terribly inefficient because the goal of the transition does not change at different iterations. <br><br>  We need to give another hint to the translator to say that a query to the dictionary will always return the same elements for the same dictionary indices. <br><br>  To do this, we will render the call to the dictionary into a separate function and wrap it with pypy.rlib.jit.purefunction. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@purefunction def get_matching_bracket(bracket_map, pc): return bracket_map[pc]</span></span></code> </pre> <br><br>  This version can be found in <a href="https://bitbucket.org/brownan/pypy-tutorial/src/tip/example5.py">example5.py</a> . <br><br>  Broadcast this example.  Mandelbrot now runs in 6 seconds instead of 12! <br><br>  Let's take a look at the new trace log. <br><br><pre> <code class="python hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span>: [<span class="hljs-number"><span class="hljs-number">3</span></span>c29fad7b792b0] {jit-log-opt-loop <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Loop 0 : loop with 15 ops 3: [p0, p1, i2, i3] 4: debug_merge_point('+&lt;[&gt;[_&gt;_+&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 5: debug_merge_point('+&lt;[&gt;[&gt;_+_&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 6: i4 = getarrayitem_gc(p1, i2, descr=&lt;SignedArrayDescr&gt;) 7: i6 = int_add(i4, 1) 8: setarrayitem_gc(p1, i2, i6, descr=&lt;SignedArrayDescr&gt;) 9: debug_merge_point('+&lt;[&gt;[&gt;+_&lt;_-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 10: debug_merge_point('+&lt;[&gt;[&gt;+&lt;_-_]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 11: i7 = getarrayitem_gc(p1, i3, descr=&lt;SignedArrayDescr&gt;) 12: i9 = int_sub(i7, 1) 13: setarrayitem_gc(p1, i3, i9, descr=&lt;SignedArrayDescr&gt;) 14: debug_merge_point('+&lt;[&gt;[&gt;+&lt;-_]_&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 15: i10 = int_is_true(i9) 16: guard_true(i10, descr=&lt;Guard2&gt;) [p0] 17: debug_merge_point('+&lt;[&gt;[_&gt;_+&lt;-]&gt;.[&lt;+&gt;-]&lt;&lt;-]++++++++++.', 0) 18: jump(p0, p1, i2, i3, descr=&lt;Loop0&gt;) 19: [3c29fad7ba32ec] jit-log-opt-loop}</span></span></code> </pre> <br><br>  Much better!  Now, each cycle is just one addition, subtraction, two loads from the array, two rooms into the array, and a check on exit.  The code does not require any changes to the command counter. <br><br>  This optimization was suggested to me by Armin Rigo in the pypy-dev mailing list.  Karl Friedrich has <a href="https://bitly.com/bundles/cfbolz/1">several articles</a> on interpreter optimization that have also proven useful. <br><br><h4>  Conclusion </h4><br>  I hope this article has convinced you that PyPy is not only a fast Python interpreter. <br><br>  For those of you who want to learn more about the PyPy JIT compiler, I recommend reading the <a href="http://codespeak.net/pypy/extradoc/talk/icooolps2009/bolz-tracing-jit.pdf">Tracing the Meta-Level</a> article <a href="http://codespeak.net/pypy/extradoc/talk/icooolps2009/bolz-tracing-jit.pdf">: PyPy's Tracing JIT Compiler</a> . </div><p>Source: <a href="https://habr.com/ru/post/124418/">https://habr.com/ru/post/124418/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124412/index.html">Lead Firebug Developer Moved to Google Chrome Team</a></li>
<li><a href="../124413/index.html">Abrakadabra - movie catalog ex.ua</a></li>
<li><a href="../124414/index.html">FreeNAS Legacy (0.7) is dead. Long live NAS4Free!</a></li>
<li><a href="../124415/index.html">Student plagiarism in essays is ineradicable, so we must abandon essays</a></li>
<li><a href="../124416/index.html">Infographics "Chinese: The New Dominant Language of the Internet"</a></li>
<li><a href="../124419/index.html">Determine the number of shutter actuations on the Canon 400D or how much the camera took</a></li>
<li><a href="../124420/index.html">Month with a generator of beautiful QR codes</a></li>
<li><a href="../124422/index.html">LulzSec hacked The Sun publishing server</a></li>
<li><a href="../124424/index.html">Microsoft Surface Table has a competitor</a></li>
<li><a href="../124428/index.html">How do programmers train in Karelia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>