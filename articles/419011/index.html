<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Jinja2 in the world of C ++, part two. Rendering</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the second part of the story about porting the Jinja2 template engine to C ++. The first can be read here: templates of the third order, or as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Jinja2 in the world of C ++, part two. Rendering</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/c81/fe0/548/c81fe0548837b911b9569cdf49d90ca2.jpg" alt="Jinja2 logo" align="left">  This is the second part of the story about porting the Jinja2 template engine to C ++.  The first can be read here: <a href="https://habr.com/post/416581/">templates of the third order, or as I ported Jinja2 to C ++</a> .  It focuses on the template rendering process.  Or, in other words, about writing the interpreter of a python-like language from scratch. </p><a name="habracut"></a><br><h2 id="rendering-kak-takovoy">  Rendering as such </h2><br><p>  After parsing, the template turns into a tree containing nodes of three types: <strong>simple text</strong> , <strong>calculated expressions,</strong> and <strong>control structures</strong> .  Accordingly, in the rendering process, plain text should be placed in the output stream without any changes, expressions should be calculated, converted into text, which will be placed in the stream, and control structures must be executed.  At first glance, there was nothing difficult in realizing the rendering process: you just need to go around all the nodes of the tree, calculate everything, execute everything, and generate text.  It's simple.  Exactly as long as two conditions are met: a) all work is done with strings of only one type (string or wstring);  b) only very simple and basic expressions are used.  Actually, it is with such limitations that inja and Jinja2CppLight are implemented.  In the case of my <a href="https://github.com/flexferrum/Jinja2Cpp">Jinja2Cpp,</a> both conditions do not work.  First, I initially laid out transparent support for both types of strings.  Secondly, all development was started just for the sake of supporting the Jinja2 specification almost in full, and this is, in essence, a full-fledged scripting language.  Therefore, I had to dig deeper with rendering than with parsing. </p><br><h3 id="vychislenie-vyrazheniy">  Expression evaluation </h3><br><p><img src="https://habrastorage.org/webt/46/i0/0y/46i00yfhkcaiybpae4famsictho.png" align="right">  A template would not be a template if it could not be parameterized.  In principle, Jinja2 allows the option of ‚Äúin itself‚Äù templates - all the necessary variables can be set inside the template itself, and then rendered.  But the work in the template with the parameters obtained "outside" remains the main case.  Thus, the result of the calculation of the expression depends on which variables (parameters) with which values ‚Äã‚Äãare visible at the point of calculation.  And the snag is that in Jinja2 there are not just scopes (which can be nested), but also with complicated "transparency" rules.  For example, here is a template: </p><br><pre><code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">set</span></span></span><span class="hljs-template-tag"> param1=10 %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  As a result of its rendering, the text will be received <code>10</code> <br>  The option is a bit more complicated: </p><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">set</span></span></span><span class="hljs-template-tag"> param1=10 %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">for</span></span></span></span></span><span class="hljs-template-tag"> param1 </span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag"> range(10) %}</span></span><span class="xml"><span class="xml">-</span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"><span class="xml">-</span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">endfor</span></span></span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ param1 }}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  Rendered already in <code>10-0--1--2--3--4--5--6--7--8--9-10</code> <br>  The cycle generates a new scop in which you can define your own variable parameters, and these parameters will not be visible outside the scope, just as they will not overwrite the values ‚Äã‚Äãof the same parameters in the external one.  More cunning with extends / block constructions, but this is better read in the Jinja2 documentation. </p><br><p>  Thus, the computing context appears.  Or rather, rendering in general: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RenderContext</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: RenderContext(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValueMap&amp; extValues, IRendererCallback* rendererCallback); <span class="hljs-function"><span class="hljs-function">InternalValueMap&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExitScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; found)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = m_scopes.rbegin(); p != m_scopes.rend(); ++ p) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> valP = p-&gt;find(val); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valP != p-&gt;end()) { found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valP; } } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> valP = m_externalScope-&gt;find(val); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (valP != m_externalScope-&gt;end()) { found = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> valP; } found = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_externalScope-&gt;end(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGlobalScope</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRendererCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">RenderContext </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> includeCurrentContext)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: InternalValueMap* m_currentScope; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValueMap* m_externalScope; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;InternalValueMap&gt; m_scopes; IRendererCallback* m_rendererCallback; };</code> </pre> <br><p>  <a href="">From here</a> . </p><br><p>  The context contains a pointer to a collection of values ‚Äã‚Äãobtained when calling a rendering function, a list (stack) of scopes, the current active scopes and a pointer to a callback interface, with various rendering functions useful for rendering.  But about him a little later.  The search function of the parameter is consistently raised through the list of contexts up to the external, until it finds the desired parameter. </p><br><p>  Now a little about the parameters themselves.  From the point of view of the external interface (and its users), Jinja2 supports the following list of valid types: </p><br><ul><li>  Numbers (int, double) </li><li>  Strings (narrow, wide) </li><li>  bool </li><li>  Arrays (more like dimensionless tuples) </li><li>  Dictionaries </li><li>  Reflected C ++ Structures </li></ul><br><p>  All this is described by a special data type created on the basis of boost :: variant: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> ValueData = boost::variant&lt;EmptyValue, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::wstring, <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>, boost::recursive_wrapper&lt;ValuesList&gt;, boost::recursive_wrapper&lt;ValuesMap&gt;, GenericList, GenericMap&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Value() = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; Value(T&amp;&amp; val, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">decay_t</span></span>&lt;T&gt;, Value&gt;::value&gt;::type* = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(val)) { } Value(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* val) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(val)) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> N&gt; Value(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> (&amp;val)[N]) : m_data(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(val)) { } Value(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val) : m_data(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>&gt;(val)) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> ValueData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data;} <span class="hljs-function"><span class="hljs-function">ValueData&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data;} <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ValueData m_data; };</code> </pre> <br><p>  <a href="">From here</a> . </p><br><p>  Of course, the elements of arrays and dictionaries can be of any of the listed types.  But the problem is that for internal use this set of types is too narrow.  To simplify implementation, support for the following additional types was needed: </p><br><ul><li>  String in the target format.  It can be narrow or wide depending on what type of template is being rendered. </li><li>  callable type </li><li>  AST tree node </li><li>  Key-value pair </li></ul><br><p>  Through such an extension, it became possible to transfer service data through the rendering context, which otherwise would have to be ‚Äúshined‚Äù in public headers, as well as more successfully generalizing some algorithms that work with arrays and dictionaries. </p><br><p>  Boost :: variant was not chosen by chance.  Its rich features are used to work with parameters of specific types.  Jinja2CppLight uses polymorphic classes for the same purpose, and inja uses the nlohmann json library type system.  Both of these alternatives, alas, did not suit me.  The reason: the possibility of n-ary dispatch for boost :: variant (and now std :: variant).  For a variant type, you can make a static visitor that takes two specific stored types, and set it on a couple of values.  And everything will work as it should!  In the case of polymorphic classes or simple union'ami such convenience will not work: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringJoiner</span></span></span><span class="hljs-class"> :</span></span> BaseVisitor&lt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BaseVisitor::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> (); <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EmptyValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; str)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; left, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; right)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left + right; } };</code> </pre> <br><p>  <a href="">From here</a> . </p><br><p>  Such a visitor is called very simply: </p><br><pre> <code class="hljs php">InternalValue delimiter = m_args[<span class="hljs-string"><span class="hljs-string">"d"</span></span>]-&gt;Evaluate(context); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> InternalValue&amp; val : values) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFirst) isFirst = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> result = Apply2&lt;visitors::StringJoiner&gt;(result, delimiter); result = Apply2&lt;visitors::StringJoiner&gt;(result, val); }</code> </pre> <br><p>  <code>Apply2</code> here is a wrapper over <code>boost::apply_visitor</code> , which applies a visitor of a given type parameter to a pair of variant values, doing some transformations first, if necessary.  If the designer of the visitor needs parameters - they are passed after the objects to which the visitor is applied: </p><br><pre> <code class="hljs vbscript">comparator = [](<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> KeyValuePair&amp; <span class="hljs-built_in"><span class="hljs-built_in">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> KeyValuePair&amp; <span class="hljs-built_in"><span class="hljs-built_in">right</span></span>) { return ConvertToBool(Apply2&lt;visitors::BinaryMathOperation&gt;(<span class="hljs-built_in"><span class="hljs-built_in">left</span></span>.value, <span class="hljs-built_in"><span class="hljs-built_in">right</span></span>.value, BinaryExpression::LogicalLt, BinaryExpression::CaseSensitive)); };</code> </pre> <br><p><img src="https://habrastorage.org/webt/ql/6e/qd/ql6eqdbjul3yrvjblr0nwjgqet8.png" align="left" width="60%" height="60%">  Thus, the logic of performing operations with parameters is as follows: variant (s) -&gt; unpacking with the help of visitor -&gt; performing the desired action on specific values ‚Äã‚Äãof specific types -&gt; packing the result back into the variant.  And a minimum of hidden magic.  It would be possible to implement everything as in js: perform operations (for example, additions) in any case, choosing a certain system of converting strings to numbers, numbers to strings, strings to lists, etc. And to get strange and unexpected results.  I chose a simpler and more predictable way: if an operation on a value (or a pair of values) is impossible or illogical, then an empty result is returned.  Therefore, if you add a number with a string, you can only get a string as a result if the concatenation operation ('~') is used.  Otherwise, the result will be an empty value.  The priority of operations is determined by the grammar, so no additional checks during the processing of AST are needed. </p><br><h3 id="filtry-i-testy">  Filters and tests </h3><br><p><img src="https://habrastorage.org/webt/iy/zr/pp/iyzrppwjtrqdunkvflnjf1bv5ak.png" align="right" width="50%" height="50%">  What is called the "standard library" in other languages ‚Äã‚Äãin Jinja2 is called "filters".  In essence, a filter is a kind of complex operation on a value to the left of the '|' sign, the result of which will be a new value.  Filters can be chained by organizing pipeline: <br> <code>{{ menuItems | selectattr('visible') | map(attribute='title') | map('upper') | join(' -&gt; ') }}</code> <br>  Here, only those elements from which the visible attribute is set to true will be selected from the menuItems array, then the title attribute will be taken from these elements, converted to upper case, and the resulting list of strings will be glued with a separator '-&gt;' into one line.  Or, say, in the example of "life": </p><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">macro</span></span></span><span class="hljs-template-tag"> MethodsDecl(class, access) %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">for</span></span></span></span></span><span class="hljs-template-tag"> method </span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag"> class.methods | rejectattr('isImplicit') | selectattr('accessType', '</span><span class="hljs-keyword"><span class="hljs-template-tag"><span class="hljs-keyword">in</span></span></span><span class="hljs-template-tag">', access) %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ method.fullPrototype }}</span></span><span class="xml"><span class="xml">; </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">endfor</span></span></span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name">endmacro</span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  <a href="">From here</a> . </p><br><div class="spoiler">  <b class="spoiler_title">Alternative option</b> <div class="spoiler_text"><pre> <code class="hljs mel">{% macro MethodsDecl(class, access) %} {{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> method <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> class.methods | rejectattr(<span class="hljs-string"><span class="hljs-string">'isImplicit'</span></span>) | selectattr(<span class="hljs-string"><span class="hljs-string">'accessType'</span></span>, <span class="hljs-string"><span class="hljs-string">'in'</span></span>, access) | map(attribute=<span class="hljs-string"><span class="hljs-string">'fullPrototype'</span></span>) | join(<span class="hljs-string"><span class="hljs-string">';\n'</span></span>) }}; {% endmacro %}</code> </pre> </div></div><br><p>  This macro enumerates all the methods of a given class, discards those for which the isImplicit attribute is set to true, from the rest it selects those for which the value of the accessType attribute matches one of the ones specified, and displays their prototypes.  Relatively visually.  And it is much simpler than three-story cycles and if'y to fence.  By the way, something similar in C ++ can be done within the <a href="https://ericniebler.github.io/std/wg21/D4128.html">range v.3</a> specification. </p><br><p>  Actually, the main error in time was associated with the implementation of about forty filters, which I included in the basic set.  From something I took that I could handle it in a week or two.  It was too optimistic.  And although the typical implementation of the filter is quite simple: take a value and apply a certain functor to it, they turned out to be too many, and I had to tinker. <br>  A separate interesting task in the implementation process was the logic of argument processing.  In Jinja2, as in python, the arguments passed to the call can be both named and positional.  And the parameters in the declaration of the filter can be both mandatory and optional (with default values).  Moreover, unlike C ++, optional parameters can be anywhere in the declaration.  It was necessary to invent an algorithm for combining these two lists, taking into account different cases.  Here, let's say, is the function range: <code>range([start, ]stop[, step])</code> .  It can be called in the following ways: </p><br><pre> <code class="hljs lisp">range(<span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">1</span></span>) range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">1</span></span>) range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">3</span></span>) range(<span class="hljs-name"><span class="hljs-name">step=2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">2</span></span>) range(<span class="hljs-number"><span class="hljs-number">2</span></span>, step=2, <span class="hljs-number"><span class="hljs-number">10</span></span>) // -&gt; range(<span class="hljs-name"><span class="hljs-name">start</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span>, stop = <span class="hljs-number"><span class="hljs-number">10</span></span>, step = <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br><p>  And so on.  And I would very much like that in the implementation code of the filter function it was not necessary to take into account all these cases.  As a result, I stopped at the fact that in the code of a filter, a tester or a function, the parameters are obtained strictly by name.  And a separate function compares the actual argument list with the expected parameter list while checking that all the required parameters are specified in one way or another: </p><br><div class="spoiler">  <b class="spoiler_title">Big piece of code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">ParsedArguments </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseCallParams</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">initializer_list</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;ArgumentInfo&gt;&amp; args, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CallParams&amp; params, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; isSucceeded)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArgInfo</span></span></span><span class="hljs-class"> {</span></span> ArgState state = NotFound; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nextNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ArgumentInfo* info = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; }; boost::container::small_vector&lt;ArgInfo, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; argsInfo(args.size()); boost::container::small_vector&lt;ParamState, <span class="hljs-number"><span class="hljs-number">8</span></span>&gt; posParamsInfo(params.posParams.size()); isSucceeded = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ParsedArguments result; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> argIdx = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> firstMandatoryIdx = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prevNotFound = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> foundKwArgs = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Find all provided keyword args for (auto&amp; argInfo : args) { argsInfo[argIdx].info = &amp;argInfo; auto p = params.kwParams.find(argInfo.name); if (p != params.kwParams.end()) { result.args[argInfo.name] = p-&gt;second; argsInfo[argIdx].state = Keyword; ++ foundKwArgs; } else { if (argInfo.mandatory) { argsInfo[argIdx].state = NotFoundMandatory; if (firstMandatoryIdx == -1) firstMandatoryIdx = argIdx; } else { argsInfo[argIdx].state = NotFound; } if (prevNotFound != -1) argsInfo[prevNotFound].nextNotFound = argIdx; argsInfo[argIdx].prevNotFound = prevNotFound; prevNotFound = argIdx; } ++ argIdx; } int startPosArg = firstMandatoryIdx == -1 ? 0 : firstMandatoryIdx; int curPosArg = startPosArg; int eatenPosArgs = 0; // Determine the range for positional arguments scanning bool isFirstTime = true; for (; eatenPosArgs &lt; posParamsInfo.size(); ++ eatenPosArgs) { if (isFirstTime) { for (; startPosArg &lt; args.size() &amp;&amp; (argsInfo[startPosArg].state == Keyword || argsInfo[startPosArg].state == Positional); ++ startPosArg) ; isFirstTime = false; continue; } int prevNotFound = argsInfo[startPosArg].prevNotFound; if (prevNotFound != -1) { startPosArg = prevNotFound; } else if (curPosArg == args.size()) { break; } else { int nextPosArg = argsInfo[curPosArg].nextNotFound; if (nextPosArg == -1) break; curPosArg = nextPosArg; } } // Map positional params to the desired arguments int curArg = startPosArg; for (int idx = 0; idx &lt; eatenPosArgs &amp;&amp; curArg != -1; ++ idx, curArg = argsInfo[curArg].nextNotFound) { result.args[argsInfo[curArg].info-&gt;name] = params.posParams[idx]; argsInfo[curArg].state = Positional; } // Fill default arguments (if missing) and check for mandatory for (int idx = 0; idx &lt; argsInfo.size(); ++ idx) { auto&amp; argInfo = argsInfo[idx]; switch (argInfo.state) { case Positional: case Keyword: continue; case NotFound: { if (!IsEmpty(argInfo.info-&gt;defaultVal)) result.args[argInfo.info-&gt;name] = std::make_shared&lt;ConstantExpression&gt;(argInfo.info-&gt;defaultVal); break; } case NotFoundMandatory: isSucceeded = false; break; } } // Fill the extra positional and kw-args for (auto&amp; kw : params.kwParams) { if (result.args.find(kw.first) != result.args.end()) continue; result.extraKwArgs[kw.first] = kw.second; } for (auto idx = eatenPosArgs; idx &lt; params.posParams.size(); ++ idx) result.extraPosArgs.push_back(params.posParams[idx]); return result; }</span></span></code> </pre> <br><p>  <a href="">From here</a> . </p></div></div><br><p>  It is called in this way (for, say, <code>range</code> ): </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isArgsParsed = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> args = helpers::ParseCallParams({{<span class="hljs-string"><span class="hljs-string">"start"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"stop"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"step"</span></span>}}, m_params, isArgsParsed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isArgsParsed) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InternalValue();</code> </pre> <br><p>  and returns the following structure: </p><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ParsedArguments</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, ExpressionEvaluatorPtr&lt;&gt;&gt; args; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, ExpressionEvaluatorPtr&lt;&gt;&gt; extraKwArgs; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; extraPosArgs; ExpressionEvaluatorPtr&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>[](<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> p = args.find(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == args.end()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p-&gt;second; } };</code> </pre> <br><p>  the necessary argument from which is taken simply by its name: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> startExpr = args[<span class="hljs-string"><span class="hljs-string">"start"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> stopExpr = args[<span class="hljs-string"><span class="hljs-string">"stop"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> stepExpr = args[<span class="hljs-string"><span class="hljs-string">"step"</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> startVal = startExpr ? startExpr-&gt;Evaluate(values) : InternalValue(); <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> stopVal = stopExpr ? stopExpr-&gt;Evaluate(values) : InternalValue(); <span class="hljs-attribute"><span class="hljs-attribute">InternalValue</span></span> stepVal = stepExpr ? stepExpr-&gt;Evaluate(values) : InternalValue();</code> </pre> <br><p>  A similar mechanism is used when working with macros and testers.  And although, it seems, there is nothing difficult in describing the arguments of each filter and test, not (as well as implementing it), but even the ‚Äúbasic‚Äù set, which included about fifty of both, turned out to be quite voluminous to implement.  And this is on the condition that it did not include all sorts of tricky things, like formatting strings under HTML (or C ++), outputting values ‚Äã‚Äãin formats like xml or json, and so on. </p><br><p>  The next part focuses on the implementation of working with several templates (export, include, macros), as well as exciting adventures with the implementation of error handling and working with strings of different widths. </p><br><p>  Traditionally, links: </p><br><p>  <a href="http://jinja.pocoo.org/docs/2.10/templates/">Jinja2 Specification</a> <br>  <a href="https://github.com/flexferrum/Jinja2Cpp">Jinja2Cpp implementation</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/419011/">https://habr.com/ru/post/419011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../419001/index.html">5 "super skills" necessary for the work of the future</a></li>
<li><a href="../419003/index.html">Digest news from the sphere of blockchain technologies</a></li>
<li><a href="../419005/index.html">Excursion to the substation 220/110/20</a></li>
<li><a href="../419007/index.html">Textures for 64k intro: how it is done today</a></li>
<li><a href="../419009/index.html">clang and IDE: a story about friendship and foe</a></li>
<li><a href="../419013/index.html">Funnel-based attribution for SaaS B2B businesses - as we considered the value of all marketing efforts</a></li>
<li><a href="../419017/index.html">What's new in ConstraintLayout 1.1</a></li>
<li><a href="../419019/index.html">AlterEgo: a device that can read (some) thoughts</a></li>
<li><a href="../419021/index.html">The main types of printing and their features</a></li>
<li><a href="../419023/index.html">How we scaled Nginx and save the world 54 years of waiting each day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>