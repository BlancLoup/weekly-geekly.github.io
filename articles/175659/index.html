<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Globals MUMPS: Extreme Database Programming. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translator's note. 

 There is an interesting technology in the world of DB - MUMPS . This programming language and data access has been known for sev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Globals MUMPS: Extreme Database Programming. Part 1</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  <b>Translator's note.</b> <br><br>  There is an interesting technology in the world of DB - <a href="http://ru.wikipedia.org/wiki/MUMPS">MUMPS</a> .  This programming language and data access has been known for several decades, debugged and is an adult proven technology. <br><br>  Let me give you an analogy: if SQL can be compared with BASIC, then MUMPS is more similar to C - it gives the highest performance, flexibility and versatility, allowing you to create the most complex data structures. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is the translation of the first part of the article “Extreme Database programming with MUMPS Globals”.  If it seems interesting to the community, then the second part will be translated. </blockquote><br><a name="habracut"></a><br><h4>  Chapter 1. Globals: An Alternative to the Relational Approach </h4><br>  The true heart of MUMPS technology is the data storage mechanism.  It is based on what is called a global variable, or (more popular name) globals (Globals).  Globala is an incredibly simple concept, however, it is also incredibly powerful. <br><br>  Many people do not accept globals.  These are primitive structures.  They do not have controls, support systems or advanced functionality provided by “decent” databases.  As a result, MUMPS is often written off as useless, insufficient, or, in general, the wrong system.  If you do it too, you ignore the simple, convenient and very flexible data storage mechanism.  In skillful hands, the lack of excess baggage and undemanding of resources give an incredible feeling of freedom.  In unskillful hands, all the same can lead to disaster.  This is a bit like an extreme sport, such as free climbing.  Few "real" athletes will recommend it - because it is the fastest, most effective and fascinating way to climb that mountain if you can do climbing without insurance.  However, companies-manufacturers of mountaineering equipment would not recommend this sport for anything, as this means reducing the demand for their own products! <br><br>  So if you accept the call and are ready to admit that there are other ways to organize a data warehouse apart from the scowling relational and SQL approach, let's dig into the depths. <br><br>  This is the first chapter in which the basics of globals are revealed.  The second chapter focuses on using them in terms that the RDBMS / SQL programmer understands.  If you want, you can go directly to the second chapter and return to this text later to familiarize yourself with the basics. <br><br>  All MUMPS systems and their modern modifications, for example, Caché, use globals as the basis of the storage mechanism.  Many modern MUMPS systems and / or extensions offer a more “familiar” look at key global designs.  For example, on globals, you can create views (views) that will work as an object, relational or XML database.  Moreover, in theory, the same physical database based on globals can be logically represented and used in one of these forms (and even in all at once).  As a result, there are many developers who do not know that the tools are based on globals.  They do not know what it is, how it works and how it is used.  This text will help you learn this secret and, we hope that you will agree, a very fascinating world. <br><br>  <b>So what are globals?</b> <br><br>  In short, a global is a constant, sparse, dynamic, multidimensional array containing text values.  MUMPS permits the use of both persistent and multidimensional arrays contained only in RAM, known as “local arrays”. <br><br>  Unlike many systems, MUMPS allows you to use both alphabetic and numeric indices.  So in MUMPS you can work with a similar array: <br><br><pre><code class="bash hljs">Employee(company,country,office,employeeNumber) = employeeDetails</code> </pre> <br>  and a separate entry: <br><br><pre> <code class="bash hljs">Employee(“MGW”,”UK”,”London”,1) = “Rob Tweed`Director`020 8404 3054”</code> </pre><br>  In this example, the data elements that make up information about the employee (name, title, telephone number) are attached to each other in combination with the reverse apostrophe symbol as a separator.  MUMPS does not control or control the way you organize your structures: there is no schema or dictionary of data describing your records.  This provides incredible flexibility and speeds up development.  You can optionally assign one or more data delimiters that will break the text value of the array record into any number of “fields”.  The maximum total length of a single array entry depends on the implementation of MUMPS, however in Caché it is up to 32k.  The length of the string is variable, and, as you understand, based on the presence of a delimiter character, the length of the individual fields is also variable.  This makes MUMPS globals a very efficient data storage mechanism (as opposed to tables): there is practically no space on the MUMPS files that can store empty, unused spaces. <br><br>  In the example above, the employee record is contained in what is called a “local array”.  If you left the MUMPS session, the array would disappear, just like a PHP array after the page or session disappeared. <br><br>  And now let's start the fun!  To keep the employee's record on disk all the time, that is, in the form of a global, simply add "^" in front of the array name: <br><br><pre> <code class="bash hljs">^Employee(company,country,office,employeeNumber) = employeeDetails</code> </pre><br>  example: <br><br><pre> <code class="bash hljs">^Employee(“MGW”,”UK”,”London”,1) = “Rob Tweed`Director`020 8404 3054”   !</code> </pre><br>  To create such an element in the global, you need to use the MUMPS "set" command: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">set</span></span> ^Employee(“MGW”,”UK”,”London”,1) = “Rob Tweed`Director`020 8404 3054”</code> </pre><br>  Most of all people in MUMPS are confused and frightened that the main part of commands can be reduced to one letter (lower case or upper case), so often you can see the following instead of the command written above: <br><br><pre> <code class="bash hljs">s ^Employee(“MGW”,”UK”,”London”,1) = “Rob Tweed`Director`020 8404 3054”</code> </pre><br>  Now, when you exit MUMPS, the recording will not disappear, but will remain on the disk.  Whenever you return, you can read a record from the disk through the global indexed: <br><br><pre> <code class="bash hljs">^Employee(“MGW”,”UK”,”London”,1)</code> </pre><br>  To extract a value from the global and assign it to a variable, usually use the “set” command, for example: <br><br><pre> <code class="bash hljs">Set companyRecord= ^Employee(“MGW”,”UK”,”London”,1)</code> </pre><br>  The variable companyRecord now contains the string value: “Rob Tweed`Director`020 8404 3054” <br><br>  Globals can contain as many indices as you want, and these indices can be any combination of text and numbers (real or integer).  String indices should be surrounded by double quotes, and numeric - not. <br><br>  Most MUMPS implementations actually have a limit on the total length of the index, so you won't be able to go completely beyond the boundaries.  However, you make sure that there is enough space for any of your requirements. <br><br>  To remove an entry from the global, you can use the “kill” command: <br><br><pre> <code class="bash hljs">Kill ^Employee(“MGW”,”UK”,”London”,1)</code> </pre><br>  Actually, this is all about globala.  The real difficulty is to make such a primitive data structure work for you.  We will describe this throughout the rest of the document.  We will try to do this in such a way that the SQL programmer of relational databases can understand the similar techniques and views that the MUMPS programmer would use. <br><br>  Remember that nothing in MUMPS supports any database design methodology.  You can add monitoring and verification tools that will follow the logic, consistency and absence of errors in your database.  This means that you will do the work that the usual DBMS would do for you.  However, you will quickly realize that you can automate most repetitive tasks and easily manage your MUMPS database. <br><br>  <b>Creating a simple layered structure</b> <br><br>  You can use several dimensions in the same global at the same time, for example: <br><br><pre> <code class="bash hljs">^Employee(“MGW”,”UK”,”London”) = 2 ^Employee(“MGW”,”UK”,”London”,1) = “Rob Tweed`Director`020 8404 3054” ^Employee(“MGW”,”UK”,”London”,2) = “Chris Munt`Director`01737 371457”</code> </pre><br>  Using 3 indices, we indicate the number of employees in a particular office, and four indicate the record of a particular employee. <br><br>  Links between different globals should be indicated by the programmer.  MUMPS, out of the box, does not provide automatic indexing and does not cross-reference. <br><br>  In order to make a quick sample by phone number, we will create a global ^ EmployeeTelephone, where the indices will be phone numbers and the index values ​​of the global ^ Employee, pointing to the employee's record: <br><br><pre> <code class="bash hljs">^EmployeeTelephone(“020 8404 3054) = “MGW`UK`London`1” ^EmployeeTelephone(“01737 371457”) = “MGW`UK`London`2”</code> </pre><br>  In this example, the value stored in each telephone number also contains a glue index pointing to the corresponding employee record.  If you know the phone number, then all you need is to separate the data using the reverse apostrophe (separator) and extract the employee's master record. <br><br>  Example: <br><pre> <code class="bash hljs">S telNo=”020 8404 3054” S indexData=^EmployeeTelephone(telNo) S company=<span class="hljs-variable"><span class="hljs-variable">$piece</span></span>(indexData,”`”,1) S country=<span class="hljs-variable"><span class="hljs-variable">$piece</span></span>(indexData,”`”,2) S office=<span class="hljs-variable"><span class="hljs-variable">$piece</span></span>(indexData,”`”,3) S employeeNo=<span class="hljs-variable"><span class="hljs-variable">$piece</span></span>(indexData,”`”,4) S record=^Employee(company,country,office,employeeNo) S employee=<span class="hljs-variable"><span class="hljs-variable">$piece</span></span>(record,”`”,1)</code> </pre><br>  Note the use of the $ piece function of the MUMPS to split values ​​into fields. <br><br>  One of the great features of MUMPS is that you don’t need to declare anything in advance.  In the SQL world, changing the data structure requires changing the structure of the tables (ALTER TABLE, etc.).  In MUMPS, you decide when and how to create, edit and delete entries in the global - all this is automatically and dynamically controlled only by you.  You can add additional indexes and “fields” (pieces) to your globals at any time without any announcements or the like.  If you want to start using another global one, just start it and it will be created dynamically for you. <br><br>  <b>Creating, reading and deleting entries in the global</b> <br><br>  In short, in MUMPS, entries in globals are created and retrieved with the “Set” command, and deleted with the “Kill” command. <br><br><ol><li>  Creating an entry in the global: <br><br><pre> <code class="bash hljs"> Set ^Employee(“MGW”,”UK”,”London”,1)=“Rob Tweed`Director`020 8404 3054”</code> </pre><br>  This code creates an index in the global and saves writing to disk. <br><br></li><li>  Reading a record from the global <br><br><pre> <code class="bash hljs"> Set data=^Employee(“MGW”,”UK”,”London”,1)</code> </pre><br>  This code retrieves the element from the global and places the value in a local variable called “data”. <br><br></li><li>  Deleting a record from the global: <br><br><pre> <code class="bash hljs"> <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> ^Employee(“MGW”,”UK”,”London”,1)</code> </pre><br></li></ol><br><br>  This code deletes the specified global record from disk immediately and permanently.  Be careful with the Kill team — it's incredibly easy and incredibly dangerous to use.  If you specify fewer indexes than there are in the global - you will remove all items indexed by a large number of indexes.  If you do not specify an index at all, you will delete the entire global, for example: <br><br><pre> <code class="bash hljs">Kill ^Employee(“MGW”,”UK”)</code> </pre><br>  This line will delete all records of all offices in England. <br><br><pre> <code class="bash hljs">Kill ^Employee</code> </pre><br>  And this command will delete the entire Global ^ Employee - immediately, forever and irrevocably (if you have not made its backup). <br><br>  <b>Global traversal</b> <br><br>  One of the most commonly used functions is the crawling of several or all globals.  Suppose you need to take all employee records to display a list from which the user can select one record or count them.  To do this, you need to use the MUMPS $ order function.  The $ order function is one of the MUMPS pearls that allows you to manipulate any data stored in globals with incredible simplicity. <br><br>  This functionality will not be intuitive to the programmer of "traditional" databases, but it is worth understanding, since it is both very powerful and simple. <br><br>  The $ order function works at the same level of indexing within the global and returns the value of the next index in the sample that exists at this level of the global.  You can specify an initial value, and the $ order function will find the next value that is in the selected sequence.  To find the first index at the specified level, use an empty initial value (“”).  To find the first index at the specified level, which starts at “C”, use an initial value that goes in order immediately before “C”, for example, “B ~”. <br>  So, to find the first employee in the global: <br><br><pre> <code class="bash hljs">S company=”” S company=<span class="hljs-variable"><span class="hljs-variable">$order</span></span>(^Employee(company))</code> </pre><br>  The variable company now contains the value of the first company index in the first record of the global ^ Employee. <br><br>  When the last value is found, the next time the $ order function is run, it returns an empty value.  So, if there was only one company in our global and we repeated $ order: <br><br><pre> <code class="bash hljs">S company=<span class="hljs-variable"><span class="hljs-variable">$order</span></span>(^Employee(company))</code> </pre><br>  Then the company variable would contain an empty value ("") <br>  To get and process all the companies in the global Employee, you need to create a cycle: <br><br><pre> <code class="bash hljs">S company=”” For s company=<span class="hljs-variable"><span class="hljs-variable">$order</span></span>(^Employee(company)) quit:company=”” <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> . ;  -  company</code> </pre><br>  This code demonstrates the interesting features of the concise MUMPS coding: <br><ul><li>  The For command with two subsequent spaces sets an infinite loop. </li><li>  Quit: company = ”” indicates a loop exit condition and uses a construct known as “post-condition”.  This construct says "if the company value is empty, exit the For loop."  Quit should be followed by two spaces, if any other command follows the command. </li><li>  A “do” at the end of a line means to execute code that goes to the next level of the “point”.  “Do” will be executed on each iteration of the For loop until the value of the company is not empty. </li><li>  The code to be executed in each cycle is written after a single point.  In principle, any line beginning with a point forms a subroutine that is executed by the “do” command at the end of the second line in the example. </li></ul><br><br>  So, we set $ order to null to ensure that the command starts by searching for the first index stored in the global.  We go through each value until the stored data runs out and we get an empty value returned by $ order, after which we end the cycle. <br><br>  You will find that this type of cycle is one of the most common things in the MUMPS program. <br><br>  We can expand this query and process the entire global at once.  To do this, we run a loop at each index level, starting with the first and moving on to each subsequent one: <br><br><pre> <code class="bash hljs">s company=”” <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s company=<span class="hljs-variable"><span class="hljs-variable">$order</span></span>(^Employee(company)) quit:company=”” <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> . s country=”” . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s country=<span class="hljs-variable"><span class="hljs-variable">$order</span></span>(^Employee(company,country)) quit:country=”” <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> . . s office=”” . . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s office=<span class="hljs-variable"><span class="hljs-variable">$order</span></span>(^Employee(company,country,office)) quit:office=”” <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> . . . s employeeNo=”” . . . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s employeeNo=<span class="hljs-variable"><span class="hljs-variable">$order</span></span>(^Employee(company,country,office,employeeNo)) quit:employeeNo=”” <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> . . . . s record=^Employee(company,country,office,employeeNo) . . . . ;  -  </code> </pre><br>  Notice how we designated the “point” levels to create a hierarchy of nested subroutines.  Also, pay attention to how $ order is used to bypass the values ​​of all 4 global indices. <br><br><blockquote>  <b>Note</b>  <b>translator</b> : in Caché braces can be used for nested structures. </blockquote><br><br>  If we needed to find and process only the records of employees of companies starting with “C”, then we use the following popular construct: <br><br><pre> <code class="bash hljs">s company=”B~” fs company=<span class="hljs-variable"><span class="hljs-variable">$o</span></span>(^Employee(company)) quit:<span class="hljs-variable"><span class="hljs-variable">$e</span></span>(company,1) <span class="hljs-string"><span class="hljs-string">'= ”C” do . ;  -  </span></span></code> </pre><br>  Notice the $ extract (or $ e) function.  It retrieves the character from the specified position of the string value: in this case, the first letter of the company name.  Also note the method of specifying "not equal to C": it uses the MUMPS NOT operator, which is written with a single quote ('). <br><br>  This cycle can be read as follows: <br><ul><li>  The initial value of $ order is the value before the “C” in the sequential sample </li><li>  Run an infinite loop to search all the records of companies in the sample. </li><li>  If the first letter of the company name is not “C”, leave the loop </li><li>  Otherwise, continue processing company records. </li></ul><br><br>  This ability to start and stop global crawling from any particular index and at any level of index nesting is a unique function of MUMPS globals. <br><br>  <b>Check the existence of a record in the global</b> <br><br>  You often need to know if a particular entry exists in the global.  For this you can use the MUMPS $ data function: <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-variable"><span class="hljs-variable">$data</span></span>(^Employee(company)) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> xxx</code> </pre><br>  The line reads “if ^ Employee (company) exists, then execute subroutine xxx”.  The $ data function can be abbreviated to $ d. <br><br>  $ data returns several different values. <br><ul><li>  If data exists at the specified index level and there are no subnodes, the value 1 will return. </li><li>  If data exists at the specified index level and there are subnodes, the value 11 will return </li><li>  If data does not exist at the specified index level, but there are sub-nodes, the value 10 will return </li><li>  If the data does not exist at the specified index level, the value 0 is returned. </li></ul><br><br>  In MUMPS, any non-zero value when using the logical if operator is evaluated as true.  Thus, the first three values ​​returned by $ data (1, 10, and 11) will be considered true.  The latter situation (no data and subnodes) is evaluated as false. <br><br>  As an example, consider the following global: <br><br><pre> <code class="bash hljs">^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>=3 ^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“a”)=1 ^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“a”,”b”,”c”)=2 ^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“a”,”b”,”d”)=3 <span class="hljs-variable"><span class="hljs-variable">$data</span></span>(^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>) = 11 <span class="hljs-variable"><span class="hljs-variable">$data</span></span>(^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“a”,”b”)=10 <span class="hljs-variable"><span class="hljs-variable">$data</span></span>(^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“a”,”b”,”c”)=1 <span class="hljs-variable"><span class="hljs-variable">$data</span></span>(^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“b”)=0</code> </pre><br>  <b>Preventing "data undefined" errors</b> <br><br>  If you try to extract a non-existing record from the global, MUMPS will generate a run-time error, for example, &lt;UNDEF&gt;.  To avoid this, you can either use the $ data function to check the existence of a node, or use the more convenient $ get function.  This will return the value of the global node if it exists, or an empty value if not.  The $ get function can be reduced to $ g <br><br>  So, based on the example we used in the previous section with $ data: <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$get</span></span>(^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>) = 3 <span class="hljs-variable"><span class="hljs-variable">$get</span></span>(^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“a”,”b”)=”” ;        <span class="hljs-variable"><span class="hljs-variable">$get</span></span>(^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“a”,”b”,”c”)=1 <span class="hljs-variable"><span class="hljs-variable">$get</span></span>(^<span class="hljs-built_in"><span class="hljs-built_in">test</span></span>(“b”)=”” <span class="hljs-variable"><span class="hljs-variable">$get</span></span>(^nonExistentGlobal)=””</code> </pre><br>  <b>View globals</b> <br><br>  Caché and all other MUMPS systems include ways to view globals.  The easiest way is to use the ^% G command line command, which you will find in Caché and some other MUMPS implementations.  Run the following in the terminal session: <br><br><pre> <code class="bash hljs">USER&gt; D ^%G Global ^ Employee</code> </pre><br>  Introducing the global name will give the command to display the contents of the entire global.  However, you can output separate indexes, for example: <br><br><pre> <code class="bash hljs">Employee()</code> </pre><br>  List all values ​​of the first index only. <br><br><pre> <code class="bash hljs">Employee(“MGW”</code> </pre><br>  List all employee records with the first value of the MGW index <br><br><pre> <code class="bash hljs">Employee(“MGW”,)</code> </pre><br><br>  List all second employee record indexes with the first “MGW” index <br><br>  Caché provides a browser application with a graphical interface called Caché Explorer that allows you to view and edit globals. <br><br>  <b>Summary</b> <br><br>  We looked at the basics of globals, as well as their creation and editing.  The next chapter will look at globals from the point of view of a person familiar with relational databases. <br><br>  Probably, you have already understood that MUMPS globals practically do not control and do not limit your actions.  This is both wonderful (you can quickly and flexibly design, create, and change the structure of your databases) and dangerous (in unskilled hands, the database turns into an uncontrollable mess). <br><br>  MUMPS relies on you programmers.  There is no insurance, but there are no limits to what can be achieved or how you will achieve it.  You will understand MUMPS - a great and exciting working environment, thanks to the effectiveness of programming and command execution. <br>  When you learn MUMPS globals, you will probably be surprised: “Why all the databases cannot work as well!” This is very simple, intuitive, flexible and exceeds any relational database in performance.  In addition, MUMPS is available for almost any platform and scales to the size of huge systems - some of the largest interactive systems in the world are based on MUMPS, sometimes with tens of thousands of concurrent users. <br><br>  However, if you think that you need the tools and insurance that, in the opinion of the relational world, are necessary, MUMPS is definitely not for you.  And if you still intend to do free climbing, go to the next chapter. <br><br>  <a href="https://habr.com/post/176305/">Continued.</a>  <a href="https://habr.com/post/176305/">Part 2.</a> </div><p>Source: <a href="https://habr.com/ru/post/175659/">https://habr.com/ru/post/175659/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../175643/index.html">Important points when linking to your site</a></li>
<li><a href="../175645/index.html">OwnCloud installation and configuration</a></li>
<li><a href="../175651/index.html">Problems of long PHP scripts</a></li>
<li><a href="../175655/index.html">How we improved the work of the support service in Yandex.Mail</a></li>
<li><a href="../175657/index.html">Code as an argument in Caché ObjectScript</a></li>
<li><a href="../175661/index.html">Windows Phone and continuous integration into TeamCity</a></li>
<li><a href="../175663/index.html">Installing Nexus 1000V on vSphere 5.1 (Part One)</a></li>
<li><a href="../175665/index.html">Browser Games (Poll)</a></li>
<li><a href="../175669/index.html">PXE boot menu with System Center Configuration Manager</a></li>
<li><a href="../175671/index.html">Petman from Boston Dynamics is ready to serve</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>