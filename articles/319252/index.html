<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Puzzle on STL associative containers or How to solve one problem in eight very different ways</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In this article I want to talk about my ‚Äúadventures‚Äù when solving the STL problem that arose during the work on a small project (C ++ 1...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Puzzle on STL associative containers or How to solve one problem in eight very different ways</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction </h3><br>  In this article I want to talk about my ‚Äúadventures‚Äù when solving the STL problem that arose during the work on a small project (C ++ 11, Visual Studio 2015). <br><br>  At first glance, the task looked quite simple.  But upon closer inspection: <br>  - there was no ready solution in open sources; <br>  - standard OOP approaches on it ‚Äústalled‚Äù; <br>  - It turned out that even for an experienced developer, the task may be difficult. <br><br>  I will give several solutions.  I dropped some of them before implementation, but some were actually written.  From some examples, one can benefit only from the ‚Äúsee and never do that‚Äù type, while others may well be used in practice. <br><a name="habracut"></a><br><h3>  Formulation of the problem </h3><br>  So, there is a storage structure, one of the fields of which is the STL associative container std :: map: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs swift">#include &lt;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... something using Data = std::map&lt;int, double&gt;; Data data; // ... something };</span></span></code> </pre> <br>  Then several instances of the repository are created into which the data is stuffed: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> Fill(<span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>) { <span class="hljs-type"><span class="hljs-type">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span>.data.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>( {i, i} ); } } <span class="hljs-type"><span class="hljs-type">int</span></span> main() { <span class="hljs-keyword"><span class="hljs-keyword">Storage</span></span> data1, data2; Fill(data1); Fill(data2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Then (since the development of data structures went hand in hand with writing the code that uses them), it turned out that in fact these storages should not be exactly the same: in some instances, sorting is required in ascending order, in others - in descending order.  Those.  data can be filled (and even needed) in a uniform way, but using (extracting) the data sorted by default, the map has to be written differently (for some instances - with a direct iterator, for others - the reverse). <br><br>  The problem with this was that the use of data was planned in many algorithms, and erroneous walking of the container in the wrong direction could lead to serious consequences. <br><br>  Creating containers with many such storages (or pointers to such storages) was not planned, which of course simplified the task, but if you could solve it for the general case, it would be excellent. <br><br><h3>  Option 1 - frontal </h3><br>  We supplement the structure with a field of variety, and the responsibility for choosing the correct version is assigned to the user of the structure.  Well, a little sweeten the pill - ensure the impossibility of changing the variety after creating an instance: <br><br><pre> <code class="hljs lua">#include &lt;map&gt; #include &lt;iostream&gt; struct Storage { // ... something using Data = std::map&lt;int, double&gt;; Data data; enum Type { forward, <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span> }; const Type <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>; Storage() = delete; Storage(Type initType) : <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(initType) {}; // ... something }; void Fill(Storage &amp;storage) { int i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i ) { storage.data.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>( {i, i} ); } } std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const Storage &amp;storage) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( storage.<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> == Storage::forward ) //     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (const auto &amp;iter : storage.data) stream &lt;&lt; std::endl &lt;&lt; iter.first &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; iter.second; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto iter = storage.data.crbegin(); iter != storage.data.crend(); ++iter) stream &lt;&lt; std::endl &lt;&lt; iter-&gt;first &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; iter-&gt;second; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stream; } int main() { Storage data1(Storage::forward), data2(Storage::<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>); Fill(data1); Fill(data2); std::cout &lt;&lt; data1 &lt;&lt; std::endl &lt;&lt; data2 &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Calling it a solution does not turn the language - just a transfer of responsibility, almost not safe from using errors. <br><br><h3>  Option 2 - template </h3><br>  Associative containers STL (including map) allow you to specify the class of the comparison functor.  This feature is quite rarely required, so this parameter has a default value of std :: less.  In the literature there are examples of using associative containers with non-standard functors (as well as examples of writing custom functors), and the header file std :: greater is already defined in the header file ‚Äî just take it and use the ready-made solution. <br><br>  So, we declare Storage as a template, and we define for it 2 specializations with specific values.  At first glance - a beautiful complex-time solution: it is quickly executed, it reveals errors at the compilation stage: <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;map&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt;</span></span></span><span class="hljs-meta"> #include </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt;</span></span></span><span class="hljs-meta"> enum Type { ascending, descending }; struct StorageAncestor { // ... something }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Type T&gt;</span></span></span><span class="hljs-meta"> struct Storage : StorageAncestor { }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt;</span></span></span><span class="hljs-meta"> struct Storage</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ascending&gt;</span></span></span><span class="hljs-meta"> { using Data = std::map</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int, double, std::less&lt;int&gt;</span></span></span><span class="hljs-meta">&gt;; Data data; }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&gt;</span></span></span><span class="hljs-meta"> struct Storage</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;descending&gt;</span></span></span><span class="hljs-meta"> { using Data = std::map</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int, double, std::greater&lt;int&gt;</span></span></span><span class="hljs-meta">&gt;; Data data; }; template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Type T&gt;</span></span></span><span class="hljs-meta"> void Fill(Storage</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;T&gt;</span></span></span><span class="hljs-meta"> &amp;storage) { int i; for ( i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; 5; ++i ) { storage.data.insert( {i, i} ); } } template&lt;Type T&gt;</span></span></span><span class="hljs-meta"> std::ostream&amp; operator</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;(std::ostream &amp;stream, const Storage&lt;T&gt;</span></span></span><span class="hljs-meta"> &amp;storage) { //     for (const auto &amp;iter : storage.data) stream </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; std::endl &lt;&lt; iter.first &lt;&lt; " " &lt;&lt; iter.second; return stream; } int main() { Storage&lt;ascending&gt;</span></span></span><span class="hljs-meta"> data1; Storage</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;descending&gt;</span></span></span><span class="hljs-meta"> data2; Fill(data1); Fill(data2); std::cout </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; data1 &lt;&lt; std::endl &lt;&lt; data2 &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br>  However, an experienced eye will notice in the example given an important nuance: all the code that performs filling and using the structure had to be reworked into a template form.  In this example, this did not cause any difficulties, but in the real project the code, of course, was much more complicated - there were a lot of functions and classes filling the data, and some of them were already templates with several parameters. <br><br>  Besides: <br><br>  - the requirement of preserving uniform data filling was actually not fulfilled (the code for filling was ready by that time, unlike the code for using data) - simply with due diligence some of the work could be assigned to the compiler; <br>  - the compiler generates a separate code for each required specialization, and in this case we could talk about a significant increase (up to a doubling) of the size of the executable file. <br><br>  As a result, this option was recognized as realizable, but too complex for encoding. <br><br><h3>  Option 3 - fraudulent </h3><br>  The idea is as follows: leave std :: map alone (that is, in both cases use the default comparison functor std :: less, calling operator &lt;), and ‚Äútreat‚Äù the value used as the key. <br><br><pre> <code class="hljs kotlin">#include &lt;map&gt; #include &lt;iostream&gt; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { ascending, descending }; template&lt;typename T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FraudulentValue</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FraudulentValue(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T &amp;t, Type initType) : m_value(t), m_type(initType) {}; bool <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>&lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FraudulentValue&lt;T&gt; &amp;comp) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (m_type == ascending) ? (m_value &lt; comp.m_value) : (m_value &gt; comp.m_value); }; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> T() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value;}; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: T m_value; Type m_type; FraudulentValue() = delete; }; struct Storage { <span class="hljs-comment"><span class="hljs-comment">// ... something using Data = std::map&lt;FraudulentValue&lt;int&gt;, double&gt;; Data data; const Type type; Storage() = delete; Storage(Type initType) : type(initType) {}; // ... something }; void Fill(Storage &amp;storage) { int i; for ( i = 0; i &lt; 5; ++i ) { storage.data.insert( {FraudulentValue&lt;int&gt;(i, storage.type), i} ); } } std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const Storage &amp;storage) { //     for (const auto &amp;iter : storage.data) stream &lt;&lt; std::endl &lt;&lt; iter.first &lt;&lt; " " &lt;&lt; iter.second; return stream; } int main() { Storage data1(ascending), data2(descending); Fill(data1); Fill(data2); std::cout &lt;&lt; data1 &lt;&lt; std::endl &lt;&lt; data2 &lt;&lt; std::endl; return 0; }</span></span></code> </pre><br>  It is clear that this option is categorically not suitable for production, because: <br><br>  - operator &lt;in some cases performs a comparison "&lt;", and in others "&gt;" - a stunningly unexpected behavior, nothing can be said; <br>  - there is no mechanism to prevent adding values ‚Äã‚Äãto the map with an incorrectly configured key, which is expected to lead to container damage. <br><br><h3>  Option 4 - encapsulation </h3><br>  "Encapsulation" - placement in one class (or structure, as in this case) and data, and algorithms.  Well, if difficulties are caused by differences in the bypass code, this means that this code should be placed in the same place as the container being relocated and the direction flag. <br><br><pre> <code class="hljs lua">#include &lt;map&gt; #include &lt;iostream&gt; #include &lt;functional&gt; struct Storage { // ... something using Data = std::map&lt;int, double&gt;; Data data; enum Type { forward, <span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span> }; const Type <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>; Storage() = delete; Storage(Type initType) : <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>(initType) {}; using const_functor = std::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(const Data::value_type&amp;)</span></span></span></span>&gt; const; void for_each(const_functor &amp;functor) const { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> == Storage::forward ) //     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto &amp;iter : data) functor(iter); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> //     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (auto iter = data.crbegin(); iter != data.crend(); ++iter) functor(*iter); }; // ... something }; void Fill(Storage &amp;storage) { int i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">5</span></span>; ++i ) { storage.data.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>( {i, i} ); } } std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const Storage &amp;storage) { storage.for_each([&amp;](const Storage::Data::value_type &amp;value) { stream &lt;&lt; std::endl &lt;&lt; value.first &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; value.second; } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stream; } int main() { Storage data1(Storage::forward), data2(Storage::<span class="hljs-built_in"><span class="hljs-built_in">reverse</span></span>); Fill(data1); Fill(data2); std::cout &lt;&lt; data1 &lt;&lt; std::endl &lt;&lt; data2 &lt;&lt; std::endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  To make this solution suitable for production, all that remains is: <br><br>  - write a family of brute force algorithms - in the forward and backward directions, for const and non-const functors; <br>  - hide data in private to exclude the possibility of using the usual (in this case, undesirable) brute force mechanism; <br>  - provide a full-fledged interface to the hidden container, for which to write wrappers for three or four dozen functions and repeat 15 typedefs. <br><br><h3>  Option 5 - hereditary, it is - unrealizable </h3><br>  The idea of ‚Äã‚Äãthis option is as follows: inherit from std :: map, as a result of which get access to any protected-map mechanisms. <br><br>  However, this option was not feasible for the following reasons: <br><br>  - all potentially useful mechanisms were declared to be private rather than protected (possibly Microsoft-specific); <br>  - even if something was found protected, the option would be completely dependent on the specific implementation of STL; <br>  - Inheritance from an STL container is generally a very bad idea, since  STL containers do not have a virtual destructor, which can lead to memory leaks. <br>  However, the study of the internal structure of std :: map prompted me to the next option. <br><br><h3>  Option 6 - specific </h3><br>  During the initial analysis of the problem, it seemed that only <b>the</b> comparison functor <b>class is</b> important (after all, we specify the <b>class</b> as a parameter of the std :: map template, and how the container controls this class is hidden somewhere in the depths of the implementation).  However, when studying the STL source codes, it turned out that each instance of std :: map creates and stores an <b>instance of the</b> comparison functor.  Thus, the basis of this idea is to configure an instance of the comparison functor in accordance with the required direction of sorting. <br>  In the Microsoft STL implementation of std :: map, there is an undocumented nonstandard _Getcomp () method, one of the versions of which provides access by reference to an instance of the comparison functor, allowing you to change its internal state (setting) according to our needs. <br><br><pre> <code class="hljs swift">#include &lt;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&gt; #include &lt;iostream&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SortingType</span></span></span><span class="hljs-class"> </span></span>{ ascending, descending }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompareType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, less, greater }; template&lt;typename <span class="hljs-type"><span class="hljs-type">T</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AdjustableCompare</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-type"><span class="hljs-type">AdjustableCompare</span></span>() : m_type(<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>) {}; bool <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(const <span class="hljs-type"><span class="hljs-type">T</span></span> &amp;_Left, const <span class="hljs-type"><span class="hljs-type">T</span></span> &amp;_Right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( m_type == less ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (_Left &lt; _Right); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( m_type == greater ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (_Left &gt; _Right); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"AdjustableCompare was not initialized"</span></span>); }; void setTypeOnce(<span class="hljs-type"><span class="hljs-type">CompareType</span></span> type) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( m_type != <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"AdjustableCompare double set"</span></span>); m_type = type; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-type"><span class="hljs-type">CompareType</span></span> m_type; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... something using Data = std::map&lt;int, double, AdjustableCompare&lt;int&gt;&gt;; Data data; Storage() = delete; Storage(SortingType initType) { data._Getcomp().setTypeOnce( (initType == ascending) ? less : greater ); }; // ... something }; void Fill(Storage &amp;storage) { int i; for ( i = 0; i &lt; 5; ++i ) { storage.data.insert( {i, i} ); } } std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const Storage &amp;storage) { //     for (const auto &amp;iter : storage.data) stream &lt;&lt; std::endl &lt;&lt; iter.first &lt;&lt; " " &lt;&lt; iter.second; return stream; } int main() { Storage data1(ascending), data2(descending); Fill(data1); Fill(data2); std::cout &lt;&lt; data1 &lt;&lt; std::endl &lt;&lt; data2 &lt;&lt; std::endl; return 0; }</span></span></code> </pre><br>  This solution: <br><br>  - in contrast to the options considered so far, it is the <b>setting of the</b> container <b>instance</b> that performs; <br>  - containers with different sorting directions are of the same type, which makes it possible to carry out both filling of the container and data retrieval in a uniform manner, as well as creating containers of such containers (or pointers to them); <br>  - it requires that the default constructor compare class functor (which is why CompareType has three possible values ‚Äã‚Äãinstead of two, and also expands the space for incorrect use of the functor); <br>  - is Microsoft-specific; <br>  - based on interference with the internal mechanisms of the map. <br><br>  The last two points are enough to not recommend it for use. <br><br><h3>  Option 7 - trick or Trojan </h3><br>  In the std :: map there is also the standard function key_comp (), which returns <b>a copy of the</b> comparison functor <b>instance</b> .  Unfortunately, a copy of the functor does not allow us to change the internal state of an instance of a class stored in the depths of std :: map, and will not help in solving our problem. <br><br>  Do you agree? <br><br>  Well, see the code: <br><br><pre> <code class="hljs swift">#include &lt;<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&gt; #include &lt;iostream&gt; #include &lt;memory&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SortingType</span></span></span><span class="hljs-class"> </span></span>{ ascending, descending }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompareType</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">none</span></span>, less, greater }; template&lt;typename <span class="hljs-type"><span class="hljs-type">T</span></span>&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TrickyCompare</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-type"><span class="hljs-type">TrickyCompare</span></span>() : m_type(new <span class="hljs-type"><span class="hljs-type">CompareType</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>)) {}; bool <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(const <span class="hljs-type"><span class="hljs-type">T</span></span> &amp;_Left, const <span class="hljs-type"><span class="hljs-type">T</span></span> &amp;_Right) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *m_type == less ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (_Left &lt; _Right); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *m_type == greater ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (_Left &gt; _Right); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"TrickyCompare was not initialized"</span></span>); }; void setTypeOnce(<span class="hljs-type"><span class="hljs-type">CompareType</span></span> type) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( *m_type != <span class="hljs-keyword"><span class="hljs-keyword">none</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> std::runtime_error(<span class="hljs-string"><span class="hljs-string">"TrickyCompare double set"</span></span>); *m_type = type; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: std::shared_ptr&lt;<span class="hljs-type"><span class="hljs-type">CompareType</span></span>&gt; m_type; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Storage</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... something using Data = std::map&lt;int, double, TrickyCompare&lt;int&gt;&gt;; Data data; Storage() = delete; Storage(SortingType initType) { data.key_comp().setTypeOnce( (initType == ascending) ? less : greater ); }; // ... something }; void Fill(Storage &amp;storage) { int i; for ( i = 0; i &lt; 5; ++i ) { storage.data.insert( {i, i} ); } } std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const Storage &amp;storage) { //     for (const auto &amp;iter : storage.data) stream &lt;&lt; std::endl &lt;&lt; iter.first &lt;&lt; " " &lt;&lt; iter.second; return stream; } int main() { Storage data1(ascending), data2(descending); Fill(data1); Fill(data2); std::cout &lt;&lt; data1 &lt;&lt; std::endl &lt;&lt; data2 &lt;&lt; std::endl; return 0; }</span></span></code> </pre><br>  Why trick?  Yes, because thanks to the properties of the smart pointer std :: shared_ptr we were able to change the internal state of the comparison functor (and therefore the std :: map container itself) using only a copy of the instance, and it is safe to do so in terms of memory leaks.  In this example, the absence of a copy constructor and an assignment statement that ‚Äúcorrectly handles pointers‚Äù is not an encoding error, but exactly what is needed. <br><br>  Why trojan?  Because we gave std :: map something externally very simple and useful, but actually hiding inside some complicated mechanism with unexpected behavior that could affect the operation of the map.  The seemingly reliable ways to protect the internal state of the map provided by the developers of the C ++ standard turned out to be powerless against this trick (yes, it‚Äôs dangerous for the associative container to work, because changing the mode of the functor after adding a certain number of elements almost guaranteed to damage the container) .  Our functor provides protection against changing the operation mode after initialization.  But any protection may contain errors. <br><br>  This method is already very close to the final version.  There, however, I do not recommend it for use in production ‚Äî not because I know about any of its fatal flaws, but only because I discovered a simpler and more ‚Äúdirect‚Äù way. <br><br>  At the same time, the trick applied in this variant may well give an elegant solution to some other practical problem. <br><br><h3>  Option 8 - final </h3><br>  The correct solution of the problem, of course, turned out to be very simple and elegant. <br>  Among a dozen constructors, std :: map, there were several that take an <b>instance of a</b> comparison functor as an argument.  It seems that such use of the map was foresightly provided by the developers of the C ++ standard, for which honor and praise to them. <br><br><pre> <code class="hljs kotlin">#include &lt;map&gt; #include &lt;iostream&gt; #include &lt;memory&gt; template&lt;typename T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Compare</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Type { less, greater }; Compare() = delete; Compare(Type type) : m_type(type) {}; bool <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>()(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T &amp;_Left, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> T &amp;_Right) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( m_type == less ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (_Left &lt; _Right); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (_Left &gt; _Right); }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Type m_type; }; struct Storage { <span class="hljs-comment"><span class="hljs-comment">// ... something using Data = std::map&lt;int, double, Compare&lt;int&gt;&gt;; Data data; enum Type { ascending, descending }; Storage() = delete; Storage(Type initType) : data((initType == ascending) ? Compare&lt;int&gt;::less : Compare&lt;int&gt;::greater) {}; // ... something }; void Fill(Storage &amp;storage) { int i; for ( i = 0; i &lt; 5; ++i ) { storage.data.insert( {i, i} ); } } std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const Storage &amp;storage) { //     for (const auto &amp;iter : storage.data) stream &lt;&lt; std::endl &lt;&lt; iter.first &lt;&lt; " " &lt;&lt; iter.second; return stream; } int main() { Storage data1(Storage::ascending), data2(Storage::descending); Fill(data1); Fill(data2); std::cout &lt;&lt; data1 &lt;&lt; std::endl &lt;&lt; data2 &lt;&lt; std::endl; return 0; }</span></span></code> </pre><br>  This solution: <br><br>  - perfectly consistent with the ideology of STL, and with the standard C + +; <br>  - fully fulfills the task, including the desired item (nothing prevents the creation and uniform processing of the container of such containers); <br>  - has a high level of protection against usage errors (including due to the lack of a default constructor for the comparison functor). <br><br><h3>  Conclusion </h3><br>  What caused the difficulty in solving this problem? <br><br>  The main factor was that the fact of storing an instance of a comparison functor inside each instance of an associative container is neither obvious nor widely known.  At first glance, only the comparison functor class seems important, which does not fully correspond to the real state of affairs. <br><br>  <b>PS:</b> despite the presence of side effects and contraindications for use, all examples cited in the article are functional. <br><br><h3>  Thanks </h3><br>  <a href="https://habrahabr.ru/users/the_1x/" class="user_link">the_1x</a> <br><br><h3>  Literature </h3><br>  - C. Meyers - Effective use of STL <br>  - Working Draft, Standard for Programming Language C ++, N3797.  Pp  23.2.4.2, 23.2.4.12. </div><p>Source: <a href="https://habr.com/ru/post/319252/">https://habr.com/ru/post/319252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319242/index.html">Mobile OCR. How it all began (part 2)</a></li>
<li><a href="../319244/index.html">BLE under the microscope</a></li>
<li><a href="../319246/index.html">How can I save on taxes 13.3 times</a></li>
<li><a href="../319248/index.html">Skype Out vs Out vs Tviggo vs Signal</a></li>
<li><a href="../319250/index.html">Why are VR shots so lame, and what to do about it?</a></li>
<li><a href="../319254/index.html">"How do games": a two-hour talk about the monetization of online games</a></li>
<li><a href="../319256/index.html">First steps with STM32 and mikroC compiler for ARM architecture - Part 2, continued</a></li>
<li><a href="../319258/index.html">Oracle APEX: Interactive Report with Checkboxes</a></li>
<li><a href="../319260/index.html">Develop and publish a game for Android in a week</a></li>
<li><a href="../319262/index.html">Comparative analysis of traffic balancing methods</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>