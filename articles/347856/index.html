<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data structures with program properties</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, a database is a repository of structured information, passive in nature. The business logic of the application is implemented somewhere o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data structures with program properties</h1><div class="post__text post__text-html js-mediator-article">  As you know, a database is a repository of structured information, passive in nature.  The business logic of the application is implemented somewhere outside the base, in the form of a "set of actions to achieve the desired result."  If changes are made to the stored data set, the result should be the new state of the database.  In short form, it can be written something like this: event ‚Üí {actions} ‚Üí result.  Let's change this wording to: event ‚Üí rules ‚Üí result, and see what happens. <br><a name="habracut"></a><br>  If the automation domain is a system of interacting values, then it can be described by the ER model, which is formed by instances of just four abstract entities: <i><b>a</b> data</i> <i>class</i> , a <i>class <b>attribute, a</b> class</i> <i><b>relationship</b> ,</i> and an <i><b>association of</b> attributes</i> .  Such a model not only forms the logical structure of the database, but possesses all the properties of the program, which in essence is - in the computing environment formed by the methods of the mentioned abstract entities. <br><br>  Consider this bold statement in more detail, starting with the most common definitions.  (The following repetition of the well-known is necessary at least to indicate the meaning of the terms used. It will be dry and tedious - as in any other theoretical material. To enliven it slightly, examples are embedded in the text.) <br><br>  Virtually any objectively existing subject area can be viewed from an <i><b>informational</b> point of view</i> as a system of <i>interacting values</i> .  Immediately, we note that a single value is never either independent or self-sufficient, since it exists as a certain characteristic of <i>a data object</i> .  Therefore, a complete set of data objects with their values ‚Äã‚Äãis necessary for an accurate description of a subject area in a certain state.  At the same time, single-type objects are described <i>by a data class</i> , and exist on the rights of derived instances of this class - <i>class objects</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="p01"></a><h3>  Classes and Attributes </h3><br>  <i><b>The</b> data <b>class</b></i> expresses a separate conceptual essence of the subject domain in question and is characterized by the user name of this entity.  In turn, any conceptual entity has some unique set of its own characteristics / properties.  <i><b>The</b> class <b>attribute</b></i> expresses a separate characteristic of an entity, is named the user name of this characteristic, has a type that defines the set (domain) of its valid values, and acts as a factory of specific characteristic values ‚Äã‚Äãin class objects. <br><br>  Accordingly, a data class owns a set of attributes (class) that it stores in a tuple format.  Acting as a factory of objects, a class forms the contents of an object as a <a href="https://habrahabr.ru/post/345158/"><i>tuple of</i></a> <i>values</i> , which is an instance derived from the <i>attribute tuple</i> .  In addition, each value in the <i>tuple of values ‚Äã‚Äãof a class object</i> is an instance derived from the corresponding class attribute. <br><br>  Thus, a very specific subject area that exists as a set of objects with their values ‚Äã‚Äãis described at the level of abstraction by a system of classes with their attributes.  And at the same time, data and metadata represent a persistent data structure stored in an <a href="https://habrahabr.ru/post/345158/">object database</a> . <br><br><a name="p02"></a><h3>  Class relationship </h3><br>  The basis for the implementation of communication data objects based on the principle of symmetry.  In accordance with this principle, the objects being linked mutually exchange their identifiers.  The object identifier ( <a href="https://habrahabr.ru/post/345158/"><i><b>IDO</b></i></a> descriptor) is global within the physical database, and is a simple integer. <br><br>  At the level of abstraction, the relationship of objects is described by a <i><b>class relation</b></i> .  The declaration of a relationship is implemented by creating an attribute in each of the two classes connected by a relationship, which mutually address each other.  Each of the <i><b>attributes of the relationship is</b></i> typed by the opposite class of the relationship (each class is considered to be an independent user data type), as a result of which the domain of values ‚Äã‚Äãof the reference attribute is a set of object descriptors of the opposite class. <br><br>  The class relationship sets a <i><b>measure for the</b> quantitative interaction of the</i> derived objects of these classes.  With all the simplicity of this definition, relations have so diverse functional behavior and mutual logical dependence that this extensive topic will be considered separately. <br><br>  In the meantime, it is worth mentioning that with respect to <i>one-to-one,</i> both reference attributes are absolutely equal, and their value in data objects will be the only descriptor of a communication partner.  In relation to the <i>many-to-one</i> attributes are obviously not equal: neither by the format of the stored value, nor by the order of formation of the value.  If, on the side of the <i>many</i> , the attribute value of the [ <i>direct link</i> ] is still the only descriptor, then on the side of the <i>one</i> , as a result of strictly observing the reference symmetry, the value of the attribute [ <i>backward reference</i> ] will be a set of descriptors representing the key-value list.  In this case, the value of the reverse link attribute is derived from the value of the direct link attribute.  The mechanism for implementing this derivative will be discussed in detail below. <br><br><a name="p03"></a><h3>  Attribute Relationship </h3><br>  The interaction of values ‚Äã‚Äãis understood as their <i>causal</i> functional relationship.  This relationship exists only at the conceptual level of abstraction, where it takes the form of a <i><b>virtual connector of</b></i> two attributes.  By analogy with the class relationship, the attribute association declaration is implemented by creating two sockets (parallel with TCP sockets is appropriate), each of which belongs to its own attribute, and is placed in its <i>socket tuple</i> . <br><br>  A separate <i><b>socket</b></i> describing the properties of communications from its attribute is the same persistent data structure of the abstraction layer as a class and attribute.  Like relationship attributes, the sockets that make up the connector mutually address each other.  For these purposes, the socket declaration contains a complex identifier ( <i>class + attribute + socket</i> ) of the opposite socket connector.  Also, the socket declaration contains a set of flags that control the transmission and reception of values ‚Äã‚Äãthrough a connector. <br><br><a name="p04"></a><h3>  Tuple </h3><br>  Logically, a tuple is a simple enumeration of homogeneous (in terms of a tuple) elements containing a certain number of bytes of data.  Knowledge of the content and methods of its formation lie outside the tuple.  The tuple only provides space for storage and long-term storage.  Features of the internal implementation of the tuple were discussed <a href="https://habrahabr.ru/post/345158/">here</a> . <br><br>  A tuple element is uniquely identified by its place (sequence number) in a tuple that never changes.  When added to a tuple, the new element takes its place once and for all. <br><br>  The content of a tuple element can be either a unitary value or another tuple.  This makes the tuple the main (and only) structure-forming component of the object representation.  For example, a class declaration is a tuple whose elements are class properties, one of which is a class attribute tuple. <br><br>  A tuple has the ability to create its own instance, which is an empty tuple whose elements have no content.  This ability is used, for example, by a class, both when creating inheritance classes and when creating its derived objects, in which the mutual identification of attributes and values ‚Äã‚Äãderived from them is ensured by the coincidence of the element numbers in the corresponding tuples. <br><br><a name="p05"></a><h3>  Identification system </h3><br>  The constancy of the space occupied by an element in a tuple underlies the system of internal identification of entities, which in its most general form looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lr/rx/g9/lrrxg93ykpyqbjak0nece8fo8zg.png"></div><br>  Each entity is identified by its descriptor - a sequence number in the corresponding tuple: <i><b>IDC</b></i> - class, <i><b>IDA</b></i> - attribute, <i><b>IDS</b></i> - socket, <i><b>IDO</b></i> - object (logically <a href="https://habrahabr.ru/post/345158/">DAT</a> objects should also be considered as a tuple).  Logic also suggests that classes are elements of a tuple whose specific owner is covered in the class relationship article. <br><br><a name="p06"></a><h3>  Models and Meta Entities </h3><br>  What is remarkable - at the level of abstraction, there are two models at once, formed by various entities of this level. <br><br>  The collection of stored <i>class</i> declarations, <i>attributes,</i> and <i>sockets</i> forms <i><b>the data model</b></i> .  The data model is considered to be <i>executive</i> , since the entities forming it perform in relation to the data level the function of the object factory (class) and the value factory (attribute). <br><br>  <i><b>The application model</b></i> is virtual, and exists on the rights of the <i>form of</i> data model <i>representation</i> .  An application model is dynamically created by a <i>visual designer</i> , which uses it to display an existing data model, and create new declarations in it, by creating new application model entities.  Along with the real <i>class</i> and <i>attribute</i> , such virtual entities as <i>relation</i> and <i>connector</i> take part in the formation of <i>the application model</i> .  Virtual entities do not form stored declarations, but are created dynamically from attribute and socket declarations, partially encapsulating the fact of their existence.  The virtual nature of the application model does not interfere at all to consider it as a <i>primary</i> domain <i>model</i> . <br><br>  In turn, all the listed real and virtual entities of the level of abstraction are instances of entities of a still higher level of abstraction - the level of <i>meta-definitions</i> .  At this level, structurally and programmatically implemented such entities as: <i>meta-tuple</i> , <i>meta-class</i> , <i>meta-attribute</i> , <i>meta-relation</i> , <i>meta-socket</i> and <i>meta-connector</i> . <br><br>  It is worth emphasizing once again that all design methods by which both models (data and applications) are created and changed, as well as all the execution methods used by the data model in relation to objects and data-level values, belong to meta-level entities.  The model level, which ensures the creation and execution of all business logic of the application, is formed exclusively by declarative instances of meta-entities, and does not contain executable code. <br><br><a name="p07"></a><h3>  Execution methods </h3><br>  <i>Design</i> methods by which instances of meta-entities are created and the values ‚Äã‚Äãof one or another of their properties are redefined are quite obvious and do not require comments.  What cannot be said about the methods of <i>execution</i> forming the notorious computing environment, with the help of which external influences change the state of data in accordance with the rules declared in the form of a data model.  As a matter of fact, the call of the method of execution is such an external influence.  In total, there are four such methods: <i>Create</i> , <i>Set</i> , <i>Get,</i> and <i>Update</i> . <br><br>  The <i><b>Create</b></i> method belongs to the meta-class, and is used to create a derived class object.  The method parameter is the <i>IDC</i> descriptor of the target class.  The <i>Create</i> method creates an object as an instance of the attribute tuple of the specified class, and registers it in the <i>DAT</i> allocation table for the next free <i>IDO</i> descriptor. <br><br>  Attribute methods: <i>Set</i> , <i>Get</i> and <i>Update</i> , belong to a meta-attribute, and allow you to operate on the values ‚Äã‚Äãof data objects.  The <i><b>Set</b></i> method is responsible for assigning a value, the <i><b>Get</b></i> method is responsible for fetching a value, and the <i><b>Update</b></i> method is an event that triggers an attribute to re-form a derived stored value (the meaning of this action will become clear later). <br><br>  For attribute methods, the target object is identified by the <i>IDO</i> descriptor, and the target value itself is available exclusively through the class attribute, the path to which is represented in the <i>IDC + IDA</i> data model descriptors.  In other words, all actions on a value are performed on behalf of a class attribute.  A feature of the execution of attribute methods is that in its course each method resorts to iterating over the sockets in the attribute tuple, invoking a similar method for the target attribute addressed by the connector, provided that the flag is set to the same name in the socket. <br><br>  Since the execution of any of the three methods: <i>Create</i> , <i>Set</i> or <i>Update</i> , will change the <a href="https://habrahabr.ru/post/345158/">state of the data</a> , they can only be called in the context of a <a href="https://habrahabr.ru/post/345158/">transactional session</a> .  Calling any of these three methods is an atomic external impact on the database, which is easily formalized into <a href="https://habrahabr.ru/post/345158/">a transaction format</a> , and then saved in a log. <br><br>  Consider the logic of the execution of attribute methods in a little more detail. <br><br><a name="p08"></a><h3>  Assignment of value </h3><br>  So, the <i>Set</i> method is called, to which the address parameters have been passed, and a pointer to the value to be assigned ( <i>* value</i> ).  In the body of this method, the attribute will generate a new value, perform its assignment to the corresponding element of the object tuple, and then begin sequential search of sockets from its tuple.  For each socket for which the <i>Set</i> [ <b>S</b> ] flag is <i>set</i> , the source attribute will call the <i>Set</i> method for the attribute, the path to which is specified in the socket declarations.  Note that the execution of the method can be completed ahead of time, without bypassing the socket tuple, if the new value is equivalent to the stored one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gw/o-/tx/gwo-txqvvs80guwef3zpaq-ypre.png"></div><br>  When making derived calls to <i>Set</i> , the attribute follows the principle of isolation - ‚Äúfired, and forgot,‚Äù without worrying about the consequences.  The further course of events is determined by other actors-attributes.  At the same time, what is important, the transactional nature of the execution ensures the permanent consistency of all variable values, regardless of the scope and ‚Äúlength‚Äù of the changes. <br><br>  Consider the formation of derived values ‚Äã‚Äãfor example from the life of accounts and invoices: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5d/j6/ah/5dj6ahycuzhgt-p11ks4k2ikcri.png"></div><br>  In the diagram, the contour arrows indicate the user input of values, the same external call <i>Set</i> .  Any change in the attribute values <i>Quantity</i> or <i>Price is</i> actively transferred to the <i>Sum</i> attribute, which uses a <i><b>functional</b></i> , in this case - multiplicative, to form a derived value. <br><br>  <i>Functionals</i> are predefined (for each value type) meta-attribute methods that allow the resulting value to be generated by converting argument values ‚Äã‚Äãobtained via connectors from one or more source attributes.  An attribute is assigned a functional by assigning its descriptor ( <i><b>IDF</b></i> ), which is a sequence number in the general list of functionals. <br><br>  If an attribute is assigned a functional, then all <i>Set</i> and <i>Get</i> calls to the attribute address are processed by this functionality, if necessary with additional polling ( <i>Get</i> ) of sources.  Note: to exclude the original call source from polls, the address part of the call ( <i>IDC + IDA</i> ) permanently includes the socket socket ( <i>+ IDS</i> ) as well. <br><br><a name="p09"></a><h3>  Dependent connector </h3><br>  Both connectors from the above example were used in simple <i>unconditional</i> form. <br><br>  Meanwhile, the functional behavior of the connector can be made dependent on the valid values ‚Äã‚Äãof third-party attributes, which for the original connector form a kind of " <i>execution context</i> ".  To implement communication with context attributes, socket declarations provide for the possibility of addressing three additional, so-called " <i>context</i> " sockets.  Each context socket has its own, strictly fixed purpose-aspect: <i>blocking</i> ( <i><b>lock</b></i> ), <i>reference</i> ( <i><b>ref</b></i> ) and <i>key</i> ( <i><b>key</b></i> ), but at the same time these are exactly the same meta-socket instances as the " <i>basic</i> " sockets of the connector.  To address each context socket to the base one, two descriptors are enough: <i>IDA + IDS</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/58/0s/zl/580szluuncvatj0o3dt_apghsiu.png"></div><br>  A blocking <i><b>lock-</b></i> socket allows the transfer of a value over a connector, if the value returned by it is relevant, and blocks otherwise.  Actual is the initialized value of the socket's owner attribute ( <i><b>lock-context</b></i> ), which is additionally evaluated from the point of view of its type: <i>true</i> for logic, not zero for a number, and at least one literal is present (besides the space) for the string. <br><br>  Reference <i><b>ref-</b></i> socket is used in external connectors linking attributes of different classes.  It provides the connector with <i>IDO</i> descriptors for data objects of another class, using the corresponding relation attribute ( <i><b>ref context</b></i> ) in its class as the source of values. <br><br>  The ‚Äúkey‚Äù <i><b>key-</b></i> socket provides the connector with the key values, and is required for the implementation of working with lists.  As a source of key values ‚Äã‚Äã( <i><b>key context</b></i> ), the <i>base</i> class <i>attribute is</i> used by default. <br><br>  Without taking into account the specifics of the reference and key <i>aspects</i> , the logic of the interaction of context sockets with the basic one is common for all three contexts.  So the base socket on each side of the connector will immediately interrupt the execution of the current method <i>Set</i> |  <i>Get</i> , if at least one of its existing (that is, actually declared and still relevant) contexts contains an irrelevant meaning.  In other words, <i>ref-</i> and <i>key-</i> contexts permanently also possess <i>lock-</i> context properties.  This is not surprising if we recall that the value of any type can be reduced to a logical type. <br><br><a name="p10"></a><h3>  Socket methods </h3><br>  The initiation of a <i>conditional connector</i> from its contexts is performed by calling one of two internal execution methods: <i><b>Reset</b></i> and <i><b>Unset</b></i> , belonging to the meta-socket.  These methods are invoked by the context attribute during the execution of the <i>Set</i> method to the address of the underlying socket of the connector according to the following rules.  If the current value of the attribute is relevant, then before any change of the attribute, the attribute will call the <i>Unset</i> method for all its sockets that have the <i>Unset</i> [ <i><b>U</b></i> ] flag <i>set</i> .  Further, after assigning a new value, in the repeated cycle of traversing the tuple to invoke the <i>Set</i> derived methods, the attribute will call the <i>Reset</i> method for its own sockets which have the <i>Reset</i> [ <i><b>R</b></i> ] flag set.  In other words, an attribute performs a simulation, first de-initializing its effective value, with all the ensuing consequences for the external environment of the attribute, and then performing initialization with a new value. <br><br>  In turn, the <i>base socket</i> , when executing the <i>Unset</i> |  <i>Reset</i> , will call the <i>Set</i> method to the opposite attribute of the connector with a set of parameters (including the current values ‚Äã‚Äãof the existing contexts), imitating the de-initialization (Unset) of the property of the owning attribute, or its initialization (Reset) by the external value.  It is easy to implement such an imitation if, in the parametric part of the <i>Set</i> method, to transfer not one pointer to the value, but two: to the value before the change, and to the new value.  Then in the parameters <i>Set</i> , derived from <i>Unset</i> |  <i>Reset</i> , one of the pointers will always be NUL. <br><br>  For greater clarity, we illustrate what has been said with examples. <br><br><a name="p11"></a><h3>  Execution examples </h3><br>  Consider the use of a reference <i>ref</i> aspect with the following example: The <i>invoice</i> in the <i>Total</i> attribute summarizes the value of the <i>Sum</i> attribute of all its Records.  Hereinafter, in such schemes, the vertical line divides the spaces of class-related classes, and the protrusion on it denotes the measure of quantitative interaction of classes as <i>many-to-one</i> .  In our example, <i>many</i> are <i>Record</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/t-/l5/mh/t-l5mhi93hv6tsmkfgzaaflracg.png"></div><br>  The attribute [N] is an attribute of the direct link of the Entry relationship with the <i>Invoice</i> .  If the relationship is implemented, this attribute gets the value of the <i>IDO of the</i> Object of <i>delivery note</i> as a value. <br><br>  When any change occurs, the <i>Sum</i> value is actively passed to the <i>Total</i> attribute, while the underlying socket of the connector uses the declaration of the referenced <i>ref</i> socket to refer to the [H] attribute.  The extracted <i>ref</i> value will be used as the address parameter (as a pointer to the target object) of the <i>Set</i> method, called to the address of the <i>Total</i> attribute.  If the relationship is not implemented, the derived <i>Set</i> will not be invoked. <br><br>  When the value is received by the [H] attribute, the latter method <i>Reset</i> initiates the base socket to the call of the <i>Set</i> method, the significant parameters of which will be the pair NUL ‚Üí [the current value of the <i>Sum</i> ].  If you then de-initialize the value of [H] (break the relation), then the attribute using the <i>Unset</i> method initiates the base socket to call the <i>Set</i> method with the parameters [current <i>Amount</i> value] ‚Üí NUL.  That will lead to the fact that the current value of the <i>amount</i> will be "withdrawn" from the current value of the attribute <i>Total</i> . <br><br>  Note: the <i>additive</i> functional of the attribute <i>Total</i> "can" correctly change the resulting value, receiving the input change in the value of the attribute-argument.  Such behavior, characteristic of the so-called "lazy" calculations, lies at the basis of the implementation of all natural functionals.  In relation to the above example, the <i>Total</i> attribute, there is no need to resort to the <i>Get</i> survey of all private <i>Sums</i> when changing any one; it is enough for it to take into account the magnitude and direction of the change. <br><br>  Returning to the example: if the previously initialized reference attribute [H] gets a new value ( <i>Record</i> is removed from one <i>Invoice</i> , and is included in the other), then this attribute will cause <i>Unset</i> before the change, and <i>Reset</i> after the change.  Thus, the <i>amount of the</i> record will be removed from the <i>total of the</i> first <i>Invoice</i> , and added to the second <i>total</i> .  With any combination of external influences, the system permanently preserves the logical consistency of values. <br><br>  To illustrate the work of the blocking aspect, we simply supplement the previous example: let a fixed discount be provided for each heading, which can be turned off manually. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3l/0a/9b/3l0a9bkna3j7pv61bezna7cuwvi.png"></div><br>  It should be noted that if the creation of a blocking sub-connector is done manually in the constructor, then the declarations of all reference sub-connectors are created automatically when the external connector binds attributes of different classes.  Further, in all examples, reference sub-connectors are not shown.  Also note that any attribute can be used as a blocking context, since the value of any type is automatically reduced to a logical one. <br><br>  The following example illustrates the operation of the <i>key-</i> context of a connector: Objects of the <i>Record</i> class form a list of <i>Currencies</i> rates, which is then used to perform exchange <i>operations</i> with this currency. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/py/hh/ly/pyhhlyr9cpgixc_heus17zj9prs.png"></div>  The <i>Date</i> attributes in the <i>Record</i> and <i>Operation</i> classes are the source of the key - the <i>key</i> context for the corresponding connector. <br><br>  The <i>Course</i> attribute in the <i>Currency</i> class stores a list formed by the <i>Date: Rate</i> pairs, which are formed by the <i>list functionality</i> assigned to an attribute from the values ‚Äã‚Äãthat are actively (by the <i>Set</i> method) passed to it via the connector from the <i>Record</i> class.  Note that in the parametric part of the <i>Set</i> and <i>Get</i> methods, a separate place is permanently allocated under the pointer to the key value. <br><br>  In the <i>Operation</i> class, the <i>Course</i> attribute, using the <i>Date</i> method as the key in the <i>Get</i> method, retrieves the corresponding value from the list.  <i>Get</i> itself is initiated by the active <i>Reset</i> method, generated by changing the value of: either the <i>Date</i> attribute or the reference attribute, a pointer to the <i>Currency</i> object (the corresponding reference attribute is not shown in the figure). <br><br><a name="p12"></a><h3>  Connector activity </h3><br>  Note: in the previous example, the connector <i>Course</i> . [Currency] ‚Üí <i>Course</i> . [Operation] is not active because the [ <b>S</b> ] flag is not set on the source attribute side.  Accordingly, no changes in the list of courses will not be actively translated into existing <i>Operations</i> .  However, changing the value of any of the contexts of the connector conditionally ‚Äúactivates‚Äù it, since it is accompanied by a call to the active methods <i>Reset</i> |  <i>Unset</i> .  And although <i>Get</i> itself is passive, nevertheless, the value returned by it will be assigned to the <i>Course</i> attribute during the execution of the original transaction to change the <i>Date</i> or the <i>Currency</i> reference. <br><br>  A connector with the [ <b>S</b> ] flag is the unconditionally <i><b>active</b> connector</i> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A connector that is devoid of its own activity, but with active contexts (as indicated by the flags [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] and [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] in its context sockets) is hereinafter referred to as a </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semi-active</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connector</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A connector with only the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag </font><font style="vertical-align: inherit;">is considered a </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passive</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connector</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If the connector resets all flags, then this is equivalent to its complete removal from the model. </font><font style="vertical-align: inherit;">And pay attention: it is the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag that </font><font style="vertical-align: inherit;">defines what is not mentioned earlier, but such an important property of a connector as </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value transfer </font><b><font style="vertical-align: inherit;">vector</font></b></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><a name="p13"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Logical consistency </font></font></h3><br>    ,          . <br><br>       .        ,    <i></i> .[]          .           ( <i></i> .[]) ,             <i></i>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, do not forget about emergency situations. </font><font style="vertical-align: inherit;">For example, when a functionally dependent attribute is created already after the values ‚Äã‚Äãof the attribute-arguments have been formed. </font><font style="vertical-align: inherit;">In this case, you can restore data consistency only under compulsion, using Update.</font></font><br><br><a name="p14"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Event Update </font></font></h3><br>   <i><b>Update</b></i> ,  <i>-</i> ,      .         ,          -    . <br><br>  ,       ,           .     <i>Update</i>     <i>  </i>  . ,             ,      . <br><br><a name="p15"></a><h3>   </h3><br>    ,   <i></i>  <i></i>   ,     :  <i></i> ,    <i></i>  <i></i> ,      ,  .         ,        -  ,    . ,     ,      <i> </i>  . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meanwhile, this ability can be restored by allowing the attribute to reverse the entered value in one of the attribute-arguments. In other words, it is necessary to choose the recipient of the correction value, namely, the connector to which the reverse will be carried out. In our example, it seems logical if the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Price</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attribute is selected by the recipient of the correction </font><font style="vertical-align: inherit;">, for the connector with which the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method can be </font><i><font style="vertical-align: inherit;">invoked</font></i><font style="vertical-align: inherit;"> from the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> side </font><font style="vertical-align: inherit;">by setting the corresponding flag [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> socket, as shown in the figure.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bp/zy/7s/bpzy7sfhopqa9yujp5yuzd7kny4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that the actual performer of the reversible transfer of the value is always the attribute functional, which has the appropriate algorithm for calculating the correction value. It defines the target attribute for transmission through a socket, in which the [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] and [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">flags are </font><font style="vertical-align: inherit;">set simultaneously. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reverse values ‚Äã‚Äãcan be implemented in the address of any attribute that has the ability to accept value from the outside, including such an attribute, which itself acquired this ability due to the inclusion of the reverse:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lv/zq/ke/lvzqkeuoj5jaqdnpxyjgmnwjikc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After receiving input from the outside, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Total</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attribute </font><font style="vertical-align: inherit;">uses the list of backlinks to reversely distribute its change to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attributes </font><font style="vertical-align: inherit;">for all </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> objects </font><font style="vertical-align: inherit;">from the back reference list ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ref-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> context). </font><font style="vertical-align: inherit;">You should not think that the given example is devoid of practical sense: here the cost of the work is adjusted to the maximum amount voiced by the customer. </font><font style="vertical-align: inherit;">However, it is worthwhile to give one more example of the distribution of values, also based on the reverse mechanism.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/sv/nh/pz/svnhpz4va6viixa1qifi2jms54o.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In each of the classes, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attribute is </font><font style="vertical-align: inherit;">used as a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> context to the reversible connector, thus providing it with basic values ‚Äã‚Äãfor the proportional distribution of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value </font><font style="vertical-align: inherit;">.</font></font><br><br><a name="p16"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Invert Socket </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A socket has an inversion property that is enabled by setting the </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inverse</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag </font><font style="vertical-align: inherit;">. The meaning and application of this property is different for sockets on different sides of the connector. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So if the inversion flag is set to an outgoing base socket or a context socket, then the value passed through that socket will be inverted: a positive number will become negative, and the logical value will change to the opposite.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5o/jl/w8/5ojlw8ppcbi6c2zibwp78hdynvy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setting the inversion flag for the incoming ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -) socket of the connector will change the operational behavior of the attribute's functionality. </font><font style="vertical-align: inherit;">So the value obtained through the inverse socket, the multiplicative number functional will be considered as a divisor, and not as a factor. </font><font style="vertical-align: inherit;">Similarly, a value received via an inverse socket will be considered additive by the additive functional as a deductible.</font></font><br><br><a name="p17"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Relationship implementation </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most remarkable thing is that the connector technology is also fully used for the internal needs of the data model itself. And in particular - for the implementation of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutual exchange of identifiers of</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> derived objects of classes, within the framework of the declaration of the relationship between these classes and in accordance with the requirements of the reference symmetry. The reference attributes that make up the class relationship are obviously in a direct causal relationship, which in the data model is expressed as a connector declaration. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the connector, the so-called </font><i><b><font style="vertical-align: inherit;">service</font></b></i><i><font style="vertical-align: inherit;"> attributes</font></i><font style="vertical-align: inherit;"> are used to implement the relationship.</font></font><i><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. These attributes, which perform certain utilitarian functions, are declared directly in the tuple of the meta-class, and therefore are present in the tuple of each user class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source of the value for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reference connector</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the service attribute </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Own</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This attribute is typed by its own class descriptor. When a class creates a derived object, </font><font style="vertical-align: inherit;">it stores the </font><i><font style="vertical-align: inherit;">IDO</font></i><font style="vertical-align: inherit;"> descriptor of </font><font style="vertical-align: inherit;">that object </font><font style="vertical-align: inherit;">as the value of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Own</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attribute </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Another service attribute - </font><i><b><font style="vertical-align: inherit;">Del</font></b></i><font style="vertical-align: inherit;"> , the default is used as a </font><i><font style="vertical-align: inherit;">lock</font></i></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><i><b><font style="vertical-align: inherit;"></font></b></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-context for all, without exception, outgoing external connectors connecting the attributes of different classes. This declaration provides adequate behavior for the object being deleted, namely, the removal ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) of attribute-argument values ‚Äã‚Äãfrom the values ‚Äã‚Äãof attribute-recipients localized in other classes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the actual reference attribute itself acts as a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ref-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> context of the active reference connector, providing it with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> handle of the </font><font style="vertical-align: inherit;">target object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value of the list of backlinks is formed by the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list functionality</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the key-value pairs, where the value is the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDO of the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> object that owns the direct link, and as the key source ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-context) by default, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><i><font style="vertical-align: inherit;">attribute is</font></i><font style="vertical-align: inherit;"> used </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Thus, the formation of a list of backlinks is essentially no different from the formation of a list of courses from the example above, in which the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> context of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Del</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ref</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> context of [B] are also present, but were not shown in the diagram.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qc/ky/qn/qckyqnkk7j3anvzbcn2nfysvecs.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is worth emphasizing once again that this whole structure, which includes service attributes and a reference connector, is created automatically by the relationship designer. </font></font><br><br><a name="p18"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connector functionality </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although the socket has an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unset / Reset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><i><font style="vertical-align: inherit;">connector</font></i><font style="vertical-align: inherit;"> , the connector does not have its own functionality. Logically linking attributes, the connector is merely a declaration of the presence and nature of the causal dependence of the derived values. The implementation of this dependency itself is carried out exclusively by attribute methods. Therefore, the connector functionality should be understood as a complex declarative property of the dependency described by it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Being a purely virtual entity, the connector is made up of </font><i><font style="vertical-align: inherit;">meta-socket</font></i><font style="vertical-align: inherit;"> instances.</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that are logically related by mutual addressing. Accordingly, the nature of the declared attribute dependency is determined both by the combination of the sockets forming the connector and by setting the flags of the individual instance. A separate socket can be connected to four other sockets, each of which is assigned a strictly unambiguous functional aspect: basic (opposed) ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -), blocking ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -), referential ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ref</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -) and additional ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -). Accordingly, the address part of the properties of a meta-socket includes three routes in terms of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDA + IDE + IDS</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (the meaning of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDE</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descriptor </font><font style="vertical-align: inherit;">will be clear later), of which a pointer to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-socket supplemented by an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descriptor </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Property Meta socket defining its transfer function includes five flags: </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nverse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not previously mentioned, but the meta-socket declaration also includes an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> functional descriptor </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The attribute allows you to generate your value in the only way, so the incoming socket ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-) This property is not used. </font><font style="vertical-align: inherit;">But the outgoing socket, as well as the context sockets of the complex connector, can use not only the stored value of the attribute, but also the transformed value obtained through the functional.</font></font><br><br><a name="p20"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sampling value </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In all the examples considered earlier, by default it was assumed that class attributes operate on persistent values ‚Äã‚Äãthat are stored in a database in tuples of class objects. </font><font style="vertical-align: inherit;">The fact of long-term storage of derived values ‚Äã‚Äãallows characterizing such attributes as </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">For static attributes, data sampling, implemented by the execution of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">, is reduced to simple retrieval and return of the stored value, regardless of all other conditions, including the presence of incoming connectors for the attribute.</font></font><br><br>       .      ,            (,      ¬´ ¬ª).     <i>Get</i>           <i>Get</i> .  ,      ,     ,   <a href="https://habrahabr.ru/post/345158/"></a>        .      :  -  <i>Get</i>   <i>Unset/Reset</i> ,       . <br><br><a name="p21"></a><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An exception may unexpectedly become a rule, under certain conditions. It is not necessary to use a stored value if it can be dynamically generated, based on incoming connectors for attribute arguments. To give the attribute of such behavior, it is enough to set the corresponding flag in its properties. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When implementing a sample, the </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dynamic</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> attribute</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ignores the stored value, even if it exists in the data object, and uses only the functionals assigned to it and cause-and-effect relations expressed by connectors to form the value. During polling, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get Get</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calls </font><font style="vertical-align: inherit;">will be made only for those sockets from the tuple that have the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">flag set </font><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/iy/fy/2u/iyfy2uvmsqnt8g4nuazoktgimb0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that even with incoming connectors, not all attributes can be translated into a dynamic form. Baseline entity characteristics, reference values, and all lists, can only exist statically. And do not forget that directly or indirectly, but the value of a dynamic attribute is formed from stored values. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since a dynamic attribute does not form a stored value, all its incoming connectors are forcibly transferred to an inactive form by resetting the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Set</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in all sockets. </font><font style="vertical-align: inherit;">This allows you to automatically exclude an unnecessary call to the active method in the address of a dynamic attribute. </font><font style="vertical-align: inherit;">In all other respects, the behavior of a dynamic attribute corresponds to all the rules and examples considered earlier and, which is of fundamental importance, ensures unconditional logical consistency of data.</font></font><br><br><a name="p22"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Performance balancing </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of dynamic attributes naturally reduces the amount of stored data, but this is not the meaning of their use. If discard operations are removed from consideration, then in a data model formed only by static attributes, the execution time of a value is orders of magnitude shorter than the atomic transaction execution time, the duration of which also depends on the volume of subsequent dependencies. This imbalance is partially compensated by the quantitative ratio of samples and transactions ‚Äî the samples are usually an order of magnitude larger.</font></font><br><br>                    .   ,          ,        ,   .         ,         . <br><br><a name="p23"></a><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The derived attribute value can be either a single ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atomic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) value or a set of similar values ‚Äã‚Äãin a tuple format, considered as a trivial array ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enumeration</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). It should be noted that the idea of ‚Äã‚Äãan array of values ‚Äã‚Äãas a value of the characteristic of a conceptual entity is present initially, and therefore its use is only a more accurate correspondence of the data model to the target subject domain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The array declaration in the attribute properties, as well as its implementation, also takes the form of a tuple whose elements contain custom names for the array elements. If the tuple of names is not initialized, then this means that the attribute operates on a single value, and is considered </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atomic</font></font></b></i> .      <i><b></b></i> .             ,     .  ,         ,       : ‚Äú1‚Äú  ‚Äú2‚Äú. <br><br>         ,     ,     ‚Äì  <i><b>IDE</b></i> .    ,   ,       ,      : <i>IDC+IDA+IDE+IDS</i> .     <i></i> ,   IDE  .   <i>IDE</i>  0,    <i></i> ,          . <br><br>           .           .    ,      <i><b></b> </i>  .       -    <i>IDE</i> , ‚Äú"     ,          .   ,  ,         . <br><br><a name="p24"></a><h3>   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The list is formed by key-value pairs, while the types of key values ‚Äã‚Äãand the actual values ‚Äã‚Äãare the same for all list items, which is not surprising if we recall the mechanism of their formation in the above examples </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of backlinks list</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Currency</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . {Course}. Nominally, there are no direct restrictions on the use of value types, both as a key and as a value itself, are not imposed. So for the backlink attribute, the value is the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDO</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> handle of the </font><font style="vertical-align: inherit;">class object. From the point of view of logical representation, the list is linear, homogeneous, and ordered in order of increasing key value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All lists are instances of another, not previously mentioned member of the meta-definition level - the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meta-list</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-list</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> owns a complete set of methods for managing the list, and provides: creating a list, inserting and deleting elements, selecting data and obtaining numerical characteristics of the list. Physically, the list is implemented as a B-tree, the root, nodes and leaves of which are instances of a meta-tuple, which in turn are stored in data objects. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the data model level, a meta-list does not create derived instances. Instead, the class attributes are assigned various functionals from the family of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">list functionals</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which actually carry out direct work with lists, using the methods of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meta-list</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">List functionals are defined separately for each pair of key and value types, which allows not only to take into account the specifics of the type, but also to expand the palette of ways to control the values ‚Äã‚Äãin the list.</font></font><br><br><a name="p25"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Typing of values </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The value type system forms a natural hierarchy in which the ancestor type domain includes the value domains of all its descendants. </font><font style="vertical-align: inherit;">In other words, an attribute typed by an ancestor can take any value of a type of heir, leading it to an internal form of representation of its type, if necessary.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4n/p0/vf/4np0vfxh1kmh1v1gxvuu-pit2w8.png"></div><br>   ‚Äì   [ <b>U</b> ].  ‚Äì   ,        :   ,    .       ,        ,     <i>Undefined Type</i>   -. <br><br>    [ <b>L</b> ]    ,      :    ‚Äì <i>true</i> ,     ‚Äì <i>false</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The second case also includes such particulars as zero for a number, and the absence of other literals except a space for a string. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For type </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], the value is a sequence of literals of arbitrary length. In this case, the encoding type (ASCII or UTF) is the same for the entire database, and is set when it is generated. But if necessary, you can create sub-domains (subtypes) for different encodings. On the procedure for storing the values of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">String</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is not affected. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The type </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numeric</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] combines all real numerical values ‚Äã‚Äãconsidered in the decimal system with a floating or fixed decimal point. From it the type </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integer is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selected </font><font style="vertical-align: inherit;">[</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] ‚Äì‚Äì the whole set of positive integers, from which the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Date</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font><font style="vertical-align: inherit;">type is selected </font><font style="vertical-align: inherit;">- integers in the calendar system of calculation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Complex</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] type, also </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">known</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> as the </font><i><font style="vertical-align: inherit;">User Defined Type</font></i><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UDT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ], is an abstract prototype domain that combines a set of user-created complex value types ‚Äî data classes. Domain of class values, includes domains of values ‚Äã‚Äãof all classes generated by inheritance from this class. As a domain value formed by a class, both a data object itself and a pointer to it, the </font><i><font style="vertical-align: inherit;">IDO</font></i><font style="vertical-align: inherit;"> descriptor, can be equally considered as a data object derived from a class.</font></font><i><font style="vertical-align: inherit;"></font></i>  . <br><br>  <i>External</i> [ <b>Ex</b> ]      ,      ,         ,       .   <i>External</i>   ,      ,        .    <i>External</i>   <i><b>Image</b></i> ,              . <br><br><a name="p26"></a><h3>   </h3><br>   <i>Numeric</i> [ <b>N</b> ]  <i>Date</i> [ <b>D</b> ],     (/) .   <i>Numeric</i>        .   <i>Date</i>  ‚Äì      CYMDhms,    ,     . <br><br><a name="p27"></a><h3>   </h3><br>  As already mentioned, the functionality is a predefined method, identified by an <i>IDF</i> handle.  The original set of functionals includes the most primitive, but most frequently used methods of forming values, but this set can be easily extended by adding new functionals to it.  For each type of value, there is a set of natural functionals: <br>  - for <i>Logical</i> - additive (logical OR) and multiplicative (logical AND); <br>  - for <i>String</i> - additive (concatenation); <br>  - for <i>Numeric</i> - additive, multiplicative, minimum, maximum; <br>  - for <i>Integer</i> - additive, multiplicative, minimum, maximum; <br>  - for <i>Date</i> - additive (shift), minimum, maximum; <br>  - for <i>Complex</i> - additive (assignment), Autoset; <br><br>  All listed functionals allow obtaining values ‚Äã‚Äãfrom a variety of sources (connectors).  The role of the functional of assigning values ‚Äã‚Äãfrom a single source by default is played by the additive functional.  For all types, except <i>Logical</i> and <i>External</i> , there are <i>list functionals</i> .  Separately, it is also worth briefly mentioning the <i><b>interval</b> functional</i> , which ensures the formation of interval values, and by means of which both the internal dependencies of the values ‚Äã‚Äãforming the interval and the operations on interval values ‚Äã‚Äãare implemented.  It would be logical to assume that the interval value is complex, and has an enumerated form. <br><br><a name="p28"></a><h3>  List functionals </h3><br>  Each list functionality is a wrapper function that encapsulates a <i>meta-list</i> and uses <i>meta-list</i> methods, the internal implementation of which the functionality overrides for its own goals and objectives.  The entire family of list functionals includes several groups. <br><br>  The functionals that create and modify the list are identified with the actual list, more precisely, its functional type.  In addition to the ‚Äú <i><b>simple</b></i> ‚Äù list, this group includes a ‚Äú <i><b>unique</b></i> ‚Äù list (the list does not allow duplicate key values), as well as its two logical modifications operating with numerical values: a ‚Äú <i><b>totalization</b></i> ‚Äù list (values ‚Äã‚Äãwith the same key are added together) and its subsequent modification - " <i><b>integral</b></i> " (values ‚Äã‚Äãwith the same key are summed with the addition of the value of the preceding element).  These functionals are assigned directly to the attribute as its incoming functionality, thereby making the attribute a <i>list</i> attribute.  Functionals of this group need at least one incoming active connector ‚Äî the source of the key and value ‚Äî to form the actual list. <br><br>  <i>Sample</i> functionals that return a value from the list are always assigned to the outbound connector socket, localized in the list attribute tuple.  Although this also simulates the "postscript" of such a functional to the attribute-recipient.  Actually the <i>key</i> itself is a context (key source), can be declared for any of the basic sockets of this connector. <br><br>  Functionals sampling values ‚Äã‚Äãby key differ in the positioning condition: " <i>equal</i> " (precise positioning), " <i>less</i> " (positioning on a logically preceding element), " <i>greater</i> " (similarly, only the next one), " <i>equal or less</i> " and " <i>equal to or more</i> "(if not exactly then preceding or following).  If there is no element that satisfies the condition, the functional will return the equivalent of the " <i>empty</i> " value.  A subgroup of functionals similar to them instead of a value returns the position of the element ‚Äî its ordinal number in the list.  Another subgroup of functionals (" <i>first / last / N</i> " - " <i>key / value</i> ") returns the requested from the first, last, or specified (N) list items. <br><br><a name="p29"></a><h3>  Software insert </h3><br>  Not all problems can be solved by combining primitive functionals.  To implement complex algorithms, the <i>Script</i> container is provided in the attribute properties, in which you can place an arbitrary script (for example, in Python) as a private functional of a specific attribute instance.  The practice of creating various applications has unexpectedly shown that this tool has to be used quite rarely.  Note that in the script body of a static attribute, it is allowed to use active methods addressed to the class ( <i>Create</i> ) or class attribute ( <i>Set</i> or <i>Update</i> ).  For a dynamic attribute script, only the <i>Get</i> method call is allowed. <br><br><a name="p30"></a><h3>  Attribute functionality </h3><br>  A class attribute is an <i>instance of a <b>meta attribute</b></i> .  The attribute is characterized by a custom name ( <i>Name</i> ), unique within its own class, value type ( <i>Type</i> ), type metric ( <i>Metric</i> ), and the <i>Dynamic</i> flag.  In addition, the attribute owns an <i>IDF</i> functional descriptor, a <i>Script</i> container, and two tuples: array elements ( <i><b>Item</b> list</i> ) and sockets ( <i><b>Socket</b> list</i> ).  In a tuple of a native class, the attribute is identified by an <i>IDA</i> descriptor. <br><br>  In <i>the data model, the</i> attribute performs the function <i><b>of a value factory</b></i> , and from this point of view it is the central actor of the object data management environment.  To perform operations on values, the attribute uses the <i>Set</i> , <i>Get,</i> and <i>Update</i> methods, as well as a set of type-dependent functionals. <br><br>  Attributes connected by connectors form a topology, somewhat resembling the topology of a neural network.  Recall the starting point - the subject area is considered as a system of interacting values.  Accordingly, the ideal hardware platform for such a network looks like a set of independent primitive processors interconnected by serial channels.  In such a hardware environment, you can simulate a variety of processes. <br><br><a name="p60"></a><h3>  Service attributes </h3><br>  Service attributes are permanently present in a tuple of any class where they occupy strictly fixed positions.  These attributes are used by the data model to solve its own problems.  So the <i><b>Del</b></i> and <i><b>Own</b></i> attributes mentioned earlier provide the implementation of a symmetric connection of class objects.  Another, not mentioned earlier, service attribute - <i><b>Type</b></i> , in the class object stores the structural type of the object - the <i><b>IDC</b></i> descriptor of the factory class. <br><br><a name="p31"></a><h3>  Class functionality </h3><br>  A data class is an <i>instance of a <b>metaclass</b></i> regardless of how this instance was obtained.  A class is characterized by a custom name ( <i>Name</i> ), unique in the full set of classes, a visual image ( <i>Image</i> ), and an attribute tuple ( <i><b>Attribute</b> list</i> ).  In the full set of classes, a single class is identified by an <i><b>IDC</b></i> descriptor.  If the class was created by inheriting from another ancestor class, then in the <i>Parent</i> property the class stores the <i>IDC</i> of the ancestor class. <br><br>  In the object management computing environment, the class performs the function of a <i><b>factory of objects</b></i> using the <i>Create</i> meta method of the class.  A class object is created as an instance of a class attribute tuple. <br><br>  Deleting an object is not a class prerogative.  The object is logically deleted by initializing the value of the service attribute <i>Del</i> , which, in order to ensure logical integrity, is automatically present in all external connectors as a <i>lock</i> context.  The initialization of <i>Del</i> entails the de-initialization of all the effective connections of the object, putting the object into an isolated state.  Subsequently, a logically isolated object will be physically deleted by the garbage collector. <br><br><a name="p32"></a><h3>  Class inheritance </h3><br>  A data class can be created not only as an instance of a meta-class, but also by inheriting from another class.  The object of inheritance is the full tuple of attributes of the ancestor class, which is permanently present in the tuple of attributes of the heir class.  This allows an ancestor class to include into its domain all objects, generated by both direct and mediated by its heirs, without exception, regardless of the depth of inheritance.  An inherited tuple is the natural interface to all objects in the ancestor class domain. <br><br>  The mechanism for implementing attribute tuple inheritance is extremely simple: an <a href="https://habrahabr.ru/post/345158/">instance (!) Of</a> ancestor attribute <a href="https://habrahabr.ru/post/345158/">tuple</a> is created in the heir class.  This instance, by definition, contains no values, since there is no need to duplicate the attribute declarations - the required declarations can be obtained by referring to the ancestor class tuple.  A descendant class will generate a complete declaration of an attribute only if it makes its own private changes to it, or if it creates a new attribute of its own.  When a new attribute is created in an ancestor class, then, in advance, the full set of its heirs determines the maximum size of the attribute tuple, after which the created attribute is allocated an element in the ancestor's tuple beyond this size.  Thus, the new attribute of the ancestor automatically becomes available to all his heirs.  The non-initialized elements generated in the tuples can be neglected, since they practically do not take up space. <br><br>  Heir polymorphism is implemented by overriding the rules for obtaining values ‚Äã‚Äãfor inherited attributes, while preserving their type.  At the same time, it is forbidden to change inherited connectors, which, if necessary, should be deactivated and created new ones. <br><br>  Looking ahead, it is worth mentioning that a user data class, being a complex entity, has many forms of its interface (including visual) presentation.  The descendant class fully inherits the ancestor's presentation forms, with the possibility of overriding them.  The natural combination of <i>polymorphism</i> with " <i>polyformism</i> " is a powerful tool for developing an application. <br><br><a name="p33"></a><h3>  Base attribute and class prototypes </h3><br>  In the total mass of class attributes, one can always single out one whose value is used for user identification of a specific object of this class, such as the <i>Name</i> attribute in the <i>Counterparty</i> class.  Such an attribute performs the function of a <i><b>basic</b></i> class <i>attribute</i> . <br><br>  It is logical to assume that it is the base attribute that should automatically be used as a <i>key</i> context for any connector to the list functionality, including lists of backlinks.  For this, the base attribute must have a fixed position in the tuple of any class, namely, it must be placed immediately after the service attributes. <br><br>  Of all existing value types, only two types, <i>String</i> and <i>Date</i> , can be meaningfully assigned to the base attribute when it is created.  These two types of typing predetermine the existence of two prototype classes: <i><b>Named</b> class</i> and <i>Event</i> <i>class</i> , with corresponding basic attributes. <br><br>  It is convenient to use prototype classes as templates when creating custom user classes, which not only seems logical, but also gives a small gain: the class created immediately includes the basic attribute of the desired type with the necessary name. <br><br><a name="p34"></a><h3>  Model Constructor </h3><br>  Already repeatedly checked - you can‚Äôt create a regular program with the mouse.  In the case of using the application / data model, everything is strictly the opposite: textual notation looks like a dull, little informative listing of declarations.  But in the visual environment, the same declarations look natural and very clear: there is a common space displayed in whole or in part connected by class relations, and the transition to the visual space of a class opens up many of its attributes with their connections.  However, the principles of interface presentation and the mechanisms for its implementation are also a topic for a separate article. <br><br>  An executive data model is created and modified through its presentation form ‚Äî an application model.  The editor of this model is a visual designer, operating with images of model entities.  The transition from the user interface of the application to the visual environment of the designer and returning back to the application execution environment while preserving the current state of the interface is performed simultaneously with a hot key.  In this case, all changes made by the designer take effect immediately.  If something is done wrong, it will become immediately obvious: in the form of an erroneous result or lack of response to an interface event, without interrupting the application. <br><br>  The constructor creates new model components as declarative instances of meta-entities, while completely hiding the real descriptors of derived instances.  The initial set of basic meta-entities is small, which makes it easy to control the logical consistency of newly created declarations that already exist in the model by simply excluding the conflicting editor tool or structural component from access. <br><br>  A valid data model is a simple type declaration for an entity-property, which means it can be exported in text format: XML, JSON, or in the form of a sequence of transactions to create its components.  Internal descriptors are not exported to the text view; instead, custom class and attribute names are used. <br><br><a name="p35"></a><h3>  Application area </h3><br>  A data model describes an <i>information</i> <i>system</i> with <i>states</i> .  Accordingly, it cannot be used to implement a driver, for example. <br><br>  Also with its help it is impossible to implement a separate algorithm or subroutine - the data model describes the subject area only as a whole. <br><br>  For performance reasons (due to the lack of appropriate hardware), the data model cannot be used to directly simulate physical processes in real time.  Although there is such potential. <br><br>  Seeming to be senseless attempts to create a universal model of "everything in the world."  An application program always reflects the subject area only from a strictly defined point of view and within certain limits.  And for another point of view, the same subject area may look different. <br><br>  Otherwise, the computing environment based on the data model is designed to solve the same problems that are solved on the basis of all other databases.  But it has some useful properties. <br><br>  Agree, the visual model of the application gives a more visual perception of business logic. <br><br>  Reference symmetry allows you to use all the power of natural navigation methods, both in data and in meta-data. <br><br>  The executive data model that forms the application is only a declaration stored in the database, which is completely independent of the processor architecture or the operating system. <br><br>  The speed of development, algorithmic reliability, strict referential integrity, permanent consistency - all this is a direct consequence of the integration of business logic directly into the logical structure of the database.  And while fundamentally changing the approach to the implementation of the interface of the application, which is subject to a separate detailed consideration. <br><br><a name="p36"></a><h3>  Summary </h3><br>  Nature shows us its infinite variety, obtained by the infinite combination of elements in a very tiny base set (nod towards DNA).  This is her favorite trick. <br><br>  Only four abstract entities form a basis, which is enough to informationally describe any subject area.  Declarative instances of all three meta-entities are sufficient to formalize this description as a data model.  And, in the computational environment of the object representation formed by the six executive methods of meta-entities, the model will behave like a program, giving the desired result. <br><br>  All of the above is just a further development of the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B4%25D0%25B4,_%25D0%25AD%25D0%25B4%25D0%25B3%25D0%25B0%25D1%2580">EFKodd</a> relational model, as well as <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25B9%25D1%2582,_%25D0%259A%25D1%2580%25D0%25B8%25D1%2581%25D1%2582%25D0%25BE%25D1%2584%25D0%25B5%25D1%2580">K.Date's</a> ideas on combining relational and object technologies.  The essence of the relational model remains the same: tables, columns, tables connection.  It just added a fourth element, so natural, but for some reason not mentioned by Codd, the connection of columns in the tables. </div><p>Source: <a href="https://habr.com/ru/post/347856/">https://habr.com/ru/post/347856/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347844/index.html">DCShadow - Active Directory Attack Technique</a></li>
<li><a href="../347846/index.html">The book "Microservices on the .NET platform"</a></li>
<li><a href="../347848/index.html">Blockchain - the future of financial technology?</a></li>
<li><a href="../347852/index.html">Web development experience when making a ‚ÄúMake a Word‚Äù game</a></li>
<li><a href="../347854/index.html">Special projects at Sberbank Technologies: how banks are preparing Hadoop, Spark, Kafka and other Big Data</a></li>
<li><a href="../347858/index.html">Digest news from the world of PostgreSQL. Issue number 2</a></li>
<li><a href="../347864/index.html">Absurdly fast base64 encoding and decoding</a></li>
<li><a href="../347866/index.html">Implicit type conversion in javascript. How many will be! + [] + [] +! []?</a></li>
<li><a href="../347868/index.html">The miner on the site is evil (although it can be good)</a></li>
<li><a href="../347870/index.html">‚ÄúStrashilka‚Äù about GDPR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>