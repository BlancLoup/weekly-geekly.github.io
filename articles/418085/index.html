<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Use of promises in javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Periodically, we publish materials that somehow relate to the use of promises in JavaScript. 

 Here are some of them  Promises in ES6: Patterns and A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Use of promises in javascript</h1><div class="post__text post__text-html js-mediator-article">  Periodically, we publish materials that somehow relate to the use of promises in JavaScript. <br><br><div class="spoiler">  <b class="spoiler_title">Here are some of them</b> <div class="spoiler_text">  <a href="https://habr.com/company/ruvds/blog/339414/">Promises in ES6: Patterns and Anti-Patterns</a> <br>  <a href="https://habr.com/company/ruvds/blog/337662/">JavaScript: Asynchronous Programming Techniques</a> <br>  <a href="https://habr.com/company/ruvds/blog/339770/">Javascript es8 and transition to async / await</a> <br>  <a href="https://habr.com/company/ruvds/blog/326074/">Async / await: 6 reasons to forget about promises</a> <br>  <a href="https://habr.com/company/ruvds/blog/353658/">Escape from hell async / await</a> <br>  <a href="https://habr.com/company/ruvds/blog/354280/">Javascript es6: write less - do more</a> <br>  <a href="https://habr.com/company/ruvds/blog/358808/">Promise guide for those who want to understand them</a> <br>  <a href="https://habr.com/company/ruvds/blog/414373/">Construction of async / await in JavaScript: strengths, pitfalls and features of use</a> </div></div><br>  Why is there so much attention to promises?  We believe that the whole thing is that this technology is very much in demand, and that it is rather difficult to understand. <br><br>  Therefore, if you want to better understand the promises, we offer you a translation of the next article on this topic.  Its author says that he has been developing in Java and PHP for the last 10 years, but all this time he has been looking at JavaScript with interest.  Recently, he decided to get serious about JS and the first interest in his topic were promises. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <a href="https://habr.com/company/ruvds/blog/418085/"><img src="https://habrastorage.org/webt/s3/wz/42/s3wz42iyj1wjzrvjzsx6spduxeu.jpeg"></a> <br><br>  We believe that this material will be interesting to novice developers who feel that, although they use promises, they are not well understood yet.  It is quite possible that the story of someone who looks at JavaScript with a fresh look and seeks to explain to others what he understood himself, apart from the fact that some things are clear to everyone and without explanation, will help beginners in mastering the mechanisms of JavaScript. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Javascript newbie eyes</font> </h2><br>  Anyone who begins to write in JavaScript, can feel what is called, "not at ease".  Some say that JS is a synchronous programming language, others argue that it is asynchronous.  A novice hears about the code that blocks the main thread and the code that does not block it, about design patterns based on events, about the life cycle of events, about the stack of function calls, about the event queue and their surfacing, about polyfills.  He learns that there are such things as Babel, Angular, React, Vue and myriads of other libraries.  If you have just learned in such a ‚Äúnewcomer‚Äù yourself - you should not worry about it.  You are not the first and not the last.  There is even a term for this - the so-called "JavaScript-fatigue" (JavaScript fatigue).  On this occasion <a href="https%253A%252F%252Fhackernoon.com%252Fmedia%252Fe43330e0cc6ed8e61eac8f6d50b0cc35%253FpostId%253D13d99df067c1">,</a> Lucas F Costa aptly <a href="https%253A%252F%252Fhackernoon.com%252Fmedia%252Fe43330e0cc6ed8e61eac8f6d50b0cc35%253FpostId%253D13d99df067c1">said</a> : ‚Äú <i>JavaScript-fatigue is something that can be observed when people use tools that they don‚Äôt need to solve problems that they don‚Äôt have</i> .‚Äù <br><br>  But let's not talk about sad things.  So, JavaScript is a synchronous programming language that, thanks to the mechanism of callbacks, allows you to call functions in the same way as in asynchronous languages. <br><br><h2>  <font color="#3AC1EF">A simple story about promises</font> </h2><br>  The word "promise" is translated as "promise."  Promise objects in programming, which we call ‚Äúpromises,‚Äù are very similar to the usual promises that people make to each other in real life.  So let's first talk about such promises. <br><br>  In Wikipedia, you can find the following <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D0%25B5%25D1%2589%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">definition of the</a> word "promise": "the obligation, the consent of someone to do something, or, conversely, not to do."  In Ozhegov's dictionary, a ‚Äúpromise‚Äù is a ‚Äúvoluntary commitment to do something.‚Äù <br><br>  So what do we know about promises? <br><br><ol><li>  A promise gives you a guarantee that something will be done.  It does not matter who exactly does it: the one who made the promise, or someone else, at the request of the one who made the promise.  A promise gives confidence in something, based on that confidence, the one who received the promise may, for example, make some plans. </li><li>  A promise can be either fulfilled or not. </li><li>  If the promise is fulfilled, then you, as a result, expect something that you will be able to use in the future to carry out any actions or implement some plans. </li><li>  If the promise is unfulfilled, then you will want to know why the one who made it could not fulfill it.  Once you know the cause of the incident and you will have confidence that the promise is not fulfilled, you can think about what to do next, or how to cope with the situation. </li><li>  After you have been promised something, all you have is some kind of guarantee.  You cannot take advantage of what you have been promised immediately.  You can determine for yourself what you need to do if the promise is fulfilled (therefore, you get the promise), and what you need to do if it is broken (in this case, you know the reason for what happened, and therefore you can think of a backup plan of action ). </li><li>  There is a possibility that the person who made the promise will simply disappear.  In such cases, it is useful that the promise be tied to some time frame.  For example, if the one who gave you the promise does not appear in 10 days, we can assume that he has some problems and he has broken the promise.  As a result, even if the one who made the promise fulfills it after 15 days, it will not matter, as you are already acting on an alternative plan, without relying on the promise. </li></ol><br>  Now go to javascript. <br><br><h2>  <font color="#3AC1EF">Javascript promises</font> </h2><br>  I have one rule: doing JavaScript, I always read the <a href="https://developer.mozilla.org/">documentation</a> , which can be found on MDN.  It seems to me that this resource favorably differs from the others with its specificity and clarity of presentation.  Therefore, studying the promises, I got acquainted with the relevant <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">material</a> and experimented with the code in order to get used to the new syntactic constructions. <br><br>  In order to understand the promises, you need to deal with two main things.  The first is the creation of promises.  The second is the processing of the results returned by promises.  Although most of the code we write is aimed at working with promises created, for example, by some libraries, a complete understanding of the mechanisms of work of promises will no doubt be useful.  In addition, for a programmer who already has some experience, knowing how to create promises is just as important as knowing how to work with them. <br><br><h2>  <font color="#3AC1EF">Creating promises</font> </h2><br>  This is how promises are created: <br><br><pre><code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-comment"><span class="hljs-comment">/* executor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ ... } );</code> </pre> <br>  The constructor takes a function that performs certain actions, we called it <code>executor</code> here.  This function takes two parameters, <code>resolve</code> and <code>reject</code> , which, in turn, are also functions.  Promises are usually used to perform asynchronous operations or code that can block the main thread, for example, one that works with files, makes certain API calls, queries database, deals with input / output operations, and so on.  Running such asynchronous operations is performed in the <code>executor</code> function.  If the asynchronous operation completes successfully, then the result expected from promise will be returned by calling the function <code>resolve</code> .  The situation in which this function is called is determined by the creator of the promise.  Similarly, when an error occurs, information about what happened is returned by calling the <code>reject</code> function. <br><br>  Now that we know in general how to create promises, we will create a simple promise in order to better understand everything. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> keepsHisWord; keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; promise1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesnt want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise1);</code> </pre> <br>  This is what this code will output: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e2/f52/7a1/8e2f527a185616e8dbb6fa3433303d54.png"></div><br>  <i><font color="#999999">Promis has state (PromiseStatus) and value (PromiseValue)</font></i> <br><br>  Since our promise is instantly resolved, we cannot explore its initial state.  So let's create a new promise that needs some time to resolve.  The easiest way to do this is by resorting to the <code>setTimeout</code> function. <br><br><pre> <code class="hljs javascript">promise2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   resolve({     <span class="hljs-attr"><span class="hljs-attr">message</span></span>: <span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">code</span></span>: <span class="hljs-string"><span class="hljs-string">"aManKeepsHisWord"</span></span>   }); }, <span class="hljs-number"><span class="hljs-number">10</span></span> * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise2);</code> </pre> <br>  In this code, a promise is created, which will unconditionally be resolved in 10 seconds.  This gives us the opportunity to look at the state of unresolved promise. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd4/828/13d/bd482813d5a8d53df3eb39b716b8c0b7.png"></div><br>  <i><font color="#999999">Unresolved Promise</font></i> <br><br>  After 10 seconds, the promise will be resolved.  As a result, both <code>PromiseStatus</code> and <code>PromiseValue</code> will be updated accordingly.  As you can see, in this example we have changed the function that is called upon successful resolution of the promise, now it returns not an ordinary string, but an object.  This is done in order to demonstrate the ability to return complex functions of data structures using the function <code>resolve</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/ff7/74a/707ff774ad727f4e41a247714182d7fd.png"></div><br>  <i><font color="#999999">Promise allowed after 10 seconds and returning an object</font></i> <br><br>  Let us now look at the promis, which we decided not to allow, but to reject.  To do this, modify the code that was already used in the first example. <br><br><pre> <code class="hljs javascript">keepsHisWord = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; promise3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (keepsHisWord) {   resolve(<span class="hljs-string"><span class="hljs-string">"The man likes to keep his word"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"The man doesn't want to keep his word"</span></span>); } }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(promise3);</code> </pre> <br>  Since we do not handle the situation of discarding promises, an error message will be displayed in the browser console (Google Chrome is used here).  We will talk more about this below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd1/cd1/aa6/bd1cd1aa66cdd5969cb7e8726236938d.png"></div><br>  <i><font color="#999999">Rejected promis</font></i> <br><br>  Now, after analyzing all three examples, we can see that three different values ‚Äã‚Äãcan appear in <code>PromiseStatus</code> : <code>pending</code> (waiting), <code>resolved</code> (successful resolution) and <code>rejected</code> (deviation).  When the promise is created, the value of <code>pending</code> will be in <code>PromiseStatus</code> , and in <code>PromiseValue</code> will be <code>undefined</code> .  These values ‚Äã‚Äãwill be maintained until permission or rejection of promis.  When the promise is <code>resolved</code> or <code>rejected</code> , it is called the <code>settled</code> promise.  Such a promise has moved from the waiting state to the state in which it has either a <code>resolved</code> state or a <code>rejected</code> state. <br><br>  Now, after we learned how to create promises, we can talk about how to handle what they return.  In order to understand this, we need to understand the structure of the object <code>Promise</code> . <br><br><h2>  <font color="#3AC1EF">Promise object</font> </h2><br>  According to the MDN documentation, a <code>Promise</code> object is the result of the successful or unsuccessful completion of an asynchronous operation. <br><br>  The <code>Promise</code> object has static methods and object prototype methods.  Static methods can be called without creating an object instance, and to call prototype methods you need an instance of a <code>Promise</code> object.  Note that both static and normal methods return <code>Promise</code> objects.  It simplifies the work. <br><br><h3>  <font color="#3AC1EF">PromPromise Prototype Methods</font> </h3><br>  We first talk about the methods of the prototype of the object <code>Promise</code> .  There are three such methods.  Do not forget that these methods can be called on an instance of a <code>Promise</code> object, and that they return promises.  Thanks to all these methods, you can designate handlers that respond to changes in the state of promises.  As we have seen, when a promise is created, it is in a <code>pending</code> state.  When promise goes into the <code>resolved</code> or <code>rejected</code> state, at least one of the following methods will be invoked: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.catch</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.then</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFulfilled</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">onRejected</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">Promise</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.prototype</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.finally</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">onFinally</span></span>)</code> </pre> <br>  Below is a diagram of the operation of the promise and events leading to the <code>.catch</code> <code>.then</code> and <code>.catch</code> .  Since these methods return <code>Promise</code> objects, their calls can be chained, this is also reflected in the diagram.  If the promis provides for the use of the <code>.finally</code> method, it will be called when the promise becomes <code>settled</code> , regardless of whether the promise was successfully resolved or rejected. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c01/d3a/9bc/c01d3a9bce02c7b7a0a7373bba117a02.png"><br>  <i><font color="#999999">Promise work pattern (image taken <a href="">from here</a> )</font></i> <br><br>  Here is a little story.  You are a schoolboy and ask your mother to buy you a mobile phone.  She says: "If our savings are more than the cost of the phone, I'll buy it for you."  Now retell this story in JavaScript. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> momsPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ momsSavings = <span class="hljs-number"><span class="hljs-number">20000</span></span>; priceOfPhone = <span class="hljs-number"><span class="hljs-number">60000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (momsSavings &gt; priceOfPhone) {   resolve({     <span class="hljs-attr"><span class="hljs-attr">brand</span></span>: <span class="hljs-string"><span class="hljs-string">"iphone"</span></span>,     <span class="hljs-attr"><span class="hljs-attr">model</span></span>: <span class="hljs-string"><span class="hljs-string">"6s"</span></span>   }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {   reject(<span class="hljs-string"><span class="hljs-string">"We donot have enough savings. Let us save some more money."</span></span>); } }); momsPromise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(value)); }); momsPromise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); }); momsPromise.finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(   <span class="hljs-string"><span class="hljs-string">"Irrespecitve of whether my mom can buy me a phone or not, I still love her"</span></span> ); });</code> </pre> <br>  This is what this code will output: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf0/cc9/be3/cf0cc9be3eff013549852e5a27b47823.png"></div><br>  <i><font color="#999999">Mom did not keep a promise</font></i> <br><br>  If we change the value of the <code>momsSavings</code> variable to 200,000, then mom can buy a gift for her son.  In this case, the above code will output the following. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cf5/393/72a/cf539372a0dce219b10136e4b6280de8.png"></div><br>  <i><font color="#999999">Mom kept her promise</font></i> <br><br>  Now let's imagine that the code in question is designed as a library, and we are using this library.  Let's talk about the effective use of the methods <code>.then</code> and <code>.catch</code> . <br><br>  Since the <code>.then</code> method can be assigned both the <code>onFulfilled</code> handler, called when the promise is successfully resolved, and the <code>onRejected</code> handler, called when the promise is rejected, instead of using both the <code>.then</code> method and the <code>.catch</code> method, we can achieve the same effect with only one method <code>.then</code> .  Here is what it might look like: <br><br><pre> <code class="hljs lua">momsPromise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Hurray I got this phone as a gift "</span></span>, JSON.stringify(value)); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Mom coudn't buy me the phone because "</span></span>, reason); } );</code> </pre> <br>  This is a working example, but in order not to suffer from readability of the code, it is better, instead of one universal <code>.then</code> , to use the methods <code>.then</code> and <code>.catch</code> . <br><br>  In order for these examples to be run in the browser, and specifically, in Google Chrome, I tried to avoid external dependencies.  In order to better understand what we will look at next, let's create a function that returns a promise, the resolution or rejection of which happens randomly.  This will allow us to try out different scenarios for working with promises.  In order to understand the peculiarities of the operation of asynchronous functions, we will set random delays in our promises.  Since we need random numbers, let's create a function that returns a random number between <code>x</code> and <code>y</code> .  This is the function. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getRandomNumber(start = <span class="hljs-number"><span class="hljs-number">1</span></span>, end = <span class="hljs-number"><span class="hljs-number">10</span></span>) { //,      <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseInt(Math.random() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>; }</code> </pre> <br>  Now create a function that returns the promises.  <code>promiseTRRARNOSG</code> call it <code>promiseTRRARNOSG</code> .  The name of this function is decoded as <code>promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator</code> , that is, it is a generator of promises that are randomly allowed or rejected in a random number of seconds.  This function will create a promise that will be allowed or rejected after a random time interval between 2 and 10 seconds.  In order to randomly resolve or reject the promise, we get a random number between 1 and 10. If this number is greater than 5, the promise will be allowed, if not, it is rejected. <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomNumber</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start = 1, end = 10)</span></span></span></span> { //,      start  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt;=<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> &gt; start <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (parseInt(Math.<span class="hljs-built_in"><span class="hljs-built_in">random</span></span>() * <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) % (<span class="hljs-keyword"><span class="hljs-keyword">end</span></span> - start + <span class="hljs-number"><span class="hljs-number">1</span></span>)) + start; } var promiseTRRARNOSG = (promiseThatResolvesRandomlyAfterRandomNumnberOfSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new Promise(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span></span> {   let randomNumberOfSeconds = getRandomNumber(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {     let randomiseResolving = getRandomNumber(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (randomiseResolving &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>) {       resolve({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       reject({         randomNumberOfSeconds: randomNumberOfSeconds,         randomiseResolving: randomiseResolving       });     }   }, randomNumberOfSeconds * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); var testProimse = promiseTRRARNOSG(); testProimse.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); testProimse.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); //             ,    .     ,  - . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { let promise = promiseTRRARNOSG(); promise.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Value when promise is resolved : "</span></span>, value); }); promise.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span></span> {   console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"Reason when promise is rejected : "</span></span>, reason); }); }</code> </pre> <br>  Run this code in the browser console to see how the allowed and rejected promises behave.  Next, we will talk about how you can create a lot of promises and check the results of their implementation using other mechanisms. <br><br><h3>  <font color="#3AC1EF">‚ñçStatic methods of the Promise object</font> </h3><br>  There are four static methods of the <code>Promise</code> object. <br><br>  Here are two methods - <code>Promise.reject(reason)</code> and <code>Promise.resolve(value)</code> , which allow you to create, respectively, rejected and allowed promises. <br><br>  Here's how to work with the <code>Promise.reject</code> method, creating rejected promises. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise3 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.reject(<span class="hljs-string"><span class="hljs-string">"Not interested"</span></span>); promise3.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a rejected promise. The resolved value is "</span></span>, value); }); promise3.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This run as it is a rejected promise. The reason is "</span></span>, reason); });</code> </pre> <br>  Here is an example of using the <code>Promise.resolve</code> method, which creates successfully resolved promises. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will run as it is a resovled promise. The resolved value is "</span></span>, value); }); promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"This will not run as it is a resolved promise"</span></span>, reason); });</code> </pre> <br>  It should be noted that the promise can have several handlers.  For example, based on the previous example, you can get the code shown below. <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promise4 = Promise.resolve(<span class="hljs-number"><span class="hljs-number">1</span></span>); promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will run as it is a resovled promise. The resolved value is ", value); }</span></span></span><span class="hljs-function">);</span></span> promise4.<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will also run as multiple handlers can be added. Printing twice the resolved value which is ", value * 2); }</span></span></span><span class="hljs-function">);</span></span> promise4.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reason)</span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{ console.log("This will not run as it is a resolved promise", reason); }</span></span></span><span class="hljs-function">);</span></span></code> </pre> <br>  This is what it will bring to the browser console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/644/10b/6d3/64410b6d31e57ab7197e6af1453d9b93.png"></div><br>  <i><font color="#999999">Using multiple .then when working with promis</font></i> <br><br>  The following two methods, <code>Promise.all</code> and <code>Promise.race</code> , are designed to work with promise sets.  If, to solve a problem, you need to process several promises, it is most convenient to put these promises in an array and then perform the necessary actions with them.  In order to understand the essence of the methods considered here, we will not be able to use our convenient function <code>promiseTRRARNOSG</code> , since the result of its work depends too much on the will of the case.  It will be more convenient for us to take advantage of something that produces more predictable promises, which will allow us to understand their behavior.  Therefore, we will create two new functions.  One of them ( <code>promiseTRSANSG</code> ) will create promises that are resolved after <code>n</code> seconds, the second ( <code>promiseTRSANSG</code> ) will create promises that are rejected after <code>n</code> seconds. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRSANSG = (promiseThatResolvesAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     resolve({       <span class="hljs-attr"><span class="hljs-attr">resolvedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promiseTRJANSG = (promiseThatRejectsAfterNSecondsGenerator = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> n = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     reject({       <span class="hljs-attr"><span class="hljs-attr">rejectedAfterNSeconds</span></span>: n     });   }, n * <span class="hljs-number"><span class="hljs-number">1000</span></span>); }); });</code> </pre> <br>  Now we will use these functions in order to understand the features of the <code>Promise.all</code> method. <br><br><h3>  <font color="#3AC1EF">Prom Method Promise.all</font> </h3><br>  From the MDN documentation, you can see that the <code>Promise.all(iterable)</code> method returns a promise that will be resolved when all promises that are passed as an <code>iterable</code> argument are <code>iterable</code> , or when this argument does not contain promises.  This promise will be rejected if any of the transmitted promises are rejected. <br>  Consider a few examples. <br><br><h4>  Example ‚Ññ1 </h4><br>  All promises will be allowed here.  This scenario is most common. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  This is what this code will bring to the console: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cfb/36f/112/cfb36f11242338d72c4541e53a8313f2.png"></div><br>  <i><font color="#999999">All promises are allowed.</font></i> <br><br>  After analyzing the results of this example, you can make two important observations. <br><br>  First, the third promise, the resolution of which takes 2 seconds, is completed before the completion of the second, but, as can be seen from the output generated by the code, the order of promises in the array is preserved. <br><br>  Secondly, there is a timer in the code, which is used to find out how long it takes to execute the <code>Promise.all</code> instruction. <br><br>  If the promises were performed sequentially, the execution time of this instruction would be 7 seconds (1 + 4 + 2).  However, the timer tells us that the whole operation took 4 seconds, if we round the result.  This is proof that all promises are executed in parallel. <br><br><h4>  Example # 2 </h4><br>  Now consider the situation when there is no Promise in the array passed to Promise.all.  I suppose such an application of this function is the least likely. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(<span class="hljs-number"><span class="hljs-number">1</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">4</span></span>); promisesArray.push(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason"</span></span>, reason); });</code> </pre> <br>  Here is the output that this code will generate: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24d/20c/e98/24d20ce98e2939d54fb40d7efe40a98d.png"></div><br>  <i><font color="#999999">Calling Promise.all with the transfer to this method of an array that does not contain promises</font></i> <br><br>  Since there are no promises in the array, <code>Promise.all</code> almost instantly resolved. <br><br><h4>  Example number 3 </h4><br>  Now let's take a look at what happens when one of the promises transmitted by <code>Promise.all</code> is rejected. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">1</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handleAllPromises = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.all(promisesArray); handleAllPromises.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"All the promises are resolved"</span></span>, values); }); handleAllPromises.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.All"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"One of the promises failed with the following reason "</span></span>, reason); });</code> </pre> <br>  As can be seen from the results of executing the code shown below, the implementation of <code>Promise.all</code> stops after the first rejected promise with a message that gives this promise. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/b92/a32/87ab92a321b372cd6fe3abeba21f16a2.png"></div><br>  <i><font color="#999999">Execution stops after the first rejected promise.</font></i> <br><br><h3>  <font color="#3AC1EF">Prom Promise.race Method</font> </h3><br>  MDN reports that the <code>Promise.race(iterable)</code> method returns the allowed or rejected promis with the value or cause of the rejection, after one of the transmitted promises is, respectively, allowed or rejected. <br><br>  Consider the examples of working with <code>Promise.race</code> . <br><br><h4>  Example ‚Ññ1 </h4><br>  It shows what happens when one of the promises passed to <code>Promise.race</code> is resolved before anyone else. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">2</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  This is what gets into the console after executing this example. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/010/151/044/0101510448b397d862e2e3a21edb4822.png"></div><br>  <i><font color="#999999">Promise, which was resolved faster than all the others</font></i> <br><br>  All promises are performed in parallel here.  The third promise is allowed in 2 seconds.  Once this happens, the promise returned by <code>Promise.race</code> is resolved. <br><br><h4>  Example 2 </h4><br>  Now consider the situation when one of the promises transmitted by <code>Promise.race</code> is rejected. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.time(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesArray = []; promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">6</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">5</span></span>)); promisesArray.push(promiseTRJANSG(<span class="hljs-number"><span class="hljs-number">3</span></span>)); promisesArray.push(promiseTRSANSG(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promisesRace = <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race(promisesArray); promisesRace.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">values</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fasted promise resolved"</span></span>, values); }); promisesRace.catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">reason</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.timeEnd(<span class="hljs-string"><span class="hljs-string">"Promise.race"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"The fastest promise rejected with the following reason "</span></span>, reason); });</code> </pre> <br>  After executing this example, the console will get the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/063/6fe/351/0636fe351042cfb51428c33db5595b44.png"></div><br>  <i><font color="#999999">Promise rejected before anyone else</font></i> <br><br>  The promises here, as in the previous examples, are performed in parallel.  The fourth promise is rejected after 3 seconds.  Once this happens, the promise returned by <code>Promise.race</code> is rejected. <br><br><h2>  <font color="#3AC1EF">General example and experiments</font> </h2><br>  I collected all the examples that we considered in this material in one place, which will make it more convenient to experiment with them, to explore various scenarios of working with promises.  This code is designed for execution in the browser, so here we do not use any API calls, do not use file operations, and do not work with databases.  Although all this is used in the development of real projects, I believe that working with these mechanisms may distract us from our main goal - promises.  And the use of simple functions, simulating, time delays, gives similar results and does not burden us with additional details. <br><br>  Independently exploring these examples, you can experiment with the code, with the values ‚Äã‚Äãof variables, study different scenarios for using promises.  In particular, you can use a combination of <code>promiseTRJANSG</code> , <code>promiseTRSANSG</code> and <code>promiseTRRARNOSG</code> to simulate a number of promise usage scenarios that will allow you to better understand them.  In addition, note that using the <code>console.time</code> command allows you to figure out the time it takes to execute a certain piece of code, and, for example, find out whether promises are performed in parallel or sequentially.  Here is the <a href="">link</a> to the gist page with the code.  And by the way, if you like, take a look at the <a href="https://github.com/petkaantonov/bluebird/">Bluebird</a> library, which contains some interesting methods for working with promises. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  I offer you a list of rules that I follow when working with promises in order to use them correctly. <br><br><ol><li>  Use promises in situations where you are working with asynchronous or blocking code. </li><li>  To handle the situation of successful resolution of the promise, use the <code>.then</code> method, for those cases when the promise is rejected, use the <code>.catch</code> . </li><li>  Use the <code>.then</code> and <code>.catch</code> in all promises. </li><li>  If you need to do something when resolving and rejecting promise, use the <code>.finally</code> method. </li><li>  ,  ,      ,   . </li><li>       ,     . </li><li>    <code>Promise</code> ,     ,    ,  . </li><li>  <code>Promise.all</code>         ,        . </li></ol><br> ,      ,      ,     . <br><br>  <b>Dear readers!</b> ,       ,     ? <br><br><div class="spoiler"> <b class="spoiler_title">-   ,     </b> <div class="spoiler_text"> -    10%    : <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/webt/qk/au/oy/qkauoyb4porqes9wmm3jofcs3bg.png"></a> <br><br>    :) </div></div></div><p>Source: <a href="https://habr.com/ru/post/418085/">https://habr.com/ru/post/418085/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418075/index.html">TOP 5 things that can be printed on a 3D printer [video]</a></li>
<li><a href="../418077/index.html">Accidents "do not watch the clock": a statistical justification for the mode of technical support 24/7</a></li>
<li><a href="../418079/index.html">The most popular programming languages ‚Äã‚Äã- 2018</a></li>
<li><a href="../418081/index.html">Organization of safe testing in production. Part 1</a></li>
<li><a href="../418083/index.html">Simple server with GraphQL instead of REST, java implementation</a></li>
<li><a href="../418087/index.html">80% of self-checkout counters are at risk</a></li>
<li><a href="../418089/index.html">Overview of SolidCraft CNC Milling Machines</a></li>
<li><a href="../418091/index.html">List of articles and literature about NAS</a></li>
<li><a href="../418093/index.html">MIT course "Computer Systems Security". Lecture 3: "Buffer overflow: exploits and protection", part 2</a></li>
<li><a href="../418095/index.html">About the device built-in testing functionality in Rust (translation)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>