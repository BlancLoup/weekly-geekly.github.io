<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript main loop</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all heard about ajax and node.js. They are firmly established not only in the vocabulary, but also in the toolkit of the web developer. Ajax - asyn...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript main loop</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/48c/e72/eae/48ce72eae915dc06bebe4eaccdf4e7cb.gif" width="150" height="110"><br><br>  We all heard about ajax and node.js.  They are firmly established not only in the vocabulary, but also in the toolkit of the web developer.  Ajax - asynchronous data pulling from server to page, node - asynchronous IO framework.  But how is that asynchrony implemented in such a <em>single-threaded</em> language like Javascript? <br><br>  You, probably, have already guessed from the title, we will discuss the main loop (‚Äúmain loop‚Äù). <br><a name="habracut"></a><br><h4>  As per specification </h4><br>  Let's start from afar.  We say ‚ÄúJavascript‚Äù, we mean ‚ÄúECMAScript‚Äù, we say ‚ÄúES‚Äù, we mean ‚ÄúJS‚Äù (unless, of course, you are working in Mozilla and you are not called Brendan Ayh).  It would be logical to start with the ECMAScript specification. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We open ECMA-262 and see ... that it says nothing at all about what the script should do after it has worked, how to pause or stop it.  This means that it is given to the environment in which it is performed. <br><br><h4>  How it is done in WSH </h4><br>  Perhaps the most simple environment is Windows Script Host, also known as WSH.  Loaded the processor 100%, worked to the end, died - this is such a simple life cycle.  Of the execution control functions, only good old <code>sleep()</code> , which stops the interpreter for n milliseconds. <br><br><pre> <code class="javascript hljs">WScript.echo(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() + <span class="hljs-string"><span class="hljs-string">': Hello world!'</span></span>); WScript.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); WScript.echo(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() + <span class="hljs-string"><span class="hljs-string">': Goodbye, cruel world!'</span></span>);</code> </pre><br>  For simple tasks, this is quite enough, the more difficult tasks can turn into a run with obstacles. <br><br>  Example from the ceiling: the library has a terminal on Windows 98, without a keyboard, but with Internet Explorer 6, which shows a catalog of books in fullscreen.  Young hooligans became obsessed with IE6, and it was not easy for librarians to start it back.  How to be? <br><br>  Create a function to start IE, create a callback with a sly name in the global osprey and launch it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startIE</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ie = WScript.CreateObject(<span class="hljs-string"><span class="hljs-string">"InternetExplorer.Application"</span></span>, <span class="hljs-string"><span class="hljs-string">"ieEvent_"</span></span>); ie.Navigate(<span class="hljs-string"><span class="hljs-string">"http://127.0.0.1/"</span></span>); ie.Visible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ie.FullScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ieEvent_OnQuit = startIE; startIE();</code> </pre><br>  Does not work.  More precisely, it works, IE starts, but the interpreter modifies to the end and silently dies.  We need to send him to eternal sleep.  In the forehead, <code>sleep(Infinity)</code> WSH does not know how, so we make an infinite loop with slips for 60 seconds.  It turns out something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startIE</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ie = WScript.CreateObject(<span class="hljs-string"><span class="hljs-string">"InternetExplorer.Application"</span></span>, <span class="hljs-string"><span class="hljs-string">"ieEvent_"</span></span>); ie.Navigate(<span class="hljs-string"><span class="hljs-string">"http://127.0.0.1/"</span></span>); ie.Visible = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; ie.FullScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ieEvent_OnQuit = startIE; startIE(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>){ WScript.sleep(<span class="hljs-number"><span class="hljs-number">60000</span></span>); }</code> </pre><br>  Here, now it works, the librarians are happy.  Even better than expected - IE restarts immediately, and not after an arbitrary amount of time from 0 to 59 seconds.  It turns out that the ‚Äúevent‚Äù OnQuit interrupts the interpreter‚Äôs sleep.  Moreover, if <code>sleep</code> cut, leaving only the busy loop, the explorer will not even be able to run OnQuit. <br><br>  Well, we got a primitive main loop.  Briefly it can be described as: <br><br><ul><li>  The interpreter does not complete with the completion of the program. </li><li>  The kollbek code can work only when the interpreter does nothing.  At the same time two pieces of code can not work. </li></ul><br><br><h4>  How it is done in browsers </h4><br>  The ‚Äúfulfilled and died‚Äù approach in the browser is not suitable.  Otherwise, how to use JS for its main purpose - to open annoying pop-up windows when you click anywhere?  Browsers <em>(and node.js) have a</em> main loop embedded.  And so deeply that with the looping script, sometimes it is even impossible to use the interface. <br><br>  The principle is simple: there is a queue, and any code that wants to execute becomes into it.  If the queue is not empty, the interpreter bites out the first element from it and executes it.  If the queue is empty, it waits until something hits it. <br><br>  Any such ‚Äúpieces of code‚Äù in the queue can be anything: embedded and linked scripts on the page, interface events ( <code>onclick</code> , <code>onmouseover</code> , ...), timer callbacks ( <code>setTimeout</code> , <code>setInterval</code> ) or browser objects ( <code>xhr.onreadystatechange</code> ).  In a sense, there is no difference between timers and events in browser JS. <br><br>  Well, now in order. <br><br><h5>  alert </h5><br>  Three functions: <code>alert</code> , <code>prompt</code> and <code>confirm</code> - stand apart in all browser-based javascript.  Perhaps you, like me, have become acquainted with JS with one of them.  Anyway, each of them creates a modal window, and the interpreter falls asleep until it is closed.  This is the only way to pause the main loop in the browser (without using a debugger). <br><br>  Previously, in the <code>alert</code> browsers in some background tab could block the entire interface, and Google Chrome still suffers from this.  However, in the modern Internet to meet the use of these functions can not often.  Here you also do not use them. <br><br><h5>  setTimeout, setInterval </h5><br>  In the browser JS there is no <code>sleep</code> function - the interpreter never stops (except for <code>alert</code> and others like it).  But you can postpone the execution of the function "on the spot" with the <code>setTimeout</code> function. <br><br>  The syntax is simple and concise: <code>setTimeout(fn, timeout)</code> .  The <code>fn</code> function will run no earlier than in <code>timeout</code> milliseconds.  Why <em>not earlier</em> , and not <em>exactly through</em> ?  Look under the hood. <br><br>  A call to <code>setTimeout</code> registers a new timer (by the way, its identifier and this function returns when called).  When his time expires, and it turns out that the interpreter is not busy at any time executing any code, the <code>fn</code> function will be called immediately, this is a trivial case. <br><br>  If you are unlucky, and the JS engine will still chew on the pieces of the queue, then you will first have to wait for the queue to be empty.  With all the desire to start a callback "right now" will not work, Javascript is single-threaded!  Then, when the queue is empty, the interpreter runs over all the timers and checks which ones have expired.  Of all the expired timers, the one that was set to a shorter timeout is selected and, if there are several, the one that was set before all is selected.  Now, such a ‚Äúmost expired‚Äù timer generates a new element of the queue for execution, and - voila - the interpreter again has something to do - disassemble the queue that has become non-empty. <br><br>  After the <code>setTimeout</code> timer <code>setTimeout</code> , it is deleted.  That is, <code>setTimeout</code> does not fire twice. <br><br>  Well, and some illustrative code: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'script started'</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'timed out function'</span></span>); }, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endDate = +<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() + <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (+<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() &lt; endDate){ <span class="hljs-comment"><span class="hljs-comment">// busy loop for 10 ms } console.log('script finished');</span></span></code> </pre><br>  The console will display: <br><pre>  script started
 script finished
 timed out function </pre><br>  In that order.  Despite the fact that the timer ended after 5 milliseconds, the engine at that time was processing the super-important task of constantly comparing the date with the reference one.  Therefore, the deferred function had to wait another 5 milliseconds until it was finished.  Here it is.  This is perhaps the most important. <br><br>  You can cancel the timer at any time with the <code>clearTimeout(timeoutId)</code> function.  If the timer has already bummed, then, in general, it is already meaningless to cancel it, but this is not considered a mistake. <br><br>  And if we have time to cancel the timer? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> timeoutId; setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'timed out function'</span></span>); clearTimeout(timeoutId); }, <span class="hljs-number"><span class="hljs-number">5</span></span>); timeoutId = setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'timed out function 2'</span></span>); }, <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endDate = +<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() + <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (+<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() &lt; endDate){ <span class="hljs-comment"><span class="hljs-comment">// busy loop for 10 ms }</span></span></code> </pre><br>  Such cases as in this example happen in practice rarely, but still.  Both timers were set to 5 ms and both had expired when <code>while</code> finished its meaningless and merciless activity.  But the first timer ‚Äúshoots‚Äù first because it was set earlier, although the number of milliseconds of delay was the same for both timers.  And successfully removes the already overdue second timer, not giving him a shot. <br><br>  <code>setInterval</code> differs from <code>setTimeout</code> in that its timer is not deleted after it generates an element for the execution queue.  Instead, its value is reset to its original value.  Thus, you can call a function periodically, without calling <code>setTimeout</code> inside <code>setTimeout</code> . <br><br>  Note that the <code>setInterval</code> timer counter is not reset when the timer is triggered, but only when the main loop queue is empty.  Because with this, he can "slip" over time. <br><br><div class="spoiler">  <b class="spoiler_title">Proof</b> <div class="spoiler_text"><pre> <code class="javascript hljs">setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(+<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endDate = +<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() + <span class="hljs-number"><span class="hljs-number">2000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (+<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() &lt; endDate){ <span class="hljs-comment"><span class="hljs-comment">// busy loop for 2000 ms } }, 1500);</span></span></code> </pre></div></div><br>  The rest is all the same.  Only intervals are canceled by another function, <code>clearInterval</code> . <br><br>  Well, and finally, if <code>setTimeout</code> or <code>setInterval</code> was passed a timeout value less than 4 milliseconds, instead of it uses 4 ms exactly.  For me it was an unpleasant surprise.  But, apparently, it is for the better - an accidentally set interval of 0 milliseconds would quickly and effectively drown out the main loop of any browser.  To execute a function with a truly zero timeout, use <code>setImmediate</code> .  This feature is not yet widely available out of the box, but there are polyfills for it. <br><br><h5>  &lt;script&gt; </h5><br>  All scripts are in the queue of the main loop.  On the one hand, it allows using <code>async</code> and <code>defer</code> .  And on the other hand, and without these attributes, this can lead to unexpected results. <br><br>  What if there are two scripts embedded in the page, and the first one sets the timeout to 4 milliseconds, and then slows down 10 milliseconds.  When will the callback timeout work out - before the second script, or after? <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'script 1'</span></span></span><span class="javascript">); setTimeout(</span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>)</span></span></span><span class="javascript">{ </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'setTimeout from script 1'</span></span></span><span class="javascript">); }, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">5</span></span></span><span class="javascript">); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> endDate = +</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">() + </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">10</span></span></span><span class="javascript">; </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">while</span></span></span><span class="javascript"> (+</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">() &lt; endDate){ </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// busy loop for 10 ms } console.log('script 1 finished'); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'script 2'</span></span></span><span class="javascript">); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></div></div><br>  Firefox, Chrome and IE10 will time out after the second script.  Opera - before the second script. <br><br>  And if the second script is not implemented, inline, and external? <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="html hljs xml"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'script 1'</span></span></span><span class="javascript">); setTimeout(</span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>)</span></span></span><span class="javascript">{ </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">console</span></span></span><span class="javascript">.log(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'setTimeout from script 1'</span></span></span><span class="javascript">); }, </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">5</span></span></span><span class="javascript">); </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> endDate = +</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">() + </span><span class="hljs-number"><span class="javascript"><span class="hljs-number">10</span></span></span><span class="javascript">; </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">while</span></span></span><span class="javascript"> (+</span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Date</span></span></span><span class="javascript">() &lt; endDate){ </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">// busy loop for 10 ms } console.log('script 1 finished'); </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://127.0.0.1/script.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></div></div><br>  And here all browsers <em>are likely</em> to <em>time</em> out before the second script.  What is the use, you ask, of this knowledge, besides academic significance?  To reduce the number of requests, often several scripts are merged into one.  And the resulting script may work differently than the original. <br><br><h5>  Developments </h5><br>  It is worth considering separately UI events and DOM change events ( <code>onDOMNodeInsertedIntoDocument</code> and the like). <br><br>  Events occurring when the DOM tree changes do not fall into the main loop.  Instead, they work out <em>immediately after</em> changing the tree. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.addEventListener(<span class="hljs-string"><span class="hljs-string">'DOMSubtreeModified'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">)</span></span>{ i = <span class="hljs-number"><span class="hljs-number">42</span></span>; }, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'i = '</span></span> + i); <span class="hljs-comment"><span class="hljs-comment">// i = 0; document.body.appendChild(document.createElement('div')) console.log('i = ' + i); // i = 42;</span></span></code> </pre><br>  Striving for such a spontaneous, it would seem, changing the value of a variable in real life is difficult.  But I believe that some particularly tricky jQuery plugin, which actively uses MutationEvent and flows into the global skop, is waiting somewhere in the Internet.  In addition, DOM change events are not recommended for use (deprecated) and very slow down work with the tree, so do not use them. <br><br>  Let's return to mouse-keyboard-tachev events.  Each such event has actions by default.  For example, the default action for a button on a <code>mousedown</code> event is to get a depressed look.  And for links to <code>click</code> - go to the address.  Some default actions can be undone by calling the preventDefault method <code>preventDefault</code> the first argument in the callback function. <br><br>  And that means two things.  First, first the handler, then the default action, and the button will not ‚Äúclick‚Äù until the Javascript handler passes.  Second, the handler will not start until its turn in the main loop comes up.  Thus, massive calculations of the js engine have a very negative effect on what is called responsiveness.  In other words, everything starts to significantly slow down and annoy the user.  It would seem logical not to wait in the queue for an event for which no handler is hung, but in virtually all browsers the button with <code>onclick</code> slows down as well as without it. <br><br>  Browser developers, of course, are trying to do something about it.  Opera, for example, changes the visual representation, without waiting for the handler, which allows a little smooth brakes.  In addition, the page may be affected by a heavy process in the adjacent tab, but this does not apply to Chrome. <br><br>  <em>The sequence ‚Äúfirst handler, then default action‚Äù still follows the canonical case, when the <code>keypress</code> event requires determining the length of the text in the input field, but it turns out that it does not coincide with the real one.</em>  <em>I will leave this task to the reader.</em> <br><br><h4>  Webworks </h4><br>  WebWorkers are a way to unload the main loop, primarily with the goal of getting rid of the "sagging" in the responsiveness of the user interface.  In fact, this is a separate process, with its own main loop, not tied to the interface and the DOM (and not having direct access to them). <br><br>  WebWorker communicates with its ‚Äúmainstream‚Äù process exclusively through messages.  Moreover, when the message from the worker comes to the main process, it becomes - yes - yes - in the same queue as everything else. <br><br>  In general, if you need to generate wav from xm on a client or unpack a multi-megabyte bzip, and the browser supports WebWorkers, use them. <br><br><h4>  How it is done in node.js </h4><br>  This section will be very small, because the node uses a very similar to the browser model.  The same <code>setTimeout</code> and <code>setInterval</code> , and the events of the file system and other IO are similar to browser events, except that the arguments are different. <br><br>  Of the features, the <code>process.nextTick</code> function can be noted, it works like <code>setTimeout(‚Ä¶, 0)</code> , but does not create any timers as superfluous.  The identifier in the node.js timer is not an integer, as in browsers, but an object.  Well, the node completely ignores the limit of 4 milliseconds. <br><br><h4>  Instead of conclusion </h4><br>  Summarizing all the above: understand how the main cycle works and try not to delay it for a long time. <br><br>  For further reading / viewing: <br><ul><li>  <a href="http://www.w3.org/TR/html5/webappapis.html">W3C Specification</a> </li><li>  <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html">Draft WHATWG</a> </li><li>  <a href="http://learn.javascript.ru/settimeout-setinterval">setTimeout and setInterval on javascript.ru</a> </li><li>  <a href="http://www.yuiblog.com/blog/2010/08/30/yui-theater-douglas-crockford-crockford-on-javascript-scene-6-loopage-52-min/">Lecture by Douglas Crockford</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/178261/">https://habr.com/ru/post/178261/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../178251/index.html">Windows Azure Update: point-to-site connectivity and other improvements to virtual machines and networks, cloud services, and the release of the Ruby SDK</a></li>
<li><a href="../178253/index.html">Shkolnik about Olympiad programming</a></li>
<li><a href="../178255/index.html">Several rules for creating outstanding products</a></li>
<li><a href="../178257/index.html">Pascal, Delphi and Oberon today</a></li>
<li><a href="../178259/index.html">"What if", Event Sourcing</a></li>
<li><a href="../178265/index.html">Something about using this</a></li>
<li><a href="../178267/index.html">We are preparing an adaptive video for HTTP Live Streaming</a></li>
<li><a href="../178269/index.html">How we organized the Ural rehearsal of ACM ICPC WORLD FINALS</a></li>
<li><a href="../178271/index.html">The era of octal numbers ends with a leading zero in JavaScript</a></li>
<li><a href="../178273/index.html">How to release a great iOS application that someone needs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>