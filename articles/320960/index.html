<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CEF, ES6, Angular 2, TypeScript using .Net Core classes. Creating a cross-platform GUI for .Net using CEF</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everyone asks me - "Why is this necessary?". To which, I proudly reply - ‚ÄúI use 1C to access the trading equipment, Web services via ws-protocols, rea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CEF, ES6, Angular 2, TypeScript using .Net Core classes. Creating a cross-platform GUI for .Net using CEF</h1><div class="post__text post__text-html js-mediator-article">  Everyone asks me - "Why is this necessary?".  To which, I proudly reply - ‚ÄúI use 1C to access the trading equipment, Web services via ws-protocols, ready-made components.  <a href="https://habrahabr.ru/post/308216/">1C, Linux, Excel, Word, OpenXML, ADO and Net Core</a> .  In addition, I will make the transfer of JS objects to the .Net side using DynamicObject. <br><br>  You can make a specific <a href="">CEF</a> configuration for all platforms and you can make cross-platform dextup applications.  As an analogue of Electron.  .Net Core develops and you can quite easily transfer applications under WPF and UWP to Angular 2 by making a description of the classes and using IntelliSense when encoding to TypeScript. <br><br>  But I understand perfectly well that these are just lofty words, and very few people need it.  But I'm damn interested, especially after programming on 1C. <br><a name="habracut"></a><br>  To show the possibilities, take an example from my article <a href="https://habrahabr.ru/post/307188/">Cross-Platform Using .Net Classes in 1C via Native VK.</a>  <a href="https://habrahabr.ru/post/307188/">Or replacing COM with Linux II</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It has a lot of sugar and shows all the problems.  Immediately I apologize for Ruslish.  I try very hard, but I have a lot of examples on it, and there is very little time. <br><br><pre><code class="cs"> //  
    //IConfiguration WithDefaultLoader(this IConfiguration configuration, Action&lt;LoaderSetup&gt; setup = null, IEnumerable&lt;IRequester&gt; requesters = null);
    var config = Configuration.Default.WithDefaultLoader();
    //    
    var address = "https://en.wikipedia.org/wiki/List_of_The_Big_Bang_Theory_episodes";
    //     
 
    // 
    //Task&lt;IDocument&gt; OpenAsync(this IBrowsingContext context, string address);
    var document = BrowsingContext.New(config).OpenAsync(address).Result;
    //  CSS         
    var rowSelector = "tr.vevent";
    var  = document.QuerySelectorAll&lt;IHtmlTableRowElement&gt;(rowSelector);
    foreach (var str in )
</code></pre><br>
 TypeScript   :<br>
<br>
<pre><code>            let Net = NetObject.NetWrapper;
            let $$ = NetObject.FlagDeleteObject; //         

            //   AngleSharp
            let AngleSharp = Net.("AngleSharp");
            //     
            let Configuration = AngleSharp.GetType("AngleSharp.Configuration");
            let BrowsingContext = AngleSharp.GetType("AngleSharp.BrowsingContext");
            let HtmlParser = AngleSharp.GetType("AngleSharp.Parser.Html.HtmlParser");
            let IHtmlTableRowElement = AngleSharp.GetType("AngleSharp.Dom.Html.IHtmlTableRowElement");
            let ApiExtensions = AngleSharp.GetType("AngleSharp.Extensions.ApiExtensions");

            let Default = Configuration._Default;
            var config = Default.WithDefaultLoader();
            //    
            var address = "https://en.wikipedia.org/wiki/List_of_The_Big_Bang_Theory_episodes";
            //     

            let Context = BrowsingContext.New(config);

            // 
            //Task&lt;IDocument&gt; OpenAsync(this IBrowsingContext context, string address);
            let document = await Context.async.OpenAsync(address);
            //        Proxy  Target fuction
            //      
            document = NetObject.WrapResult(document, true);

            //  CSS         
            let rowSelector = "tr.vevent";

            //          
            //let rows = document.QuerySelectorAll([IHtmlTableRowElement], rowSelector);
           
            //    
            //IEnumerable &lt; TElement &gt; QuerySelectorAll&lt;TElement&gt;(this IParentNode parent, string selectors) where TElement : IElement;
             let rows = ApiExtensions.QuerySelectorAll([IHtmlTableRowElement], document, rowSelector);
         
            //    ,     
            //let rows = document.QuerySelectorAll(rowSelector);

//      
            for (let row of rows) {
                let Cells = row._Cells;
                let i = 0;
                let  = new ();
                this.ResultParse.push();
//       
                for (let Cell of Cells) {
 //    ,      
                    if (i &lt; 8)                        {
                    [this.Colums[i]] = Cell._TextContent;
                    Cell($$); //      
                    i++;
                    }
                }
                Cells($$);
                row($$);
            }
            rows($$);

            //    
            NetObject.DeleteNetObjets(AngleSharp, Configuration, BrowsingContext, HtmlParser, IHtmlTableRowElement, ApiExtensions, Default, config, Context, document); 
            alert("    "+Net.());</code></pre><br>
      C#.      "_"<br>
<br>
<pre><code>let Default = Configuration._Default;</code></pre><br>
        <b>async</b>:<br>
<br>
<pre><code>let document = await Context.async.OpenAsync(address);</code></pre><br>
   ,           :<br>
<br>
<pre><code>let rows = ApiExtensions.QuerySelectorAll([IHtmlTableRowElement], document, rowSelector);</code></pre><br>
   ,         .Net<br>
<br>
<pre><code>Cells(NetObject.FlagDeleteObject);</code></pre>    <pre><code>Cells($$);</code></pre><br>
     Intel Core i3-2120 CPU 3.3 GHz.<br>
<br>
<blockquote>   Proxy 60   <br>
    Proxy 45k   <br>
   160k   </blockquote><br>
  -  .<br>
<br>
   .<br>
<br>
<pre><code class="cs"> public class 
    {
       public string  { get; set; }
       public  (string )
            {
            this. = ;
            }
 public object ExpandoObject()
        {

            dynamic res = new ExpandoObject();
            res. = " ExpandoObject";
            res. = 456;
            res. = (Func&lt;string&gt;)(() =&gt; res.);
            res. = (Func&lt;int, int, int&gt;)((x, y) =&gt; x + y);

            return res;
        }
     }</code></pre><br>
 TypeScript   :<br>
<br>
<pre><code>//        
let  = Net.GetType("TestDllForCoreClr.", "TestDllForCoreClr");
//    new
let TO = new ("  ");
//  ExpandoObject
var EO = TO.ExpandoObject();
let =EO._;//   _
let =EO._;
let  = EO._;
let res= ());//   
 //  ExpandoObject    
 res= EO.());//  ExpandoObject
</code></pre><br>
     . <a href="https://habrahabr.ru/post/304482/">   .Net   .   IDispatch  Linux</a>.  <a href="">CEF </a>   :<br>
<br>
<pre><code>   declare var window: WindowInterface;
    export interface WindowInterface {
    CallNetMethod(Id: number, MethodName: string, args?: any[]): any;//  
    CallNetDelegate(Id: number, args?: any[]): any; //  
    CallNetPropertySet(Id: number, PropertyName: string, value: any): void; //  
    CallNetPropertyGet(Id: number, PropertyName: string): any; //   
    DeleteNetObject(Id: number): void; //       .Net
    //     Task  Task&lt;T&gt;
    CallAsyncNetObjectFunction(Id: number, MethodName: string, TaskId: string, args?: any[]): any; 
    //     CEF,    Promise 
    RegisterCallBacks(SetAsyncResult: (Successfully: boolean, TaskId: string, result: any) =&gt; void): void; 
    //       
    CallNetObjectGenericFunction(Id: number, MethodName: string, types: any[], args?: any[]): any;
    //   IEnumerator MoveNext   .Net
    IteratorNext(Id: number): any;
}</code></pre><br>
         Target  :<br>
<br>
<pre><code>export interface NetObjectinterface {
    (): void;
    Id: number;
    isNetObject: boolean;
    IsAsyncCall?: boolean;
    CallAsProp(target: NetObject, name: any): ResultCallAsProp;
    Execute: (target: NetObject, name: any, args: any[]) =&gt; any;

}</code></pre><br>
Target       new  ().    Handler:<br>
<br>
<pre><code>export var NetObjectHandler: ProxyHandler&lt;NetObjectinterface&gt; = {
    get: (target, name: any) =&gt; {
//   PropertyGet      
//         "_"

        let res = target.CallAsProp(target, name);
        if (res.Successfully)
            return res.result;

        return (...args: any[]) =&gt; {
            return target.Execute(target, name, args);
        }

    },
    set: function (target, prop, value, receiver) {
        return NetObject.SetPropertyValue(target, prop, value, receiver);
    },

    apply: (target, that, args) =&gt; {
        if (args.length == 1) {
            var param = args[0];
            if (param === NetObject.FlagGetObject)
                return target;
            else if (param === NetObject.FlagDeleteObject) {
                window.DeleteNetObject(target.Id);
                return undefined;
            }
        }

        NetObject.SetArgs(args);
        let res = window.CallNetDelegate(target.Id, args)
        return NetObject.WrapResult(res, true);
    },

    construct: (target, argumentsList, newTarget) =&gt; {
//     Net 
// object (object , params object[] argOrig)
        NetObject.SetArgs(argumentsList);
        argumentsList.unshift(target);
        let res = window.CallNetMethod(0, "", argumentsList);
        return NetObject.WrapResult(res, true);

    }
}</code></pre><br>
    Target: <br>
<br>
<pre><code>function getNetObject(id: number): NetObjectinterface {
    let netObject = &lt;NetObjectinterface&gt;function (start: number) { };
    netObject.Id = id;
    netObject.isNetObject = true;
    netObject[NetObject.isNetclass] = true;
    netObject.Execute = NetObject.Execute;
    netObject.CallAsProp = NetObject.CallAsProp;
    return netObject;
}</code></pre><br>
    CEF :<br>
<br>
<pre><code>static WrapResult(value: any, ReturnProxy: boolean = false): any {
        if (typeof value == "object") {
            if ("IsNetObject" in value) {
                let res = getNetObject(value.Id);
                if (ReturnProxy)
                    return new Proxy(res, NetObjectHandler);
                else
                    return res

            }


        }
        return value;
    }</code></pre><br>
          :<br>
<br>
<pre><code>static GetPromise(Target: NetObjectinterface, name: any, args: any[]) {

        let key = window.CallNetMethod(0, "GetUniqueString");
        let promise = new Promise((resolve, reject) =&gt; {
            NetObject.PromiseDictioanary.set(key, { resolve: resolve, reject: reject });
            window.CallAsyncNetObjectFunction(Target.Id, name, key, args);
        });
        return promise;
    }</code></pre><br>
     :<br>
<br>
<pre><code> static SetPromiseResult(Successfully: boolean, TaskId: string, result: any) {
        let item = NetObject.PromiseDictioanary.get(TaskId);
        try {

            NetObject.PromiseDictioanary.delete(TaskId);
           //       Proxy  Target function
            //  result = NetObject.WrapResult(result, true);
           //   "  then"
            if (Successfully)
                item.resolve(result);
            else
                item.reject(result);
        }

        catch (e) {
            item.reject("    " + e);
            alert("    " + e);
        }
    }</code></pre><br>
:<br>
<br>
<pre><code> static PromiseDictioanary = new Map();</code></pre><br>
      :<br>
<br>
<div class="spoiler"><b class="spoiler_title">  NetProxy</b><div class="spoiler_text"><pre><code>declare var window: WindowInterface;
declare var $_: Symbol;
declare var _$: Symbol;

export interface WindowInterface {
    CallNetMethod(Id: number, MethodName: string, args?: any[]): any;//  
    CallNetDelegate(Id: number, args?: any[]): any; //  
    CallNetPropertySet(Id: number, PropertyName: string, value: any): void; //  
    CallNetPropertyGet(Id: number, PropertyName: string): any; //   
    DeleteNetObject(Id: number): void; //       .Net
    //     Task  Task&lt;T&gt;
    CallAsyncNetObjectFunction(Id: number, MethodName: string, TaskId: string, args?: any[]): any; 
    //     CEF,    Promise 
    RegisterCallBacks(SetAsyncResult: (Successfully: boolean, TaskId: string, result: any) =&gt; void): void; 
    //       
    CallNetObjectGenericFunction(Id: number, MethodName: string, types: any[], args?: any[]): any;
    //   IEnumerator MoveNext   .Net
    IteratorNext(Id: number): any;
}

class ResultCallAsProp {
    constructor(public Successfully: boolean, public result?: any) { };
}
export interface NetObjectinterface {
    (): void;
    Id: number;
    isNetObject: boolean;
    IsAsyncCall?: boolean;
    CallAsProp(target: NetObject, name: any): ResultCallAsProp;
    Execute: (target: NetObject, name: any, args: any[]) =&gt; any;

}

export var NetObjectHandler: ProxyHandler&lt;NetObjectinterface&gt; = {
    get: (target, name: any) =&gt; {


        let res = target.CallAsProp(target, name);
        if (res.Successfully)
            return res.result;

        return (...args: any[]) =&gt; {
            return target.Execute(target, name, args);
        }


    },
    set: function (target, prop, value, receiver) {
        return NetObject.SetPropertyValue(target, prop, value, receiver);
    },

    apply: (target, that, args) =&gt; {
        if (args.length == 1) {
            var param = args[0];
            if (param === NetObject.FlagGetObject)
                return target;
            else if (param === NetObject.FlagDeleteObject) {
                window.DeleteNetObject(target.Id);
                return undefined;
            }
        }

        NetObject.SetArgs(args);
        let res = window.CallNetDelegate(target.Id, args)
        return NetObject.WrapResult(res, true);
    },

    construct: (target, argumentsList, newTarget) =&gt; {

        //  var res = NetObject.GetNetObject(5);
        //  return new Proxy(res, NetObjectHandler)
        NetObject.SetArgs(argumentsList);
        argumentsList.unshift(target);
        let res = window.CallNetMethod(0, "", argumentsList);
        return NetObject.WrapResult(res, true);

    }


}

function getNetObject(id: number): NetObjectinterface {
    let netObject = &lt;NetObjectinterface&gt;function (start: number) { };
    netObject.Id = id;
    netObject.isNetObject = true;
    netObject[NetObject.isNetclass] = true;
    netObject.Execute = NetObject.Execute;
    netObject.CallAsProp = NetObject.CallAsProp;
    return netObject;
}

function GetNetProxy(): any {
    let res = getNetObject(0);
    if (NetObject.FlagFirstLoad) {
        try {
            window.RegisterCallBacks(NetObject.SetPromiseResult);

        }
        catch (e) {
            // alert(" " + e);
        }

        NetObject.FlagFirstLoad = false;
    }

    return new Proxy(res, NetObjectHandler);

}
export class NetObject {
    static GetNetObject(id: number) { return getNetObject(id); }
    static isNetclass = Symbol();
    static IsAsyncCall = Symbol();
    static FlagGetObject = Symbol();
    static FlagDeleteObject = Symbol();
    static FlagFirstLoad = true;
    static NetWrapper = GetNetProxy();

    static PromiseDictioanary = new Map();
    static GetIterator(target: NetObjectinterface): any {
        return function () {
            let IdIterator = window.CallNetMethod(0, "GetIterator", [target]).Id;

            return {
                next: function () {

                    let value = window.IteratorNext(IdIterator);
                    if (value === undefined) {
                        return { value: undefined, done: true };

                    } else
                        return { value: NetObject.WrapResult(value, true), done: false }

                }
            }


        }
    }


    static WrapResult(value: any, ReturnProxy: boolean = false): any {
        if (typeof value == "object") {
            if ("IsNetObject" in value) {
                let res = getNetObject(value.Id);
                if (ReturnProxy)
                    return new Proxy(res, NetObjectHandler);
                else
                    return res

            }


        }
        return value;
    }

    static WrapObject(value: any): any {
        if (typeof value == "function") {
            if (NetObject.isNetclass in value)
                return new Proxy(value, NetObjectHandler);
        }
    }

    static GetPropertyValue(target: NetObjectinterface, name: any): any {
        let res = window.CallNetPropertyGet(target.Id, name);
        return NetObject.WrapResult(res, true);

    }

    static SetPropertyValue(target: NetObjectinterface, prop: any, value: any, receiver: any): any {
        let res = window.CallNetPropertySet(target.Id, prop, NetObject.GetTarget(value));
        return true;

    }

    static CallAsProp(Target: NetObjectinterface, name: any): ResultCallAsProp {
        if (name === Symbol.iterator) {
            return new ResultCallAsProp(true, NetObject.GetIterator(Target));
        }

        if (name === Symbol.toPrimitive) {
            return new ResultCallAsProp(true, () =&gt; { return `Id= ${Target.Id}, isNetObject= ${Target.isNetObject}` });
        }
        if (name.startsWith('_')) {

            return new ResultCallAsProp(true, NetObject.GetPropertyValue(Target, name.substring(1)));

        }

        if (name === "async") {

            let res = getNetObject(Target.Id);

            res.Execute = NetObject.ExecuteAsync;
            res.CallAsProp = NetObject.CallAsPropAsync;
            return new ResultCallAsProp(true, new Proxy(res, NetObjectHandler));
        }

        return new ResultCallAsProp(false);
    }

    static CallAsPropAsync(Target: NetObjectinterface, name: any): ResultCallAsProp {


        return new ResultCallAsProp(false);
    }

    static GetPromise(Target: NetObjectinterface, name: any, args: any[]) {

        let key = window.CallNetMethod(0, "GetUniqueString");
        let promise = new Promise((resolve, reject) =&gt; {
            NetObject.PromiseDictioanary.set(key, { resolve: resolve, reject: reject });
            window.CallAsyncNetObjectFunction(Target.Id, name, key, args);
        });
        return promise;
    }

    static GetTarget(obj: any): any {
        if (typeof obj == "function") {
            if (NetObject.isNetclass in obj)
                return obj(NetObject.FlagGetObject);


        }
        return obj;
    }

    static SetArgs(args: any[]) {
        for (let i in args) {
            let obj = args[i];
            if (typeof obj == "function") {
                if (NetObject.isNetclass in obj)
                    args[i] = obj(NetObject.FlagGetObject);


            }

        }
    }


    static SetPromiseResult(Successfully: boolean, TaskId: string, result: any) {
        let item = NetObject.PromiseDictioanary.get(TaskId);
        try {

            NetObject.PromiseDictioanary.delete(TaskId);
            //  result = NetObject.WrapResult(result, true);
            if (Successfully)
                item.resolve(result);
            else
                item.reject(result);
        }

        catch (e) {
            item.reject("    " + e);
            alert("    " + e);
        }
    }

    static CheckGenericMethod(args: any[]): any {

        var argsCount = args.length;

        if (argsCount &gt; 0 &amp;&amp; args[0] instanceof Array) {
            var types = args[0].slice();
            NetObject.SetArgs(types);

            var args2 = args.slice(1);
            NetObject.SetArgs(args2);
            return { IsGeneric: true, types: types, args: args2 }
        }

        return { IsGeneric: false };

    }
    static Execute(Target: NetObjectinterface, name: any, args: any[]) {

        let res = undefined;
        let chek = NetObject.CheckGenericMethod(args);

        if (chek.IsGeneric) {
            res = window.CallNetObjectGenericFunction(Target.Id, name, chek.types, chek.args);

        }
        else {
            NetObject.SetArgs(args);

            res = window.CallNetMethod(Target.Id, name, args);
        }

        return NetObject.WrapResult(res, true);
    }

    static ExecuteAsync(Target: NetObjectinterface, name: any, args: any[]) {


        let res = undefined;
        let chek = NetObject.CheckGenericMethod(args);

        if (chek.IsGeneric) {
            let Target0 = getNetObject(0);
            let task = window.CallNetObjectGenericFunction(Target.Id, name, chek.types, chek.args);
            res = NetObject.GetPromise(Target0, "ReturnParam", [getNetObject(task.Id)]);
            window.DeleteNetObject(task.Id);

        }
        else {
            NetObject.SetArgs(args);

            res = NetObject.GetPromise(Target, name, args);
        }

        return res;
    }

    static New(Target: NetObjectinterface, name: any, args: any[]): any {
        NetObject.SetArgs(args);
        var res = window.CallNetMethod(0, "", args);
        return NetObject.WrapResult(res, true);
    }

    static DeleteNetObjets(...args: any[]) {

        for (let item of args)
            item(NetObject.FlagDeleteObject);
    }


}</code></pre><br>
</div></div><br>
     ++. ,    ,      .<br>
   Dev Tools  CefSimple:<br>
<br>
<div class="spoiler"><b class="spoiler_title"> CEF     JS  .Net Core</b><div class="spoiler_text"><pre><code class="cpp">#include "include/CEF_V8.H"
#include "ManagedDomainLoader.h"
#include "CefV8HandlersForNet.h"

#include "types.h"
#include "NetConverter.h"


#include "include/base/cef_bind.h"
#include "include/wrapper/cef_closure_task.h"
#include &lt;thread&gt;
#include "include/base/cef_platform_thread.h"
namespace NetObjectToNative{

	BaseClassForNetHandlers::BaseClassForNetHandlers(ManagedDomainLoader* mD)
	{
		this-&gt;mD = mD;
	}

	 bool CallNetObjectFunction::Execute(const CefString&amp; name,
		CefRefPtr&lt;CefV8Value&gt; object,
		const CefV8ValueList&amp; arguments,
		CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		CefString&amp; exception)  {


		const size_t argumentsCount = arguments.size();
		vector&lt;wstring&gt; savedstrings;
		NetObjectToNative::tVariant* Params = nullptr;

		int Target = arguments[0]-&gt;GetIntValue();
		wstring MethodMame = arguments[1]-&gt;GetStringValue().ToWString();

		CefRefPtr&lt;CefV8Value&gt; params;

		size_t  argCount = 0;
		if (argumentsCount == 3)
		{


			params = arguments[2];

			if (!params-&gt;IsArray())
			{
				exception = CefString(L"   3    ");
				return true;

			}
			argCount = params-&gt;GetArrayLength();


		}

		if (argCount &gt; 0)
		{
			savedstrings.reserve(argCount);
			Params = new NetObjectToNative::tVariant[argumentsCount];
			NetObjectToNative::tVariant* Param = Params;

			for (size_t i = 0; i &lt; argCount; ++i)
			{

				NetObjectToNative::ConvertCEFtoNet(params-&gt;GetValue(i), &amp;Param[i], savedstrings);
			}

		}
		wchar_t*  Error = nullptr;
		NetObjectToNative::tVariant RetVal;

		bool res = mD-&gt;pCallAsFunc(Target, MethodMame.c_str(), &amp;RetVal, Params, argCount, &amp;Error);

		if (res)
		{

			retval = NetObjectToNative::ConvertNetToCef(&amp;RetVal, true);
		}
		else
		{
			if (Error)
				exception = CefString(std::wstring(Error));
			delete Error;
		}

		if (Params) delete[] Params;

		return true;
	}

	 //====================== ============================================
	 bool CallAsyncNetObjectFunction::Execute(const CefString&amp; name,
		 CefRefPtr&lt;CefV8Value&gt; object,
		 const CefV8ValueList&amp; arguments,
		 CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		 CefString&amp; exception) {


		 const size_t argumentsCount = arguments.size();
		 vector&lt;wstring&gt; savedstrings;
		 NetObjectToNative::tVariant* Params = nullptr;

		 int Target = arguments[0]-&gt;GetIntValue();
		 wstring MethodMame = arguments[1]-&gt;GetStringValue().ToWString();
		 wstring TaskId = arguments[2]-&gt;GetStringValue().ToWString();

		 CefRefPtr&lt;CefV8Value&gt; params;

		 size_t  argCount = 0;
		 if (argumentsCount == 4)
		 {


			 params = arguments[3];

			 if (!params-&gt;IsArray())
			 {
				 exception = CefString(L"    4    ");
				 return true;

			 }
			 argCount = params-&gt;GetArrayLength();


		 }

		 if (argCount &gt; 0)
		 {
			 savedstrings.reserve(argCount);
			 Params = new NetObjectToNative::tVariant[argumentsCount];
			 NetObjectToNative::tVariant* Param = Params;

			 for (size_t i = 0; i &lt; argCount; ++i)
			 {

				 NetObjectToNative::ConvertCEFtoNet(params-&gt;GetValue(i), &amp;Param[i], savedstrings);
			 }

		 }
		 wchar_t*  Error = nullptr;
		 NetObjectToNative::tVariant RetVal;

		 //bool res = mD-&gt;pCallAsFunc(Target, MethodMame.c_str(), &amp;RetVal, Params, argCount, &amp;Error);
		 bool res = mD-&gt;pCallAsyncFunc(Target, MethodMame.c_str(), this-&gt;cfn, TaskId.c_str(), Params, argCount, &amp;Error);

		 if (res)
		 {

			 retval = NetObjectToNative::ConvertNetToCef(&amp;RetVal, true);
		 }
		 else
		 {
			 if (Error)
				 exception = CefString(std::wstring(Error));
			 delete Error;
		 }

		 if (Params) delete[] Params;

		 return true;
	 }

	//============================ Call Generic Function

	 bool CallNetObjectGenericFunction::Execute(const CefString&amp; name,
		 CefRefPtr&lt;CefV8Value&gt; object,
		 const CefV8ValueList&amp; arguments,
		 CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		 CefString&amp; exception) {


		 const size_t argumentsCount = arguments.size();
		 vector&lt;wstring&gt; savedstrings;
		 NetObjectToNative::tVariant* Params = nullptr;
		 NetObjectToNative::tVariant* ParamsTypes = nullptr;

		 int Target = arguments[0]-&gt;GetIntValue();
		 wstring MethodMame = arguments[1]-&gt;GetStringValue().ToWString();

		 CefRefPtr&lt;CefV8Value&gt; params;
		 CefRefPtr&lt;CefV8Value&gt; types= arguments[2];
		 size_t  typesCount= types-&gt;GetArrayLength();


		 size_t  argCount = 0;
		 if (argumentsCount == 4)
		 {


			 params = arguments[3];

			 if (!params-&gt;IsArray())
			 {
				 exception = CefString(L"   4    ");
				 return true;

			 }
			 argCount = params-&gt;GetArrayLength();


		 }

		 
		 savedstrings.reserve(argCount+ typesCount);
		 ParamsTypes = new NetObjectToNative::tVariant[typesCount];
		 for (size_t i = 0; i &lt; typesCount; ++i)
		 {

			 NetObjectToNative::ConvertCEFtoNet(types-&gt;GetValue(i), &amp;ParamsTypes[i], savedstrings);
		 }


		 if (argCount &gt; 0)
		 {
			
			 Params = new NetObjectToNative::tVariant[argumentsCount];
			 NetObjectToNative::tVariant* Param = Params;

			 for (size_t i = 0; i &lt; argCount; ++i)
			 {

				 NetObjectToNative::ConvertCEFtoNet(params-&gt;GetValue(i), &amp;Param[i], savedstrings);
			 }

		 }



		 wchar_t*  Error = nullptr;
		 NetObjectToNative::tVariant RetVal;

		 bool res = mD-&gt;pCallAsGenericFunc(Target, MethodMame.c_str(), &amp;RetVal, ParamsTypes, typesCount, Params, argCount, &amp;Error);

		 if (res)
		 {

			 retval = NetObjectToNative::ConvertNetToCef(&amp;RetVal, true);
		 }
		 else
		 {
			 if (Error)
				 exception = CefString(std::wstring(Error));
			 delete Error;
		 }

		 if (Params) delete[] Params;
		 delete[] ParamsTypes;

		 return true;
	 }


	 //===================== CallNetDelegate

	 bool CallNetDelegate::Execute(const CefString&amp; name,
		 CefRefPtr&lt;CefV8Value&gt; object,
		 const CefV8ValueList&amp; arguments,
		 CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		 CefString&amp; exception) {


		 const size_t argumentsCount = arguments.size();
		 vector&lt;wstring&gt; savedstrings;
		 NetObjectToNative::tVariant* Params = nullptr;

		 int Target = arguments[0]-&gt;GetIntValue();
		

		 CefRefPtr&lt;CefV8Value&gt; params;

		 size_t  argCount = 0;
		 if (argumentsCount == 2)
		 {


			 params = arguments[1];

			 if (!params-&gt;IsArray())
			 {
				 exception = CefString("    2    ");
				 return true;

			 }
			 argCount = params-&gt;GetArrayLength();


		 }

		 if (argCount &gt; 0)
		 {
			 savedstrings.reserve(argCount);
			 Params = new NetObjectToNative::tVariant[argumentsCount];
			 NetObjectToNative::tVariant* Param = Params;

			 for (size_t i = 0; i &lt; argCount; ++i)
			 {

				 NetObjectToNative::ConvertCEFtoNet(params-&gt;GetValue(i), &amp;Param[i], savedstrings);
			 }

		 }
		 wchar_t*  Error = nullptr;
		 NetObjectToNative::tVariant RetVal;

		 bool res = mD-&gt;pCallAsDelegate(Target, &amp;RetVal, Params, argCount, &amp;Error);

		 if (res)
		 {

			 retval = NetObjectToNative::ConvertNetToCef(&amp;RetVal, true);
		 }
		 else
		 {
			 if (Error)
				 exception = CefString(std::wstring(Error));
			 delete Error;
		 }

		 if (Params) delete[] Params;

		 return true;
	 }

	 // CallNetObjectPropertySet
	 bool 	CallNetObjectPropertySet::Execute(const CefString&amp; name,
		 CefRefPtr&lt;CefV8Value&gt; object,
		 const CefV8ValueList&amp; arguments,
		 CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		 CefString&amp; exception) {


		 const size_t argumentsCount = arguments.size();

		 if (argumentsCount != 3)
		 {


				 exception = CefString(L" PropertySet   3 ");
				 return true;

			}
			 
		 vector&lt;wstring&gt; savedstrings;


		 int Target = arguments[0]-&gt;GetIntValue();
		 wstring PropertyName = arguments[1]-&gt;GetStringValue().ToWString();
		 CefRefPtr&lt;CefV8Value&gt; value = arguments[2];

			 
			 savedstrings.reserve(1);
			 NetObjectToNative::tVariant Param;
			
			 NetObjectToNative::ConvertCEFtoNet(value, &amp;Param, savedstrings);
			 


		 wchar_t*  Error = nullptr;
	
		 bool res = mD-&gt;pSetPropVal(Target, PropertyName.c_str(), &amp;Param, &amp;Error);

		 if (!res)
		 {
			 if (Error)
			 {
				 exception = CefString(std::wstring(Error));
				 delete Error;
			 }
			 else 
				 exception = CefString(L"   "+ PropertyName);
			
		 }

		

		 return true;
	 }

	 bool 	DeleteNetObject::Execute(const CefString&amp; name,
		 CefRefPtr&lt;CefV8Value&gt; object,
		 const CefV8ValueList&amp; arguments,
		 CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		 CefString&amp; exception) {


		 const size_t argumentsCount = arguments.size();

		 if (argumentsCount != 1)
		 {
			 exception = CefString(L" DeleteObject   1 ");
			 return true;
		 }

		 CefRefPtr&lt;CefV8Value&gt; value = arguments[0];
		 
		 
		 mD-&gt;pDeleteObject(value-&gt;GetIntValue());

		

		 return true;
	 }

	 bool 	IteratorNext::Execute(const CefString&amp; name,
		 CefRefPtr&lt;CefV8Value&gt; object,
		 const CefV8ValueList&amp; arguments,
		 CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		 CefString&amp; exception) {


		 const size_t argumentsCount = arguments.size();

		 if (argumentsCount != 1)
		 {
			 exception = CefString(L" IteratorNext   1 ");
			 return true;
		 }

		 CefRefPtr&lt;CefV8Value&gt; value = arguments[0];
		 wchar_t*  Error = nullptr;
		 NetObjectToNative::tVariant RetVal;

		bool res= mD-&gt;pIteratorNext(value-&gt;GetIntValue(),&amp;RetVal, &amp;Error);
		if (res)
		{
			retval = NetObjectToNative::ConvertNetToCef(&amp;RetVal, true);

		}
		else
		{
			retval = CefV8Value::CreateUndefined();
			if (Error)
			{
				exception = CefString(std::wstring(Error));
				delete Error;
			}

		}
		 return true;
	 }

	 bool 	CallNetObjectPropertyGet::Execute(const CefString&amp; name,
		 CefRefPtr&lt;CefV8Value&gt; object,
		 const CefV8ValueList&amp; arguments,
		 CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		 CefString&amp; exception) {


		 int Target = arguments[0]-&gt;GetIntValue();
		 wstring PropertyName = arguments[1]-&gt;GetStringValue().ToWString();

		 wchar_t*  Error = nullptr;
		 NetObjectToNative::tVariant RetVal;

		 bool res = mD-&gt;pGetPropVal(Target, PropertyName.c_str(), &amp;RetVal,&amp;Error);

		 if (!res)
		 {
			 if (Error)
			 {
				 exception = CefString(std::wstring(Error));
				 delete Error;
			 }
			 else
				 exception = CefString(L"    " + PropertyName);

		 }
		 else
			 retval = NetObjectToNative::ConvertNetToCef(&amp;RetVal, true);



		 return true;
	 }

	 void SetHandlerToContex(CefRefPtr&lt;CefV8Handler&gt; Handler, CefRefPtr&lt;CefV8Value&gt; object, const char* MetodName)
	 {

		 CefRefPtr&lt;CefV8Value&gt; CallNetObject = CefV8Value::CreateFunction(MetodName, Handler);

		 // Add the "myfunc" function to the "window" object.
		 object-&gt;SetValue(MetodName, CallNetObject, V8_PROPERTY_ATTRIBUTE_NONE);
	 }

	 void ContextForNetHandlers::OnContextCreated(CefRefPtr&lt;CefBrowser&gt; browser, CefRefPtr&lt;CefFrame&gt; frame, CefRefPtr&lt;CefV8Context&gt; context)
	 {
		 this-&gt;context = context;
		 // Retrieve the context's window object.
		 CefRefPtr&lt;CefV8Value&gt; object = context-&gt;GetGlobal();
		 NetObjectToNative::ManagedDomainLoader* mD = NetObjectToNative::ManagedDomainLoader::InitManagedDomain(L"c:\\Program Files\\DNX\\runtimes\\dnx-coreclr-win-x86.1.0.0-rc1-update1\\bin\\", L"", L"");

		 //=========== CallNetMethod =======================================================
		 SetHandlerToContex(new CallNetObjectFunction(mD), object, "CallNetMethod");
		 //=========== CallNetDelegate =======================================================
		 SetHandlerToContex(new CallNetDelegate(mD), object, "CallNetDelegate");
		 //=========== PropertySet =======================================================
		 SetHandlerToContex(new CallNetObjectPropertySet(mD), object, "CallNetPropertySet");
		 //=========== PropertyGet =======================================================
		 SetHandlerToContex(new CallNetObjectPropertyGet(mD), object, "CallNetPropertyGet");
		 //=========== PropertyGet =======================================================
		 SetHandlerToContex(new DeleteNetObject(mD), object, "DeleteNetObject");
		 //=========== SetCallBacks =======================================================
		 SetHandlerToContex(new SetCallBacks(mD, this, object), object, "RegisterCallBacks");
		 //============ CallAsyncNetObjectFunction ================================
		 SetHandlerToContex(new CallAsyncNetObjectFunction(mD, this), object, "CallAsyncNetObjectFunction");
		 //============ CallNetObjectGenericFunction ================================
		 SetHandlerToContex(new CallNetObjectGenericFunction(mD), object, "CallNetObjectGenericFunction");
		 //============ IteratorNext ================================
		 SetHandlerToContex(new IteratorNext(mD), object, "IteratorNext");

	 }

	

	 
	 void ContextForNetHandlers::AsyncCalBack(const wchar_t* TaskID, bool Successfully, tVariant* ReturnValue)
	 {
		

		 if (!CefCurrentlyOn(TID_RENDERER)) {
			 // Execute on the UI thread.
			// CefPostTask(TID_UI, base::Bind(&amp;AsyncCalBack2, TaskID, Successfully,ReturnValue, CallbackContext));
			 CefPostTask(TID_RENDERER, base::Bind(&amp;SetCallBacks::AsyncCalBack, this-&gt;scb, TaskID, Successfully, ReturnValue));
			 return;
		 }

		 scb-&gt;AsyncCalBack(TaskID, Successfully, ReturnValue);
	 }

	 //==================== Set CallBacs
	 bool SetCallBacks::Execute(const CefString&amp; name,
		 CefRefPtr&lt;CefV8Value&gt; object,
		 const CefV8ValueList&amp; arguments,
		 CefRefPtr&lt;CefV8Value&gt;&amp; retval,
		 CefString&amp; exception) {

		    this_id = std::this_thread::get_id();
			 if (arguments.size() == 1 &amp;&amp; arguments[0]-&gt;IsFunction()) {
				 AsyncMetodCall = arguments[0];
				 CallbackContext = CefV8Context::GetCurrentContext();
				 cfn-&gt;scb = this;

				 /*CefV8ValueList args;
				 args.push_back(CefV8Value::CreateBool(true));
				 args.push_back(CefV8Value::CreateString(L""));
				 args.push_back(CefV8Value::CreateString(L""));

				 if (AsyncMetodCall-&gt;ExecuteFunctionWithContext(CallbackContext, globalObj, args)) {
					
				 }*/
				
				 return true;
			 }
		

		 return true;

	 }

	 void SetCallBacks::AsyncCalBack(const wchar_t* TaskID, bool Successfully, tVariant* ReturnValue)
	 {
		 CefV8ValueList args;
		 
		 std::thread::id Curr_id = std::this_thread::get_id();
		 if (this_id != Curr_id)
		 {
		 }

		 if (CallbackContext.get() &amp;&amp; CallbackContext-&gt;Enter()) {

			 args.push_back(CefV8Value::CreateBool(true));

			 args.push_back(CefV8Value::CreateString(TaskID));
			 delete[] TaskID;

			 if (ReturnValue==nullptr)
				 args.push_back(CefV8Value::CreateUndefined());
			 else
			 {
			 args.push_back(NetObjectToNative::ConvertNetToCef(ReturnValue, true));
			 delete[] ReturnValue;
			 }
 
			 
			 if (AsyncMetodCall-&gt;ExecuteFunctionWithContext(CallbackContext, globalObj, args)) {
				 
			 }
			 CallbackContext-&gt;Exit();
		 }
	 }	
}
</code></pre><br>
</div></div><br>
        <a href="https://habrahabr.ru/post/309850/">1,.Net Core.        .Net   1</a>. <br>
<br>
    ,       <a href="https://yadi.sk/d/0If7C5jZ3CEhmf"></a>.<br>
<br>
  .   cefsimple\Release\         Test.html.   cefsimple\NetObjectToNative\<br>
      CEF  .Net Core. ManagedDomainLoader  ClrLoader    .Net Core,       .<br>
<br>
 CefV8HandlersForNet      JS  CEF.  NetConverter    Net  Cef.<br>
<br>
 NetObjectToCEF       CEF.  TestDllForCoreClr      .<br>
 <br>
  TestTypeScript\TestTypeScript\app\   ts    Proxy. NetProxy.ts   Proxy.<br>
<br>
home.component.ts   AngleSharp. counter.component.ts   . TestSpeed.ts   <br>
<br>
   node_modules.      TestTypeScript npm install<br>
<br>
  .  TestTypeScript  CefProgects\cefsimple\Release\cefsimple.exe.        JS.     TS           ¬´   ¬´     ¬ª¬ª.   .<br>
<br>
   cefsimple.    <a href="http://opensource.spotify.com/cefbuilds/index.html">opensource.spotify.com/cefbuilds/index.html</a> 32- Standard Distribution     tests\cefsimple\   h     NetObjectToNative.<br>
<br>
  VS 2015     CEF cmake.exe -G ¬´Visual Studio 14¬ª<br>
<br>
 VS 2017 cmake.exe -G ¬´Visual Studio 15 2017¬ª.<br>
<br>
  !</div><p>Source: <a href="https://habr.com/ru/post/320960/">https://habr.com/ru/post/320960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320948/index.html">Exceptions in the UEFI application</a></li>
<li><a href="../320952/index.html">Founder's advice. Dmitry Barychev, ‚ÄúTrack parcel.rf‚Äù</a></li>
<li><a href="../320954/index.html">Hyper-Converged Platforms: From Exotic to Mainstream</a></li>
<li><a href="../320956/index.html">Google publishes Chrome source code for iOS</a></li>
<li><a href="../320958/index.html">Game theory and poker. Counting the number of possible strategies</a></li>
<li><a href="../320962/index.html">Microservice architecture</a></li>
<li><a href="../320964/index.html">Matrix with ideas for startups</a></li>
<li><a href="../320966/index.html">CryptoAPI of the Linux kernel: development and application of Russian cryptography</a></li>
<li><a href="../320968/index.html">Over the past year, users of ad blockers have become 30% more</a></li>
<li><a href="../320970/index.html">Powershell and stack depth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>