<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Checking Vim with PVS-Studio on GNU / Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The reader might think that this is another article about testing another project from the free software world, but in fact, the article is not so muc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Checking Vim with PVS-Studio on GNU / Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/5f5/b54/09e/5f5b5409ed7c9c4c6dbb07c5f2d13bfd.png" align="left"><br><br>  The reader might think that this is another article about testing another project from the free software world, but in fact, the article is not so much about testing as about the practice of using the PVS-Studio analyzer in a fully GNU / Linux environment.  It is not by chance that Vim became the choice of the project for verification, for he, too, served in this matter. <br><br><h3>  First, a little about Vim </h3><br>  Vim ( <a href="http://vim.org/">http://vim.org</a> ) is a cross-platform free text editor with a 30-year history, which is the successor of the vi editor and came from the world of Unix systems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Vim is widely used in administration and development, in many GNU / Linux distributions it is the default editor.  Vim differs from other text editors with its focus on using only the keyboard, a text interface, and rich extensibility through a system of plug-ins written in Vim Script. <br><a name="habracut"></a><br><br><h3>  Now about the test itself </h3><br>  One option for testing Linux projects is to integrate into the build system, for example, GNU Make.  To verify vim, this method was chosen.  For each call to the compiler, a call to the analyzer was added to the makefile.  For convenience, this call was wrapped in a Make variable in a similar way: <br><pre><code class="cpp hljs">#PVS Studio vars PVS_CFLAGS = $(ALL_CFLAGS) PVS_INCFLAGS = -I$(srcdir) PVS_STUDIO = ~/PVS-Studio/PVS-Studio ‚Äìcfg \ ~/PVS-Studio/PVS-Studio_vim.cfg --source-file \ $&lt; --cl-params $(PVS_CFLAGS) -c $(PVS_INCFLAGS) $&lt;</code> </pre> <br>  Next, the project is built in the usual mode with the make command (if you wish, you can add a separate target for analysis, for example, ".analysis").  The result, in addition to the collected project, is a raw analyzer log. <br><br>  <b><i>Note.</i></b>  <i>The analyzer can be launched in parallel when building a project in parallel.</i>  <i>Each running instance of the analyzer writes its own portion of messages to the log.</i>  <i>Therefore, keep in mind that the analyzer does not clear the file with the raw log.</i>  <i>Therefore, before restarting the check, you must delete the log from the previous check yourself.</i> <br><br>  It is impossible to work with a raw log.  There are many duplicate messages in this log (when one .h file is included in several .cpp files).  To change the parameters of the analysis, it is necessary, after editing the configuration file, to run a check again, which seriously affects the time for large projects.  Even if we just wanted, for example, to disable warnings related to files from a specific directory.  To solve this problem, C ++ has written the log-parser utility, which processes the PVS-Studio raw log, removes duplicate messages, applies filters to messages from its options file and displays analyzer warnings in one of the supported formats.  The utility works very quickly (even on the verification logs of very large projects, its work time does not exceed 2-3 seconds), which makes it possible to quickly and easily change some analysis parameters and get a new list of messages. <br><br>  If necessary, you can easily add new output formats.  At the moment there are two: xml and the so-called errorfile.  As far as I understand, he does not have an official name, this is the format in which many programs under Linux give out messages, for example, grep, gcc compilation errors, etc.  It was he who helped us. <br><br>  Unlike Windows, where the vast majority of developers use Visual Studio, in the GNU / Linux world there are many IDEs, text editors, and others with their share of users.  There is no consensus and advantage of the parties, and everyone chooses an instrument to his liking.  However, when checking projects, it is important not only to get the analysis results, but also to have the opportunity to work with them conveniently, as this possibility is provided by the integration of PVS-Studio with Visual Studio.  The error message format described above is a kind of standard for Linux programs and most editors and development environments have some kind of support for it, but unfortunately, in most cases, this support exists only for reading compiler messages from stderr when building, in this however, it is much more convenient to take the analyzer messages from a previously prepared file. <br><br>  This is where the Vim editor came in handy.  Of course, you can develop an appropriate plugin for any of the other tools, but it turned out that Vim has this feature initially. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/77a/0f3/05c/77a0f305cda3e570d385f85ce852bbe8.png"></a> <br>  Figure 1 - Running vim with the results of the analysis. <br><br>  After the analyzer and the log processing utility, it suffices to execute vim -q &lt;errorfile&gt;, and then in the opened editor, execute the buffer creation command with errors.  For example: cw 20. And now we get a comfortable environment for working with analyzer messages and navigating through the code.  Of course, I had to spend several hours studying Vim myself, since I hadn‚Äôt worked in it before, and its principles of use are very different from the more familiar text editors.  But in the end, I can say that he was very imbued with the convenience of using it and from the category of incomprehensible alien gizmos he moved into the category of powerful tools for work.  Accordingly, it did not take long to choose a project for verification - of course, Vim himself.  The vim code turned out to be very high-quality, there were no obvious bugs in it (although the style of writing the code is rather controversial in places, but I think you can make a discount on the project‚Äôs age. Nevertheless, there were a number of places worth paying attention to. Let's talk about them in more detail . <br><br><h3>  Extra check </h3><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ptr == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compl_leader != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) ptr = compl_leader; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (compl_orig_text != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { p = compl_orig_text; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (len = <span class="hljs-number"><span class="hljs-number">0</span></span>; p[len] != NUL &amp;&amp; p[len] == ptr[len]; ++len) ; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> FEAT_MBYTE </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (len &gt; 0) len -= (*mb_head_off)(p, p + len); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> for (p += len; *p != NUL; mb_ptr_adv(p)) AppendCharToRedobuff(K_BS); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> len = 0; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ptr != NULL) AppendToRedobuffLit(ptr + len, -1);</span></span></code> </pre> <br>  Analyzer Warning <a href="http://www.viva64.com/ru/d/0205/">V595</a> (1) The 'ptr' pointer was used before it was verified against nullptr.  Check lines: 3922, 3933. <br><br>  The ptr pointer has already been checked for NULL; if this condition is true, it has been assigned the pointer comp_leader, which is definitely not null.  A second check is required. <br><br><h3>  Weird memset </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* * If requested, store and reset the global values controlling * the exception handling (used when debugging). Otherwise avoid * clear it to a bogus compiler warning when the optimizer * uses inline functions... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flags &amp; DOCMD_EXCRESET) save_dbg_stuff(&amp;debug_saved); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> vim_memset(&amp;debug_saved, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  where debug_saved is a structure object <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dbg_stuff</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> trylevel; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> force_abort; except_T *caught_stack; char_u *vv_exception; char_u *vv_throwpoint; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> did_emsg; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> got_int; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> did_throw; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> need_rethrow; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> check_cstack; except_T *current_exception; };</code> </pre> <br>  Analyzer message: <a href="http://www.viva64.com/ru/d/0101/">V512</a> (1) A call of the 'memset' function will be carried out. <br><br>  It is difficult to say why it was necessary to reset only the first byte of the structure.  If this is used as a flag, it is better to define it with a separate structure field (you can union). <br><br><h3>  Suspicious cycle </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* check for out-of-memory */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_names; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (names[i] == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; num_names; ++i) vim_free(names[i]); num_names = <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre> <br>  Analyzer Message: <a href="http://www.viva64.com/ru/d/0124/">V535</a> (1) The variable 'i' is being used for the loop.  Check lines: 1893, 1897. <br><br>  In the outer and inner loop, the same array is passed through the same counter i.  It is clear that when the first condition is triggered if (names [i] == NULL), the next step of the external cycle will not be executed, but the outsider will have to strain to understand this code correctly, and the peculiarity of its writing suggests either the behavior meant the author.  In other words, although there is no error, but the code smells a bit.  Perhaps the break operator would be better suited to stop the loop. <br><br><h3>  Scopes </h3><br><pre> <code class="cpp hljs">char_u *p, *old; <span class="hljs-comment"><span class="hljs-comment">//... { char_u buffer[BUFLEN + 1]; //... for (p = buffer; p &lt; buffer + len; p += l) //...</span></span></code> </pre> <br>  Analyzer warning: <a href="http://www.viva64.com/ru/d/0096/">V507</a> (2) <a href="http://www.viva64.com/ru/d/0096/">Point</a> to this array.  Such a pointer will become invalid. <br><br>  There are quite a few similar places in the code in Vim (on the issue of style).  The pointer p, declared at the very beginning of the function (in some places with a global scope), stores a pointer to an array that exists only in a smaller scope and which will be deleted when it leaves the code block.  At a cursory examination, it seemed to me that after going out of the buffer scope, the p pointer is used only after assigning a new value to it, but you can skip this somewhere.  For what purpose, instead of declaring another variable inside the buffer scope (really to save space on the stack?), I don‚Äôt understand.  This code is poorly supported and inconvenient to read. <br><br><h3>  Error with signed and unsigned types in the same expression </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (cu = <span class="hljs-number"><span class="hljs-number">1</span></span>; cu &lt;= <span class="hljs-number"><span class="hljs-number">255</span></span>; cu++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (VIM_ISDIGIT(cu)) regc(cu);</code> </pre> <br>  Where <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> VIM_ISDIGIT(c) ((unsigned)(c) - </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'0'</span></span></span><span class="hljs-meta"> &lt; 10)</span></span></code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0281/">V658</a> (2) A value is being subtracted from the unsigned variable.  This can result in an overflow.  In such a case, the '&lt;' comparison operation can potentially behave unexpectedly.  Consider inspecting the '(unsigned) (cu) -' 0 '&lt;10' expression. <br><br>  This code looks more like a dirty hack.  When calculating the expression ((unsigned) - '0' &lt;10), the result of the subtraction will be an unsigned value and, when comparing, both parts of the expression will also be converted to unsigned.  Accordingly, when the variable cu is less than the numeric value 0, an overflow occurs.  In this case, the code behaves correctly, its purpose (checking whether the character is a digit) performs, but I do not think that there are reasons to use similar techniques in your code without need.  The cycle could be done from '0' and do without casting to unsigned. <br><br><h3>  The pointer is initialized to NULL and is not changed anywhere, moreover, it is used </h3><br><pre> <code class="cpp hljs">char_u *retval = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... if (round == 2) vim_strncpy(retval, s, len); //  retval //... if (retval == NULL) {</span></span></code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0205/">V595</a> (1) The 'retval' pointer was used before it was verified against nullptr.  Check lines: 7903, 7907. <br><br>  This is like an error.  The analyzer says that there is an extra check, but in fact the problem is primarily in another.  The retval pointer was initialized to 0, and I did not find a single place in this function where its value would change.  In this case, it is strncpy many times.  After which he was suddenly decided to check for NULL. <br><br><h3>  Unsafe use of realloc </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> check for vim_realloc() returning NULL. */</span></span> l-&gt;t = vim_realloc(l-&gt;t, newlen * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(nfa_thread_T));</code> </pre> <br>  <a href="http://www.viva64.com/ru/d/0340/">V701</a> (2) realloc () analyzer <a href="http://www.viva64.com/ru/d/0340/">warning</a> possible leak: when realloc () fails in allocating memory, original pointer 'l-&gt; t' is lost.  Consider assigning realloc () to a temporary pointer. <br><br>  A very common error in many projects, the essence of this error is described in detail in the message of the analyzer.  Fortunately, judging by the commentary, this will be fixed soon.  In other places in the code Vim realloc is used correctly. <br><br><h3>  Some examples of false positives. </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ireg_icombine &amp;&amp; len == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* If \Z was present, then ignore composing characters. * When ignoring the base character this always matches. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (len == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sta-&gt;c != curc) result = FAIL;</code> </pre> <br>  <a href="http://www.viva64.com/ru/d/0153/">V560</a> (2) A part of conditional expression is always true: len == 0. <br><br>  <a href="http://www.viva64.com/ru/d/0169/">V571</a> (2) Recurring check.  The 'len == 0' condition was already verified in line 6032. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (VIsual_active) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (VIsual_active &amp;&amp; (VIsual_mode != wp-&gt;w_old_visual_mode || type == INVERTED_ALL))</code> </pre> <br>  <a href="http://www.viva64.com/ru/d/0169/">V571</a> (2) Recurring check.  The 'VIsual_active' condition was already verified in line 1515. <br><br>  There are a few more places with similar checks.  They do not cause much interest for discussion, in most cases they do not bear harm, but in some cases there may be a logical error, therefore such places should be paid attention to. <br><br><h3>  Just a bad code, in the structure fill only the first byte. </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> FEAT_TAG_BINS </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* This is only to avoid a compiler warning for using search_info * uninitialised. */</span></span></span><span class="hljs-meta"> vim_memset(&amp;search_info, 0, (size_t)1); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  <a href="http://www.viva64.com/ru/d/0101/">V512</a> (1) A call of the "memset" function will lead you to go. <br><br>  The commentary explains why this is done, but the method is rather strange.  There are many more beautiful ways to avoid compiler warnings. <br><br><h3>  Bad practice using short names </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *UP, *BC, PC;</code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0348/">V707</a> (2) Giving short names for global variables.  It is suggested to rename 'UP', 'BC', 'PC' variables. <br><br>  This practice is not uncommon in the Vim code.  Many variables have 1- and 2-letter names, often with a large scope, and in this case generally with a global one.  Combined with functions that are 500+ lines long, this leads to very hard-to-read code. <br><br><h3>  Strange i assignment in condition </h3><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* index in s[] just after &lt;Esc&gt;[ or CSI */</span></span> <span class="hljs-comment"><span class="hljs-comment">//... if (n &gt;= 8 &amp;&amp; t_colors &gt;= 16 &amp;&amp; ((s[0] == ESC &amp;&amp; s[1] == '[') || (s[0] == CSI &amp;&amp; (i = 1) == 1)) &amp;&amp; s[i] != NUL &amp;&amp; (STRCMP(s + i + 1, "%p1%dm") == 0 || STRCMP(s + i + 1, "%dm") == 0) &amp;&amp; (s[i] == '3' || s[i] == '4'))</span></span></code> </pre> <br>  Analyzer Warning: <a href="http://www.viva64.com/ru/d/0153/">V560</a> (2) A part of the conditional expression is always true: (i = 1) == 1. <br><br>  It is difficult to say whether this is a mistake or just a strange way to assign i to the unit.  Write so obviously not worth it. <br><br><h2>  Conclusion </h2><br>  In conclusion, I would like to say that now checking projects using PVS-Studio under GNU Linux without using a Windows machine is quite real and quite convenient.  Vim helped in this number, for which he was subjected to such a verification scenario first. <br><br><h2>  This article is in English. </h2><br>  If you want to share this article with an English-speaking audience, then please use the link to the translation: Anton Tokarev.  <a href="http://www.viva64.com/en/b/0311/">Analyzing Vim by PVS-Studio in GNU / Linux</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text"><br>  Often our articles are asked the same questions.  We collected the answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio and CppCat, version 2014</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/253553/">https://habr.com/ru/post/253553/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253539/index.html">Store design: multi-brand, personalization, microformats, integration with 1C and marketplaces</a></li>
<li><a href="../253545/index.html">How to catch what is not. Part one. Terms and Definitions</a></li>
<li><a href="../253547/index.html">Akka.NET Bootcamp</a></li>
<li><a href="../253549/index.html">Memo: Five-minute UX guide from Squarespace and MailChimp</a></li>
<li><a href="../253551/index.html">Bolid integration in 1C or how we tamed the access control system</a></li>
<li><a href="../253555/index.html">Akka.NET Bootcamp - Part 1: Starting Level Akka.NET</a></li>
<li><a href="../253557/index.html">Pwn2Own 2015: first results</a></li>
<li><a href="../253559/index.html">[case] Iteration on time or half a team?</a></li>
<li><a href="../253561/index.html">We start PHPUnit tests for the project on 1C-Bitrix</a></li>
<li><a href="../253563/index.html">How do we build a magical SSD hosting in the Netherlands and the USA with new principles of charging and working, is it really magic?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>