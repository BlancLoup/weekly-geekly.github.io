<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET and design patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A design pattern or pattern is a repeatable architectural construct that represents a solution to a design problem within a context that often arises....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET and design patterns</h1><div class="post__text post__text-html js-mediator-article">  A design pattern or pattern is a repeatable architectural construct that represents a solution to a design problem within a context that often arises. <br><br>  It seems that we have heard this definition a thousand times ... In addition to knowledge of terms and patterns, it is interesting to know how they are used in real projects. <br><br>  In this article, I will look at several of the most popular patterns used in .NET.  Some of them are deeply integrated into the .NET infrastructure, while others are simply applied when designing base classes in the BCL. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Not one dozen books are devoted to design patterns, but one book stands alone and this is the famous book ‚ÄúGangs of Four‚Äù.  Therefore, for a better understanding of the situation, I will give a brief description of this book. <br><a name="habracut"></a><br>  We will look at the following six patterns: <br><br><ol><li>  observer; </li><li>  iterator; </li><li>  decorator; </li><li>  adapter; </li><li>  factory; </li><li>  strategy. </li></ol><br>  So, let's begin. <br><br><h4>  Observer </h4><br>  Perhaps the most famous pattern that is applied in .NET is the observer.  It is known because it laid the foundation for delegates who have been an integral part of .NET since its inception.  It is difficult not to appreciate their contribution to the .NET object model, especially considering what they have evolved into in later versions (lambdas, closures, etc.). <br><br>  <b>The purpose of the pattern observer from GOF:</b> determines the one-to-many dependency between objects in such a way that when a state of a single object changes, all dependent on it are notified of this and automatically updated. <br><br>  The simplest implementation of this pattern in C # may look something like this: <br><br><div class="spoiler">  <b class="spoiler_title">Simple observer</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IObserver</span></span> <span class="hljs-comment"><span class="hljs-comment">//   { void Notify(); } public abstract class Subject //  { private List&lt;IObserver&gt; observers = new List&lt;IObserver&gt;(); public void Add(IObserver o) { observers.Add(o); } public void Remove(IObserver o) { observers.Remove(o); } public void Notify() //    { foreach (IObserver o in observers) o.Notify(); } }</span></span></code> </pre> </div></div><br>  As I said in the .NET platform, delegates implement the abstraction of the observer.  For more convenient work with delegates in C # events are used.  In the following example, we will use them: <br><br><div class="spoiler">  <b class="spoiler_title">Observer in .NET</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyEventHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    public class Subject { public Subject() { } public MyEventHandler MyEvent; //  public void RaiseEvent() //       { MyEventHandler ev = MyEvent; if (ev != null) ev(); } } static void Main(string[] args) { Subject s = new Subject(); s.MyEvent += () =&gt; Console.WriteLine("Hello habrahabr"); //   s.MyEvent += () =&gt; Console.WriteLine("Hello world"); //   s.RaiseEvent(); //    Console.ReadKey(); }</span></span></code> </pre></div></div><br>  Analogy with the observer pattern on the face.  An event acts as a subject, while delegates as an observer. <br><br>  <b>On a note</b> <br><br>  The code described above has one drawback: when using lambda expressions, you will not be able to detach the delegate, that is, the code <br><br><pre> <code class="cs hljs">s.MyEvent -= () =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello habrahabr"</span></span>);</code> </pre><br>  will not remove this delegate since it is a different instance.  To further detach a delegate, you will have to save the delegate (lambda expression) in a variable. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Subject s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Subject(); MyEventHandler myEv1 = () =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello habarhabr"</span></span>); MyEventHandler myEv2 = () =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello world"</span></span>); s.MyEvent += myEv1; s.MyEvent += myEv2; s.MyEvent -= myEv1; s.RaiseEvent(); <span class="hljs-comment"><span class="hljs-comment">//      Console.ReadKey(); }</span></span></code> </pre><br>  In .NET 4.0, interfaces have appeared that allow you to directly implement an observer pattern.  They look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IObservable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">IDisposable </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IObserver&lt;T&gt; observer</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IObserver</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnCompleted</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception error</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  As you can see, the IObservable interface is implemented a little differently than our observer.  Instead of having methods for adding and removing observers, it only has a method that registers an observer.  The method returns an implementation of IDisposable, which allows observers to cancel notifications at any time before the supplier stops sending them.  You can now use lambda expressions, and then detach them by calling Dispose. <br><br>  <b>On a note</b> <br><br><h4>  Iterator </h4><br>  The following pattern, no less popular in use in .NET, is an iterator. <br><br>  <b>Pattern assignment iterator from GOF:</b> provides a method of sequential access to all elements of a compound object, without revealing its internal representation. <br><br>  On the .NET platform, two interfaces are responsible for implementing the iterator pattern: IEnumerable and IEnumerator <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span> { <span class="hljs-function"><span class="hljs-function">IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IEnumerator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre><br>  as well as their generalized analogues: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IEnumerable</span></span> { <span class="hljs-function"><span class="hljs-function">IEnumerator&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetEnumerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IEnumerator</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IDisposable</span></span>, <span class="hljs-title"><span class="hljs-title">IEnumerator</span></span> { T Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } }</code> </pre><br>  In order to be able to iterate some entity using the foreach loop, it is necessary to implement the IEnumerable &lt;&gt; interface, as well as to create an iterator itself - a class / structure implementing the IEnumerator &lt;&gt; interface. <br><br>  Given the fact that iterator blocks appeared in C # 2.0 using the <b>yield</b> keyword, creating custom types that implement the IEnumerator &lt;&gt; interface now rarely occurs (the compiler does this for us). <br><br>  The foreach loop works side by side with the iterator pattern.  Following code <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)) { Console.WriteLine(item); }</code> </pre><br>  it's just syntactic sugar for the code: <br><br><pre> <code class="cs hljs">IEnumerator&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; enumerator = Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>).GetEnumerator(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (enumerator.MoveNext()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> item = enumerator.Current; Console.WriteLine(item); } } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (enumerator != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { enumerator.Dispose(); } }</code> </pre><br>  Thus, the iterator pattern is the basis of the C # language, since its language construct (foreach) uses it. <br><br>  <b>On a note</b> <br><br>  The fact that the foreach loop does not actually require the iterated entity to implement the IEnumerable interface (and only requires the presence of certain methods with given signatures) was written by many, so I will not talk about this.  <a href="http://habrahabr.ru/users/sergeyt/" class="user_link">SergeyTeplyakov SergeyT</a> has a good <a href="http://habrahabr.ru/post/148905/">post</a> dedicated to the work of the foreach cycle. <br><br>  In .NET, there are several optimizations regarding the foreach loop.  Since each iteration creates an iterator object, this can adversely affect garbage collection, especially if there are several foreach nested loops, so when iterating over arrays and strings (types deeply integrated into the CLR), the foreach loop turns into a normal for loop. <br><br>  <b>On a note</b> <br><br><h4>  Decorator </h4><br>  Pattern number 3 - decorator objects. <br><br>  <b>Pattern assignment decorator from GOF:</b> dynamically adds new responsibilities to the object.  It is a flexible alternative to spawning subclasses to extend functionality. <br><br>  An abstraction decorator in .NET represents the System.IO.Stream class and its heirs.  Consider the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteBytes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stream stream</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> oneByte; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((oneByte = stream.ReadByte()) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { Console.WriteLine(oneByte); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] { <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span> }); WriteBytes(memStream); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buffStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedStream(memStream); WriteBytes(buffStream); Console.ReadLine(); }</code> </pre><br>  The WriteBytes method works with any stream, but it is not always effective.  Reading one byte from the disk is not very good, so we can use the BufferedStream class, which reads data as a block and then returns it quickly.  The BufferedStream class in the constructor takes a type Stream (any stream), thereby wrapping (decorating) it into a more efficient wrapper.  BufferedStream overrides the basic methods of the Stream class, such as Read and Write, to provide more functionality. <br><br>  The System.Security.Cryptography.CryptoStream class allows you to encrypt and decrypt streams on the fly.  It also accepts a Stream parameter in the constructor, wrapping it in its shell. <br><br><img src="https://habrastorage.org/storage3/f04/9f0/0da/f049f00da6bb9ae6720a9b302546cb54.png"><br><br>  For any stream, we can add the ability to efficiently read by surrounding it with a BufferedStream, without changing the data access interface.  Since we do not inherit functionality, but only ‚Äúdecorate‚Äù it, we can do it at runtime, and not at compilation as it would be if we used inheritance. <br><br><h4>  Adapter </h4><br>  <b>Assigning a pattern adapter from GOF:</b> converts the interface of one class to the interface of another that customers expect.  The adapter ensures that classes work with incompatible interfaces, which would be impossible without it. <br><br>  COM and .NET have a different internal architecture.  Therefore, it is necessary to adapt one interface to another.  The CLR provides access to COM objects through an intermediary, called the Runtime Shell Called (RCW). <br><br>  The runtime creates one runtime shell called per COM object, regardless of the number of existing references to this object. <br><br><img src="https://habrastorage.org/storage3/54b/82b/5e2/54b82b5e25b1bf979d8b2871e9db108b.png"><br><br>  Among other operations, the invoked runtime shell marshals data between managed and unmanaged code on behalf of a wrapped object.  In particular, the invoked runtime shell marshalls the arguments and return values ‚Äã‚Äãof the method if the data exchanged between the client and server is represented in them differently. <br><br>  For example, when a .NET client sends an unmanaged object as part of an argument of type String, the shell converts this string to BSTR (the <a href="http://habrahabr.ru/post/172627/">post</a> in which I described the features of strings in .NET).  If a COM object returns BSTR data to a managed caller, the caller will receive String data.  Both the client and server send and receive data in a manner that they understand. <br><br>  In fact, RCW is an adapter that converts one interface to another. <br><br><h4>  Factory </h4><br>  The fifth pattern is a kind of factory. <br><br>  <b>Purpose of a pattern factory from GOF:</b> provides an interface for creating families of interrelated or interdependent objects without specifying their specific classes. <br><br>  The <b>System.Convert</b> class contains a set of static methods that allow you to create objects without explicitly calling their constructors, and works like a factory.  To convert an integer to a boolean, for example, we can call and pass an integer to the Convert.ToBoolean method as a parameter.  The return value of this method will be true if the number was non-zero and false otherwise.  Other type conversion methods work similarly. <br><br>  Such a strategy for creating new instances of objects is known as the Factory pattern.  We can ask the factory to create the necessary object without invoking the constructor.  Thus, the Factory pattern can hide the complexity of creating an object.  If we want to change the details of the creation of an object, we just need to change the factory itself, we will not have to change every place in the code in which the constructor is called. <br><br>  The <b>Activator.CreateInstance</b> method in combination with information about types implements an abstract class factory, i.e.  one that can create instances of any type. <br><br><h4>  Strategy </h4><br>  <b>The purpose of the pattern strategy from GOF:</b> defines a family of algorithms, encapsulates each of them and makes them interchangeable.  The strategy allows you to change algorithms, regardless of the customers who use them. <br><br>  A good example of using this simple pattern is sorting arrays.  One of the overloads of the Array.Sort method takes a parameter of type IComparable.  Using this interface, we can create a whole series of algorithms for sorting the so-called strategies that are independent of each other and are easily interchangeable. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IComparable</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CompareTo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T other</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  The sorting code is virtually independent of the element comparison algorithms and may remain unchanged. <br><br>  This also includes the Array.BinarySearch methods, which also accepts the IComparable interface and the Array.Find method, which the Predicate delegate accepts.  Thus, by varying the various delegates (strategies) we can change the behavior of the method and get the result we need. <br><br>  In general, the pattern strategy is used very often.  Before writing this article, I didn‚Äôt really think that I use the pattern strategy when sorting arrays with different comparators. <br><br><h4>  Conclusion </h4><br>  Now that we have covered some of the patterns used in the .NET Framework, I think it should be even easier for you to recognize them in the code you are working with.  It is hard not to appreciate the contribution of events and iterators to the C # language and the .NET infrastructure in general, so knowing that this is the implementation of classic design patterns is simply necessary. <br><br>  Thanks for reading.  I hope the article was helpful. </div><p>Source: <a href="https://habr.com/ru/post/191934/">https://habr.com/ru/post/191934/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../191920/index.html">The history of personal computers in advertising. Part 1: 1970s</a></li>
<li><a href="../191922/index.html">Experience in building a b2b product: 3 continents in 6 years and half a mile of stuffed cones</a></li>
<li><a href="../191926/index.html">C # async for iOS and Android</a></li>
<li><a href="../191928/index.html">Dog's life in the Jimdo office in Hamburg</a></li>
<li><a href="../191932/index.html">.NET 4.5 - on-site update .NET 4.0</a></li>
<li><a href="../191936/index.html">Dendy console in amateur constructions</a></li>
<li><a href="../191938/index.html">The prosecutor's office of St. Petersburg has blocked the site for bribing a moderator with virtual currency!</a></li>
<li><a href="../191940/index.html">How I use computer technology. Nestollman</a></li>
<li><a href="../191942/index.html">China will launch its "moonwalker" by the end of the year</a></li>
<li><a href="../191946/index.html">XAP (Shitty Architecture Ruins)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>