<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ memory management</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Working with dynamic memory is often a bottleneck in many algorithms, if you do not use special tricks. 

 In the article I will consider a couple of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ memory management</h1><div class="post__text post__text-html js-mediator-article">  Working with dynamic memory is often a bottleneck in many algorithms, if you do not use special tricks. <br><br>  In the article I will consider a couple of such techniques.  The examples in the article differ (for example, from <a href="http://habrahabr.ru/post/125435/">this</a> ) in that the overloading of the operators new and delete is used and due to this, the syntactic constructions will be minimalistic, and the reworking of the program will be simple.  Also described are the pitfalls found in the process (of course, the gurus who read the standard from cover to cover will not be surprised). <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  0. Do we need manual work with memory? </h4><br>  First of all, we will check how smart the allocator can speed up the work with memory. <br><br>  Let's write simple tests for C ++ and C # (C # is known for an excellent memory manager, which divides objects by generations, uses different pools for objects of different sizes, etc.). <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-type"><span class="hljs-type">Node</span></span>* next; }; <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; 10000000; i++) { Node* v = new Node(); }</span></span></code> </pre> <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Node</span></span> next; } <span class="hljs-comment"><span class="hljs-comment">// ... for (int l = 0; l &lt; 10000000; l++) { var v = new Node(); }</span></span></code> </pre><br><br>  Despite all the ‚Äúspherical vacuum‚Äù of the example, the time difference turned out to be 10 times (62 ms against 650 ms).  In addition, the c # example is completed, and according to the rules of good tone in c ++, selected objects must be deleted, which will further increase the gap (up to 2580 ms). <br><br><h4>  1. Pool of objects </h4><br>  The obvious solution is to take a large memory block from the OS and divide it into equal blocks of size size (Node), take a block from the pool when allocating memory, and return to the pool when freeing.  A pool is easiest to organize using a single-linked list (stack). <br><br>  Since there is a task of minimal intervention in the program, all that can be done is to add an admixture of BlockAlloc to the Node class: <br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Node</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlockAlloc</span></span></span><span class="hljs-class">&lt;Node&gt;</span></span></code> </pre><br><br>  First of all, we need a pool of large blocks (pages) that we take from the OS or C-runtime.  It can be organized on top of the malloc and free functions, but for greater efficiency (to skip the extra level of abstraction), we use VirtualAlloc / VirtualFree.  These functions allocate memory in units of multiples of 4K, and also reserve process address space in units of multiples of 64K.  At the same time specifying the commit and reserve options, we skip another level of abstraction, reserving the address space and allocating memory pages in one call. <br><br><div class="spoiler">  <b class="spoiler_title">PagePool class</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> size_t align(size_t x, size_t a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((x<span class="hljs-number"><span class="hljs-number">-1</span></span>) | (a<span class="hljs-number"><span class="hljs-number">-1</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } //#define align(x, a) ((((x)<span class="hljs-number"><span class="hljs-number">-1</span></span>) | ((a)<span class="hljs-number"><span class="hljs-number">-1</span></span>)) + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;size_t PageSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PagePool { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>: <span class="hljs-type"><span class="hljs-type">void</span></span>* GetPage() { <span class="hljs-type"><span class="hljs-type">void</span></span>* page = VirtualAlloc(<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, PageSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); pages.push_back(page); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> page; } ~PagePool() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (vector&lt;<span class="hljs-type"><span class="hljs-type">void</span></span>*&gt;::iterator i = pages.<span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>(); i != pages.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); ++i) { VirtualFree(*i, <span class="hljs-number"><span class="hljs-number">0</span></span>, MEM_RELEASE); } } private: vector&lt;<span class="hljs-type"><span class="hljs-type">void</span></span>*&gt; pages; };</code> </pre> </div></div><br><br>  Then arrange a pool of blocks of a given size. <br><br><div class="spoiler">  <b class="spoiler_title">Class BlockPool</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">template&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">size_t PageSize = 65536</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">size_t Alignment = 8 /* sizeof</span></span></span></span>(void*) */&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlockPool</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PagePool</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PageSize</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: BlockPool() : head(NULL) { BlockSize = align(sizeof(T), Alignment); count = PageSize / BlockSize; } void* AllocBlock() { <span class="hljs-comment"><span class="hljs-comment">// todo: lock(this) if (!head) FormatNewPage(); void* tmp = head; head = *(void**)head; return tmp; } void FreeBlock(void* tmp) { // todo: lock(this) *(void**)tmp = head; head = tmp; } private: void* head; size_t BlockSize; size_t count; void FormatNewPage() { void* tmp = GetPage(); head = tmp; for(size_t i = 0; i &lt; count-1; i++) { void* next = (char*)tmp + BlockSize; *(void**)tmp = next; tmp = next; } *(void**)tmp = NULL; } };</span></span></code> </pre> </div></div><br><br>  Comment <b><i>// todo: lock (this)</i></b> marked places that require inter-thread synchronization (for example, use EnterCriticalSection or boost :: mutex). <br><br>  Let me explain why when ‚Äúformatting‚Äù a page, I do not use the FreeBlock abstraction to add a block to the pool.  If it were written something like <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; PageSize; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> += BlockSize) FreeBlock((char*)tmp+<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>);</code> </pre> <br><br>  That page on the FIFO principle would be marked up ‚Äúthe other way around‚Äù: <br><img src="http://habrastorage.org/storage2/08e/fa3/ad0/08efa3ad00c441e07d449f6195e191c4.png"><br><br>  A few blocks requested from the pool in a row would have decreasing addresses.  And the processor does not like to go back, from this it breaks Prefetch ( <b>UPD</b> : Not relevant for modern processors).  If you do the markup in the loop <br><pre> <code class="hljs lisp">for (<span class="hljs-name"><span class="hljs-name">size_t</span></span> i = PageSize-(<span class="hljs-name"><span class="hljs-name">BlockSize-</span></span>(<span class="hljs-name"><span class="hljs-name">PageSize</span></span>%BlockSize))<span class="hljs-comment"><span class="hljs-comment">; i != 0; i -= BlockSize) FreeBlock...</span></span></code> </pre> <br>  then the markup loop would go back to the addresses. <br><br>  Now that the preparations have been made, we can describe the admixture class. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BlockAlloc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(s); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pool.AllocBlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s != <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T)) { ::<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { pool.FreeBlock(m); } } <span class="hljs-comment"><span class="hljs-comment">// todo: implement nothrow_t overloads, according to borisko' comment // http://habrahabr.ru/post/148657/#comment_5020297 // Avoid hiding placement new that's needed by the stl containers... static void* operator new(size_t, void* m) { return m; } // ...and the warning about missing placement delete... static void operator delete(void*, void*) { } private: static BlockPool&lt;T&gt; pool; }; template&lt;class T&gt; BlockPool&lt;T&gt; BlockAlloc&lt;T&gt;::pool;</span></span></code> </pre><br><br>  Let me explain why you need checks <b>if (s! = Sizeof (T))</b> <br>  When do they work?  Then when a class inherited from the base T is created / deleted. <br>  Heirs will use the usual new / delete, but BlockAlloc can also be added to them.  Thus, we can easily and safely determine which classes should use pools without fear of breaking something in the program.  Multiple inheritance also works great with this impurity. <br><br>  Is done.  Inherit Node from BlockAlloc and re-run the test. <br>  Test time is now 120 ms.  5 times faster.  But in c # the allocator is still better.  Probably there is not just a coherent list.  (If immediately after new immediately call delete, and thus not wasting a lot of memory, storing data in the cache, we get 62 ms. Strange. Exactly, like the .NET CLR, as if it returns the released local variables immediately to the corresponding pool, without waiting for GC) <br><br><h4>  2. Container and its colorful contents </h4><br><br>  Do you often come across classes that store a lot of different child objects, such that the last lifetime of the latter is not longer than the lifetime of the parent? <br><br>  For example, it can be an XmlDocument class, filled with the Node and Attribute classes, as well as c-strings (char *) taken from the text inside the nodes.  Or a list of files and directories in the file manager, loaded once when the directory is re-read and no longer changing. <br><br>  As shown in the introduction, delete is more expensive than new.  The idea of ‚Äã‚Äãthe second part of the article is to allocate memory for the child objects in a large block associated with the Parent object.  When deleting a parent object, the children will, as usual, be called destructors, but there is no need to return the memory ‚Äî it will be freed by one large block. <br><br>  Create a class PointerBumpAllocator, which can bite off a large block of pieces of different sizes and select a new large block when the old one is exhausted. <br><br><div class="spoiler">  <b class="spoiler_title">Class PointerBumpAllocator</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> PageSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> Alignment = <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-comment"><span class="hljs-comment">/* sizeof(void*) */</span></span>&gt; class PointerBumpAllocator { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PointerBumpAllocator() : <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* AllocBlock(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> block) { <span class="hljs-comment"><span class="hljs-comment">// todo: lock(this) block = align(block, Alignment); if (block &gt; free) { free = align(block, PageSize); head = GetPage(free); } void* tmp = head; head = (char*)head + block; free -= block; return tmp; } ~PointerBumpAllocator() { for (vector&lt;void*&gt;::iterator i = pages.begin(); i != pages.end(); ++i) { VirtualFree(*i, 0, MEM_RELEASE); } } private: void* GetPage(size_t size) { void* page = VirtualAlloc(NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); pages.push_back(page); return page; } vector&lt;void*&gt; pages; void* head; size_t free; }; typedef PointerBumpAllocator&lt;&gt; DefaultAllocator;</span></span></code> </pre> </div></div><br><br>  Finally, we describe the ChildObject admixture with the overloaded new and delete accessing the given allocator: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> A = DefaultAllocator&gt; struct ChildObject { static <span class="hljs-type"><span class="hljs-type">void</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(size_t s, A&amp; allocator) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> allocator.AllocBlock(s); } static <span class="hljs-type"><span class="hljs-type">void</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(size_t s, A* allocator) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> allocator-&gt;AllocBlock(s); } static <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-type"><span class="hljs-type">void</span></span>*, size_t) { } // *<span class="hljs-number"><span class="hljs-number">1</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-type"><span class="hljs-type">void</span></span>*, A*) { } static <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>(<span class="hljs-type"><span class="hljs-type">void</span></span>*, A&amp;) { } private: static <span class="hljs-type"><span class="hljs-type">void</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(size_t s); };</code> </pre> <br><br>  In this case, in addition to adding an impurity to the child-class, it will also be necessary to correct all calls to new (or use the ‚Äúfactory‚Äù pattern).  The syntax for the new operator is as follows: <br><br>  new (... parameters for the operator ...) ChildObject (... constructor parameters ...) <br><br>  For convenience, I specified two new operators that accept A &amp; or A *. <br>  If the allocator is added to the parent class as a member, the first option is more convenient: <br><pre> <code class="hljs lisp">node = new(<span class="hljs-name"><span class="hljs-name">allocator</span></span>) XmlNode(<span class="hljs-name"><span class="hljs-name">nodename</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>  If the allocator is added as an ancestor (admixture), the second is more convenient: <br><pre> <code class="hljs lisp">node = new(<span class="hljs-name"><span class="hljs-name">this</span></span>) XmlNode(<span class="hljs-name"><span class="hljs-name">nodename</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  It is clear that the pointer and the link are mutually converted, the separation of these cases - getting rid of unnecessary icons. <br><br>  There is no special syntax for calling delete; the compiler will call standard delete (marked with * 1), regardless of which of the new operators was used to create the object.  That is, the delete syntax is normal: <br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> node;</code> </pre> <br><br>  If an exception occurs in the ChildObject constructor (or its successor), delete is called with the signature corresponding to the signature of the new operator used to create this object (the first parameter size_t will be replaced with void *). <br><br>  Placing the new operator in the private section protects against calling new without specifying the allocator. <br><br>  Let me give you a complete example of using the Allocator-ChildObject pair: <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XmlDocument</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DefaultAllocator { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~XmlDocument() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;XmlNode*&gt;::iterator i = nodes.begin(); i != nodes.end(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> (*i); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* content, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* name)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* c = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)AllocBlock(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(content)+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(c, content); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* n = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)AllocBlock(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(name)+<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">strcpy</span></span>(n, content); nodes.push_back(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) XmlNode(c, n)); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XmlNode</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ChildObject&lt;XmlNode, XmlDocument&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: XmlNode(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* _content, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* _name) : content(_content), name(_name) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* content; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;XmlNode*&gt; nodes; };</code> </pre> </div></div><br><br>  Conclusion  The article was written 1.5 years ago for the sandbox, but alas, the moderator didn‚Äôt like it. </div><p>Source: <a href="https://habr.com/ru/post/148657/">https://habr.com/ru/post/148657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148651/index.html">Allegro Cadence 16.5</a></li>
<li><a href="../148653/index.html">Tiled Map Editor: pixelart tileset editor</a></li>
<li><a href="../148654/index.html">Metrics in software development projects</a></li>
<li><a href="../148655/index.html">Hidden messages in music</a></li>
<li><a href="../148656/index.html">Soldering for beginners</a></li>
<li><a href="../148658/index.html">Using external web services in 1C on the example of downloading currency rates</a></li>
<li><a href="../148662/index.html">Why are projects late?</a></li>
<li><a href="../148663/index.html">RFID attacks</a></li>
<li><a href="../148664/index.html">The reasons for the total failure of Nokia Lumia and Windows Phone in particular</a></li>
<li><a href="../148665/index.html">Electronic freelance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>