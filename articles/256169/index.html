<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SQL Language Tutorial (DDL, DML) on the example of MS SQL Server dialect. Part five</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Previous parts 


- Part One - habrahabr.ru/post/255361 
- Part Two - habrahabr.ru/post/255523 
- Part Three - habrahabr.ru/post/255825 
- Part Four -...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SQL Language Tutorial (DDL, DML) on the example of MS SQL Server dialect. Part five</h1><div class="post__text post__text-html js-mediator-article"><h2>  Previous parts </h2><br><ul><li>  Part One - <a href="http://habrahabr.ru/post/255361/">habrahabr.ru/post/255361</a> </li><li>  Part Two - <a href="http://habrahabr.ru/post/255523/">habrahabr.ru/post/255523</a> </li><li>  Part Three - <a href="http://habrahabr.ru/post/255825/">habrahabr.ru/post/255825</a> </li><li>  Part Four - <a href="http://habrahabr.ru/post/256045/">habrahabr.ru/post/256045</a> </li></ul><br><br><h2>  In this part we will look at </h2><br>  Here we will look at the general operation of data modification operators: <br><ul><li>  INSERT - insert new data </li><li>  UPDATE - update data </li><li>  DELETE - delete data </li><li>  SELECT ... INTO ... - save the result of the query in a new table </li><li>  MERGE - data fusion </li><li>  Using the OUTPUT construct </li><li>  TRUNCATE TABLE - DDL operation for quick table cleaning </li></ul><br>  At the very end, you are waiting for ‚ÄúAppendix 1 - a bonus on the SELECT operator‚Äù and ‚ÄúAppendix 2 - OVER and analytical functions‚Äù, in which some advanced constructions will be shown: <br><ul><li>  PIVOT </li><li>  UNPIVOT </li><li>  GROUP BY ROLLUP </li><li>  GROUP BY GROUPING SETS </li><li>  using the OVER application </li></ul><br><br>  Data modification operations are very strongly associated with the constructions of the SELECT statement, since  in essence, a sample of the data being modified goes with it.  Therefore, to understand this material, an important place has a confident knowledge of the constructions of the SELECT statement. <br><a name="habracut"></a><br>  This part, as I said, will be more overview.  Here I will describe only those basic forms of data modification operators, which I myself regularly use.  Therefore, one should not count on the completeness of the presentation, here only the necessary minimum will be shown, which beginners can use as a direction for deeper study.  For more information on each operator, contact MSDN.  Although it is possible to someone and in such a volume of information will be quite enough. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since  direct modification of information in the DDB requires a great responsibility from the person, and also because users usually modify the database information through different workstations, and do not have full access to the database, this part is more devoted to beginning IT specialists, and I will be very brief here.  But of course, if you could master the SELECT statement, then I think, and the modification operators will be in your power, since  after the SELECT statement there is nothing too complicated here, and for the most part it should be perceived on an intuitive level.  But sometimes the complexity is not the modification operators themselves, but the fact that they must be performed in groups, within the framework of a single transaction, i.e.  when you additionally need to consider data integrity.  In any case, you can read and try to do the examples for informational purposes, besides, in the end you will be able to get a more detailed base on which you can work out certain constructions of the SELECT statement. <br><br><h2>  We will carry out changes in the structure of our database. </h2><br>  Let's do a small update on the structure and data of the Employees table: <br><br><pre><code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--       2-    ALTER TABLE Employees ALTER COLUMN Salary numeric(20,2) --          ALTER TABLE Employees ALTER COLUMN BonusPercent tinyint</span></span></code> </pre> <br><br>  And also for demonstration purposes, we will expand the schema of our database, and for one we will repeat the DDL.  The assignments of tables and fields are indicated in the comments: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--      CREATE TABLE EmployeesSalaryHistory( EmployeeID int NOT NULL, --   ID  DateFrom date NOT NULL, --    DateTo date, --   .  NULL     . Salary numeric(20,2) NOT NULL, --      CONSTRAINT PK_EmployeesSalaryHistory PRIMARY KEY(EmployeeID,DateFrom), CONSTRAINT FK_EmployeesSalaryHistory_EmployeeID FOREIGN KEY(EmployeeID) REFERENCES Employees(ID) ) GO --        CREATE TABLE EmployeesSalary( EmployeeID int NOT NULL, SalaryDate date NOT NULL, --   SalaryAmount numeric(20,2) NOT NULL, --   Note nvarchar(50), --  --        1    CONSTRAINT PK_EmployeesSalary PRIMARY KEY(EmployeeID,SalaryDate), --    Employees CONSTRAINT FK_EmployeesSalary_EmployeeID FOREIGN KEY(EmployeeID) REFERENCES Employees(ID) ) GO --     CREATE TABLE BonusTypes( ID int IDENTITY(1,1) NOT NULL, Name nvarchar(30) NOT NULL, CONSTRAINT PK_BonusTypes PRIMARY KEY(ID) ) GO --       CREATE TABLE EmployeesBonus( EmployeeID int NOT NULL, BonusDate date NOT NULL, --   BonusAmount numeric(20,2) NOT NULL, --   BonusTypeID int NOT NULL, BonusPercent tinyint, Note nvarchar(50), --  --        1    CONSTRAINT PK_EmployeesBonus PRIMARY KEY(EmployeeID,BonusDate,BonusTypeID), --    Employees  BonusTypes CONSTRAINT FK_EmployeesBonus_EmployeeID FOREIGN KEY(EmployeeID) REFERENCES Employees(ID), CONSTRAINT FK_EmployeesBonus_BonusTypeID FOREIGN KEY(BonusTypeID) REFERENCES BonusTypes(ID) ) GO</span></span></code> </pre><br><br>  Here we had to get such a range as a result: <br><br><img src="https://habrastorage.org/files/ffd/7c5/68b/ffd7c568bc224bbaa22b98b20e7cde33.png"><br><br>  By the way, then this polygon (when it will be filled with data) you can use in order to test various requests on it - here you can try various JOIN connections, UNION unions, and groupings with data aggregation. <br><br><h2>  INSERT - insert new data </h2><br>  This operator has 2 main forms: <br><ol><li>  <b>INSERT INTO table (list_fields) VALUES (list of</b> values <b>)</b> - inserts in the new row table the values ‚Äã‚Äãof which fields are formed from the listed values </li><li>  <b>INSERT INTO table (list_field) SELECT list_</b> of values <b>FROM ...</b> - inserts into the table new rows, the values ‚Äã‚Äãof which are formed from the values ‚Äã‚Äãof the rows returned by the query. </li></ol><br><br>  In the MS SQL dialect, the word INTO can be released, which I really like and I always use it. <br><br>  Besides, it is worth noting that the first form in the MS SQL dialect from version 2008 allows you to insert several rows into the table at once: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> (_) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (_<span class="hljs-number"><span class="hljs-number">1</span></span>), (_<span class="hljs-number"><span class="hljs-number">2</span></span>), ‚Ä¶ (_N)</code> </pre><br><br><h2>  INSERT - Form 1. Go directly to the practice. </h2><br>  Fill the EmployeesSalaryHistory table with the data provided to us: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> EmployeesSalaryHistory(EmployeeID,DateFrom,DateTo,Salary) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-comment"><span class="hljs-comment">--  .. (1000,'20131101','20140531',4000), (1000,'20140601','20141230',4500), (1000,'20150101',NULL,5000), --  .. (1001,'20131101','20140630',1300), (1001,'20140701','20140930',1400), (1001,'20141001',NULL,1500), --  .. (1002,'20140101',NULL,2500), --  .. (1003,'20140601',NULL,2000), --  .. (1004,'20140701','20150131',1400), (1004,'20150201','20150131',1500), --  .. (1005,'20150101',NULL,2000)</span></span></code> </pre><br><br>  So we inserted 11 new entries into the EmployeesSalaryHistory table. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> EmployeesSalaryHistory</code> </pre><br><table><tbody><tr><th>  EmployeeID </th><th>  DateFrom </th><th>  Dateto </th><th>  Salary </th></tr><tr><td>  1000 </td><td>  2013-11-01 </td><td>  2014-05-31 </td><td>  4000.00 </td></tr><tr><td>  1000 </td><td>  2014-06-01 </td><td>  2014-12-30 </td><td>  4500.00 </td></tr><tr><td>  1000 </td><td>  2015-01-01 </td><td>  Null </td><td>  5000.00 </td></tr><tr><td>  1001 </td><td>  2013-11-01 </td><td>  2014-06-30 </td><td>  1300.00 </td></tr><tr><td>  1001 </td><td>  2014-07-01 </td><td>  2014-09-30 </td><td>  1400.00 </td></tr><tr><td>  1001 </td><td>  2014-10-01 </td><td>  Null </td><td>  1500.00 </td></tr><tr><td>  1002 </td><td>  2014-01-01 </td><td>  Null </td><td>  2500.00 </td></tr><tr><td>  1003 </td><td>  2014-06-01 </td><td>  Null </td><td>  2000.00 </td></tr><tr><td>  1004 </td><td>  2014-07-01 </td><td>  2015-01-31 </td><td>  1400.00 </td></tr><tr><td>  1004 </td><td>  2015-02-01 </td><td>  2015-01-31 </td><td>  1500.00 </td></tr><tr><td>  1005 </td><td>  2015-01-01 </td><td>  Null </td><td>  2000.00 </td></tr></tbody></table><br>  Although we in this case could not specify a list of fields, because  we insert the data of all fields and in the same form as they are listed in the table, i.e.  we could write: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> EmployeesSalaryHistory <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-comment"><span class="hljs-comment">--  .. (1000,'20131101','20140531',4000), (1000,'20140601','20141230',4500), (1000,'20150101',NULL,5000), ‚Ä¶</span></span></code> </pre><br><br>  But I would not recommend using this approach, especially if this request will be used regularly, for example, when calling from some AWP.  Again, this is fraught with the fact that the table structure can change, new fields can be added to it, or the sequence of fields can be changed, which is even more dangerous, because  this can lead to logical errors in the inserted data.  Therefore, it is better not to be lazy once again and explicitly list all the fields into which you want to insert a value. <br><br>  A few notes about INSERT: <br><ul><li>  The order of listing the fields does not matter; you can write and (EmployeeID, DateFrom, DateTo, Salary) and (DateFrom, DateTo, EmployeeID, Salary).  What is important here is that it matches the order of the values ‚Äã‚Äãthat you list in brackets after the keyword VALUES. </li><li>  It is also important that when inserting values ‚Äã‚Äãfor all required fields are specified, which are marked in the table as NOT NULL. </li><li>  You can omit the fields for which the IDENTITY option was specified or for the fields for which the default value was specified using DEFAULT, since  as their value, either the value from the counter or the default value will be substituted.  We have already made such inserts in the first part. </li><li>  In cases where the value of the counter field must be set explicitly, use the IDENTITY_INSERT option. </li></ul><br><br>  In the previous installments, we periodically used the IDENTITY_INSERT option.  Let's use this option here to create rows in the BonusTypes table, whose ID field is specified with the IDENTITY option: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--    / IDENTITY  SET IDENTITY_INSERT BonusTypes ON INSERT BonusTypes(ID,Name)VALUES (1,N''), (2,N''), (3,N'') --  / IDENTITY  SET IDENTITY_INSERT BonusTypes OFF</span></span></code> </pre><br><br>  Let's insert information on the accrual of employees of the RFP, kindly provided to us by an accountant: <br><br><table><tbody><tr><td><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  .. INSERT EmployeesSalary(EmployeeID,SalaryDate,SalaryAmount,Note)VALUES (1000,'20131130',4000,NULL), (1000,'20131231',4000,NULL), (1000,'20140115',2000,N''), (1000,'20140131',2000,NULL), (1000,'20140228',4000,NULL), (1000,'20140331',4000,NULL), (1000,'20140430',4000,NULL), (1000,'20140531',4000,NULL), (1000,'20140630',6500,N' +  2500  2014.07'), (1000,'20140731',2000,NULL), (1000,'20140831',4500,NULL), (1000,'20140930',4500,NULL), (1000,'20141031',4500,NULL), (1000,'20141130',4500,NULL), (1000,'20141230',4500,NULL), (1000,'20150131',5000,NULL), (1000,'20150228',5000,NULL), (1000,'20150331',5000,NULL)</span></span></code> </pre><br></td><td><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  .. INSERT EmployeesSalary(EmployeeID,SalaryDate,SalaryAmount,Note)VALUES (1001,'20131130',2600,N' +   2013.12'), (1001,'20140228',2600,N' 2  2014.01, 2014.02'), (1001,'20140331',1300,NULL), (1001,'20140430',1300,NULL), (1001,'20140510',300,N''), (1001,'20140520',500,N''), (1001,'20140531',500,NULL), (1001,'20140630',1300,NULL), (1001,'20140731',1400,NULL), (1001,'20140831',1400,NULL), (1001,'20140930',1400,NULL), (1001,'20141031',1500,NULL), (1001,'20141130',1500,NULL), (1001,'20141230',3000,N' +   2015.01'), (1001,'20150228',1500,NULL), (1001,'20150331',1500,NULL)</span></span></code> </pre><br></td></tr><tr><td><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  .. INSERT EmployeesSalary(EmployeeID,SalaryDate,SalaryAmount,Note)VALUES (1002,'20140131',2500,NULL), (1002,'20140228',2500,NULL), (1002,'20140331',2500,NULL), (1002,'20140430',2500,NULL), (1002,'20140531',2500,NULL), (1002,'20140630',2500,NULL), (1002,'20140731',2500,NULL), (1002,'20140831',2500,NULL), (1002,'20140930',2500,NULL), (1002,'20141031',2500,NULL), (1002,'20141130',2500,NULL), (1002,'20141230',2500,NULL), (1002,'20150131',2500,NULL), (1002,'20150228',2500,NULL), (1002,'20150331',2500,NULL)</span></span></code> </pre><br></td><td><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  .. INSERT EmployeesSalary(EmployeeID,SalaryDate,SalaryAmount,Note)VALUES (1003,'20140630',2000,NULL), (1003,'20140731',2000,NULL), (1003,'20140831',2000,NULL), (1003,'20140930',2000,NULL), (1003,'20141031',2000,NULL), (1003,'20141130',2000,NULL), (1003,'20141230',2000,NULL), (1003,'20150131',2000,NULL), (1003,'20150228',2000,NULL), (1003,'20150331',2000,NULL)</span></span></code> </pre><br></td></tr><tr><td><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  .. INSERT EmployeesSalary(EmployeeID,SalaryDate,SalaryAmount,Note)VALUES (1004,'20140731',1400,NULL), (1004,'20140831',1400,NULL), (1004,'20140930',1400,NULL), (1004,'20141031',1400,NULL), (1004,'20141130',1400,NULL), (1004,'20141212',400,N''), (1004,'20141230',1400,NULL), (1004,'20150131',1400,NULL), (1004,'20150228',1500,NULL), (1004,'20150331',1500,NULL)</span></span></code> </pre><br></td><td><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  .. INSERT EmployeesSalary(EmployeeID,SalaryDate,SalaryAmount,Note)VALUES (1005,'20150131',2000,NULL), (1005,'20150228',2000,NULL), (1005,'20150331',2000,NULL)</span></span></code> </pre><br></td></tr></tbody></table><br>  I think it makes no sense to bring the contents of the table. <br><br><h2>  INSERT - Form 2 </h2><br>  This form allows you to insert into the table the data obtained by the request. <br><br>  For the demonstration, we will fill the table with bonus accruals in one large query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> EmployeesBonus(EmployeeID,BonusDate,BonusAmount,BonusTypeID,BonusPercent) <span class="hljs-comment"><span class="hljs-comment">--    SELECT hist.EmployeeID,bdate.BonusDate,hist.Salary/100*emp.BonusPercent,1 BonusTypeID,emp.BonusPercent FROM EmployeesSalaryHistory hist JOIN ( VALUES --     -    ('20131130'), ('20131231'), ('20140131'), ('20140228'), ('20140331'), ('20140430'), ('20140531'), ('20140630'), ('20140731'), ('20140831'), ('20140930'), ('20141031'), ('20141130'), ('20141230'), ('20150131'), ('20150228'), ('20150331') ) bdate(BonusDate) ON bdate.BonusDate BETWEEN hist.DateFrom AND ISNULL(hist.DateTo,'20991231') JOIN Employees emp ON hist.EmployeeID=emp.ID WHERE emp.BonusPercent IS NOT NULL AND emp.BonusPercent&gt;0 AND NOT EXISTS( --  ,   -        SELECT * FROM ( VALUES (1001,'20140115'), (1001,'20140430'), (1001,'20141031'), (1001,'20141130'), (1001,'20150228') ) exclude(EmployeeID,BonusDate) WHERE exclude.EmployeeID=emp.ID AND exclude.BonusDate=bdate.BonusDate ) UNION ALL --    2014  -      SELECT hist.EmployeeID, '20141231' BonusDate, hist.Salary/100* CASE DepartmentID WHEN 2 THEN 10 -- 10%     WHEN 3 THEN 15 -- 15%    - ELSE 5 --    5% END BonusAmount, 2 BonusTypeID, CASE DepartmentID WHEN 2 THEN 10 -- 10%     WHEN 3 THEN 15 -- 15%    - ELSE 5 --    5% END BonusPercent FROM EmployeesSalaryHistory hist JOIN Employees emp ON hist.EmployeeID=emp.ID WHERE CAST('20141231' AS date) BETWEEN hist.DateFrom AND ISNULL(hist.DateTo,'20991231') AND emp.HireDate&lt;='20140601' UNION ALL --   SELECT EmployeeID,BonusDate,BonusAmount,3 BonusTypeID,NULL BonusPercent FROM ( VALUES (1001,'20140930',300), (1002,'20140331',500), (1002,'20140630',500), (1002,'20140930',500), (1002,'20141230',500), (1002,'20150331',500), (1004,'20140831',200) ) indiv(EmployeeID,BonusDate,BonusAmount)</span></span></code> </pre><br><br>  50 entries were to be inserted into the EmployeesBonus table. <br><br>  The result of each query combined with UNION ALL constructs you can analyze yourself.  If you have studied the basic constructs well, then you should be able to understand everything, except for possibly constructions with VALUES (tabular value designer), which appeared with MS SQL 2008. <br><br><h2>  A couple of words about the construction of VALUES </h2><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> EmployeeID,BonusDate,BonusAmount,<span class="hljs-number"><span class="hljs-number">3</span></span> BonusTypeID,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> BonusPercent <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1001</span></span>,<span class="hljs-string"><span class="hljs-string">'20140930'</span></span>,<span class="hljs-number"><span class="hljs-number">300</span></span>), (<span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20140331'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>), (<span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20140630'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>), (<span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20140930'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>), (<span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20141230'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>), (<span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20150331'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>), (<span class="hljs-number"><span class="hljs-number">1004</span></span>,<span class="hljs-string"><span class="hljs-string">'20140831'</span></span>,<span class="hljs-number"><span class="hljs-number">200</span></span>) ) indiv(EmployeeID,BonusDate,BonusAmount)</code> </pre><br><br>  If necessary, this construction can be replaced by a similar query written through UNION ALL: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1001</span></span> EmployeeID,<span class="hljs-string"><span class="hljs-string">'20140930'</span></span> BonusDate,<span class="hljs-number"><span class="hljs-number">300</span></span> BonusAmount,<span class="hljs-number"><span class="hljs-number">3</span></span> BonusTypeID,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> BonusPercent <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20140331'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20140630'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20140930'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20141230'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1002</span></span>,<span class="hljs-string"><span class="hljs-string">'20150331'</span></span>,<span class="hljs-number"><span class="hljs-number">500</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> ALL <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-number"><span class="hljs-number">1004</span></span>,<span class="hljs-string"><span class="hljs-string">'20140831'</span></span>,<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span></code> </pre><br><br>  I think comments are superfluous and it will not be difficult for you to deal with this yourself. <br><br>  So, go ahead. <br><br><h2>  INSERT + CTEs </h2><br>  Together with INSERT, you can use CTE expressions.  For example, let's rewrite the same query by transferring all subqueries to the WITH block. <br><br>  To begin, completely clear the EmployeesBonus table using the TRUNCATE TABLE operation: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> EmployeesBonus</code> </pre><br><br>  Now we will rewrite the query, taking the queries to the WITH block: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> cteBonusType1 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>( <span class="hljs-comment"><span class="hljs-comment">--    SELECT hist.EmployeeID,bdate.BonusDate,hist.Salary/100*emp.BonusPercent BonusAmount,1 BonusTypeID,emp.BonusPercent FROM EmployeesSalaryHistory hist JOIN ( VALUES --     -    ('20131130'), ('20131231'), ('20140131'), ('20140228'), ('20140331'), ('20140430'), ('20140531'), ('20140630'), ('20140731'), ('20140831'), ('20140930'), ('20141031'), ('20141130'), ('20141230'), ('20150131'), ('20150228'), ('20150331') ) bdate(BonusDate) ON bdate.BonusDate BETWEEN hist.DateFrom AND ISNULL(hist.DateTo,'20991231') JOIN Employees emp ON hist.EmployeeID=emp.ID WHERE emp.BonusPercent IS NOT NULL AND emp.BonusPercent&gt;0 AND NOT EXISTS( --  ,   -        SELECT * FROM ( VALUES (1001,'20140115'), (1001,'20140430'), (1001,'20141031'), (1001,'20141130'), (1001,'20150228') ) exclude(EmployeeID,BonusDate) WHERE exclude.EmployeeID=emp.ID AND exclude.BonusDate=bdate.BonusDate ) ), cteBonusType2 AS( --    2014  -      SELECT hist.EmployeeID, '20141231' BonusDate, hist.Salary/100* CASE DepartmentID WHEN 2 THEN 10 -- 10%     WHEN 3 THEN 15 -- 15%    - ELSE 5 --    5% END BonusAmount, 2 BonusTypeID, CASE DepartmentID WHEN 2 THEN 10 -- 10%     WHEN 3 THEN 15 -- 15%    - ELSE 5 --    5% END BonusPercent FROM EmployeesSalaryHistory hist JOIN Employees emp ON hist.EmployeeID=emp.ID WHERE CAST('20141231' AS date) BETWEEN hist.DateFrom AND ISNULL(hist.DateTo,'20991231') AND emp.HireDate&lt;='20140601' ), cteBonusType3 AS( --   SELECT EmployeeID,BonusDate,BonusAmount,3 BonusTypeID,NULL BonusPercent FROM ( VALUES (1001,'20140930',300), (1002,'20140331',500), (1002,'20140630',500), (1002,'20140930',500), (1002,'20141230',500), (1002,'20150331',500), (1004,'20140831',200) ) indiv(EmployeeID,BonusDate,BonusAmount) ) INSERT EmployeesBonus(EmployeeID,BonusDate,BonusAmount,BonusTypeID,BonusPercent) SELECT * FROM cteBonusType1 UNION ALL SELECT * FROM cteBonusType2 UNION ALL SELECT * FROM cteBonusType3</span></span></code> </pre><br><br>  As you can see, the removal of large subqueries into the WITH block has simplified the main query - made it more understandable. <br><br><h2>  UPDATE - update data </h2><br>  This operator in MS SQL has 2 forms: <br><ol><li>  <b>UPDATE table SET ... WHERE sampling_condition</b> - updating the rows of the table for which sampling condition is fulfilled.  If the WHERE clause is not specified, all rows will be updated.  This is the classic form of the UPDATE statement. </li><li>  <b>UPDATE alias SET ... FROM ...</b> - updates the data of the table participating in the FROM clause, which is specified by the specified alias.  Of course, here you can not use pseudonyms, using table names instead, but with a pseudonym in my opinion is more convenient. </li></ol><br><br>  Let's use the first form to give the dates of each employee in order.  Perform 6 separate UPDATE operations: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--      UPDATE Employees SET HireDate='20131101' WHERE ID=1000 UPDATE Employees SET HireDate='20131101' WHERE ID=1001 UPDATE Employees SET HireDate='20140101' WHERE ID=1002 UPDATE Employees SET HireDate='20140601' WHERE ID=1003 UPDATE Employees SET HireDate='20140701' WHERE ID=1004 --      FirstName UPDATE Employees SET HireDate='20150101',FirstName=NULL WHERE ID=1005</span></span></code> </pre><br><br>  We already managed to use the second form where the pseudonym was used in the first part, when we updated the PositionID and DepartmentID fields, to the values ‚Äã‚Äãreturned by the subqueries: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> PositionID=(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Positions <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>=e.Position), DepartmentID=(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Departments <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>=e.Department) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees e</code> </pre><br><br>  Now of course this and the next query will not work, because  we have removed the Position and Department fields from the Employees table.  This would be the way to submit this request using connection operations: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> PositionID=p.ID, DepartmentID=d.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees e <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Positions p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.Name=e.Position <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Departments d <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.Name=e.Department</code> </pre><br><br>  I hope the essence of the update is clear here, the rows of the Employees table will be updated here. <br><br>  First, you can make a selection to see which data will be updated and which values: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> e.ID, e.PositionID,e.DepartmentID, <span class="hljs-comment"><span class="hljs-comment">--   e.Position,e.Department, p.ID,d.ID, --   p.Name,d.Name FROM Employees e LEFT JOIN Positions p ON p.Name=e.Position LEFT JOIN Departments d ON d.Name=e.Department</span></span></code> </pre><br><br>  And then rewrite it in UPDATE: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> PositionID=p.ID, DepartmentID=d.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees e <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Positions p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.Name=e.Position <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Departments d <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.Name=e.Department</code> </pre><br><br>  <b>Eh, I can not, so let's see how it works clearly.</b> <br><br>  To do this, recall the DDL and temporarily create the Position and Department fields in the Employees table: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> Employees <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Position</span></span> <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>),Department <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>)</code> </pre><br><br>  Fill the data into them, after looking with the help of SELECT, what happens: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> e.ID, e.Position, p.Name NewPosition, e.Department, d.Name NewDepartment <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees e <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Positions p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.ID=e.PositionID <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Departments d <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.ID=e.DepartmentID</code> </pre><br><br>  Now rewrite and execute the update: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> e.Position=p.Name, e.Department=d.Name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees e <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Positions p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.ID=e.PositionID <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Departments d <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.ID=e.DepartmentID</code> </pre><br><br>  See what happened (the values ‚Äã‚Äãshould appear in 2 fields - Position and Department, located at the end of the table): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees</code> </pre><br><br>  Now this query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> PositionID=(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Positions <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>=e.Position), DepartmentID=(<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Departments <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>=e.Department) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees e</code> </pre><br><br>  And this one: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> PositionID=p.ID, DepartmentID=d.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees e <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Positions p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.Name=e.Position <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Departments d <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.Name=e.Department</code> </pre><br><br>  Work out successfully. <br><br>  Do not forget to just look at it (this is a very good habit): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> e.ID, e.PositionID,e.DepartmentID, <span class="hljs-comment"><span class="hljs-comment">--   e.Position,e.Department, p.ID,d.ID, --   p.Name,d.Name FROM Employees e LEFT JOIN Positions p ON p.Name=e.Position LEFT JOIN Departments d ON d.Name=e.Department</span></span></code> </pre><br><br>  And of course you can use the WHERE clause here: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> PositionID=p.ID, DepartmentID=d.ID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees e <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Positions p <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> p.Name=e.Position <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Departments d <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.Name=e.Department <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> d.ID=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">--     -</span></span></code> </pre><br><br>  Everything, were convinced that everything works.  If you want, you can again delete the Position and Department fields. <br><br>  The second form can also be used with a subquery: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> HireDate=<span class="hljs-string"><span class="hljs-string">'20131101'</span></span>, MiddleName=N<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> MiddleName,HireDate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>=<span class="hljs-number"><span class="hljs-number">1000</span></span>) e</code> </pre><br><br>  In this case, the subquery must explicitly return the rows of the Employees table that will be updated.  DISTINCT groupings or clauses cannot be used in a subquery, since  in this case, we will not get explicit rows from the Employees table.  And accordingly, all the updated fields should be contained in the SELECT clause, unless of course you have specified "SELECT *". <br><br>  You can also use CTE expressions with UPDATE.  For example, let's move our subquery to the WITH block: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> cteEmp <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> MiddleName,HireDate <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>=<span class="hljs-number"><span class="hljs-number">1000</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> cteEmp <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> HireDate=<span class="hljs-string"><span class="hljs-string">'20131101'</span></span>, MiddleName=N<span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre><br><br>  Go ahead. <br><br><h2>  DELETE - delete data </h2><br>  The principle of operation of DELETE is similar to the principle of operation of UPDATE, and also in MS SQL you can use 2 forms: <br><ol><li>  <b>DELETE table WHERE collection_condition</b> - deletes table rows for which selection_ condition is satisfied.  If the WHERE clause is not specified, all rows will be deleted.  This can be said the classic form of the DELETE statement (only in some DBMS do you need to write the DELETE FROM table WHERE selection condition). </li><li>  <b>DELETE alias FROM ...</b> - deletes the data of the table participating in the FROM clause, which is specified by the specified alias.  Of course, here you can not use pseudonyms, using table names instead, but with a pseudonym in my opinion is more convenient. </li></ol><br><br>  For example, using the first option: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--       DELETE Positions WHERE ID IN(6,7)</span></span></code> </pre><br><br>  With the second option, remove the remaining unused posts.  For purposes of demonstration, the request is intentionally overly complex.  First, let's see what exactly to retire (always try to do a check, otherwise you can unintentionally delete the excess, or even all the information from the table): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pos.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DISTINCT</span></span> PositionID <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees ) emp <span class="hljs-keyword"><span class="hljs-keyword">RIGHT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Positions pos <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pos.ID=emp.PositionID <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> emp.PositionID <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">--      Employees</span></span></code> </pre><br><br>  Make sure everything is fine.  Rewriting the DELETE request: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> pos <span class="hljs-comment"><span class="hljs-comment">--     FROM ( SELECT DISTINCT PositionID FROM Employees ) emp RIGHT JOIN Positions pos ON pos.ID=emp.PositionID WHERE emp.PositionID IS NULL --      Employees</span></span></code> </pre><br><br>  A subquery can also act as a Positions table, as long as it uniquely returns rows that will be deleted.  Let's add garbage to the Positions table for demonstration: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> Positions(<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>(<span class="hljs-string"><span class="hljs-string">'Test 1'</span></span>),(<span class="hljs-string"><span class="hljs-string">'Test 2'</span></span>)</code> </pre><br><br>  Now for the demonstration we use instead of the Positions table, a subquery in which only certain rows from the Positions table are selected: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> pos <span class="hljs-comment"><span class="hljs-comment">--     FROM ( SELECT DISTINCT PositionID FROM Employees ) emp RIGHT JOIN ( SELECT ID FROM Positions WHERE ID&gt;4 --     ) pos ON pos.ID=emp.PositionID WHERE emp.PositionID IS NULL --      Employees</span></span></code> </pre><br><br>  We can also use CTE expressions (subqueries executed in the WITH block).  Let's add garbage to the Positions table again: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> Positions(<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>(<span class="hljs-string"><span class="hljs-string">'Test 1'</span></span>),(<span class="hljs-string"><span class="hljs-string">'Test 2'</span></span>)</code> </pre><br><br>  And look at the same query with a CTE expression: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> ctePositionc <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Positions <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>&gt;<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">--     ) DELETE pos --     FROM ( SELECT DISTINCT PositionID FROM Employees ) emp RIGHT JOIN ctePositionc pos ON pos.ID=emp.PositionID WHERE emp.PositionID IS NULL --      Employees</span></span></code> </pre><br><br><h2>  Conclusion on INSERT, UPDATE and DELETE </h2><br>  That's basically all that I wanted to tell you about the main data modification operators - INSERT, UPDATE and DELETE. <br><br>  I believe that these operators are very easy to understand intuitively when you are able to use the constructions of the SELECT statement.  Therefore, the story about the SELECT statement was stretched into 3 parts, and the story about the modification operators was written in such a cursory form. <br><br>  And as you saw, with the modification operators, the flight of fantasy is also not limited.  But still try to write as simply and clearly as possible, be sure to first check which records will be processed with the help of SELECT, since  usually data modification is a very big responsibility. <br><br>  In addition, I will say that in the MS SQL dialect with all modification operations, you can use the TOP clause (INSERT TOP ..., UPDATE TOP ..., DELETE TOP ...), but I have never had to resort to this form, since  here it is not clear exactly which TOP records will be processed. <br><br>  If we really need to process the TOP records, then I probably would rather use the indication of the TOP option in the subquery and use the ORDER BY method in it in order to explicitly know which TOP records will be processed.  For example, add garbage again: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> Positions(<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>(<span class="hljs-string"><span class="hljs-string">'Test 1'</span></span>),(<span class="hljs-string"><span class="hljs-string">'Test 2'</span></span>)</code> </pre><br><br>  And delete the last 2 entries: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> emp <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-comment"><span class="hljs-comment">-- 2.   2   FROM Positions ORDER BY ID DESC -- 1.    ) emp</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I give more examples here to demonstrate the capabilities of the SQL language. </font><font style="vertical-align: inherit;">In real requests, try to express your intentions very precisely, so that the execution of your request does not lead to data corruption. </font><font style="vertical-align: inherit;">I say once again - be very careful, and do not be lazy to do preliminary checks.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SELECT ... INTO ... - save the result of the query in a new table </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This design allows you to save the result of the sample in the new table. </font><font style="vertical-align: inherit;">It is something intermediate between DDL and DML. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The column types of the created table will be determined based on the column types of the set obtained by the SELECT query. </font><font style="vertical-align: inherit;">If the results of expressions are present in the sample, then they must be given aliases that will serve as column names. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's select the following data and save it in the EmployeesBonusTarget table (before FROM, just write INTO and specify the name of the new table):</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bonus.EmployeeID, bonus.BonusDate, bonus.BonusAmount-bonus.BonusAmount BonusAmount, <span class="hljs-comment"><span class="hljs-comment">--   bonus.BonusTypeID, bonus.BonusPercent, bonus.Note INTO EmployeesBonusTarget --      EmployeesBonusTarget FROM EmployeesBonus bonus JOIN Employees emp ON bonus.EmployeeID=emp.ID WHERE emp.DepartmentID=3</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can update the list of tables in the object inspector and see the new table EmployeesBonusTarget: </font></font><br><br><img src="//habrastorage.org/files/f45/919/833/f459198334d54595ae071b3b65299009.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, I specifically created the table EmployeesBonusTarget, I will use it to demonstrate the MERGE operator.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A few more words about the SELECT ... INTO ... </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This construction is sometimes convenient to use when generating very complex reports that require sampling from a variety of tables. </font><font style="vertical-align: inherit;">In this case, the data is usually stored in temporary tables (#).</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> preliminarily using queries, we drop the data into temporary tables, and then use these temporary tables in other queries that form the final result: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONCAT</span></span>(LastName,<span class="hljs-string"><span class="hljs-string">' '</span></span>,FirstName,<span class="hljs-string"><span class="hljs-string">' '</span></span>,MiddleName) FullName, <span class="hljs-comment"><span class="hljs-comment">--   FullName Salary, BonusPercent, Salary/100*ISNULL(BonusPercent,0) Bonus --   Bonus INTO #EmployeesBonus --      FROM Employees</span></span></code> </pre><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-comment"><span class="hljs-comment">#EmployeesBonus b JOIN ‚Ä¶</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sometimes this construct is convenient to use to make a complete copy of all the data in the current table: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> EmployeesBackup <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> Employees</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can be used, for example, as a safety net, before making major changes to the structure of the Employees table. </font><font style="vertical-align: inherit;">You can save a copy of either all the data in the table, or only those data that the modification will affect.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if something goes wrong, you can recover the data from the Employees table from this copy. </font><font style="vertical-align: inherit;">In such cases, it is certainly good to make a preliminary backup of the database at the current time, but this is not always possible because of the huge volumes, urgency, etc. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order not to clutter up the main database, you can create a new database and make a copy of the table there:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DATABASE</span></span> TestTemp <span class="hljs-keyword"><span class="hljs-keyword">GO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> TestTemp.dbo.EmployeesBackup <span class="hljs-comment"><span class="hljs-comment">--   .. FROM Employees</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In order to see the new TestTemp database, respectively, update the list of databases in the object inspector, and you can already find this table in it. </font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On a note. </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Oracle database, there is also a construct for storing the result of the query in a new table, it looks like this:</font></font><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> EMPLOYEES_BACK <span class="hljs-comment"><span class="hljs-comment">--        EMPLOYEES_BACK AS SELECT * FROM EMPLOYEES</span></span></code> </pre><br></blockquote><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MERGE - data fusion </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This operator is well suited for data synchronization of 2 tables. </font><font style="vertical-align: inherit;">Such a task may be needed when integrating different systems, when data is transferred in portions from one system to another. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our case, let's say that the task is to synchronize the EmployeesBonusTarget table with the EmployeesBonus table. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's add some garbage to the EmployeesBonusTarget table:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> EmployeesBonusTarget(EmployeeID,BonusDate,BonusAmount,BonusTypeID,Note)<span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">9999</span></span>,<span class="hljs-string"><span class="hljs-string">'20150101'</span></span>,<span class="hljs-number"><span class="hljs-number">9999.99</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,N<span class="hljs-string"><span class="hljs-string">' '</span></span>), (<span class="hljs-number"><span class="hljs-number">9999</span></span>,<span class="hljs-string"><span class="hljs-string">'20150201'</span></span>,<span class="hljs-number"><span class="hljs-number">9999.99</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,N<span class="hljs-string"><span class="hljs-string">' '</span></span>), (<span class="hljs-number"><span class="hljs-number">9999</span></span>,<span class="hljs-string"><span class="hljs-string">'20150301'</span></span>,<span class="hljs-number"><span class="hljs-number">9999.99</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,N<span class="hljs-string"><span class="hljs-string">' '</span></span>), (<span class="hljs-number"><span class="hljs-number">9999</span></span>,<span class="hljs-string"><span class="hljs-string">'20150401'</span></span>,<span class="hljs-number"><span class="hljs-number">9999.99</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,N<span class="hljs-string"><span class="hljs-string">' '</span></span>), (<span class="hljs-number"><span class="hljs-number">9999</span></span>,<span class="hljs-string"><span class="hljs-string">'20150501'</span></span>,<span class="hljs-number"><span class="hljs-number">9999.99</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,N<span class="hljs-string"><span class="hljs-string">' '</span></span>), (<span class="hljs-number"><span class="hljs-number">9999</span></span>,<span class="hljs-string"><span class="hljs-string">'20150601'</span></span>,<span class="hljs-number"><span class="hljs-number">9999.99</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,N<span class="hljs-string"><span class="hljs-string">' '</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, using the MERGE operator, we will ensure that the data in the EmployeesBonusTarget table become the same as in the EmployeesBonus, i.e. </font><font style="vertical-align: inherit;">let's make data synchronization. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will synchronize on the basis of matching the data included in the primary key of the EmployeesBonus table (EmployeeID, BonusDate, BonusTypeID):</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If for the row of the EmployeesBonusTarget table there was no match by key, then you need to delete such rows from the EmployeesBonusTarget </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If a match is found, then you need to update the rows of EmployeesBonusTarget with the data of the corresponding row from EmployeesBonus </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If the string is in the EmployeesBonus, but it is not in the EmployeesBonusTarget, then it must be added to the EmployeesBonusTarget </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's make the implementation of all this logic using the MERGE instruction: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> EmployeesBonusTarget trg <span class="hljs-comment"><span class="hljs-comment">--   USING EmployeesBonus src --   ON trg.EmployeeID=src.EmployeeID AND trg.BonusDate=src.BonusDate AND trg.BonusTypeID=src.BonusTypeID --   -- 1.    trg       src WHEN NOT MATCHED BY SOURCE THEN DELETE -- 2.    trg     src WHEN MATCHED THEN UPDATE SET trg.BonusAmount=src.BonusAmount, trg.BonusPercent=src.BonusPercent, trg.Note=src.Note -- 3.     trg,    src WHEN NOT MATCHED BY TARGET THEN --  BY TARGET  , .. NOT MATCHED = NOT MATCHED BY TARGET INSERT(EmployeeID,BonusDate,BonusAmount,BonusTypeID,BonusPercent,Note) VALUES(src.EmployeeID,src.BonusDate,src.BonusAmount,src.BonusTypeID,src.BonusPercent,src.Note);</span></span></code> </pre><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This construction should end with ";".</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After completing the query, compare the 2 tables, their data should be the same. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The MERGE construct is somewhat similar to a conditional CASE statement; it also contains WHEN blocks, when the conditions are met, an action takes place, in this case, deletion (DELETE), update (UPDATE) or append (INSERT). Data modification is performed in the receiver table. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The request may be the source. For example, we synchronize only the data of department 3 and, for example, exclude the block ‚ÄúNOT MATCHED BY SOURCE‚Äù so that the data does not succeed if it does not match:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> EmployeesBonusTarget trg <span class="hljs-comment"><span class="hljs-comment">--   USING ( SELECT bonus.* FROM EmployeesBonus bonus JOIN Employees emp ON bonus.EmployeeID=emp.ID WHERE emp.DepartmentID=3 ) src --  ON trg.EmployeeID=src.EmployeeID AND trg.BonusDate=src.BonusDate AND trg.BonusTypeID=src.BonusTypeID --   -- 2.    trg     src WHEN MATCHED THEN UPDATE SET trg.BonusAmount=src.BonusAmount, trg.BonusPercent=src.BonusPercent, trg.Note=src.Note -- 3.     trg,    src WHEN NOT MATCHED BY TARGET THEN --  BY TARGET  , .. NOT MATCHED = NOT MATCHED BY TARGET INSERT(EmployeeID,BonusDate,BonusAmount,BonusTypeID,BonusPercent,Note) VALUES(src.EmployeeID,src.BonusDate,src.BonusAmount,src.BonusTypeID,src.BonusPercent,src.Note);</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I showed the work of the construction of the MERGE in its most general form. </font><font style="vertical-align: inherit;">With it, you can implement a variety of schemes for merging data, for example, you can include additional conditions in WHEN blocks (WHEN MATCHED AND ... THEN). </font><font style="vertical-align: inherit;">This is a very powerful design that allows, in appropriate cases, to reduce the amount of code and to combine, within one operator, the functionality of all three operators - INSERT, UPDATE and DELETE. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And naturally, with the MERGE construct, CTE expressions can also be used:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> cteBonus <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bonus.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> EmployeesBonus bonus <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> Employees emp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bonus.EmployeeID=emp.ID <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> emp.DepartmentID=<span class="hljs-number"><span class="hljs-number">3</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> EmployeesBonusTarget trg <span class="hljs-comment"><span class="hljs-comment">--   USING cteBonus src --  ON trg.EmployeeID=src.EmployeeID AND trg.BonusDate=src.BonusDate AND trg.BonusTypeID=src.BonusTypeID --   -- 2.    trg     src WHEN MATCHED THEN UPDATE SET trg.BonusAmount=src.BonusAmount, trg.BonusPercent=src.BonusPercent, trg.Note=src.Note -- 3.     trg,    src WHEN NOT MATCHED BY TARGET THEN --  BY TARGET  , .. NOT MATCHED = NOT MATCHED BY TARGET INSERT(EmployeeID,BonusDate,BonusAmount,BonusTypeID,BonusPercent,Note) VALUES(src.EmployeeID,src.BonusDate,src.BonusAmount,src.BonusTypeID,src.BonusPercent,src.Note);</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In general, I tried to set a direction for you, in more detail, if necessary, study it yourself. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using the OUTPUT construct </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The OUTPUT construction makes it possible to obtain information on rows that have been added, deleted or changed as a result of the execution of DML commands INSERT, DELETE, UPDATE and MERGE. </font><font style="vertical-align: inherit;">This construction represents an extension for data modification operations and in each DBMS can be implemented in its own way, or be absent altogether. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The OUTPUT design has 2 main forms:</font></font><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OUTPUT expression_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - used to return the result as a set</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OUTPUT expression_list INTO host_table (field_list)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - used to insert the result into the specified table</font></font></li></ol><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the first form.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add new entries to the Positions table:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> Positions(<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OUTPUT</span></span> inserted.* <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (N<span class="hljs-string"><span class="hljs-string">'Test 1'</span></span>), (N<span class="hljs-string"><span class="hljs-string">'Test 2'</span></span>), (N<span class="hljs-string"><span class="hljs-string">'Test 3'</span></span>)</code> </pre><br><br>    ,      Positions           . <br><br>   ¬´inserted¬ª       .     ¬´inserted.*¬ª      ,     Positions (ID  Name). <br><br>    OUTPUT           ¬´inserted._¬ª,      : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> Positions(<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">OUTPUT</span></span> inserted.ID,inserted.Name,<span class="hljs-string"><span class="hljs-string">'I'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (N<span class="hljs-string"><span class="hljs-string">'Test 4'</span></span>), (N<span class="hljs-string"><span class="hljs-string">'Test 5'</span></span>), (N<span class="hljs-string"><span class="hljs-string">'Test 6'</span></span>)</code> </pre><br><br>   DML  DELETE,           ¬´deleted¬ª: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> Positions <span class="hljs-keyword"><span class="hljs-keyword">OUTPUT</span></span> deleted.ID,deleted.Name,<span class="hljs-string"><span class="hljs-string">'D'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> N<span class="hljs-string"><span class="hljs-string">'Test%'</span></span></code> </pre><br><br>   DML  UPDATE,     : <br><ul><li> deleted ‚Äì  ,      ,     ( ) </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inserted - in order to get new row values </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let's demonstrate on the Employees table: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> Employees <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> LastName=N<span class="hljs-string"><span class="hljs-string">''</span></span>, FirstName=N<span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTPUT</span></span> deleted.ID, deleted.LastName [ ], deleted.FirstName [ ], inserted.ID, inserted.LastName [ ], inserted.FirstName [ ] <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>=<span class="hljs-number"><span class="hljs-number">1005</span></span></code> </pre><br><table><tbody><tr><th>  ID </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Old name </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Old Name </font></font></th><th>  ID </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> New Surname </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> New name </font></font></th></tr><tr><td>  1005 </td><td>  Null </td><td>  Null </td><td>  1005 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alexandrov </font></font></td><td>  Alexander </td></tr></tbody></table><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the case of MERGE, we can also use ‚Äúinserted‚Äù and ‚Äúdeleted‚Äù to access the values ‚Äã‚Äãof the processed rows. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, let's create the PositionsTarget table, which will be followed by an example with MERGE:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CAST</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, <span class="hljs-comment"><span class="hljs-comment">--      IDENTITY Name+'-old' Name --   INTO PositionsTarget FROM Positions WHERE ID=2 --    </span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add garbage to PositionsTarget: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> PositionsTarget(<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">100</span></span>,N<span class="hljs-string"><span class="hljs-string">'Qwert'</span></span>), (<span class="hljs-number"><span class="hljs-number">101</span></span>,N<span class="hljs-string"><span class="hljs-string">'Asdf'</span></span>)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run the MERGE command with the OUTPUT construct: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">MERGE</span></span> PositionsTarget trg <span class="hljs-comment"><span class="hljs-comment">--   USING Positions src --   ON trg.ID=src.ID --   -- 1.    trg       src WHEN NOT MATCHED BY SOURCE THEN DELETE -- 2.    trg     src WHEN MATCHED THEN UPDATE SET trg.Name=src.Name -- 3.     trg,    src WHEN NOT MATCHED BY TARGET THEN --  BY TARGET  , .. NOT MATCHED = NOT MATCHED BY TARGET INSERT(ID,Name) VALUES(src.ID,src.Name) OUTPUT deleted.ID Old_ID, deleted.Name Old_Name, inserted.ID New_ID, inserted.Name New_Name, CASE WHEN deleted.ID IS NOT NULL AND inserted.ID IS NOT NULL THEN 'U' WHEN deleted.ID IS NOT NULL THEN 'D' WHEN inserted.ID IS NOT NULL THEN 'I' END OperType;</span></span></code> </pre><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Old_id </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Old_name </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> New_ID </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> New_name </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opertype </font></font></th></tr><tr><td>  Null </td><td>  Null </td><td>  one </td><td>  Accountant </td><td>  I </td></tr><tr><td>  2 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Old director </font></font></td><td>  2 </td><td>  Director </td><td>  U </td></tr><tr><td>  Null </td><td>  Null </td><td>  3 </td><td>  Programmer </td><td>  I </td></tr><tr><td>  Null </td><td>  Null </td><td>  four </td><td>  Senior programmer </td><td>  I </td></tr><tr><td>  100 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qwert </font></font></td><td>  Null </td><td>  Null </td><td>  D </td></tr><tr><td>  101 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Asdf </font></font></td><td>  Null </td><td>  Null </td><td>  D </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think the purpose of the first form is clear - to make a modification and get the result in the form of a set that can be returned to the user. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the second form.</font></font></b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The OUTPUT construction has a more important purpose - it allows not only to receive, but also to fix (OUTPUT ... INTO ...) information about what has already happened after the fact, that is, after performing the modification operation. </font><font style="vertical-align: inherit;">It may be useful in the case of logged actions. </font><font style="vertical-align: inherit;">In some cases, it can be used as a good alternative to triggers (for transparency of actions). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's create a demo table to log changes to the Positions table:</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> PositionsLog( LogID <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> PK_PositionsLog PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>, Old_Name <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), New_Name <span class="hljs-keyword"><span class="hljs-keyword">nvarchar</span></span>(<span class="hljs-number"><span class="hljs-number">30</span></span>), LogType <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, LogDateTime datetime <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span> SYSDATETIME() )</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And now with the help of the construction (OUTPUT ... INTO ...) we will make an entry in this table: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  INSERT Positions(Name) OUTPUT inserted.ID,inserted.Name,'I' INTO PositionsLog(ID,New_Name,LogType) VALUES (N'Test 1'), (N'Test 2') --  UPDATE Positions SET Name+=' - new' --     "+=",  Name=Name+' - new' OUTPUT deleted.ID, deleted.Name, inserted.Name, 'U' INTO PositionsLog(ID,Old_Name,New_Name,LogType) WHERE Name LIKE N'Test%' --  DELETE Positions OUTPUT deleted.ID,deleted.Name,'D' INTO PositionsLog(ID,Old_Name,LogType) WHERE Name LIKE N'Test%'</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> See what happened: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> PositionsLog</code> </pre><br><br><h2> TRUNCATE TABLE ‚Äì DDL-     </h2><br>    DDL-       ‚Äì     .       MSDN. <br><br><blockquote> <b>   MSDN.</b> TRUNCATE TABLE ‚Äì     ,       .  TRUNCATE TABLE    DELETE   WHERE,  TRUNCATE TABLE          . <br><br>      (   IDENTITY),       ,    .     ,    ,  1.    ,   DELETE. <br><br>  TRUNCATE TABLE        FOREIGN KEY. ,   ,    ,  . </blockquote><br><br>  Example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> EmployeesBonusTarget</code> </pre><br><br><h2>      </h2><br>    ,    . <br><br>           ,                   . <br><br>         , ,      ,      .      SELECT. <br><br>         ,    ,    ,      SELECT ‚Ä¶ INTO ‚Ä¶ <br><br> ,      . <br><br><h2>  1 ‚Äì    SELECT </h2><br> ,       ,    . <br><br>           : <br><ul><li> PIVOT </li><li> UNPIVOT </li><li> GROUP BY ROLLUP </li><li> GROUP BY GROUPING SETS </li></ul><br>       ,    .    ,      ,      . <br><br> <b>     GROUP BY+CASE   PIVOT</b> <br><br>    ,         GROUP BY  CASE-.  ,      : <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--      GROUP BY SELECT EmployeeID, SUM(CASE WHEN MONTH(BonusDate)=1 THEN BonusAmount END) BonusAmount1, SUM(CASE WHEN MONTH(BonusDate)=2 THEN BonusAmount END) BonusAmount2, SUM(CASE WHEN MONTH(BonusDate)=3 THEN BonusAmount END) BonusAmount3, SUM(CASE WHEN MONTH(BonusDate)=4 THEN BonusAmount END) BonusAmount4, SUM(CASE WHEN MONTH(BonusDate)=5 THEN BonusAmount END) BonusAmount5, SUM(CASE WHEN MONTH(BonusDate)=6 THEN BonusAmount END) BonusAmount6, SUM(CASE WHEN MONTH(BonusDate)=7 THEN BonusAmount END) BonusAmount7, SUM(CASE WHEN MONTH(BonusDate)=8 THEN BonusAmount END) BonusAmount8, SUM(CASE WHEN MONTH(BonusDate)=9 THEN BonusAmount END) BonusAmount9, SUM(CASE WHEN MONTH(BonusDate)=10 THEN BonusAmount END) BonusAmount10, SUM(CASE WHEN MONTH(BonusDate)=11 THEN BonusAmount END) BonusAmount11, SUM(CASE WHEN MONTH(BonusDate)=12 THEN BonusAmount END) BonusAmount12, SUM(BonusAmount) TotalBonusAmount FROM EmployeesBonus WHERE BonusDate BETWEEN '20140101' AND '20141231' --    2014  GROUP BY EmployeeID</span></span></code> </pre><br><br>  ,         PIVOT: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--      PIVOT SELECT EmployeeID, [1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12], ISNULL([1],0)+ISNULL([2],0)+ISNULL([3],0)+ISNULL([4],0)+ ISNULL([5],0)+ISNULL([6],0)+ISNULL([7],0)+ISNULL([8],0)+ ISNULL([9],0)+ISNULL([10],0)+ISNULL([11],0)+ISNULL([12],0) TotalBonusAmount FROM ( /*          : -  BonusMonth  BonusAmount     PIVOT -  ,      EmployeeID,      */ SELECT EmployeeID, MONTH(BonusDate) BonusMonth, BonusAmount FROM EmployeesBonus WHERE BonusDate BETWEEN '20140101' AND '20141231' ) q PIVOT(SUM(BonusAmount) FOR BonusMonth IN([1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12])) p</span></span></code> </pre><br><br>   PIVOT  SUM,    ,       (COUNT, AVG, MIN, MAX, ‚Ä¶). <br><br> <b> UNPIVOT</b> <br><br>   ,    UNPIVOT.        DemoPivotTable: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> EmployeeID, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount1, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount2, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount3, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount4, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount5, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount6, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount7, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount8, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount9, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount10, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount11, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MONTH</span></span>(BonusDate)=<span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> BonusAmount <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>) BonusAmount12, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(BonusAmount) TotalBonusAmount <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> DemoPivotTable <span class="hljs-comment"><span class="hljs-comment">--      FROM EmployeesBonus WHERE BonusDate BETWEEN '20140101' AND '20141231' GROUP BY EmployeeID</span></span></code> </pre><br><br>   ,        : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> DemoPivotTable</code> </pre><br><br>       UNPIVOT: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--  UNPIVOT SELECT *, CAST(REPLACE(ColumnLabel,'BonusAmount','') AS int) BonusMonth FROM DemoPivotTable UNPIVOT(BonusAmount FOR ColumnLabel IN(BonusAmount1,BonusAmount2,BonusAmount3,BonusAmount4, BonusAmount5,BonusAmount6,BonusAmount7,BonusAmount8, BonusAmount9,BonusAmount10,BonusAmount11,BonusAmount12)) u</span></span></code> </pre><br><br>  ,  NULL     . <br><br>    ,            . <br><br> <b>GROUP BY ROLLUP  GROUP BY GROUPING SETS</b> <br><br>        . <br><br>  : <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- GROUP BY ROLLUP   GROUPING SELECT --GROUPING(YEAR(bonus.BonusDate)) g1, --GROUPING(bonus.EmployeeID) g2, --GROUPING(emp.Name) g3, CASE WHEN GROUPING(YEAR(bonus.BonusDate))=1 THEN ' ' WHEN GROUPING(bonus.EmployeeID)=1 THEN '  '+CAST(YEAR(bonus.BonusDate) AS varchar(4))+' ' END RowTitle, emp.Name, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=1 THEN bonus.BonusAmount END) BonusAmountQ1, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=2 THEN bonus.BonusAmount END) BonusAmountQ2, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=3 THEN bonus.BonusAmount END) BonusAmountQ3, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=4 THEN bonus.BonusAmount END) BonusAmountQ4, SUM(bonus.BonusAmount) TotalBonusAmount FROM EmployeesBonus bonus JOIN Employees emp ON bonus.EmployeeID=emp.ID GROUP BY ROLLUP(YEAR(bonus.BonusDate),bonus.EmployeeID,emp.Name) --     GROUPING HAVING NOT(GROUPING(YEAR(bonus.BonusDate))=0 AND GROUPING(bonus.EmployeeID)=0 AND GROUPING(emp.Name)=1)</span></span></code> </pre><br><br>  ,    GROUPING,   g1, g2  g3,      ,     HAVING. <br><br>  : <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- GROUP BY ROLLUP   GROUPING_ID SELECT /* GROUPING_ID (a, b, c) input = GROUPING(a) + GROUPING(b) + GROUPING(c)  001 =  1  011 =  3  111 =  7 */ --GROUPING_ID(YEAR(bonus.BonusDate),bonus.EmployeeID,emp.Name) gID, CASE GROUPING_ID(YEAR(bonus.BonusDate),bonus.EmployeeID,emp.Name) WHEN 7 THEN ' ' WHEN 3 THEN '  '+CAST(YEAR(bonus.BonusDate) AS varchar(4))+' ' END RowTitle, emp.Name, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=1 THEN bonus.BonusAmount END) BonusAmountQ1, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=2 THEN bonus.BonusAmount END) BonusAmountQ2, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=3 THEN bonus.BonusAmount END) BonusAmountQ3, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=4 THEN bonus.BonusAmount END) BonusAmountQ4, SUM(bonus.BonusAmount) TotalBonusAmount FROM EmployeesBonus bonus JOIN Employees emp ON bonus.EmployeeID=emp.ID GROUP BY ROLLUP(YEAR(bonus.BonusDate),bonus.EmployeeID,emp.Name) --     GROUPING_ID HAVING GROUPING_ID(YEAR(bonus.BonusDate),bonus.EmployeeID,emp.Name)&lt;&gt;1</span></span></code> </pre><br><br>   ,      gID    HAVING. <br><br>  : <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- GROUP BY GROUPING SETS   GROUPING_ID SELECT /* GROUPING_ID (a, b, c) input = GROUPING(a) + GROUPING(b) + GROUPING(c)  001 =  1  011 =  3  111 =  7 */ --GROUPING_ID(YEAR(bonus.BonusDate),bonus.EmployeeID,emp.Name) gID, CASE GROUPING_ID(YEAR(bonus.BonusDate),bonus.EmployeeID,emp.Name) WHEN 7 THEN ' ' WHEN 3 THEN '  '+CAST(YEAR(bonus.BonusDate) AS varchar(4))+' ' END RowTitle, emp.Name, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=1 THEN bonus.BonusAmount END) BonusAmountQ1, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=2 THEN bonus.BonusAmount END) BonusAmountQ2, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=3 THEN bonus.BonusAmount END) BonusAmountQ3, SUM(CASE WHEN DATEPART(QUARTER,bonus.BonusDate)=4 THEN bonus.BonusAmount END) BonusAmountQ4, SUM(bonus.BonusAmount) TotalBonusAmount FROM EmployeesBonus bonus JOIN Employees emp ON bonus.EmployeeID=emp.ID GROUP BY GROUPING SETS( (YEAR(bonus.BonusDate),bonus.EmployeeID,emp.Name), --   (YEAR(bonus.BonusDate)), --    () --   )</span></span></code> </pre><br><br>   GROUPING SET        ,       HAVING. <br><br>  Those.  ,  GROUP BY ROLLUP   GROUP BY GROUPING SETS,     . <br><br> <b>  FULL JOIN</b> <br><br>              , : <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   FULL JOIN WITH cteBonus AS( SELECT YEAR(BonusDate) BonusYear, EmployeeID, SUM(CASE WHEN DATEPART(QUARTER,BonusDate)=1 THEN BonusAmount END) BonusAmountQ1, SUM(CASE WHEN DATEPART(QUARTER,BonusDate)=2 THEN BonusAmount END) BonusAmountQ2, SUM(CASE WHEN DATEPART(QUARTER,BonusDate)=3 THEN BonusAmount END) BonusAmountQ3, SUM(CASE WHEN DATEPART(QUARTER,BonusDate)=4 THEN BonusAmount END) BonusAmountQ4, SUM(BonusAmount) TotalBonusAmount FROM EmployeesBonus GROUP BY YEAR(BonusDate),EmployeeID ), cteSalary AS( SELECT YEAR(SalaryDate) SalaryYear, EmployeeID, SUM(CASE WHEN DATEPART(QUARTER,SalaryDate)=1 THEN SalaryAmount END) SalaryAmountQ1, SUM(CASE WHEN DATEPART(QUARTER,SalaryDate)=2 THEN SalaryAmount END) SalaryAmountQ2, SUM(CASE WHEN DATEPART(QUARTER,SalaryDate)=3 THEN SalaryAmount END) SalaryAmountQ3, SUM(CASE WHEN DATEPART(QUARTER,SalaryDate)=4 THEN SalaryAmount END) SalaryAmountQ4, SUM(SalaryAmount) TotalSalaryAmount FROM EmployeesSalary GROUP BY YEAR(SalaryDate),EmployeeID ) SELECT ISNULL(s.SalaryYear,b.BonusYear) AccYear, ISNULL(s.EmployeeID,b.EmployeeID) EmployeeID, s.SalaryAmountQ1,s.SalaryAmountQ2,s.SalaryAmountQ3,s.SalaryAmountQ4, s.TotalSalaryAmount, b.BonusAmountQ1,b.BonusAmountQ2,b.BonusAmountQ3,b.BonusAmountQ4, b.TotalBonusAmount, ISNULL(s.TotalSalaryAmount,0)+ISNULL(b.TotalBonusAmount,0) TotalAmount FROM cteSalary s FULL JOIN cteBonus b ON s.EmployeeID=b.EmployeeID AND s.SalaryYear=b.BonusYear</span></span></code> </pre><br><br>   ,      FULL JOIN.   ,       WITH. <br><br><h2>  2 ‚Äì OVER    </h2><br>  OVER     ,   ,   SELECT (   ).   OVER       SELECT, ..   , ,   WHERE. <br><br>    OVER       .             . ,          ,       OVER        (    ,       )    . <br><br>   ,     ,    : <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--    SET IDENTITY_INSERT Positions ON INSERT Positions(ID,Name)VALUES (10,N''), (11,N'') SET IDENTITY_INSERT Positions OFF</span></span></code> </pre><br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">--   INSERT Employees(ID,Name,DepartmentID,PositionID,HireDate,Salary,Email)VALUES (1006,N' ..',4,10,'20150215',1800,'a.antonov@test.tt'), (1007,N' ..',5,11,'20150405',1200,'m.maksimov@test.tt'), (1008,N' ..',5,11,'20150410',1200,'d.danolov@test.tt'), (1009,N' ..',5,11,'20150415',1200,'o.ostapov@test.tt')</span></span></code> </pre><br><br> <b> OVER     ,   </b> <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>, DepartmentID, Salary, <span class="hljs-comment"><span class="hljs-comment">--      SUM(Salary) OVER() AllSalary, --        SUM(Salary) OVER(PARTITION BY DepartmentID) DepartmentSalary, --         CAST(Salary/SUM(Salary) OVER(PARTITION BY DepartmentID)*100 AS numeric(20,3)) SalaryPercentOfDepSalary, -- -   COUNT(*) OVER() AllEmplCount, -- -    COUNT(*) OVER(PARTITION BY DepartmentID) DepEmplCount FROM Employees</span></span></code> </pre><br><table><tbody><tr><th>  ID </th><th>  Name </th><th> DepartmentID </th><th> Salary </th><th> AllSalary </th><th> DepartmentSalary </th><th> SalaryPercentOfDepSalary </th><th> AllEmplCount </th><th> DepEmplCount </th></tr><tr><td>  1005 </td><td>  .. </td><td>  Null </td><td> 2000.00 </td><td> 19900.00 </td><td> 2000.00 </td><td> 100.000 </td><td>  ten </td><td>  one </td></tr><tr><td>  1000 </td><td>  Ivanov I.I. </td><td>  one </td><td> 5000.00 </td><td> 19900.00 </td><td> 5000.00 </td><td> 100.000 </td><td>  ten </td><td>  one </td></tr><tr><td>  1002 </td><td>  .. </td><td>  2 </td><td> 2500.00 </td><td> 19900.00 </td><td> 2500.00 </td><td> 100.000 </td><td>  ten </td><td>  one </td></tr><tr><td>  1003 </td><td>  .. </td><td>  3 </td><td> 2000.00 </td><td> 19900.00 </td><td> 5000.00 </td><td> 40.000 </td><td>  ten </td><td>  3 </td></tr><tr><td>  1004 </td><td>  .. </td><td>  3 </td><td> 1500.00 </td><td> 19900.00 </td><td> 5000.00 </td><td> 30.000 </td><td>  ten </td><td>  3 </td></tr><tr><td>  1001 </td><td>  .. </td><td>  3 </td><td> 1500.00 </td><td> 19900.00 </td><td> 5000.00 </td><td> 30.000 </td><td>  ten </td><td>  3 </td></tr><tr><td> 1006 </td><td>  .. </td><td>  four </td><td> 1800.00 </td><td> 19900.00 </td><td> 1800.00 </td><td> 100.000 </td><td>  ten </td><td>  one </td></tr><tr><td>  1007 </td><td>  .. </td><td>  five </td><td> 1200.00 </td><td> 19900.00 </td><td> 3600.00 </td><td> 33.333 </td><td>  ten </td><td>  3 </td></tr><tr><td> 1008 </td><td>  .. </td><td>  five </td><td> 1200.00 </td><td> 19900.00 </td><td> 3600.00 </td><td> 33.333 </td><td>  ten </td><td>  3 </td></tr><tr><td> 1009 </td><td>  .. </td><td>  five </td><td> 1200.00 </td><td> 19900.00 </td><td> 3600.00 </td><td> 33.333 </td><td>  ten </td><td>  3 </td></tr></tbody></table><br>  ¬´PARTITION BY¬ª      ,      ¬´GROUP BY¬ª. <br><br>      ,  , , ¬´PARTITION BY DepartmentID,PositionID¬ª, ¬´PARTITION BY DepartmentID,YEAR(HireDate)¬ª. <br><br>      ,    ‚Äì AVG, MIN, MAX, COUNT  DISTINCT. <br><br> <b>   </b> <br><br>       ROW_NUMBER. <br><br>     Name     LastName,FirstName,MiddleName: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>, <span class="hljs-comment"><span class="hljs-comment">--     Name ROW_NUMBER() OVER(ORDER BY Name) EmpNoByName, --     LastName,FirstName,MiddleName ROW_NUMBER() OVER(ORDER BY LastName,FirstName,MiddleName) EmpNoByFullName FROM Employees ORDER BY Name</span></span></code> </pre><br><table><tbody><tr><th>  ID </th><th>  Name </th><th> EmpNoByName </th><th> EmpNoByFullName </th></tr><tr><td>  1005 </td><td>  .. </td><td>  one </td><td>  6 </td></tr><tr><td>  1003 </td><td>  .. </td><td>  2 </td><td>  7 </td></tr><tr><td> 1006 </td><td>  .. </td><td>  3 </td><td>  one </td></tr><tr><td> 1008 </td><td>  .. </td><td>  four </td><td>  2 </td></tr><tr><td>  1000 </td><td>  Ivanov I.I. </td><td>  five </td><td>  eight </td></tr><tr><td>  1007 </td><td>  .. </td><td>  6 </td><td>  3 </td></tr><tr><td>  1004 </td><td>  .. </td><td>  7 </td><td>  four </td></tr><tr><td> 1009 </td><td>  .. </td><td>  eight </td><td>  five </td></tr><tr><td>  1001 </td><td>  .. </td><td>  9 </td><td>  9 </td></tr><tr><td>  1002 </td><td>  .. </td><td>  ten </td><td>  ten </td></tr></tbody></table><br>      OVER   ¬´ORDER BY¬ª. <br><br>    ,     OVER    ¬´PARTITION BY¬ª: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> emp.ID, emp.Name EmpName, dep.Name DepName, <span class="hljs-comment"><span class="hljs-comment">--     ,    Name ROW_NUMBER() OVER(PARTITION BY dep.ID ORDER BY emp.Name) EmpNoInDepByName FROM Employees emp LEFT JOIN Departments dep ON emp.DepartmentID=dep.ID ORDER BY dep.Name,emp.Name</span></span></code> </pre><br><table><tbody><tr><th>  ID </th><th> EmpName </th><th> DepName </th><th> EmpNoInDepByName </th></tr><tr><td>  1005 </td><td>  .. </td><td>  Null </td><td>  one </td></tr><tr><td>  1000 </td><td>  Ivanov I.I. </td><td>  Administration </td><td>  one </td></tr><tr><td>  1002 </td><td>  .. </td><td>  Accounting </td><td>  one </td></tr><tr><td>  1003 </td><td>  .. </td><td>  IT </td><td>  one </td></tr><tr><td>  1004 </td><td>  .. </td><td>  IT </td><td>  2 </td></tr><tr><td>  1001 </td><td>  .. </td><td>  IT </td><td>  3 </td></tr><tr><td> 1008 </td><td>  .. </td><td>  Logistics </td><td>  one </td></tr><tr><td>  1007 </td><td>  .. </td><td>  Logistics </td><td>  2 </td></tr><tr><td> 1009 </td><td>  .. </td><td>  Logistics </td><td>  3 </td></tr><tr><td> 1006 </td><td>  .. </td><td>    </td><td>  one </td></tr></tbody></table><br><br> <b> </b> ‚Äì    ,  .  2  ,   (RANK)    (DENSE_RANK). <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> emp.ID, emp.Name EmpName, emp.PositionID, <span class="hljs-comment"><span class="hljs-comment">-- -     COUNT(*) OVER(PARTITION BY emp.PositionID) EmpCountInPos, --    -     -     RANK() OVER(ORDER BY emp.PositionID) RankValue, --    ‚Äì   () DENSE_RANK() OVER(ORDER BY emp.PositionID) DenseRankValue FROM Employees emp LEFT JOIN Positions pos ON emp.PositionID=pos.ID</span></span></code> </pre><br><table><tbody><tr><th>  ID </th><th> EmpName </th><th> PositionID </th><th> EmpCountInPos </th><th> RankValue </th><th> DenseRankValue </th></tr><tr><td>  1005 </td><td>  .. </td><td>  Null </td><td>  one </td><td>  one </td><td>  one </td></tr><tr><td>  1002 </td><td>  .. </td><td>  one </td><td>  one </td><td>  2 </td><td>  2 </td></tr><tr><td>  1000 </td><td>  Ivanov I.I. </td><td>  2 </td><td>  one </td><td>  3 </td><td>  3 </td></tr><tr><td>  1001 </td><td>  .. </td><td>  3 </td><td>  2 </td><td>  four </td><td>  four </td></tr><tr><td>  1004 </td><td>  .. </td><td>  3 </td><td>  2 </td><td>  four </td><td>  four </td></tr><tr><td>  1003 </td><td>  .. </td><td>  four </td><td>  one </td><td>  6 </td><td>  five </td></tr><tr><td> 1006 </td><td>  .. </td><td>  ten </td><td>  one </td><td>  7 </td><td>  6 </td></tr><tr><td>  1007 </td><td>  .. </td><td>  eleven </td><td>  3 </td><td>  eight </td><td>  7 </td></tr><tr><td> 1008 </td><td>  .. </td><td>  eleven </td><td>  3 </td><td>  eight </td><td>  7 </td></tr><tr><td> 1009 </td><td>  .. </td><td>  eleven </td><td>  3 </td><td>  eight </td><td>  7 </td></tr></tbody></table><br><br> <b> : LAG()  LEAD(), FIRST_VALUE()  LAST_VALUE()</b> <br><br>          . <br><br>  LAG()  LEAD(): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> CurrEmpID, <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> CurrEmpName, <span class="hljs-comment"><span class="hljs-comment">--    LAG(ID) OVER(ORDER BY ID) PrevEmpID, LAG(Name) OVER(ORDER BY ID) PrevEmpName, LAG(ID,2) OVER(ORDER BY ID) PrevPrevEmpID, LAG(Name,2,'not found') OVER(ORDER BY ID) PrevPrevEmpName, --    LEAD(ID) OVER(ORDER BY ID) NextEmpID, LEAD(Name) OVER(ORDER BY ID) NextEmpName, LEAD(ID,2) OVER(ORDER BY ID) NextNextEmpID, LEAD(Name,2,'not found') OVER(ORDER BY ID) NextNextEmpName FROM Employees ORDER BY ID</span></span></code> </pre><br><table><tbody><tr><th> CurrEmpID </th><th> CurrEmpName </th><th> PrevEmpID </th><th> PrevEmpName </th><th> PrevPrevEmpID </th><th> PrevPrevEmpName </th><th> NextEmpID </th><th> NextEmpName </th><th> NextNextEmpID </th><th> NextNextEmpName </th></tr><tr><td>  1000 </td><td>  Ivanov I.I. </td><td>  Null </td><td>  Null </td><td>  Null </td><td> not found </td><td>  1001 </td><td>  .. </td><td>  1002 </td><td>  .. </td></tr><tr><td>  1001 </td><td>  .. </td><td>  1000 </td><td>  Ivanov I.I. </td><td>  Null </td><td> not found </td><td>  1002 </td><td>  .. </td><td>  1003 </td><td>  .. </td></tr><tr><td>  1002 </td><td>  .. </td><td>  1001 </td><td>  .. </td><td>  1000 </td><td>  Ivanov I.I. </td><td>  1003 </td><td>  .. </td><td>  1004 </td><td>  .. </td></tr><tr><td>  1003 </td><td>  .. </td><td>  1002 </td><td>  .. </td><td>  1001 </td><td>  .. </td><td>  1004 </td><td>  .. </td><td>  1005 </td><td>  .. </td></tr><tr><td>  1004 </td><td>  .. </td><td>  1003 </td><td>  .. </td><td>  1002 </td><td>  .. </td><td>  1005 </td><td>  .. </td><td> 1006 </td><td>  .. </td></tr><tr><td>  1005 </td><td>  .. </td><td>  1004 </td><td>  .. </td><td>  1003 </td><td>  .. </td><td> 1006 </td><td>  .. </td><td>  1007 </td><td>  .. </td></tr><tr><td> 1006 </td><td>  .. </td><td>  1005 </td><td>  .. </td><td>  1004 </td><td>  .. </td><td>  1007 </td><td>  .. </td><td> 1008 </td><td>  .. </td></tr><tr><td>  1007 </td><td>  .. </td><td> 1006 </td><td>  .. </td><td>  1005 </td><td>  .. </td><td> 1008 </td><td>  .. </td><td> 1009 </td><td>  .. </td></tr><tr><td> 1008 </td><td>  .. </td><td>  1007 </td><td>  .. </td><td> 1006 </td><td>  .. </td><td> 1009 </td><td>  .. </td><td>  Null </td><td> not found </td></tr><tr><td> 1009 </td><td>  .. </td><td> 1008 </td><td>  .. </td><td>  1007 </td><td>  .. </td><td>  Null </td><td>  Null </td><td>  Null </td><td> not found </td></tr></tbody></table><br>           ,                . <br><br>     ,     ¬´PARTITION BY¬ª  OVER, , ¬´OVER(PARTITION BY emp.DepartmentID ORDER BY emp.ID)¬ª. <br><br>  FIRST_VALUE()  LAST_VALUE(): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> CurrEmpID, <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> CurrEmpName, DepartmentID, <span class="hljs-comment"><span class="hljs-comment">--     FIRST_VALUE(ID) OVER(PARTITION BY DepartmentID ORDER BY ID) FirstEmpID, FIRST_VALUE(Name) OVER(PARTITION BY DepartmentID ORDER BY ID) FirstEmpName, --     LAST_VALUE(ID) OVER(PARTITION BY DepartmentID ORDER BY ID RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) LastEmpID, LAST_VALUE(Name) OVER(PARTITION BY DepartmentID ORDER BY ID RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) LastEmpName FROM Employees ORDER BY DepartmentID,ID</span></span></code> </pre><br><table><tbody><tr><th> CurrEmpID </th><th> CurrEmpName </th><th> DepartmentID </th><th> FirstEmpID </th><th> FirstEmpName </th><th> LastEmpID </th><th> LastEmpName </th></tr><tr><td>  1005 </td><td>  .. </td><td>  Null </td><td>  1005 </td><td>  .. </td><td>  1005 </td><td>  .. </td></tr><tr><td>  1000 </td><td>  Ivanov I.I. </td><td>  one </td><td>  1000 </td><td>  Ivanov I.I. </td><td>  1000 </td><td>  Ivanov I.I. </td></tr><tr><td>  1002 </td><td>  .. </td><td>  2 </td><td>  1002 </td><td>  .. </td><td>  1002 </td><td>  .. </td></tr><tr><td>  1001 </td><td>  .. </td><td>  3 </td><td>  1001 </td><td>  .. </td><td>  1004 </td><td>  .. </td></tr><tr><td>  1003 </td><td>  .. </td><td>  3 </td><td>  1001 </td><td>  .. </td><td>  1004 </td><td>  .. </td></tr><tr><td>  1004 </td><td>  .. </td><td>  3 </td><td>  1001 </td><td>  .. </td><td>  1004 </td><td>  .. </td></tr><tr><td> 1006 </td><td>  .. </td><td>  four </td><td> 1006 </td><td>  .. </td><td> 1006 </td><td>  .. </td></tr><tr><td>  1007 </td><td>  .. </td><td>  five </td><td>  1007 </td><td>  .. </td><td> 1009 </td><td>  .. </td></tr><tr><td> 1008 </td><td>  .. </td><td>  five </td><td>  1007 </td><td>  .. </td><td> 1009 </td><td>  .. </td></tr><tr><td> 1009 </td><td>  .. </td><td>  five </td><td>  1007 </td><td>  .. </td><td> 1009 </td><td>  .. </td></tr></tbody></table><br> ,   .   ,   RANGE. <br><br> <b> RANGE  ROWS</b> <br><br>     ¬´RANGE¬ª  ¬´ROWS¬ª,     ,     OVER.       -   .     . <br><br><blockquote> <b> .</b>               ,             . </blockquote><br><br>      : <br><ol><li>   (RANGE)   </li><li>   (ROWS)    </li></ol><br><br><blockquote>       : <br>  <b>Option 1:</b> <br> {ROWS | RANGE} {{UNBOUNDED | } PRECEDING | CURRENT ROW} <br><br>  <b>Option 2:</b> <br> {ROWS | RANGE} <br> BETWEEN <br> {{UNBOUNDED PRECEDING | CURRENT ROW | <br> {UNBOUNDED |  1}{PRECEDING | FOLLOWING}} <br> AND <br> {{UNBOUNDED FOLLOWING | CURRENT ROW | <br> {UNBOUNDED |  2}{PRECEDING | FOLLOWING}} <br></blockquote><br><br>       Excel  : <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>, Salary, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(Salary) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>() Sum1, <span class="hljs-comment"><span class="hljs-comment">--    - " "  " " SUM(Salary) OVER(ORDER BY ID ROWS BETWEEN unbounded preceding AND unbounded following) Sum2, --       - " "  " " SUM(Salary) OVER(ORDER BY ID ROWS BETWEEN unbounded preceding AND current row) Sum3, --        - " "  " " SUM(Salary) OVER(ORDER BY ID ROWS BETWEEN current row AND unbounded following) Sum4, --     - "1 "  "3 " SUM(Salary) OVER(ORDER BY ID ROWS BETWEEN 1 following AND 3 following) Sum5, --    - "1 "  "1 " SUM(Salary) OVER(ORDER BY ID ROWS BETWEEN 1 preceding AND 1 following) Sum6, --   " "  "" SUM(Salary) OVER(ORDER BY ID ROWS 3 preceding) Sum7, --  " "  "" SUM(Salary) OVER(ORDER BY ID ROWS unbounded preceding) Sum8 FROM Employees ORDER BY ID</span></span></code> </pre><br><table><tbody><tr><th>  ID </th><th> Salary </th><th> Sum1 </th><th> Sum2 </th><th> Sum3 </th><th> Sum4 </th><th> Sum5 </th><th> Sum6 </th><th> Sum7 </th><th> Sum8 </th></tr><tr><td>  1000 </td><td> 5000.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 5000.00 </td><td> 19900.00 </td><td> 6000.00 </td><td> 6500.00 </td><td> 5000.00 </td><td> 5000.00 </td></tr><tr><td>  1001 </td><td> 1500.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 6500.00 </td><td> 14900.00 </td><td> 6000.00 </td><td> 9000.00 </td><td> 6500.00 </td><td> 6500.00 </td></tr><tr><td>  1002 </td><td> 2500.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 9000.00 </td><td> 13400.00 </td><td> 5500.00 </td><td> 6000.00 </td><td> 9000.00 </td><td> 9000.00 </td></tr><tr><td>  1003 </td><td> 2000.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 11000.00 </td><td> 10900.00 </td><td> 5300.00 </td><td> 6000.00 </td><td> 11000.00 </td><td> 11000.00 </td></tr><tr><td>  1004 </td><td> 1500.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 12500.00 </td><td> 8900.00 </td><td> 5000.00 </td><td> 5500.00 </td><td> 7500.00 </td><td> 12500.00 </td></tr><tr><td>  1005 </td><td> 2000.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 14500.00 </td><td> 7400.00 </td><td>  4200.00 </td><td> 5300.00 </td><td> 8000.00 </td><td> 14500.00 </td></tr><tr><td> 1006 </td><td> 1800.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 16300.00 </td><td> 5400.00 </td><td> 3600.00 </td><td> 5000.00 </td><td> 7300.00 </td><td> 16300.00 </td></tr><tr><td>  1007 </td><td> 1200.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 17500.00 </td><td> 3600.00 </td><td> 2400.00 </td><td>  4200.00 </td><td> 6500.00 </td><td> 17500.00 </td></tr><tr><td> 1008 </td><td> 1200.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 18700.00 </td><td> 2400.00 </td><td> 1200.00 </td><td> 3600.00 </td><td> 6200.00 </td><td> 18700.00 </td></tr><tr><td> 1009 </td><td> 1200.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 1200.00 </td><td>  Null </td><td> 2400.00 </td><td> 5400.00 </td><td> 19900.00 </td></tr></tbody></table><br>  RANGE   ,       ,    .      ORDER BY       . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> PositionID, Salary, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(Salary) <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> PositionID) Sum1, <span class="hljs-comment"><span class="hljs-comment">--      PositionID - " "  " " SUM(Salary) OVER(ORDER BY PositionID RANGE BETWEEN unbounded preceding AND unbounded following) Sum2, --      PositionID     - " "  " " (&lt;=PositionID) SUM(Salary) OVER(ORDER BY PositionID RANGE BETWEEN unbounded preceding AND current row) Sum3, --           - " "  " " (&gt;=PositionID) SUM(Salary) OVER(ORDER BY PositionID RANGE BETWEEN current row AND unbounded following) Sum4, /*     RANGE  MS SQL  ,   Oracle  .   MSDN:  RANGE     &lt;  &gt; PRECEDING   &lt;  &gt; FOLLOWING. &lt;  &gt; PRECEDING   &lt;  &gt;         .       RANGE. &lt;  &gt; FOLLOWING   &lt;  &gt;         .       RANGE. */ --      - "+1"  "+3" ( BETWEEN PositionID+1 AND PositionID+3) --SUM(Salary) OVER(ORDER BY PositionID RANGE BETWEEN 1 following AND 3 following) Sum5, --      - "-1"  "+1" ( BETWEEN PositionID-1 AND PositionID+1) --SUM(Salary) OVER(ORDER BY PositionID RANGE BETWEEN 1 preceding AND 1 following) Sum6, --       - "-3"  "" ( BETWEEN PositionID-3 AND PositionID) --SUM(Salary) OVER(ORDER BY PositionID RANGE 3 preceding) Sum7, --    "  "  "" (&lt;=PositionID) SUM(Salary) OVER(ORDER BY PositionID RANGE unbounded preceding) Sum8 FROM Employees ORDER BY PositionID</span></span></code> </pre><br><table><tbody><tr><th> PositionID </th><th> Salary </th><th> Sum1 </th><th> Sum2 </th><th> Sum3 </th><th> Sum4 </th><th> Sum8 </th></tr><tr><td>  Null </td><td> 2000.00 </td><td> 2000.00 </td><td> 19900.00 </td><td> 2000.00 </td><td> 19900.00 </td><td> 2000.00 </td></tr><tr><td>  one </td><td> 2500.00 </td><td> 2500.00 </td><td> 19900.00 </td><td> 4500.00 </td><td> 17900.00 </td><td> 4500.00 </td></tr><tr><td>  2 </td><td> 5000.00 </td><td> 5000.00 </td><td> 19900.00 </td><td> 9500.00 </td><td> 15400.00 </td><td> 9500.00 </td></tr><tr><td>  3 </td><td> 1500.00 </td><td> 3000.00 </td><td> 19900.00 </td><td> 12500.00 </td><td> 10400.00 </td><td> 12500.00 </td></tr><tr><td>  3 </td><td> 1500.00 </td><td> 3000.00 </td><td> 19900.00 </td><td> 12500.00 </td><td> 10400.00 </td><td> 12500.00 </td></tr><tr><td>  four </td><td> 2000.00 </td><td> 2000.00 </td><td> 19900.00 </td><td> 14500.00 </td><td> 7400.00 </td><td> 14500.00 </td></tr><tr><td>  ten </td><td> 1800.00 </td><td> 1800.00 </td><td> 19900.00 </td><td> 16300.00 </td><td> 5400.00 </td><td> 16300.00 </td></tr><tr><td>  eleven </td><td> 1200.00 </td><td> 3600.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 3600.00 </td><td> 19900.00 </td></tr><tr><td>  eleven </td><td> 1200.00 </td><td> 3600.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 3600.00 </td><td> 19900.00 </td></tr><tr><td>  eleven </td><td> 1200.00 </td><td> 3600.00 </td><td> 19900.00 </td><td> 19900.00 </td><td> 3600.00 </td><td> 19900.00 </td></tr></tbody></table><br><br><h2>  Conclusion </h2><br>   ,  ,        SQL (DDL, DML). <br><br> ,          ,   ,           SQL. <br><br> , ,    . <br><br>  Thanks for attention!  That's all for now. <br><br>  Ps.   ,      ,       ! </div><p>Source: <a href="https://habr.com/ru/post/256169/">https://habr.com/ru/post/256169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256157/index.html">Weekly assembly Vivaldi 1.0.156.2</a></li>
<li><a href="../256159/index.html">Arabic localization: words, words, words</a></li>
<li><a href="../256163/index.html">Do experience and achievements in sports programming in real life and work help or hinder?</a></li>
<li><a href="../256165/index.html">Retrieving Entity Mentions and Textocat API Search</a></li>
<li><a href="../256167/index.html">Legs, wings ... the main thing is the tail! The human body in terms of Intel RealSense</a></li>
<li><a href="../256171/index.html">The hacker group Sednit uses 0day exploits for cyber attacks</a></li>
<li><a href="../256173/index.html">Realization of some tasks for self-assembled NAS</a></li>
<li><a href="../256175/index.html">Your code does not interest anyone</a></li>
<li><a href="../256177/index.html">HP Integrity NonStop: Availability Is Key</a></li>
<li><a href="../256179/index.html">Online broadcast Microsoft Developer Tour in Novosibirsk April 22</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>