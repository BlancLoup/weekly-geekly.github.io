<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing DNS proxy on Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long wanted to solve the problem with advertising. The easiest way to do this on all devices turned out to be raising your DNS server with bloc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing DNS proxy on Go</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/wt/_k/9b/wt_k9byeikdbemab1xqi7dyhfwa.jpeg"></div><br>  I have long wanted to solve the problem with advertising.  The easiest way to do this on all devices turned out to be raising your DNS server with blocking requests for receiving IP addresses of advertising domains. <br><a name="habracut"></a><br>  First of all, I started using <a href="https://ru.wikipedia.org/wiki/Dnsmasq">dnsmasq</a> , but I wanted to download lists from the Internet and get some usage statistics.  That's why I decided to write my server. <br><br>  Of course, it is not written entirely from scratch, all work with DNS is taken from <a href="https://github.com/miekg/dns">this library</a> . <br><br><h2>  Configuration </h2><br>  The program starts, of course, by loading the configuration file.  Immediately I thought about the need to automatically upload the config when it was changed in order to avoid restarting the server.  The fsnotify package came in handy for this. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Config structure: <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Nameservers []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`yaml:"nameservers"`</span></span> Blocklist []<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`yaml:"blocklist"`</span></span> BlockAddress4 <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`yaml:"blockAddress4"`</span></span> BlockAddress6 <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`yaml:"blockAddress6"`</span></span> ConfigUpdate <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-string"><span class="hljs-string">`yaml:"configUpdate"`</span></span> UpdateInterval time.Duration <span class="hljs-string"><span class="hljs-string">`yaml:"updateInterval"`</span></span> }</code> </pre> <br>  Here the most interesting point is tracking configuration file updates.  With the help of the library, this is done quite simply: we create a Watcher, hook to it a file and listen to events from the channel.  True go! <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configWatcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { watcher, err := fsnotify.NewWatcher() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> watcher.Close() err = watcher.Add(*configFile) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> event := &lt;-watcher.Events: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> event.Op&amp;fsnotify.Write == fsnotify.Write { log.Println(<span class="hljs-string"><span class="hljs-string">"Config file updated, reload config"</span></span>) c, err := loadConfig() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"Bad config: "</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"Config successfuly updated"</span></span>) config = c <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !c.ConfigUpdate { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> err := &lt;-watcher.Errors: log.Println(<span class="hljs-string"><span class="hljs-string">"error:"</span></span>, err) } } }</code> </pre><br></div></div><br><h2>  Blacklist </h2><br>  Of course, since the goal is to block unwanted sites, they need to be stored somewhere.  For this, with a small load, a simple hash table of empty structures will be suitable, where a blocked domain is used as a key.  I want to note that you must have a point at the end. <br>  But since we do not have a simultaneous read / write, we can do without mutexes. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> BlackList <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { data <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *BlackList)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(server </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { server = strings.Trim(server, <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(server) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !strings.HasSuffix(server, <span class="hljs-string"><span class="hljs-string">"."</span></span>) { server += <span class="hljs-string"><span class="hljs-string">"."</span></span> } b.data[server] = <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *BlackList)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Contains</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(server </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := b.data[server] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok }</code> </pre><br></div></div><br><h2>  Caching </h2><br>  Initially, I thought to do without it, after all, all my devices do not create a significant number of requests.  But one evening, my server was somehow discovered and flooded with the same request with a frequency of ~ 100 rps.  Yes, this is not much, but the requests are proxied to real namespace servers (in my case, Google) and it would be very unpleasant to get a lock. <br><br>  The main problem of caching is a large number of different requests and they need to be stored separately, so a two-level hash table has turned out. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Cache <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Get(reqType <span class="hljs-keyword"><span class="hljs-keyword">uint16</span></span>, domain <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) dns.RR Set(reqType <span class="hljs-keyword"><span class="hljs-keyword">uint16</span></span>, domain <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, ip dns.RR) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> CacheItem <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Ip dns.RR Die time.Time } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MemoryCache <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { cache <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">uint16</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*CacheItem locker sync.RWMutex } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *MemoryCache)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reqType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16</span></span></span></span><span class="hljs-function"><span class="hljs-params">, domain </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dns</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RR</span></span></span></span> { c.locker.RLock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> c.locker.RUnlock() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m, ok := c.cache[reqType]; ok { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ip, ok := m[domain]; ok { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ip.Die.After(time.Now()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ip.Ip } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *MemoryCache)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Set</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reqType </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint16</span></span></span></span><span class="hljs-function"><span class="hljs-params">, domain </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, ip dns.RR)</span></span></span></span> { c.locker.Lock() <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> c.locker.Unlock() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*CacheItem m, ok := c.cache[reqType] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { m = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*CacheItem) c.cache[reqType] = m } m[domain] = &amp;CacheItem{ Ip: ip, Die: time.Now().Add(time.Duration(ip.Header().Ttl) * time.Second), } }</code> </pre><br></div></div><br><h2>  Handler </h2><br>  Of course, the main part of the program is an incoming requests handler, so I left it for dessert.  The basic logic is something like this: we receive a request, check its presence in the blacklist, check the availability in the cache, proxy the request to the real server. <br><br>  The main interest is the function lukapa.  In it, we simultaneously send a request to all servers at once (if we have time before the answer arrives) and wait for a successful response from at least one of them. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lookup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(req *dns.Msg)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*dns.Msg, error)</span></span></span></span> { c := &amp;dns.Client{ Net: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, ReadTimeout: time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>, WriteTimeout: time.Second * <span class="hljs-number"><span class="hljs-number">5</span></span>, } qName := req.Question[<span class="hljs-number"><span class="hljs-number">0</span></span>].Name res := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> *dns.Msg, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wg sync.WaitGroup L := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(nameserver </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> wg.Done() r, _, err := c.Exchange(req, nameserver) totalRequestsToGoogle.Inc() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Printf(<span class="hljs-string"><span class="hljs-string">"%s socket error on %s"</span></span>, qName, nameserver) log.Printf(<span class="hljs-string"><span class="hljs-string">"error:%s"</span></span>, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> &amp;&amp; r.Rcode != dns.RcodeSuccess { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.Rcode == dns.RcodeServerFailure { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> res &lt;- r: <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: } } ticker := time.NewTicker(<span class="hljs-number"><span class="hljs-number">5</span></span> * time.Second) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ticker.Stop() <span class="hljs-comment"><span class="hljs-comment">// Start lookup on each nameserver top-down, in every second for _, nameserver := range config.Nameservers { wg.Add(1) go L(nameserver) // but exit early, if we have an answer select { case r := &lt;-res: return r, nil case &lt;-ticker.C: continue } } // wait for all the namservers to finish wg.Wait() select { case r := &lt;-res: return r, nil default: return nil, errors.New("can't resolve ip for" + qName) } }</span></span></code> </pre><br></div></div><br><h2>  Metrics </h2><br>  For metrics we will use the client from prometheus.  It is used very simply, you first need to declare a counter, then register it and call the Inc () method in the right place.  The main thing to remember is to launch the web server with the prometheus handler so that it can read the metrics. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( totalRequestsTcp = prometheus.NewCounter(prometheus.CounterOpts(prometheus.Opts{ Namespace: <span class="hljs-string"><span class="hljs-string">"dns"</span></span>, Subsystem: <span class="hljs-string"><span class="hljs-string">"requests"</span></span>, Name: <span class="hljs-string"><span class="hljs-string">"total"</span></span>, Help: <span class="hljs-string"><span class="hljs-string">"total requests"</span></span>, ConstLabels: <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, }, })) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runPrometheus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { prometheus.MustRegister(totalRequestsTcp) http.Handle(<span class="hljs-string"><span class="hljs-string">"/metrics"</span></span>, promhttp.Handler()) log.Fatal(http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":9970"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) }</code> </pre><br></div></div><br>  I think the main needs no introduction and description.  In this article, the code is presented in an abbreviated format. <br><br>  The full code can be viewed in the <a href="https://github.com/GoWebProd/goDNS">repository</a> (fixes and additions are of course welcome).  Also in the repository there is a file for Docker and an example CI configuration for Gitlab. <br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/348280/">https://habr.com/ru/post/348280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348268/index.html">Lightning Network: Solution for the last kilometer</a></li>
<li><a href="../348270/index.html">Another reality of the financial market</a></li>
<li><a href="../348272/index.html">The sum of the sums of arithmetic progressions</a></li>
<li><a href="../348276/index.html">Richard Hamming: Chapter 14. Digital Filters - 1</a></li>
<li><a href="../348278/index.html">The digest of fresh materials from the world of the frontend for the last week No. 300 (January 29 - February 4, 2018)</a></li>
<li><a href="../348282/index.html">Implicitness</a></li>
<li><a href="../348284/index.html">Smart Contract Calling System in the Ethereum blockchain</a></li>
<li><a href="../348286/index.html">SOLID</a></li>
<li><a href="../348288/index.html">Announcement of Moscow Kubernetes Online: we have collected the pitfalls of k8s</a></li>
<li><a href="../348290/index.html">Timlides does not happen much</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>