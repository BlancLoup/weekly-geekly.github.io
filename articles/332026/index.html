<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Libdispatch. How to make the application responsive</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To increase the responsiveness of the application, it is necessary to correctly break the execution of tasks into several threads. The set of technolo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Libdispatch. How to make the application responsive</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/14d/c1b/ee6/14dc1bee6d6b45428dadef9c14b76059.png" alt="image"></p><br><br><p>  To increase the responsiveness of the application, it is necessary to correctly break the execution of tasks into several threads.  The set of technologies in the hands of the iOS developer is the following.  The methods are represented by increasing the level of abstraction. </p><br><ul><li>  <strong>Pthreads</strong> , or POSIX threads.  Library for low-level work with multithreading.  Defined as a set of types and functions in C. More information can be found <a href="https://habrahabr.ru/post/326138/">here</a> . </li><li> <strong>Background selectors</strong> .  This is sending a message to the object that will be executed on the specified stream.  In code, this is a selector called <code>performSelector</code> and various parameters (for example, <code>performSelectorOnMainThread:withObject:waitUntilDone:</code> .  <a href="https://developer.apple.com/documentation/objectivec/nsobject/1417922-performselector">Documentation</a> </li><li>  <strong>NSThread</strong> .  Presented as basic tools for working with threads.  Familiarize yourself with the conceptual <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html">document</a> on work with streams and <a href="https://developer.apple.com/documentation/foundation/thread">documentation</a> . </li><li>  <strong>Grand Central Dispatch</strong> .  Block-based library - anonymous sections of code, or closures.  The working title is <strong>libdispatch</strong> . </li><li>  <strong>NSOperation</strong> .  Built on the basis of GCD.  It is worth noting that the operation itself is an abstract entity and in practice it is worth using <code>NSInvocationOperation</code> and <code>NSBlockOperation</code> . </li></ul><br><p>  This article will talk about GCD issues. </p><a name="habracut"></a><br><p>  Libdispatch is Apple's library for multi-threading.  GCD was first introduced in Mac OS X 10.6.  The source code for the libdispatch library, which implements GCD services, was released under the Apache license on September 10, 2009. There are also library versions for other Unix operating systems, such as FreeBSD and Linux.  For the rest, there is no support.  True, there are unofficial <a href="https://blog.quiscalusmexicanus.org/2011/04/25/grand-central-dispatch-for-win32-the-port/">builds of</a> libdispatch from users. </p><br><p>  Let's talk about the internal structure of the library.  We make an assumption on the basis of which technology it was developed.  Options: pthreads, background selectors, NSThread.  The second option is definitely not suitable - since the basis of libdispatch is working with blocks.  Then from the assumptions remains <strong>NSThread</strong> or <strong>pthreads</strong> .  Now consider in more detail. </p><br><h2 id="ustroystvo-gcd">  GCD device </h2><br><h3 id="zagolovochnye-fayly-vseya-ios">  Header files "all iOS" </h3><br><p>  It all started when a <a href="https://github.com/JaviSoto/iOS10-Runtime-Headers">collection of</a> header files of all libraries and protocols in Obj-C was discovered for one of the most recent versions of the operating system (at that time it was iOS 10).  The project contains public frameworks - most of those with which almost all developers are familiar, from AVFoundation to WebKit.  Surprisingly, even in public frameworks there are such properties and methods that are not available in the original Apple documentation.  For example, the <a href="">trustedTimestamp</a> property of a <a href="">CLLocation</a> object. </p><br><p>  Further, a large section of private libraries is found, for example, PhysicsKit.  By the way, there is an interesting <a href="">timeline for the life of</a> private frameworks - I recommend reading it.  It is worth it to spend a few hours and study the interesting and partially opened insides of iOS (do not rejoice too much, there are only generated header files).  The rest is reserved for libraries and protocols.  There are not so many libraries there, and their naming is similar: lib + name.  For example, libobjc or libxpc.  But there are so many protocols there that even github does not display them all. </p><br><p>  And yes, among other things, libdispatch was discovered.  As for the other libraries in the repository, for it there are only header files.  Among them there are no hints on the library device.  The generated header files for classes in most cases contain several standard methods, among which are: <code>debugDescription</code> , <code>description</code> , <code>hash</code> and <code>superclass</code> .  In this case, the only option is to research the open <a href="https://github.com/apple/swift-corelibs-libdispatch">source</a> Apple. </p><br><h3 id="obzor-otkrytogo-repozitoriya">  Open repository overview </h3><br><p>  Consider what the libdispatch repository consists of.  These are source codes and header files of several levels.  Levels include a public (what you used to think of as libdispatch), an internal and private level of access.  It is worth paying attention to the documentation that is provided for the command line utility.  Among other things, you can stumble upon the configuration files cmake and xcodeconfig, as well as tests in large quantities. </p><br><p>  The most interesting places for us: </p><br><ul><li>  a wrapper for Swift (since the standard dispatch has not gone away and no one has altered it), which is in the source code of the project </li><li>  An Xcode project in which you can more conveniently review the structure and structure of the library. </li></ul><br><p>  The library repository is actively maintained - regular commits from developers several times a month, which are actively repairing broken support and compilation on various platforms.  The project is considered complete, and some problems, such as <a href="https://bugs.swift.org/browse/SR-449">building a library on El Capitan</a> , remain unresolved until now. </p><br><h3 id="opisanie-struktury-proekta-bazovye-obekty">  Description of the project structure.  Basic objects </h3><br><p>  Consider what a queue in libdispatch is.  The queue is defined by three macros, the definition can be found in the file - <a href="">queue_internal.h</a> . </p><br><p>  Determination of the queue begins with the inclusion of <code>DISPATCH_STRUCT_HEADER</code> - this is done for all objects of the project.  This general header consists of the definition of <code>OS_OBJECT_HEADER</code> ( <code>OS_OBJECT_HEADER</code> itself <code>OS_OBJECT_HEADER</code> required for a virtual table of operations ‚Äî vtable and reference counting), several fields, including the field of the target queue.  The target queue (target queue) is represented by one of the base queues ‚Äî usually the default queue. </p><br><p>  Next, the queue is determined by the macros <code>DISPATCH_QUEUE_HEADER</code> and <code>DISPATCH_QUEUE_CACHELINE_PADDING</code> .  The latter is needed to make sure that the structure fits optimally in the processor's cache line.  The <code>DISPATCH_QUEUE_HEADER</code> macro is used to define queue metadata that includes the width (the number of threads in the pool), the debugging number, the regular number, and the list of tasks to be executed. </p><br><p>  The base type for the work is represented as continuation.  It is defined as the inclusion of a single <code>DISPATCH_CONTINUATION_HEADER</code> macro.  The macro definition includes a pointer to an operation table, various flags, a priority, pointers to a context, functions, data, and the next operation. </p><br><p>  By examining the private header files and library sources, it was discovered that libdispatch can be compiled using the libpqw library or the POSIX Thread API. </p><br><h3 id="obzor-programmnogo-interfeysa-biblioteki-libpqw">  Libpqw Library Program Interface Overview </h3><br><p>  So, the latest version of GCD is built over a wrapper over the pthread library - <a href="https://github.com/mheily/libpwq">libpwq</a> , which also <a href="https://github.com/mheily/libpwq">includes</a> Apple.  The main idea of ‚Äã‚Äãthe library is to add a level of abstraction.  The first version was released in 2011, at the moment the latest stable version is 0.9 from 2014. </p><br><p>  The library is a direct add-on over <code>&lt;pthread.h&gt;</code> , introducing a new level of abstraction.  It involves working not with threads, but with task queues: creating, setting priorities, adding tasks for execution.  For example, adding a task is done by calling <code>pthread_workqueue_additem_np</code> , where the queue is passed, a pointer to the functions for the task and its arguments. </p><br><p>  Inside the library, the main manager is a manager who operates with queues and a list of tasks.  The manager always has at least one working queue.  The queue is represented by a regular structure with an identifier, a priority (there are only three - high, low and default priority), various flags and a pointer to the first task.  Tasks are organized as a list.  The task itself is a structure with a function pointer, flags, arguments, and a pointer to the next task, if any. </p><br><p>  Of course, it is possible to compile libdispatch without the libpwq library, in which case pthreads will be used.  This is due to the fact that it was announced much earlier than the release of this library (on Mac OS X Snow Leopard in 2009). </p><br><h3 id="derevo-vyzovov-ot-dispatch_async-do-sozdaniya-potoka-ili-otpravki-elementa-v-ochered">  Call tree from dispatch_async before creating stream or sending item to queue </h3><br><p>  Let's take a look at some existing solution in libdispatch as an example implementation.  Take everyone's favorite call </p><br><pre> <code class="hljs cs">DispatchQueue.main.<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> { <span class="hljs-comment"><span class="hljs-comment">// some asynchronous code... }</span></span></code> </pre> <br><p>  Actually implementation is trivial.  The swift wrapper itself will be discussed later in this article.  We can only say that CDispatch is a compiled GCD C library for the Swift project. </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DispatchQueue</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DispatchObject</span></span></span><span class="hljs-class"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DispatchQueue</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">var</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DispatchQueue</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">DispatchQueue</span></span>(queue: _swift_dispatch_get_main_queue()) } ... <span class="hljs-meta"><span class="hljs-meta">@available</span></span>(<span class="hljs-type"><span class="hljs-type">OSX</span></span> <span class="hljs-number"><span class="hljs-number">10.10</span></span>, iOS <span class="hljs-number"><span class="hljs-number">8.0</span></span>, *) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(execute workItem: DispatchWorkItem)</span></span></span></span> { <span class="hljs-type"><span class="hljs-type">CDispatch</span></span>.dispatch_async(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.__wrapped, workItem._block) } ... }</code> </pre> <br><p>  In the code section above, we see how the main queue is created and what the asynchronous code call is.  Analysis of the GCD device under the hood will start from the well-known dispatch_async. </p><br><p>  The basic call tree from the moment of launching an asynchronous task to the moment of creating a thread (pthread_create) or sending a task to a lower-level library (libpwq) will be as follows: </p><br><ul><li> <code>dispatch_async</code> </li> <li> <code>_dispatch_continuation_async</code> </li> <li> <code>_dispatch_continuation_async2</code> </li> <li> <code>_dispatch_async_f2</code> </li> <li> <code>_dispatch_continuation_push</code> </li> <li>  <code>dx_push</code> macro </li><li> <code>_dispatch_queue_push</code> </li> <li> <code>_dispatch_queue_push_inline</code> </li> <li>  <code>dx_wakeup</code> macro </li><li> <code>_dispatch_queue_class_wakeup</code> </li> <li> <code>_dispatch_queue_class_wakeup_with_override</code> </li> <li> <code>_dispatch_queue_class_wakeup_with_override_slow</code> </li> <li> <code>_dispatch_root_queue_push_override_stealer</code> </li> <li> <code>_dispatch_root_queue_push_inline</code> </li> <li> <code>_dispatch_global_queue_poke</code> </li> <li> <code>_dispatch_global_queue_poke_slow</code> </li> <li>  call <code>pthread_create</code> or <code>pthread_workqueue_additem_np</code> </li></ul><br><p>  Let's go through the structure of the most interesting challenges.  Original <code>dispatch_async</code> method: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch_async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dispatch_queue_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">dispatch_block_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> work)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">dispatch_continuation_t</span></span> dc = _dispatch_continuation_alloc(); <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> dc_flags = DISPATCH_OBJ_CONSUME_BIT; _dispatch_continuation_init(dc, dq, work, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, dc_flags); _dispatch_continuation_async(dq, dc); }</code> </pre> <br><p>  What is going on here?  First, memory is allocated to a previously defined type - continuation.  It is worth recalling the accepted concept, according to which <code>_t</code> means a pointer to a <code>_s</code> structure.  In this case, somewhere in the header files there will be a definition (for example, <code>typedef struct dispatch_queue_s *dispatch_queue_t;</code> ).  Secondly, we set flags to initialize this structure, which are transmitted along with the type of the block and the queue for the execution of the block instructions.  For example, the fourth parameter determines the priority, which is set to 0 by default. </p><br><p>  By allocating memory for the structure and initializing it, control is passed on to two functions ( <code>_dispatch_continuation_async</code> and <code>_dispatch_continuation_async2</code> ).  The first function is a noninline ( <code>noinline</code> ) stub for calling another already inline ( <code>inline</code> ) function, simultaneously dereferencing the flags, and checking for the presence of a barrier.  The task of the second function is to perform the appropriate checks and send continuations for asynchronous execution to the queue.  <code>_dispatch_continuation_push</code> means using the <code>_dispatch_continuation_push</code> function.  This happens only if the queue is not full or in the absence of a barrier. </p><br><p>  In the case of a barrier, control can be transferred to the <code>_dispatch_async_f2</code> function, where the check is performed and the <a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html">QoS</a> level for the continuation is set - otherwise the priority.  However, the following function is still called <code>_dispatch_continuation_push</code> , which calls the macro <code>dx_push</code> under it.  The macro expands to a rather cumbersome construction, and ultimately this leads to a call to the <code>_dispatch_queue_push_inline</code> function.  Her unwrapped wrapper is intentionally skipped. </p><br><p>  The main reason why functions are so often embedded in one un-recessed is a reduction in the number of calls, but at the same time control the complexity of the code.  In this way, an acceptable balance is achieved.  The cumbersome constructions with dereferencing pointers and their pointers easily fit into small functions, which the compiler then embeds into the call places.  Well, deal with a smaller amount of data from the point of view of a person is always easier. </p><br><p>  The <code>_dispatch_queue_push_inline</code> function <code>_dispatch_queue_push_inline</code> built on a large number of macros.  Among the most interesting low-level constructions (which, by the way, are used throughout the entire libdispatch source code) are the following: </p><br><ul><li>  the function <code>atomic_load_explicit</code> is in the standard library for atomic work and provides atomic pointer dereferencing.  Any pointer logic in a project uses calls from the header file - <code>&lt;stdatomic.h&gt;</code> ; </li><li>  the <code>__builtin_expect()</code> and <code>__builtin_unreachable()</code> functions, as well as other <code>__builtin</code> constructs, are related to low-level optimizations for the compiler ‚Äî to <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D0%25BA%25D0%25B0%25D0%25B7%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D1%2585%25D0%25BE%25D0%25B4%25D0%25BE%25D0%25B2">branch prediction</a> . </li></ul><br><p>  The main task of this function is to check for a queue overflow or for a blocked barrier and transfer control.  The control then goes to the <code>_dispatch_async_f_redirect</code> function and checks whether the continuation is redirected to the same queue.  This function also updates the start and end of the queue - an atomic change of pointers. </p><br><p>  This is followed by another <code>dx_wakeup</code> macro - or the <code>_dispatch_queue_class_wakeup</code> call.  This is one of the main methods in which the processing of tasks in the queue.  It checks the conditions of the barriers, the status of the queue, and in case of non-compliance with the conditions, the task can again go to the queue through the already known <code>dx_push</code> . </p><br><p>  If the conditions are met, the task is passed to the <code>_dispatch_queue_class_wakeup_with_override</code> method, which is a wrapper over <code>_dispatch_queue_class_wakeup_with_override_slow</code> with the task's priority change and the possibility of overwriting them.  The presence of <code>slow</code> in the name correlates with the mechanism of embedding functions - the logic is divided into several functions in order to simplify its support. </p><br><p>  Next are calls that directly process tasks in a loop and contain a large amount of logic for interacting and setting pointers, checking various flags, and so on. During execution, the last call becomes <code>pthread_create</code> or <code>pthread_workqueue_additem_np</code> .  Of course, if the dispatch is built without using libpwq, then the internal flow control manager comes into play, and its principle of operation is similar to that described above. </p><br><p>  The rest of the calls are intentionally missed, since the goal of this description is to show that even in the case of a normal call of the code for asynchronous execution, this turns into multi-layered logic. </p><br><h3 id="pishem-na-swift">  We write on Swift </h3><br><p>  And now let's take a quick look at what features of the intermediate swift-library, which directly interacts with libdispatch.  As you know, it appeared from the third version of Swift.  It is a wrapper over the original libdispatch with the addition of nice swift enumerations and the imposition of functionality in extensions.  All this, of course, is one of the main tasks of the library - providing a convenient API for working with GCD. </p><br><p>  Let's start with a file in which the cumbersome types of libdispatch data turn into elegant Swift classes - <code>Wrapper.swift</code> .  This file can serve as a display of the entire project. </p><br><p>  The general approach is to create simple wrappers for most objects.  Objects of the original libdispatch, such as <code>dispatch_group_t</code> or <code>dispatch_queue_t</code> , are stored in wrapper objects in the <code>__wrapped</code> property.  Most functions make a single call directly to the functions of the original libdispatch over the <code>__wrapped</code> properties. </p><br><p>  Consider a simple example: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DispatchQueue</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">DispatchObject { //     libdispatch internal let __wrapped:dispatch_queue_t ... final internal override func wrapped</span></span></span></span>() -&gt; dispatch_object_t { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> unsafeBitCast(__wrapped, to: dispatch_object_t.self) } ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> func sync(execute workItem: ()-&gt;()) { <span class="hljs-comment"><span class="hljs-comment">//      dispatch_sync(self.__wrapped, workItem) } ... }</span></span></code> </pre> <br><p>  On the other hand, there are calls that do not consist of one line.  They bring up types, counting intermediate values, checking for the system version and calling the appropriate methods.  It is also worth mentioning that direct calls to the libdispatch library methods are prohibited in the <code>Private.swift</code> file.  An example is given below.  Therefore, you will not be able to write less than a <code>swift</code> 's new code (except, of course, old versions of the swift or the self-contained library libdispatch). </p><br><pre> <code class="hljs swift"><span class="hljs-meta"><span class="hljs-meta">@available</span></span>(*, unavailable, renamed:<span class="hljs-string"><span class="hljs-string">"DispatchQueue.async(self:group:qos:flags:execute:)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dispatch_group_async</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> group: DispatchGroup, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> queue: DispatchQueue, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> block: @escaping </span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>() }</code> </pre> <br><h2 id="preduprezhden--znachit-vooruzhen">  Forewarned is forearmed </h2><br><p>  Total, the description about the principles of work of libdispatch turned out.  Assumptions about its internal structure were confirmed.  <strong>libdispatch is</strong> really built on the POSIX Thread API - as the most minimal API for working with multithreading. </p><br><p>  The latest version of libdispatch uses a different library (libpwq), but the essence remains the same. </p><br><p>  And now you have a question - why should we understand what is there at a low level?  Understanding low-level things is similar to knowing basic concepts.  With their help you will not do something quickly, but you will avoid stupid mistakes in the future. </p><br><p>  Understanding and knowledge of low-level things will allow to solve non-trivial problems in this area.  If you have to write something on pthread for iOS, you will now be prepared. </p><br><h3 id="ssylki">  Links </h3><br><ul><li>  <a href="https://habrahabr.ru/post/326138/">Posix</a> </li><li>  <a href="http://ssd.sscc.ru/ru/content/opplabs/loadbalancing">Pthreads introduction</a> </li><li>  <a href="https://habrahabr.ru/post/320152/">Swift GCD &amp; Queue</a> </li><li>  <a href="http://newosxbook.com/articles/GCD.html">Gcd internals</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/332026/">https://habr.com/ru/post/332026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332016/index.html">‚ÄúIt is important to prioritize‚Äù: about testing at Sberbank Technologies</a></li>
<li><a href="../332018/index.html">How we unify analytic work in CUSTIS</a></li>
<li><a href="../332020/index.html">JavaScript: Many Faces Functions</a></li>
<li><a href="../332022/index.html">Startup Day (June 2017)</a></li>
<li><a href="../332024/index.html">Improving data quality with Oracle Enterprise Data Quality</a></li>
<li><a href="../332028/index.html">How to choose a language to learn in 2017</a></li>
<li><a href="../332030/index.html">It would not be happy, but sports programming helped</a></li>
<li><a href="../332032/index.html">Another way to put tails on a USB flash drive (and get your gigabytes back)</a></li>
<li><a href="../332034/index.html">Cyber ‚Äã‚Äãattacks on pharmacies, industrial espionage, insider and 4-year investigation. It would seem, what have the "Peter"?</a></li>
<li><a href="../332038/index.html">Native variables in CSS. It is time‚Ä¶</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>