<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a three-dimensional retro shooter engine from scratch</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I always liked the classic first-person shooters of the 90s. I would sit for hours at my 386th , playing Doom , stunned by how someone managed to writ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a three-dimensional retro shooter engine from scratch</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/d7c/f55/788d7cf554f7dcf5d46fd31d02f157b0.png"></div><br>  I always liked the classic first-person shooters of the 90s.  I would sit for hours at my <nobr>386th</nobr> , playing <em>Doom</em> , stunned by how someone managed to write code that renders 3D graphics in real time on my screen with an excellent resolution of 320x200.  I knew programming a bit (I just started studying BASIC), so I realized that deep inside it was just a bunch of math and bytes written to video memory.  But at that time even arrays were a rather complicated concept for me, so I could not even begin to comprehend the complexity of 3D rendering. <br><br>  At that time, everyone wrote 3D engines from scratch, because there was no other way.  But today, writing the logic of 3D rendering from scratch is likely to be a bad idea.  <em>Very</em> bad.  Almost like the invention of the wheel!  With a huge number of 3D engines and libraries that are much more well tested and optimized than what you can do yourself, there is no reason for a reasonable developer to start writing his own engine. <br><br>  <em>If only‚Ä¶</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Imagine that you can go back in the time machine back in the 90s, when there was no OpenGL or DirectX yet, there were no video processors.  All you have is a CPU and a screen full of pixels.  You have to write everything yourself. <br><br>  If this idea seems interesting to you, then you are not alone: ‚Äã‚Äãthis is exactly what can be done on such a made-up console like the TIC-80. <br><a name="habracut"></a><br>  After writing the <a href="https://tic.computer/play%3Fcart%3D188" rel="noopener nofollow">8-bit panda</a> , my first game for this console (you can read about it in my <a href="https://medium.com/%40btco_code/writing-a-platformer-for-the-tic-80-virtual-console-6fa737abe476">previous article</a> ), I started looking for an idea for a new game.  Therefore, I decided to set myself the task of writing a simple 3D engine from scratch and creating a minimal first-person shooter in it. <br><br>  That's how I started writing FPS80. <br><br>  In this article, I will describe the 3D rendering process in FPS80 and talk a little about all the trade-offs to ensure speed (and endless horrible hacks!) When implementing fast 3D rendering on this weak machine. <br><br><h3>  3D graphics basics </h3><br>  <em>If you already know how 3D rendering works, then this section will seem boring to you.</em>  <em>You can immediately proceed to the next section!</em> <br><br>  A full explanation of 3D graphics is too voluminous for this article, so we only briefly consider what is important for our purposes. <br><br>  The fundamental idea of ‚Äã‚Äã3D graphics is to project 3D space onto a 2D surface (computer screen).  In other words, one of the main tasks of the 3D engine is to find for a given coordinate <em>(x, y, z) a</em> point in the space of a 2D coordinate <em>(x, y) of the</em> place in which the point should be on the screen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/733/8a7/e49/7338a7e49afcf6ed3ae3bf7e90d33955.png" alt="image"></div><br>  For this, 3D engines perform a series of transformations.  Transformation is a brief definition of the expression "transformation from one coordinate system to another."  Transformations can represent movement (movement, rotation, scale) and projection.  Usually they are represented by matrices. <br><br>  To calculate the screen position of a point, we first need to transform it by its model matrix <em>M</em> , translating it into the space of the world.  Then we multiply it by a matrix of type <em>V</em> to take into account the position of the camera, which translates it into the space of the camera (or eyes).  Then we apply the projection matrix P, which performs a perspective transformation that makes nearby objects large, and distant objects small.  After this, a perspective division is performed, which translates points into coordinates of the screen (viewport): <br><br>  <em>p '= P * V * M * p</em> <br><br>  Applying this sequence of operations to a point is often called ‚Äúprojecting‚Äù a point.  But scenes are made up of objects, not points, so the 3D engine does not only do this. <br><br>  A 3D object consists of polygons.  To render them, the engine usually divides a polygon into triangles, then projects each vertex of each triangle using the above formula, and then draws the resulting triangles of screen space on the screen.  This process is called rasterization: it is a transformation from a vector shape (triangle) to a raster shape (the screen pixels themselves).  But drawing the triangles in random order will not give good results.  because it may turn out that the far triangle is drawn over the near one, therefore the engine should use the strategy for solving such a problem.  Usually, it is solved either by pre-sorting polygons, or by creating a depth buffer, into which the depth of each pixel is written for display on the screen, so that you can know when and when you do not need to draw a pixel. <br><br>  Add texture mapping and lighting, and this is another whole layer of math that the engine calculates to figure out the final pixel color. <br><br><h3>  Do we need full 3D? </h3><br>  Honestly, I started to implement the full process of creating 3D graphics, described above, but I realized that it would be too slow on TIC-80.  As on older PCs, all mathematical calculations and rendering can easily overload the CPU and make the game slow.  I wrote an example in which only four rotating cubes with superimposed textures were drawn, and even that was enough for the frame rate to drop below 10 fps.  It became obvious that "full 3D" will not work.  In particular, the ‚Äúbottleneck‚Äù was <em>fill rate</em> , that is, the problem was basically not with the mathematics of projecting points, but with the time required to draw all the pixels of the triangles onto the screen, especially when doing this several times because occupy overlapping parts of the screen. <br><br>  But do we need full 3D?  In fact, it turns out that many of the old games of the 90s do not implement ‚Äúfull 3D‚Äù.  Instead, they implement cunning graphics restriction mechanisms so that rendering it is less expensive. <br><br>  So, here are the limitations that I imposed: <br><br><ul><li>  The whole level is flat: no stairs, pits, balconies, second floors and all that.  That is, the floor and ceiling are at a constant height. </li><li>  All walls have the same height, from floor to ceiling.  And they are all opaque. </li><li>  The player can turn in any direction, but can not tilt his head up and down, as well as sideways.  In other words, the camera has only one degree of freedom of rotation: the <em>course</em> or <em>yaw</em> . </li><li>  All objects are drawn as ‚Äúbillboards‚Äù, that is, 2D images rendered in 3D space in such a way that they are always directed towards the camera. </li><li>  There are only point sources of light.  One of them is always in the chamber (like a torch in the hands of a player).  Others can be created for a short time, for example, for the effects of explosions. </li></ul><br><h3>  How will these limitations help us? </h3><br>  The fact that the floor and ceiling have a constant height and that all walls go from floor to ceiling (and the player cannot look up / down) creates a wonderful property that will help us very much: in each X position of the screen there will be no more than one wall.  In other words, all visible walls occupy the middle part of the screen and two different walls will never occupy the same X coordinate: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c9/cd8/c3f/6c9cd8c3f30370aaadb379d1fab792c8.png" alt="image"></div><br>  Select the walls in different colors to make them more visible: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c5/ee8/ebc/1c5ee8ebcf8b4d1807e7e60c789ea793.png" alt="image"></div><br>  As you can see, in the screenshot there are six walls (the door is also a ‚Äúwall‚Äù), and all of them are very conveniently located on the screen: each X coordinate of the screen corresponds to only one wall. <br><br>  This is very useful for us, because we can render the walls in two stages: <br><br><ul><li> Determine which wall should be in each X coordinate (in other words, build a map from X coordinates to the walls). </li><li>  We go around (only once!) All the X coordinates, drawing for each the necessary part of the wall. </li></ul><br>  For entities (objects) - monsters, projectiles, columns, fountains, trees and the like - we will use the frequently used <em>billboarding</em> technique.  Entities will not be represented by a real 3D object, we will simply draw a flat 2D image in a 3D coordinate as a cut out of cardboard.  This method is very inexpensive when rendering. <br><br><h3>  Our projection procedure </h3><br>  Even in our very simplified 3D world, we still need to project points from 3D space to 2D.  However, our limitations make mathematical calculations much easier and faster to process.  Instead of performing the full matrix multiplication, we can do a much simpler way: we define the unchanged parts of the matrix calculations (those that do not depend on the position of the player or object), and then simply insert the calculated values ‚Äã‚Äãinto the code.  I will look at all this briefly, but if you are interested in detailed calculations, this <a href="https://docs.google.com/document/d/1vQCBb8IgCPmwFCQFs-koKrwUiJ6c95CW_0MCfyQtf5U/edit" rel="noopener nofollow">is how they are derived</a> . <br><br>  Remember the formula: <br><br>  <em>p '= P * V * M * p</em> <br><br>  Where p 'is the screen coordinates (output), and p - world coordinates (input).  In our simple model, M is the identity matrix (everything is represented in world space), that is, it turns into: <br><br>  <em>p '= P * V * p</em> <br><br>  The visibility matrix V can be calculated by simply moving and rotating the camera, which are limited to rotation only along the Y axis. If the rotation is R and the movement is T, then: <br><br>  <em>p '= P * R * T * p</em> <br><br>  The projection matrix P can be calculated in advance, because it depends only on the field of view and the near / far cut-off planes, which are constant throughout the game.  Having simplified the calculations, we will end up with a fairly straightforward (if everything is set as hard as possible in the code) the projection function: <br><br><pre><code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">S3Proj</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y,z)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> c,s,a,b=S3.cosMy,S3.sinMy,S3.termA,S3.termB <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> px=<span class="hljs-number"><span class="hljs-number">0.9815</span></span>*c*x+<span class="hljs-number"><span class="hljs-number">0.9815</span></span>*s*z+<span class="hljs-number"><span class="hljs-number">0.9815</span></span>*a <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> py=<span class="hljs-number"><span class="hljs-number">1.7321</span></span>*y<span class="hljs-number"><span class="hljs-number">-1.7321</span></span>*S3.ey <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pz=s*xz*cb<span class="hljs-number"><span class="hljs-number">-0.2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> pw=x*sz*cb <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ndcx,ndcy=px/<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pw),py/<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(pw) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">120</span></span>+ndcx*<span class="hljs-number"><span class="hljs-number">120</span></span>,<span class="hljs-number"><span class="hljs-number">68</span></span>-ndcy*<span class="hljs-number"><span class="hljs-number">68</span></span>,pz <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Look at these magic numbers: 0.9815, 1.7321, etc.  All of them are taken from pre-prepared matrix calculations.  By themselves, they have no intuitive meanings (so I didn‚Äôt even turn them into constants). <br><br>  The variables <em>cosMy</em> , <em>sinMy</em> , <em>termA</em> and <em>termB</em> are calculated from the current movement and rotation of the camera before calling the function, because it is enough to calculate them only once for all points. <br><br><h3>  Wall rendering </h3><br>  At the first stage, we will use an array, which we call <em>H-Buf (horizontal buffer)</em> , which determines what will be drawn in each X coordinate of the screen.  "H-Buf" is a non-standard designation, I came up with it myself.  He is called H-Buf because he is H (horizontal) and he is Buf (buffer).  I am not very original in making up names. <br><br>  The TIC-80 screen contains 240 columns (240x136), so H-Buf has 240 positions.  Each position corresponds to the X coordinate of the screen, and contains information about which part of the wall should be drawn there.  In order to simplify everything, I will call it not ‚Äúa piece of a wall one pixel wide‚Äù, but <em>‚Äúa wall cut‚Äù</em> .  That is, each position in H-Buf gives information about which wall section to draw in each X coordinate of the screen: <br><br><ul><li>  <strong>wall (object):</strong> - this is a link to the wall that will be drawn in this slice. </li><li>  <strong>z (float):</strong> - the z coordinate of the screen space (depth) of this slice. </li><li>  <em>and much more ... but let's not talk about it yet!</em> </li></ul><br>  This is enough for us, at least for the first stage!  So, we need to go around all the walls of the level (we will soon talk about how to make this operation more efficient).  For each wall we: <br><br><ul><li>  Use the projection function on its four corners to determine where it will appear on the screen: left x, right x, left-top y, left-bottom y, right-top y, right-bottom y, left z (depth), right z (depth). </li><li>  We go around each X coordinate (from left_x to right_x) of the wall and record the wall section in H-Buf, when <strong>its depth is less than the existing section</strong> in this position in H-Buf. </li></ul><br>  The first test ‚Äúthe depth of this slice is less than that of the existing slice‚Äù is called the <em>depth test</em> .  It allows us to render the walls in the correct order - those closest to the player block the far ones.  Here is the corresponding code snippet: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_AddWallToHbuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hbuf,w)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> startx=<span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(S3.VP_L,S3Round(w.slx)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> endx=<span class="hljs-built_in"><span class="hljs-built_in">min</span></span>(S3.VP_R,S3Round(w.srx)) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> step <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> nclip,fclip=S3.NCLIP,S3.FCLIP startx,endx,step=_S3AdjHbufIter(startx,endx) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> startx <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x=startx,endx,step <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">--  hbuf   1 (   Lua) local hbx=hbuf[x+1] local z=_S3Interp(w.slx,w.slz,w.srx,w.srz,x) if z&gt;nclip and z&lt;fclip then if hbx.z&gt;z then --  . hbx.z,hbx.wall=z,w --       end end end</span></span></code> </pre> <br>  After performing this operation for each wall, H-Buf will contain the correct information about which slice to render at each X coordinate, that is, for rendering, we just need to render the correct part of the desired wall cyclically.  Because of this, this approach turns out to be fast: when we draw walls, there is no delay, no extra work, we know for sure that we need to draw and touch only the pixels that need to be touched.  We never have it so that first we draw a part of the wall, and then draw another wall over it (there is no redrawing). <br><br>  Here is the rendering code.  Notice how simple it is: for each X, we simply render the texture column at this X coordinate, and nothing more: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_S3RendHbuf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(hbuf)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> startx,endx,step=_S3AdjHbufIter(S3.VP_L,S3.VP_R) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> startx <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x=startx,endx,step <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> hb=hbuf[x+<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-comment"><span class="hljs-comment">--  hbuf   1 local w=hb.wall if w then local z=_S3Interp(w.slx,w.slz,w.srx,w.srz,x) local u=_S3PerspTexU(w,x) _S3RendTexCol(w.tid,x,hb.ty,hb.by,u,z,nil,nil, nil,nil,nil,w.cmt) end end end</span></span></code> </pre> <br><h3>  We double the frame rate with a very strange trick. </h3><br>  Even though the TIC-80 has a resolution of only 240x136, filling the <em>entire</em> screen still takes quite a lot of the CPU power, even if we don‚Äôt waste time at all and know exactly what to draw.  Even the fastest rendering algorithm on simple scenes produces about 30 fps, and on more complex scenes the frequency drops significantly. <br><br>  How do we get around this problem? <br><br>  We need to ask ourselves: is it really necessary to fill the <em>entire</em> screen?  No, it is not required.  The human eye ‚Äúsmoothes out‚Äù the flaws of fast-moving events (and people playing retro games are very lenient towards small visual glitches!), So we can speed up rendering by filling only <em>half of the</em> screen in each frame. <br><br>  We will do the following: <br><br><ul><li>  In even frames we will draw only even X coordinates. </li><li>  In odd frames, we will only draw odd X coordinates. </li></ul><br>  This process is also known as <em>interlaced rendering</em> .  This means that in each frame we will actually render only 120x136 pixels, not full 240x136.  We do not clear the screen in each frame, so the pixels that we will not draw will simply be saved as the remnants of the previous frame. <br><br>  This causes small visible glitches, especially when moving fast, but in fact it works <em>on the</em> game, not against it, giving the retro feel of a television screen. <br><br>  Here‚Äôs what we‚Äôll actually render each frame (at least we‚Äôd see it if the other columns weren‚Äôt filled with pixels from the previous frame): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e24/daf/292/e24daf292d06b612492796e44a657e6d.png" alt="image"></div><br>  <i>One frame of interlaced rendering.</i>  <i>Non-rendered columns are left empty for clarity.</i>  <i>In fact, they will be filled with the results of rendering the previous frame.</i> <br><br><h3>  Rendering a wall cut </h3><br>  Great, now we are going to render the cut of the wall.  We already know which slice to render, and we know where.  All you need to do is determine which pixels to render in this column and what color they should be.  How to do it? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11f/76f/0ce/11f76f0cebcd7ef9a8ff5e6ff4519656.png" alt="image"></div><br>  <i>Wall slice (vertical column wall one pixel thick).</i> <br><br><ul><li>  Calculate the lighting falling on this slice, taking into account the sources of light and distance. </li><li>  Calculate the horizontal coordinate of the texture to cut the wall (with perspective correction). </li><li>  Calculate the top and bottom Y coordinates of the slice by interpolating the end points of the wall. </li><li>  Fill each pixel from top to bottom, which means determining the vertical coordinate of the texture (affine transformation), texture sampling, then modulation by lighting, and finally recording the pixel on the screen. </li></ul><br>  We can do with an affine transformation (instead of a perspective-correct transformation) for the vertical coordinate of the texture because the walls are always upright relative to the screen (this is guaranteed because the player cannot turn his head up and down, as well as sideways).  If the situation were different, we would have to realize the correct texture imposition from the perspective of both horizontal and vertical texture coordinates, which would be slower. <br><br><h3>  Entity rendering (add stencil buffer!) </h3><br>  Well, the walls are fun, but the engine will not be a game without enemies.  As I said earlier, enemies are rendered as billboards, that is, as floating images, always directed towards the player. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/8e8/b38/f738e8b38735db6abdd9ec8c4827c22e.png" alt="image"></div><br>  <i>Entities rendered as billboards (always directed towards the camera).</i> <br><br>  However, these images are not just two-dimensional: they are drawn at a certain point in space, so they have <em>depth</em> .  If the enemy goes behind the wall, the wall must be rendered in front of the enemy (the enemy must overlap the wall), and nothing else. <br><br>  How to achieve this effect? <br><br>  If we wanted to simplify everything, we could use <em>the artist's algorithm</em> (which is more like the absence of an algorithm): just draw objects backwards, while objects in the foreground would naturally draw over the objects from the background, providing the desired effect. <br><br>  What is wrong with him?  Its easy to understand.  It's easy to write.  But ... it is <em>very</em> slow, especially on TIC-80, limited in fill rate.  With this implementation, we would spend a lot of resources on drawing beautifully textured and lit pixels, which would later be simply covered by other pixels. <br><br>  And here we need to introduce a new buffer: stencil buffer.  In 3D rendering, the stencil buffer is a screen-sized 2D surface that shows where you can and where you cannot draw.  It looks like a filter.  Each pixel in the stencil buffer can be ‚Äúon‚Äù, that is, to say ‚Äúblocked, not to draw‚Äù or ‚Äúoff‚Äù, that is, to say ‚Äúfreely, you can draw‚Äù.  Depending on the implementation, the values ‚Äã‚Äãmay be reversed, but in our code we will use the value ‚Äútrue‚Äù to indicate the state ‚Äúbusy, do not draw‚Äù. <br><br>  When the program <em>‚Äúreads the stencil buffer‚Äù</em> , this means that before drawing it checks whether the stencil buffer is ‚Äúturned on‚Äù at each position.  If this is the case, then it will not render the pixels above the existing pixel. <br><br>  When the program <em>‚Äúwrites to the stencil buffer‚Äù</em> , this means that when it renders something at a given screen position, it writes to the stencil buffer to indicate that this position is already taken and should not be redrawn. <br><br>  So, here is what we do.  <em>Before</em> rendering the walls, but <em>after</em> calculating the H-Buf, we draw the entities.  The complete algorithm will be as follows: <br><br><ol><li>  Clear stencil buffer. </li><li>  Calculate H-Buf. </li><li>  <strong>Render entities from front to back (read / write stencil, depth test in H-Buf).</strong> </li><li>  Render walls with H-Buf (read stencil). </li></ol><br>  When rendering each pixel of each entity, we write to the stencil buffer, prohibiting to render everything else on top of it.  So we need to render in order <em>from front to back</em> .  This means that <strong>everything we draw is final</strong> .  This means no redrawing, we never waste the pixels drawn on the screen. <br><br>  When drawing entities, we know their depth in the screen space and we know the depth of the wall in this position X (thanks to H-Buf!), So we can also perform a depth test of this column.  This means that we correctly refuse to render parts of the entity that will then be hidden behind the wall (even though at this stage of rendering the wall is not there yet!).  Again, we don‚Äôt want to waste a single extra pixel.  They are very expensive for us. <br><br>  Here is an example of a scene with four overlapping billboards and the order in which they are rendered.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The first is the fountain (number 1, the closest one), then the tree (2), then the green monster (3) and the orange monster (4, the farthest). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5cb/997/0cb/5cb9970cbf3d549f3d97acaa3a1363e5.png" alt="image"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What about the floor and ceiling? </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The floor and ceiling are rendered at the final stage of the process, because they are the only pixels left after rendering entities and walls. </font><font style="vertical-align: inherit;">Everything is simple with the ceiling: it is just completely black, we fill these pixels by looking at the H-Buf and determining where the wall begins. </font><font style="vertical-align: inherit;">Each pixel above it is black (but we still check the stencil buffer).</font></font> Is done. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The floor is more complicated because it is necessary to apply the lighting effect: we want parts of the floor that are distant from the player to be darker. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But to calculate the lighting, we need to know the depth of each pixel of the floor. To determine it for each pixel is surprisingly simple, because we start in reverse order from the coordinates of the screen space to determine the coordinates of world space, and then determine the distance from the player to them. Moreover: we can calculate everything in advance manually and enter these magic numbers so that the procedure is very simple:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_S3FlatFact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x,y)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> z=<span class="hljs-number"><span class="hljs-number">3000</span></span>/(y<span class="hljs-number"><span class="hljs-number">-68</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _S3LightF(x,z) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For given x, y pixel coordinates on the floor, the corresponding Z coordinate on the floor will be only 3000 / (y-68). </font><font style="vertical-align: inherit;">I have no idea why, it just so turned out from calculations on paper. </font><font style="vertical-align: inherit;">And we use this in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_S3LightF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to calculate the amount of light falling on this point, the corresponding modulation of the color of the floor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is what the floor lighting palette looks like. </font><font style="vertical-align: inherit;">Notice that it gradually darkens with distance from the player:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ab/aad/003/3abaad0036f99d67989405f8986d7edf.png" alt="image"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional point light sources </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We will provide support for temporary point lights for lighting effects, for example, when a player throws a fireball and it explodes: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/185/1d6/ce9/1851d6ce9e605e582965499fa86d54c0.gif" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The principle is the same: we calculate the distance in the screen space from the point drawn to the secondary light source (explosion) and take into account its effect. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Please note that we do not use this effect for constant lighting (for example, torches on the walls), because it is expensive and not too reliable. </font><font style="vertical-align: inherit;">Since it is calculated in screen space, it actually does not take into account the rotation and movement of the camera, and it has unpleasant features and division by zero when the source is too close to the player.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Color Modulation and Dithering </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIC-80 allows you to work with only 16 colors, so how can we create lighting effects, making the pixels brighter or darker? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I used the following technique: I created three different ‚Äútones‚Äù that have four different shades, from dark to light. These tones can be modulated by choosing one of four shades each, plus black (color 0) as the darkest. As a result, we will have three "linear changes" - gray, green and brown:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8dd/c6d/2da/8ddc6d2daffff98d713bf0da0a212920.png" alt="image"></div><br><pre> <code class="lua hljs">clrM={ <span class="hljs-comment"><span class="hljs-comment">--  "" {1,2,3,15}, --  "" {7,6,5,4}, --  "" {8,9,10,11} },</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They are set as simple arrays, so when we need to modulate a color for a certain amount of lighting, we just need to find the color and determine which other color of the same linear change to choose. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What about intermediate colors? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For them, I applied the strategy that was used in the old graphics hardware: </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dithering</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Since we cannot have one pixel of an intermediate color, we will draw a pattern in which a part of the pixels will have one color, and the other part a different color. </font><font style="vertical-align: inherit;">As a result, the eye will perceive them as an intermediate color:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/651/df9/4e4/651df94e453d5f3f1c60b1764c953ab5.png" alt="image"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Particle effects </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To give the player a pleasant feedback when killing monsters or destroying objects, we will use simple particle effects: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/141/d16/a91/141d16a914df0e8d518824edcc0f4a3e.gif" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These are just small rectangles simulated in world space and transformed into screen space at the rendering stage. For reasons of speed, they are not cut off and are not taken into account in the stencil buffer, but are simply drawn on top of everything else (a slight deviation from the principle of ‚Äúnot spending extra pixels‚Äù). Fortunately for us, interlaced rendering masks the fact that they are rectangles: since they quickly move and render each frame in different positions, they are broken up by interlacing into parts and look more ‚Äúorganic‚Äù.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, we briefly reviewed the rendering process in the FPS80. I had no experience in writing 3D-engines from scratch, so I am sure that much could have been done better, and my explanations are largely erroneous. Contact me if you find an error (I can write to </font></font><a href="http://twitter.com/btco_code" rel="nofollow noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Developing your own logic for 3D rendering turned out to be very interesting and informative. Especially funny was the need to squeeze every drop of speed from the algorithms. It gave me a (small) idea of ‚Äã‚Äãhow 3D engines were created in the 90s! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The FPS80 source code and rendering engine are laid out on </font></font><a href="http://github.com/btco/ticgeo3d" rel="nofollow noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Feel free to use them in your projects!</font></font><br><br><hr><br>  <i><b>Note.</b></i> <i><b> :</b></i> <em>    </em> <a href="http://tic.computer/" rel="nofollow noopener"><em>TIC-80</em></a> <em>.  TIC-80   </em> <code><em>surf</em></code> <em>. </em> <code><em>[tic.computer/play]</em></code> <em>  Z  .   </em> <code><em>FPS80</em></code> <em>  Z  .     </em> <a href="https://tic.computer/play%3Fcart%3D237" rel="nofollow noopener"><em> - TIC-80</em></a> <em>(   ).</em> </div><p>Source: <a href="https://habr.com/ru/post/340234/">https://habr.com/ru/post/340234/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340222/index.html">Stone in the designer's garden</a></li>
<li><a href="../340224/index.html">How to hide</a></li>
<li><a href="../340228/index.html">How to enforce PCI DSS 3.2 requirements</a></li>
<li><a href="../340230/index.html">Serious vulnerability in the popular encryption library undermines the security of millions of crypto keys</a></li>
<li><a href="../340232/index.html">TextView and Spannable: highlighting parts of a word</a></li>
<li><a href="../340236/index.html">Analysis of the case of changing the settings for the size of the data block for recording on tape with Veeam Backup & Replication</a></li>
<li><a href="../340238/index.html">(Without) painful NGINX Ingress</a></li>
<li><a href="../340242/index.html">Search and fix bugs in PHP source</a></li>
<li><a href="../340246/index.html">PHP page navigation</a></li>
<li><a href="../340248/index.html">Creating distributions for different operating systems in Java 9 and 10</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>