<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architecture and programming computer Vectrex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Does he have a video output? 
 - And how do you imagine this? 
 (from talking about Vectrex) 

 Vectrex was produced by GCE in 1982-1983. and is a g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Architecture and programming computer Vectrex</h1><div class="post__text post__text-html js-mediator-article">  <i>- Does he have a video output?</i> <i><br></i>  <i>- And how do you imagine this?</i> <i><br></i>  <i>(from talking about Vectrex)</i> <br><br><img src="https://habrastorage.org/files/b10/2f4/7bd/b102f47bda3f45d2b092656405537b49.jpg" align="right">  <a href="http://en.wikipedia.org/wiki/Vectrex">Vectrex</a> was produced by GCE in 1982-1983.  and is a gaming computer (console) whose key feature, a vector display, makes it one of the most unusual and interesting 8-bit computers.  With some stretch we can say that it is a simplified version of <a href="https://en.wikipedia.org/wiki/Cinematronics">Cinematronics</a> , more technically advanced vector slot machines. <br><br>  Motorola 6809 is used as a processor in Vectrex - it is similar to MOS 6502/6510, but 16-bit registers, additional addressing modes, multiplication are added. <br>  Clock frequency - 1.5MHz. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Since the computer was released as a game console and games were sold for it on cartridges, the program is placed in the cartridge ROM (32 KB), and the RAM is quite tiny (1 KB - two pieces 2114) and is intended more for data. <br><br>  There is also a built-in ROM with BIOS (8 kb - one 2363), which includes a set of routines for drawing vectors and text output, several primitive melodies and even one game - Minestorm (many known as Asteroids). <br><a name="habracut"></a><br>  The sound is implemented on the AY8912 chip (also used in MSX2 and later ZX Spectrum), however, in addition there is a regular possibility to play 8-bit sound through the DAC (the practical application of this method, however, is limited). <br><br>  Vectrex is designed as a monoblock (including a CRT screen), but the keyboard is not provided in principle.  Management is carried out by two joysticks (including analog).  In addition, a light pen and 3D Imager glasses can be connected. <br><br>  From 1982 to the present time, about 150 <a href="http://www.vectrexmuseum.com/mirror/vgdb/">games</a> have been written for Vectrex, several serious programs (such as editors of graphics, music, animation), as well as about a dozen <a href="http://www.pouet.net/prodlist.php%3Fplatform%255B%255D%3DVectrex">demos and intro</a> .  Interestingly, more than half of the games (and all demos) are released after 1995, i.e.  a decade after the cessation of production and support for Vectrex.  The revival of the platform is connected, first of all, with the advent of good emulators, which made the development available to anyone.  The computers themselves are also quite accessible on eBay. <br><br><h2>  Vector display </h2><br><img src="https://habrastorage.org/files/78a/55f/7c6/78a55f7c667144399ffe53f42ecb4b19.jpg" align="right">  Except for the image output part, the Vectrex architecture is fairly common for computers of that period.  The main interest is the subsystem that forms the vector image, and much of the article will be devoted to it. <br><br>  Vector displays, now practically unheard of and little known, were common in the 1970s. <br><br>  The main difference from the well-known raster is the lack of automatic scanning.  The beam does not run along the lines itself.  Its movement is controlled by the program - the code you write determines the direction, speed, duration and brightness with which the beam will move.  As a result, the vector display has no pixels, and, therefore, no concept of ‚Äúresolution‚Äù (at least in the usual sense). <br><br>  In fact, such a display is an oscilloscope, to the horizontal (X), vertical (Y) and brightness channel (Z) of which digital-to-analog converters are connected. <br><br>  To get a line on the screen, you need not just to move the beam from one point to another, but to do it evenly and at the desired speed.  Then the beam can be extinguished and moved to another point, where to light and move to the third, etc.  Thus we get some figure. <br><br>  After the transfer is completed, the phosphor will glow for a while and the line will be visible.  However, this afterglow does not last long. <br><br>  For this reason, all that is required, including the execution of the code, the delays caused by the call to the periphery and the very drawing of the lines, must be completed in a limited time. <br><br>  If there are many lines, the image will begin to flicker.  This makes it impossible to create shaded shapes (unless they are very tiny), and any serious things will have to be written in assembler because, even if you imagine a perfectly optimizing compiler, calculate all the time delays when the beam moves that will occur in the output code, problematic - one extra load in the register in the wrong place can completely distort the image. <br><br>  If for traditional 8-bit platforms (such as Commodore VIC-20, C64 or ZX Spectrum) it is possible to program without ever looking at the computer circuit, in the case of Vectrex, understanding how the image forming part works is necessary. <br><br>  Of course, you can use ready-made BIOS routines for drawing lines, simple shapes, and displaying labels, but this does not allow you to fully use the capabilities of the device - sooner or later you will still have to work with the hardware directly. <br><br>  For this reason, familiarity with the development will be closely intertwined with a description of the computer device. <br><br>  We will deal with the example of constructing a straight line from a point where the beam was already located, to some new given point. <br><br>  In this context, we are interested in the following Vectrex'a components (numbers in <a href="">the diagram</a> are shown in brackets): <br><br>  MOS 6522 (IC207) - the universal interface adapter (VIA - Versatile Interface Adapter) - this chip maps to the memory area $ D000 ... $ D00F.  Accordingly, writing to these addresses of values ‚Äã‚Äã(for example, instructions of the processor STA $ D00x) leads to a change in its registers. <br><br>  6522 contains, in particular, I / O ports, two timers, shift register. <br><br>  Details are better seen in the documentation on the chip (see the link to the archive at the end of the article), but the point is that, by writing the microprocessor commands to the above-mentioned memory cells, we set the legs sticking out of the chip to 0 or 1 (and also vice versa). we can check if they are 0 or 1). <br><br>  MC 1408 (IC301) - 8-bit digital-to-analog converter (DAC, DAC).  Converts the code received from the 6522 chip to the appropriate voltage level.  In terms of programming, the voltage range corresponds to the numbers -128 ... +127 (and not 0 ... 255!) <br><br>  LF347 (IC303) - s &amp; h (store &amp; hold) sampling-storage circuits on operational amplifiers.  Keep the output voltage (including after it is removed from the input).  There are two of them - on channels Y and Z (for X it is not needed, explanation below). <br><br>  CD 4052 (IC302) is an analogue digital multiplexer (mux).  Depending on the code on its digital inputs (which are connected to the same 6522), it passes the input voltage from the DAC to one of its several outputs. <br><br>  4066 (IC305) - analog keys.  Managed (the same 6522) switches that allow to pass or not to pass through a voltage. <br><br>  LF247 (IC303) - integrators on operational amplifiers (there are two of them - in X and Y, respectively).  The input rectangular signal, whose amplitude is specified by the code on the DAC, is transformed into a varying voltage that causes the beam to smoothly move from one point to another, leaving a glowing trace on the screen. <br><br>  Next comes a cathode ray tube with a deflecting system (horizontally and vertically) to which, through amplifiers, voltage is supplied from the integrators and, separately, the voltage that controls the brightness of the beam. <br><br>  In the absence of voltage on deflecting systems, the beam is in the center of the screen.  At the maximum allowable voltage on any of them - outside the screen. <br><br><img src="https://habrastorage.org/files/29e/06a/8ba/29e06a8bab0e4c4badfe58fb3480a96b.png"><br><br>  (for a more detailed picture, see the <a href="">block diagram</a> and <a href="">diagram</a> ) <br><br>  Drawing is approximately as follows: <br><br>  Loading in certain registers 6522 values, we can set the desired voltage at the DAC output.  But there is only one DAC, and we need to set three voltages - X (horizontal direction -128 ... + 127), Y (vertical direction -128 ... + 127) and Z (brightness 0 ... $ 7F) . <br><br>  To do this, after setting each voltage, you need to switch the multiplexer so that the voltage is transmitted to the desired output.  With channels Y and Z in this respect, everything is simple, but channel X goes (obviously to simplify the scheme) bypassing the multiplexer. <br>  That is, when setting Y or Z, we always simultaneously install X! <br><br>  Therefore, we do this: <br><br>  <strong>1.</strong> Record the brightness in the DAC, switch the multiplexer to the output on channel Z. The voltage is stored in the sample &amp; hold (s &amp; h) circuit of channel Z. <br><br>  <strong>2.</strong> Write to the D / A converter D, switch the multiplexer to the output on channel Y. The voltage is stored in the s &amp; h circuit of channel Y. <br><br>  <strong>3.</strong> Turn off the multiplexer and write to the DAC X (s &amp; h is not needed here, since the voltage is stored on the DAC itself) <br><br>  Channel Z is no longer interesting to us (the brightness is constant), but with X and Y we understand further. <br><br>  So, the X and Y voltages from the outputs of the s &amp; h circuits are supplied to the analog switches.  Through 6522 (PB7 output) we send a RAMP signal to these keys.  The keys open at the same time and both voltages fall on the corresponding integrators - in X and Y. <br><br>  At the output of the integrators, respectively, we obtain varying voltages.  They change either from the previous value remaining on the capacitor of the integrator (remember, did we put a beam somewhere?), Or from zero (if the integrators had previously dropped to zero, by applying the ZERO signal to them through the same 6522 - the capacitor is discharged) . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/188/cf3/f20/188cf3f20d494083876d51ba9d7f80eb.png"></div><br><br>  Integration goes, the voltage changes, the beam moves across the screen and leaves a trace due to the afterglow of the phosphor.  When we get tired, we can stop it by disconnecting the voltage from the integrators with the already mentioned RAMP signal. <br><br>  Thus, the line is drawn, and the rest of the voltage on the integrators corresponds to its end (and the beginning of the next, if necessary). <br><br>  The question arises - at what point to turn off the voltage?  Basically, that's your business.  You can simply calculate how long the vector is needed and drive the delay into the desired number of ticks with appropriate commands. <br><br>  However, in practice, another method is usually used - timer 1 is activated in 6522. A certain value is entered in the timer, not very successfully named ‚Äúscale‚Äù and the countdown begins.  When the value reaches zero, the integration will be automatically stopped by the RAMP signal.  That is, it is enough to set and start the timer, the beam stops itself.  However, there is a problem - the beam will stop, but how to find out about it in order to start drawing the next one? <br><br>  To do this, you will have to check one of the registers 6522 in the loop, where the flag will be set after the completion of the account.  In fact, waiting is being wasted, so this cycle time is sometimes used to perform some useful calculations. <br><br>  In addition to the solid line, there is enough curve to draw a dotted line.  For this purpose, a shift register (shift register) in 6522 is used. We transfer the necessary pattern there (for example, $ AA =% 01010101) and say 6522 that the shift should occur automatically.  With a shift, each bit creeps out on the BLANK signal and, thus, the beam itself turns on on units and turns off on zeros.  The problem is that after 8 shifts in the register, only zeros are left and all of our wonderful dotted line ends.  To prevent this from happening, it is necessary to put the pattern value there again and again.  This is done in the aforementioned integration wait cycle.  In such circumstances, to get exactly the dotted line, what you want - very difficult. <br><br>  However, it is this register that is used by the BIOS for the text output function (that is, in fact, the standard characters are bitmap, they are simply drawn with discontinuous horizontal vectors). <br><br>  From all of the above, there are three important points: <br><br>  <strong>1.</strong> Drawing is not in absolute coordinates, but relative.  The next movement is counted from the end of the previous one and the vector has a certain length in a certain direction (by the way, this allows you to completely display the image beyond the boundaries of the visible part of the screen - for example, to implement scrolling). <br><br>  Due to various leaks, with each movement, the error quickly increases (units of centimeters per ten thousand cycles), therefore at the beginning of each ‚Äúframe‚Äù (series of drawings) the beam is placed in the center of the screen. <br><br>  <strong>2.</strong> The length and direction of the vector depends on the combination of scale and stresses in X and Y. In a sense, scale specifies the length, and X and Y the direction (but also affecting the length).  We can say that in the figure with the schedule, the scale sets the time from A to B (or from B to C), and the value of X (or Y) applied to the DAC is the slope of the segments on the lower part of the diagram (in other words, the rate of change of voltage). <br><br>  3. Since scale is the time for moving the beam, it should be as short as possible.  The smaller it is, the more vectors you can manage to draw until flickering begins. <br><br>  For a flicker-free image of 50 frames per second (50 Hz for any Vectrex), it is necessary to keep within 30,000 ticks with all the drawings and calculations. <br><br>  If you draw horizontal lines across the full width of the screen at the maximum scale ($ FF) and before starting to draw each line, set the beam to the center and then to the starting point of the line, then about 60-70 lines will be added to the 30,000 ticks, which is quite a bit.  It is clear that with decreasing scale (and, accordingly, decreasing their length), the maximum number of lines will increase. <br><br><h2>  Drawing a straight line </h2><br>  Now let's look at how everything described above is implemented in the code (the VIA_ * constants from vectrex.i from the BIOS sources). <br><br>  Virtually any program for Vectrex is an endless loop.  First of all, it always calls the BIOS routine Wait_Recal, and then everything else - the necessary calculations, drawing all the vectors for a given ‚Äúframe‚Äù, playing music, polling joysticks, etc. <br><br>  Unlike traditional raster displays, where the ray runs around all the lines the same time for each frame, everything is different here - after all, 10 lines can be output in one frame, and only 5 in the next frame. <br><br>  To ensure equal execution time of all iterations of the cycle (‚Äúframes‚Äù), the following method is used: <br><br>  Timer 2 VIA 6522 is programmed in one shot mode and the value Vec_Rfrsh = 30000 ($ 7530) is entered into it.  From the moment of entering there is a countdown.  At the beginning of Wait_Recal we wait for the countdown to end.  As soon as it is over, we recalibrate the circuits (and in the timer again we bring the same value).  The meaning of this expectation is that the iteration of the loop is guaranteed to take at least 30,000 cycles.  If the drawing and calculations took less, time will still be ‚Äúadded‚Äù to 30,000. <br><br>  But if they took more, it will lead to negative effects - first, the vectors drawn first will start to fade, and secondly, due to late recalibration, various distortions can occur. <br><br>  Why exactly 30,000?  The value is chosen at the rate of 50 Hz (i.e., 1/50 second is given to one ‚Äúframe‚Äù), based on a processor frequency of 1.5 MHz.  50 Hz, apparently, is chosen purely by tradition. <br><br>  Wait_Recal consists of several sequential procedures: <br><br>  - Increases counter Vec_Loop_Count (this is just a word variable) <br>  - It is expected when finished to count timer 2 (and if finished, it starts again) <br>  - Sets the maximum scale (scale) = $ FF <br>  - Turn off zeroing integrators, turn off the beam, the beam moves to the position x = $ 7F, y = $ 7F (lower left corner) from its previous point (which can be anything) <br>  - The beam is turned on, the shift register is cleared (i.e., the empty pattern for lines), the integrator is ‚Äúreset‚Äù (the beam is in the center) <br>  - Switching off the zeroing of integrators, turning off the beam, the beam moves to the position x = $ 80, y = $ 80 (upper right corner) <br>  - Once again, the inclusion of resetting the integrators (the beam is again in the center) <br>  - Set zero relative to zero DAC (see note from svo below) <br><br>  How calibration helps to move the beam to the corners of the screen is unclear. <br><br>  From a practical point of view, it is important that as a result of these actions, after the Wait_Recal call, the beam is turned off and forcibly located in the center (resetting the integrators is on - they cannot work even if integration is started), the scale is set to $ FF. <br><br>  So, the source: <br><br><pre><code class="hljs mel">loop: jsr Wait_Recal ;   <span class="hljs-number"><span class="hljs-number">2</span></span>   CRT ;     <span class="hljs-string"><span class="hljs-string">""</span></span>  (    ) lda #$CE ; BLANK low, ZERO high sta &lt;VIA_cntl ;     <span class="hljs-number"><span class="hljs-number">6522</span></span> ;   (<span class="hljs-keyword"><span class="hljs-keyword">scale</span></span>): lda #$ff ; $ff --   sta &lt;VIA_t1_cnt_lo ;      <span class="hljs-number"><span class="hljs-number">1</span></span> ;   (Z): lda #$7f ; $7f -   sta &lt;VIA_port_a ;     ldb #$04 stb &lt;VIA_port_b ; (<span class="hljs-number"><span class="hljs-number">4</span></span>  portb)        <span class="hljs-number"><span class="hljs-number">2</span></span> (sel0=<span class="hljs-number"><span class="hljs-number">0</span></span>, sel1=<span class="hljs-number"><span class="hljs-number">1</span></span>),     s&amp;h  Z stb &lt;VIA_port_b ;  ldb #$05 stb &lt;VIA_port_b ; (<span class="hljs-number"><span class="hljs-number">5</span></span>  port b)   ( S/H  <span class="hljs-number"><span class="hljs-number">6522</span></span>) ldb #<span class="hljs-number"><span class="hljs-number">100</span></span> ;    - X lda #<span class="hljs-number"><span class="hljs-number">100</span></span> ;    - Y sta &lt;VIA_port_a ;   Y   clr &lt;VIA_port_b ; (<span class="hljs-number"><span class="hljs-number">0</span></span>  port b)        <span class="hljs-number"><span class="hljs-number">0</span></span>,     s&amp;h  Y inc &lt;VIA_port_b ; (<span class="hljs-number"><span class="hljs-number">1</span></span>  port b)   stb &lt;VIA_port_a ;   X      (    ,    Y  Z). lda #$aa ;    ($ff - , $aa - ) ldb #$40 ;    <span class="hljs-number"><span class="hljs-number">1</span></span> sta &lt;VIA_shift_reg ;      clr &lt;VIA_t1_cnt_hi ;  ,     ( RAMP) wait_timer: sta &lt;VIA_shift_reg ;      bitb &lt;VIA_int_flags ;     <span class="hljs-number"><span class="hljs-number">1</span></span> ($40) -       <span class="hljs-keyword"><span class="hljs-keyword">scale</span></span> beq wait_timer ;  ,   .  ,   clr &lt;VIA_shift_reg ;     (       ) ;     ,  ,     ; ...... bra loop ;   </code> </pre> <br>  Note that the pattern is written to the register twice - before the start of integration and then in each iteration of the loop.  The second is necessary because during shift (automatic) the register becomes empty and if the value is not updated, the line will become invisible.  When updating, it is very important that the shift and cycles that commands take in the cycle match correctly.  If even one nop is inserted there, the visible line pattern changes. <br><br>  If several lines are drawn (for example, a square), then, of course, ‚Äúclr &lt;VIA_shift_reg‚Äù makes sense to put not after each line, but one at the very end. <br><br>  In the BIOS Draw_VL subroutine (calling Drawline_d), this moment is played up quite cleverly: there is a variable Vec_Misc_Count in which the number of lines that you plan to draw is entered.  And when the last one is drawn, the pattern is not just cleared there, but integrators are also being reset (i.e., the code from Wait_Recal is partially executed). <br><br>  If you need to quickly return the beam to the center of the screen before the loop completes and the next Wait_Recal call, you can use the ‚Äúzeroing‚Äù of integrators, not forgetting to turn it off: <br><br><pre> <code class="hljs mel">;   lda #$CC sta &lt;VIA_cntl ; /BLANK low and /ZERO low ;    ,     ldd #$0302 clr &lt;VIA_port_a ; <span class="hljs-keyword"><span class="hljs-keyword">clear</span></span> D/A register sta &lt;VIA_port_b ; mux=<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> mux stb &lt;VIA_port_b ; mux=<span class="hljs-number"><span class="hljs-number">1</span></span>, enable mux stb &lt;VIA_port_b ; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> it again ldb #$01 stb &lt;VIA_port_b ; <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> mux ;    lda #$CE ; /Blank low, /ZERO high sta &lt;VIA_cntl</code> </pre><br>  The BIOS Reset0Ref routine does the same thing (plus, shift register is cleared there), which is called from Wait_Recal. <br><br>  It is essential that you need to perform AND zeroing integrators And writing zeros in the DAC.  For an emulator, it makes no difference, but on a real Vectrex the difference will be very much. <br><br>  NOTES: <br><br>  The described line drawing option is intentionally redundant.  For example, it is not necessary to set the scale and brightness every time; a solid line does not require an extra cycle with updating shift register.  In some cases it is much more optimal (but less clearly) to load A and B immediately with LDD instructions, use clr, inc / dec, etc.  In a real situation it is necessary to do this, because  saves cycles. <br><br><img src="https://habrastorage.org/files/2c0/e36/74d/2c0e3674d9594d04bfb92a1384129aac.jpg" align="right" vspace="2" title="With the brightness unscrewed to the maximum, the beam travels to the center of the screen with each recalibration."><br><br>  In regard to the ‚Äúmeaningless‚Äù delay instructions: after writing to ports 6522, several cycles sometimes wait in the BIOS code.  Otherwise, the next entry may fail.  When it is needed and when not - the question is rather vague.  Judging by the experiments (both mine and other people) - no need at all.  This may have been required for early copies of Vectrex. <br><br>  You need to understand that if you want to draw long continuous vectors (for example, the entire width of the screen), then this is possible only at the maximum scale.  However, if it is maximum, this automatically means a reduction in ‚Äúresolution‚Äù in the sense that a vertical step of one will mean a distance approximately the width of a bright line (i.e. there will be a gap between adjacent lines). <br><br>  If you make long lines of several short, the joints will be noticeable. <br>  In practice, it makes sense to constantly switch the scale - in one (large) a line is drawn, in the other (small) the beam moves to the beginning of drawing the next one. <br><br>  If you draw a long (from -128 to 127) horizontal line (on the scale of $ FF) so that its left end is at the right edge of the screen, and the right end is far behind the screen, you cannot move it to the left so that the right end is behind left edge of the screen. <br>  At first glance there is no problem, because  beam movements are always relative.  However, on the present Vectrex the line will not go left over the edge (and if you reduce the initial coordinate of the line smoothly, it will be seen how its movement to the left will slow down and stop before reaching the desired position around a quarter of the screen. This is due to restrictions on the maximum amplitude voltages at the outputs of the integrators (the emulator, by the way, does not understand this). <br><br>  The brightness of the vector is determined not only by the value of Z, but also by the time that the beam is in this particular place.  Accordingly, the brightness will be higher if a) the beam moves slowly b) the beam moves along the same trajectory many times. <br><br>  In this regard, it is worth mentioning the points - they are drawn by simply turning on the beam (without integration), waiting in a cycle for some time, on which the brightness depends and turning off the beam (see the Dot_here subroutine). <br><br><h2>  Straight line with manual integration </h2><br>  In the previous section, we started a timer to start moving the beam, which automatically started the integration.  And then they waited for the end, checking in a loop whether the timer had finished counting. <br><br>  There is another way to draw a line in which the timer is not used: we start the integration manually (by installing the RAMP on PB7 6522 leg), and then wait for the time we need in any way while the beam creeps in the given (X and Y) direction.  Depending on the task, simple nop or cycle can be used to wait (in which, in particular, you can update the value of shift register if a dash-dotted line is required). <br><br>  At the end of the drawing, the integration stops (also manually). <br><br>  The code looks like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: jsr Wait_Recal lda #$CE ; (<span class="hljs-number"><span class="hljs-number">11001110</span></span>) /Blank low, /ZERO high sta &lt;VIA_cntl ; <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> beam, <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> zeroing clr &lt;VIA_shift_reg ;   PB7 <span class="hljs-number"><span class="hljs-number">6522</span></span>,     (    ,  ) lda #<span class="hljs-meta"><span class="hljs-meta">$18</span></span> ; (<span class="hljs-number"><span class="hljs-number">00011000</span></span>) AUX: shift mode <span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-number"><span class="hljs-number">110</span></span>). PB7 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> timer controlled. PB7 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ~RAMP ldb #<span class="hljs-meta"><span class="hljs-meta">$81</span></span> ; (<span class="hljs-number"><span class="hljs-number">10000001</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> MUX (bit0=<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> ~RAMP (bit7=<span class="hljs-number"><span class="hljs-number">1</span></span>), MUX <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> channel Y stb &lt;VIA_port_b sta &lt;VIA_aux_cntl ;       ,       Y (  ;      X, .. X   ) lda #<span class="hljs-number"><span class="hljs-number">127</span></span> ;  Y sta &lt;VIA_port_a ldb #<span class="hljs-meta"><span class="hljs-meta">$80</span></span> ; (<span class="hljs-number"><span class="hljs-number">10000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> MUX (bit0=<span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> ~RAMP (bit7=<span class="hljs-number"><span class="hljs-number">1</span></span>), MUX <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> channel Y stb &lt;VIA_port_b ; <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> MUX, that means put DAC <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Y integrator S/H ;         X ldb #<span class="hljs-number"><span class="hljs-number">127</span></span> ;  X lda #<span class="hljs-meta"><span class="hljs-meta">$81</span></span> ; (<span class="hljs-number"><span class="hljs-number">10000001</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> MUX (bit0=<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> ~RAMP (bit7=<span class="hljs-number"><span class="hljs-number">1</span></span>), MUX <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> channel Y ( ) sta &lt;VIA_port_b stb &lt;VIA_port_a ; store B (X_update) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> DAC ;   ldb #<span class="hljs-meta"><span class="hljs-meta">$01</span></span> ; (<span class="hljs-number"><span class="hljs-number">00000001</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Disable</span></span> mux (bit0=<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> ~RAMP (bit7=<span class="hljs-number"><span class="hljs-number">0</span></span>), MUX <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> channel Y ( ) stb &lt;VIA_port_b ;        (     ).       ldb #$ff ;     stb &lt;VIA_shift_reg ;  ,           (X,Y)  nop nop nop nop nop nop clr &lt;VIA_shift_reg ;   ,    ;   ldb #<span class="hljs-meta"><span class="hljs-meta">$81</span></span> ; (<span class="hljs-number"><span class="hljs-number">10000001</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> MUX (bit0=<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> ~RAMP (bit7=<span class="hljs-number"><span class="hljs-number">1</span></span>), MUX <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> channel Y stb &lt;VIA_port_b ;      ,         . ;         nop nop nop nop ;      -   lda #<span class="hljs-meta"><span class="hljs-meta">$98</span></span> ; (<span class="hljs-number"><span class="hljs-number">10011000</span></span>) AUX: shift mode <span class="hljs-number"><span class="hljs-number">4</span></span> (<span class="hljs-number"><span class="hljs-number">110</span></span>). PB7 timer controlled (bit7=<span class="hljs-number"><span class="hljs-number">1</span></span>). PB7 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ~RAMP sta &lt;VIA_aux_cntl bra <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span></code> </pre><br>  Since the timer is not used here, setting the scale (scale) does not make sense and does not affect anything.  The direction and length of the line is completely determined by the values ‚Äã‚Äãof X, Y and the delay between the beginning and the end of integration. <br><br>  In BIOS, a similar approach (without a timer) is used when displaying characters (subroutine Print_Str). <br><br><h2>  Drawing a curve </h2><br>  With drawing direct vectors, if you look, everything is quite simple.  But what if you want to draw a curve?  Vectrex has no special hardware capabilities for this. <br><br>  Moreover, you can not even arbitrarily move the beam - you need to switch channels of the multiplexer, and one of the channels (X) generally goes past it. <br><br><img src="https://habrastorage.org/files/649/9ca/f2b/6499caf2bce145c6a19ae172f47169cd.jpg" align="right" vspace="2" title="Curve example"><br><br>  From the official point of view it is impossible to draw curves.  There is not a single subroutine in the BIOS that does something similar.  However, if you do everything manually, curves, with a number of serious limitations, it is still possible to draw. <br><br>  To do this, as in the previous case, you will have to refuse to start the integration by timer and check its completion. <br><br>  The launch is done manually (with a RAMP signal) and, after the beam has started moving, we start writing the values ‚Äã‚Äãin the X and Y channels at the right moments, as a result of which the beam is forced to change direction.  Besides, again, the need to clearly calculate the points needed for recording, a serious limitation is the need to switch the multiplexer between channels.  In practice, this leads to the fact that everything is good with channel X, since  it bypasses the multiplexer (therefore, the horizontal deflections of the beam are clean and neat).  But with channel Y, everything is bad. <br><br>  In order to write to it, it is necessary to turn on the multiplexer (activate the output S / H 6522 leading to the DIS MUX multiplexer), record the value and turn off the multiplexer again, which is likely to stop the integration. <br><br>  Consider a simple example in which a curve is drawn with a deviation only horizontally (X): <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: jsr Wait_Recal ;  lda #<span class="hljs-meta"><span class="hljs-meta">$7</span></span>f sta &lt;VIA_t1_cnt_lo ;  (    Moveto_d) lda #<span class="hljs-number"><span class="hljs-number">-120</span></span> ; Y ldb #<span class="hljs-number"><span class="hljs-number">0</span></span> ; X <span class="hljs-number"><span class="hljs-number">-127</span></span> jsr Moveto_d ;       ;       mux ldd #<span class="hljs-meta"><span class="hljs-meta">$1881</span></span> stb &lt;VIA_port_b ; poke <span class="hljs-meta"><span class="hljs-meta">$81</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> port B: <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> MUX, <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span> ~RAMP sta &lt;VIA_aux_cntl ; poke <span class="hljs-meta"><span class="hljs-meta">$18</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> AUX: shift mode <span class="hljs-number"><span class="hljs-number">4.</span></span> PB7 <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> timer controlled. PB7 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> ~RAMP ;  Y,      lda #<span class="hljs-number"><span class="hljs-number">127</span></span> ; Y sta &lt;VIA_port_a ;    decb ; B now <span class="hljs-meta"><span class="hljs-meta">$80</span></span> stb &lt;VIA_port_b ; <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> MUX, that means put DAC <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Y integrator S/H ;         - X,        ldb #<span class="hljs-number"><span class="hljs-number">0</span></span> ; X <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> inc &lt;VIA_port_b ; MUX <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> X <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> DAC now stb &lt;VIA_port_a ; store B (X_update) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> DAC ;   ldb #<span class="hljs-meta"><span class="hljs-meta">$01</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> poke <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> MUX <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span>, ~RAMP <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> stb &lt;VIA_port_b ; MUX <span class="hljs-keyword"><span class="hljs-keyword">disable</span></span>, ~RAMP <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> ;   ( ) ldb #$ff stb &lt;VIA_shift_reg ; , , .         X.  , , ;          .       ;        lda #<span class="hljs-meta"><span class="hljs-meta">$10</span></span> sta &lt;VIA_port_a ;   lda #<span class="hljs-meta"><span class="hljs-meta">$20</span></span> sta &lt;VIA_port_a ;   lda #<span class="hljs-meta"><span class="hljs-meta">$30</span></span> sta &lt;VIA_port_a ;   ;   ldb #<span class="hljs-meta"><span class="hljs-meta">$81</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ramp <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, MUX <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> stb &lt;VIA_port_b ; poke <span class="hljs-meta"><span class="hljs-meta">$81</span></span>, ramp <span class="hljs-keyword"><span class="hljs-keyword">off</span></span>, MUX <span class="hljs-keyword"><span class="hljs-keyword">off</span></span> ;       .   ,   ,      nop nop nop nop clr &lt;VIA_shift_reg ;   ;     (<span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> PB7 timer, SHIFT mode <span class="hljs-number"><span class="hljs-number">4</span></span>) lda #<span class="hljs-meta"><span class="hljs-meta">$98</span></span> sta &lt;VIA_aux_cntl bra <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span></code> </pre><br>  In fact, the given example is similar to the example from the previous section (a straight line with manual integration), just here in the drawing process we also write the value of X in the DAC. <br><br><img src="https://habrastorage.org/files/6cb/fad/ff2/6cbfadff2bdd47d798b63643e496eecf.jpg" align="right" vspace="2" title="Curves with dots at the ends in the intro Electric Force"><br><br>  As for the use of shift register, there are difficulties.  The dotted line can be made, but the accuracy of the dotted line will be conditional, since  It‚Äôs problematic to change both X and shift register exactly when it‚Äôs needed. <br><br>  If at equal intervals of time we write the same values ‚Äã‚Äãin X (for example, 10, 10, 10), the change will be linear ‚Äî that is,  get an inclined line. <br><br>  The smoothness of the curve and its length depend on the delay between the recording of the values.  If the delays are large, you get just a broken line.  Therefore, in specific situations, any superfluous instruction will matter, and it is likely that you will have to unfold the cycles.  In addition, the resulting curve may depend on a specific copy of the vectrex (due to differences in the parameters of analog components / circuits), although it is possible to achieve an approximate similarity on different instances (though it is not clear where to get as many Vectrexes for testing). <br><br>  The described technology was used in practice, although rarely.  The most famous example is the road in the game Pole Position.  The other is <a href="http://www.pouet.net/prod.php%3Fwhich%3D66303">my intro ‚ÄúElectric Force‚Äù</a> for CC'2015. <br><br>  Is it possible to change the brightness in the process of drawing a line (straight or curve)?  For practical purposes, it is unlikely.  The brightness changes through the same DAC - just as with the Y channel, you need to switch the multiplexer (with the corresponding side effects).  In addition, it will take time, so the length of the line segment of the same brightness will be too large. <br><br><h2>  Raster of vectors </h2><br>  If we have the ability to draw vectors, it is logical to assume that we can try to build a raster from them by making the beam run back and forth and turn it on and off at the right time.  However, when implementing this idea, a number of obstacles arise that are only partially surmountable: <br><br><img src="https://habrastorage.org/files/2d0/6cd/eea/2d06cdeeaec7418da01dfdad14bbb387.jpg" align="right" vspace="2" title="Two rasters superimposed with offset, with different brightness"><br><br>  1. For the available 30,000 strokes (so that the image is stable), too many scanning lines cannot be drawn. <br><br>  In fact, at the maximum length of the line, their number (we will call this the vertical resolution) will be measured in dozens.  Moreover, if the scale is maximal (i.e., if we want a raster wider to the screen), then the lines will have less time to draw.  Moreover, you need to take into account that after drawing each line, we must somehow move on to the beginning of the next one.  Even if we draw back during the course of the beam (creating problems for addressing points), with the maximum scale, it will not be possible to draw several horizontal lines close by - there will be significant gaps between them.  To avoid this, you can reduce the scale before moving the beam vertically and return it back to a maximum before drawing a line.  This switch will also take time. <br>  You can abandon the raster on the entire width of the screen and initially set the scale smaller.  Then, firstly, the problem is solved with vertical intervals, and secondly, the time for drawing lines is reduced. <br><br>  2. If you do not recalibrate the circuit after each line, the whole thing moves aside. <br><br><img src="https://habrastorage.org/files/b3b/a6c/ec0/b3ba6cec03f54205997dc5cf5f12f440.jpg" align="right" vspace="2" title="Full set of standard BIOS symbols displayed as raster"><br><br>  The fatality of the problem depends on the chosen scale (i.e., the longer the beam is drawn, the more integrators' parameters drift away) and on the specific Vectrex instance.  On my copy with a raster across the entire width of the screen, the second line already begins a millimeter to the left, so there is no need to talk about a stable raster.  Decreasing the scale somewhat reduces the severity of the problem, but does not remove it. <br><br>  The solution is recalibration (resetting the integrators and DAC) after each line.  This gives a stable raster but, of course, at the cost of extra bars. <br><br>  On the emulator (ParaJVE), the flow of parameters of analog circuit elements is absent, therefore it is impossible to rely on it in this regard. <br><br>  3. It is necessary to turn the beam on and off in the process of its movement very quickly and accurately. <br><br>  Acceptable speed is possible only when using shift register. <br>  Moreover, if when drawing a dashed line, the uniformity of the dotted line doesn‚Äôt matter much, then when displaying an image, regular loss of points or extra gaps, especially in conjunction with other problems, is unacceptable. <br><br>  The approach with the timer does not work here, so you need to use the manual integration launch described earlier, after which, at precisely calculated time intervals (so that every 8 ‚Äúpixels‚Äù dock correctly with each other), the shift register is updated with the necessary values.  Accordingly, the end of the line drawing is also determined manually - by a program counter. <br><br>  This is how the BIOS routine Print_Str works, with which text lines are usually displayed.  In practice, however, there are a lot of nuances - just look at the code Print_Str.  By the way, in order to save clock cycles after each line, the beam is not set to zero.  Because of this, almost any string (longer than a few characters, depending on the scale) is output distorted, at least on some instances of Vectrex. <br><br>  4. As previously noted, switching the brightness while drawing a line is problematic.  However, nothing (except the need to keep within 30,000 cycles) does not prevent us from drawing 2-3 raster of different brightness, superimposing one on another. <br><br><h2>  Sound </h2><br>  Despite its age, the sound in Vectrex is not bad.  There are even two independent ways to reproduce it - through the AY8912 chip (i.e., similar to the Yamaha MSX2 and the advanced versions of the ZX Spectrum) and via the DAC (i.e., playing samples). <br><br>  The use of samples is limited by the modest size of the addressable memory and processor performance - too many clock cycles will be spent on sound.  I used the short phrase to digitize in my <a href="http://www.pouet.net/prod.php%3Fwhich%3D65963">Invitron</a> intro.  The general meaning is that the corresponding multiplexer channel is selected (sel0 = 1, sel1 = 1) and then the values ‚Äã‚Äã(8 bits, with a sign) are written to the DAC. <br><br>  It looks like this: <br><br><pre> <code class="hljs mel"> lda #%10000110 sta &lt;VIA_port_b ; enable mux, set mux to <span class="hljs-keyword"><span class="hljs-keyword">sound</span></span> channel (%11) ldx #sample ; sample address ldy #<span class="hljs-number"><span class="hljs-number">23570</span></span> ; sample length (bytes) next: lda ,-y lda ,x+ ;    sta &lt;VIA_port_a ;     cmpy #$0000 beq done ldb #$19 ; . $19  <span class="hljs-number"><span class="hljs-number">8</span></span> delay: decb cmpb #$00 bne delay jmp &gt;next done: .... sample: db xx, xx, xx, ...</code> </pre><br>  Convert the sample to the desired form (in this case, signed 8 bit, mono, 8khz), you can: <br>  ffmpeg -i input.wav -acodec pcm_s8 -ar 8000 -ac 1 output.au (do not forget to cut off the header then) <br><br>  As for playing music through AY8912, this is the main way, which is not too costly in terms of beats.  Even the BIOS has built-in tools for playing primitive melodies (and a small set of them).  You can play a melody from there like this: <br><br><pre> <code class="hljs vbscript"> inc Vec_Music_Flag <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>: jsr DP_to_C8 ldu #$fef8 ;     ROM jsr Init_Music_chk ;  jsr Wait_Recal ;       jsr Do_Sound ;  tst Vec_Music_Flag ;     beq endmusic jsr DP_to_D0 ; ,  ,   bra <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> endmusic:</code> </pre><br>  However, if we talk about playing normal music on 8912, the easiest way is to use YM_VPACK.EXE from the VecSound package from Christopher Salomon (you will need DosBox). <br><br>  YM_VPACK converts the well-known (in narrow circles :) format YM (YM5) to .asm, containing immediately a player (able to unpack music on the fly) and the music itself.  Under Windows, .ym can be obtained by exporting from Arkos Tracker, or by converting it with <a href="http://bulba.untergrund.net/emulator_e.htm">AY_Emul</a> (conversion from the playlist is carried out there). <br><br>  The .ym file for YM_VPACK must first be unpacked (the packaged YM is the lha archive).  It remains to set the assembler on it, resulting in a binary, including the player and music, which can be run on Vectrex.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is necessary to take into account that a lot of clock is spent a lot anyway (there is RLE unpacking on the fly). </font><font style="vertical-align: inherit;">But unpacked music will most likely take an unacceptable amount. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For sound effects through 8912 there is also a ready-made solution - AYFXEdit (PC / Win) and a player for them in the form of sfx.asm (from Richard Chadd).</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memory card </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memory is distributed as follows. </font></font><br><br><pre> <code class="hljs perl">$000<span class="hljs-number"><span class="hljs-number">0</span></span> - $7FFF -   (,  ) $800<span class="hljs-number"><span class="hljs-number">0</span></span> - $C7FF -     $C800 - $CBFF - ,  - <span class="hljs-number"><span class="hljs-number">874</span></span>  $C800 - $C87F - ,  Vectrex<span class="hljs-string"><span class="hljs-string">' $D000 - $D7FF -  VIA 6522 $D800 - $DFFF -     6522,   $E000 - $FFFF -  BIOS (  Minestorm)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When Vectrex is turned on, after the BIOS initializes the system and the splash screen is displayed, the program starts with the address $ 0000. </font><font style="vertical-align: inherit;">After pressing Reset, or when turned on with the "1" button pressed, the screen saver is skipped. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In case of any problems with reading the cartridge, the typical reaction of the system is to launch the built-in game MineStorm.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> About the mysterious ‚Äúzero ref‚Äù channel </font></font></h2><br>   Y, Z  SOUND       ,     'ZERO REF'      .  BIOS       Reset_Pen (  ACTGND    ‚Äî SET ACTIVE GROUND).  ,   ,  Reset0Ref (      )      .   svo   : <br><br> <i>‚Äî svo ---</i> <br><br>  DAC-     (  )  . ,   ,       DAC-  ,    .   S&amp;H,      ,      . <br><br>  ,  ,     Vref+-Vref- ( 14, 15)     .    Vref,    ,   ,  -        +   IC304/2.          . <br><br>     ¬´0¬ª   ?  ,       ,       ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The integrator integrates in time the value of the potential difference between the inputs of the OU. </font><font style="vertical-align: inherit;">For example, if the difference is 0, then the integral of this should be 0 even at T = eternity. </font><font style="vertical-align: inherit;">If the potential of the non-inverting input is not equal to the potential of zero, because we scored on the calibration, we get a nonlinearity, such as 1 - 0! = 2 - 1. The integral of zero will not be equal to zero and everything will go away in an unknown way. </font><font style="vertical-align: inherit;">Outwardly, this probably should appear as poorly predictable distortion of vectors. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- end svo ---</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DEVELOPMENT MEANS </font></font></h2><br>    Vectrex   ,        (Commodore, Atari, Spectrum  .)    Vectrex ‚Äî .         ,        -   . <br> ,        ‚Äî                 . ,        . <br><br>     ( 2016 .)  Vectrex ‚Äî <a href="http://vide.malban.de/">Vide</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/df7/4d2/873/df74d28731ac49d6b4f0e5a9766b5099.jpg"></div><br>     ( ,         Electric Force.       ).  ,   Vide   .      , ,      , ,     .        .   .     Vectrex   , Vide  ,    . ,       ParaJVE. <br><br>   Vectrex ‚Äî ParaJVE. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/686/7a5/90c/6867a590c281441f9133800072c37877.png"></div><br>    ParaJVD,     ParaJVE.    ,  <a href="http://parajvd.blogspot.ru/2010/03/parajvd-alpha-version.html"></a>       . <br><br>  How it works: <br><br>  - test.asm. ,  C:\Program Files (x86)\parajvd\data\sources\test <br><br>      as09 v1.41 / windows (79872 bytes)  a09.exe / windows (98304 bytes).     Win 64  (  6809    Win 64). <br><br>   as09,  ,       1)    2)    ()  . ,       . <br><br>    : <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">as09</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exe</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-i</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.asm</span></span> (  <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.bin</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">as09</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.exe</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ig</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-h0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-w200</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-l</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-m</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.asm</span></span> (   <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.dbg</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lst</span></span>)</code> </pre> <br>    .asm, .bin, .dbg, .lst <br><br> (.lst     , -,      , -,     ) <br><br>     .bin   jve: <br><br><pre> <code class="hljs cmake">ParaJVE.exe -game=<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>.bin</code> </pre> <br>     jvd: <br><br>  parajvd.bat,  .     (source mode) ‚Äî .lst  .dbg.    ( ): <br><br><blockquote> <i>So the DBG mode shows the source exactly as you typed it, whereas LST does not (if you look at the content of a generated LST file, you will see that it contains lots of ¬´garbage¬ª text, like generated addresses, etc.). But on the other hand, the LST option is good if your source uses a lot of macros (LST will display the expanded macro, whereas DBG will not).</i> </blockquote><br>   ¬´source¬ª   .asm (    ),  .dbg  .lst <br><br>    ,     jvd.bat .  jvd     test.bin.  . <br><br>     dbg/lst,     jvd (!).  Debug/Reload Cartridge ROM   jve.  Those. jvd <a href="http://www.vectrex.fr/tracker/view.php%3Fid%3D28">   </a> . <br>   Reload    .bin   ,   . ,       (,  breakpoint'e) ‚Äî  . <br><br> Breakpoint'    (..    jvd  ). <br><br>  :    JVE    .       .  ,      Wait_Recal           ( DP_to_D0   ).       ,       . <br><br>  ,            . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/276/628/55c/27662855cc314576a22d1ac5b016d36d.jpg" title="       Vectrex ()   ParaJVE ()"></div><br> ,        ,     BIOS',  ,    . <br><br>      ,    ‚Äî <a href="http://www.zophar.net/vectrex/dve.html">DVE</a> .     DOS.   ,    DosBox,        .   ,   help.dat/*  . <br><br>        Sublime Text 3,             JVE (  .bat). <br>  (JVD)     ‚Äî    ,   ,  . <br><br>       <a href="http://vide.malban.de/">Vide</a> . <br><br> ,       Vectrex.        svo (  USB),    <a href="http://www.vectrex.hackermesh.org/index.php/en/mvbd-mvmc-3/faq"></a> . <br><br>   .asm: <br><br><pre> <code class="hljs ruby"> <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">"vectrex.i"</span></span> org <span class="hljs-number"><span class="hljs-number">0</span></span> db <span class="hljs-string"><span class="hljs-string">"g GCE 2015"</span></span>, $80 ;    . <span class="hljs-string"><span class="hljs-string">'g'</span></span> -   dw $F600 ;             (   - ) db $F8, $32, <span class="hljs-number"><span class="hljs-number">33</span></span>, -$36; , , Y, X     db <span class="hljs-string"><span class="hljs-string">"PROGRAM TITLE"</span></span>, $80;   db <span class="hljs-number"><span class="hljs-number">0</span></span> ;    <span class="hljs-symbol"><span class="hljs-symbol">loop:</span></span> jsr Wait_Recal .... bra loop</code> </pre> <br>   ‚Ä¶   ,    Vectrex ‚Äî    ( C   Pascal).   DOS (..  DosBox)   . <br><br>              .      <a href="http://vectrexmuseum.com/share/coder/">http://vectrexmuseum.com/share/coder/</a> <br><br>    IDA.    6.7      DP (    ).  6.7.    ,    . <br><br>    DIS6809.EXE,  .     .ctl   : <br><br><pre> <code class="hljs css">; <span class="hljs-selector-tag"><span class="hljs-selector-tag">FILENAME</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CTL</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">TITLE</span></span> ___ <span class="hljs-selector-tag"><span class="hljs-selector-tag">ASM</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">FILE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">FILENAME</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.BIN</span></span> 000000 0000 076<span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LABS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LABELS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ENTRY</span></span> 0024 ;   <span class="hljs-selector-tag"><span class="hljs-selector-tag">ASCII</span></span> 0000 0023 ;  0  23 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ascii</span></span>  <span class="hljs-selector-tag"><span class="hljs-selector-tag">BYTE</span></span> 0710 0769 ;  0710  0769 <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>  (<span class="hljs-selector-tag"><span class="hljs-selector-tag">fcb</span></span>)</code> </pre><br>  etc. (    ,      ,         ).   DosBox  dis6809 filename.ctl &gt;filename.asm <br><br><h2>  ‚Äî    VECTREX </h2><br>       Vectrex ‚Äî Electric Force (233 ), Invitron (32 )    ‚Äî Rainy (413 )  Emptyscreentro (128 ). <br><br> <b>Electric Force</b> (233b) <br> <a href="">(source+bin)</a> <br><br><img src="https://habrastorage.org/files/6cb/fad/ff2/6cbfadff2bdd47d798b63643e496eecf.jpg"><br><br>        Vectrex   (   -   X   ,      Y).   ‚Äî ,   ,     Vectrex. ,      ,    Tiny intro  Chaos Constructions'2015. <br><br>  (ParaJVE)     (  ),        ‚Äî   Vectrex'a,    Youtube. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I must say that for how much I did not try to record a normal video (on Sony NEX7, 35 / F1.8) - it turns out only a miserable similarity to what is seen on the CRT screen. First of all, there is a catastrophic lack of dynamic range - between a completely black screen and a bright point on it, where the beam is delayed - a huge difference in brightness, which the camera cannot fix. In addition, do not convey smoothness (slow shutter speed reduces sensitivity). In short, the video is the fruit of compromise, as a result of which the ‚Äúwarm lamp‚Äù is inevitably lost, which is very disappointing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For the code itself in terms of drawing curves - see the relevant section of my article. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the end of the curves, the beam is deliberately delayed by several cycles, as a result of which bright dots appear - ‚Äúsparks‚Äù.</font></font><br><br> ¬´¬ª      BIOS,  ‚Äî    (     ;) <br><br>   ‚Äî  ,   (    +   +       +   +   )   30    ¬´¬ª. <br><br>    ‚Äî ,        .    Vectrex'a     ,      . <br><br>  ,       ,  Vectrex -   (    Vectrex'),       :) <br><br> <a href="http://www.youtube.com/watch%3Fv%3DlPZPBwaWRuk">Youtube</a> | <a href="http://www.pouet.net/prod.php%3Fwhich%3D66303">Pouet</a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invitron</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (32kb) </font></font><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(source + bin) The</font></font></a> <br><br><img src="https://habrastorage.org/files/b79/7d2/ad5/b797d2ad5f2444dda2619b9b7412b67c.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> work was written as an invitation intro at the Chaos Constructions'2015. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main volume of its 32k is digitized (7kHz) uncompressed voice - 20kb. The well-known (in narrow circles) phrase ‚Äúit smells of the demoscene here‚Äù was uttered by Random during the ‚ÄúRandom speech compo‚Äù on CC'2004. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Its playback is carried out through the DAC. After that, Plaigraunt by C-Jeff music starts playing through the AY8912 chip in the background. It is converted from pt3 to .YM via AY-Emul, then to data for VecSound via ym_vpack. Accordingly, VecSound is used as a player.</font></font><br><br>   ,     ,     ‚Äî   .  ,   ,   C-Jeff-     ,   ‚Äî      (  8912         :). <br><br>    VecSound   YM  .     ,     .           32   Vectrex. <br><br>      ‚Äî       ¬´Tron Legacy¬ª. ,   .   ,   30   (  ¬´¬ª)      (  ,   ). ,        ‚Äî    ,    .  ,     ,   ,      (   ,   .). <br><br>         ‚Äî         ,   ,  .  ,      ,  .         .    ,          . ,         ,           ¬´¬ª. ,    (ParaJVE)           . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The points at the ends of the vectors are bright not due to the brightness control, but due to the fact that the beam is delayed in this place for several cycles (the emulator does not understand this either, and in the video, unfortunately, there is almost no effect). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The text in the center initially wanted to display, drawing characters with vectors. However, this turned out to be completely unacceptable in tact. As a result, a reworked BIOS procedure is used to output the string "raster". The alteration was, firstly, in the deployment of subroutines that were called from it (to save ticks) and, secondly, one delay was corrected, due to which on most Vectrexes (as far as can be judged from different youtube videos) , long lines of text begins to warp in a certain direction.</font></font><br><br>   ,  ,   ‚Äî      BIOS,      , -, . <br><br>    ,  asm09win     ‚Äî    ,       ,   .      . <br><br> <a href="https://www.youtube.com/watch%3Fv%3Dvf_fb8G5Rdc">Youtube</a> | <a href="http://www.pouet.net/prod.php%3Fwhich%3D65963">Pouet</a> <br><br> <b>EmptyScreentro</b> (128b) <br> <a href="">(source+bin)</a> <br><br><img src="https://habrastorage.org/files/9e6/2e8/62a/9e62e862ae52426882619e334ccab9f6.jpg"><br><br>        (,    ,     ). <br><br>       ,       .     30    ,               .  ,     ,            .  ,   Vectrex           (   ). <br>            AY8912 (   ROM). <br><br>  <a href="https://www.youtube.com/watch%3Fv%3DHP0M89IQiQI">Youtube</a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rainy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (413b) </font></font><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(source + bin)</font></font></a> <br><br><img src="https://habrastorage.org/files/7a5/e09/060/7a5e09060ab54c14aed0a041bf42e6f3.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simulation of variable intensity jets of rain. A large number of vectors of different brightness and with a different pattern (changing in the process) is used. The maximum scale. Below, at the end of the line, the beam adheres for a while to get a bright point. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although this code was the first attempt to write something meaningful for Vectrex, the work was published last. With a great desire, the code can be cut at least twice (the data for the coordinates of the lines are not stored, but computed, and also partially used BIOS routines for Draw_Line_d, Move_D, Reset0Ref, Intensity_a (in this case they are removed from the BIOS and modified, which you can potentially do without ).</font></font><br><br>  <a href="https://www.youtube.com/watch%3Fv%3DMriSTEdnU5U">Youtube</a> <br><br><h2>  Links </h2><br><blockquote> ¬ª <a href="https://www.youtube.com/watch%3Fv%3DEYtilL7C23k">   Vectrex, CC'2015</a> <br> ¬ª <a href="http://vectrexmuseum.com/share/coder/">http://vectrexmuseum.com/share/coder/</a> <br> ¬ª <a href="http://vectorgaming.proboards.com/board/22/vectrex-programming-modifications-discussions"> vectorgaming</a> <br> ¬ª <a href="https://www.facebook.com/groups/104852679725118/"> Vectrex fans unite!</a>  <a href="https://www.facebook.com/groups/104852679725118/">on facebook</a> <br> ¬ª <a href="http://vide.malban.de/">Vide</a> <br> ¬ª <a href="http://parajvd.blogspot.com/">ParaJVD</a> <br> ¬ª <a href="http://vectrex-emu.blogspot.com/">ParaJVE</a> <br> ¬ª <a href="http://www.asm80.com/">Asm80 ‚Äî   6809,  </a> <br> ¬ª <a href="">,      ,    ( )</a> <br> ¬ª <a href="http://enlight.ru/post/9436/">      Frogger  Vectrex</a> <br> ¬ª <a href="http://enlight.ru/post/8956/"> svo  Vectrex (  )</a> <br> ¬ª <a href="http://enlight.ru/post/9575/">   ‚Äî Electric Force, Invitron, Rainy, EmptyScreenTro</a> </blockquote><br>        ¬´6809 Assembly Language Programming ‚Äî Leventhal.pdf¬ª, ¬´CoCoAssemblyLang_Color.pdf¬ª <br><br>  <a href="http://enlight.ru/roi/" rel="nofollow">Here</a> you can see my works for different retro platforms, and <a href="https://github.com/petersobolev" rel="nofollow">here</a> their sources are on github. <br><br>      2015      2016-. <br><br> <strong>PS</strong>    (tnt23)  Vectrex    (svo)    </div><p>Source: <a href="https://habr.com/ru/post/313218/">https://habr.com/ru/post/313218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313208/index.html">JsTree - building a simple tree using JAVA</a></li>
<li><a href="../313210/index.html">We test not absolutely real (or absolutely unreal) monitoring from New Relic and Appdynamics</a></li>
<li><a href="../313212/index.html">Blockchain ‚â† Cryptocurrency. Blockchain> Cryptocurrency</a></li>
<li><a href="../313214/index.html">The complete guide to native advertising in the mobile application</a></li>
<li><a href="../313216/index.html">Neural networks for beginners. Part 2</a></li>
<li><a href="../313224/index.html">Sudoku: so how many of them? Part 1/2</a></li>
<li><a href="../313226/index.html">Donald Knut: about his wife, kisses, "Concrete math" and a look at teaching at the university</a></li>
<li><a href="../313232/index.html">Will Microsoft HoloLens ignite or not?</a></li>
<li><a href="../313234/index.html">JavaScript 2016, and can be easier?</a></li>
<li><a href="../313236/index.html">ZeroNights 2016 program + HackQuest announcement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>