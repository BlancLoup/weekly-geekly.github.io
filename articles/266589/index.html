<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The way of writing parsers in c ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes how to write parsers using this small C ++ library. 

 Usually, the text in the machine language consists of sentences, those f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The way of writing parsers in c ++</h1><div class="post__text post__text-html js-mediator-article">  This article describes how to write parsers using <a href="https://github.com/FeelUsM/common-parse-lib/">this</a> small C ++ library. <br><br>  Usually, the text in the machine language consists of sentences, those from subproposals, and those in turn from subproposals, and so on up to symbols. <br><br>  For example, an xml element consists of an opening tag, a content, and a closing tag.  -&gt; The opening tag consists of '&lt;', the name of the tag, perhaps an empty attribute list and '&gt;'.  -&gt; The closing tag consists of '&lt;/', the tag name and '&gt;'.  -&gt; Attribute consists of name, '=', '"' characters, character strings and again '"'.  -&gt; Content in turn may also contain elements.  -&gt; Etc.  Thus, after parsing, a syntax tree is obtained. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Such languages ‚Äã‚Äãare conveniently described by the Backus-Naur form (BNF), where each non-terminal corresponds to a certain sentence of the language.  When we write programs, we usually break them down into functions and subfunctions, and since we are going to write a parser, <b>let</b> each non-terminal BNF have one function of our analyzer, and let each such function: <br><br><ul><li>  trying to parse this sentence from a given position </li><li>  returns, did she manage to do it </li><li>  returns the position where the parsing ended or an error occurred </li><li>  and also, perhaps, returns some additional data that we want to receive as a result of parsing </li></ul><br>  For example, for a BNF of the form <code>expr ::= expr1 expr2 expr3</code> we will write the following function: <br><a name="habracut"></a><br><pre> <code class="hljs lua">bool read_expr(<span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *&amp; p, ....){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!read_expr1(p, ....)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; // read_expr1()  p ,    expr1 //     p      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!read_expr2(p, ....)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!read_expr3(p, ....)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; /*     */ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre><br>  And for the BNF clause of the form <code>expr ::= expr1 | expr2 | expr3</code> <code>expr ::= expr1 | expr2 | expr3</code>  <code>expr ::= expr1 | expr2 | expr3</code> - function: <br><br><pre> <code class="hljs lua">bool read_expr(const <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *&amp; p, ....){ const <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> * l = p; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(read_expr1(p, ....)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; //p    ,      expr1 p = l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(read_expr2(p, ....)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; p = l; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(read_expr3(p, ....)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; /*     */ }</code> </pre><br>  (I think this is called parsing with returns) <br><br>  Not every text satisfying the BNF may suit us.  For example, an element of the xml language can be described as: <code>element ::= '&lt;'identifier'&gt;'some_data'&lt;/'identifier'&gt;'</code> , but this clause will only be an element if the identifiers match.  Such (or similar) checks can be easily added to parsing functions. <br><br>  Terminal functions may look like this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">bool</span></span> read_fix_char(const <span class="hljs-type"><span class="hljs-type">char</span></span> *&amp; it, <span class="hljs-type"><span class="hljs-type">char</span></span> c){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*it) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;//  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*it!=c) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;//   //       it++; //       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-type"><span class="hljs-type">bool</span></span> read_fix_str(const <span class="hljs-type"><span class="hljs-type">char</span></span> * &amp; it, const ch_t * s){ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(*it)//    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(*it!=*s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; //         <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> it++, s++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!*s) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;//     }</code> </pre><br>  So far we have been doing the parsing of the string.  But note that for all types of the above functions, iterator forward is sufficient. <br><br><h1>  forward stream </h1><br>  Let us set ourselves the goal of creating a stream class providing forward iterators and storing the file in memory not entirely but in small pieces.  Then, if you make the parsing functions template, then they can be used with strings and with threads.  (Which is done in ‚Äúbase_parse.h‚Äù for terminal (and so) functions.) But first, we will make some clarifications to the unix ideology ‚Äúeverything is a file‚Äù: There are files located on the disk - they can be read several times and from any position ( let's call them random-access files).  And there are streams redirected from other programs, going over the network or from the user from the keyboard (let's call them forward streams).  Such streams can only be read in one pass.  (fixme) Therefore, in order to work with both, we set ourselves the goal of creating a stream class reading a file in one pass, providing forward iterators, and storing the file in memory not entirely but in small pieces. <br><br>  For input iterators, such streams are implemented for a very long time; in fact, they contain only one input iterator, and inside they contain one buffer through which this iterator moves, and when it comes to the end of the buffer, the next piece of the file is loaded into this buffer, and the iterator starts moving from the beginning of the updated buffer. <br><br><img src="https://habrastorage.org/files/ef5/1d7/66e/ef51d766e3a549938c203cc584682318.png"><br><br>  Forward iterators differ from input iterators in that they can be copied.  For a stream with forward iterators, the solution will be a list of buffers.  As soon as any iterator goes beyond the limits of the rightmost buffer, a new buffer is added to the list, and populated directly from the file with a data block.  But gradually, the whole file will be loaded into memory, but we don‚Äôt want it.  Let's make it so that all buffers are deleted, which are to the left of the buffer on which the leftmost (lagging) iterator is located.  But we will not compare the list of iterators on it to each buffer, but we will only compare their number (iterator counting).  As soon as any buffer finds out that there are 0 iterators left on it and that it is the leftmost one, then it and all neighboring buffers are deleted to the right of it, on which there are also 0 iterators. <br><br><img src="https://habrastorage.org/files/b63/38e/f0a/b6338ef0a9504aadb1868c2bc7a87fce.png"><br><br>  It turns out that each iterator should contain: <br><ul><li>  pointer to character (which will be returned when dereference) </li><li>  pointer to the end of the array of characters in the buffer (it is compared when the iterator is moved) </li><li>  iterator over the list of buffers (to access the buffer data, and through them to the data of the entire stream). </li></ul><br>  When the iterator reaches the buffer boundary, it looks to see whether the next buffer is in the list of buffers; if it does not exist, it loads it, decrements the iterator count in the previous buffer, and increases it in the next one.  If the previous buffer contains 0 iterators, it is deleted.  If the iterator has reached the end of the file, it only decouples from the previous buffer and goes to the ‚Äúend of file‚Äù state.  When copying an iterator, the iterator count on the buffer on which it is located increases, and when the iterator destructor is called, the counter decreases, and again, if there are 0 iterators on the buffer, then it and the adjacent buffers, on which also 0 iterators, are deleted .  For implementation details, see <a href="">forward_ht.h</a> . <br><br>  Such iterators have some features of use that distinguish them from ordinary iterators.  So, for example, before a flow is destroyed (destructor) (which stores a list of buffers and some additional information) all iterators should be destroyed, since  when destroyed, they will access buffers regardless of whether they are destroyed in turn or not.  If we once received the first iterator as a result of calling the begin () method (and created the first buffer), and it left so much that the first buffer has already been deleted, we will not be able to get the iterator again using the begin () method.  Also (as will be seen in the next paragraph) the stream does not have the end () method.  As a result, I decided to make an internal iterator in the stream, which is initialized when the entire stream is initialized, and a link to which can be obtained using the iter () method.  Also, when used in algorithms, it is not worth once again to copy iterators, since  buffers are stored in memory from the leftmost to the rightmost iterator, and in the case of large files this can lead to a large memory footprint. <br><br>  As a bonus, there are various types of buffers: simple (basic_simple_buffer), with the calculation of a column row by iterator (basic_adressed_buffer), it is planned to make a buffer that performs the conversion between different encodings.  In this connection, the stream is parameterized by the type of buffer. <br><br><h1>  atend () </h1><br>  The end of the string is defined by a null character.  This means that while we are moving along a line in order to detect its end, we need not compare the pointer with another pointer (as is traditionally done in STL), but rather check the value indicated by our pointer.  With files, the situation is approximately the same: when character chars are entered character by character, we get ints, and since  they have a greater range of values, again we test each symbol for equality EOF.  The fact that the forward end position of the file is unknown in advance adds fuel to the fire. <br><br>  This information can be generalized by making the function atend (it), which for pointers on a line will look like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">atend</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * p</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !*p; }</code> </pre><br>  And for iterators over the stream, it will return true when the iterator points to the end of the file. <br><br><h1>  strin </h1><br>  Block buffering is not suitable for interactive user interaction (via stdin), since  In a block, several lines most often fit, and after entering one line, the program continues to wait for input from the user, since  the block is still empty.  This requires string buffering, when the buffer is filled with characters up to the line feed character.  In this library, you can select the type of buffering by choosing the type of file from which the stream is initialized (basic_block_file_on_FILE or string_file_on_FILE). <br><br>  strin is an internal stream iterator over stdin with string buffering. <br>  For non-interactive files when creating a stream, an iterator is created that points to the first character, which means that the first buffer is loaded.  For strin'a this is not permissible, because  the programmer may want to do something or display something before the program goes into standby mode. <br><br>  Therefore, when filling the first buffer, string files produce a dummy string "\ n".  To read it, there is a function start_read_line (it), after which the program goes into standby mode for entering a string, after which it is possible to parse this string without outputting iterators beyond the next '\ n' character. <br><br>  The programmer's field of analysis may want to display something again, and if after that he again needs data from the user, then start_read_line (strin) should be called again before receiving it. <br><br>  So  a cycle is obtained: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>){ <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">""</span></span> &lt;&lt;<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; start_read_line(strin); <span class="hljs-comment"><span class="hljs-comment">//    analys(strin); }</span></span></code> </pre><br>  Of course, this is a crutch, and it would be possible to make iterators that require loading the buffer only during dereferencing, but this would lead to additional checks when unfolding and simply complicating the entire system ... <br><br><h1>  Basic parsing functions </h1><br>  So that the user does not have to re-write terminal functions every time, they are already implemented in <a href="">‚Äúbase_parse.h‚Äù</a> .  Now they are implemented (except for handling floating numbers) in general, it is further planned to specialize them using string functions (such as strcmp, strstr, strchr, strspn, strcspn) for pointers in rows and for thread iterators.  They also allow the user to almost not think about the end of the file, and simply set the style of the code. <br><br>  Below is a brief summary of the basic functions of parsing, the returned values ‚Äã‚Äãand the statistics of their use in the implementation of two test parsers. <br><br><pre> <code class="hljs pgsql">size_t n ch_t c ch_t * s func_obj <span class="hljs-type"><span class="hljs-type">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(c) // <span class="hljs-type"><span class="hljs-type">bool</span></span> isspace(c) span spn //  bispan bspn //  func_obj err pf(it*) // <span class="hljs-type"><span class="hljs-type">int</span></span> read_spc(it*) func_obj err pf(it*, rez*) len - - ,   *pstr .        ..  EOF   EOF   <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_eof (it&amp;) .*$ <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_eof (it&amp;, pstr*) .*$ len len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_fix_length (it&amp;, n) .{n} <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_fix_length (it&amp;, n, pstr*) .{n} -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_fix_str (it&amp;, s) str -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) <span class="hljs-number"><span class="hljs-number">0</span></span>  (<span class="hljs-number"><span class="hljs-number">1</span></span>+len) <span class="hljs-number"><span class="hljs-number">9</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_fix_char (it&amp;, c) c <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass (it&amp;, spn) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass (it&amp;, bspn) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass_s (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>, pstr*) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass_s (it&amp;, spn, pstr*) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass_s (it&amp;, bspn, pstr*) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass_c (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>, ch*) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass_c (it&amp;, spn, ch*) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_charclass_c (it&amp;, bspn, ch*) [ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_c (it&amp;, ch*) . <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_while_charclass (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>) [ ]* -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_while_charclass (it&amp;, spn) [ ]* -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len <span class="hljs-number"><span class="hljs-number">2</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_while_charclass (it&amp;, bspn) [ ]* -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_while_charclass (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>, pstr*) [ ]* -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_while_charclass (it&amp;, spn, pstr*) [ ]* -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_while_charclass (it&amp;, bspn, pstr*) [ ]* -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_charclass (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>) .*[ ]&lt;- -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_charclass (it&amp;, spn) .*[ ]&lt;- -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_charclass (it&amp;, bspn) .*[ ]&lt;- -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_charclass (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>, pstr*) .*[ ]&lt;- -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_charclass (it&amp;, spn, pstr*) .*[ ]&lt;- -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len <span class="hljs-number"><span class="hljs-number">2</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_charclass (it&amp;, bspn, pstr*) .*[ ]&lt;- -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_char (it&amp;, c) .*c -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_char (it&amp;, c, pstr*) .*c -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK &lt;- -   ,               <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_str (it&amp;, s) .*str -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len <span class="hljs-number"><span class="hljs-number">2</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_str (it&amp;, s, pstr*) .*str -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_pattern (it&amp;, pf) .*( ) -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_pattern (it&amp;, pf, rez*) .*( ) -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_pattern_s (it&amp;, pf, pstr*) .*( ) -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_until_pattern_s (it&amp;, pf, pstr*, rez*) .*( ) -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK ch_t c ch_t * s func_obj <span class="hljs-type"><span class="hljs-type">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>(c) // <span class="hljs-type"><span class="hljs-type">bool</span></span> isspace(c) span spn //  bispan bspn //  func_obj err pf(it*) // <span class="hljs-type"><span class="hljs-type">int</span></span> read_spc(it*) func_obj err pf(it*, rez*) len - - ,   *pstr .        ..  EOF   EOF   <span class="hljs-type"><span class="hljs-type">int</span></span> read_line (it&amp;, s) .*[\r\n]&lt;- <span class="hljs-number"><span class="hljs-number">-1</span></span>  len len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_line (it&amp;) .*[\r\n]&lt;- <span class="hljs-number"><span class="hljs-number">-1</span></span>  len len <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> start_read_line (it&amp;) .*(\n|\r\n?) <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> OK &lt;- -   ,               <span class="hljs-type"><span class="hljs-type">int</span></span> read_spc (it&amp;) [:space:] -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_spcs (it&amp;) [:space:]* -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len <span class="hljs-number"><span class="hljs-number">5</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_s_fix_str (it&amp;, s) [:space:]*str -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) <span class="hljs-number"><span class="hljs-number">0</span></span>  len <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_s_fix_char (it&amp;, c) [:space:]*c <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_s_charclass (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>) [:space:][ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_s_charclass_s (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>, pstr*) [:space:][ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_s_charclass_c (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>, pc*) [:space:][ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_bln (it&amp;) [:blank:] -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_blns (it&amp;) [:blank:]* -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) len <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_b_fix_str (it&amp;, s) [:blank:]*str -(<span class="hljs-number"><span class="hljs-number">1</span></span>+len) <span class="hljs-number"><span class="hljs-number">0</span></span>  len OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_b_fix_char (it&amp;, c) [:blank:]*c <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_b_charclass (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>) [:blank:][ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_b_charclass_s (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>, pstr*) [:blank:][ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_b_charclass_c (it&amp;, <span class="hljs-keyword"><span class="hljs-keyword">is</span></span>, pc*) [:blank:][ ] <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-number"><span class="hljs-number">1</span></span> OK int_t   : long, long long, unsigned long, unsigned long long -   [:digit:] ::= [<span class="hljs-number"><span class="hljs-number">0</span></span>-"$(($ss-1))"] sign ::= (<span class="hljs-string"><span class="hljs-string">'+'</span></span>|<span class="hljs-string"><span class="hljs-string">'-'</span></span>) <span class="hljs-type"><span class="hljs-type">int</span></span> ::= spcs[sign]spcs[:digit:]+ .   . [w]<span class="hljs-type"><span class="hljs-type">char</span></span> char16/<span class="hljs-number"><span class="hljs-number">32</span></span> stream_string .        ..     <span class="hljs-type"><span class="hljs-type">int</span></span> read_digit (it&amp;, <span class="hljs-type"><span class="hljs-type">int</span></span> ss, int_t*) [:digit:] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>(EOF) <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_uint (it&amp;, <span class="hljs-type"><span class="hljs-type">int</span></span> ss, int_t*) [:digit:]+ <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_sign_uint (it&amp;, <span class="hljs-type"><span class="hljs-type">int</span></span> ss, int_t*) [sign][:digit:]+ <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_sign_s_uint (it&amp;, <span class="hljs-type"><span class="hljs-type">int</span></span> ss, int_t*) [sign]spcs[:digit:]+ <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_int (it&amp;, <span class="hljs-type"><span class="hljs-type">int</span></span> ss, int_t*) spcs[sign]spcs[:digit:]+ <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> OK OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_dec (it&amp;, int_t*) <span class="hljs-type"><span class="hljs-type">int</span></span>#[:digit:]=[<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-9</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> OK OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_hex (it&amp;, int_t*) <span class="hljs-type"><span class="hljs-type">int</span></span>#[:digit:]=[:xdigit:] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> OK OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_oct (it&amp;, int_t*) <span class="hljs-type"><span class="hljs-type">int</span></span>#[:digit:]=[<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-number"><span class="hljs-number">-7</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> OK OK <span class="hljs-type"><span class="hljs-type">int</span></span> read_bin (it&amp;, int_t*) <span class="hljs-type"><span class="hljs-type">int</span></span>#[:digit:]=[<span class="hljs-number"><span class="hljs-number">01</span></span>] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> OK OK</code> </pre><br>  Since  it is convenient to return an error code or an error message through the function name, so that the text of the parsers would look more obvious, I made special macros: <br><br><pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> r_if(expr) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((expr)==0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> r_while(expr) while((expr)==0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> r_ifnot(expr) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(expr) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> r_whilenot(expr) while(expr) /* r_ifnot(err=read_smth(it))// -   return err; */ //    read_while_sm  read_until #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> rm_if(expr) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((expr)&gt;=0) // . . '.*' * - multiple -&gt; m #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> rm_while(expr) while((expr)&gt;=0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> rm_ifnot(expr) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((expr)&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> rm_whilenot(expr) while((expr)&lt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> rp_if(expr) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((expr)&gt;0) // . . '.+' + - plus -&gt; p #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> rp_while(expr) while((expr)&gt;0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> rp_ifnot(expr) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">((expr)&lt;=0) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> rp_whilenot(expr) while((expr)&lt;=0) /* rm_if(read_until_char(it,'\n'))//  0      \n rp_if(read_until_char(it,'\n'))//  1      \n */</span></span></code> </pre><br>  Although it is possible to make some class that stores this information and is converted to bool accordingly. <br><br>  In general, I am opposed to non-constant references, and I believe that the arguments that the function should change should be passed to it by pointer and not by reference, so that when calling it it would be visible, but due to the fact that operators for pointers to anything it was impossible to overload, especially for compatibility with operator &gt;&gt; () (a couple of these are defined in "strin.h") I pass iterators everywhere by reference (and return values ‚Äã‚Äãfrom the pointer). <br><br>  At the moment there are two examples of using these functions: <a href="">calc.cpp</a> and <a href="">winreg.cpp</a> . <br><br><hr><br>  Thus, writing a parser does not require the ability to handle other parser generation programs.  Each non-terminal BNF translates into a function that, of course, is cumbersome compared to the description in the BNF (this can be further corrected by making a function that parses the regular expression, similarly as in &lt;boost / xpressive&gt;), but add any validation and data processing.  All this can be done both with strings and with threads in the same form.  The default input stream is ready for default input, and the &gt;&gt; operators, similar to those from the standard library, allow using this library instead of the standard input library. <br><br>  How to do tokenization using forward_stream, I will try to tell and show in the next article. </div><p>Source: <a href="https://habr.com/ru/post/266589/">https://habr.com/ru/post/266589/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266577/index.html">Underground carders market. Translation of the book "KingPIN". Chapter 2. Deadly Weapons</a></li>
<li><a href="../266581/index.html">Published exploit code for critical Android vulnerabilities Stagefright</a></li>
<li><a href="../266583/index.html">It is finished! io.js + NodeJS = NodeJS 4.0.0</a></li>
<li><a href="../266585/index.html">Open Source Calendar for JIRA</a></li>
<li><a href="../266587/index.html">Intel Threading Building Blocks 4.4 - what's new?</a></li>
<li><a href="../266591/index.html">How security holes are arranged: buffer overflow</a></li>
<li><a href="../266593/index.html">Absolute minimum. How quantum theory explains our world</a></li>
<li><a href="../266595/index.html">Simulator ghost. From the idea of ‚Äã‚Äãbecoming a programmer to the finished game on iOS</a></li>
<li><a href="../266597/index.html">Bash script to create an archive of data</a></li>
<li><a href="../266599/index.html">How to estimate the depth of the game mechanics. Part two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>