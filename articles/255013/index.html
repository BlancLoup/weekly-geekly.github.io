<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Cloud services under high load. Cackle experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! We, at Cackle , have been developing cloud SaaS solutions for websites since 2011. Our products are installed on more than 10,000 sites, every ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Cloud services under high load. Cackle experience</h1><div class="post__text post__text-html js-mediator-article">  Hello!  We, at <a href="http://cackle.ru/">Cackle</a> , have been developing cloud SaaS solutions for websites since 2011.  Our products are installed on more than 10,000 sites, every day we process an average of 65 million unique hits.  The bandwidth of the peaks reaches 780 Mb / s, and the database receives up to 120 million read requests per day, and up to 300 thousand write requests.  Such loads force us to invent difficult solutions, part of which we want to share. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f2/3ef/876/0f23ef876af0aea06fe3dfcd64d8b769.jpg" alt="Cackle cloud widgets"></div><a name="habracut"></a><br>  First, a few words about what we have developed in general, on what technologies and architecture everything is based, where the high load comes from.  And then - about 5 main decisions that we use to cope with this load. <br><br><h3>  <font color="#0078b6">Commenting system</font> </h3><br>  <a href="http://cackle.ru/comments">Cackle Comments</a> is our first product announced in 2011. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Simplifies the process of commenting due to convenient authorization - anonymous, social or one with your site.  It helps to attract more traffic due to indexing in search engines, broadcast comments on the walls of social networks (VK, My World, Facebook, Twitter), subscribe to new comments and replies.  Reduces the load due to the independence of your site. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdb/a42/a6a/cdba42a6a9a0280f9abddba5cd2999de.png" alt="Cackle Comments"></div><br><br><h3>  <font color="#0078b6">Online Store Feedback System</font> </h3><br>  <a href="http://cackle.ru/reviews">Cackle Reviews</a> is a review system, which was released in 2013.  Used mainly online stores, but works without any problems on any site. <br><br>  Key features: <br><br><ul><li>  Loading reviews from Yandex.Market; </li><li>  Indexing to Google with micromarking out of the box ( <a href="">ranking in search results</a> ); </li><li>  Follow-up sending letters with an invitation to leave a review after purchase; </li><li>  Convenient anonymous, social, unified authorization; </li><li>  Broadcast reviews in social networks: VK, My World, Facebook, Twitter; </li><li>  Moderation reviews in real time; </li><li>  Comments on reviews; </li><li>  SPAM protection; </li><li>  CMS plugins: <a href="http://marketplace.1c-bitrix.ru/solutions/cackle.reviews/">1C-Bitrix</a> , <a href="">Joomla (K2, Virtuemart, Zoo)</a> , <a href="">OpenCart</a> , <a href="">PrestaShop</a> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35c/b46/0bb/35cb460bb30ba80257f1c1519170cf98.png" alt="Cackle Reviews"></div><br><br><h3>  <font color="#0078b6">Online consultant</font> </h3><br>  <a href="http://cackle.ru/chat">Cackle Live Chat</a> - online chat for site visitors, release in 2013. <br><br>  Of the features: quick installation, the operator panel is implemented in the browser, no need to spend time installing the desktop client.  Social authorization of users, the operator receives information about the client (name, photo, email, link to the profile). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ef/725/939/0ef7259394e768d4b4ba245584c8e309.png" alt="Cackle Live Chat"></div><br><br><h3>  <font color="#0078b6">Polls widget</font> </h3><br>  <a href="http://cackle.ru/polls">Cackle Polls</a> - polls with the possibility of voting via social networks, IP or Cookie, the release also in 2013. <br><br>  Polls are automatically indexed by Google, attracting additional traffic.  You can upload images, there is video recognition YouTube and Vimeo. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/139/46c/d1013946c232f6eb9dd797ba1225cc7c.png" alt="Cackle Polls"></div><br><br><h2>  <font color="#144269">Technology</font> </h2><br>  The frontend in the understanding of Cackle is JavaScript.  Backend - data and logic server. <br><br><h3>  <font color="#0078b6">Frontend</font> </h3><br>  The frontend consists of widgets.  A widget is an executable JavaScript library based on other common JavaScript libraries.  Examples of shared libraries: <br><br><ul><li>  The library for working with DOM: jQuery was very slow and did not work on several mobile platforms, so they wrote their solution on Vanilla JS.  As a result, for some operations, the speed of work increased 600 times + our solution works on all versions of Android and iOS; </li><li>  Single Authorization Library (anonymous, social, SSO); </li><li>  Library of support for Real-time mode with a smart choice of interaction protocol (WebSocket, EventSource, Long-Polling); </li><li>  Cross Domain Library GET / POST requests; </li><li>  And others: work with the date, browser database (cookie, localstorage), json, image upload, video recognition (YouTube, Vimeo), notification tray, pagination, etc. </li></ul><br>  All widgets work without an iframe, due to which css can be modified to fit your site. <br><br>  There is a common widget loader (widget.js), something like RequireJS, just simpler.  The loader has two modes of operation - devel and prod.  The first is used in the development, loads the library in a loop.  The second is in production, loads the assembled bundle.  In prod mode, widgets are loaded from different servers randomly selected, resulting in balancing (more on this later). <br><br><div class="spoiler">  <b class="spoiler_title">Cross-browser loader code (widget.js part 1)</b> <div class="spoiler_text"><pre><code class="javascript hljs">Cackle.Bootstrap = Cackle.Bootstrap || { <span class="hljs-attr"><span class="hljs-attr">appendToRoot</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">child</span></span></span><span class="hljs-function">) </span></span>{ (<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'head'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">'body'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]).appendChild(child); }, <span class="hljs-comment"><span class="hljs-comment">// js loadJs: function(src, callback) { var script = document.createElement('script'); script.type = 'text/javascript'; script.src = src; script.async = true; if (callback) { if (typeof script.onload != 'undefined') { script.onload = callback; } else if (typeof script.onreadystatechange != 'undefined') { script.onreadystatechange = function () { if (this.readyState == 'complete' || this.readyState == 'loaded') { callback(); } }; } else { script.onreadystatechange = script.onload = function() { var state = script.readyState; if (!state || /loaded|complete/.test(state)) { callback(); } }; } } this.appendToRoot(script); }, // css loadCss: function(href) { var style = document.createElement('link'); style.rel = 'stylesheet'; style.type = 'text/css'; style.href = href; this.appendToRoot(style); }, //  css loadCsss: function(url, css) { for (var i = 0; i &lt; css.length; i++) { Cackle.Bootstrap.loadCss(url + css[i] + Cackle.ver); } }, //  js loadJss: function(url, js, i) { var handler = this; if (js.length &gt; i) { Cackle.Bootstrap.loadJs(url + js[i] + Cackle.ver, function() { handler.loadJss(url, js, i + 1); }); } }, //   load: function(host, js, css) { var url = host + '/widget/'; this.loadJss(url + 'js/', js, 0); if (css) this.loadCsss(url + 'css/', css); }, /** *   , ,  */ Comment: { isLoaded: false, load: function(host) { this.isLoaded = true; if (Cackle.env == 'prod') { //    Cackle.Bootstrap.load(host, ['comment.js'], ['comment.css']); } else { //         / Cackle.Bootstrap.load(host, ['fastjs.js', 'json2.js', 'rt.js', 'xpost.js', 'storage.js', 'login.js', 'comment.js'], ['comment.css']); } } }, ... }; //   (widget == 'Comment') //host -     (  ) if (!Cackle.Bootstrap[widget].isLoaded) { Cackle.Bootstrap[widget].load(host); }</span></span></code> </pre> </div></div><br><h3>  <font color="#0078b6">Backend</font> </h3><br>  This is a cluster of Apache Tomcat containers wrapped outside by Nginx servers.  Nginx in this case acts not only as a proxy, but also as an ‚Äúabsorber‚Äù of the load.  PostgreSQL database with streaming replication for several slaves. <br><br>  All backends are distributed across several data centers (Data Centers) of Russia and Europe.  Our experience has shown that hosting all servers in one data center is too risky, so now we are connected to three different data centers. <br><br><h3>  <font color="#0078b6">Real-time</font> </h3><br>  Support for real-time updates (comments, likes, editing, moderation, personal messages, chat) on the browser side, via any of the supported technologies: WebSocket, EventSource, Long-Polling.  That is, first we check if there is a WebSocket, then EventSource, Long-Polling.  In case of disconnects (errors), the connection is automatically restored by a function that monitors the connection status in setTimeout. <br><br>  On the server, we use the cluster Nginx + module <a href="https://github.com/wandenberg/nginx-push-stream-module">Push Stream</a> .  Only 3 servers: 2 common and 1 for online consultant.  Real-time messages from backends (Tomcat) are sent to all servers.  And in the browser, when connecting from the widget, any server is selected (randomly).  The result is something like balancing (unfortunately, Push Stream does not support balancing out of the box). <br><br>  In addition, there are: <br><br><ul><li>  Server loading, processing and storage of images; </li><li>  SMTP server. </li></ul><br><h2>  <font color="#144269">Architecture</font> </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c97/4fd/90d/c974fd90d8cb1a5daef611b86440435c.png" alt="Cackle servers"></div><br>  PG - PostgreSQL. <br>  RT - Real-time. <br>  DPC (1,2, ..., N) - various data centers. <br>  RMI - Java technology remote method call ( <a href="https://ru.wikipedia.org/wiki/RMI">wikipedia</a> ). <br><br>  For better understanding, the widget loading sequence diagram: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d7/66f/680/7d766f6809db26ecee419a7880a317d4.png" alt="Cackle widget bootstrap"></div><br><h2>  <font color="#144269">Load</font> </h2><br>  Below is a summary of the statistics on widgets and API calls. <br><br>  Unique hits per day: 60 - 70 million <br>  Peak requests per second: 2700 <br>  Peak simultaneous real-time sessions: 300,000 <br>  Peak bandwidth: 780 Mbps <br>  Traffic per day: 1.6 TB <br>  Nginx daily log summary: 102 GB <br><br>  Queries to the database for reading (per day): 80 - 120 million <br>  Requests to the database to write (per day): 300 000 <br><br>  Number of registered sites: 32 558 <br>  Number of registered users: 8 220 681 <br>  Comments posted: 23 840 847 <br>  Daily average increment of comments: 50,000 <br>  Daily average increase of users: 15 000 <br><br><h2>  <font color="#144269">Problems</font> </h2><br>  High load causes two problems: <br><br>  First, almost all hosters have a default server bandwidth of 100 Mb / s.  Anything higher is cut or, at best, you are asked to purchase additional lanes (and the prices there are several times higher than the cost of the servers themselves). <br><br>  The second problem is the load itself.  Physics can not be fooled, no matter how cool your server is, it has its limit. <br><br><h3>  <font color="#0078b6">¬ªSolution 1: Balancing in JavaScript</font> </h3><br>  Standard load sharing methods talk about balancing an input request on a server.  This will solve the second problem, but not the first one (bandwidth), since the outgoing traffic will still go through the same server. <br><br>  To solve two problems at the same time, we do the balancing in JavaScript, in the loader itself (widget.js), choosing the backend randomly.  As a result, the traffic is redirected to the servers from the cluster server widget, dividing the bandwidth between them and distributing the load. <br><br>  An additional huge plus of this method is caching javascript.  All libraries (including the widget.js loader), when refreshing the page, will be obtained from the browser cache, and our servers will continue to calmly process new requests. <br>  Loader code continuation (widget.js part 2): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Cackle = Cackle || {}; Cackle.protocol = (<span class="hljs-string"><span class="hljs-string">'https:'</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.location.protocol) ? <span class="hljs-string"><span class="hljs-string">'https:'</span></span> : <span class="hljs-string"><span class="hljs-string">'http:'</span></span>; Cackle.host = Cackle.host || <span class="hljs-string"><span class="hljs-string">'cackle.me'</span></span>; Cackle.origin = Cackle.protocol + <span class="hljs-string"><span class="hljs-string">'//'</span></span> + Cackle.host; <span class="hljs-comment"><span class="hljs-comment">//   (a.cackle.me, b.cackle.me, c.cackle.me): Cackle.cluster = ['a.' + Cackle.host, 'b.' + Cackle.host, 'c.' + Cackle.host]; //  , .  widget.js  1 Cackle.getRandInt = function(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } Cackle.getRandHost = function() { return Cackle.cluster[Cackle.getRandInt(0, Cackle.cluster.length - 1)]; }; Cackle.initHosts = function() { //getRandHost     var host = Cackle.getRandHost(); for (var i = 0; i &lt; cackle_widget.length; i++) { cackle_widget[i].host = Cackle.protocol + '//' + host; } }; //cackle_widget -      , //      (  ). //: cackle_widget.push({widget: 'Comment', id: 1}); Cackle.main = function() { Cackle.initHosts(); for (var i = 0; i &lt; cackle_widget.length; i++) { var widget = cackle_widget[i].widget; if (!Cackle.Bootstrap[widget].isLoaded) { Cackle.Bootstrap[widget].load(cackle_widget[i].host); } } }; Cackle.main();</span></span></code> </pre><br><h4>  What about professional CDN? </h4><br>  It's great!  The only problem is that with our volumes and loads, in order to use CDN it is necessary to raise prices at least 3 times, while maintaining the current turnover. <br><br><h3>  <font color="#0078b6">¬ªSolution 2: Nginx Micro-Cache</font> </h3><br>  A microcache is a cache with a very short lifespan, for example 3 seconds.  It is very useful at peak loads, with thousands of identical GET requests per second.  For us, this is widget data in JSON format.  It makes sense to make a microcache in proxy servers, for example, Nginx to protect the main backend (Tomcat). <br><br>  Part of the Nginx config with a microbag: <br><br><pre> <code class="nginx hljs">... <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /bootstrap { <span class="hljs-attribute"><span class="hljs-attribute">try_files</span></span> <span class="hljs-variable"><span class="hljs-variable">$uri</span></span> <span class="hljs-variable"><span class="hljs-variable">@proxy</span></span>; } ... <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> <span class="hljs-variable"><span class="hljs-variable">@proxy</span></span> { <span class="hljs-comment"><span class="hljs-comment"># (Tomcat) proxy_pass http://localhost:8888; proxy_redirect off; #      Nginx , # -   ,        proxy_ignore_headers X-Accel-Expires Expires Cache-Control; set $no_cache ""; #  GET|HEAD if ($request_method !~ ^(GET|HEAD)$) { set $no_cache "1"; } if ($no_cache = "1") { add_header Set-Cookie "_mcnc=1; Max-Age=2; Path=/"; add_header X-Microcachable "0"; } if ($http_cookie ~* "_mcnc") { set $no_cache "1"; } proxy_cache microcache; proxy_no_cache $no_cache; proxy_cache_bypass $no_cache; proxy_cache_key $scheme$host$request_method$request_uri; #  3  proxy_cache_valid 200 301 302 3s; proxy_cache_use_stale error timeout http_500 http_502 http_503 http_504 http_403 http_404 updating; default_type application/json; } ...</span></span></code> </pre><br>  If there are problems with understanding this config, then it is mandatory to read <a href="http_proxy_module.html">ngx_http_proxy_module</a> . <br><br><h3>  <font color="#0078b6">¬ªSolution 3: Tomcat tuning, Java cache</font> </h3><br><h4>  Tomcat </h4><br>  Especially tune Tomcat will not work.  From practical experience: <br><br><ul><li>  Do not bother with the choice of connector (Http11Protocol, Nio, Apr).  With large loads it does not matter. </li><li>  Make the connectionTimeout as minimal as possible, preferably not more than 5 seconds. </li><li>  Do not make too big maxThreads, it will not help, and in some the situation only hurts.  The standard for a loaded project is 300-350.  If this is not enough, add a new Tomcat server. </li><li>  But acceptCount can be made several thousand (2000-4000).  At small values, the connections are cut off (connection refused), and so will be added to the queue.  Do not forget to <a href="http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html">set the same or more backlog</a> in the OS. </li></ul><br><h4>  Java cache </h4><br>  It is considered to be a DB, in high-loaded projects, as a weak point.  It really is.  For example, the server accepts the request, sends it to the service level, where the service accesses the database and returns the result.  The link ‚Äúservice - DB (relational)‚Äù in this case is the slowest, so it is customary to wrap services with a cache.  Accordingly, the result from the database is placed in the service cache, and the next time it is used, it is taken from it. <br><br>  For caching services, we have developed our own cache, since standard ones (for example, Ehcache) work slower and do not always solve specific problems well.  Of the specific tasks we have is caching with support for several keys for one value.  We use org.apache.commons.collections.map.MultiKeyMap. <br><br>  You need this for what tasks.  For example, a user visits a page with comments.  Suppose a lot of comments, 300 pieces.  They are divided into three pages (pagination), respectively, 100 each.  When first accessed, the first page will be cached (100 comments), if the user scrolls down, then 2 and 3 pages will be cached in turn.  Now the user publishes a comment on this page and here you need to reset all three caches.  Using MultiKeyMap it looks like this: <br><br><pre> <code class="java hljs">MultiKeyMap cache = MultiKeyMap.decorate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LRUMap(capacity)); cache.put(chanId, <span class="hljs-string"><span class="hljs-string">"page1"</span></span>, commentSerivce.list(chanId, <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//chanId - id    cache.put(chanId, "page2", commentSerivce.list(chanId, 2)); //commentSerivce.list -     (chanId)   (2) cache.put(chanId, "page3", commentSerivce.list(chanId, 3)); cache.removeAll(chanId); //  3      </span></span></code> </pre><br>  Below is the kernel cache code that works fine on highload. <br><br><div class="spoiler">  <b class="spoiler_title">Cache kernel: thread-safety, deferred and only execution of the caching result, soft links to avoid OOM</b> <div class="spoiler_text"><pre> <code class="javascript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CackleCache</span></span></span><span class="hljs-class"> </span></span>{ private final MultiKeyMap CACHE = MultiKeyMap.decorate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LRUMap(capacity)); public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SoftValue</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">K</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SoftReference</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span></span>{ final K key; final long expired; public SoftValue(V ref, ReferenceQueue&lt;V&gt; q, K key, long timelife) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(ref, q); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.key = key; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expired = System.currentTimeMillis() + timelife; } } public synchronized Future&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt; get(final MultiKey key, final long timelife, final MethodInvocation invocation) { Future&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt; ret; @SuppressWarnings(<span class="hljs-string"><span class="hljs-string">"unchecked"</span></span>) SoftValue&lt;MultiKey, Future&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt;&gt; sr = (SoftValue&lt;MultiKey, Future&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt;&gt;) CACHE.get(key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sr != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { ret = sr.get(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ret != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sr.expired &gt; System.currentTimeMillis()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { sr.clear(); } } } ret = executor.submit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Callable&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt;() { @Override public <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> call() throws Exception { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> invocation.proceed(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(t); } } }); SoftValue&lt;MultiKey, Future&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt;&gt; value = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SoftValue&lt;MultiKey, Future&lt;<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>&gt;&gt;(ret, referenceQueue, key, timelife); CACHE.put(key, value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; } public synchronized <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> evict(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span> key) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CACHE.removeAll(key); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Throwable t) {} } }</code> </pre></div></div><br><h3>  <font color="#0078b6">"Solution 4: PostgreSQL streaming replication to different data centers</font> </h3><br>  In our opinion, PostgreSQL is the best solution for high-load projects.  Now it is fashionable to use NoSQL, but in most cases, with the right approach and the right architecture, PostgreSQL is better. <br><br>  In PostgreSQL, streaming replication works fine, and it does not matter in one subnet or in different networks, different data centers.  We have, for example, database servers located in several countries and no serious problems have been noticed.  The only caveat is large database modifications (ALTER TABLE) for releases.  It is necessary to make them in pieces, trying not to perform the whole UPDATE at once. <br><br>  There are a lot of resources on setting up replication, this is a hackneyed topic, so there‚Äôs nothing really to add, except: <br><br><ul><li>  Be sure to make a plan (config) in case of failover (drop master) and really test it; </li><li>  Understand the principle of WAL, so that in case the slave and master are out of sync, know why you need archives and where to put them; </li><li>  Watch the place on the HDD wizard, if suddenly it doesn‚Äôt become, then PostgreSQL can fall, and during replication it is fraught with big troubles. </li></ul><br><h3>  <font color="#0078b6">¬ªSolution 5: OS tuning</font> </h3><br>  Do not forget to <a href="http://tweaked.io/guide/kernel/">tune the parameters of the OS kernel</a> , because without this some settings of Nginx or Tomcat simply will not work. <br><br>  We have, for example, Debian everywhere.  In the OS kernel settings (/etc/sysctl.conf) special attention should be paid to: <br><br><pre> <code class="hljs dos">kernel.shmmax = <span class="hljs-number"><span class="hljs-number">8000234752</span></span> //   PostgreSQL,      shared_buffers (<span class="hljs-number"><span class="hljs-number">6</span></span> - <span class="hljs-number"><span class="hljs-number">8</span></span>GB) <span class="hljs-built_in"><span class="hljs-built_in">fs</span></span>.file-max = <span class="hljs-number"><span class="hljs-number">99999999</span></span> //   Nginx,     "Too many open files" <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_max_syn_backlog=<span class="hljs-number"><span class="hljs-number">524288</span></span> //       <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_max_orphans=<span class="hljs-number"><span class="hljs-number">262144</span></span> //       TCP <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.core.somaxconn=<span class="hljs-number"><span class="hljs-number">65535</span></span> //     <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_mem=<span class="hljs-number"><span class="hljs-number">1572864</span></span> <span class="hljs-number"><span class="hljs-number">1835008</span></span> <span class="hljs-number"><span class="hljs-number">2097152</span></span> //     TCP <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_rmem=<span class="hljs-number"><span class="hljs-number">4096</span></span> <span class="hljs-number"><span class="hljs-number">16384</span></span> <span class="hljs-number"><span class="hljs-number">16777216</span></span> //     TCP <span class="hljs-built_in"><span class="hljs-built_in">net</span></span>.ipv4.tcp_wmem=<span class="hljs-number"><span class="hljs-number">4096</span></span> <span class="hljs-number"><span class="hljs-number">32768</span></span> <span class="hljs-number"><span class="hljs-number">16777216</span></span> //  ,      TCP</code> </pre> <br><h2>  <font color="#144269">Problems that have not yet been resolved</font> </h2><br>  Rather, one problem - the size of the database.  There is sharding, of course, but we have not yet found a standard solution for PostgreSQL without a drop in performance.  If someone can share practical experience - welcome! <br><br>  Thanks for attention.  Questions and suggestions on <a href="http://cackle.ru/">our system are</a> welcome! </div><p>Source: <a href="https://habr.com/ru/post/255013/">https://habr.com/ru/post/255013/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255003/index.html">MMAS ant algorithm</a></li>
<li><a href="../255005/index.html">Quaternion rotation notes</a></li>
<li><a href="../255007/index.html">In the wake of WinHEC (Hardware Engineering Conference) 2015 - Windows 10, IoT, AllJoyn, clouds, and more</a></li>
<li><a href="../255009/index.html">Self-assembly 3d-printer or purchase ready-made equipment for the design. 3d printing. Part 3</a></li>
<li><a href="../255011/index.html">Improving sound quality on Android tablets with Intel Atom processors using the Dolby Digital API</a></li>
<li><a href="../255015/index.html">How to catch what is not. Part sad: what is an antivirus?</a></li>
<li><a href="../255019/index.html">Clouds - white-manned horses or secure ownCloud for ‚Äúsmall‚Äù ones in FreeNAS</a></li>
<li><a href="../255021/index.html">Top 100+ Wolfram | Alpha Sine Functions, or Wolfram | Alpha Overview of Mathematical Features and Syntax</a></li>
<li><a href="../255025/index.html">The story of creating another robot. Part One, Design</a></li>
<li><a href="../255027/index.html">DevCon 2015: announcement of the speakers - representatives of the community</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>