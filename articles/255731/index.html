<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>New analysis tool for SIMD programs - Vectorization Advisor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many of the posts on vectorization have been published on the company's blog, for example, a rather comprehensive review of the principles of auto-vec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>New analysis tool for SIMD programs - Vectorization Advisor</h1><div class="post__text post__text-html js-mediator-article">  Many of the posts on vectorization have been published on the company's blog, for example, a rather comprehensive review of the principles of auto-vectorization.  With each release of new Intel processors, the topic is becoming increasingly relevant for maximum application performance.  In this post, I will talk about Vectorization Advisor, which is included in many familiar Intel Advisor XE and allows you to solve many problems of vectorization code.  However, first about why it is needed. <a name="habracut"></a><br><br><h4>  Introduction </h4><br><br><img src="https://habrastorage.org/files/f26/5dd/a0d/f265dda0d03f42b382bd9953e3b61d16.png" alt="image"><br>  <i>Figure 1. The width of vector registers for different microarchitecture processors</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An important part of new microarchitecture processors is the increase in the length of vector registers and the emergence of new sets of vector instructions, known to all as MMX, SSE, AVX and AVX2, thanks to which several operations of the same type can be performed in one instruction.  To better understand how vectorization can speed up your program, take a look at the following graph. <br><br><img src="https://habrastorage.org/files/29e/bc8/921/29ebc8921ce1413c9f12881fbbaab369.png" alt="image"><br>  <i>Figure 2. Performance of different versions of the program for calculating the binomial options</i> <br><br>  Despite the possible synthetic nature of this benchmark, he says that not only parallelism (threading) already familiar to many, but also the effective use of vector registers is a key factor for achieving maximum performance.  There are several popular ways to achieve vectorization: <br><ul><li>  auto-vectoring by the compiler; </li><li>  use of the OpenMP * 4.0 standard (I will use them later) and Intel Cilk Plus. </li><li>  managed compiler vectorization - using vector directives such as #pragma ivdep and #pragma vector; </li><li>  Intel Cilk Plus Array Notation; </li></ul><br>  In addition, there are more complex ways, for example, the use of intrinsics and the use of vector instructions in assembly code. <br><br>  Fortunately, with the release of new versions of compilers, auto-vectorization becomes more accessible and effective.  To see how the compiler succeeded in this, you can add compilation keys (-optreport for Intel Compilers) and read the vectorization report with details for each cycle and the acceleration received.  But for many cases, everything is far from being so simple and you have to somehow help the compiler to understand that the code can and should be vectorized or rewritten the code, making the code vectorized.  Also, you should not think that the vectorized code is by default the most efficient in terms of performance.  It is often possible to see that the cycle, though vectorized, but the real acceleration is rather small.  These problems make the work of optimization engineers quite difficult and routine: you need to study the code, look at the messages from the compiler, examine the assembler code and data access patterns, check the correctness of the new version, modify the required part, evaluate the performance, etc. <br><br>  Good news: Vectorization Advisor greatly simplifies the routine part! <br><br>  The Intel Parallel Studio XE package provides ample opportunities for analyzing the code for performance evaluation, however, the earlier assessment of the code vectorization was not fully covered.  Intel Parallel Studio XE 2016 Beta includes a heavily updated Intel Advisor XE 2016 Beta, which actually combines two products: <br><ul><li>  Threading assistant - everything that was in Intel Advisor earlier, with several improvements. </li><li>  Vectorization Advisor is a completely new analysis tool for SIMD programs. </li></ul><br><br>  Where to begin?  To focus on performance problems and their possible causes, you need to run Survey. <br><br><h4>  Stage 1. Profiling (Survey Target) </h4><br>  So the first thing that Vectorization Advisor does is launch your application and profile it.  The tool provides a full report for each cycle, which includes analysis of hotspots, static analysis of binary modules, compiler messages.  Moreover, the new product includes recommendations and diagnostics from vectorization experts, only a part of which can be found at the Intel Developer Zone. <br><br><img src="https://habrastorage.org/files/345/c30/d49/345c30d493b548688de0ddfb7e583da5.png" alt="image"><br>  <i>Figure 3. Detailed program report after Survey analysis</i> <br><br>  The screenshots shown here and below show that after Survey the user receives a lot of important information: first you should pay attention to the time spent in the cycle (Self and Total time) in order to choose the most time-consuming.  Then you can focus on the cycles that are not yet vectorized.  In Figure 3 a scalar cycle is marked, which we will further consider and optimize.  There is compiler diagnostics for this cycle - information about the reasons why the cycle was not vectorized, here the compiler assumes the presence of dependencies.  Also, as shown below in the screenshot of step 1.1 (Figure 4), Vectorization Advisor is looking for performance problems and ways to solve them, and uses for this not only compiler information, but also static analysis of a binary file: acceleration estimates, various characteristics of assembler instructions, data types and so on.  All these data can be found here, for each cycle. <br>  It is assumed that the information obtained at this stage is sufficient to decide what needs to be improved and take the first steps towards a well-optimized program. <br><br><h4>  Step 1.1 Finding the number of iterations (Find Trip Counts) </h4><br>  Often, to solve problems with inefficient generation of vectorized cycles, you need to know the number of iterations in the cycle.  If the number of iterations is not constant (respectively, the compiler cannot evaluate it and use it for optimization), then it can be measured and give a hint to the compiler.  To do this, Vector Analysis Advisor has a new type of analysis - Trip Counts.  Another advantage of this analysis is that it integrates into the overall profile of the program, collected after Survey. <br><br><img src="https://habrastorage.org/files/3a3/271/185/3a3271185a5d46f3b995fedcdfcf5bf3.png" alt="image"><br>  <i>Figure 4. Program report, supplemented by the number of loop iterations</i> <br><br>  The yellow columns are those that appeared after searching for the number of iterations.  Here we see the average, minimum and maximum number of iterations, as well as the number of occurrences in the cycle and an indicator showing a significant number of occurrences that have a different number of iterations.  As noted earlier, the cycle we chose was not vectorized due to the assumed dependencies.  Consider the example code in more detail: <br><br><pre><code class="hljs lisp">#pragma omp parallel for private(<span class="hljs-name"><span class="hljs-name">i__3</span></span>,j,k,i__) schedule(<span class="hljs-name"><span class="hljs-name">guided</span></span>) if(<span class="hljs-name"><span class="hljs-name">i__2</span></span> &gt; <span class="hljs-number"><span class="hljs-number">101</span></span>) for (<span class="hljs-name"><span class="hljs-name">i__</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-comment"><span class="hljs-comment">; i__ &lt;= i__2; ++i__) { k = i__ * (i__ + 1) / 2; i__3 = *n; for (j = i__; j &lt;= i__3; ++j) { cdata_1.array[k - 1] += bb[i__ + j * bb_dim1]; k += j; } }</span></span></code> </pre> <br><br>  The outer loop is parallelized using OpenMP threads.  It would be nice to vectorize the internal loop, but Advisor XE talks about possible data dependencies, let's check it. <br><br><h4>  Stage 2.1 Dependency Check (Check Correctness) </h4><br>  To check for possible dependencies on the data that potentially impede vectorization, we mark the cycles of interest and run Correctness. <br><br><img src="http://habrastorage.org/files/d52/432/90a/d5243290a82b4e858f2906e300214007.png" alt="image"><br>  <i>Figure 5. The choice of cycles for subsequent analysis on the correctness</i> <br><br>  After collecting the data, we see that Advisor XE did not find any problems in this example, precluding the possibility to vectorize the code: <br><br><img src="http://habrastorage.org/files/9f1/b74/f18/9f1b74f18678441488e64b9f7bac4e86.png" alt="image"><br>  <i>Figure 6. Report after analyzing correctness</i> <br><br>  Since we were convinced of the security of vectorization (No dependencies found in Figure 6), we ‚Äúforce‚Äù the compiler to vectorize the cycle of interest to us, for this we add a directive <pre> <code class="hljs cs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> omp simd</span></span></code> </pre>  before the cycle: <br><br><pre> <code class="hljs lisp">#pragma omp parallel for private(<span class="hljs-name"><span class="hljs-name">i__3</span></span>,j,k,i__) schedule(<span class="hljs-name"><span class="hljs-name">guided</span></span>) if(<span class="hljs-name"><span class="hljs-name">i__2</span></span> &gt; <span class="hljs-number"><span class="hljs-number">101</span></span>) for (<span class="hljs-name"><span class="hljs-name">i__</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-comment"><span class="hljs-comment">; i__ &lt;= i__2; ++i__) { k = i__ * (i__ + 1) / 2; i__3 = *n; #pragma omp simd for (j = i__; j &lt;= i__3; ++j) { cdata_1.array[k - 1] += bb[i__ + j * bb_dim1]; k += j; } }</span></span></code> </pre><br><br>  Reconstruct Survey and get the following result: <br><br><img src="http://habrastorage.org/files/dc5/96c/366/dc596c3661594ba681111f3cdbb34445.png" alt="image"><br>  <i>Figure 7. The result for the selected cycle for optimization</i> <br><br>  The loop was vectorized using AVX instructions.  Cycle time fell to 0.77 seconds - received more than 2 times acceleration! <br><br><h4>  Step 2.2 Verify Memory Access Patterns Data Access Pattern </h4><br>  Similar to the analysis of correctness, the selected cycles can be checked for the efficiency of working with memory.  This is important because vectorization can be more or less effective depending on the order of access to the data, for example, accessing aligned data usually gives a more efficient code.  Note the cycles for which you want to get information and run the analysis of Memory Access Patterns. <br><br><img src="http://habrastorage.org/files/79a/81c/7a7/79a81c7a73814d9c9a66719ddcf1ce64.png" alt="image"><br>  <i>Figure 8. Data Access Template Report</i> <br><br>  As we see in Figure 8, the step of passing through the bb (stride) array is constant and equal to 8000 or 1000 (equal in different calls to bb_dim1).  The step along the c_data_1.array array is variable (994; 995; 996 ...), which, however, is rather difficult to fix without rewriting the algorithm.  It is desirable to make a single step, thereby organizing the prefetch of data, which the compiler ultimately does.  This can be seen by analyzing the instructions in the Instruction Set Analysis column, there are specific to this Insert and Shuffles. <br><br><h4>  findings </h4><br>  Vectorization Advisor will be useful where there is already a working code that needs to be further vectorized.  With the help of a new tool, everyone can get not only a full report containing a detailed view of the ‚Äúnarrow‚Äù points of the application, but also get recommendations for eliminating them.  Those who tried to do the analysis manually before the advent of Vectorization Advisor will save a huge amount of time, and those who did not know that it is possible will have a wonderful opportunity to optimize their application on their own! <br><br><h4>  Links </h4><br><ol><li>  <a href="http://habrahabr.ru/company/intel/blog/255175/">Intel Parallel Studio XE 2016 Beta - what's new?</a> </li><li>  <a href="https://software.intel.com/en-us/articles/intel-parallel-studio-xe-2016-beta">Intel Parallel Studio XE 2016 Beta</a> </li><li>  <a href="https://software.intel.com/en-us/articles/vectorization-advisor-faq">Vectorization Advisor FAQ</a> </li><li>  <a href="https://software.intel.com/en-us/vectorization_advisor_getting_started_intro">Vectorization Advisor Getting Started</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/255731/">https://habr.com/ru/post/255731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255721/index.html">How to set up Mac OS X, iOS simulator and RAD Studio XE8 (Delphi, C ++ Builder)</a></li>
<li><a href="../255723/index.html">CLion 1.0 - a powerful tool for powerful language</a></li>
<li><a href="../255725/index.html">Mobius conference: as in mobile devices opened the unobvious</a></li>
<li><a href="../255727/index.html">EastBanc Technologies at NSU Career Days</a></li>
<li><a href="../255729/index.html">Review of Veeam Endpoint Backup Free - a product for free backup of laptops and computers running Windows</a></li>
<li><a href="../255735/index.html">Build CSS sprites for MIME descriptors from svg / png icons</a></li>
<li><a href="../255737/index.html">Welcome to the first Moscow AndroidDevs Meetup on April 23</a></li>
<li><a href="../255739/index.html">Composer & Packagist 101</a></li>
<li><a href="../255741/index.html">PVS-Studio security research</a></li>
<li><a href="../255745/index.html">Philosophy of evolution and the evolution of the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>