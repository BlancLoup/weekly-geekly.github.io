<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>External Sort with O (1) Extra Memory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After reading this article , I remembered writing external sorting, which used O (1) external memory. The function received a binary file and the maxi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>External Sort with O (1) Extra Memory</h1><div class="post__text post__text-html js-mediator-article">  After reading <a href="http://habrahabr.ru/post/266557/">this article</a> , I remembered writing external sorting, which used O (1) external memory.  The function received a binary file and the maximum memory size that it could allocate for the array: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ext_sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memory)</span></span></span></span></code> </pre> <br>  I used the algorithm from <a href="https://scholar.google.co.il/scholar%3Fcluster%3D7995905689817415486%26hl%3Dru%26as_sdt%3D0,5">Effective Performance of External Sorting with No Additional Disk Space</a> : <br><br><ol><li>  Divide the file into blocks that fit into the available memory.  We denote these blocks as Block_1, Block_2, ..., Block_ (S-1), Block_S.  Set P = 1. </li><li>  We read Block_P in memory. </li><li>  We sort the data in memory and write it back to Block_P.  Set P = P + 1, and if P ‚â§ S, then read Block_P into memory and repeat this step.  In other words, sort each block of the file. </li><li>  We divide each block into smaller blocks B_1 and B_2.  Each of these blocks takes up half of the available memory. </li><li>  We read block B_1 of block_1 in the first half of the available memory.  Set Q = 2. </li><li>  We read block B_1 of block Block_Q in the second half of the available memory. </li><li>  We merge arrays in memory using in-place merge, write the second half of the memory into block B_1 of Block_Q and set Q = Q + 1 if Q ‚â§ S, read block B_1 of Block_Q into the second half of available memory and repeat this step. </li><li>  Write the first half of the available memory in block B_1 of Block_1.  Since we always left in the memory a smaller half of the elements and merged with all the blocks, M minimal elements of the entire file are stored in this part of the memory. </li><li>  We read block B_2 of Block_S in the second half of the available memory.  Set Q = S ‚àí1. </li><li>  We read block B_2 of Block_Q in the first half of the available memory. </li><li>  Let us combine the arrays in memory using in-place merge, write the first half of the available memory into the B_2 block of the Block_Q block and set Q = Q ‚àí1.  If Q ‚â• 1, we read block B_2 of Block_Q in the first half of the available memory and repeat this step. </li><li>  Write the second half of the available memory in the block B_2 of Block_S.  Similar to step 8, the maximum elements of the entire file are stored here. </li><li>  Starting from block B_2 of Block_1 and to block B_1 of Block_S, we define new blocks in the file and enumerate them again Block_1 to Block_S.  We divide each block into blocks B_1 and B_2.  Set P = 1. </li><li>  We read B_1 and B_2 of Block_P in memory.  We combine arrays in memory.  write the sorted array back to Block_P and set P = P +1.  If P ‚â§ S, repeat this step. </li><li>  If S&gt; 1, we return to step 5. Each time we select M minimum and maximum elements, write them to the beginning and end of the file, respectively, and then do the same with the remaining elements until we reach the middle of the file. </li></ol><br>  The advantage of this algorithm, besides the lack of a buffer on the disk, is that we read data from the disk in relatively large chunks, which speeds up the algorithm. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We implement the algorithm in C ++. <br><a name="habracut"></a><br>  To begin with, we will determine the number of blocks and the block size in bytes and in elements and allocate memory: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> filesize = file_size(filename); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">fstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::in | </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::out | </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::binary)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> chunk_number = filesize / memory; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size = memory / type_size - (memory / type_size) % <span class="hljs-number"><span class="hljs-number">2</span></span>, chunk_byte_size = chunk_size * type_size, half_chunk_byte_size = chunk_byte_size / <span class="hljs-number"><span class="hljs-number">2</span></span>, half_chunk_size = chunk_size / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; *chunk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(chunk_size);</code> </pre><br>  Now points 2-3 - we sort each block: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunk_number; ++i) { data.seekg(chunk_byte_size * i); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), chunk_byte_size); flat_quick_sort(chunk-&gt;begin(), chunk-&gt;end()); data.seekp(chunk_byte_size * i); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), chunk_byte_size); }</code> </pre><br>  We will write the sorting a little later. <br><br>  Let's start mergers.  Bottom half: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> s = chunk_number, start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { data.seekp(half_chunk_byte_size * start); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), half_chunk_byte_size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> q = <span class="hljs-number"><span class="hljs-number">1</span></span>; q &lt; s; ++q) { data.seekg(half_chunk_byte_size * start + chunk_byte_size * q); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (chunk-&gt;data() + half_chunk_size), half_chunk_byte_size); in_place_merge(chunk-&gt;begin(), chunk-&gt;begin() + half_chunk_size - <span class="hljs-number"><span class="hljs-number">1</span></span>, chunk-&gt;begin() + chunk_size); data.seekp(half_chunk_byte_size * start + chunk_byte_size * q); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (chunk-&gt;data() + half_chunk_size), half_chunk_byte_size); } data.seekp(half_chunk_byte_size * start); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), half_chunk_byte_size);</code> </pre><br>  And the same top: <br><br><pre> <code class="cpp hljs"> data.seekp(half_chunk_byte_size * start + chunk_byte_size * s - half_chunk_byte_size); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (chunk-&gt;data() + half_chunk_size), half_chunk_byte_size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> q = s - <span class="hljs-number"><span class="hljs-number">2</span></span>; q &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; --q) { data.seekg(half_chunk_byte_size * (start + <span class="hljs-number"><span class="hljs-number">1</span></span>) + chunk_byte_size * q); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), half_chunk_byte_size); in_place_merge(chunk-&gt;begin(), chunk-&gt;begin() + half_chunk_size - <span class="hljs-number"><span class="hljs-number">1</span></span>, chunk-&gt;begin() + chunk_size); data.seekp(half_chunk_byte_size * (start + <span class="hljs-number"><span class="hljs-number">1</span></span>) + chunk_byte_size * q); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), half_chunk_byte_size); } data.seekg(half_chunk_byte_size * start + chunk_byte_size * s - half_chunk_byte_size); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (chunk-&gt;data() + half_chunk_size), half_chunk_byte_size);</code> </pre><br>  Redistribute the blocks, end the cycle and do not forget to free the memory: <br><br><pre> <code class="cpp hljs"> --s; ++start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; p &lt; s; ++p) { data.seekp(half_chunk_byte_size * start + chunk_byte_size * p); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), chunk_byte_size); in_place_merge(chunk-&gt;begin(), chunk-&gt;begin() + half_chunk_size - <span class="hljs-number"><span class="hljs-number">1</span></span>, chunk-&gt;begin() + chunk_size); data.seekg(half_chunk_byte_size * start + chunk_byte_size * p); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), chunk_byte_size); } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> chunk; }</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Full function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ext_sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> filename, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> memory)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> type_size = <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(T); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> filesize = file_size(filename); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-function">fstream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(filename, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::in | </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::out | </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::ios::binary)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> chunk_number = filesize / memory; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> chunk_size = memory / type_size - (memory / type_size) % <span class="hljs-number"><span class="hljs-number">2</span></span>, chunk_byte_size = chunk_size * type_size, half_chunk_byte_size = chunk_byte_size / <span class="hljs-number"><span class="hljs-number">2</span></span>, half_chunk_size = chunk_size / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; *chunk = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(chunk_size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; chunk_number; ++i) { data.seekg(chunk_byte_size * i); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), chunk_byte_size); flat_quick_sort(chunk-&gt;begin(), chunk-&gt;end()); data.seekp(chunk_byte_size * i); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), chunk_byte_size); } <span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> s = chunk_number, start = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (s &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { data.seekp(half_chunk_byte_size * start); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), half_chunk_byte_size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> q = <span class="hljs-number"><span class="hljs-number">1</span></span>; q &lt; s; ++q) { data.seekg(half_chunk_byte_size * start + chunk_byte_size * q); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (chunk-&gt;data() + half_chunk_size), half_chunk_byte_size); in_place_merge(chunk-&gt;begin(), chunk-&gt;begin() + half_chunk_size - <span class="hljs-number"><span class="hljs-number">1</span></span>, chunk-&gt;begin() + chunk_size); data.seekp(half_chunk_byte_size * start + chunk_byte_size * q); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (chunk-&gt;data() + half_chunk_size), half_chunk_byte_size); } data.seekp(half_chunk_byte_size * start); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), half_chunk_byte_size); data.seekp(half_chunk_byte_size * start + chunk_byte_size * s - half_chunk_byte_size); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (chunk-&gt;data() + half_chunk_size), half_chunk_byte_size); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> q = s - <span class="hljs-number"><span class="hljs-number">2</span></span>; q &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; --q) { data.seekg(half_chunk_byte_size * (start + <span class="hljs-number"><span class="hljs-number">1</span></span>) + chunk_byte_size * q); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), half_chunk_byte_size); in_place_merge(chunk-&gt;begin(), chunk-&gt;begin() + half_chunk_size - <span class="hljs-number"><span class="hljs-number">1</span></span>, chunk-&gt;begin() + chunk_size); data.seekp(half_chunk_byte_size * (start + <span class="hljs-number"><span class="hljs-number">1</span></span>) + chunk_byte_size * q); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), half_chunk_byte_size); } data.seekg(half_chunk_byte_size * start + chunk_byte_size * s - half_chunk_byte_size); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) (chunk-&gt;data() + half_chunk_size), half_chunk_byte_size); --s; ++start; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span> p = <span class="hljs-number"><span class="hljs-number">0</span></span>; p &lt; s; ++p) { data.seekp(half_chunk_byte_size * start + chunk_byte_size * p); data.read((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), chunk_byte_size); in_place_merge(chunk-&gt;begin(), chunk-&gt;begin() + half_chunk_size - <span class="hljs-number"><span class="hljs-number">1</span></span>, chunk-&gt;begin() + chunk_size); data.seekg(half_chunk_byte_size * start + chunk_byte_size * p); data.write((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) chunk-&gt;data(), chunk_byte_size); } } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> chunk; }</code> </pre><br></div></div><br>  It remains to implement the flat_quick_sort and in_place_merge functions.  I took the idea (and most of the implementation) of flat quick sort in the <a href="http://habrahabr.ru/post/247053/">article of the</a> ripatti <a href="http://habrahabr.ru/users/ripatti/" class="user_link">habraiser</a> .  I just replaced the median of medians (considered it overkill on average) with median-of-nine and added sorting inserts for small parts of the array. <br><br><div class="spoiler">  <b class="spoiler_title">flat_quicksort.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> EXTERNAL_SORT_FLAT_QUICKSORT_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> EXTERNAL_SORT_FLAT_QUICKSORT_H template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ForwIt&gt; void insertion_sort(ForwIt be, ForwIt en) { for (ForwIt ii = be + 1; ii != en; ii++) { ForwIt jj = ii - 1; auto val = *ii; while (jj &gt;= be and *jj &gt; val) { *(jj + 1) = *jj; --jj; } *(jj + 1) = val; } } template&lt;class ForwIt&gt; ForwIt median_of_3(ForwIt it1, ForwIt it2, ForwIt it3) { return (*it1 &gt; *it2) ? (*it3 &gt; *it2) ? (*it1 &gt; *it3) ? it3 : it1 : it2 : (*it3 &gt; *it1) ? (*it2 &gt; *it3) ? it3 : it2 : it1; } template&lt;class ForwIt&gt; ForwIt choose_pivot(ForwIt be, ForwIt en) { ptrdiff_t s = (en - be) / 8; ForwIt mid = be + (en - be) / 2; ForwIt best1 = median_of_3(be, be + s, be + 2 * s), best2 = median_of_3(mid - s, mid, mid + s), best3 = median_of_3( en - 2 * s, en - s, en); return median_of_3(best1, best2, best3); } // search for the end of the current block template&lt;class ForwIt&gt; ForwIt block_range(ForwIt be, ForwIt en) { ForwIt it = be; while (it != en) { if (*be &lt; *it) return it; ++it; } return it; } // warning: after the partition outer pivot may point to random element template&lt;class ForwIt&gt; std::pair&lt;ForwIt, ForwIt&gt; partition_range(ForwIt be, ForwIt en, ForwIt pivot) { std::pair&lt;ForwIt, ForwIt&gt; re; ForwIt j = be; for (ForwIt i = be; i != en; ++i) if (*i &lt; *pivot) { if (pivot == i) pivot = j; else if (pivot == j) pivot = i; std::swap(*j, *i); ++j; } re.first = j; for (ForwIt i = j; i != en; ++i) if (*pivot == *i) { if (pivot == i) pivot = j; else if (pivot == j) pivot = i; std::swap(*j, *i); ++j; } re.second = j; return re; } // makes largest element the first template&lt;class ForwIt&gt; void blockify(ForwIt be, ForwIt en) { for (ForwIt it = be; it != en; ++it) if (*be &lt; *it) std::swap(*be, *it); } template&lt;class ForwIt&gt; void flat_quick_sort(ForwIt be, ForwIt en) { ForwIt tmp = en; // the current end of block while (be != en) { if (std::is_sorted(be, tmp)) { be = tmp; tmp = block_range(be, en); continue; } if (tmp - be &lt; 32) insertion_sort(be, tmp); else { ForwIt pivot = choose_pivot(be, tmp); std::pair&lt;ForwIt, ForwIt&gt; range = partition_range(be, tmp, pivot); blockify(range.second, tmp); tmp = range.first; } } } #endif //EXTERNAL_SORT_FLAT_QUICKSORT_H</span></span></span></span></code> </pre><br></div></div><br>  Merging was harder.  First, I used a stub using O (n) memory: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;T&gt; &amp;chunk, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> q, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt; *chunk2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;(q - s + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it2 = chunk2-&gt;begin(), it1 = chunk.begin() + q + <span class="hljs-number"><span class="hljs-number">1</span></span>, it = chunk.begin() + s; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(it, it1, it2); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (it2 != chunk2-&gt;end() &amp;&amp; it1 != chunk.begin() + r + <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*it1 &gt; *it2) { *it = *it2; ++it2; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *it = *it1; ++it1; } ++it; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it1 == chunk.begin() + r + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(it2, chunk2-&gt;end(), it); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy(it1, chunk.begin() + r + <span class="hljs-number"><span class="hljs-number">1</span></span>, it); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> chunk2; }</code> </pre><br>  When I wanted to replace the in-place stub with the version, it turned out that the fast in-place merge algorithms are mostly quite complicated (see, for example, <a href="https://scholar.google.com/scholar%3Fcluster%3D15596289922936727341%26hl%3Dru%26as_sdt%3D0,5">On optimal and efficient in place merging</a> ).  I needed something simpler, and I chose the algorithm from the article <a href="https://scholar.google.co.il/scholar%3Fcluster%3D8489305296842245618%26hl%3Dru">A simple algorithm for in-place merging</a> : <br><br><div class="spoiler">  <b class="spoiler_title">in-place merge</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Iter&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">merge_B_and_Y</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iter z, Iter y, Iter yn)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (; z &lt; y &amp;&amp; y &lt; yn; ++z) { Iter j = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min_element(z, y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*j &lt;= *y) <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(*z, *j); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(*z, *y); ++y; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; y) flat_quick_sort(z, yn); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Iter&gt; <span class="hljs-function"><span class="hljs-function">Iter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">find_next_X_block</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iter x0, Iter z, Iter y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f, Iter b1, Iter b2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">auto</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> min1 = max, min2 = max; Iter m = x0 + (<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>((z - x0 - f) / k) * k + f, x = x0; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m &lt;= z) m += k; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> i = m; i + k &lt;= y; i += k) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != b1 &amp;&amp; i != b2) { Iter j = (i &lt; b1 &amp;&amp; b1 &lt; i + k) ? m - <span class="hljs-number"><span class="hljs-number">1</span></span> : i + k - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*i &lt;= min1 &amp;&amp; *j &lt;= min2) { x = i; min1 = *i; min2 = *j; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Iter&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in_place_merge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Iter x0, Iter y0, Iter yn, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> k, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rec)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (k == <span class="hljs-number"><span class="hljs-number">-1</span></span>) k = (<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(yn - x0); <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> f = (y0 - x0) % k; Iter x = (f == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? y0 - <span class="hljs-number"><span class="hljs-number">2</span></span> * k : y0 - k - f; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t = *x, max = *<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max_element(x0, yn); *x = *x0; Iter z = x0, y = y0, b1 = x + <span class="hljs-number"><span class="hljs-number">1</span></span>, b2 = y0 - k; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (y - z &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * k) { ++i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*x &lt;= *y || y &gt;= yn) { *z = *x; *x = *b1; ++x; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x - x0) % k == f) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &lt; x - k) b2 = x - k; x = find_next_X_block(x0, z, y, k, f, b1, b2, max); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *z = *y; *y = *b1; ++y; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((y - y0) % k == <span class="hljs-number"><span class="hljs-number">0</span></span>) b2 = y - k; } ++z; *b1 = *z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z == x) x = b1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z == b2) b2 = yn + <span class="hljs-number"><span class="hljs-number">1</span></span>; ++b1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((b1 - x0) % k == f) b1 = (b2 == yn + <span class="hljs-number"><span class="hljs-number">1</span></span>) ? b1 - k : b2; } *z = t; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (rec) merge_B_and_Y(z, y, yn); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { flat_quick_sort(z, y); in_place_merge(z,y,yn,(<span class="hljs-keyword"><span class="hljs-keyword">int64_t</span></span>)<span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(k),<span class="hljs-literal"><span class="hljs-literal">true</span></span>); } }</code> </pre><br></div></div><br>  But on my computer, replacing merge with in-place merge slowed down the algorithm by almost an order of magnitude.  Maybe I was mistaken in the implementation or simply chose a slow algorithm in pursuit of simplicity.  There was no time to understand, as always, and for some reason, the gprof fell.  And then it dawned on me.  If we allocate M bytes of dynamic memory, it doesn‚Äôt matter how we use it, we still get O (1).  Then just select 2/3 for the data, and a third for the merge buffer.  The slowdown will be much less.  And the truth is: <br><table><tbody><tr><th>  Algorithm </th><th>  Time (75MB ‚Äã‚Äãint64 in 7.5MB of memory) </th><th>  Speed ‚Äã‚Äã(75MB ‚Äã‚Äãint64 in 7.5MB of memory) </th><th>  Time (7.5MB int64 to 75KB of memory) </th><th>  Speed ‚Äã‚Äã(7.5MB int64 in 75KB of memory) </th><th>  Time (750MB int64 to 75MB of memory) </th><th>  Speed ‚Äã‚Äã(750MB int64 in 75MB memory) </th></tr><tr><td>  In-place merge </td><td>  6.04329 s </td><td>  1,241,045 b / s </td><td>  24.2993 s </td><td>  3,086,508 b / s </td><td>  - </td><td>  - </td></tr><tr><td>  Merge </td><td>  0.932663 s </td><td>  8,041,489 b / s </td><td>  2.73895 s </td><td>  27,382,756 B / s </td><td>  47.7946 s </td><td>  15 691 689 b / s </td></tr><tr><td>  Algorithm <a href="http://habrahabr.ru/users/sly_g/" class="user_link">SLY_G</a> </td><td>  1.79629 s </td><td>  4175272 b / s </td><td>  3.84775 s </td><td>  19,491,910 B / s </td><td>  39.77 s </td><td>  18,858,436 B / s </td></tr></tbody></table>  Unfortunately, the algorithm slows down on large volumes, which is expected, because we do not use any buffer at all.  Nevertheless, the speed of the algorithm is quite adequate, and I am sure it can be improved. <br><br>  All sources are <a href="https://github.com/Randl/CS/tree/master/External%2520sort">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/268535/">https://habr.com/ru/post/268535/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268519/index.html">DevTips: Web Developer Tips (1-16)</a></li>
<li><a href="../268523/index.html">GPIO settings in Coremodule 920</a></li>
<li><a href="../268527/index.html">Adaptive email-letters and media queries: Problems and solutions</a></li>
<li><a href="../268531/index.html">Writing a graphical Python program with tkinter</a></li>
<li><a href="../268533/index.html">Cloud for development companies: 1C in the cloud, complete guide</a></li>
<li><a href="../268537/index.html">A laser pointer is enough to confuse the so-called ‚Äúsmart car‚Äù</a></li>
<li><a href="../268539/index.html">= ^ ._. ^ =</a></li>
<li><a href="../268541/index.html">On-line connection without marriage</a></li>
<li><a href="../268545/index.html">We shared the Internet: a lot of us, but it is not</a></li>
<li><a href="../268547/index.html">Manage different types of disks on a virtual server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>