<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kubernetes in production: services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Six months ago, we completed the migration of all our stateless services to kubernetes. At first glance, the task is quite simple: you need to deploy ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kubernetes in production: services</h1><div class="post__text post__text-html js-mediator-article"><p><img align="left" width="250" src="https://habrastorage.org/webt/ww/yz/_z/wwyz_zvbfjx8vrreqprenpo0a00.png">  Six months ago, we completed the migration of all our stateless services to kubernetes.  At first glance, the task is quite simple: you need to deploy a cluster, write application specifications and go ahead.  Because of the obsession with the issue of ensuring stability in the operation of our service, we had to immediately begin to understand how k8s works and test various failure scenarios.  Most of the questions I had to everything related to the network.  One of these "slippery" moments - the work of services (Services) in kubernetes. </p><br><p>  The documentation tells us: </p><br><ul><li>  roll out the app </li><li>  set the liveness / readiness of the sample </li><li>  create a service </li><li>  then everything will work: load balancing, bounce handling, and so on. </li></ul><br><p>  But in practice everything is more complicated.  Let's see how it actually works. </p><a name="habracut"></a><br><h2 id="nemnogo-teorii">  Some theory </h2><br><p>  Further, I mean that the reader is already familiar with the device kubernetes and its terminology, just remember what a service is. </p><br><p>  <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> - the essence of k8s, which describes a set of <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/">pods</a> and methods of access to them. </p><br><p>  For example, we launched our application: </p><br><pre><code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: webapp spec: selector: matchLabels: app: webapp replicas: 2 template: metadata: labels: app: webapp spec: containers: - name: webapp image: defaultxz/webapp command: ["/webapp", "0.0.0.0:80"] ports: - containerPort: 80 readinessProbe: httpGet: {path: /, port: 80} initialDelaySeconds: 1 periodSeconds: 1</code> </pre> <br><pre> <code class="bash hljs">$ kubectl get pods -l app=webapp NAME READY STATUS RESTARTS AGE webapp-5d5d96f786-b2jxb 1/1 Running 0 3h webapp-5d5d96f786-rt6j7 1/1 Running 0 3h</code> </pre> <br><p>  Now, in order to access it, we need to create a service in which we define to which subsections we want to have access (selector) and on which ports: </p><br><pre> <code class="plaintext hljs">kind: Service apiVersion: v1 metadata: name: webapp spec: selector: app: webapp ports: - protocol: TCP port: 80 targetPort: 80</code> </pre> <br><pre> <code class="bash hljs">$ kubectl get svc webapp NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE webapp ClusterIP 10.97.149.77 &lt;none&gt; 80/TCP 1d</code> </pre> <br><p>  Now we can access our service from any cluster machine: </p><br><pre> <code class="bash hljs">curl -i http://10.97.149.77 HTTP/1.1 200 OK Date: Mon, 24 Sep 2018 11:55:14 GMT Content-Length: 2 Content-Type: text/plain; charset=utf-8</code> </pre> <br><h2 id="kak-eto-vse-rabotaet">  How it all works </h2><br><img src="https://habrastorage.org/webt/bn/uc/y4/bnucy4fkcptbeo3fwyycr-fc6po.jpeg"><br><p>  Very simplistic: </p><br><ul><li>  you made kubectl apply Deployment specifications </li><li>  there is magic, the details of which are not important in this context </li><li>  As a result, on some nodes, there were working applications </li><li>  Once a kubelet interval (the k8s agent on each node) performs liveness / readiness samples of all the subs running on its node, it sends the results to the apiserver (interface to the k8s brains) </li><li>  kube-proxy on each node receives notifications from apiserver about all changes to services and pods that are involved in services </li><li>  kube-proxy reflects all changes in the configuration of the <a href="https://kubernetes.io/docs/concepts/services-networking/service/">underlying subsystems</a> (iptables, ipvs) </li></ul><br><p>  For simplicity, consider the default method of proxying - iptables.  In iptables we have for our virtual ip 10.97.149.77: </p><br><pre> <code class="bash hljs">-A KUBE-SERVICES -d 10.97.149.77/32 -p tcp -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp: cluster IP"</span></span> -m tcp --dport 80 -j KUBE-SVC-BL7FHTIPVYJBLWZN</code> </pre> <br><p>  traffic goes to the chain <strong>KUBE-SVC-BL7FHTIPVYJBLWZN</strong> , in which it is distributed between 2 other chains </p><br><pre> <code class="bash hljs">-A KUBE-SVC-BL7FHTIPVYJBLWZN -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp:"</span></span> -m statistic --mode random --probability 0.50000000000 -j KUBE-SEP-UPKHDYQWGW4MVMBS -A KUBE-SVC-BL7FHTIPVYJBLWZN -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp:"</span></span> -j KUBE-SEP-FFCBJRUPEN3YPZQT</code> </pre> <br><p>  this is ours </p><br><pre> <code class="bash hljs">-A KUBE-SEP-UPKHDYQWGW4MVMBS -p tcp -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp:"</span></span> -m tcp -j DNAT --to-destination 10.244.0.10:80 -A KUBE-SEP-FFCBJRUPEN3YPZQT -p tcp -m comment --comment <span class="hljs-string"><span class="hljs-string">"default/webapp:"</span></span> -m tcp -j DNAT --to-destination 10.244.0.11:80</code> </pre> <br><h2 id="testiruem-otkaz-odnogo-iz-podov">  Testing the failure of one of the pods </h2><br><p>  My webapp test application is able to switch to the "rash errors" mode, for this you need to do pull the URL "/ err". </p><br><p>  The results of ab -c 50 -n 20000 in the middle of the test yanked "/ err" on one of the platforms: </p><br><pre> <code class="bash hljs">Complete requests: 20000 Failed requests: 3719</code> </pre> <br><p>  The point here is not in the specific number of errors (their number will vary depending on the load), but in the fact that they exist.  In general, we threw the "bad" under out of balancing, but at the time of switching the client of the service received errors.  The reason for the errors is fairly easy to explain: the readiness of the test is performed by the kubelet once a second + even a short time for the dissemination of information that did not respond to the test. </p><br><h2 id="pomozhet-li-ipvs-bekend-dlya-kube-proxy-experimental">  Will IPVS help backend for kube-proxy (experimental)? </h2><br><p>  Not really!  It solves the problem of optimization of proxying, offers a custom balancing algorithm, but does not solve the problem of processing failures. </p><br><h2 id="kak-byt">  How to be </h2><br><p>  This problem can be solved only by a balancer who can retry (retries).  In other words, for http we need an L7 balancer.  Such balancers for kubernetes are already fully used either in the form of <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">ingress</a> (meant as a point in turn into a cluster, but by and large does exactly what you need), or as an implementation of a separate layer - a service mesh, for example <a href="https://istio.io/">istio</a> . </p><br><p>  In our production we didn‚Äôt use either ingress or service mesh due to the added complexity.  Such abstractions, in my opinion, help in cases where you need to often configure a large number of services.  But at the same time you ‚Äúpay‚Äù for controllability and simple infrastructure.  You will spend extra time to figure out how to set up schedules, timeouts for a particular service. </p><br><h2 id="kak-delaem-my">  How do we </h2><br><p>  We use headless k8s services.  Such services do not have a virtual ip and, accordingly, kube-proxy and iptables do not participate in their work.  For each such service, you can get a list of live podov either through DNS, or through the API. </p><br><p>  For applications that interact with other services, we make a sidecar container with <a href="https://github.com/envoyproxy/envoy">envoy</a> .  Evoy periodically receives an up-to-date list of hearths for all necessary services via DNS, and most importantly is able to make repeated attempts to query other hearths in case of an error.  You can run it as a DaemonSet on each node, but then if this instance fails, all applications that use it would stop working.  Since the consumption of resources by this proxy is rather small, we decided to use it exactly in the sidecar container variant. </p><br><p>  This is essentially exactly what istio does, but in our case the balance has shifted towards simplicity (no need to learn istio, run into its bugs).  Perhaps this balance will change, and we will start using something like istio. </p><br><p>  <em>We in <a href="https://okmeter.io/%3Futm_source%3Dhabr%26utm_medium%3Dhabr-post%26utm_campaign%3Dblog%26utm_content%3Dk8s_services">okmeter.io</a> kubernetes definitely got accustomed, and we believe in its further distribution.</em>  <em>Support monitoring k8s in our service on the way, stay tuned!</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/424229/">https://habr.com/ru/post/424229/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424211/index.html">Understand the Container Storage Interface (in Kubernetes and not only)</a></li>
<li><a href="../424215/index.html">Elm. Comfortable and awkward</a></li>
<li><a href="../424217/index.html">Discourse on holy wars, and prayer for peace</a></li>
<li><a href="../424223/index.html">Disposable customers. Segmentation for repeat purchases</a></li>
<li><a href="../424227/index.html">Evenly distribute points over a sphere in pytorch and tensorflow</a></li>
<li><a href="../424231/index.html">How to make money on hosters</a></li>
<li><a href="../424233/index.html">Computer taught to determine dementia with an accuracy of 93%</a></li>
<li><a href="../424235/index.html">How to use STATSPACK instead of AWR in Oracle Standard Edition</a></li>
<li><a href="../424237/index.html">Charge your brains directly! Rantime, compilers and performance on Joker 2018</a></li>
<li><a href="../424239/index.html">IBM's Autumn Seminars - Containers, Computer Vision, Digital Transformation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>