<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C calls in Go: principle of operation and performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Go language has recently been repeatedly discussed in the Habr√© ‚Äî it was both criticized and praised . We at Intel love Go and participate in the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C calls in Go: principle of operation and performance</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f71/c71/b16/f71c71b166ff4a31a5b8f8c6180f61e6.png"><br>  The Go language has recently been repeatedly discussed in the Habr√© ‚Äî it was both <a href="https://habrahabr.ru/post/269731/">criticized</a> and <a href="https://habrahabr.ru/post/269817/">praised</a> .  We at Intel love Go and participate in the open-source development of this project.  If you use Go too, you are interested in its internal structure and questions of the most effective programming in this wonderful language, then welcome under cat.  The article will be about how the external call mechanism is implemented in Go and how fast it works. <br><a name="habracut"></a><br>  The main principle guided by the creators of Go when designing a language is the maximum simplicity of the organization of this project.  The creators deliberately avoid the "overload" and unnecessary functionality available "by default", so all the additional functionality is made into utilities that users of the language can install at will.  Thus, Go is not just a platform, it is also a set of useful standard utilities.  Go itself includes only the minimum necessary for them, but a great many additional useful tools are always available, provided by the creators of the language or created by the community.  For example, among the standard utilities there is <b>go vet</b> , which helps to catch suspicious constructs in the code (and in addition you can put <b>go lint</b> , <b>errcheck</b> , <b>structcheck,</b> and others).  The <b>test</b> utility automates the testing of packages, <b>fix</b> - will help in the transition to the new version of Go and the modified API and will make the necessary changes in the already existing code.  The creators of Go took care of the convenience and ease of use of these tools, and writing code makes them easy and enjoyable. <br><br>  Among other things, the creators also provide for the possibility of using C-libraries in Go-programs.  This is very important, because at the moment Go-shny packages exist far from all occasions, while in C almost everything is implemented.  To use all this wealth of C-libraries in Go, the cgo utility is created.  It analyzes the Go code and when compiling the Go program, if necessary, calls the C compiler for the connected C code with the specified flags, and also forms one package from the C and Go files.  With its help, C-code is very easy to integrate into Go (see, for example, <a href="http://akrennmair.github.io/golang-cgo-slides/">here</a> ) <br><br>  But inevitably the question arises, how will Go code that actively use C calls work?  In order to understand this, you need to learn a little more about the internal mechanism of work environment Go.  Looking ahead, I will say that we need this knowledge, because they will allow us to doubt the effectiveness of the work of C-challenges, and to do further analysis ... But let's get everything in order. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  <font color="#0071c5">How the runtime environment works</font> </h1><br>  In Go, there are go-routines - these are the ‚Äúuser-level‚Äù execution threads - go-routines are switched within one system thread, each of them has its own stack.  It should be noted that the organization of the multithreading model in Go is under a strict theory, namely, the theory of interacting Hoare consecutive processes ( <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a> ), used for the formal description of the functioning of parallel systems. <br><br>  Go is known for its ability to create a huge amount (tens and hundreds of thousands) of go-routines.  This is possible due to the fact that initially all go-routines require quite a few resources for their creation - namely, all of them are created with a small stack size (2K stack versus 2M in the case of a standard flow on Linux / x86-32), and in the process their stack relocates as needed.  The means of interaction go-rutin is the <a href="https://blog.golang.org/pipelines">channel</a> . <br><br>  Here the question arises: how will the C-calls fit into this system?  Will the stack increase for the needs of the C function in the same way as it does for a go-routine?  How will the go-routine be planned when making an outside call?  At first, all this is quite obvious. <br>  Let's first understand the general mechanism of go-rutin, without external calls.  To understand how everything works, consider the internal entities Go, which are usually denoted by the letters <b>g</b> , <b>m</b> and <b>p</b> .  Someone is probably familiar with them under the <a href="https://morsmachine.dk/go-scheduler">article</a> about the go-scheduler device, the translation of which is <a href="http://habrahabr.ru/company/ua-hosting/blog/269271/">also available</a> . <br><br>  <b>g</b> - structure go-routine descriptor.  It contains all the information specific to one go-routine, including data on the current boundaries of its stack, the program counter, and a pointer to the handle of the current system thread in which this go-run is executed (it is indicated by <b>m</b> , and about it just below) .  Go-routines are put to execution by the scheduler, which is called at the right moment for this ‚Äî for example, when the executed go-routine makes a system call or an I / O operation. <br><br>  Each system thread created by the Go runtime is in turn described by the structure <b>m</b> .  M contains internal stream data: its identifier, the go-routine currently running in it, there are state description fields (spinning, blocked, dying) and other Go-specific fields.  But among other things there are data that will interest us further - these are the boundaries of the stack allocated to the flow, as well as a pointer to something called the ‚Äúexecution context‚Äù. <br><br>  The execution context of <b>p</b> is also a special structure.  The context is needed by the system thread <b>m</b> in order to perform go-routines.  Inside itself, p stores a local queue of go-routines, ready for execution.  As soon as <b>m has</b> acquired some context <b>p</b> , he can execute go-routines from the local queue belonging to this context.  If the local queue is empty, then work-stealing will occur from the queues of other <b>p</b> .  There is also a global queue, which all <b>p</b> check periodically. <br>  It is important to understand that there are usually many system threads <b>m</b> at the same time, often more than contexts.  But only those threads that have context can do the go-rutin.  The number of contexts can be set by the GOMAXPROCS environment variable, and by default it is equal to the number of processor cores.  Due to the fact that the number of contexts is fixed, the whole set of go-routines is multiplexed to a given number of OS threads. <br><br>  The point of introducing a context is that it can be transferred between different OS threads, and the usual go-routines from the local context queue will not notice the difference.  When can this be needed?  Then when you need to release the current thread for some kind of blocking task.  Let's pretend that passing context is impossible.  Then if any one go-routine makes a system call, then for those remaining in the local queue it will mean idle.  And since the system call can be blocking, the go-routines can remain blocked indefinitely, and this should not be allowed.  The transfer of context solves this problem and allows go-routines from the queue to continue to run even in such cases.  That is why, before making a system call, the context is transferred to some other free system thread <b>m</b> , and the queue will continue to work freely on this new thread.  The system call will be made on the source thread, but without the execution context. <br><br>  So, we looked at the basic <b>g, m, p</b> entities and slightly touched on system calls.  Now we come to the question of external calls in Go. <br><br><h1>  <font color="#0071c5">How external calls are made</font> </h1><br>  As you can see, in Go, the execution model is not at all peculiar to C functions.  Therefore, external calls must be handled in a special way, outside the go-rutin mechanism.  But we have already started talking about handling system calls in Go ‚Äî and what if the system calls are also inside the C function?  Since this cannot be known knowingly, from the point of view of Go, any arbitrary C-function should be processed so that the system calls inside it work correctly.  Consequently, there should be common points in handling Go C-calls and system calls.  Let's take a closer look at them, but along the way we will note the differences. <br><br><h5>  Both syscall and arbitrary C-call are executed in a separate system thread. </h5><br>  We cannot know in advance how long it will take to make a C-call.  In the same way as a system call, it can be blocking, and other go-routines should not suffer from this.  Therefore, the C-call, like the system call, is always executed in a separate thread, first passing the context to another <b>m</b> .  If at the moment of calling free <b>m</b> in the pool was not, then <b>m</b> is created on the go.  Important note: since both C functions and system calls are executed without context, they are not subject to the GOMAXPROCS restriction, which means that they will be executed in a separate thread even with GOMAXPROCS = 1.  This way it is guaranteed that the execution of the go-rutin cannot be blocked by anyone. <br><br>  We also emphasize that the created system threads remain alive after the completion of a system call or C function and can be reused, and new <b>m</b> will always be created only in the absence of free ones. <br><br><h5>  Both are required to "switch" the stack. </h5><br>  As you might guess, the go-routine stack and the OS thread stack are not the same thing.  This is already clear from those considerations that the go-routine is many times larger than threads, plus the entire stack size of each go-routine changes dynamically during the program. <br>  Indeed, the go-rutin stacks are heaped and maintained by the runtime, regardless of the OS thread stacks.  Initially, all go-routines start with a small 2K stack, then the stack can grow and shrink.  While system stacks are the most common stacks of system threads m.  In order to store the borders of the system stack, there is a special go-routine <b>g0</b> in the structure <b>m</b> : it is special because the limits of the system stack are stored as its stack.  From here and the accepted designation for a system stack in Go: <b>m-&gt; g0 stack</b> . <br><br>  System calls and C functions work on the <b>m-&gt; g0</b> stack.  That is why, before launching them, a "stack switch" is required.  In the case of the C function, this will be done inside the <i>runtime.asmcgocall ()</i> function.  There is literally the following: <br><ul><li>  The current SP go-routine is saved in spec.  m field of structure. </li><li>  SP go-routine: = SP of this system thread. </li></ul><br>  In the case of a system call, the difference lies in the fact that, for the sake of optimization, not all of them will be performed on the system stack, but only some internal functions for which this is explicitly spelled out (and the switching is done inside the <i>systemstack ()</i> function). <br><br>
<h5>  In both cases, you need the binding of the calling go-routine to the current thread m </h5><br>  So, in order for the C functions to execute correctly, they need to be run on the system <br>  stack  But there is one more thing: before the control is transferred to the C-code, you need to inform the execution environment that the stream becomes "sish", and it cannot be used to plan new go-routines.  This is done using the <i>runtime.LockOSThread ()</i> function.  Thus, it is guaranteed that no other go-routine will be assigned to this m until the current one is completed, or until the current go-routine does not call <i>runtime.UnlockOSThread ()</i> . <br><br><h5>  There is some delay when returning from a system call or from a C function. </h5><br>  After the completion of the C function or the system call, the go-routine may not always immediately continue to be executed.  Remember, before executing the C function itself, the context <b>p</b> was passed to another thread <b>m</b> ?  Now we are again returning to the execution of the Go code, which means that in order to continue execution we need to get the context again (the same or different). <br><br>  In the current implementation of the go-routine scheduler, it first tries to get the same execution context <b>p</b> that was given by it.  If this succeeds (for example, if <b>p is</b> not used by anyone and is in the idle state), then the work continues (and the delay is minimal). <br><br>  If it is impossible to get p at once, and all other <b>p are</b> also busy, then the go-routine is blocked.  The reason for this is the existing GOMAXPROCS restriction: no more than <i>$ GOMAXPROCS</i> go-rutin can run simultaneously (that is, no more than there are contexts), and a new go-rut is set to be executed only when one of the executables is ready to ‚Äúgive up‚Äù i.e.  will do some kind of blocking operation.  It turns out that, returning from the C-call, the go-routine will have to wait until someone ‚Äúgives up‚Äù the context at will.  If external calls occur frequently, then waiting for the release of <b>p</b> upon returning from the C-call can spoil everything. <br><br>  It is not difficult to see if you write the following code: <br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> <span class="hljs-string"><span class="hljs-string">"runtime"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { runtime.GOMAXPROCS(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wg sync.WaitGroup wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> wg.Done() work() }() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> spinlock() } wg.Wait() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spinlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"I am working!"</span></span>) }</code> </pre> <br>  Here, with the given constraint GOMAXPROCS = 5, 10 go-routines are created, which work in infinite cycles, and then another go-routine that displays something on the screen.  After all of them are created, some 5 of them receive contexts and are executed.  If you run this example several times, you can catch the situation when work has time to get the context at the beginning and work out.  But if it turns out that 5 ‚Äúendless‚Äù go-routines have started to be executed, then they will not give up the context, and work () will never be able to be executed. <br><br><h1>  <font color="#0071c5">C function call</font> </h1><br>  Let's follow the course of events occurring during the C-call.  Let some C-function <b>f ()</b> be called.  This unfolds into the next sequence of calls shown in the figure.  The solid arrow indicates the function call, the dotted line is the return of control. <br><br><img src="https://habrastorage.org/files/7b7/c0e/a49/7b7c0ea4997146109abc93ea7f36ffac.png"><br><br>  Let's see what will happen at each step: <br>  Step 1. Fixing the Go-routine for the current <b>m</b> (call lockOSThread ()) <br>  Step 2. Choosing <b>m</b> from the pool of system threads (if there are no free <b>m</b> - creating a new thread) and passing the context to the selected <b>m</b> <br>  Step 3. Switching the stack of the go-routine to <b>m-&gt; g0</b> operating system thread stack <br>  Step 4. Preparing the C-function call <b>f</b> and directly calling the function itself.  By preparation is meant a casting to the calling agreement corresponding to a specific architecture (for example, on <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">x86_64,</a> the function arguments will be put in the corresponding registers).  Returning the value of the C-function also occurs by agreement, so if necessary, a reverse cast will be done (on x86_64, the return value from the register will be moved to the stack) <br>  Step 5. Reverse switching from the OS stack stack to the stack of the current go-routine ( <b>m-&gt; curg</b> stack) <br>  Step 6. Exitsyscall () - the function is blocked inside it until it is possible to execute the Go code without violating the $ GOMAXPROCS restriction <br>  Step 7. As soon as execution is possible - detach the go-routine from <b>m</b> (unlockOSThread ()) <br><br>  Here it should be noted that the creators of Go also provides the ability to make callback-and.  A callback happens like this: from a Go-code, a call is made to some C-function, which is passed as an argument to a pointer to some Go-function.  In the course of its work, this C-function calls the Go-function according to the pointer passed to it. <br><br>  At a minimum, the case discussed in the previous part suggests that delays in waiting p will significantly affect the effectiveness of callback.  Let's take a closer look at why this is so.  We dealt with what is happening in the C-call, but in order to execute the internal Go-code from C, the following actions will be performed: <br><ol><li>  A new go-routine will be created. </li><li>  Then a reverse stack switch will be performed (from the system one to the stack of the new go-routine) </li><li>  New go-routine for execution is needed <b>p</b> .  Therefore, it will be blocked and just as when returning from an external call, it will wait until some <b>p is released</b> . </li></ol><br>  Thus, in the case of callback, in addition to the delay of return from the C-call already considered (due to the expectation of a free p), there is one more delay of the same nature.  We obtain that the waiting time <b>p</b> makes a double contribution to the overhead. <br><br><h1>  <font color="#0071c5">How well it works.</font>  <font color="#0071c5">Overhead</font> </h1><br>  So, let us once again denote the nature of the costs arising from external calls from the go-routine: <br><br>  <i>Situation 1. A go-routine is waiting for p to be released after returning from the C function.</i> <br>  In this situation, it would seem, there is nothing terrible.  But let us imagine that we have a lot of go-rutin and C-calls from them occur quite often (for example, even if we wrote a wrapper to our favorite library and use it according to all Go canons, through a lot of go-rutin).  With multiple C-calls, these delays will be, firstly, more likely, and secondly, more prolonged. <br><br>  <i>Situation 2. At the next external call, there was not enough free flow to execute the remaining go-routines.</i> <br>  In this case, a forced creation of a new thread will occur and the execution context will be transferred to it.  Because of this, even the simplest C-function will be executed with a significant delay equal to the overhead of creating an OS-stream.  This kind of delay cannot be predicted in the course of the program, since the threads, as we found out, are created out of necessity. <br><br>  To estimate these costs, you can measure the time spent on the call to an empty C-function from the go-routine in two possible situations: <br>  1) In a situation where a new thread is created. <br>  2) In case the existing stream is reused. <br>  This was done by us.  Below is a simple program with which data was obtained. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">// Run program as ./program pb=&lt;int&gt; // where pb means P_blocked - number of Ps to be in a spinlock. // Program prints to console time (in nanoseconds) elapsed by one C call that is done in goroutine import "fmt" import "time" import "flag" import "sync" // int empty_c_foo() {} //    import "C" func spin_lock() { for { } } func main() { var wg sync.WaitGroup wg.Add(1) pb_ptr := flag.Int("pb", 3, "number of Ps that will be in spinlock") flag.Parse() P_blocked := *pb_ptr for i := 0; i &lt; P_blocked; i++ { // ¬´¬ª   go spin_lock() } go func() { // C.empty_c_foo() //   2 defer wg.Done() time1 := time.Now() C.empty_c_foo() time2 := time.Now() fmt.Println(int64(time2.Sub(time1))) }() wg.Wait() }</span></span></code> </pre><br>  In paragraph 1, it is enough to measure the time for one empty C-function called first - since this will be the very first external call, then at the moment it occurs, there is guaranteed no free <b>m</b> in the pool, which means that we will create the thread that we need.  In case 2, the program is similar, but measurements are already being made for a repeated C-call, it is expected that the costs will be significantly lower, since <b>m</b> will already be created on the first call. <br><br>  To simulate the ‚Äúloaded‚Äù execution environment, a number of go-routines were created that were occupied in infinite cycles: their number is indicated by P_spinlocked = 5, 10, 15, ..., 35, and for each such value 100,000 program and measurement launches were made.  The program was launched on Intel¬Æ Xeon¬Æ CPU E5-2697 v2 @ 2.70GHz.  By car 48 cores, the parameter GOMAXPROCS = 40, the machine was in exclusive use. <br><br>  <b>Experimental results for C-call when a new thread is created</b> <br><table><tbody><tr><th>  Number P_spinlocked = </th><th>  five </th><th>  ten </th><th>  15 </th><th>  20 </th><th>  25 </th><th>  thirty </th><th>  35 </th></tr><tr><td>  % emissions&gt; average + 3 degree of deviation </td><td>  0.28% </td><td>  0.36% </td><td>  0.31% </td><td>  0.31% </td><td>  0.30% </td><td>  0.27% </td><td>  0.28% </td></tr><tr><td>  The average </td><td>  2537 </td><td>  2438 </td><td>  2518 </td><td>  2534 </td><td>  2626 </td><td>  2686 </td><td>  2719 </td></tr><tr><td>  Standard deviation </td><td>  201 </td><td>  470 </td><td>  200 </td><td>  224 </td><td>  346 </td><td>  369 </td><td>  393 </td></tr><tr><td>  Median </td><td>  2512 </td><td>  2523 </td><td>  2493 </td><td>  2500 </td><td>  2540 </td><td>  2590 </td><td>  2613 </td></tr><tr><td>  Maximum </td><td>  58182 </td><td>  65798 </td><td>  59543 </td><td>  58243 </td><td>  55700 </td><td>  66620 </td><td>  59600 </td></tr><tr><td>  Minimum </td><td>  972 </td><td>  870 </td><td>  1011 </td><td>  909 </td><td>  1005 </td><td>  975 </td><td>  937 </td></tr></tbody></table><br>  <b>The results of experiments for C-call in the case where the thread has already been created</b> <br><table><tbody><tr><th>  Number P_spinlocked = </th><th>  five </th><th>  ten </th><th>  15 </th><th>  20 </th><th>  25 </th><th>  thirty </th><th>  35 </th></tr><tr><td>  % emissions&gt; average + 3 degree of deviation </td><td>  0.06% </td><td>  0.09% </td><td>  0.10% </td><td>  0.12% </td><td>  0.13% </td><td>  0.15% </td><td>  0.16% </td></tr><tr><td>  The average </td><td>  1123 </td><td>  1126 </td><td>  1137 </td><td>  1172 </td><td>  1250 </td><td>  1283 </td><td>  1313 </td></tr><tr><td>  Standard deviation </td><td>  183 </td><td>  212 </td><td>  226 </td><td>  300 </td><td>  433 </td><td>  456 </td><td>  492 </td></tr><tr><td>  Median </td><td>  1086 </td><td>  1076 </td><td>  1080 </td><td>  1086 </td><td>  1099 </td><td>  1117 </td><td>  1123 </td></tr><tr><td>  Maximum </td><td>  68461 </td><td>  73383 </td><td>  53756 </td><td>  49751 </td><td>  50581 </td><td>  47844 </td><td>  86258 </td></tr><tr><td>  Minimum </td><td>  391 </td><td>  354 </td><td>  364 </td><td>  348 </td><td>  313 </td><td>  340 </td><td>  351 </td></tr></tbody></table><br>  To begin with, let's compare the distribution of C-call durations in cases 1 and 2 (with the same runtime load P_spinlocked = 35).  Here we see the expected result - in the case of creating a new stream, the time is longer.  The mean values ‚Äã‚Äãdiffer approximately by 2 times and are ~ 2600 ns and ~ 1200 ns, respectively, for the 1 and 2 cases. <br><br><img src="https://habrastorage.org/files/91d/c8c/e0f/91dc8ce0f25e48048ca7ccc0b49b3a91.png"><br><br>  In the figures below, for each case, the distribution of durations with a low load (P_spinlocked = 5) and with a high load (P_spinlocked = 35) (without emissions) is presented separately. <br><br>  A gradual increase in the runtime load allowed us to see how the costs related to the performance of the execution environment itself are growing - with increasing load, a smooth shift in the average value is observed.  This is also clearly seen from the histograms below: for a loaded runtime (P_spinlocked = 35), the histogram is ‚Äúblurred‚Äù towards larger values ‚Äã‚Äãcompared to an unloaded one (P_spinlocked = 5), which means that the complexity of the execution environment is not constant with respect to to the number of go-rutin. <br><br><img src="https://habrastorage.org/files/78c/ce2/ebf/78cce2ebfe694db4b0ad43e2c21b790d.png"><br><img src="https://habrastorage.org/files/f10/0a0/479/f100a0479185453ea01d4e0c2c7edebb.png"><br>  It should also be noted that in both cases there is a fraction of a percent of significant emissions (~ 50,000 ns or more).  (This is strange. It would seem that in the second case there is already a flow and there should be no significant delays, but there are nevertheless emissions of the same order as the first case. Apparently, the reason lies in the operating system features not related to the creation of threads) <br>  The histogram below (on a logarithmic scale along the y axis) shows all points, including outliers, for both cases with an equal runtime of P_spinlocked = 10. Here you can estimate the share of outliers among all the obtained values. <br><img src="https://habrastorage.org/files/a1b/ef2/625/a1bef26254cf48288338a4810a6d429f.png"><br><br>  Outside the experiment remains the contribution of the garbage collector.  For our experiment, it was forcibly turned off.  In reality, he contributes a share of non-determinism, periodically completely stopping the execution of the program (the so-called Stop-the-world stage).  Go developers pay great attention to improving its work and minimizing the pauses associated with it in the work of programs.  In Go 1.5, the work of the collector is significantly <a href="https://blog.golang.org/go15gc">optimized</a> - it is guaranteed that the stop time does not exceed 10 ms, which is very good. <br><br><h1>  <font color="#0071c5">Conclusion</font> </h1><br>  External calls are very costly.  In addition, the runtime itself can cause significant unexpected delays in the execution of external calls, even in our artificial situation when the garbage collector is turned off, go-routines that create a ‚Äúload‚Äù do not work with memory, and therefore do not provoke stack additions, as well as these "Load" go-routines do not do any expensive operations that could cause a call to the scheduler - which means they are not rescheduled.  In reality, with these loaded go-routines, the spread of values ‚Äã‚Äãwill seriously increase in a big way. <br><br>  The delay due to the creation of threads can be avoided, for example, by organizing the creation of some of their number at the start of the program.  But the waiting time for a free context will still remain unpredictable, and with frequent external calls it will only increase, so you have to admit the sad fact is that the active use of cgo from go-routines will have a negative effect on the overall effectiveness of the program and resort to it only from time to time.  The likelihood of large delays is, of course, very small, but their possibility calls into question the use of external calls in Go, even for soft real-time systems. </div><p>Source: <a href="https://habr.com/ru/post/275709/">https://habr.com/ru/post/275709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275699/index.html">Digest of the game industry: December</a></li>
<li><a href="../275701/index.html">ChakraCore: JavaScript engine validation for Microsoft Edge</a></li>
<li><a href="../275703/index.html">"Pixel gallop - part three" - Animation</a></li>
<li><a href="../275705/index.html">Data Driven Realtime Rule Engine in Wargaming: data analysis. Part 2</a></li>
<li><a href="../275707/index.html">Are you three-dimensional? Microtask spatial thinking</a></li>
<li><a href="../275711/index.html">New call reporting for 3CX v14</a></li>
<li><a href="../275713/index.html">Mobile applications of Stepic.org for iOS and Android</a></li>
<li><a href="../275715/index.html">"Naked conductor runs under the car." About online translation</a></li>
<li><a href="../275717/index.html">Using SikuliX in the background on Cloud9</a></li>
<li><a href="../275719/index.html">All you wanted to know about protection from XSS in SAP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>