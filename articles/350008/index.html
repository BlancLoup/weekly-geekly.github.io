<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Lesson 4.7 - Advanced data handling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Advanced data handling 

 We basically used OpenGL buffers to store data for quite some time. There are more interesting ways to manipulate buffers, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Lesson 4.7 - Advanced data handling</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="image" width="300" align="left"><h1>  Advanced data handling </h1><br><br>  We basically used OpenGL buffers to store data for quite some time.  There are more interesting ways to manipulate buffers, as well as other interesting methods of transferring large amounts of data to shaders using textures.  In this guide, we will discuss some of the more interesting features of the buffer and how we can use texture objects to store large amounts of data (the texture part of the lesson has not yet been written). <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br><br>  Part 3. Loading 3D Models <br><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li></ol><br></div></div><br>  A buffer in OpenGL is an object that controls a certain part of the memory, and nothing more.  We attach the value to the buffer by linking it to a specific target buffer.  A buffer is just a buffer of a vertex array when we bind it to <i>GL_ARRAY_BUFFER</i> , but we can also easily associate it with <i>GL_ELEMENT_ARRAY_BUFFER</i> .  OpenGL stores a buffer for each target and, based on the target, processes the buffers differently. <br><br>  So far, we have filled the memory managed by the buffer objects by calling <i>glBufferData</i> , which allocates a portion of the memory and adds data to this memory.  If we passed <i>NULL</i> as the data argument, the function would allocate memory and not fill it.  This is useful if we want to reserve a specific part of the memory first, and in the future return to this buffer in order to gradually fill it. <br><br>  Instead of filling the entire buffer with a single function call, we can also fill in specific buffer areas by calling <i>glBufferSubData</i> .  This function takes as arguments the target buffer, the offset, the size of the data, and the data itself.  What's new in this function is that we can set an offset that indicates where we want to start filling the buffer.  This allows us to insert / update only certain parts of the buffer memory.  Note that the buffer must have enough allocated memory, so the call to the <i>glBufferData</i> function <i>must</i> always be before the call to <i>glBufferSubData</i> . <br><br><pre><code class="cpp hljs">glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-number"><span class="hljs-number">24</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(data), &amp;data); <span class="hljs-comment"><span class="hljs-comment">// : [24, 24 + sizeof(data)]</span></span></code> </pre> <br>  Another way to transfer data to the buffer is to find out the pointer to the buffer memory, and directly copy the data to the buffer yourself.  When you call the <i>glMapBuffer</i> function <i>,</i> OpenGL returns a pointer to the memory of the current associated buffer to work with it: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> data[] = { <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-0.35f</span></span> ... }; glBindBuffer(GL_ARRAY_BUFFER, buffer); <span class="hljs-comment"><span class="hljs-comment">//   void *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY); //     memcpy(ptr, data, sizeof(data)); //  OpenGL,       glUnmapBuffer(GL_ARRAY_BUFFER);</span></span></code> </pre> <br>  OpenGL knows that we are done with the pointer as soon as we tell it to it using the <i>glUnmapBuffer</i> function.  After executing this function, the pointer becomes invalid, and the function returns <i>GL_TRUE</i> if OpenGL successfully placed your data in the buffer. <br><br>  Using <i>glMapBuffer</i> is useful for directly storing data in a buffer without first being stored in temporary memory. <br><br><h3>  Attributes of grouped vertices </h3><br>  Using <i>glVertexAttribPointer</i> , we could specify the location of the contents of the vertex array buffer.  In the vertex array buffer, we alternated attributes, i.e.  we placed the position, normal and / or texture coordinates in order for each vertex.  Now that we know a little more about buffers, we can use a different approach. <br><br>  So now we can pack all the vector data into large pieces for each attribute type, instead of alternating them.  Instead of a layout of alternating data 123123123123, we get the batch approach 111122223333. <br><br>  When you load vertex data from a file, you usually get an array of positions, an array of normals, and / or an array of texture coordinates.  It may be worth some effort to connect these arrays into a large array of alternating data.  Using the batch approach is an easy solution that we can implement using the <i>glBufferSubData</i> function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> positions[] = { ... }; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> normals[] = { ... }; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tex[] = { ... }; <span class="hljs-comment"><span class="hljs-comment">//   glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(positions), &amp;positions); glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions), sizeof(normals), &amp;normals); glBufferSubData(GL_ARRAY_BUFFER, sizeof(positions) + sizeof(normals), sizeof(tex), &amp;tex);</span></span></code> </pre> <br>  This approach allows you to directly send an array of attributes to the buffer as a whole, without preprocessing.  We can also combine them into one large array and fill it immediately using <i>glBufferData</i> , but using <i>glBufferSubData is</i> great for such tasks. <br><br>  We will also need to update the pointers to the attributes of the vertices to reflect these changes: <br><br><pre> <code class="cpp hljs">glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(positions))); glVertexAttribPointer(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, GL_FLOAT, GL_FALSE, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*)(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(positions) + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(normals)));</code> </pre> <br>  Note that the <b>stride</b> parameter is equal to the size of the vertex attribute, since the next attribute of the vertex attribute can be found immediately after its 3 (or 2) components. <br><br>  This gives us another approach to setting and defining vertex attributes.  Using both approaches does not bring immediate benefits to OpenGL, basically it‚Äôs a more organized way to set vertex attributes.  The approach you want to use is based solely on your preferences and application type. <br><br><h3>  Copy buffers </h3><br>  When your buffers are filled with your data, you may want to share this data with other buffers or perhaps copy the contents of the buffer to another.  The glCopyBufferSubData function allows you to copy data from one buffer to another with relative ease.  The function prototype looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glCopyBufferSubData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size)</span></span></span></span>;</code> </pre> <br>  The <b>readtarget</b> and <b>writetarget arguments</b> take target buffer values ‚Äã‚Äãthat we want to copy from and to where.  For example, we could copy the data from the <i>VERTEX_ARRAY_BUFFER</i> buffer to the <i>VERTEX_ELEMENT_ARRAY_BUFFER</i> buffer, specifying these buffer targets as read and write targets, respectively.  Then the buffers that are tied to these targets will be affected. <br><br>  But what if we want to read and write data in two different buffers, which are the vertex array buffers?  We cannot simultaneously bind two buffers to the same target buffer.  For this reason, and only for it, OpenGL gives us two more storage targets, called <i>GL_COPY_READ_BUFFER</i> and <i>GL_COPY_WRITE_BUFFER</i> .  Then we associate the selected buffers with these new target buffers and set these targets as <b>readtarget</b> and <b>writetarget arguments</b> . <br><br>  <i>glCopyBufferSubData</i> reads data of a given size from the given <b>readoffset</b> value and writes it to the <b>writetarget</b> write <b>buffer</b> as a <b>writeoffset</b> .  An example of copying the contents of two vertex array buffers is shown below: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertexData[] = { ... }; glBindBuffer(GL_COPY_READ_BUFFER, vbo1); glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2); glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(vertexData));</code> </pre> <br>  We could also do this by <b>associating the writetarget</b> buffer with one of the new types of target buffers: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertexData[] = { ... }; glBindBuffer(GL_ARRAY_BUFFER, vbo1); glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2); glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(vertexData));</code> </pre> <br>  Having some additional knowledge of how to manipulate buffers, we can already use them in more interesting ways.  As you dive into OpenGL, these methods for working with buffers will become more useful.  In the next lesson, where we discuss <i>Uniform Buffer Objects</i> , we still need the <i>glBufferSubData</i> function. </div><p>Source: <a href="https://habr.com/ru/post/350008/">https://habr.com/ru/post/350008/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349996/index.html">Binary ternary bit magic</a></li>
<li><a href="../349998/index.html">Secure home network: create an isolated segment for guests</a></li>
<li><a href="../350002/index.html">Two models are better than one. Experience Yandex.Translate</a></li>
<li><a href="../350004/index.html">Issue # 12: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../350006/index.html">"Tutor: Mathematics" to prepare for the exam and CDF - from idea to release. A story about a unique educational project</a></li>
<li><a href="../350010/index.html">YouTrack 2018.1 release: dependent task fields, personal localization and much more</a></li>
<li><a href="../350012/index.html">Analysis of the consensus algorithm in Tendermint</a></li>
<li><a href="../350014/index.html">How to make an adequate display of the horizontal scroll bar in a QTreeWidget with one column</a></li>
<li><a href="../350016/index.html">Digital events in Moscow from February 26 to March 4</a></li>
<li><a href="../350018/index.html">You may not need Rust to speed up your JS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>