<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Storing and encrypting Microsoft Windows passwords</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A lot of articles were written about breaking windows passwords, but they all boiled down to using some kind of software, or superficially described L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Storing and encrypting Microsoft Windows passwords</h1><div class="post__text post__text-html js-mediator-article">  A lot of articles were written about breaking windows passwords, but they all boiled down to using some kind of software, or superficially described LM and NT encryption methods, and completely superficially described syskey.  I will try to fix this lack of balance by describing all the details about where the passwords are, in what form, and how the syskey utility converts them. <br><br><a name="habracut"></a>  There are 2 ways to get a password - through the registry, or by getting direct access to registry hive files.  In any case, you will need either the privileges of the user SYSTEM, or the theft of the cherished files, for example, by booting from another OS.  Here I will not describe the possibilities of obtaining access, but for research purposes it will be clearer to choose the first option, this will allow not to focus on the structure of the registry hive.  And the <a href="http://technet.microsoft.com/ru-ru/sysinternals">psExec</a> utility from sysinternals will help us launch from the system.  Of course, for these purposes you can use windows vulnerabilities, but the article is not about that. <br><br><h4>  V-block </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Windows to Vista, by default, stored the password in two different hashes - LM and NT.  In whist and above LM-hash is not stored.  First, let's see where to look for these hashes, and then we will understand what they are. <br><br>  User passwords, as well as many other useful information is stored in the registry at <b>HKLM \ SAM \ SAM \ Domains \ Account \ users \ [RID] \ V</b> <br>  known as V-block.  The SAM section is located in the corresponding file <b>c: \ Windows \ System32 \ config \ SAM</b> .  RID is a unique user identifier, you can find it out, for example, by looking in the <b>HKLM \ SAM \ SAM \ Domains \ Account \ users \ names \ &lt;username&gt;</b> branch (Default parameter, field - parameter type).  For example, the ‚ÄúAdministrator‚Äù account RID is always 500 (0x1F4), and the ‚ÄúGuest‚Äù user is 501 (0x1f5).  Access to the SAM section by default is possible only for the SYSTEM user, but if you really want to see it, start regedit with system privileges: <br><br> <code>PsExec.exe -s -i -d regedit.</code> <br> <br>  To observe the V-block in a convenient way, for example, you can export it to a text file (File-Export to Regedit). <br>  This is what we will see there: <br><img src="https://habrastorage.org/storage/b98d9abc/f6b91d75/cd4d5f9f/a47a2a65.jpg"><br>  From 0x0 to 0xCC are the addresses of all the data that are in the V-block, their size and some additional information about the data.  To get the real address you need to the address that we find add 0xCC.  Addresses and sizes are stored according to the BIG ENDIAN principle, i.e. it will be necessary to invert bytes.  Each parameter is allocated 4 bytes, but in fact all the parameters fit in one or two bytes.  Here is where to look: <br><br>  User Name Address - 0x <br>  User name length - 0x10 <br>  LM Hash Address - 0x9s <br>  LM hash length - 0xa0 <br>  NT hash address - 0xa8 <br>  NT hash length - 0xac <br><br>  In this case, the user name is at offset 0xd4 + 0xcc and its length will be 0xc bytes. <br>  NT hash will be located at offset 0x12c + 0xcc and its size (always the same) = 0x14. <br><br>  Another detail regarding the storage of passwords is that 4 bytes are always added to the front of both the NT and LM hashes, the purpose of which is a mystery to me.  Moreover, 4 bytes will be present even if the password is disabled.  In this case, it is clear that the length of LM hash = 4 and if you look at its address, you can see these 4 bytes despite the fact that there is no LM hash. <br>  Therefore, when searching for hash offsets, we boldly add 4 bytes to the address, and when considering the sizes, we subtract.  If it is more convenient to read the code, here‚Äôs what the address search will look like, taking into account the inversion, the extra four bytes and the addition of the starting offset 0xcc (C # code) <br><br> <code>int lmhashOffset = userVblock[0x9c] + userVblock[0x9d] * 0x100 + 4 + 0xcc; <br> int nthashOffset = userVblock[0xa8] + userVblock[0xa9] * 0x100 + 4 + 0xcc; <br> int lmhashSize = userVblock[0xa0] + userVblock[0xa1] * 0x100 - 4; <br> int nthashSize = userVblock[0xac] + userVblock[0xad] * 0x100 - 4; <br> int usernameOffset = userVblock[0xc] + userVblock[0xd] * 0x100 + 0xcc; <br> int usernameLen = userVblock[0x10] + userVblock[0x1a] * 0x100;</code> <br>  userVblock - the value of HKLM \ SAM \ SAM \ Domains \ Account \ users \\ V as an array of bytes. <br>  More about the V-block can be read <a href="http://paullee.ru/sam3.html">here</a> . <br><br><h4>  Algorithms </h4><br><br>  Now let's look at encryption algorithms. <br>  <b>NT hash generation</b> : <br>  1. The user's password is converted to a Unicode string. <br>  2. MD4-hash is generated based on this string. <br>  3. The resulting hash is encrypted using the DES algorithm, the key is generated based on the user's RID. <br>  <b>LM hash generation</b> : <br>  1. The user's password is converted to uppercase and padded with zeros up to 14 bytes in length. <br>  2. The resulting string is divided into two halves of 7 bytes, and each of them is separately encrypted with the DES algorithm.  As a result, we get a hash of 16 bytes in length (consisting of two independent halves of 8 bytes in length). <br>  3. The resulting hash is encrypted using the DES algorithm, the key is generated based on the user's RID. <br><br>  <b>4.</b> In windows 2000 and higher, both received hashes are additionally encrypted by the RC4 algorithm using a key known as the ‚Äúsystem key‚Äù or bootkey generated by the syskey utility and encrypted in a rather tricky way. <br><br>  Consider the general sequence of actions for obtaining the original password and each step separately <br>  1. Get bootkey, generate keys for RC4 based on it, decrypt hashes with RC4 <br>  2. Get keys for DES from RID users, decrypt hashes with DES <br>  3. Obtain hashes by brute force attack. <br><br><h4>  Bootkey </h4><br><br>  The system key (bootkey) is divided into 4 parts and lies in the following registry keys: <br><br>  <b>HKLM \ System \ CurrentControlSet \ Control \ Lsa \ JD</b> <b><br></b>  <b>HKLM \ System \ CurrentControlSet \ Control \ Lsa \ Skew1</b> <b><br></b>  <b>HKLM \ System \ CurrentControlSet \ Control \ Lsa \ GBG</b> <b><br></b>  <b>HKLM \ System \ CurrentControlSet \ Control \ Lsa \ Data</b> <br><br>  The system partition is located in the file c: \ Windows \ System32 \ config \ system <br><br>  It should be noted that the CurrentControlSet section is a reference to one of the controlset sections and is created at the time of the system boot.  This means that you will not be able to find it in the system file if the system is inactive.  If you decide to search for a key in a file, you need to know the default ContolSet value in HKLM \ SYSTEM \ Select \ default. <br>  for example, if HKLM \ SYSTEM \ Select \ default = 1 - instead of <b>HKLM \ System \ CurrentControlSet \</b> look in <b>HKLM \ System \ controlset001 \</b> <br><br>  Each registry key has a hidden attribute known as a ‚Äúclass‚Äù.  Regedit won't show it that easy, but you can see it, for example, if you export these registry keys to text files.  In winapi, to get this attribute, there is a <a href="http://msdn.microsoft.com/en-us/library/ms724902(VS.85).aspx">RegQueryInfoKey</a> function. <br>  Fragments are stored in a string representation of hexadecimal numbers, and according to the BIG ENDIAN principle (that is, not a string backwards, but a number). <br>  For example, we found the following records: <br><br> <code>Key Name: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\JD <br> Class Name: 46003cdb = {0xdb,0x3c,0x00,0x46} <br> Key Name: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Skew1 <br> Class Name: e0387d24 = {0x24,0x7d,0x38,0xe0} <br> Key Name: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\GBG <br> Class Name: 4d183449 = {0x49,0x34,0x18,0x4d} <br> Key Name: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\Data <br> Class Name: 0419ed03 = {0x03,0xed,0x19,0x04}</code> <br> <br>  The four-part key will be an array of bytes: <br><br> <code>scrambled_key = {0xdb,0x3c,0x00,0x46,0x24,0x7d,0x38,0xe0,0x49,0x34,0x18,0x4d,0x03,0xed,0x19,0x04};</code> <br> <br>  Further, the elements of this array are rearranged on the basis of some constant array p <br><br> <code>int[] p = { 0xb, 0x6, 0x7, 0x1, 0x8, 0xa, 0xe, 0x0, 0x3, 0x5, 0x2, 0xf, 0xd, 0x9, 0xc, 0x4 };</code> <br>  The elements in this array define the positions for the permutations, i.e. <br><br> <code>key[i] = scrambled_key[p[i]]; <br></code> <br>  In our example, we get an array: <br><br> <code>key[] = {0x4d,0x38,0xe0,0x3c,0x49,0x18,0x19,0xdb,0x46,0x7d,0x00,0x04,0xed,0x34,0x03,0x24 };</code> <br> <br>  This array is the so-called <b>bootkey</b> .  Only in the encryption of passwords will not he but a certain hash based on the bootkey, fragments of the f-block and some constants.  Let's call it Hashed bootkey. <br><br><h5>  Hashed bootkey </h5><br><br>  to get the hashed bootkey, we need 2 string constants (ASCII): <br><br> <code>string aqwerty = "!@#$%^&amp;*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&amp;%\0"; <br> string anum = "0123456789012345678901234567890123456789\0";</code> <br>  You will also need the user's F-block (HKLM \ SAM \ SAM \ Domains \ Account \ users \\ F), namely, its 16 bytes: <b>F [0x70: 0x80]</b> <br><br>  Based on these values, glued into one large array, we form an MD5 hash, which will be the key for RC4 encryption <br><br> <code>rc4_key = MD5(F[0x70:0x80] + aqwerty + bootkey + anum).</code> <br> <br>  The final step to get the hashed bootkey is rc4 encryption (or decryption - in rc4 is the same function) received by the F-block fragment key <b>F [0x80: 0xA0]</b> ; <br><br> <code>hashedBootkey = RC4(rc4_key,F[0x80:0xA0])</code> <br> <br>  Hashed bootkey in our hands, it remains to learn how to handle it correctly. <br><br><h5>  We decrypt passwords with Hashed Bootkey </h5><br><br>  for LM and NT passwords, we will need another 2 string constants - <br><br> <code>string almpassword = "LMPASSWORD"; <br> string antpassword = "NTPASSWORD";</code> <br> <br>  as well as the user RID in the form of 4 bytes (padded with zeros) and the first half of the Hashed Bootkey ( <b>hashedBootkey [0x0: 0x10]</b> ); <br>  All this is glued together into one array of bytes and is considered MD5 according to the rules: <br> <code>rc4_key_lm = MD5(hbootkey[0x0:0x10] +RID + almpassword); <br> rc4_key_nt = MD5(hbootkey[0x0:0x10] +RID + antpassword);</code> <br> <br>  received md5 hash key for rc4, which LM and NT hashes are encrypted in the user's V-block <br><br> <code>userLMpass = RC4(rc4_key_lm,userSyskeyLMpass); <br> userNTpass = RC4(rc4_key_lm,userSyskeyNTpass); <br></code> <br>  At this stage, we received the user's passwords in the form in which they would be stored without syskey encryption, we can say that the most difficult thing is behind.  Go to the next step <br><br><h5>  Des </h5><br><br>  On the basis of the four bytes of the RID user, with the help of some permutations and bitwise operations, we create 2 DES keys.  Here are the functions that obfuscate (C #): <br> <code>private byte[] str_to_key(byte[] str) { <br> byte[] key = new byte[8]; <br> key[0] = (byte)(str[0] &gt;&gt; 1); <br> key[1] = (byte)(((str[0] &amp; 0x01) &lt;&lt; 6) | (str[1] &gt;&gt; 2)); <br> key[2] = (byte)(((str[1] &amp; 0x03) &lt;&lt; 5) | (str[2] &gt;&gt; 3)); <br> key[3] = (byte)(((str[2] &amp; 0x07) &lt;&lt; 4) | (str[3] &gt;&gt; 4)); <br> key[4] = (byte)(((str[3] &amp; 0x0F) &lt;&lt; 3) | (str[4] &gt;&gt; 5)); <br> key[5] = (byte)(((str[4] &amp; 0x1F) &lt;&lt; 2) | (str[5] &gt;&gt; 6)); <br> key[6] = (byte)(((str[5] &amp; 0x3F) &lt;&lt; 1) | (str[6] &gt;&gt; 7)); <br> key[7] = (byte)(str[6] &amp; 0x7F); <br> for (int i = 0; i &lt; 8; i++) { <br> key[i] = (byte)(key[i] &lt;&lt; 1); <br> } <br> des_set_odd_parity(ref key); <br> return key; <br> } <br> <br> private byte[] sid_to_key1(byte[] rid) { <br> byte[] s = new byte[7]; <br> s[0] = (byte)(rid[0] &amp; 0xFF); <br> s[1] = (byte)(rid[1] &amp; 0xFF); <br> s[2] = (byte)(rid[2] &amp; 0xFF); <br> s[3] = (byte)(rid[3] &amp; 0xFF); <br> s[4] = s[0]; <br> s[5] = s[1]; <br> s[6] = s[2]; <br> <br> return str_to_key(s); <br> } <br> <br> private byte[] sid_to_key2(byte[] rid) { <br> byte[] s = new byte[7]; <br> s[0] = (byte)((rid[3]) &amp; 0xFF); <br> s[1] = (byte)(rid[0] &amp; 0xFF); <br> s[2] = (byte)((rid[1]) &amp; 0xFF); <br> s[3] = (byte)((rid[2]) &amp; 0xFF); <br> s[4] = s[0]; <br> s[5] = s[1]; <br> s[6] = s[2]; <br> <br> return str_to_key(s); <br> }</code> <br> <br>  Well, there is nothing special to comment here, except the function <b>des_set_odd_parity (ref key)</b> - this is one of the functions of the <a href="http://www.openssl.org/docs/crypto/des.html">openssl</a> library, whose task is to add some ‚Äúodd bits‚Äù, which is used to increase the key's resistance to attacks. <br><br>  Then we split the NT (or LM) hash into 2 parts by 8 bytes and decrypt it with DES, one half is encrypted with the key formed by the sid_to_key1 function, the second is sid_to_key2. <br> <code>obfskey_l = userNTpass[0x0:0x7] <br> obfskey_r = userNTpass[0x8:0xF] <br> byte[] deskey1 = sid_to_key1(RID); <br> byte[] deskey2 = sid_to_key2(RID); <br> byte[] md4hash_l = DES(obfskey_l, deskey1); <br> byte[] md4hash_r = DES(obfskey_r, deskey2);</code> <br> <br>  After pasting the two halves, we get md4 hash in the case of NT, or LanMan (DES) - in the case of LM.  The resulting hash is completely ready for brute force attack. <br>  By the way, md4 Hash from an empty password - <b>31d6cfe0d16ae931b73c59d7e0c089c0</b> <br><br>  The study was conducted on the basis of the source code <a href="http://ophcrack.sourceforge.net/download.php">ophcrack-3.3.1</a> , as well as articles <a href="http://moyix.blogspot.com/2008/02/syskey-and-sam.html">Push the Red Button: SysKey and the SAM</a> </div><p>Source: <a href="https://habr.com/ru/post/114150/">https://habr.com/ru/post/114150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114141/index.html">Lawyers argue over the legality of selling ‚Äúused MP3s‚Äù</a></li>
<li><a href="../114142/index.html">Tests are important, but others are not needed.</a></li>
<li><a href="../114145/index.html">Integration testing of a web application with Selenium WebDriver</a></li>
<li><a href="../114146/index.html">Metawidget - a tool that generates Java forms</a></li>
<li><a href="../114147/index.html">The practice of using the Onboard Administrator in BladeSystem c3000</a></li>
<li><a href="../114151/index.html">WordPress 3.1 Reinhardt Released</a></li>
<li><a href="../114152/index.html">Resurrecting a dream. A remake of your favorite iphone game</a></li>
<li><a href="../114153/index.html">Quantile Image Segmentation</a></li>
<li><a href="../114154/index.html">B-tree</a></li>
<li><a href="../114156/index.html">280 crinkles or explosive power of regular expressions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>