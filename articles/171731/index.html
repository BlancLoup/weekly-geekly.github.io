<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JavaScript Prototypes for C / C ++ / C # / Java Programmers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript is different from many other "object-oriented" programming languages ‚Äã‚Äãin that there are objects in it, but not classes. Instead of classes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JavaScript Prototypes for C / C ++ / C # / Java Programmers</h1><div class="post__text post__text-html js-mediator-article">  JavaScript is different from many other "object-oriented" programming languages ‚Äã‚Äãin that there are objects in it, but not classes.  Instead of classes in JavaScript, there are prototype chains and some other tricks that take time to comprehend.  Before professional programmers in other languages, when switching to JavaScript, there is the problem of quickly entering its object model. <br><br>  This text is written to give a novice or episodic JavaScript developer an idea of ‚Äã‚Äãhow to create objects in JavaScript, from simple ‚Äústructural‚Äù, as in C, to more ‚Äúobject-oriented‚Äù, as in C ++ / C # / Java. <br><br>  The article can be recommended both to beginners in programming, and backend programmers who write in JavaScript only sporadically. <br><a name="habracut"></a><br><h2>  Objects and classes in C and C ++ </h2><br>  Objects are entities that possess <br><ul><li>  identity (the ability to distinguish one object from another), </li><li>  state (state, attributes, fields), </li><li>  and behavior (behavior, methods, functions that can change state). </li></ul><br>  For ease of introduction into the subject matter, objects can be represented as instances of the corresponding ‚Äúclasses‚Äù that exist in memory only after the program has started. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Objects can be generated during the life of the program, change, disappear. <br><br>  Compare the conditional code in C and C ++: <br><br><ul><li>  <b>C</b> <br><br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *firstName; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *lastName; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yearOfBirth; } <span class="hljs-comment"><span class="hljs-comment">// Compute person's age in a given year. void computeAge(struct Person *person, int currentYear); // Set a new last name, possibly deallocating the old one. void setLastName(struct Person *person, char *newLastName);</span></span></code> </pre> <br></li><li>  <b>C ++</b> <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Person</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *firstName; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *lastName; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yearOfBirth; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeAge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> currentYear</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLastName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *newLastName</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre></li></ul><br>  In these examples, we in C and C ++ describe the Person object.  They did not ‚Äúcreate an object‚Äù, but ‚Äúdescribed its fields and methods,‚Äù so that later it was possible to create such objects and use them. <br><br>  Also look at the appropriate ways to create a single Person object in C and C ++: <br><br><ul><li>  <b>C</b> <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">malloc</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof</span></span></span><span class="hljs-class">(*</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">));</span></span> setLastName(p, <span class="hljs-string"><span class="hljs-string">"Poupkine"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Person's age is %d\n"</span></span>, computeAge(p, <span class="hljs-number"><span class="hljs-number">2013</span></span>));</code> </pre><br></li><li>  <b>C ++</b> <br><br><pre> <code class="hljs php">Person *p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person; p-&gt;setLastName(<span class="hljs-string"><span class="hljs-string">"Poupkine"</span></span>); printf(<span class="hljs-string"><span class="hljs-string">"Person's age is %d\n"</span></span>, p-&gt;computeAge(<span class="hljs-number"><span class="hljs-number">2013</span></span>));</code> </pre></li></ul><br>  These two programs do the same thing: create an object and allow you to use its associated functions <code>setLastName</code> , <code>computeAge</code> (behavior) to change or poll the state of an object (state).  We can access the created object at any time through the pointer p (identity).  If we create another <code>Person *m = new Person</code> object <code>Person *m = new Person</code> , then we can use the methods of the new object, accessing it through the pointer m.  Pointers p and m will point to different objects, each with its own state, albeit with the same set of methods (behavior). <br><br>  As we can see, even the related languages ‚Äã‚ÄãC and C ++ offer slightly different ways of describing the Person object.  In one case, we describe an object through a <code>struct Person</code> Data data structure and friendly functions somewhere nearby.  In another case, we syntactically put both data and functions into the same <code>class Person</code> . <br><br>  Why can people prefer C ++ and the ‚Äúobject-oriented approach‚Äù, since we can do about the same thing in the C language, ‚Äúwithout classes‚Äù, and in C ++?  There are some good answers that are relevant in the context of learning JavaScript, in which you can use both the C approach and the C ++ approach: <br><br><ol><li>  Namespaces.  In the C version, we defined the computeAge function.  This function is in the global namespace: it is ‚Äúvisible‚Äù to the entire program.  In another place now to create such a function will not work.  But what if we made a new kind of objects, say, Pony, and want to make a similar method that calculates the age of the pony?  We will need not only to create a new ponyComputeAge () method, but also to rename the old method in order to achieve uniformity: personComputeAge ().  In general, we ‚Äúclutter up‚Äù the name space, making the creation of new types of objects more and more difficult over time.  If we put the computeAge () function in a class, as in C ++, we may have many similar functions in different classes.  They will not interfere with each other. <br><br></li><li>  Information hiding.  In the C version, whoever has a pointer p to the Person structure, he can change any field in the object.  For example, you can say p-&gt; yearOfBirth ++.  So to do it ‚Äî arbitrarily changing arbitrary fields of arbitrary objects ‚Äî is considered bad practice.  Indeed, it is often necessary not just to change the field, but to consistently change several fields of the object.  And who can do this better and more correctly than a specialized procedure (method)?  Therefore, it should be possible to prohibit changing fields directly, and letting them be changed only with the help of appropriate methods.  On C, this is difficult to do, so they are rarely used.  But in C ++, it‚Äôs easy to do.  It is enough to declare any attributes of the private object, and then it will be possible to access them only from within the class methods: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//       computeAge  setLastName: private: char *firstName; char *lastName; int yearOfBirth; //   ()  : public: void computeAge(int currentYear); void setLastName(char *newLastName); }</span></span></code> </pre><br></li><li>  Creating an interface.  In version C we have to remember for each object how to get an age for it.  For one object we will call <code>ponyComputeAge()</code> , for the other <code>personComputeAge()</code> .  In the C ++ version, we can simply remember that calculating the age of any object is done through <code>computeAge()</code> .  That is, we introduce a single interface for calculating the age, and use it as an application to many objects.  It's comfortable. </li></ol><br><br><h2>  JavaScript Objects and Prototypes </h2><br>  JavaScript programmers also take advantage of object programming, but there are no ‚Äúclasses‚Äù as a syntactic way of describing objects. <br><br><h3>  Naive way </h3><br>  It would be possible in JavaScript to use the C approach when we describe an object through a data structure and a set of functions working on data: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first, last, born</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: first, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: last, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: born }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">computeAge</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, currentYear</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentYear - p.yearOfBirth; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setLastName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, newLastName</span></span></span><span class="hljs-function">) </span></span>{ p.lastName = newLastName; } <span class="hljs-comment"><span class="hljs-comment">// Create a new person and get their age: var p = createPerson("Anne", "Hathaway", 1982); console.log(p); console.log(computeAge(p, 2013));</span></span></code> </pre><br>  Try copying all this code into the <code>node</code> program (having previously installed the <a href="http://nodejs.org/">Node.JS</a> project) and see what it displays. <br><br><h3>  Crammed namespace </h3><br>  But this method has the same disadvantages of the variant on C, which was mentioned above.  Let's try one more time, but only this time we ‚Äústick‚Äù the <code>setLastName()</code> and <code>computeAge()</code> methods ‚Äúinside‚Äù the object.  By this we will ‚Äúunload‚Äù the global namespace, we will not litter it: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first, last, born</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computeAgeMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, currentYear</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentYear - p.yearOfBirth; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> setLastNameMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p, newLastName</span></span></span><span class="hljs-function">) </span></span>{ p.lastName = newLastName; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: first, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: last, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: born, <span class="hljs-attr"><span class="hljs-attr">computeAge</span></span>: computeAgeMethod, <span class="hljs-attr"><span class="hljs-attr">setLastName</span></span>: setLastNameMethod }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person; } <span class="hljs-comment"><span class="hljs-comment">// Create a new person and get their age: var p = createPerson("Anne", "Hathaway", 1982); // Note the p.computeAge(p) syntax, instead of just computeAge(p). console.log(p.computeAge(p, 2013)); console.log(p["computeAge"](p, 2013));</span></span></code> </pre><br>  Notice that we simply moved functions from outside to <code>createPerson</code> inwards.  The body of the function has not changed.  That is, each function still expects an argument <code>p</code> , with which it will work.  The method of calling these methods has not changed much: yes, instead of calling the <code>computeAge</code> global function, you need to call the method of the <code>p.computeAge</code> object, but the function still expects <code>p</code> first argument. <br><br>  This is quite redundant.  Let's use the following trick: as in C ++, Java and other languages, JavaScript has a special variable <code>this</code> .  If the function is called by itself ( <code>f()</code> ), then this variable points to a global object (in the browser it will be a <code>window</code> ).  But if the function is called through a point, as a method of an object, ( <code>pf()</code> ), then it will be passed a pointer to this object p as this.  Since we will still be forced to call methods through a call to the corresponding fields of the object ( <code>p.computeAge</code> ), <code>this</code> will already exist in the methods and set to the correct value of <code>p</code> .  Rewrite the code using this knowledge.  Also try copying it to the <code>node</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first, last, born</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> computeAgeMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentYear</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentYear - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.yearOfBirth; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> setLastNameMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newLastName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastName = newLastName; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: first, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: last, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: born, <span class="hljs-attr"><span class="hljs-attr">computeAge</span></span>: computeAgeMethod, <span class="hljs-attr"><span class="hljs-attr">setLastName</span></span>: setLastNameMethod }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person; } <span class="hljs-comment"><span class="hljs-comment">// Create a new person and get their age: var p = createPerson("Anne", "Hathaway", 1982); console.log(p.computeAge(2013));</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/810/2b0/454/8102b045435f7de9c14951fa5a1d5882.png" alt="image"><br><br><h3>  Prototypes </h3><br>  The resulting <code>createPerson</code> function has the following disadvantage: it does not work very fast and spends a lot of memory every time an object is created.  Each time you call <code>createPerson</code> JavaScript constructs two new functions, and assigns them as values ‚Äã‚Äãto the ‚ÄúcomputeAge‚Äù and ‚ÄúsetLastName‚Äù fields. <br><br>  How to make it so as not to create these functions every time?  How to make the object referenced by a person not have the <code>setLastName</code> and <code>setLastName</code> fields, but the <code>person.computeAge()</code> and <code>person.setLastName()</code> methods still work? <br><br>  To solve just this problem in JavaScript there is a mechanism called ‚Äúprototypes‚Äù, or rather ‚Äúprototype chains‚Äù.  The concept is simple: if an object does not have its own method or field, then the JavaScript engine tries to find this field in the prototype.  And if the prototype does not have a field, then try to find the field in the prototype of the prototype.  And so on.  Try twisting the following code in Node.JS by copying it to the <code>node</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj1 = { <span class="hljs-string"><span class="hljs-string">"a"</span></span>: <span class="hljs-string"><span class="hljs-string">"aVar"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj2 = { <span class="hljs-string"><span class="hljs-string">"b"</span></span>: <span class="hljs-string"><span class="hljs-string">"bVar"</span></span> }; obj1 obj2 obj2.a obj2.b obj2.__proto__ = obj1; obj1 obj2 obj2.a obj2.b</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/90c/6b2/41f/90c6b241fb5869bbe986b2c2d18042df.png" alt="image"><br><br>  We see that if we indicate that the object <code>obj2</code> is the prototype of the object <code>obj1</code> , then <code>obj2</code> ‚Äúproperties‚Äù of the object <code>obj1</code> ‚Äúappear‚Äù, such as the field ‚Äúa‚Äù with the value ‚ÄúaVar‚Äù.  At the same time, printing <code>obj2</code> will not show the presence of the ‚Äúa‚Äù attribute in the object. <br><br>  Therefore, you can do the methods once, put them into the prototype, and <code>createPerson</code> transform so as to use this prototype: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first, last, born</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: first, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: last, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: born }; person.__proto__ = personPrototype; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> personPrototype = { <span class="hljs-string"><span class="hljs-string">"computeAge"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentYear</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentYear - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.yearOfBirth; }, <span class="hljs-comment"><span class="hljs-comment">//     "setLastName": function(newLastName) { this.lastName = newLastName; } } // Create a new person and get their age: var p = createPerson("Anne", "Hathaway", 1982); console.log(p); console.log(p.computeAge(2013));</span></span></code> </pre><br>  Try this code in <code>node</code> .  Notice which simple object, without its own methods, is shown via <code>console.log(p)</code> .  And that this simple object still has a <code>computeAge</code> method. <br><br>  This method of specifying a prototype object has two drawbacks.  The first is that the special attribute <code>__proto__</code> very new, and may not be supported by browsers.  The second drawback is that even if we no longer clutter up the namespace with the functions <code>computeAge</code> and <code>setLastName</code> we still bogged it down with the name <code>personPrototype</code> . <br><br>  Fortunately, another JavaScript trick comes to the rescue, which is standard and compatible with all browsers. <br><br>  If the function is called not just by the name <code>f()</code> , but through <code>new f()</code> (compare with C ++ or Java!), Then two things happen: <br><br><ol><li>  A new empty object {} is created, and this in the body of the function starts to show on it. <br><br>  <b>More details.</b>  By default, when calling a function <code>f()</code> accessible from inside function <code>this</code> points simply to the global context;  that is, wherever the <code>window</code> shows in the browser, or <code>global</code> from Node.JS. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }; f() <span class="hljs-comment"><span class="hljs-comment">//     ,    : console.log(window)</span></span></code> </pre><br>  We know that if we call a function as a field of some object <code>pf()</code> , then this function will already show this object p on this object.  But if the function is called via <code>new f()</code> , then a fresh empty object <code>{}</code> will be created, and <code>this</code> within the function will already be pointed to it.  Try node: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log({ <span class="hljs-string"><span class="hljs-string">"a"</span></span>: <span class="hljs-string"><span class="hljs-string">"this is an object"</span></span>, <span class="hljs-string"><span class="hljs-string">"f"</span></span>: f }.f()); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> f());</code> </pre><br></li><li>  In addition, each function has a special attribute <code>.prototype</code> .  The object on which the <code>.prototype</code> attribute is <code>.prototype</code> will automatically become the prototype of the newly created object from item 1. <br><br>  Try <code>node</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fooProto = { <span class="hljs-string"><span class="hljs-string">"foo"</span></span>: <span class="hljs-string"><span class="hljs-string">"prototype!"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }; (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> f()).foo <span class="hljs-comment"><span class="hljs-comment">//  undefined f.prototype = fooProto; (new f()).foo //  "prototype!"</span></span></code> </pre></li></ol><br>  With this knowledge, it is easy to understand how the createPerson code written above using the <code>__proto__</code> supernova attribute is equivalent to this more traditional code: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first, last, born</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstName = first; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastName = last; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.yearOfBirth = born; } createPerson.prototype = { <span class="hljs-string"><span class="hljs-string">"computeAge"</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentYear</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentYear - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.yearOfBirth; }, <span class="hljs-comment"><span class="hljs-comment">//     "setLastName": function(newLastName) { this.lastName = newLastName; } } // Create a new person and get their age: var p = new createPerson("Anne", "Hathaway", 1982); console.log(p); console.log(p.computeAge(2013));</span></span></code> </pre><br>  Pay attention to the following aspects: <br><ul><li>  we call new createPerson instead of createPerson; </li><li>  we set the prototype object once from outside the function, so as not to construct functions every time we call createPerson; </li></ul><br>  In principle, you can not change the entire object pointed to by <code>createPerson.prototype</code> , but simply set the required fields separately.  This idiom can also be found in industrial JavaScript code: <br><br><pre> <code class="javascript hljs">createPerson.prototype.computeAge = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentYear</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentYear - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.yearOfBirth; } createPerson.prototype.setLastName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newLastName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastName = newLastName; }</code> </pre><br><br><h3>  We connect a piece of jQuery library </h3><br>  Please note that the body of the <code>createPerson</code> function instead of simple and clear <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first, last, born</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: first, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: last, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: born }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> person; }</code> </pre><br>  turned into a pretty awful sequence of manipulations with <code>this</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first, last, born</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstName = first; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastName = last; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.yearOfBirth = born; }</code> </pre><br>  This manual initialization of object attributes ( <code>firstName</code> , <code>lastName</code> ) into argument values ‚Äã‚Äã( <code>first</code> , <code>last</code> ) is suitable for variants with a very small number of arguments.  But for large and spreading configurations, the manual listing of attributes becomes inconvenient and unnecessarily verbose. <br><br>  We can simplify the initialization of an object with multiple fields using the <a href="http://api.jquery.com/jQuery.extend/">jQuery.extend</a> function, which simply copies attributes from one object to another: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">first, last, born</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = { <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: first, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: last, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: born }); $.extend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, person); }</code> </pre><br>  In addition, we can not transfer a bunch of fields with the function arguments, but pass an object with the fields we need to the input of the function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPerson</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ $.extend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, person); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> createPerson({ <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">"Anne"</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">"Hathaway"</span></span>, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: <span class="hljs-number"><span class="hljs-number">1982</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(p);</code> </pre><br>  (Unfortunately, due to the need to use <code>jQuery</code> , this code is easiest to try in the browser, and not in the terminal with the <code>node</code> .) <br><br>  This code already looks simple and compact.  But why do we create a ‚Äúnew createPerson‚Äù?  It's time to rename the method to a more appropriate name: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Person</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">person</span></span></span><span class="hljs-function">) </span></span>{ $.extend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, person); } Person.prototype.computeAge = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentYear</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentYear - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.yearOfBirth; } Person.prototype.setLastName = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newLastName</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastName = newLastName; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> anne = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person({ <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">"Anne"</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">"Wojcicki"</span></span>, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: <span class="hljs-number"><span class="hljs-number">1973</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sergey = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person({ <span class="hljs-attr"><span class="hljs-attr">firstName</span></span>: <span class="hljs-string"><span class="hljs-string">"Sergey"</span></span>, <span class="hljs-attr"><span class="hljs-attr">lastName</span></span>: <span class="hljs-string"><span class="hljs-string">"Brin"</span></span>, <span class="hljs-attr"><span class="hljs-attr">yearOfBirth</span></span>: <span class="hljs-number"><span class="hljs-number">1973</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(anne); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(sergey);</code> </pre><br><br>  Here‚Äôs how it looks in the Safari or Chrome console: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/555/038/bf8/555038bf8490f49927859667639cf8b2.png" alt="image"><br><br>  This form of writing is already very similar to how a class is written and works in C ++, so in JavaScript, the <code>Person</code> function is sometimes called a class.  For example, you can say: ‚ÄúPerson has a method computeAge‚Äù. <br><br><h2>  Link </h2><br><ul><li>  <a href="http://sporto.github.com/blog/2013/02/22/a-plain-english-guide-to-javascript-prototypes/">http://sporto.github.com/blog/2013/02/22/a-plain-english-guide-to-javascript-prototypes/</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/171731/">https://habr.com/ru/post/171731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171721/index.html">Russian startups at the 2013 London Web Summit</a></li>
<li><a href="../171723/index.html">Handwriting recognition using Python and scikit</a></li>
<li><a href="../171725/index.html">Non-standard cost-saving: how we learned to repair the Nortel 1120 office IP phones by ourselves</a></li>
<li><a href="../171727/index.html">Lean. Part 1. Kanban board in a new way.</a></li>
<li><a href="../171729/index.html">CeBIT 2013: SMI Augmented Eyewear Goggles</a></li>
<li><a href="../171733/index.html">Nirvana for Testers - Nerrvana</a></li>
<li><a href="../171735/index.html">Animation UIView: moving along an arbitrary trajectory on the example of a circle</a></li>
<li><a href="../171743/index.html">Arbitrary view of the file field in html-form, the same in all browsers</a></li>
<li><a href="../171745/index.html">PostgreSQL performance scaling with table partitioning</a></li>
<li><a href="../171747/index.html">CeBIT'13. The first day</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>