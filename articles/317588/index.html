<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The Tale of Lost Time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To be honest, not quite a fairy tale, but a harsh life. But time is lost, the present is completely, albeit to good use. It all started quite by accid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The Tale of Lost Time</h1><div class="post__text post__text-html js-mediator-article">  To be honest, not quite a fairy tale, but a harsh life.  But time is lost, the present is completely, albeit to good use.  It all started quite by accident.  On one site, one intelligent comrade <a href="https://science.dirty.ru/krtkst-1253293/">wrote a post</a> about <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D0%25BF%25D0%25BE%25D1%2582%25D0%25B5%25D0%25B7%25D0%25B0_%25D0%25AD%25D0%25B9%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0">Euler</a> 's <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25B8%25D0%25BF%25D0%25BE%25D1%2582%25D0%25B5%25D0%25B7%25D0%25B0_%25D0%25AD%25D0%25B9%25D0%25BB%25D0%25B5%25D1%2580%25D0%25B0">hypothesis</a> .  The point is quite simple.  Euler's hypothesis states that for any natural number n&gt; 2, no nth power of a natural number can be represented as the sum of (n-1) nth powers of other natural numbers.  That is, the equations: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/271/b3d/4cd/271b3d4cd62544c695cb8ba849078e24.png"></div><br>  do not have a solution in natural numbers. <br><br>  Well, actually the way it was until 1966 ... <br><a name="habracut"></a><br>  So far L. Lander (LJ Lander), T. Parkin (TR Parkin) and J. Selfridge (JL Selfridge) did not find the first counterexample for n = 5. And they did it on a supercomputer of that time - <a href="https://ru.wikipedia.org/wiki/CDC_6600">CDC 6600</a> , developed under the command of a not unknown <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D1%258D%25D0%25B9,_%25D0%25A1%25D0%25B5%25D0%25B9%25D0%25BC%25D1%2583%25D1%2580">Seymour</a> Roger Cray (Seymour Roger Cray) and had this supercomputer performance as much as 3 MFLOPS.  Their scientific work looked like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/579/d05/565/579d055657944e2595afd5390b34caeb.png"><br><br>  That is, by a simple search on a supercomputer, they found numbers of degree 5, which disproved Euler's hypothesis: 27 <sup>5</sup> + 84 <sup>5</sup> + 110 <sup>5</sup> + 133 <sup>5</sup> = 144 <sup>5</sup> . <br><br>  And everything would be fine, but another smart <a href="https://science.dirty.ru/krtkst-1253293/">comrade asked</a> : "I <i>wonder, but can any programmer write out the code for a super-modern i5 to search for more such coincidences? ...</i> ". <br><br>  As you can see, the offer worked like a red rag.  The first decision was quite beautiful and written with the mind.  The bottom line is that we first consider the fifth degrees for 1-N numbers, put them in a table and recursively start looking at the bottom of the four terms of the fifth degrees, looking in the table for the sum of the resulting values.  If found - this is the solution (the index in the table will be a number, the degree of which we have found). <br><br>  This is the first version of <a href="https://science.dirty.ru/krtkst-1253293/">2Alias</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;stdlib.h&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; using namespace std; typedef long long LL; const int N = 250; LL p5(int x) { int t = x * x; return t * (LL) (t * x); } vector&lt;LL&gt; p; std::unordered_map&lt;LL, int&gt; all; int res[5]; void rec(int pr, LL sum, int n) { if (n == 4) { if (all.find(sum) != all.end()) { cout &lt;&lt; "Ok\n"; res[4] = all[sum]; for (int i = 0; i &lt; 5; ++i) cout &lt;&lt; res[i] &lt;&lt; " "; cout &lt;&lt; "\n"; exit(0); } return; } for (int i = pr + 1; i &lt; N; ++i) { res[n] = i; rec(i, sum + p[i], n + 1); } } int main() { for (int i = 0; i &lt; N; ++i) { p.push_back(p5(i)); all[p.back()] = i; } rec(1, 0, 0); return 0; }</span></span></span></span></code> </pre> <br>  And as it usually happens, I thought, can it be faster?  At the same time, people have a question, what will happen if you check C # in this case.  I rewrote the solution in C # on the forehead and the program showed approximately the same result in time.  Already interesting!  But we will still optimize C ++.  After all then all is easy for transferring to C #. <br><br>  The first thing that came to mind was to remove recursion.  Well, just enter 4 variables and we will sort them out with the increment of the older ones when the younger ones overflow. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// N -     1 - N   5 // powers -      // all = unordered_map&lt; key= , value= &gt; uint32 ind0 = 0x02; //    2 uint32 ind1 = 0x02; uint32 ind2 = 0x02; uint32 ind3 = 0x02; uint64 sum = 0; while (true) { sum = powers[ind0] + powers[ind1] + powers[ind2] + powers[ind3]; if (all.find(sum) != all.end()) { //   - !! foundVal = all[sum]; ... } //  ++ind0; if (ind0 &lt; N) { continue; } else { ind0 = 0x02; ++ind1; } if (ind1 &gt;= N) { ind1 = 0x02; ++ind2; } if (ind2 &gt;= N) { ind2 = 0x02; ++ind3; } if (ind3 &gt;= N) { break; } }</span></span></code> </pre><br>  And then the result became worse.  After all, we will meet many identical amounts, most of which bypass the recursive algorithm.  Suppose we have numbers from 1 to 3, we will iterate them: <br><br>  111 <br>  112 <br>  113 <br>  121 &lt;- already been! <br>  122 <br>  123 <br>  131 &lt;- already been! <br>  132 &lt;- already been! <br>  133 <br>  ... <br><br>  So I‚Äôll have to watch combinatorics, but it didn‚Äôt help me much, since I don‚Äôt have enough knowledge on this topic, I had to write out about the same example on a piece of paper and think.  And the solution was found: with the increment of the higher digits, you do not need to reset the younger ones to the very minimum, but assign the value of the older ones to all the younger ones - this way we cut off the excess. <br><br>  The index increase code has become: <br><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//  ++ind0; if (ind0 &lt; N) { continue; } else { ind0 = ++ind1; } if (ind1 &gt;= N) { ind0 = ind1 = ++ind2; } if (ind2 &gt;= N) { ind0 = ind1 = ind2 = ++ind3; } if (ind3 &gt;= N) { break; }</span></span></code> </pre><br>  Hooray!  And immediately a little faster.  But what does the profiler tell us?  Most of the time we sit in unordered_map.find ... <br><br>  I start to remember search algorithms and various knowledge (up to the demoscene).  And what if before checking in unordered_map somehow quickly cut off some of the unnecessary? <br><br>  So there was another array, already bit (bitset).  Since we don‚Äôt put numbers into it (they are too big), we‚Äôll have to quickly make a hash of a power, bring it to the number of bits in the array and mark there.  All this must be done when constructing a table of degrees.  In the process of writing, it turned out that std :: bitset is a little slower than a simple array and minimal logic that I sketched.  Well, okay, this is nonsense.  But in general, the acceleration was significant, about two times. <br><br>  A lot of experimenting with the size of the bitset and the complexity of the hash made it clear that by and large only memory affects, and for different N differently and a large degree of filtering of calls to unordered_map.find is better only up to a certain limit. <br><br>  It looked like this: <br><br><pre> <code class="cpp hljs"> ... <span class="hljs-comment"><span class="hljs-comment">//            if (findBit(sum)) { //      map,    -     -  if (all.find(sum) != all.end()) { // ! } } //  ...</span></span></code> </pre><br>  Then there was problem number two.  The first example from the distant 1966 had the maximum number of 144 <sup>5</sup> (61 917 364 224), and the second (2004) already 85359 <sup>5</sup> (4 531 548 087 264 753 520 490 799) - the numbers cease to fit 64 bits ... <br><br>  We go the easiest way: take boost :: multiprecision :: uint128 - that‚Äôs enough for us for a long time!  This is due to the fact that I use MS CL, but it just does not support uint128, like all other compilers.  By the way, during the search for a solution to the problem of uint128 and compilers, I also found out about the posh site - <a href="http://godbolt.org/">Compiler Explorer</a> .  Directly online, you can compile the code with all popular compilers of different versions and see what they are translating into it (assembler), and with different compilation flags.  <a href="http://gcc.beta.godbolt.org/">MS CL is</a> also there, but on the beta site.  And besides <a href="http://godbolt.org/">C ++,</a> there is <a href="https://rust.godbolt.org/">Rust</a> , <a href="https://d.godbolt.org/">D</a> and <a href="https://go.godbolt.org/">Go</a> .  Actually, it became clear from the code that MS CL does not understand 128 compound integers at all, all compilers translate the multiplication of two 64-bit into 128-bit structure for three multiplications, and MS CL for four.  But back to the code. <br><br>  With boost :: multiprecision :: uint128, performance dropped 25 times.  And this is somehow completely wrong, because in theory there should be no more than 3 times.  It's funny that the performance of the decimal type C # has dropped by the same amount (although it is not quite integer, but its 96bit mantissa).  And preliminary filtering of calls to the Dictionary (a kind of unordered_map from STL) works well, the acceleration is very noticeable. <br><br>  Well, then you know, it became a shame.  So much has already been done and everything is in vain.  So we will reinvent the wheel!  That is, the simple data type is uint128.  In fact, we only need assignment, comparison, multiplication and addition.  Not so difficult, but the process at the beginning went wrong, because at first I took up the multiplication and it came to the use of the assembler.  There is nothing to be proud of; <a href="https://msdn.microsoft.com/en-us/library/hh977022.aspx">intrinsics</a> showed themselves best of all.  Why did the process go wrong?  And multiplication is not important for us.  After all, multiplication is involved only at the stage of calculating the degree table and does not participate in the main cycle.  Just in case, the source file has a multiply file on an assembler - it will suddenly come in handy. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> uint128 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint128&amp; s, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint128&amp; d) { <span class="hljs-comment"><span class="hljs-comment">// intristic use uint64 h = 0; uint64 l = 0; uint64 h2 = 0; l = _mulx_u64(dl, sl, &amp;h); h += _mulx_u64(dl, sh, &amp;h2); h += _mulx_u64(dh, sl, &amp;h2); return uint128( h, l); }</span></span></code> </pre><br>  With its uint128, performance also, of course, slipped, but only by 30% and that‚Äôs great!  Joy is full, but we do not forget the profiler.  But what if you completely remove unordered_map and make a bitor similar to unordered_map from a self-defined bitset?  That is, after calculating the amount hash, we can already use this number as an index in another table (unordered_map is not needed then). <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//     map boost::container::vector&lt;CompValue*&gt; setMap[ SEARCHBITSETSIZE * 8 ]; ... // ComValue       struct CompValue { ... mainType fivePower; uint32 number; }; //       map inline uint32 findBit(mainType fivePower) { uint32 bitval = (((uint32)((fivePower &gt;&gt; 32) ^ fivePower))); bitval = (((bitval &gt;&gt; 16) ^ bitval) &amp; SEARCHBITSETSIZEMASK); uint32 b = 1 &lt;&lt; (bitval &amp; 0x1F); uint32 index = bitval &gt;&gt; 5; if((bitseta[index] &amp; b) &gt; 0) { for (auto itm : setMap[bitval]) { if (itm-&gt;fivePower == fivePower) { return itm-&gt;number; } } } return 0; }</span></span></code> </pre><br>  Since the project was completely frivolous and did not carry any payload, I saved all the ways of searching, searching and different values ‚Äã‚Äãthrough a terrible set of defines and mainType just one of them - this is the type where the degree of the number is written to replace it when changing only once code.  Already at this stage, all tests can be performed with uint64, uint128 and boost :: multiprecision :: uint128, depending on the define - it turns out very interesting. <br><br>  And you know, the introduction of your map has helped!  But not for long.  After all, it is clear that the map is not just so invented and used wherever possible.  Experiments - this, of course, confirm.  With a certain N (closer to 1,000,000), when all the algorithms are already inhibited, the bare map (without a prior bitset) already bypasses the samopisny analog and saves only a significant increase in the bit array and the array where our values ‚Äã‚Äãof degrees and numbers are stored, and this is a huge amount of memory.  An approximate multiplier of about N * 192, that is, for N = 1 000 000 we need more than 200mb.  And then even more.  At this point, it was not yet understood why the speed drops as the array of degrees grows, and I continued to look for bottlenecks with the profiler. <br><br>  While thinking was going on, I made all the tried and tested methods switchable.  For you never know what. <br><br>  One of the latest optimizations turned out to be simple, but effective.  The speed of the C ++ version has already exceeded 400 000 000 searches per second for 64 bits (with N = 500), 300 000 000 searches for 128 bits and only 24 000 000 for 128 bits from boost, and almost everything could affect the speed.  If you translate in GB, then the reading is about 20GB per second.  Well, maybe I was wrong somewhere ... <br><br>  Suddenly it became clear that it was not necessary to recalculate the entire amount on each pass and you can enter an intermediate one.  Instead of three additions there will be one.  And to recalculate the intermediate only when increasing the high-order digits.  For larger types, this is of course more pronounced. <br><br><pre> <code class="cpp hljs"> mainType sum = <span class="hljs-number"><span class="hljs-number">0U</span></span>, baseSum = <span class="hljs-number"><span class="hljs-number">0U</span></span>; baseSum = powers[ind1] + powers[ind2] + powers[ind3]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { sum = baseSum + powers[ind0]; ... <span class="hljs-comment"><span class="hljs-comment">// refresh without ind0 baseSum = powers[ind1] + powers[ind2] + powers[ind3]; }</span></span></code> </pre><br>  Here, the task was beginning to bother, since it was no longer possible and I started the C # version.  Everything moved there.  I found a ready-made UInt128, written by another person - about as simple as mine for C ++.  And, of course, the speed jumped strongly.  The difference was less than half compared to 64 bits.  And this is another VS2013 for me, that is, not roslyn (can it be faster?). <br><br>  But samopisny map loses in all articles Dictionary.  Apparently checking the boundaries of arrays make themselves felt, for increasing the memory does not give anything. <br><br>  Then it went completely nonsense, there was even an attempt to optimize the addition of intrinsics, but the pure C ++ version turned out to be the fastest.  For some reason, I could not get the inline assembly code. <br><br>  And yet I constantly did not let go the feeling that I did not see something.  Why does everything start to slow down as the array grows?  When N = 1 000 000 performance drops by 30 times.  Comes to the CPU cache.  I even tried the prefetch intrinsic, the result is zero.  The idea came to cache a part of the array being scanned, but at 1,000,000 values ‚Äã‚Äã(20 bytes) it looks somehow stupid.  And then the full picture begins to emerge. <br><br>  Since the numbers are 4, there are 4 indices that take values ‚Äã‚Äãfrom the table.  The table is of constantly increasing values ‚Äã‚Äãand the sum of all four degrees is constantly increasing (until the switching of the highest indices).  And the difference of degrees becomes more and more. <br>  2 <sup>5</sup> is 32, and 3 <sup>5</sup> is already 243. And what if we search directly in the same array of calculated degrees with the usual linear search, first setting the initial value to the largest index and keeping the index of the last smaller value found than our sum (the next one will be more) and use this saved index as a starting point in the next search, because the values ‚Äã‚Äãwill not change much ... Bingo! <br><br>  What is the result? <br><br><pre> <code class="cpp hljs"> uint32 lastRangeIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      inline uint32 findInRange(mainType fivePower, uint32 startIndex) { while (startIndex &lt; N) { lastRangeIndex = startIndex; if (powers[startIndex] &gt; fivePower) { return 0; } if (powers[startIndex] == fivePower) { return startIndex; } ++startIndex; } return 0; } ... //    baseSum = powers[ind1] + powers[ind2] + powers[ind3]; while (true) { sum = baseSum + powers[ind0]; foundVal = findInRange( sum, lastRangeIndex); if (foundVal &gt; 0) { // ! } //  ++ind0; if (ind0 &lt; N) { continue; } else { ind0 = ++ind1; } if (ind1 &gt;= N) { ind0 = ind1 = ++ind2; } if (ind2 &gt;= N) { ind0 = ind1 = ind2 = ++ind3; } if (ind3 &gt;= N) { break; } //          lastRangeIndex = 0x02; if (ind1 &gt; lastRangeIndex) { lastRangeIndex = ind1; } if (ind2 &gt; lastRangeIndex) { lastRangeIndex = ind2; } if (ind3 &gt; lastRangeIndex) { lastRangeIndex = ind3; } // refresh without ind0 baseSum = powers[ind1] + powers[ind2] + powers[ind3]; }</span></span></code> </pre><br>  The speed at small values ‚Äã‚Äãof N is slightly inferior to the samopisny map, but as soon as N grows, the speed of work even starts to grow!  After all, the intervals between the powers of large N grow the farther, the more and the linear search works less and less!  The complexity is better than O (1). <br><br>  So much for the loss of time.  And why?  Do not rush to the embrasure, sit down - think.  As it turned out, the fastest algorithm is a linear search and no map / bitset is needed.  But, of course, this is a very interesting experience. <br><br>  Habr loves source codes <a href="https://github.com/crea7or/EulerPowersConjecture">and I have them</a> .  In commits, you can even see the history of the "struggle".  There are both versions of C ++ and C #, in which this trick, of course, works just as well.  Projects, though invested in one another, but, of course, not connected. <br><br>  The sources are terrible, there are defaults at the beginning, where you can set the main value (uint64, uint128, boost :: uin128 / decimal (for C #), the library can be switched std / boost (boost :: unordered_map turned out to be faster than std :: unordered_map by about 10% The search algorithm is also selected (though now I see that the preliminary filter for unordered_map in C ++ version did not survive the edits, but it is in commits and in C # version) unordered_map, self-defined bitset and range (last option). <br><br>  Here is such a fairy tale and a lesson to me.  And maybe someone else will be interested.  After all, a lot of what values ‚Äã‚Äãhave not <a href="https://en.wikipedia.org/wiki/Euler%2527s_sum_of_powers_conjecture">yet found</a> ... <br><br><img src="https://habrastorage.org/files/00f/1df/165/00f1df165d7f4afa8b9666379648b48a.jpg"><br>  * k / f Tale of Lost Time, 1964. </div><p>Source: <a href="https://habr.com/ru/post/317588/">https://habr.com/ru/post/317588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317574/index.html">Processing and storage of data: from antiquity to data centers</a></li>
<li><a href="../317576/index.html">VR accessibility for people with disabilities</a></li>
<li><a href="../317578/index.html">Modularization in JavaSE without OSGI and Jigsaw</a></li>
<li><a href="../317580/index.html">Android and the ‚ÄúInternet of Things‚Äù are closer to each other</a></li>
<li><a href="../317584/index.html">How IT professionals work. Konstantin Osipov, developer and founder of the Tarantool project</a></li>
<li><a href="../317596/index.html">Mitap TechTalks from EXANTE and HSE</a></li>
<li><a href="../317598/index.html">Add-on to Avito. Startup or architecture example</a></li>
<li><a href="../317602/index.html">Many to many link and upsert in Ecto 2.1</a></li>
<li><a href="../317610/index.html">Test task as a means of collecting ideas</a></li>
<li><a href="../317612/index.html">Exporting tabular data from applications written under .NET in C #</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>