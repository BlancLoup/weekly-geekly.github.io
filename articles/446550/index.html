<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pattern Problems Coordinator and what's the RouteComposer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue the series of articles about the library RouteComposer we use, and today I want to talk about the Coordinator pattern. By writing this arti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pattern Problems Coordinator and what's the RouteComposer</h1><div class="post__text post__text-html js-mediator-article"><p>  I continue the series of articles about the library <a href="https://github.com/saksdirect/route-composer">RouteComposer</a> we use, and today I want to talk about the Coordinator pattern.  By writing this article, I was inspired by the discussion of one of the articles on the Coordinator pattern here on Habr√©. </p><br><p>  The Pattern Coordinator, having been introduced not so long ago, is gaining more and more popularity in IOS developer circles, and, in general, it is clear why.  Because the tools out of the box that <strong>UIKit</strong> provides are a rather non-universal mess. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/304/47d/bd8/30447dbd8d2a0a39a34f7f6946a02383.png" alt="image"></p><a name="habracut"></a><br><p>  I have already raised the issue of fragmentation of ways of composition with the view controllers on the stack, and to avoid repetition - you can just read about it <a href="https://habr.com/ru/post/421097/">here</a> . </p><br><p> Let's be honest.  At some point, and Epol realized that putting twist controllers in the application development center, she did not offer any sensible way to create or transfer data between them, and, having ordered the solution of this problem to the developers of autocompilers from Xcode, but can the developers of UISearchConnroller, at some point presented storyboards and segues.  Then Epol realized that the application consisting of 2 screens she writes only herself, and in the next iteration offered the opportunity to split storyboards into several parts, as Xcode began to crash when it reached a certain size.  Segues have changed with this concept, in several iterations that are not very compatible with each other.  Their support is tightly embedded in the massive <code>UIViewController</code> class, and, ultimately, we got what we got.  This: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"showDetail"</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> indexPath = tableView.indexPathForSelectedRow { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = objects[indexPath.row] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">NSDate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> controller = (segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>).topViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> controller.detailItem = object controller.navigationItem.leftBarButtonItem = splitViewController?.displayModeButtonItem controller.navigationItem.leftItemsSupplementBackButton = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } }</code> </pre> <br><p>  The number of force typkasts in this block of code is amazing, as are the string constants in the storyboards themselves, for which Xcode does not offer any means to track.  And the slightest desire to change something in the process of navigation will allow you to compile the project without any effort, and it will crash into runtime with a cheerful crackling sound without any warning from Xcode.  Here is such a WYSIWYG eventually turned out.  What you see is what you get. </p><br><p>  One can argue about the charms of these gray arrows in the storyboards supposedly showing someone the connections between the screens, but, as my practice showed, and I deliberately interviewed several familiar developers from different companies, as soon as the project grew beyond 5-6 screens, people tried find a more reliable solution and finally began to keep the structure of the stack of view controllers in my head.  And if you added support for the iPad and another navigation model, or support for pushing, then everything was generally sad. </p><br><p>  Since then, several attempts have been made to solve this problem, some of which turned into separate frameworks, some into separate architectural patterns, because by creating the view controller inside the controller view, this massive and unwieldy piece of code made even more. </p><br><p>  Let's return to the Coordinator pattern.  For obvious reasons, you will not find its description in Wikipedia because it is not a standard programming / design pattern.  Rather, it is a kind of abstraction that suggests hiding under the hood all this ‚Äúugly‚Äù code of creating and inserting into the stack a new view of the controller, storing references to the container controllers and pushing data between the controllers.  The most useful article describing this process, I would call an article on <a href="https://www.raywenderlich.com/158-coordinator-tutorial-for-ios-getting-started">raywenderlich.com</a> .  It is starting to become popular after the 2015 NSSpain conference, when it was told to the general public.  In more detail what has been told can be found <a href="http://khanlou.com/2015/01/the-coordinator/">here</a> and <a href="http://khanlou.com/2015/10/coordinators-redux/">here</a> . </p><br><p>  I will briefly describe what it is before moving on. </p><br><p>  In all interpretations the Pattern Coordinator fits approximately into this picture: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/554/4bb/f95/5544bbf95415d233060a7e4d515ff58d.png"></p><br><p>  That is, the coordinator is a protocol </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Coordinator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> }</code> </pre> <br><p>  And all the ‚Äúugly‚Äù code is supposed to be hidden in the <code>start</code> function.  The coordinator, in addition, may have links to child coordinators, that is, they have some ability to compose, and, for example, you can replace one implementation with another.  That is, it sounds pretty elegant. </p><br><p>  However, non-elegance starts pretty soon: </p><br><ol><li>  Some implementations propose to transform the Coordinator from some generating pattern into something more reasonable, following the stack of view controllers, and <em>make it a container delegate</em> , for example, <code>UINavigationController</code> , to handle pressing the Back button or swipe back and remove the child coordinator.  For natural reasons, only one object can be a delegate, which limits the ability to control the container itself and leads to the fact that this logic either lies with the coordinator or creates the need to delegate this logic further to someone else on the list. </li><li>  Often, the logic of creating the next controller <em>depends on the business logic</em> .  For example, to go to the next screen, the user must be logged in to the system.  Clearly, this is an asynchronous process, which involves spawning some intermediate screen with a login form, the login process itself can succeed or not.  To avoid turning the Coordinator into a Massive Coordinator (by analogy with the Massive View Controller), we need decomposition.  That is, in fact, it is necessary to create a Coordinator Coordinator. </li><li>  Another problem faced by coordinators is that they are essentially wrappers for container <code>UITabBarController</code> controllers, such as <code>UINavigationController</code> , <code>UITabBarController</code> and so on.  And someone has to provide <em>links to these controllers to</em> them.  If everything is more or less clear with the child coordinators, then the initial coordinators of the chain are not so simple.  Plus, when changing the navigation, for example for the A / B test, refactoring and adaptation of such coordinators results in a separate headache.  Especially if the type of container changes. </li><li>  All this becomes even more complicated when the application begins to support <em>external events</em> that spawn controllers.  Such as push-notifications or universal links (the user clicks on the link in the letter and continues in the appropriate screen of the application).  There are other uncertainties that the Pattern Coordinator does not have an exact answer for.  You need to know exactly which screen the user is on in order to show him the next screen requested by an external event. <br>  The simplest example is a chat application consisting of 3 screens - the chat list, the chat itself which is pushed into the navigation of the chat list controller and the settings screen shown modally.  A user can be on one of these screens when they receive a push notification and tap on it.  And then uncertainty begins, if it is in the chat list, you need to start the chat with this particular user, if it is already in the chat, then you need to switch it, and if it is already in the chat with this user, then do nothing and update it if the user is on the settings screen - it's probably necessary to close and do the previous steps.  Or maybe not close and just show the chat modally over the settings?  And if the settings in another tab, and not modal?  These <code>if/else</code> begin to spread over the coordinators or go to another Mega-Coordinator in the form of a piece of spaghetti.  Plus, there are either active iterations of the stack of view controllers and an attempt to determine where the user is at the moment, or an attempt to build an application that monitors its state, but this is not a very simple task, simply based on the nature of the stack of controllers. </li><li>  And the cherry on the cake are <em>UIKit glitches</em> .  A trivial example: <code>UITabBarController</code> , which has a <code>UINavigationController</code> in the second tab with some other <code>UIViewController</code> .  The user in the first tab causes some kind of event that requires switching the tab and <code>UINavigationController</code> another controller in his <code>UINavigationController</code> .  This is all you need to do in that order.  If the user has never opened the second tab before this, and the <code>UINavigationController</code> not called the <code>viewDidLoad</code> method, <code>push</code> will not work, leaving only a vague message in the console.  That is, the coordinators cannot simply be made listeners of the events in this example; they must work in a certain sequence.  So must have knowledge of each other.  And this already contradicts the first statement of the Coordinator pattern, that the coordinators do not know anything about the generating coordinators and are connected only with the child ones.  And also limits their interchangeability. </li></ol><br><p>  This list can be continued, but in general it is clear that the Coordinator pattern is a rather limited, poorly scalable solution.  If you look at it without rose-colored glasses, then it is a way of decomposing a part of logic, which is usually written inside the massive <code>UIViewController</code> , into another class.  All attempts to make it something more than a kind of generating factory and introduce there another logic, do not end too well. </p><br><p>  It is worth noting that there are libraries based on this pattern, which with one success or another allow to partially offset the listed disadvantages.  I would <a href="https://github.com/quickbirdstudios/XCoordinator">point</a> out <a href="https://github.com/quickbirdstudios/XCoordinator">XCoordinator</a> and <a href="https://github.com/RxSwiftCommunity/RxFlow">RxFlow</a> . </p><br><h2 id="chto-sdelali-my">  What did we do? </h2><br><p>  Having played in the project that we got from the other team for support and development, with the coordinators and their simplified ‚Äúgreat-grandmother‚Äù Routers in the <em>VIPER</em> architectural approach, we rolled back to an approach that proved itself well in the previous large project of our company.  There is no name for this approach.  It lies on the surface.  When we had free time, it was isolated in a separate library <a href="https://github.com/saksdirect/route-composer">RouteComposer,</a> which completely replaced the coordinators and showed itself more flexible. </p><br><p>  What is this approach?  In order to rely on the stack (tree) I twist the controllers as it is.  That would not create extra entities that need to be monitored.  Do not save or track states. </p><br><p>  Let's <em>take a</em> closer look at the <em>UIKit</em> entities and try to figure out what we have in the bottom line and what you can work with: </p><br><ol><li>  <strong>The stack of</strong> view <strong>controllers</strong> is some kind of tree.  There is a fundamental view controller, which has child view controllers.  View controllers presented modally are a special case of child view controllers, as they are also tied to the generated view controller.  This is all available out of the box. </li><li>  Entities twist controllers need to create.  They all have different designers, they can be created using Xib files or Storyboards.  They have different input parameters.  But they are united by the fact that they need to be created.  So here we are going to use the <strong>Factory</strong> pattern, which knows how to create the controller I need.  Each factory is easy to cover with exhaustive unit tests and it is not dependent on others. </li><li>  We divide the controllers twist into 2 classes: 1. Just twist the controllers, 2. <strong>Container View Controller twists</strong> .  Container view controllers differ from the usual ones in that they can contain child view controllers - also containers or simple ones.  These view controllers are available out of the box: <code>UINavigationController</code> , <code>UITabBarController</code> and so on, but can be created by the user.  If you abstract, you can find the following properties in all containers: 1. They have a list of all controllers that they contain.  2. One or more controllers are currently visible.  3. They may be asked to make one of these controllers visible.  This is all that I <em>twist UIKit</em> controllers.  They just have different methods for this.  But the tasks are only 3. </li><li>  To embed a factory-created view of a controller, use the method of the parent view controller <code>UINavigationController.pushViewController(...)</code> , <code>UITabBarController.selectedViewController = ...</code> , <code>UIViewController.present(...)</code> and so on.  You may notice that you always need 2 views of the controller, one already on the stack, and one that needs to be built into the stack.  Wrap it in a wrapper and call it an <strong>Action</strong> .  Each action is easy to cover with exhaustive unit tests and each is independent of the others. </li><li>  From the above, it turns out that using prepared entities you can build a chain of configuration <em>Factory -&gt; Action -&gt; Factory -&gt; Action -&gt; Factory</em> and, having executed it, you can build a tree with view controllers of any complexity.  You only need to specify the input point.  Such input points are usually either the <em>rootViewController</em> belonging to the <em>UIWindow</em> or the current view controller, which is the most extreme branch of the tree.  That is, such a configuration is correctly recorded as: <strong>Starting ViewController -&gt; Action -&gt; Factory -&gt; ... -&gt; Factory</strong> . </li><li>  In addition to the configuration, you will need an entity that knows how to run and build the provided configuration.  Call it <strong>Router</strong> .  He does not possess a state, he does not hold any references.  It has one method to which the configuration is passed and it sequentially performs the configuration steps. </li><li>  Add responsibility to the router by adding <strong>Interceptors</strong> to the configuration chain.  Interceptors are available in 3 types: 1. Launched before navigation.  Let's remove in them the tasks of user authentication to the system and other asynchronous tasks.  2. Executed at the time of creation I twist the controller to set the values.  3. Performed after navigation and performing various analytical tasks.  Each entity is easily covered by unit tests and does not know how it will be used in the configuration.  She has only one responsibility and she fulfills it.  That is, the configuration for complex navigation may look like <strong>[Pre-navigation Task ...] -&gt; Starting ViewController -&gt; Action -&gt; (Factory + [ContextTask ...]) -&gt; ... -&gt; (Factory + [ContextTask ...]) -&gt; [Post NavigationTask ...]</strong> .  That is, all tasks will be executed by the router sequentially, performing in turn small, easily readable, atomic entities. </li><li>  There remains the last task that is not solved by the configuration - this is the state of the application at the moment.  What if we do not need to build the entire configuration chain, but only a part of it, because the user has partially passed it?  This question can always be answered unambiguously by a tree with a view of controllers.  Because if part of the chain is already built, it is already in the tree.  So, if each factory in the chain can answer the question whether it is built or not, then the router will be able to understand which part of the chain needs to be completed.  Of course, this is not a factory task, so another atomic entity is entered - a <strong>search engine (Finder)</strong> and any configuration looks like this: <strong>[Pre-navigation Task ...] -&gt; Starting ViewController -&gt; Action -&gt; (Finder / Factory + [ContextTask ...]) -&gt; ... -&gt; (Finder / Factory + [ContextTask ...]) -&gt; [Post NavigationTask ...]</strong> .  If the router starts reading it from the end, then one of the Finders will tell it that it is already built, and the router from this point will begin to build the chain back.  If not one of them finds himself in the tree, then it is necessary to build the whole chain from the initial controller. <br><img src="https://habrastorage.org/getpro/habr/post_images/f50/a64/213/f50a64213fa1654fbde33e53b31f4e43.gif" alt="image"></li><li>  The configuration must be strictly typed.  Therefore, each entity works with only one type of controller view; one type of data and configuration completely rests on the ability of swift to work with <strong>associatedtypes</strong> .  We want to rely on the compiler, not on runtime.  A developer may intentionally weaken typing, but not vice versa. </li></ol><br><p>  An example of this configuration: </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>(finder: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFactory</span></span>()) .add(<span class="hljs-type"><span class="hljs-type">LoginInterceptor</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UUID</span></span>&gt;()) <span class="hljs-comment"><span class="hljs-comment">// Have to specify the context type till https://bugs.swift.org/browse/SR-8719 is fixed .add(ProductViewControllerContextTask()) .add(ProductViewControllerPostTask(analyticsManager: AnalyticsManager.sharedInstance)) .using(UINavigationController.push()) .from(NavigationControllerStep()) .using(GeneralActions.presentModally()) .from(GeneralStep.current()) .assemble()</span></span></code> </pre> <br><p>  The items described above cover the entire library and describe the approach.  All that remains is for us to provide configurations of the chains that the router will perform when the user presses the button or an external event occurs.  If these are different types of devices, for example, iPhone or iPad, then we will provide different transition configurations using polymorphism.  If we have A / B testing, that's the same thing.  We do not need to think about the state of the application at the time of the start of navigation, we need to make sure that the configuration was written correctly initially, and we are sure that the router will build it one way or another. </p><br><p>  The described approach is more complicated than a certain abstraction or pattern, but we have not yet encountered a task where it would not be enough.  Of course, <a href="https://github.com/saksdirect/route-composer">RouteComposer</a> requires some study and understanding of how it works.  However, this is much easier than learning the basics of AutoLayout or RunLoop.  No higher mathematics. </p><br><p>  The library, as well as the implementation of the router provided to it, does not use any tricks with objective runtime and fully follows all the concepts of Cocoa Touch, only helping to break up the composition process into steps and performs them in a predetermined sequence.  Library tested with iOS versions 9 through 12. </p><br><p>  More details can be found in previous articles: <br>  <a href="https://habr.com/ru/post/421097/">Composition of UIViewControllers and navigation between them (and not only) / Habr</a> <br>  <a href="https://habr.com/ru/post/428990/">Configuration examples of UIViewControllers using RouteComposer / Habr</a> </p><br><p>  Thanks for attention.  I am pleased to answer questions in the comments. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/446550/">https://habr.com/ru/post/446550/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446532/index.html">Upwork introduces a fee for the right to write to a potential customer.</a></li>
<li><a href="../446534/index.html">Visual Studio 2019 released</a></li>
<li><a href="../446536/index.html">Queues and JMeter: sharing with Publisher and Subscriber</a></li>
<li><a href="../446538/index.html">PhotoGuru went to the "dark side" and "wiser"</a></li>
<li><a href="../446546/index.html">Microsoft expands Azure IP Advantage with new IP benefits for Azure IoT innovators and startups</a></li>
<li><a href="../446552/index.html">Working with APDU commands using the EToken example</a></li>
<li><a href="../446554/index.html">Resident program of Yandex, or How to become an ML-engineer as an experienced backend</a></li>
<li><a href="../446558/index.html">Exotic data structures: Modified Merkle Patricia Trie</a></li>
<li><a href="../446560/index.html">‚ÄúExchange of courtesies‚Äù: what is the essence of the conflict between the two most famous streaming companies</a></li>
<li><a href="../446562/index.html">Asynchrony in programming</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>