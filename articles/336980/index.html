<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a programming language using LLVM. Part 9: Add Debugging Information</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents: 

 Part 1: Introduction and Lexical Analysis 
 Part 2: Implementing Parser and AST 
 Part 3: LLVM IR Code Generation 
 Part 4: Addi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a programming language using LLVM. Part 9: Add Debugging Information</h1><div class="post__text post__text-html js-mediator-article">  Table of contents: <br><br>  <a href="https://habrahabr.ru/post/119850/">Part 1: Introduction and Lexical Analysis</a> <br>  <a href="https://habrahabr.ru/post/120005/">Part 2: Implementing Parser and AST</a> <br>  <a href="https://habrahabr.ru/post/120424/">Part 3: LLVM IR Code Generation</a> <br>  <a href="https://habrahabr.ru/post/120516/">Part 4: Adding JIT and Optimizer Support</a> <br>  <a href="https://habrahabr.ru/post/120881/">Part 5: Language Expansion: Control Flow</a> <br>  <a href="https://habrahabr.ru/post/336080/">Part 6: Language Extension: User Defined Operators</a> <br>  <a href="https://habrahabr.ru/post/336468/">Part 7: Language Expansion: Variable Variables</a> <br>  <a href="https://habrahabr.ru/post/336876/">Part 8: Compile to Object Code</a> <br>  <b>Part 9: Add Debugging Information</b> <br>  <a href="https://habrahabr.ru/post/337240/">Part 10: Conclusion and other goodies LLVM</a> <br><img src="https://habrastorage.org/web/6e5/879/803/6e58798030874db09d00f2c502b3b104.png"><br><h3>  9.1.  Introduction </h3><br>  Welcome to chapter 9 of the guide ‚ÄúCreating a programming language using LLVM‚Äù.  In chapters 1 through 8, we built a small programming language with functions and variables.  What happens if something goes wrong, then how to debug the program? <br><a name="habracut"></a><br>  Debugging at the source code level uses formatting data, which helps the debugger to translate information from the binary code back to the original, which the programmer wrote.  LLVM typically uses the DWARF format.  DWARF in a compact form encodes types, locations of the source code and locations of variables. <br><br>  A brief summary of this chapter is that we will look at the various things you need to add to a programming language to support debugging information, and how to convert it to DWARF. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Warning: now we can not debug in JIT mode, we will need to compile our program.  We will make a few changes regarding both the work of the language and the compilation.  Now we will have a compile from the source file in the Kaleidoscope language, and not the JIT execution in an interactive mode.  We introduce a restriction in that we will have only one team at the ‚Äútop level‚Äù in order to reduce the number of changes needed. <br><br>  An example of a program that we will compile: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">def </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> x &lt; 3 then 1 </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">else</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">+</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre> <br><h3>  9.2.  Why is this a difficult task? </h3><br>  Turning on debugging information is a difficult task for several reasons - mainly due to code optimization.  First, when optimizing, it is more difficult to save information about code locations.  In LLVM IR, we store the location in the source code for each IR-level instruction.  Optimization passages should maintain locations for newly created commands, but the combination of instructions should save only one location, and this can cause jumps throughout the optimized program.  Second, optimization can move variables in such a way that they can share memory with other variables and are difficult to track.  For this tutorial, we will not use optimization (as you will see below). <br><br><h3>  9.3.  AOT compile mode (Ahead-of-Time Compilation) </h3><br>  We will cover only the aspects of adding debug information to the source language, and we will not worry about the difficulties of debugging in JIT mode, and we will make several changes in the Kaleidoscope to support the compilation of IR generated by the frontend into an independent program that can be executed, debugged, and see the result. <br><br>  First, let's make the anonymous function, which contains the top level of the code, called ‚Äúmain‚Äù: <br><br><pre> <code class="cpp hljs">- <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;()); + <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> Proto = llvm::make_unique&lt;PrototypeAST&gt;(<span class="hljs-string"><span class="hljs-string">"main"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;());</code> </pre><br>  this small change gives the function a name. <br><br>  Then we remove all the command line related code: <br><br><pre> <code class="cpp hljs">@@ <span class="hljs-number"><span class="hljs-number">-1129</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span> +<span class="hljs-number"><span class="hljs-number">1129</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span> @@ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTopLevelExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/// top ::= definition | external | expression | ';' static void MainLoop() { while (1) { - fprintf(stderr, "ready&gt; "); switch (CurTok) { case tok_eof: return; @@ -1184,7 +1183,6 @@ int main() { BinopPrecedence['*'] = 40; //   . //     - fprintf(stderr, "ready&gt; "); getNextToken();</span></span></code> </pre> <br>  And finally, we turn off all optimization passes and JIT, so that only parsing and LLVM IR code generation remain: <br><br><pre> <code class="cpp hljs">@@ <span class="hljs-number"><span class="hljs-number">-1108</span></span>,<span class="hljs-number"><span class="hljs-number">17</span></span> +<span class="hljs-number"><span class="hljs-number">1108</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span> @@ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleExtern</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleTopLevelExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       if (auto FnAST = ParseTopLevelExpr()) { - if (auto *FnIR = FnAST-&gt;codegen()) { - // ,    - TheExecutionEngine-&gt;finalizeObject(); - //    JIT,     - void *FPtr = TheExecutionEngine-&gt;getPointerToFunction(FnIR); - - //     (  ,  double),   - //     . - double (*FP)() = (double (*)())(intptr_t)FPtr; - //   . - (void)FP; + if (!F-&gt;codegen()) { + fprintf(stderr, "Error generating code for top level expr"); } } else { //       @@ -1439,11 +1459,11 @@ int main() { //    TheModule-&gt;setDataLayout(TheExecutionEngine-&gt;getDataLayout()); OurFPM.add(new DataLayoutPass()); +#if 0 OurFPM.add(createBasicAliasAnalysisPass()); //  alloca   OurFPM.add(createPromoteMemoryToRegisterPass()); @@ -1218,7 +1210,7 @@ int main() { OurFPM.add(createGVNPass()); //     (  , ). OurFPM.add(createCFGSimplificationPass()); - + #endif OurFPM.doInitialization();</span></span></code> </pre><br>  This relatively small set of changes takes us to the point where we can compile a piece on the Kaleidoscope into an executable program using the command line: <br><br><pre> <code class="bash hljs">Kaleidoscope-Ch9 &lt; fib.ks | &amp; clang -x ir -</code> </pre><br>  and get a.out / a.exe in the current working directory. <br><br><h3>  9.4.  Compilation unit </h3><br>  The top-level container for the code section in DWARF is the compile unit. <br>  It contains data on types and functions for a separate broadcast module (that is, a single broadcast module file).  And the first thing we need is to build such a unit for our fib.ks file. <br><br><h3>  9.5.  Setting DWARF generation </h3><br>  Similar to the IRBuilder class, there is a DIBuilder class that helps to construct metadata for the LLVM IR file.  It is 1: 1 compliant with IRBuilder and LLVM IR.  Using it requires you to be more familiar with DWARF terminology than IRBuilder needed instruction names, but if you read the metadata format documentation, then everything will become clearer.  We will use this class to construct all the descriptions of the IR level.  Their construction occurs immediately after we have built the module object.  All these descriptions are constructed as global static variables, because it is easier to use them this way. <br><br>  Then we will create a small container to cache some commonly used objects.  The first will be our compilation unit, we will also write the code for our only type, and we will not worry about expressions that have different types: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DIBuilder *DBuilder; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DebugInfo</span></span></span><span class="hljs-class"> {</span></span> DICompileUnit *TheCU; DIType *DblTy; <span class="hljs-function"><span class="hljs-function">DIType *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getDoubleTy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } KSDbgInfo; DIType *DebugInfo::getDoubleTy() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DblTy) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DblTy; DblTy = DBuilder-&gt;createBasicType(<span class="hljs-string"><span class="hljs-string">"double"</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, <span class="hljs-number"><span class="hljs-number">64</span></span>, dwarf::DW_ATE_float); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DblTy; }</code> </pre> <br>  And then, further in the main function, we create a module: <br><br><pre> <code class="cpp hljs">DBuilder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DIBuilder(*TheModule); KSDbgInfo.TheCU = DBuilder-&gt;createCompileUnit( dwarf::DW_LANG_C, <span class="hljs-string"><span class="hljs-string">"fib.ks"</span></span>, <span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">"Kaleidoscope Compiler"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Here you need to note a few things.  First, although we create a compilation unit for the language namned by the Kaleidoscope, we use the C language constant. This is because the debugger does not have to understand the calling convention or ABI for languages ‚Äã‚Äãit does not recognize, and we follow C ABI in our generator code.  In this case, we can be sure that we are calling the function from the debugger and it will execute.  Secondly, you see ‚Äúfib.ks‚Äù in the call to createCompileUnit.  This is the default value, since we use shell redirection to get our source code into the Kaleidoscope compiler.  In a normal frontend, you would have the name of the input file in this place. <br><br>  And the last thing regarding generation of debug information through DIBuilder is that we need to ‚Äúfinalize‚Äù the debug information.  The reason for this lies in the DIBuilder API, and we need to do this near the end of the main function: <br><br><pre> <code class="cpp hljs">DBuilder-&gt;finalize();</code> </pre> <br>  before we dump the module. <br><br><h3>  9.6.  Functions </h3><br>  Now we have our compilation unit and our source code locations, and we can add function definitions to debug information.  In PrototypeAST :: codegen () we add a few lines of code to describe the context of our subroutine, in this case ‚ÄúFile‚Äù, and the actual definition of the function itself. <br><br>  So, the context: <br><br><pre> <code class="cpp hljs">DIFile *Unit = DBuilder-&gt;createFile(KSDbgInfo.TheCU.getFilename(), KSDbgInfo.TheCU.getDirectory());</code> </pre> <br>  gives us a DIFile, and requesting the compilation unit we created above for the directory and file name where we are at the moment.  Then, we use the source code locations for zero (since our AST does not yet have information about the code locations), and construct our function definition: <br><br><pre> <code class="cpp hljs">DIScope *FContext = Unit; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> LineNo = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> ScopeLine = <span class="hljs-number"><span class="hljs-number">0</span></span>; DISubprogram *SP = DBuilder-&gt;createFunction( FContext, P.getName(), StringRef(), Unit, LineNo, CreateFunctionType(TheFunction-&gt;arg_size(), Unit), <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">/* internal linkage */</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-comment"><span class="hljs-comment">/* definition */</span></span>, ScopeLine, DINode::FlagPrototyped, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); TheFunction-&gt;setSubprogram(SP);</code> </pre> <br>  and we now have a DISubprogram containing a link to all our metadata for the function. <br><br><h3>  9.7.  Source Locations </h3><br>  The most important thing for debugging information is the accuracy of the source code locations, it allows you to find a place in the source code in reverse.  Now our problem is that the Kaleidoscope does not have any information about the source locations in the lexical analyzer and in the parser, and we have to add it. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SourceLocation</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Line; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Col; }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SourceLocation CurLoc; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> SourceLocation LexLoc = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">advance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LastChar = getchar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LastChar == <span class="hljs-string"><span class="hljs-string">'\n'</span></span> || LastChar == <span class="hljs-string"><span class="hljs-string">'\r'</span></span>) { LexLoc.Line++; LexLoc.Col = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> LexLoc.Col++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LastChar; }</code> </pre> <br>  In this piece of code, we add functionality that keeps track of the row and column of the source file.  As each tokenam is parsed, we set our ‚Äúlexical location‚Äù into the corresponding row and column for the start of the token.  We do this by replacing all getchar () calls with a new advance () function that tracks information and then we add the source text location to all our AST classes. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExprAST</span></span></span><span class="hljs-class"> {</span></span> SourceLocation Loc; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ExprAST(SourceLocation Loc = CurLoc) : Loc(Loc) {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~ExprAST() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Value* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">codegen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Loc.Line; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCol</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Loc.Col; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> raw_ostream &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(raw_ostream &amp;out, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ind)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> out &lt;&lt; <span class="hljs-string"><span class="hljs-string">':'</span></span> &lt;&lt; getLine() &lt;&lt; <span class="hljs-string"><span class="hljs-string">':'</span></span> &lt;&lt; getCol() &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }</code> </pre> <br>  and we transfer these locations when we create a new expression: <br><br><pre> <code class="cpp hljs">LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinLoc, BinOp, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(LHS), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(RHS));</code> </pre><br>  and locations are assigned to each expression and variable. <br><br>  In order to make sure that each instruction received the correct location information, we need to tell the Builder object whether we are in the new source text location.  For this we use a small helper function. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> DebugInfo::emitLocation(ExprAST *AST) { DIScope *Scope; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (LexicalBlocks.empty()) Scope = TheCU; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> Scope = LexicalBlocks.back(); Builder.SetCurrentDebugLocation( DebugLoc::get(AST-&gt;getLine(), AST-&gt;getCol(), Scope)); }</code> </pre> <br>  This tells the IRBuilder object where we are, as well as what area of ‚Äã‚Äãvisibility.  The scope can be either a compilation unit level or the nearest surrounding lexical unit, for example, the current function.  To present this, create a scopes stack: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;DIScope *&gt; LexicalBlocks;</code> </pre> <br>  and put the scope (function) at the top of the stack when we start generating code for each function: <br><br><pre> <code class="cpp hljs">KSDbgInfo.LexicalBlocks.push_back(SP);</code> </pre> <br>  Also, we should not forget to remove the scope from the stack at the end of the code generation for the function: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        KSDbgInfo.LexicalBlocks.pop_back();</span></span></code> </pre><br>  Then we make sure that we generated a location every time we start generating code for a new AST object: <br><br><pre> <code class="cpp hljs">KSDbgInfo.emitLocation(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);</code> </pre> <br><h3>  9.8.  Variables </h3><br>  We now have functions, and we need the ability to display variables in scope.  Let's take a set of arguments to our function, and make it so that we can trace and see how the function was called.  Here is a bit of code, and we perform all the actions when we create allocations of arguments in FunctionAST :: codegen. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     map NamedValues. NamedValues.clear(); unsigned ArgIdx = 0; for (auto &amp;Arg : TheFunction-&gt;args()) { //  alloca   AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName()); //      DILocalVariable *D = DBuilder-&gt;createParameterVariable( SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(), true); DBuilder-&gt;insertDeclare(Alloca, D, DBuilder-&gt;createExpression(), DebugLoc::get(LineNo, 0, SP), Builder.GetInsertBlock()); //     alloca. Builder.CreateStore(&amp;Arg, Alloca); //      NamedValues[Arg.getName()] = Alloca; }</span></span></code> </pre> <br>  Here we create a variable for the first time, assign it a scope (SP), name, location of source code, type, and, if it is an argument, the index of the argument.  Then we create a call to lvm.dbg.declare to show at the IR level that we have a variable in alloca (and set the starting location for the variable), and set the location of the source text to start the scope. <br><br>  One interesting thing to note here is that various debuggers make various assumptions about how the code and debugging information was generated for them.  In this case, we need to make some small hack in order not to generate information for the function prologue, so that the debugger will skip these instructions when setting a breakpoint.  We add several lines to FunctionAST :: CodeGen: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      (   //     ,   //        KSDbgInfo.emitLocation(nullptr);</span></span></code> </pre> <br>  and then generate a new location when we actually start generating code for the function body: <br><br><pre> <code class="cpp hljs">KSDbgInfo.emitLocation(Body.get());</code> </pre> <br>  Now we have enough debug information to set a breakpoint in the function, display the function's argument variables and call the function.  Not bad for just a few lines of code! <br><br><h3>  9.9.  Full code listing </h3><br>  Below is a complete listing of the code for our working example, extended debug information.  To compile an example, run: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#  clang++ -g toy.cpp `llvm-config --cxxflags --ldflags --system-libs --libs core mcjit native` -O3 -o toy #  ./toy</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Full code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ADT/STLExtras.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Analysis/BasicAliasAnalysis.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Analysis/Passes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/DIBuilder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/IRBuilder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/LLVMContext.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/LegacyPassManager.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Module.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/IR/Verifier.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/TargetSelect.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Transforms/Scalar.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cctype&gt; #include &lt;cstdio&gt; #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; #include "../include/KaleidoscopeJIT.h" using namespace llvm; using namespace llvm::orc; //===----------------------------------------------------------------------===// //   //===----------------------------------------------------------------------===// //     [0-255]    ,    //  enum Token { tok_eof = -1, //  tok_def = -2, tok_extern = -3, //   tok_identifier = -4, tok_number = -5, //  tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10, //  tok_binary = -11, tok_unary = -12, //   tok_var = -13 }; std::string getTokName(int Tok) { switch (Tok) { case tok_eof: return "eof"; case tok_def: return "def"; case tok_extern: return "extern"; case tok_identifier: return "identifier"; case tok_number: return "number"; case tok_if: return "if"; case tok_then: return "then"; case tok_else: return "else"; case tok_for: return "for"; case tok_in: return "in"; case tok_binary: return "binary"; case tok_unary: return "unary"; case tok_var: return "var"; } return std::string(1, (char)Tok); } namespace { class PrototypeAST; class ExprAST; } static LLVMContext TheContext; static IRBuilder&lt;&gt; Builder(TheContext); struct DebugInfo { DICompileUnit *TheCU; DIType *DblTy; std::vector&lt;DIScope *&gt; LexicalBlocks; void emitLocation(ExprAST *AST); DIType *getDoubleTy(); } KSDbgInfo; struct SourceLocation { int Line; int Col; }; static SourceLocation CurLoc; static SourceLocation LexLoc = {1, 0}; static int advance() { int LastChar = getchar(); if (LastChar == '\n' || LastChar == '\r') { LexLoc.Line++; LexLoc.Col = 0; } else LexLoc.Col++; return LastChar; } static std::string IdentifierStr; //   tok_identifier static double NumVal; //   tok_number /// gettok -       static int gettok() { static int LastChar = ' '; //   while (isspace(LastChar)) LastChar = advance(); CurLoc = LexLoc; if (isalpha(LastChar)) { // : [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = advance()))) IdentifierStr += LastChar; if (IdentifierStr == "def") return tok_def; if (IdentifierStr == "extern") return tok_extern; if (IdentifierStr == "if") return tok_if; if (IdentifierStr == "then") return tok_then; if (IdentifierStr == "else") return tok_else; if (IdentifierStr == "for") return tok_for; if (IdentifierStr == "in") return tok_in; if (IdentifierStr == "binary") return tok_binary; if (IdentifierStr == "unary") return tok_unary; if (IdentifierStr == "var") return tok_var; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // : [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = advance(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), nullptr); return tok_number; } if (LastChar == '#') { //     do LastChar = advance(); while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r'); if (LastChar != EOF) return gettok(); } //   .   EOF. if (LastChar == EOF) return tok_eof; // ,     ascii-. int ThisChar = LastChar; LastChar = advance(); return ThisChar; } //===----------------------------------------------------------------------===// //    ( ) //===----------------------------------------------------------------------===// namespace { raw_ostream &amp;indent(raw_ostream &amp;O, int size) { return O &lt;&lt; std::string(size, ' '); } /// ExprAST -    . class ExprAST { SourceLocation Loc; public: ExprAST(SourceLocation Loc = CurLoc) : Loc(Loc) {} virtual ~ExprAST() {} virtual Value *codegen() = 0; int getLine() const { return Loc.Line; } int getCol() const { return Loc.Col; } virtual raw_ostream &amp;dump(raw_ostream &amp;out, int ind) { return out &lt;&lt; ':' &lt;&lt; getLine() &lt;&lt; ':' &lt;&lt; getCol() &lt;&lt; '\n'; } }; /// NumberExprAST -      "1.0". class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double Val) : Val(Val) {} raw_ostream &amp;dump(raw_ostream &amp;out, int ind) override { return ExprAST::dump(out &lt;&lt; Val, ind); } Value *codegen() override; }; /// VariableExprAST -    , , "a". class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(SourceLocation Loc, const std::string &amp;Name) : ExprAST(Loc), Name(Name) {} const std::string &amp;getName() const { return Name; } Value *codegen() override; raw_ostream &amp;dump(raw_ostream &amp;out, int ind) override { return ExprAST::dump(out &lt;&lt; Name, ind); } }; /// UnaryExprAST -      class UnaryExprAST : public ExprAST { char Opcode; std::unique_ptr&lt;ExprAST&gt; Operand; public: UnaryExprAST(char Opcode, std::unique_ptr&lt;ExprAST&gt; Operand) : Opcode(Opcode), Operand(std::move(Operand)) {} Value *codegen() override; raw_ostream &amp;dump(raw_ostream &amp;out, int ind) override { ExprAST::dump(out &lt;&lt; "unary" &lt;&lt; Opcode, ind); Operand-&gt;dump(out, ind + 1); return out; } }; /// BinaryExprAST -      class BinaryExprAST : public ExprAST { char Op; std::unique_ptr&lt;ExprAST&gt; LHS, RHS; public: BinaryExprAST(SourceLocation Loc, char Op, std::unique_ptr&lt;ExprAST&gt; LHS, std::unique_ptr&lt;ExprAST&gt; RHS) : ExprAST(Loc), Op(Op), LHS(std::move(LHS)), RHS(std::move(RHS)) {} Value *codegen() override; raw_ostream &amp;dump(raw_ostream &amp;out, int ind) override { ExprAST::dump(out &lt;&lt; "binary" &lt;&lt; Op, ind); LHS-&gt;dump(indent(out, ind) &lt;&lt; "LHS:", ind + 1); RHS-&gt;dump(indent(out, ind) &lt;&lt; "RHS:", ind + 1); return out; } }; /// CallExprAST -      class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args; public: CallExprAST(SourceLocation Loc, const std::string &amp;Callee, std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args) : ExprAST(Loc), Callee(Callee), Args(std::move(Args)) {} Value *codegen() override; raw_ostream &amp;dump(raw_ostream &amp;out, int ind) override { ExprAST::dump(out &lt;&lt; "call " &lt;&lt; Callee, ind); for (const auto &amp;Arg : Args) Arg-&gt;dump(indent(out, ind + 1), ind + 1); return out; } }; /// IfExprAST -    if/then/else. class IfExprAST : public ExprAST { std::unique_ptr&lt;ExprAST&gt; Cond, Then, Else; public: IfExprAST(SourceLocation Loc, std::unique_ptr&lt;ExprAST&gt; Cond, std::unique_ptr&lt;ExprAST&gt; Then, std::unique_ptr&lt;ExprAST&gt; Else) : ExprAST(Loc), Cond(std::move(Cond)), Then(std::move(Then)), Else(std::move(Else)) {} Value *codegen() override; raw_ostream &amp;dump(raw_ostream &amp;out, int ind) override { ExprAST::dump(out &lt;&lt; "if", ind); Cond-&gt;dump(indent(out, ind) &lt;&lt; "Cond:", ind + 1); Then-&gt;dump(indent(out, ind) &lt;&lt; "Then:", ind + 1); Else-&gt;dump(indent(out, ind) &lt;&lt; "Else:", ind + 1); return out; } }; /// ForExprAST -    for/in. class ForExprAST : public ExprAST { std::string VarName; std::unique_ptr&lt;ExprAST&gt; Start, End, Step, Body; public: ForExprAST(const std::string &amp;VarName, std::unique_ptr&lt;ExprAST&gt; Start, std::unique_ptr&lt;ExprAST&gt; End, std::unique_ptr&lt;ExprAST&gt; Step, std::unique_ptr&lt;ExprAST&gt; Body) : VarName(VarName), Start(std::move(Start)), End(std::move(End)), Step(std::move(Step)), Body(std::move(Body)) {} Value *codegen() override; raw_ostream &amp;dump(raw_ostream &amp;out, int ind) override { ExprAST::dump(out &lt;&lt; "for", ind); Start-&gt;dump(indent(out, ind) &lt;&lt; "Cond:", ind + 1); End-&gt;dump(indent(out, ind) &lt;&lt; "End:", ind + 1); Step-&gt;dump(indent(out, ind) &lt;&lt; "Step:", ind + 1); Body-&gt;dump(indent(out, ind) &lt;&lt; "Body:", ind + 1); return out; } }; /// VarExprAST -    var/in class VarExprAST : public ExprAST { std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames; std::unique_ptr&lt;ExprAST&gt; Body; public: VarExprAST( std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames, std::unique_ptr&lt;ExprAST&gt; Body) : VarNames(std::move(VarNames)), Body(std::move(Body)) {} Value *codegen() override; raw_ostream &amp;dump(raw_ostream &amp;out, int ind) override { ExprAST::dump(out &lt;&lt; "var", ind); for (const auto &amp;NamedVar : VarNames) NamedVar.second-&gt;dump(indent(out, ind) &lt;&lt; NamedVar.first &lt;&lt; ':', ind + 1); Body-&gt;dump(indent(out, ind) &lt;&lt; "Body:", ind + 1); return out; } }; /// PrototypeAST -    "" , ///    ,    (, ,  /// ,  ),   . class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; bool IsOperator; unsigned Precedence; //     int Line; public: PrototypeAST(SourceLocation Loc, const std::string &amp;Name, std::vector&lt;std::string&gt; Args, bool IsOperator = false, unsigned Prec = 0) : Name(Name), Args(std::move(Args)), IsOperator(IsOperator), Precedence(Prec), Line(Loc.Line) {} Function *codegen(); const std::string &amp;getName() const { return Name; } bool isUnaryOp() const { return IsOperator &amp;&amp; Args.size() == 1; } bool isBinaryOp() const { return IsOperator &amp;&amp; Args.size() == 2; } char getOperatorName() const { assert(isUnaryOp() || isBinaryOp()); return Name[Name.size() - 1]; } unsigned getBinaryPrecedence() const { return Precedence; } int getLine() const { return Line; } }; /// FunctionAST -      class FunctionAST { std::unique_ptr&lt;PrototypeAST&gt; Proto; std::unique_ptr&lt;ExprAST&gt; Body; public: FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto, std::unique_ptr&lt;ExprAST&gt; Body) : Proto(std::move(Proto)), Body(std::move(Body)) {} Function *codegen(); raw_ostream &amp;dump(raw_ostream &amp;out, int ind) { indent(out, ind) &lt;&lt; "FunctionAST\n"; ++ind; indent(out, ind) &lt;&lt; "Body:"; return Body ? Body-&gt;dump(out, ind) : out &lt;&lt; "null\n"; } }; } //     //===----------------------------------------------------------------------===// //  //===----------------------------------------------------------------------===// /// CurTok/getNextToken -    . CurTok -  /// ,    . getNextToken     ///     CurTok  . static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence -     , ///   static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -       . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } /// LogError* -     . std::unique_ptr&lt;ExprAST&gt; LogError(const char *Str) { fprintf(stderr, "Error: %s\n", Str); return nullptr; } std::unique_ptr&lt;PrototypeAST&gt; LogErrorP(const char *Str) { LogError(Str); return nullptr; } static std::unique_ptr&lt;ExprAST&gt; ParseExpression(); /// numberexpr ::= number static std::unique_ptr&lt;ExprAST&gt; ParseNumberExpr() { auto Result = llvm::make_unique&lt;NumberExprAST&gt;(NumVal); getNextToken(); //   return std::move(Result); } /// parenexpr ::= '(' expression ')' static std::unique_ptr&lt;ExprAST&gt; ParseParenExpr() { getNextToken(); //  (. auto V = ParseExpression(); if (!V) return nullptr; if (CurTok != ')') return LogError("expected ')'"); getNextToken(); //  ). return V; } /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static std::unique_ptr&lt;ExprAST&gt; ParseIdentifierExpr() { std::string IdName = IdentifierStr; SourceLocation LitLoc = CurLoc; getNextToken(); //  . if (CurTok != '(') //    . return llvm::make_unique&lt;VariableExprAST&gt;(LitLoc, IdName); // Call. getNextToken(); //  ( std::vector&lt;std::unique_ptr&lt;ExprAST&gt;&gt; Args; if (CurTok != ')') { while (1) { if (auto Arg = ParseExpression()) Args.push_back(std::move(Arg)); else return nullptr; if (CurTok == ')') break; if (CurTok != ',') return LogError("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return llvm::make_unique&lt;CallExprAST&gt;(LitLoc, IdName, std::move(Args)); } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static std::unique_ptr&lt;ExprAST&gt; ParseIfExpr() { SourceLocation IfLoc = CurLoc; getNextToken(); //  if. // . auto Cond = ParseExpression(); if (!Cond) return nullptr; if (CurTok != tok_then) return LogError("expected then"); getNextToken(); //  then auto Then = ParseExpression(); if (!Then) return nullptr; if (CurTok != tok_else) return LogError("expected else"); getNextToken(); auto Else = ParseExpression(); if (!Else) return nullptr; return llvm::make_unique&lt;IfExprAST&gt;(IfLoc, std::move(Cond), std::move(Then), std::move(Else)); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static std::unique_ptr&lt;ExprAST&gt; ParseForExpr() { getNextToken(); //  for. if (CurTok != tok_identifier) return LogError("expected identifier after for"); std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '=') return LogError("expected '=' after for"); getNextToken(); //  '='. auto Start = ParseExpression(); if (!Start) return nullptr; if (CurTok != ',') return LogError("expected ',' after for start value"); getNextToken(); auto End = ParseExpression(); if (!End) return nullptr; //   . std::unique_ptr&lt;ExprAST&gt; Step; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (!Step) return nullptr; } if (CurTok != tok_in) return LogError("expected 'in' after for"); getNextToken(); //  'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return llvm::make_unique&lt;ForExprAST&gt;(IdName, std::move(Start), std::move(End), std::move(Step), std::move(Body)); } /// varexpr ::= 'var' identifier ('=' expression)? // (',' identifier ('=' expression)?)* 'in' expression static std::unique_ptr&lt;ExprAST&gt; ParseVarExpr() { getNextToken(); //  var. std::vector&lt;std::pair&lt;std::string, std::unique_ptr&lt;ExprAST&gt;&gt;&gt; VarNames; //      if (CurTok != tok_identifier) return LogError("expected identifier after var"); while (1) { std::string Name = IdentifierStr; getNextToken(); //  .. //    std::unique_ptr&lt;ExprAST&gt; Init = nullptr; if (CurTok == '=') { getNextToken(); //  '='. Init = ParseExpression(); if (!Init) return nullptr; } VarNames.push_back(std::make_pair(Name, std::move(Init))); //   ,   . if (CurTok != ',') break; getNextToken(); //  ','. if (CurTok != tok_identifier) return LogError("expected identifier list after var"); } //        'in'. if (CurTok != tok_in) return LogError("expected 'in' keyword after 'var'"); getNextToken(); //  'in'. auto Body = ParseExpression(); if (!Body) return nullptr; return llvm::make_unique&lt;VarExprAST&gt;(std::move(VarNames), std::move(Body)); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr /// ::= varexpr static std::unique_ptr&lt;ExprAST&gt; ParsePrimary() { switch (CurTok) { default: return LogError("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); case tok_var: return ParseVarExpr(); } } /// unary /// ::= primary /// ::= '!' unary static std::unique_ptr&lt;ExprAST&gt; ParseUnary() { //      ,     . if (!isascii(CurTok) || CurTok == '(' || CurTok == ',') return ParsePrimary(); //    ,   int Opc = CurTok; getNextToken(); if (auto Operand = ParseUnary()) return llvm::make_unique&lt;UnaryExprAST&gt;(Opc, std::move(Operand)); return nullptr; } /// binoprhs /// ::= ('+' unary)* static std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(int ExprPrec, std::unique_ptr&lt;ExprAST&gt; LHS) { //    ,    while (1) { int TokPrec = GetTokPrecedence(); //    ,    //  ,   if (TokPrec &lt; ExprPrec) return LHS; //   ,     int BinOp = CurTok; SourceLocation BinLoc = CurLoc; getNextToken(); //    //       auto RHS = ParseUnary(); if (!RHS) return nullptr; //  BinOp    RHS,    RHS,  //    RHS   LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS)); if (!RHS) return nullptr; } //  LHS/RHS. LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinLoc, BinOp, std::move(LHS), std::move(RHS)); } } /// expression /// ::= unary binoprhs /// static std::unique_ptr&lt;ExprAST&gt; ParseExpression() { auto LHS = ParseUnary(); if (!LHS) return nullptr; return ParseBinOpRHS(0, std::move(LHS)); } /// prototype /// ::= id '(' id* ')' /// ::= binary LETTER number? (id, id) /// ::= unary LETTER (id) static std::unique_ptr&lt;PrototypeAST&gt; ParsePrototype() { std::string FnName; SourceLocation FnLoc = CurLoc; unsigned Kind = 0; // 0 = , 1 = , 2 = . unsigned BinaryPrecedence = 30; switch (CurTok) { default: return LogErrorP("Expected function name in prototype"); case tok_identifier: FnName = IdentifierStr; Kind = 0; getNextToken(); break; case tok_unary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected unary operator"); FnName = "unary"; FnName += (char)CurTok; Kind = 1; getNextToken(); break; case tok_binary: getNextToken(); if (!isascii(CurTok)) return LogErrorP("Expected binary operator"); FnName = "binary"; FnName += (char)CurTok; Kind = 2; getNextToken(); //  ,    if (CurTok == tok_number) { if (NumVal &lt; 1 || NumVal &gt; 100) return LogErrorP("Invalid precedence: must be 1..100"); BinaryPrecedence = (unsigned)NumVal; getNextToken(); } break; } if (CurTok != '(') return LogErrorP("Expected '(' in prototype"); std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return LogErrorP("Expected ')' in prototype"); // . getNextToken(); //  ')'. // ,     if (Kind &amp;&amp; ArgNames.size() != Kind) return LogErrorP("Invalid number of operands for operator"); return llvm::make_unique&lt;PrototypeAST&gt;(FnLoc, FnName, ArgNames, Kind != 0, BinaryPrecedence); } /// definition ::= 'def' prototype expression static std::unique_ptr&lt;FunctionAST&gt; ParseDefinition() { getNextToken(); //  def. auto Proto = ParsePrototype(); if (!Proto) return nullptr; if (auto E = ParseExpression()) return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E)); return nullptr; } /// toplevelexpr ::= expression static std::unique_ptr&lt;FunctionAST&gt; ParseTopLevelExpr() { SourceLocation FnLoc = CurLoc; if (auto E = ParseExpression()) { //    auto Proto = llvm::make_unique&lt;PrototypeAST&gt;(FnLoc, "__anon_expr", std::vector&lt;std::string&gt;()); return llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(E)); } return nullptr; } /// external ::= 'extern' prototype static std::unique_ptr&lt;PrototypeAST&gt; ParseExtern() { getNextToken(); // eat extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// //    //===----------------------------------------------------------------------===// static std::unique_ptr&lt;DIBuilder&gt; DBuilder; DIType *DebugInfo::getDoubleTy() { if (DblTy) return DblTy; DblTy = DBuilder-&gt;createBasicType("double", 64, 64, dwarf::DW_ATE_float); return DblTy; } void DebugInfo::emitLocation(ExprAST *AST) { if (!AST) return Builder.SetCurrentDebugLocation(DebugLoc()); DIScope *Scope; if (LexicalBlocks.empty()) Scope = TheCU; else Scope = LexicalBlocks.back(); Builder.SetCurrentDebugLocation( DebugLoc::get(AST-&gt;getLine(), AST-&gt;getCol(), Scope)); } static DISubroutineType *CreateFunctionType(unsigned NumArgs, DIFile *Unit) { SmallVector&lt;Metadata *, 8&gt; EltTys; DIType *DblTy = KSDbgInfo.getDoubleTy(); //    EltTys.push_back(DblTy); for (unsigned i = 0, e = NumArgs; i != e; ++i) EltTys.push_back(DblTy); return DBuilder-&gt;createSubroutineType(DBuilder-&gt;getOrCreateTypeArray(EltTys)); } //===----------------------------------------------------------------------===// //   //===----------------------------------------------------------------------===// static std::unique_ptr&lt;Module&gt; TheModule; static std::map&lt;std::string, AllocaInst *&gt; NamedValues; static std::unique_ptr&lt;KaleidoscopeJIT&gt; TheJIT; static std::map&lt;std::string, std::unique_ptr&lt;PrototypeAST&gt;&gt; FunctionProtos; Value *LogErrorV(const char *Str) { LogError(Str); return nullptr; } Function *getFunction(std::string Name) { //  ,       . if (auto *F = TheModule-&gt;getFunction(Name)) return F; //  ,         // . auto FI = FunctionProtos.find(Name); if (FI != FunctionProtos.end()) return FI-&gt;second-&gt;codegen(); //    ,  null. return nullptr; } /// CreateEntryBlockAlloca -   alloca    /// .     . static AllocaInst *CreateEntryBlockAlloca(Function *TheFunction, const std::string &amp;VarName) { IRBuilder&lt;&gt; TmpB(&amp;TheFunction-&gt;getEntryBlock(), TheFunction-&gt;getEntryBlock().begin()); return TmpB.CreateAlloca(Type::getDoubleTy(TheContext), nullptr, VarName.c_str()); } Value *NumberExprAST::codegen() { KSDbgInfo.emitLocation(this); return ConstantFP::get(TheContext, APFloat(Val)); } Value *VariableExprAST::codegen() { // ,       Value *V = NamedValues[Name]; if (!V) return LogErrorV("Unknown variable name"); KSDbgInfo.emitLocation(this); //   return Builder.CreateLoad(V, Name.c_str()); } Value *UnaryExprAST::codegen() { Value *OperandV = Operand-&gt;codegen(); if (!OperandV) return nullptr; Function *F = getFunction(std::string("unary") + Opcode); if (!F) return LogErrorV("Unknown unary operator"); KSDbgInfo.emitLocation(this); return Builder.CreateCall(F, OperandV, "unop"); } Value *BinaryExprAST::codegen() { KSDbgInfo.emitLocation(this); //    '=', ..     LHS   if (Op == '=') { //  ,  LHS   // ,     RTTI, .. LLVM   //  .    LLVM  RTTI     // dynamic_cast    . VariableExprAST *LHSE = static_cast&lt;VariableExprAST *&gt;(LHS.get()); if (!LHSE) return LogErrorV("destination of '=' must be a variable"); //   RHS. Value *Val = RHS-&gt;codegen(); if (!Val) return nullptr; //   Value *Variable = NamedValues[LHSE-&gt;getName()]; if (!Variable) return LogErrorV("Unknown variable name"); Builder.CreateStore(Val, Variable); return Val; } Value *L = LHS-&gt;codegen(); Value *R = RHS-&gt;codegen(); if (!L || !R) return nullptr; switch (Op) { case '+': return Builder.CreateFAdd(L, R, "addtmp"); case '-': return Builder.CreateFSub(L, R, "subtmp"); case '*': return Builder.CreateFMul(L, R, "multmp"); case '&lt;': L = Builder.CreateFCmpULT(L, R, "cmptmp"); //  bool 0/1  double 0.0 or 1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(TheContext), "booltmp"); default: break; } //      ,     .  //    . Function *F = getFunction(std::string("binary") + Op); assert(F &amp;&amp; "binary operator not found!"); Value *Ops[] = {L, R}; return Builder.CreateCall(F, Ops, "binop"); } Value *CallExprAST::codegen() { KSDbgInfo.emitLocation(this); //       Function *CalleeF = getFunction(Callee); if (!CalleeF) return LogErrorV("Unknown function referenced"); // ,    . if (CalleeF-&gt;arg_size() != Args.size()) return LogErrorV("Incorrect # arguments passed"); std::vector&lt;Value *&gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-&gt;codegen()); if (!ArgsV.back()) return nullptr; } return Builder.CreateCall(CalleeF, ArgsV, "calltmp"); } Value *IfExprAST::codegen() { KSDbgInfo.emitLocation(this); Value *CondV = Cond-&gt;codegen(); if (!CondV) return nullptr; //          0.0. CondV = Builder.CreateFCmpONE( CondV, ConstantFP::get(TheContext, APFloat(0.0)), "ifcond"); Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //    then  else.   'then'  //   BasicBlock *ThenBB = BasicBlock::Create(TheContext, "then", TheFunction); BasicBlock *ElseBB = BasicBlock::Create(TheContext, "else"); BasicBlock *MergeBB = BasicBlock::Create(TheContext, "ifcont"); Builder.CreateCondBr(CondV, ThenBB, ElseBB); //  . Builder.SetInsertPoint(ThenBB); Value *ThenV = Then-&gt;codegen(); if (!ThenV) return nullptr; Builder.CreateBr(MergeBB); //    'Then'    ,  ThenBB  PHI. ThenBB = Builder.GetInsertBlock(); //   "else" TheFunction-&gt;getBasicBlockList().push_back(ElseBB); Builder.SetInsertPoint(ElseBB); Value *ElseV = Else-&gt;codegen(); if (!ElseV) return nullptr; Builder.CreateBr(MergeBB); //    'Else'    ,  ElseBB  PHI. ElseBB = Builder.GetInsertBlock(); //    TheFunction-&gt;getBasicBlockList().push_back(MergeBB); Builder.SetInsertPoint(MergeBB); PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(TheContext), 2, "iftmp"); PN-&gt;addIncoming(ThenV, ThenBB); PN-&gt;addIncoming(ElseV, ElseBB); return PN; } //  for-loop : // var = alloca double // ... // start = startexpr // store start -&gt; var // goto loop // loop: // ... // bodyexpr // ... // loopend: // step = stepexpr // endcond = endexpr // // curvar = load var // nextvar = curvar + step // store nextvar -&gt; var // br endcond, loop, endloop // outloop: Value *ForExprAST::codegen() { Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //   alloca      AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); KSDbgInfo.emitLocation(this); //    ,  'variable'    Value *StartVal = Start-&gt;codegen(); if (!StartVal) return nullptr; //    alloca. Builder.CreateStore(StartVal, Alloca); //       ,     // . BasicBlock *LoopBB = BasicBlock::Create(TheContext, "loop", TheFunction); //        LoopBB. Builder.CreateBr(LoopBB); //    LoopBB. Builder.SetInsertPoint(LoopBB); //  ,    PHI-.   //   ,    ,   . AllocaInst *OldVal = NamedValues[VarName]; NamedValues[VarName] = Alloca; //   . ,    ,   //  BB. ,    ,   ,   //  . if (!Body-&gt;codegen()) return nullptr; //    Value *StepVal = nullptr; if (Step) { StepVal = Step-&gt;codegen(); if (!StepVal) return nullptr; } else { //   ,  1.0. StepVal = ConstantFP::get(TheContext, APFloat(1.0)); } //    Value *EndCond = End-&gt;codegen(); if (!EndCond) return nullptr; // , ,   alloca.   //        Value *CurVar = Builder.CreateLoad(Alloca, VarName.c_str()); Value *NextVar = Builder.CreateFAdd(CurVar, StepVal, "nextvar"); Builder.CreateStore(NextVar, Alloca); //          0.0. EndCond = Builder.CreateFCmpONE( EndCond, ConstantFP::get(TheContext, APFloat(0.0)), "loopcond"); //   " "    BasicBlock *AfterBB = BasicBlock::Create(TheContext, "afterloop", TheFunction); //      LoopEndBB. Builder.CreateCondBr(EndCond, LoopBB, AfterBB); //       AfterBB. Builder.SetInsertPoint(AfterBB); //    . if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); //    0.0. return Constant::getNullValue(Type::getDoubleTy(TheContext)); } Value *VarExprAST::codegen() { std::vector&lt;AllocaInst *&gt; OldBindings; Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //       for (unsigned i = 0, e = VarNames.size(); i != e; ++i) { const std::string &amp;VarName = VarNames[i].first; ExprAST *Init = VarNames[i].second.get(); //     ,   //      ,   // l  : // var a = 1 in // var a = a in ... #    'a'. Value *InitVal; if (Init) { InitVal = Init-&gt;codegen(); if (!InitVal) return nullptr; } else { //    ,  0.0. InitVal = ConstantFP::get(TheContext, APFloat(0.0)); } AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, VarName); Builder.CreateStore(InitVal, Alloca); //    OldBindings.push_back(NamedValues[VarName]); //   NamedValues[VarName] = Alloca; } KSDbgInfo.emitLocation(this); //       Value *BodyVal = Body-&gt;codegen(); if (!BodyVal) return nullptr; //    for (unsigned i = 0, e = VarNames.size(); i != e; ++i) NamedValues[VarNames[i].first] = OldBindings[i]; //     return BodyVal; } Function *PrototypeAST::codegen() { //   : double(double,double) etc. std::vector&lt;Type *&gt; Doubles(Args.size(), Type::getDoubleTy(TheContext)); FunctionType *FT = FunctionType::get(Type::getDoubleTy(TheContext), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule.get()); //    unsigned Idx = 0; for (auto &amp;Arg : F-&gt;args()) Arg.setName(Args[Idx++]); return F; } Function *FunctionAST::codegen() { //      FunctionProtos,   //    . auto &amp;P = *Proto; FunctionProtos[Proto-&gt;getName()] = std::move(Proto); Function *TheFunction = getFunction(P.getName()); if (!TheFunction) return nullptr; //   ,   if (P.isBinaryOp()) BinopPrecedence[P.getOperatorName()] = P.getBinaryPrecedence(); //        BasicBlock *BB = BasicBlock::Create(TheContext, "entry", TheFunction); Builder.SetInsertPoint(BB); //   DIE   DIFile *Unit = DBuilder-&gt;createFile(KSDbgInfo.TheCU-&gt;getFilename(), KSDbgInfo.TheCU-&gt;getDirectory()); DIScope *FContext = Unit; unsigned LineNo = P.getLine(); unsigned ScopeLine = LineNo; DISubprogram *SP = DBuilder-&gt;createFunction( FContext, P.getName(), StringRef(), Unit, LineNo, CreateFunctionType(TheFunction-&gt;arg_size(), Unit), false /* internal linkage */, true /* definition */, ScopeLine, DINode::FlagPrototyped, false); TheFunction-&gt;setSubprogram(SP); //     KSDbgInfo.LexicalBlocks.push_back(SP); //       (    //        //       ) KSDbgInfo.emitLocation(nullptr); //     NamedValues. NamedValues.clear(); unsigned ArgIdx = 0; for (auto &amp;Arg : TheFunction-&gt;args()) { //  alloca  . AllocaInst *Alloca = CreateEntryBlockAlloca(TheFunction, Arg.getName()); //      DILocalVariable *D = DBuilder-&gt;createParameterVariable( SP, Arg.getName(), ++ArgIdx, Unit, LineNo, KSDbgInfo.getDoubleTy(), true); DBuilder-&gt;insertDeclare(Alloca, D, DBuilder-&gt;createExpression(), DebugLoc::get(LineNo, 0, SP), Builder.GetInsertBlock()); //     alloca. Builder.CreateStore(&amp;Arg, Alloca); //      NamedValues[Arg.getName()] = Alloca; } KSDbgInfo.emitLocation(Body.get()); if (Value *RetVal = Body-&gt;codegen()) { //  . Builder.CreateRet(RetVal); //     . KSDbgInfo.LexicalBlocks.pop_back(); //    verifyFunction(*TheFunction); return TheFunction; } //    ,   TheFunction-&gt;eraseFromParent(); if (P.isBinaryOp()) BinopPrecedence.erase(Proto-&gt;getOperatorName()); //      KSDbgInfo.LexicalBlocks.pop_back(); return nullptr; } //===----------------------------------------------------------------------===// //     JIT //===----------------------------------------------------------------------===// static void InitializeModule() { //    TheModule = llvm::make_unique&lt;Module&gt;("my cool jit", TheContext); TheModule-&gt;setDataLayout(TheJIT-&gt;getTargetMachine().createDataLayout()); } static void HandleDefinition() { if (auto FnAST = ParseDefinition()) { if (!FnAST-&gt;codegen()) fprintf(stderr, "Error reading function definition:"); } else { //       getNextToken(); } } static void HandleExtern() { if (auto ProtoAST = ParseExtern()) { if (!ProtoAST-&gt;codegen()) fprintf(stderr, "Error reading extern"); else FunctionProtos[ProtoAST-&gt;getName()] = std::move(ProtoAST); } else { //       getNextToken(); } } static void HandleTopLevelExpression() { //       if (auto FnAST = ParseTopLevelExpr()) { if (!FnAST-&gt;codegen()) { fprintf(stderr, "Error generating code for top level expr"); } } else { //       getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (1) { switch (CurTok) { case tok_eof: return; case ';': //       . getNextToken(); break; case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // "" ,        //===----------------------------------------------------------------------===// #ifdef LLVM_ON_WIN32 #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT #endif /// putchard - putchar  double,  0. extern "C" DLLEXPORT double putchard(double X) { fputc((char)X, stderr); return 0; } /// printd -  double   "%f\n",  0. extern "C" DLLEXPORT double printd(double X) { fprintf(stderr, "%f\n", X); return 0; } //===----------------------------------------------------------------------===// //  main //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); InitializeNativeTargetAsmPrinter(); InitializeNativeTargetAsmParser(); //     // 1 -    BinopPrecedence['='] = 2; BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; //  . //    getNextToken(); TheJIT = llvm::make_unique&lt;KaleidoscopeJIT&gt;(); InitializeModule(); //       TheModule-&gt;addModuleFlag(Module::Warning, "Debug Info Version", DEBUG_METADATA_VERSION); // Darwin   dwarf2. if (Triple(sys::getProcessTriple()).isOSDarwin()) TheModule-&gt;addModuleFlag(llvm::Module::Warning, "Dwarf Version", 2); //  DIBuilder,   , ..    DBuilder = llvm::make_unique&lt;DIBuilder&gt;(*TheModule); //      //  "fib.ks"   ,     stdin //  ,      . KSDbgInfo.TheCU = DBuilder-&gt;createCompileUnit( dwarf::DW_LANG_C, "fib.ks", ".", "Kaleidoscope Compiler", 0, "", 0); //    MainLoop(); //    DBuilder-&gt;finalize(); //   . TheModule-&gt;print(errs(), nullptr); return 0; }</span></span></span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/336980/">https://habr.com/ru/post/336980/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336968/index.html">We pump USB Mass Storage Device on STM32F103 using FreeRTOS and DMA</a></li>
<li><a href="../336970/index.html">RxSwift: a bit about share (), replay (), shareReplayLatestWhileConnected () and other cool operators</a></li>
<li><a href="../336972/index.html">Optimization of the process of searching for violators of land legislation</a></li>
<li><a href="../336976/index.html">‚ÄúBy whom do you see yourself in 5 years?‚Äù: Wall Street top manager's advice on the answers to the cunning questions of recruiters</a></li>
<li><a href="../336978/index.html">Traffic mirroring on Juniper MX</a></li>
<li><a href="../336982/index.html">EWD: Substitution Processes</a></li>
<li><a href="../336984/index.html">Position selection procedure</a></li>
<li><a href="../336988/index.html">Programming Contest: JSDash (Results)</a></li>
<li><a href="../336992/index.html">Mobile Applications Testing Cheat Sheet</a></li>
<li><a href="../336994/index.html">Getting rid of fragment state saving libraries using pure kotlin</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>