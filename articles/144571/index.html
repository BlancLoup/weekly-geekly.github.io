<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Localization of a point in a convex polygon</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Leafing through the pages of the hub "Algorithms", I came across a topic dedicated to solving the problem of localizing a point in a polygon: a polygo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Localization of a point in a convex polygon</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/storage2/514/ab4/5a8/514ab45a8b071cde1c390a6f1c139ec8.png">  Leafing through the pages of the hub "Algorithms", I came across a <a href="http://habrahabr.ru/post/125356/">topic</a> dedicated to solving the problem of localizing a point in a polygon: a polygon is defined (a closed polyline without self-intersections), it is necessary to determine whether a given point A is inside this polygon or not.  In <a href="http://habrahabr.ru/post/125356/">one</a> of the last comments to the topic, it was puzzled how this <i>purely mathematical</i> task has to do with the theory of algorithms.  It has-and, most directly.  The task of localization is a classical problem of computational geometry (not to be confused with computer graphics).  As a warm-up, you are invited to look at the picture on the right, which shows a polygon of the Peano curve type (source [ <a href="https://habr.com/ru/post/144571/">1</a> ]), and try to answer the question - <s>do you see a</s> red <s>gopher?</s>  <s>and I do not see, and he is!</s>  is inside or outside the polygon?  And below, we (exclusively for educational purposes) will consider a simple variation of this task, when a given polygon is convex. <br><a name="habracut"></a><br><br>  It is clear that if a polygon is a triangle or a quadrilateral, then there are no algorithms in the full sense of the word, but there are three or four formulas that must be programmed.  However, a completely different story begins if the number of vertices of the polygon is large.  For example, a million or one hundred million vertices.  Such a task seems to be quite an algorithmic one.  The naive algorithm (launching a ray from a given point and counting the number of its intersections with the sides of a polygon) is <i>linear</i> in the number of vertices of the polygon <i>n</i> , since  we must check the intersection of the ray with <i>all</i> sides of the polygon.  Accordingly, the question arises, is it possible to do it faster, i.e.  Is there a <i>sublinear</i> algorithm for solving the localization problem in this formulation?  The correct answer to this question is yes, the problem can be solved in O (log <sub>2</sub> n) time.  Details of the solution, in the general case when the polygon does not have to be convex, can be found in the excellent book [ <a href="https://habr.com/ru/post/144571/">2</a> ].  And below we will look at how a binary search algorithm can be applied to a point localization problem in a <i>convex</i> polygon. <br><br><h1>  Small educational program </h1><br>  Let three points A, B, and C be given. Suppose that we look from point A to point B. Where does the point C turn out to be - to the right or left relative to the direction of our view?  It is possible to answer this question with the help of the vector product of the vectors a = AB and b = BC, more precisely with the help of the z-coordinate of such a product, which is calculated by the simple formula z = a <sub>x</sub> b <sub>y</sub> -a <sub>y</sub> b <sub>x</sub> .  If z&gt; 0, then the desired turn is left, if z &lt;0, then right.  If the <s>coin fell on the edge</s> z = 0, then the three points lie on one straight line (they say that the vectors a and b are collinear). <br><img src="https://habrastorage.org/storage2/4a8/67c/b66/4a867cb66210c31296aa8063089a4740.pn_g"><br>  Python code that calculates the direction of rotation is elementary (points are represented by lists of length 2): <br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rotate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A,B,C)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (B[<span class="hljs-number"><span class="hljs-number">0</span></span>]-A[<span class="hljs-number"><span class="hljs-number">0</span></span>])*(C[<span class="hljs-number"><span class="hljs-number">1</span></span>]-B[<span class="hljs-number"><span class="hljs-number">1</span></span>])-(B[<span class="hljs-number"><span class="hljs-number">1</span></span>]-A[<span class="hljs-number"><span class="hljs-number">1</span></span>])*(C[<span class="hljs-number"><span class="hljs-number">0</span></span>]-B[<span class="hljs-number"><span class="hljs-number">0</span></span>])</code> </pre> <br>  With such a useful feature, you can do a lot of good deeds.  For example, can one determine if two given segments AB and CD intersect?  This, by the way, is another basic operation of computational geometry, and we will also need it soon (though only once).  The idea is simple - two segments intersect if and only if the ends of one segment lie on opposite sides of another and vice versa. <div style="text-align:center;"><img src="https://habrastorage.org/storage2/22a/e32/c53/22ae32c53f2caff1008a2e9249c30936.png"></div>  To check whether the points C and D are located on opposite sides with respect to the segment (vector) AB, one should look at the directions of rotate (A, B, C) and rotate (A, B, D) turns.  If the signs of these expressions are different, then the line AB intersects the segment CD (and at the inner point).  The signs of two numbers are different, if and only if their product is negative.  Therefore, the criterion for the intersection of segments AB and CD is the negativity of two expressions rotate (A, B, C) * rotate (A, B, D) and rotate (C, D, A) * rotate (C, D, B).  If we replace strict negativity with nonpositivity, then we will be able to catch the intersection at the end points of the segments.  We also need some intermediate version, namely, one product will be weakly compared with zero, the second - strictly: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intersect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A,B,C,D)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotate(A,B,C)*rotate(A,B,D)&lt;=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> rotate(C,D,A)*rotate(C,D,B)&lt;<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  The reason for such a strange choice of inequality signs is a feature of the future application of this function (in particular, points A, B and C will be different vertices of a convex polygon, and point D will be the point we are trying to localize). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Binary search </h1><br>  Now we go to the localization itself.  Given a convex polygon P consisting of n vertices and a point A. In this case, it is assumed that the vertices in P are numbered counterclockwise (they say that the direction of the walk around the perimeter P is positive). <br><img src="http://habrastorage.org/storage2/347/2c4/451/3472c4451be9dadda9226c9497ed15b6.png"><br>  The idea of ‚Äã‚Äãthe algorithm: take the first vertex of the polygon P <sub>0</sub> and try to determine which segment (angle) P <sub>i</sub> P <sub>0</sub> P <sub>i + 1</sub> falls into point A. To begin with, check that A falls into the segment P <sub>n-1</sub> P <sub>0</sub> P <sub>1</sub> if this is not the case, then A is guaranteed to lie outside the polygon. <br><img src="http://habrastorage.org/storage2/7f1/651/27a/7f165127a5e204950c407c45df70ae95.png"><br>  Code: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pointloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(P,A)</span></span></span><span class="hljs-function">:</span></span> n = len(P) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rotate(P[<span class="hljs-number"><span class="hljs-number">0</span></span>],P[<span class="hljs-number"><span class="hljs-number">1</span></span>],A)&lt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rotate(P[<span class="hljs-number"><span class="hljs-number">0</span></span>],P[n<span class="hljs-number"><span class="hljs-number">-1</span></span>],A)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre><br>  Then everything is as in the classical binary search - we set p = 1, r = n-1 (borders of the current segment), we calculate the average vertex q = (p + r) / 2, we look where A is relative to the vector P <sub>0</sub> P <sub>q</sub> , if on the left, then replace r with q, if on the right, then replace p with q. <br><img src="http://habrastorage.org/storage2/458/02d/48d/45802d48d1616969ba6a83131f5ab8bf.png"><br>  We continue this process until it turns out that rp = 1: <br><pre> <code class="python hljs"> p, r = <span class="hljs-number"><span class="hljs-number">1</span></span>, n<span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> rp&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>: q = (p+r)/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> rotate(P[<span class="hljs-number"><span class="hljs-number">0</span></span>],P[q],A)&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>: r = q <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: p = q</code> </pre><br>  Now it remains to check whether the segments P <sub>0</sub> A and P <sub>p</sub> P <sub>r</sub> intersect? <br>  If they intersect, then point A lies outside, if not intersect, then inside. <br><img src="http://habrastorage.org/storage2/b3b/f76/7f9/b3bf767f9bb13a70a82df4102866631e.png"><br>  Code: <br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> intersect(P[<span class="hljs-number"><span class="hljs-number">0</span></span>],A,P[p],P[r])</code> </pre><br>  That's all ... <br><br><h1>  Results </h1><br>  It is easy to verify that the complexity of the algorithm is the same as that of the classical binary search algorithm - O (log <sub>2</sub> n).  And everything would be great if this algorithm was not sharpened under convex polygons.  For the sake of fairness, the considered algorithm works with some non-convex polygons, but of a very specific type ‚Äî in such polygons all diagonals leading from the zero vertex must lie inside the polygon: <br><img src="http://habrastorage.org/storage2/b57/d91/983/b57d91983d1eba632c1f589654d3314d.png"><br>  The universal localization algorithm also works on the principle of binary search, only inside it everything is arranged, to put it mildly, a bit more complicated. <br><br>  Thanks for attention! <br><br>  PS: The task with the picture at the top of the topic is easily solved in any graphic editor: select the fill tool (fill), take a color different from the background, click on the edge of the picture (outside the polygon) and voila! <br><br><h1>  Literature </h1><br><ol><li><a name="algbot"></a>  P. Prusinkiewicz, A. Lindenmayer, <i>The algorithmic beauty of plants</i> , 1996 </li><li><a name="compgeom"></a>  M. de Berg, O. Cheong, M. van Kreveld, M. Overmars, <i>Computational Geometry.</i>  <i>Algorithms and Applications</i> , 2008 </li><li>  F. Preparata, M. Sheimos, <i>Computational Geometry</i> , 1989 </li></ol></div><p>Source: <a href="https://habr.com/ru/post/144571/">https://habr.com/ru/post/144571/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144565/index.html">Stream encryption at 10 Gbit / s? Yes. Parallel</a></li>
<li><a href="../144566/index.html">Logging - a library for easy logging in Python</a></li>
<li><a href="../144567/index.html">About deleting quoted lines from JavaScript text</a></li>
<li><a href="../144568/index.html">Data Warehouse Metrics</a></li>
<li><a href="../144569/index.html">Dragon SpaceX successfully reached the ISS</a></li>
<li><a href="../144572/index.html">Leaked PS4 specs</a></li>
<li><a href="../144573/index.html">Large images on the site for users with Retina Display - retina.js</a></li>
<li><a href="../144574/index.html">Auto-update of stock deadline in Yandex.Direct</a></li>
<li><a href="../144575/index.html">BIOS update on Dell PowerEdge R510 server</a></li>
<li><a href="../144580/index.html">User identification by voice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>