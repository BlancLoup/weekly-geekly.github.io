<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multiple variable polynomials and Haskell‚Äôs Buchberger algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to talk about how to implement the algorithms associated with the Gr√∂bner bases, in Haskell. I hope someone my ideas and explan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multiple variable polynomials and Haskell‚Äôs Buchberger algorithm</h1><div class="post__text post__text-html js-mediator-article"> In this article I want to talk about how to implement the algorithms associated with the Gr√∂bner bases, in Haskell.  I hope someone my ideas and explanations will be useful.  I'm not going to go into theory, so the reader should be familiar with the concepts of the polynomial ring, the ideal ring and the ideal basis.  I advise you to read <a href="http://www.mccme.ru/free-books/dubna/arjantsev.pdf">this</a> book of ICNMO, in it all the necessary theory is described in detail. <br><br>  The main subject of the paper is the Gr√∂bner bases of ideals of polynomial rings of several variables.  This concept arises in the study of systems of polynomial equations.  At the end of the article I will show by example how to apply these ideas. <br><br>  The most important result that this theory gives is a good way to solve polynomial systems of equations of several variables.  Even if you are not familiar with higher algebra or Haskell, I advise you to read this article, since these very methods of solution are explained at the level accessible to the student, and the whole theory is needed only for substantiation.  You can safely skip everything related to higher algebra, and just learn how to solve systems of equations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are interested, please under the cat. <a name="habracut"></a><br><br>  <i>I apologize for the pictures - this is rendered by latex, and how to make habr understand <code>style="width:...;height=...;"</code></i>  <i>I do not know.</i>  <i>If you tell the better way, be sure to redo it.</i> <br><br><h4>  1 The most necessary concepts from algebra </h4><br><a name="a0000000002"></a>  Sets, on the elements of which two operations can be defined - ‚Äúaddition‚Äù and ‚Äúmultiplication‚Äù, which correspond to a certain set of rules (axioms), are called <i>rings</i> in algebra.  Polynomials in several variables whose coefficients are real numbers form a ring, denoted by <img src="https://habrastorage.org/storage2/2ec/c25/593/2ecc25593f408daef7bc5ffd06e3323e.png">  , regarding ordinary school operations of addition and multiplication of polynomials.  <i>The ideal of a</i> ring is its subset, the difference of two elements of which lies in it and the product of any of its elements and an arbitrary element of the ring lies in this subset.  The simplest example of an ideal is a set of multiples of five numbers as an ideal in the ring of integers.  See for yourself that this is ideal.  If it worked out, there would be no further problems. <br><br>  Further we will consider only ideals in the ring of polynomials.  Some finite set of polynomials <img src="https://habrastorage.org/storage2/df9/c61/307/df9c613073c5b77e63be7d7ec8ffb429.png">  is called an ideal <i>basis</i> if any polynomial from an ideal is represented as <img src="https://habrastorage.org/storage2/7c4/1da/b92/7c41dab92ab196831dd9061cef1ff907.png">  where <img src="https://habrastorage.org/storage2/290/b09/246/290b092469997651dc5b39f4df351f51.png">  - some polynomials.  This fact is recorded as: <img src="https://habrastorage.org/storage2/235/58d/8df/23558d8dfe361f0384ade983f73f6013.png">  .  Hilbert's theorem on a basis gives a remarkable result ‚Äî <i>every</i> ideal (in a ring of polynomials) has a finite basis.  This allows you to work in any situation just to work with finite bases of ideals. <br><br>  Now we will consider systems of equations of the following form: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/dfc/b86/1a9/dfcb861a9076612de9273192ee2c5495.png"></div><br><br>  Let's call the ideal of this system the ideal. <img src="https://habrastorage.org/storage2/235/58d/8df/23558d8dfe361f0384ade983f73f6013.png">  .  It is known from algebra that any polynomial lying in the ideal <img src="https://habrastorage.org/storage2/e3a/20c/408/e3a20c4088d92959d57912631def540f.png">  , vanishes on any solution of the source system.  And further, if <img src="https://habrastorage.org/storage2/6d3/4fb/0bd/6d34fb0bdca654e935df0715edd7ac75.png">  - another ideal basis <img src="https://habrastorage.org/storage2/e3a/20c/408/e3a20c4088d92959d57912631def540f.png">  then the system <br><br><img src="https://habrastorage.org/storage2/c29/79f/f96/c2979ff969fd219cb4ae9b3a78b38672.png"><br><br>  has the same set of solutions as the original one.  From all this it follows that if we succeed in finding a basis in the ideal of a system that is simpler than the original, then the problem of solving the system itself is simplified. <br><br>  In a magical way, such a basis exists - it is called the Gr√∂bner basis of the ideal.  By definition, this is such a basis that the division procedure with the remainder (about it later) for any polynomial of the ideal will yield a zero remainder.  If we construct it, then one of its polynomials, at least in most cases, will depend on only one variable, which will allow us to solve the entire system by successive substitution. <br><br>  The last thing we need is <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -mold and criterion <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -Buchberger pair.  Choose some "good" way of arranging monomials (for details - in the book) and denote by <img src="https://habrastorage.org/storage2/ef5/21b/cba/ef521bcba0c7580552355e34772cdfe1.png">  the leading term (with respect to this ordering) of a polynomial <img src="https://habrastorage.org/storage2/ce1/93d/f68/ce193df6867ad18cb4fb67f6de4448ca.png">  and through <img src="https://habrastorage.org/storage2/858/fcd/a32/858fcda3218514a5eda6e0336ce6e3ae.png">  - least common multiple of monomials <img src="https://habrastorage.org/storage2/e6a/2e4/96b/e6a2e496b9f30d0b604822d018235efd.png">  and <img src="https://habrastorage.org/storage2/676/02b/32b/67602b32bfabe2dd231c9d1c8c905955.png">  .  Then <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  polynomial from <img src="https://habrastorage.org/storage2/ce1/93d/f68/ce193df6867ad18cb4fb67f6de4448ca.png">  and <img src="https://habrastorage.org/storage2/5d4/fed/49b/5d4fed49b36d2b8c1fa278397a9a17b2.png">  called the following structure: <br><br><img src="https://habrastorage.org/storage2/c2f/deb/1ad/c2fdeb1ad9de2c15faae4a7cfa80721c.png"><br><br>  Proved (criterion <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -pair), that the ideal basis is its Gr√∂bner basis if and only if <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  - a polynomial from any pair of its members gives the remainder 0 when dividing by a basis (how this is done will be explained later).  This immediately prompts the algorithm for constructing such a basis: <br><ol><li>  For each pair of base polynomials compose them <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -policy and share it with the remainder on the basis. </li><li>  If all residues are zero, the Gr√∂bner basis is obtained.  Otherwise, add all nonzero residues to the base and return to step 1. </li></ol><br>  This is the Buchberger algorithm - the main subject of this article.  On this with mathematics everything, you can go.  If you do not understand something, you should look at Wikipedia or a book, although the further narrative does not require knowledge of higher algebra. <br><br><h4>  2 Representation of polynomials in several Haskell variables </h4><br><a name="a0000000003"></a>  Let's start building a representation of polynomials with monomials.  A monomial is characterized by only two things - a coefficient and a set of degrees of variables.  We assume that there are variables <img src="https://habrastorage.org/storage2/0ba/50b/2fd/0ba50b2fdfd6b4d3f04f03f5f61d34d7.png">  , <img src="https://habrastorage.org/storage2/c8a/7da/3df/c8a7da3df4abcbc0400ed6483f0ef98d.png">  and so on.  Then monomial <img src="https://habrastorage.org/storage2/42e/444/1f5/42e4441f5e42b3fa6b14af602a3629ad.png">  has a coefficient of 1 and degree <code>[2,3,1]</code> , while the monomial <img src="https://habrastorage.org/storage2/4ce/1f6/044/4ce1f6044d355584b05f043f4bcae215.png">  - coefficient 2 and degree <code>[0,0,3]</code> .  Pay attention to zero degrees!  They are critical for implementing all the other methods.  In general, we require that the lists of powers of all monomials (within the same task) have the same length.  This will greatly simplify our work. <br><br>  We describe the type of ‚Äúmonomial‚Äù as an algebraic data type consisting of a coefficient (type ‚Äú <code>c</code> ‚Äù) and a list of degrees (each type ‚Äú <code>a</code> ‚Äù): <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monom</span></span></span><span class="hljs-class"> ca = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class"> c [a] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  We will need to compare monomials with each other, so it's time to write an embodiment of the <code>Ord</code> class.  I will use the usual lexicographical ordering in powers, since it is very simple and at the same time corresponds to the rules of "good" ordering of monomials.  We will also write the embodiment of the <code>Show</code> class just for the convenience of working with our system. <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monom</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ca</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> compare (<span class="hljs-type"><span class="hljs-type">M</span></span> _ asl) (<span class="hljs-type"><span class="hljs-type">M</span></span> _ asr) = compare asl asr <span class="hljs-keyword"><span class="hljs-keyword">instance</span></span> (<span class="hljs-type"><span class="hljs-type">Show</span></span> a, <span class="hljs-type"><span class="hljs-type">Show</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Num</span></span> c, <span class="hljs-type"><span class="hljs-type">Eq</span></span> a, <span class="hljs-type"><span class="hljs-type">Eq</span></span> c) =&gt; <span class="hljs-type"><span class="hljs-type">Show</span></span> (<span class="hljs-type"><span class="hljs-type">Monom</span></span> ca) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> show (<span class="hljs-type"><span class="hljs-type">M</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> show c) ++ (intercalate <span class="hljs-string"><span class="hljs-string">"*"</span></span> $ map showOne $ (filter (\(p,_) -&gt; p /= <span class="hljs-number"><span class="hljs-number">0</span></span>) $ zip <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-number"><span class="hljs-number">1.</span></span>.])) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> showOne (p,i) = <span class="hljs-string"><span class="hljs-string">"x"</span></span> ++ (show i) ++ (<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> p == <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"^"</span></span> ++ (show p))</code> </pre><br>  The <code>show</code> function tries to be ‚Äúsmart‚Äù: it does not show the coefficient, if it is equal to 1, and it does not show variables of zero degree, nor does it show the first degree of variables.  Like this: <br><br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] <span class="hljs-number"><span class="hljs-number">2</span></span>x2 *<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>] x1^<span class="hljs-number"><span class="hljs-number">2</span></span>*x2^<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  I will write functions that are similar to <code>show</code> , all the time, so it‚Äôs worth explaining exactly how it works - I‚Äôm sure it scared anyone.  Using <code>zip as [1..]</code> glue each power with its own variable number, then with <code>filter ( <br> (p _) -&gt; p /= 0)</code> <code>filter ( <br> (p _) -&gt; p /= 0)</code>  <code>filter ( <br> (p _) -&gt; p /= 0)</code> get rid of zero degrees, we turn the description of each variable into a string through <code>showOne</code> and, finally, we glue everything together, interspersed with multiplication icons, using <code>intercalate</code> from <code>Data.List</code> <br><br>  Now we are ready to describe the actual type of polynomials.  For this, a <code>newtype</code> wrapper over a regular list will do: <br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Polynom</span></span></span><span class="hljs-class"> ca = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">P</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monom</span></span></span><span class="hljs-class"> ca] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">) instance (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">) =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Show</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Polynom</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ca</span></span></span><span class="hljs-class">) where show (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">P</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ms</span></span></span><span class="hljs-class">) = intercalate " + " $ map show ms</span></span></code> </pre><br>  This time, the <code>show</code> function is simple, since all the dirty work is already hidden in the type of monomials.  It works like this: <br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; <span class="hljs-type"><span class="hljs-type">P</span></span> [<span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]] x1^<span class="hljs-number"><span class="hljs-number">3</span></span>*x2 + x1^<span class="hljs-number"><span class="hljs-number">2</span></span>*x2^<span class="hljs-number"><span class="hljs-number">2</span></span> + x1*x2</code> </pre><br>  We agree on the future that the monomials in this list will always be stored in descending order (in the sense of our definition of the <code>Ord</code> incarnation).  This will make it possible to realize some things much easier. <br><br><h4>  3 Polynomial operations </h4><br><a name="a0000000004"></a>  The simplest operations are LT, checks for equality to zero and multiplication by a number.  From our agreement on the ordering of monomials, it follows that the highest monom is always at the top of the list and can be obtained with the help of <code>head</code> .  A monomial is considered to be zero if its coefficient is zero, and a polynomial is considered to contain no monomials.  Well, multiplication by a constant simply changes the coefficient: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lt</span></span> :: <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca lt (<span class="hljs-type"><span class="hljs-type">P</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = head <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> zero :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> c, <span class="hljs-type"><span class="hljs-type">Eq</span></span> c) =&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> zero (<span class="hljs-type"><span class="hljs-type">M</span></span> c _) = c == <span class="hljs-number"><span class="hljs-number">0</span></span> zeroP :: <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> zeroP (<span class="hljs-type"><span class="hljs-type">P</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = null <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> scale :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> c) =&gt; c -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca scale c' (<span class="hljs-type"><span class="hljs-type">M</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = <span class="hljs-type"><span class="hljs-type">M</span></span> (c*c') <span class="hljs-keyword"><span class="hljs-keyword">as</span></span></code> </pre><br>  Two monomials will be called similar if they differ only in coefficients.  For them, the sum is determined - you just need to add the coefficients, and the degrees remain unchanged. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">similar</span></span> :: (<span class="hljs-type"><span class="hljs-type">Eq</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> similar (<span class="hljs-type"><span class="hljs-type">M</span></span> _ asl) (<span class="hljs-type"><span class="hljs-type">M</span></span> _ asr) = asl == asr addSimilar :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> c) =&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca addSimilar (<span class="hljs-type"><span class="hljs-type">M</span></span> cl <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) (<span class="hljs-type"><span class="hljs-type">M</span></span> cr _) = <span class="hljs-type"><span class="hljs-type">M</span></span> (cl+cr) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span></code> </pre><br>  To multiply two monomials, simply add the powers of each of the variables.  This operation is very easy to accomplish with the great <code>zipWith</code> .  I think the code speaks for itself: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mulMono</span></span> :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Num</span></span> c) =&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca mulMono (<span class="hljs-type"><span class="hljs-type">M</span></span> cl asl) (<span class="hljs-type"><span class="hljs-type">M</span></span> cr asr) = <span class="hljs-type"><span class="hljs-type">M</span></span> (cl*cr) (zipWith (+) asl asr)</code> </pre><br>  The addition of polynomials is much more interesting.  We will solve this problem recursively.  Trivial cases - the sum of two zero polynomials (empty lists) is equal to the zero polynomial.  The sum of any polynomial and zero is equal to it.  Now we can consider both polynomials to be non-zero, which means that each of them can be divided into the senior member and the others - the ‚Äútail‚Äù.  There are two cases: <br><ol><li>  Older members are similar.  In this case, add them and add the result (if it is non-zero) to the sum of the tails. </li><li>  Older members are not alike.  Then pick the bigger one.  Our ordering condition guarantees that there is no similar monomial in the tails of both polynomials.  Consequently, we can fold the tail of the chosen polynomial with another, and then add to its beginning this largest monomial. </li></ol><br>  It remains to be noted that as a result of this recursive procedure, an ordered polynomial will again be obtained, and write the actual code. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">addPoly</span></span> :: (<span class="hljs-type"><span class="hljs-type">Eq</span></span> a, <span class="hljs-type"><span class="hljs-type">Eq</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> c, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca addPoly (<span class="hljs-type"><span class="hljs-type">P</span></span> l) (<span class="hljs-type"><span class="hljs-type">P</span></span> r) = <span class="hljs-type"><span class="hljs-type">P</span></span> $ go lr <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> go [] [] = [] go <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [] = <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> go [] bs = bs go (a:<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) (b:bs) = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> similar ab <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zero $ addSimilar ab) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> go <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bs <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> (addSimilar ab):(go <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> bs) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a &gt; b <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> a:(go <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> (b:bs)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> b:(go (a:<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) bs)</code> </pre><br>  Multiplication of polynomials is obtained in an absolutely natural way.  It is very easy to multiply a monomial by a polynomial - just multiply it by each of the monomials using <code>map</code> and <code>mulMono</code> .  And then we apply distributivity (‚Äúdistribution law‚Äù, opening brackets) to the product of two polynomials and we obtain that we only need to multiply all the monomials of the first polynomial by the second and add the obtained results.  We will execute multiplications with the help of the same <code>map</code> , and <code>foldl'</code> results using <code>foldl'</code> and <code>addPoly</code> .  The code of these two operations was surprisingly short - shorter than the type descriptions! <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mulPM</span></span> :: (<span class="hljs-type"><span class="hljs-type">Ord</span></span> a, <span class="hljs-type"><span class="hljs-type">Eq</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Num</span></span> c) =&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca mulPM (<span class="hljs-type"><span class="hljs-type">P</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) m = <span class="hljs-type"><span class="hljs-type">P</span></span> $ map (mulMono m) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> mulM :: (<span class="hljs-type"><span class="hljs-type">Eq</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca mulM l@(<span class="hljs-type"><span class="hljs-type">P</span></span> ml) r@(<span class="hljs-type"><span class="hljs-type">P</span></span> mr) = foldl' addPoly (<span class="hljs-type"><span class="hljs-type">P</span></span> []) $ map (mulPM r) ml</code> </pre><br>  That's all, we have implemented the basic actions on polynomials, which means we can move on! <br><br><h4>  4 Division with remainder by basis (reduction) </h4><br><a name="a0000000005"></a>  Let's say that monomial <img src="https://habrastorage.org/storage2/e6a/2e4/96b/e6a2e496b9f30d0b604822d018235efd.png">  <i>divided</i> into monomial <img src="https://habrastorage.org/storage2/676/02b/32b/67602b32bfabe2dd231c9d1c8c905955.png">  if there is such a monomial <img src="https://habrastorage.org/storage2/cbf/e48/40a/cbfe4840aa0c6f3d4bcb8edfb1403300.png">  , what <img src="https://habrastorage.org/storage2/014/ce2/cb9/014ce2cb926c3dc71c5792290e973431.png">  .  Obviously, this is true only if each variable is included in <img src="https://habrastorage.org/storage2/e6a/2e4/96b/e6a2e496b9f30d0b604822d018235efd.png">  no less than <img src="https://habrastorage.org/storage2/676/02b/32b/67602b32bfabe2dd231c9d1c8c905955.png">  .  Therefore, the check for divisibility can be implemented using the familiar <code>zipWith</code> function and the remarkable function <code>and</code> .  And along with the check, it is easy to obtain the division procedure itself: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">dividable</span></span> :: (<span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> dividable (<span class="hljs-type"><span class="hljs-type">M</span></span> _ al) (<span class="hljs-type"><span class="hljs-type">M</span></span> _ ar) = and $ zipWith (&gt;=) al ar divideM :: (<span class="hljs-type"><span class="hljs-type">Fractional</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca divideM (<span class="hljs-type"><span class="hljs-type">M</span></span> cl al) (<span class="hljs-type"><span class="hljs-type">M</span></span> cr ar) = <span class="hljs-type"><span class="hljs-type">M</span></span> (cl/cr) (zipWith (-) al ar)</code> </pre><br>  Note that now the type of the coefficient should allow division - the <code>Fractional</code> class.  It is depressing, but nothing can be done. <br>  The division algorithm of a polynomial on a basis with the remainder is essentially a simple school column division.  Among the polynomials of the basis, the first such polynomial is chosen, that the eldest member of the dividend is divided into its senior member, then this polynomial multiplied by the quotient of its older members is subtracted from the dividend.  The result of the subtraction is taken as a new dividend and the process is repeated.  If the senior member is not divided into any of the senior members of the base, the division is completed and the last divisible element is called the remainder. <br><br>  Our main division procedure, let's call it <code>reduceMany</code> , will require two auxiliary ones - <code>reducable</code> and <code>reduce</code> .  The first of them checks whether the polynomial is divisible by another, and the second performs division. <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">reducable</span></span> :: (<span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> reducable lr = dividable (lt l) (lt r) reduce :: (<span class="hljs-type"><span class="hljs-type">Eq</span></span> c, <span class="hljs-type"><span class="hljs-type">Fractional</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca reduce lr = addPoly lr' <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> r' = mulPM r (scale (<span class="hljs-number"><span class="hljs-number">-1</span></span>) q) q = divideM (lt l) (lt r)</code> </pre><br>  Since we do not have a function for subtraction, we simply multiply the second polynomial by -1 and add them - everything is simple!  And here is the whole division algorithm: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">reduceMany</span></span> :: (<span class="hljs-type"><span class="hljs-type">Eq</span></span> c, <span class="hljs-type"><span class="hljs-type">Fractional</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; [<span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca] -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca reduceMany h fs = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> reduced <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> reduceMany h' fs <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> h' <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> (h', reduced) = reduceStep h fs <span class="hljs-type"><span class="hljs-type">False</span></span> reduceStep h (f:fs) r | zeroP h = (h, r) | otherwise = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> reducable hf <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> (reduce hf, <span class="hljs-type"><span class="hljs-type">True</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> reduceStep h fs r reduceStep h [] r = (h, r)</code> </pre><br>  The <code>reduceMany</code> function <code>reduceMany</code> to divide the polynomial into a base.  If a division has occurred, the process continues; otherwise, it ends.  The internal <code>reduceStep</code> function merely searches for the very first polynomial into which it can be divided, and divides, returning a remainder and a flag indicating whether a division has been made. <br><br><h4>  5 Algorithm of Buchberger </h4><br><a name="a0000000006"></a>  Here we come to the main part of this article - the implementation of the Buchberger algorithm.  The only thing we don‚Äôt have yet is the functions to get <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  polynomial  Its implementation is very simple, as is the auxiliary function for finding the smallest common multiple of monomials: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">lcmM</span></span> :: (<span class="hljs-type"><span class="hljs-type">Num</span></span> c, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Monom</span></span> ca lcmM (<span class="hljs-type"><span class="hljs-type">M</span></span> cl al) (<span class="hljs-type"><span class="hljs-type">M</span></span> cr ar) = <span class="hljs-type"><span class="hljs-type">M</span></span> (cl*cr) (zipWith max al ar) makeSPoly :: (<span class="hljs-type"><span class="hljs-type">Eq</span></span> c, <span class="hljs-type"><span class="hljs-type">Fractional</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca makeSPoly lr = addPoly l' r' <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> l' = mulPM l ra r' = mulPM r la lcm = lcmM (lt l) (lt r) ra = divideM lcm (lt l) la = scale (<span class="hljs-number"><span class="hljs-number">-1</span></span>) $ divideM lcm (lt r)</code> </pre><br>  Here both polynomials are simply multiplied by the corresponding monomials, with the second additionally also having a minus one, as in the case of division with the remainder. <br>  I am sure that there are many ways to implement this algorithm.  I also do not pretend that my implementation is sufficiently optimal or simple.  But I like it and it works, and that's all it takes. <br><br>  The approach I used can be called dynamic.  We divide our basis into two parts - the one in which we have already checked (and added) <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -polynomials from all pairs - ‚Äú <code>checked</code> ‚Äù - and the one in which only to be done is ‚Äú <code>add</code> ‚Äù.  One step of the algorithm will look like this: <br><ol><li>  Take the first polynomial from the second part </li><li>  Consistently build <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -polynomials between it and all polynomials of the first part and add all non-zero residues to the end of the second part </li><li>  Move this polynomial to the first part. </li></ol><br>  As soon as the second part is empty, the first will contain the Gr√∂bner basis.  The advantage of this solution is that they will not be considered <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -polynomials from those pairs from which they are already counted and verified.  The key function in this process is <code>checkOne</code> .  It takes a polynomial (from the second part), as well as both parts, and returns a list of polynomials that should be added to the base.  We use simple recursion on the first part, naturally without adding zero residues: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">checkOne</span></span> :: (<span class="hljs-type"><span class="hljs-type">Eq</span></span> c, <span class="hljs-type"><span class="hljs-type">Fractional</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; <span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca -&gt; [<span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca] -&gt; [<span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca] -&gt; [<span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca] checkOne f checked@(c:cs) add = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> zeroP s <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> checkOne f cs add <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> s:(checkOne f cs (add ++ [s])) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> s = reduceMany (makeSPoly fc) (checked++add) checkOne _ [] _ = []</code> </pre><br>  Surely this can be replaced by sly <code>foldl</code> , but I will leave this as an exercise.  It remains only to construct the Gr√∂bner basis itself for this.  The implementation of the algorithm step literally repeats its description, see for yourself: <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">build</span></span> checked add@(a:<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = build (checked ++ [a]) (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ++ (checkOne a checked add)) build checked [] = checked</code> </pre><br>  The polynomial <code>a</code> passes to the first part, and all its nonzero residues go to the second.  Note that it's enough to check <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -polynomials of each polynomial of the second part only from the first, due to the displacements of polynomials between parts.  It remains to be noted that to obtain the Gr√∂bner basis from this one, it is enough to place one of its polynomials in the first part, the rest in the second and apply the <code>build</code> procedure, which is done in the function <code>makeGroebner</code> . <br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">makeGroebner</span></span> :: (<span class="hljs-type"><span class="hljs-type">Eq</span></span> c, <span class="hljs-type"><span class="hljs-type">Fractional</span></span> c, <span class="hljs-type"><span class="hljs-type">Num</span></span> a, <span class="hljs-type"><span class="hljs-type">Ord</span></span> a) =&gt; [<span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca] -&gt; [<span class="hljs-type"><span class="hljs-type">Polynom</span></span> ca] makeGroebner (b:bs) = build [b] bs <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> build checked add@(a:<span class="hljs-keyword"><span class="hljs-keyword">as</span></span>) = build (checked ++ [a]) (<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ++ (checkOne a checked add)) build checked [] = checked</code> </pre><br><h4>  6 Examples of use </h4><br><a name="a0000000007"></a>  All these theoretical constructions seem completely useless without demonstrating the practical application of these methods.  As an example, consider the problem of finding the intersection point of three circles - the simplest case of positioning on the map.  We write the equations of circles as a system of equations: <br><br><img src="https://habrastorage.org/storage2/dd5/2fe/f0e/dd52fef0ea14831a01ae59d73f25f7c5.png">  . <br><br>  After opening the brackets, we get the following: <br><br><img src="https://habrastorage.org/storage2/fd6/8cb/598/fd68cb59823fda21c39a625c559b386e.png"><br><br>  Construct the Gr√∂bner basis (I used the <code>Rational</code> type for greater accuracy): <br><pre> <code class="haskell hljs">*<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f1 = <span class="hljs-type"><span class="hljs-type">P</span></span> [<span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> (<span class="hljs-number"><span class="hljs-number">-2</span></span>) [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> (<span class="hljs-number"><span class="hljs-number">-26</span></span>) [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">70</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]] :: <span class="hljs-type"><span class="hljs-type">Polynom</span></span> <span class="hljs-type"><span class="hljs-type">Rational</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> *<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f2 = <span class="hljs-type"><span class="hljs-type">P</span></span> [<span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> (<span class="hljs-number"><span class="hljs-number">-22</span></span>) [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> (<span class="hljs-number"><span class="hljs-number">-16</span></span>) [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">160</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]] :: <span class="hljs-type"><span class="hljs-type">Polynom</span></span> <span class="hljs-type"><span class="hljs-type">Rational</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> *<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> f3 = <span class="hljs-type"><span class="hljs-type">P</span></span> [<span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> (<span class="hljs-number"><span class="hljs-number">-20</span></span>) [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> (<span class="hljs-number"><span class="hljs-number">-2</span></span>) [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-type"><span class="hljs-type">M</span></span> <span class="hljs-number"><span class="hljs-number">76</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]] :: <span class="hljs-type"><span class="hljs-type">Polynom</span></span> <span class="hljs-type"><span class="hljs-type">Rational</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> *<span class="hljs-type"><span class="hljs-type">Main</span></span>&gt; putStr $ unlines $ map show $ makeGroebner [f1,f2,f3] x1^<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">-2</span></span>) % <span class="hljs-number"><span class="hljs-number">1</span></span>x1 + x2^<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">-26</span></span>) % <span class="hljs-number"><span class="hljs-number">1</span></span>x2 + <span class="hljs-number"><span class="hljs-number">70</span></span> % <span class="hljs-number"><span class="hljs-number">1</span></span> x1^<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">-22</span></span>) % <span class="hljs-number"><span class="hljs-number">1</span></span>x1 + x2^<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">-16</span></span>) % <span class="hljs-number"><span class="hljs-number">1</span></span>x2 + <span class="hljs-number"><span class="hljs-number">160</span></span> % <span class="hljs-number"><span class="hljs-number">1</span></span> x1^<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">-20</span></span>) % <span class="hljs-number"><span class="hljs-number">1</span></span>x1 + x2^<span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">-2</span></span>) % <span class="hljs-number"><span class="hljs-number">1</span></span>x2 + <span class="hljs-number"><span class="hljs-number">76</span></span> % <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">-20</span></span>) % <span class="hljs-number"><span class="hljs-number">1</span></span>x1 + <span class="hljs-number"><span class="hljs-number">10</span></span> % <span class="hljs-number"><span class="hljs-number">1</span></span>x2 + <span class="hljs-number"><span class="hljs-number">90</span></span> % <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> % <span class="hljs-number"><span class="hljs-number">1</span></span>x2 + (<span class="hljs-number"><span class="hljs-number">-75</span></span>) % <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br>  In a miraculous way, we got two linear equations that quickly give the answer - the point (7.5).  You can check that it lies on all three circles.  So, we have reduced the solution of a system of three complex square equations to two simple linear ones.  Gr√∂bner bases are really useful tools for such tasks. <br><br><h4>  7 Questions for reflection and conclusion </h4><br><a name="a0000000008"></a>  In fact, this result can still be improved. <img src="https://habrastorage.org/storage2/cdf/a37/89d/cdfa3789d7be91d89914ad01759e88d6.png">  -polynomials need to be counted only for those pairs of polynomials whose higher members are not mutually simple - that is, their least common multiple is not just their product.  In some sources about this case they say "polynomials have a <i>link</i> ".  Add this optimization to our <code>makeGroebner</code> function. <br><br>  If a polynomial got into the final basis, the senior member of which is divided into the senior member of some other polynomial from the basis, then it can be excluded.  The basis obtained after eliminating all such polynomials is called the Gr√∂bner <i>minimal</i> basis.  You can also consider a polynomial, <i>an arbitrary</i> member of which is divided into the senior member of some other polynomial.  In this case, we replace this polynomial by the remainder of division by another.  The basis in which all possible operations of this type are carried out is called <i>reduced</i> .  As an exercise, implement minimization and reduction of the base. <br><br>  In conclusion, I want to say thank you to everyone who read this article to the end.  I know that my narration was somewhat chaotic, and the code is not ideal (and, perhaps, incomprehensible), but I still hope that I have interested someone with Gr√∂bner bases.  I would be very pleased if someone can find the use of my work in any real tasks. <br><br>  All code from the article is available as <a href="https://gist.github.com/maksbotan/5414897">gist</a> . </div><p>Source: <a href="https://habr.com/ru/post/177237/">https://habr.com/ru/post/177237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../177225/index.html">Time management on a personal example: 10 theses</a></li>
<li><a href="../177227/index.html">CRUD application on Ext JS and Ruby on Rails in 7 minutes</a></li>
<li><a href="../177229/index.html">An agreement on the development of the site, design, software. Version 1.1</a></li>
<li><a href="../177233/index.html">Conference ‚ÄúStrike! 2013 ". Small report</a></li>
<li><a href="../177235/index.html">Computer application development projects. Special features</a></li>
<li><a href="../177239/index.html">Best Xperia</a></li>
<li><a href="../177241/index.html">YAGNI principle in project management</a></li>
<li><a href="../177243/index.html">Deploying django applications on OpenShift hosting from Red Hat</a></li>
<li><a href="../177249/index.html">Game mechanics: let's look at the core of the game by bone</a></li>
<li><a href="../177251/index.html">Java 8 release shifted to March 2014</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>