<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>WTF is a SuperColumn? Introduction to the Cassandra Data Model</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This translation of an article dated September 1, 2009 should be taken into account when reading. - approx. per. 

 In the past month or two, the Digg...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>WTF is a SuperColumn? Introduction to the Cassandra Data Model</h1><div class="post__text post__text-html js-mediator-article">  <i>This translation of an article dated September 1, 2009 should be taken into account when reading.</i>  <i>- approx.</i>  <i>per.</i> <br><br>  In the past month or two, the Digg engineering team has spent quite a bit of time researching, testing and finalizing <a href="http://cassandra.apache.org/">Cassandra</a> production.  It was a very fun project, but before the fun started, we had to spend some time figuring out what the Cassandra data model is ... the phrase ‚ÄúWTF is a‚Äú super column ‚Äù‚Äù (‚Äúwhat the hell is that super column ? ‚Äù) Was pronounced more than once. <br><br>  If you‚Äôve previously worked with RDBMSs (this applies to almost everyone), you‚Äôll probably be a bit discouraged by some of the names when studying the Cassandra data model.  It took several days of discussions for me and my Digg team before we got the hang of it.  A couple of weeks ago, on the developers mailing list, there was a <a href="http://www.freebsd.org/doc/ru/books/faq/misc.html">bikeshed</a> process on a completely new naming scheme to resolve the confusion.  Throughout the discussion, I thought: ‚Äúmaybe if there are several normal examples, people will not be so confused by the names‚Äù.  So, this is my attempt to explain the Cassandra data model;  It is designed to ensure that you are familiar with, but do not go into the wilds, and, I hope, this will help clarify some things. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Pieces </h4><br>  Let's first take a look at the building blocks, before we see how they can all work together. <br><br><h5>  Column </h5><br>  A column is a minimum data element.  This is a triplet containing the name, value, and timestamp.  The column represented in the JSON notation: <br><blockquote><code><font color="black">{ <br> name: <font color="#A31515">"emailAddress"</font> , <font color="#008000">// </font> <br> value: <font color="#A31515">"arin@example.com"</font> , <font color="#008000">// </font> <br> timestamp: 123456789 <font color="#008000">//  </font> <br> }</font></code> </blockquote> <br>  It's all.  For simplicity, you can omit the timestamp.  And take the column as a name / value pair.  Also, it is worth noting that both the name and the value are binary (technically byte []) and can be of any length. <br><br><h5>  SuperColumn </h5><br>  A supercolumn (SuperColumn) is a collection of a binary name and value, which is essentially a table containing an unlimited number of columns, with a key ‚Äî the name of a column.  Again, imagine this as JSON: <br><blockquote> <code><font color="black">{ <br> name: <font color="#A31515">"homeAddress"</font> , <br> <font color="#008000">//   :</font> <br> value: { <br> <font color="#008000">//  -   </font> <br> street: {name: <font color="#A31515">"street"</font> , value: <font color="#A31515">"1234 x street"</font> , timestamp: 123456789}, <br> city: {name: <font color="#A31515">"city"</font> , value: <font color="#A31515">"san francisco"</font> , timestamp: 123456789}, <br> zip: {name: <font color="#A31515">"zip"</font> , value: <font color="#A31515">"94107"</font> , timestamp: 123456789}, <br> } <br> }</font></code> </blockquote> <br><h5>  Column vs Supercolumn </h5><br>  Both columns and supercolumns are pairs of name and value.  The key difference is that the value of a regular column is ‚Äúrow‚Äù, and the value of a supercolumn is a table of columns.  This is the main difference.  Their values ‚Äã‚Äãcontain different data types.  Another minor difference is that the supercolumn does not contain a timestamp. <br><br><h5>  Before we begin to combine </h5><br>  Before going further, I want to simplify our notation with two things: 1) say goodbye to time stamps in columns and 2) pull the names of columns and supercolumns out, so that it will look like a key / value pair.  So we move from: <br><blockquote> <code><font color="black">{ <br> name: <font color="#A31515">"homeAddress"</font> , <br> value: { <br> street: {name: <font color="#A31515">"street"</font> , value: <font color="#A31515">"1234 x street"</font> , timestamp: 123456789}, <br> city: {name: <font color="#A31515">"city"</font> , value: <font color="#A31515">"san francisco"</font> , timestamp: 123456789}, <br> zip: {name: <font color="#A31515">"zip"</font> , value: <font color="#A31515">"94107"</font> , timestamp: 123456789}, <br> } <br> }</font></code> </blockquote>  to <br><blockquote> <code><font color="black">homeAddress: { <br> street: <font color="#A31515">"1234 x street"</font> , <br> city: <font color="#A31515">"san francisco"</font> , <br> zip: <font color="#A31515">"94107"</font> , <br> }</font></code> </blockquote> <br><br><h4>  Group them </h4><br>  There is a structure used for grouping both columns and supercolumns ... this structure is called the family of columns (ColumnFamily) and exists in two variations respectively - regular and super. <br><br><h5>  Column family </h5><br>  A column family is a structure containing an unlimited number of rows.  Wow, did you say the strings?  Yes - the lines :) To make it easier to keep in mind, just think of them as the rows of a table in a RDBMS. <br><br>  So, each row has a key set by the client (you) and contains a set of columns.  Again, the keys in the set are the column names and the values ‚Äã‚Äãare the columns themselves: <br><blockquote> <code><font color="black">UserProfile = { <br> phatduckk: { <font color="#008000">//      </font> <br> <font color="#008000">//         </font> <br> username: <font color="#A31515">"phatduckk"</font> , <br> email: <font color="#A31515">"phatduckk@example.com"</font> , <br> phone: <font color="#A31515">"(900) 976-6666"</font> <br> }, <font color="#008000">//  </font> <br> ieure: { <font color="#008000">//       </font> <br> <font color="#008000">//           </font> <br> username: <font color="#A31515">"ieure"</font> , <br> email: <font color="#A31515">"ieure@example.com"</font> , <br> phone: <font color="#A31515">"(888) 555-1212"</font> <br> age: <font color="#A31515">"66"</font> , <br> gender: <font color="#A31515">"undecided"</font> <br> }, <br> }</font></code> </blockquote> <br>  Remember: for simplicity, we only show the value of a column, but in fact the values ‚Äã‚Äãin the set are a whole column. <br><br>  You can think of it as a hash table / dictionary or associative array.  If you started thinking like that, then you are on the right track. <br><br>  I want to draw your attention to the fact that at this level there is no mandatory scheme.  Rows do not have a predefined list of columns that they contain.  In our example above, you can see that the row with the key ‚Äúieure‚Äù contains columns with the names ‚Äúage‚Äù and ‚Äúgender‚Äù, while the string identified by the key ‚Äúphatduckk‚Äù does not contain.  This is 100% flexibility: one row can contain 1989 columns, while the other will be only 2. One row can contain a column with the name ‚Äúfoo‚Äù, while everyone else will not.  Here it is - the prospect of a lack of a scheme in Cassandra. <br><br><h5>  The column family can also be super. </h5><br>  So, the column family can be of type Standard or Super. <br><br>  What we looked at above is an example of the Standard type.  It is standard because all its rows contain a table of ordinary (not super) columns ... there are no supercolumns. <br><br>  If the column family is of type Super, then the opposite: each row contains a set of supercolumns.  A set where the keys are the names of the supercolumns, and the values ‚Äã‚Äãare the supercolumns themselves.  And just for clarity: the family of supercolumns does not contain the usual columns.  Here is an example: <br><blockquote> <code><font color="black">AddressBook = { <br> phatduckk: { <font color="#008000">//      </font> <br> <font color="#008000">//  -    </font> <br> <br> <font color="#008000">//         </font> <br> <font color="#008000">//    -   </font> <br> <font color="#008000">//     -     </font> <br> friend1: {street: <font color="#A31515">"8th street"</font> , zip: <font color="#A31515">"90210"</font> , city: <font color="#A31515">"Beverley Hills"</font> , state: <font color="#A31515">"CA"</font> }, <br> <br> <font color="#008000">//    John'    phatduckk'</font> <br> John: {street: <font color="#A31515">"Howard street"</font> , zip: <font color="#A31515">"94404"</font> , city: <font color="#A31515">"FC"</font> , state: <font color="#A31515">"CA"</font> }, <br> Kim: {street: <font color="#A31515">"X street"</font> , zip: <font color="#A31515">"87876"</font> , city: <font color="#A31515">"Balls"</font> , state: <font color="#A31515">"VA"</font> }, <br> Tod: {street: <font color="#A31515">"Jerry street"</font> , zip: <font color="#A31515">"54556"</font> , city: <font color="#A31515">"Cartoon"</font> , state: <font color="#A31515">"CO"</font> }, <br> Bob: {street: <font color="#A31515">"Q Blvd"</font> , zip: <font color="#A31515">"24252"</font> , city: <font color="#A31515">"Nowhere"</font> , state: <font color="#A31515">"MN"</font> }, <br> ... <br> <font color="#008000">//          </font> <br> }, <font color="#008000">//  </font> <br> ieure: { <font color="#008000">//       </font> <br> joey: {street: <font color="#A31515">"A ave"</font> , zip: <font color="#A31515">"55485"</font> , city: <font color="#A31515">"Hell"</font> , state: <font color="#A31515">"NV"</font> }, <br> William: {street: <font color="#A31515">"Armpit Dr"</font> , zip: <font color="#A31515">"93301"</font> , city: <font color="#A31515">"Bakersfield"</font> , state: <font color="#A31515">"CA"</font> }, <br> }, <br> }</font></code> </blockquote> <br><h5>  Key space </h5><br>  Key space (Keyspace) is what unites all your data.  All your column families are in key space.  Your key space will probably match your application. <br><br>  So, the key space can contain several column families, but this does not mean that they will somehow depend on each other.  For example, they cannot be JOIN'ed, like tables in MySQL.  Also, just because ColumnFamily_1 contains a string with the key "phatduckk", it does not mean that ColumnFamily_2 also contains it. <br><br><h4>  Sorting </h4><br>  So, we figured out what data containers exist, but another key element of the data model is how data is sorted.  In Cassandra, you cannot make such queries as in SQL - you cannot specify how you want to sort the data when you make a selection (among other differences).  The data is sorted as soon as you record it in a cluster and always remain sorted.  This is a huge improvement in reading performance, but in exchange for this advantage, you need to make sure that you plan your data model in such a way that it is possible to satisfy your access schemes. <br><br>  Columns inside rows are always sorted by column name.  This is important, so I repeat: the columns are always sorted by name!  How exactly the names are compared depends on the CompareWith parameter of the column family.  By default, you have the following options: BytesType, UTF8Type, LexicalUUIDType, TimeUUIDType, AsciiType, and LongType.  Each of these options treats column names as different data types, providing some flexibility.  For example: using LongType will treat column names as 64-bit integers.  Let's try and clarify this by looking at the data before and after sorting: <br><blockquote> <code><font color="black"><font color="#008000">//       ,    <br> // Cassandra ""      .    <br> // ,    -        </font> <br> {name: 123, value: <font color="#A31515">"hello there"</font> }, <br> {name: 832416, value: <font color="#A31515">"kjjkbcjkcbbd"</font> }, <br> {name: 3, value: <font color="#A31515">"101010101010"</font> }, <br> {name: 976, value: <font color="#A31515">"kjjkbcjkcbbd"</font> }</font></code> </blockquote> <br>  So, given that we use the LongType variant, these columns will look like this after sorting: <br><blockquote> <code><font color="black"><font>&lt;!--     storage-conf.xml --&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="LongType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="CF_NAME_HERE"</font> <font color="#0000ff">/&gt;</font></font></code> </blockquote> <blockquote> <code><font color="black"><font color="#008000">// ,     </font> <br> <font color="#008000">// ,      </font> <br> {name: 3, value: <font color="#A31515">"101010101010"</font> }, <br> {name: 123, value: <font color="#A31515">"hello there"</font> }, <br> {name: 976, value: <font color="#A31515">"kjjkbcjkcbbd"</font> }, <br> {name: 832416, value: <font color="#A31515">"kjjkbcjkcbbd"</font> }</font></code> </blockquote> <br>  As you can see, the column names were compared as if they were 64-bit integers.  If we now use another version of CompareWith, we would get a different result.  If we set CompareWith as UTF8Type, the column names would be treated as UTF8 strings and formed the following order: <br><blockquote> <code><font color="black"><font>&lt;!--     storage-conf.xml --&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="UTF8Type"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="CF_NAME_HERE"</font> <font color="#0000ff">/&gt;</font></font></code> </blockquote> <blockquote> <code><font color="black"><font color="#008000">//        UTF8</font> <br> {name: 123, value: <font color="#A31515">"hello there"</font> }, <br> {name: 3, value: <font color="#A31515">"101010101010"</font> }, <br> {name: 832416, value: <font color="#A31515">"kjjkbcjkcbbd"</font> }, <br> {name: 976, value: <font color="#A31515">"kjjkbcjkcbbd"</font> }</font></code> </blockquote> <br>  A completely different result! <br><br>  This sorting principle applies to supercolumns, but we have another dimension to work with: we define not only how super-columns should be sorted, but also how columns inside the supercolumns should be sorted.  Sorting columns within super columns is determined by the value of the CompareSubcolumnsWith parameter.  Here is an example: <br><blockquote> <code><font color="black"><font color="#008000">//       </font> <br> <font color="#008000">//       </font> <br> <br> { <font color="#008000">//    </font> <br> name: <font color="#A31515">"workAddress"</font> , <br> <font color="#008000">//    </font> <br> value: { <br> street: {name: <font color="#A31515">"street"</font> , value: <font color="#A31515">"1234 x street"</font> }, <br> city: {name: <font color="#A31515">"city"</font> , value: <font color="#A31515">"san francisco"</font> }, <br> zip: {name: <font color="#A31515">"zip"</font> , value: <font color="#A31515">"94107"</font> } <br> } <br> }, <br> { <font color="#008000">//      </font> <br> name: <font color="#A31515">"homeAddress"</font> , <br> <font color="#008000">//    </font> <br> value: { <br> street: {name: <font color="#A31515">"street"</font> , value: <font color="#A31515">"1234 x street"</font> }, <br> city: {name: <font color="#A31515">"city"</font> , value: <font color="#A31515">"san francisco"</font> }, <br> zip: {name: <font color="#A31515">"zip"</font> , value: <font color="#A31515">"94107"</font> } <br> } <br> }</font></code> </blockquote> <br>  Now, if we decide to set CompareSubcolumnsWith and CompareWith to UTF8Type, we get the following result: <br><blockquote> <code><font color="black"><font color="#008000">//   </font> <br> <br> { <br> name: <font color="#A31515">"homeAddress"</font> , <br> value: { <br> city: {name: <font color="#A31515">"city"</font> , value: <font color="#A31515">"san francisco"</font> }, <br> street: {name: <font color="#A31515">"street"</font> , value: <font color="#A31515">"1234 x street"</font> }, <br> zip: {name: <font color="#A31515">"zip"</font> , value: <font color="#A31515">"94107"</font> } <br> } <br> }, <br> { <br> name: <font color="#A31515">"workAddress"</font> , <br> value: { <br> city: {name: <font color="#A31515">"city"</font> , value: <font color="#A31515">"san francisco"</font> }, <br> street: {name: <font color="#A31515">"street"</font> , value: <font color="#A31515">"1234 x street"</font> }, <br> zip: {name: <font color="#A31515">"zip"</font> , value: <font color="#A31515">"94107"</font> } <br> } <br> }</font></code> </blockquote> <br>  I want to note that in the last example, CompareSubcolumnsWith and CompareWith are both set to UTF8Type, but this is not necessary.  You can combine the values ‚Äã‚Äãof the CompareSubcolumnsWith and CompareWith parameters as you like. <br><br>  And the last thing I want to mention in connection with sorting is that you can write your own class to do the sorting.  The sorting mechanism connects independently ... you can set CompareSubcolumnsWith and / or CompareWith any suitable class name as soon as this class implements the org.apache.cassandra.db.marshal.IType interface (that is, you can create your own comparison scheme for sorting) . <br><br><br><h4>  Schematic example </h4><br>  Okay, now we have all the pieces of the puzzle, so let's put them together and make a simple blog app.  We will model the application with the following specifications: <br><ul><li>  single blog support </li><li>  there may be several authors </li><li>  records contain title, body, unique label and publication date. </li><li>  records can be associated with any number of tags </li><li>  people can leave comments, but cannot register: they re-enter information about themselves each time (just simplify) </li><li>  comments contain the text, the time when they were left, and the name of the commentator </li><li>  it should be possible to show all posts in the reverse order of chronological order (the newest is above) </li><li>  should be able to show all posts by tag in reverse order of chronological </li></ul>  Each of the following sections will describe the column family, which we will define in the key space of our application, show the definition in xml, say why we chose one or another sorting option (s), and also show the data of the column family as JSON. <br><br><h5>  Authors column family </h5><br>  Modeling the authors' column family is fairly basic;  we will not do anything cool here.  We will assign each author a string and a key and this will be the full name of the author.  Each column in the row will represent a specific parameter of the author's profile. <br><br>  This is an example of using strings as objects ... in this case, Author objects.  With this approach, each column will serve as an object property.  Very simple.  I want to note that since there is no definition of how the columns should be represented in a row, we can define this definition ourselves. <br><br>  We will retrieve rows from our column family using the key and select all columns for each row (that is, for example, we will not select only the first 3 columns from the row with the key ‚Äúfoo‚Äù).  This means that for us it does not matter how the columns will be sorted, so we will use the BytesType sort, because it does not require any validation for the column names. <br><blockquote> <code><font color="black"><font>&lt;!--</font> <br> <font>ColumnFamily: Authors</font> <br> <font>      .</font> <br> <br> <font>  =&gt;   (,   )</font> <br> <font> :   (email, bio  ..)</font> <br> <font> :   </font> <br> <br> <font>:     (      )</font> <br> <br> <font>Authors : { //  </font> <br> <font>Arin Sarkissian : { //  </font> <br> <font>// ,  </font> <br> <font>numPosts: 11,</font> <br> <font>twitter: phatduckk,</font> <br> <font>email: arin@example.com,</font> <br> <font>bio: "bla bla bla"</font> <br> <font>},</font> <br> <font>//   </font> <br> <font>Author 2 {</font> <br> <font>...</font> <br> <font>}</font> <br> <font>}</font> <br> <font>--&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="BytesType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="Authors"</font> <font color="#0000ff">/&gt;</font></font></code> </blockquote> <br><h5>  BlogEntries Column Family </h5><br>  Again, the column family will behave like a simple key / value store.  We will store one record in one line.  Columns in the rows will serve as the recording parameters: title, body, etc.  (as in the previous example).  With a small optimization, we denormalize the tags in one column as a string, separated by commas.  In the output, we will split the value of the column to get a list of tags. <br><br>  The key of each line is a unique label (slug).  So, to select a single record, we will look for it by this tag. <br><blockquote> <code><font color="black"><font>&lt;!--</font> <br> <font>ColumnFamily: BlogEntries</font> <br> <font>      .</font> <br> <br> <font>  =&gt;    (    )</font> <br> <font> :   (, ,  ..)</font> <br> <font> :   </font> <br> <br> <font>:      (     )</font> <br> <br> <font>  :  tags ...     .</font> <br> <font>   JSON,     ,  ,</font> <br> <font>     ,    ,    </font> <br> <br> <font>BlogEntries : { //  </font> <br> <font>i-got-a-new-guitar : { //   -    (slug)</font> <br> <font>title: This is a blog entry about my new, awesome guitar,</font> <br> <font>body: this is a cool entry. etc etc yada yada</font> <br> <font>author: Arin Sarkissian //      Authors</font> <br> <font>tags: life,guitar,music</font> <br> <font>pubDate: 1250558004   //     unixtime</font> <br> <font>slug: i-got-a-new-guitar</font> <br> <font>},</font> <br> <font>//  </font> <br> <font>another-cool-guitar : {</font> <br> <font>...</font> <br> <font>tags: guitar,</font> <br> <font>slug: another-cool-guitar</font> <br> <font>},</font> <br> <font>scream-is-the-best-movie-ever : {</font> <br> <font>...</font> <br> <font>tags: movie,horror,</font> <br> <font>slug: scream-is-the-best-movie-ever</font> <br> <font>}</font> <br> <font>}</font> <br> <font>--&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="BytesType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="BlogEntries"</font> <font color="#0000ff">/&gt;</font></font></code> </blockquote> <br><h5>  TaggedPosts Column Family </h5><br>  So finally there will be something interesting.  This column family will show us a new level.  It will be responsible for storing links between tags and posts.  It will not only store links, but also allow us to select all the blog entries by a specific tag, in a sorted order (remember everything we know about sorting?). <br><br>  The peculiarity of the solution that I want to point out is that the logic of our application should attach the tag "__notag__" to each BlogEntry entry (I just invented it).  This tag will allow us to use this family of columns as well for storing a list of all blog entries in a sorted form.  This is a small trick that will make it possible to use only one column family for two selections: ‚Äúshow all recent posts‚Äù and ‚Äúshow all recent posts with the tag` foo` ‚Äù. <br><br>  According to this data model, records with three tags will correspond to 1 column in 4 lines.  One for each tag and one for the "__notag__" service tag. <br><br>  Since we decided that we would display the list of records in chronological order, we need to make the column names of the type TimeUUID and set the CompareWith parameter to TimeUUIDType.  This will sort the columns by time.  So using queries like ‚Äúget the last 10 entries tagged with` foo` ‚Äùwill be a very efficient operation. <br><br>  Now, when we want to display the last 10 entries (on the main, for example), we will need: <br><ol><li>  take the last 10 columns by the key "__notag__" (tag "all posts") </li><li>  cycle through this set of columns </li><li>  in the loop, we know that the value of each column is the key of the row in the BlogEntries column family </li><li>  so we use this key to get the row for this entry from the BlogEntries column family.  so we get all the data about the record </li><li>  one of the columns in the BlogEntries row is named author and its value is the key in the Authors column family, and we use it to get the author‚Äôs profile data </li><li>  So, we have data of a post and data of the author </li><li>  next we break down the tagged column to get the list of tags </li><li>  now we have everything to display this post (for now, without comments, this is a page of the list of posts, and not a specific post) </li></ol><br>  We can do this procedure using any tag ... it works for both "all records" and "records with the` foo` tag. "  Seems not bad. <br><blockquote> <code><font color="black"><font>&lt;!--</font> <br> <font>ColumnFamily: TaggedPosts</font> <br> <font>   ,    BlogEntries  </font> <br> <br> <font>  =&gt; </font> <br> <font> : TimeUUIDType</font> <br> <font> :      BlogEntries</font> <br> <br> <font>:      "foo"</font> <br> <br> <font>      ,      </font> <br> <font>       __notag__,  "   ".</font> <br> <font>       ...</font> <br> <font> ,     "-  + 1"    .</font> <br> <br> <font>TaggedPosts : { //  </font> <br> <font>//     "guitar"</font> <br> <font>guitar : {</font> <br> <font>timeuuid_1 : i-got-a-new-guitar,</font> <br> <font>timeuuid_2 : another-cool-guitar,</font> <br> <font>},</font> <br> <font>//    </font> <br> <font>__notag__ : {</font> <br> <font>timeuuid_1b : i-got-a-new-guitar,</font> <br> <br> <font>// ,        "guitar"</font> <br> <font>timeuuid_2b : another-cool-guitar,</font> <br> <br> <font>//   -   "movie"</font> <br> <font>timeuuid_2b : scream-is-the-best-movie-ever,</font> <br> <font>},</font> <br> <font>//     "movie"</font> <br> <font>movie: {</font> <br> <font>timeuuid_1c: scream-is-the-best-movie-ever</font> <br> <font>}</font> <br> <font>}</font> <br> <font>--&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="TimeUUIDType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="TaggedPosts"</font> <font color="#0000ff">/&gt;</font></font></code> </blockquote> <br><h5>  Column family Comments </h5><br>  The last thing we have to figure out is how to model comments.  And here, finally, we need supercolumns. <br><br>  We will have 1 line per post.  As keys, we will use the same keys that were used for posts.  In the lines we will have supercolumns, for each comment is your own.  The names of supercolumns will be unique identifiers of the TimeUUIDType type.  So we guarantee that all comments to the post are sorted in chronological order.  Columns in each supercolumn will be comment parameters (commentator name, comment time, etc.) <br><br>  So, it's pretty simple so far ... nothing extraordinary. <br><blockquote> <code><font color="black"><font>&lt;!--</font> <br> <font>ColumnFamily: Comments</font> <br> <font>   </font> <br> <br> <font>  =&gt;    BlogEntries</font> <br> <font> : TimeUUIDType</font> <br> <br> <font>:     </font> <br> <br> <font>Comments : {</font> <br> <font>//   scream-is-the-best-movie-ever</font> <br> <font>scream-is-the-best-movie-ever : {</font> <br> <font>//   </font> <br> <font>timeuuid_1 : { //  </font> <br> <font>//     -  </font> <br> <font>commenter: Joe Blow,</font> <br> <font>email: joeb@example.com,</font> <br> <font>comment: you're a dumb douche, the godfather is the best movie ever</font> <br> <font>commentTime: 1250438004</font> <br> <font>},</font> <br> <br> <font>...    scream-is-the-best-movie-ever</font> <br> <br> <font>//   -  </font> <br> <font>timeuuid_2 : {</font> <br> <font>commenter: Some Dude,</font> <br> <font>email: sd@example.com,</font> <br> <font>comment: be nice Joe Blow this isnt youtube</font> <br> <font>commentTime: 1250557004</font> <br> <font>},</font> <br> <font>},</font> <br> <br> <font>//   i-got-a-new-guitar</font> <br> <font>i-got-a-new-guitar : {</font> <br> <font>timeuuid_1 : {</font> <br> <font>commenter: Johnny Guitar,</font> <br> <font>email: guitardude@example.com,</font> <br> <font>comment: nice axe dawg...</font> <br> <font>commentTime: 1250438004</font> <br> <font>},</font> <br> <font>}</font> <br> <br> <font>..</font> <br> <font>//     </font> <br> <font>}</font> <br> <font>--&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="TimeUUIDType"</font> <font color="#ff0000">ColumnType</font> <font color="#0000ff">="Super"</font> <br> <font color="#ff0000">CompareSubcolumnsWith</font> <font color="#0000ff">="BytesType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="Comments"</font> <font color="#0000ff">/&gt;</font></font></code> </blockquote> <br><br><h4>  Woot! </h4><br>  It's all.  Our little blog app is modeled and ready to go.  Get a little digestion, and you will end up with a very small piece of XML in your storage-conf.xml: <br><blockquote> <code><font color="black"><font color="#0000ff">&lt;</font> <font color="#800000">Keyspace</font> <font color="#ff0000">Name</font> <font color="#0000ff">="BloggyAppy"</font> <font color="#0000ff">&gt;</font> <br> <font>&lt;!-- ... --&gt;</font> <br> <font>&lt;!-- CF definitions --&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="BytesType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="Authors"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="BytesType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="BlogEntries"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="TimeUUIDType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="TaggedPosts"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">ColumnFamily</font> <font color="#ff0000">CompareWith</font> <font color="#0000ff">="TimeUUIDType"</font> <font color="#ff0000">Name</font> <font color="#0000ff">="Comments"</font> <br> <font color="#ff0000">CompareSubcolumnsWith</font> <font color="#0000ff">="BytesType"</font> <font color="#ff0000">ColumnType</font> <font color="#0000ff">="Super"</font> <font color="#0000ff">/&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">Keyspace</font> <font color="#0000ff">&gt;</font></font></code> </blockquote> <br>  Now all you have to do is figure out how to write and read data from Cassandra.  This can be done using the <a href="http://wiki.apache.org/cassandra/ThriftInterface">Thrift Interface</a> .  The <a href="http://wiki.apache.org/cassandra/API">Cassandra API wiki page</a> did a decent job of explaining how to work with it, so I won't go into all these details.  But, in general, you can simply compile the cassandra.thrift file and use the generated code to access the API.  You can also take advantage of <a href="http://blog.evanweaver.com/files/doc/fauna/cassandra/files/README_rdoc.html">a Ruby</a> <a href="http://github.com/digg/lazyboy">client</a> or <a href="http://github.com/digg/lazyboy">a Python client</a> . <br><br>  Okay ... I hope all this has made you feel what a hell of a supercolumn it really is and you will start creating cool applications. <br><br>  <i>From the translator: I tried to translate as close as possible to the original.</i>  <i>I hope for constructive criticism.</i> <i><br><br></i>  <i><b>Update</b> : thanks to <a href="https://habrahabr.ru/users/honeyman/" class="user_link">Honeyman</a> for the fix and <a href="http://en.wikipedia.org/wiki/Parkinson%27s_Law_of_Triviality">link</a></i> <br><br>  <i>08/24/2010: Transferred to the NoSQL blog</i> </div><p>Source: <a href="https://habr.com/ru/post/100075/">https://habr.com/ru/post/100075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../100069/index.html">Mobile holder</a></li>
<li><a href="../100070/index.html">Is social project moderation (web 2.0) a reality?</a></li>
<li><a href="../100071/index.html">Famous writers began selling books directly to Amazon.</a></li>
<li><a href="../100072/index.html">Electronic queue of applicants</a></li>
<li><a href="../100074/index.html">How to improve the efficiency of the data center?</a></li>
<li><a href="../100076/index.html">Introducing the fastest VP8 decoder in the world: ffvp8</a></li>
<li><a href="../100077/index.html">Solar drone set a new record - 2 weeks in the air</a></li>
<li><a href="../100078/index.html">Definition of IP geography - are there accurate services?</a></li>
<li><a href="../100080/index.html">IPad Emulator</a></li>
<li><a href="../100081/index.html">Maintaining a balance between functionality and compatibility when developing an application</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>