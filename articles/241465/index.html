<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Advanced use of objects in javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post goes beyond the daily use of objects in javascript. The basics of working with objects are for the most part as simple as using JSON notatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Advanced use of objects in javascript</h1><div class="post__text post__text-html js-mediator-article"> This post goes beyond the daily use of objects in javascript.  The basics of working with objects are for the most part as simple as using JSON notation.  However, JavaScript allows you to use thin tools, with which you can create objects in some interesting and useful ways and which is now available in the latest versions of modern browsers. <br><a name="habracut"></a><br>  The last two questions that will be addressed - <code>Proxy</code> and <code>Symbol</code> are related to the ECMAScript 6 specification, are partially implemented and implemented only in some of the modern browsers. <br><br><h4>  Getters and Setters </h4><br>  Getters and setters have been available in JavaScript for some time, but I didn‚Äôt notice that I had to use them often.  Often, I write ordinary functions to get properties, something like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {string} prefix * @constructor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Product</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * @private * @type {string} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix_ = prefix; <span class="hljs-comment"><span class="hljs-comment">/** * @private * @type {string} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_ = <span class="hljs-string"><span class="hljs-string">""</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * @param {string} newType */</span></span> Product.prototype.setType = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newType</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_ = newType; }; <span class="hljs-comment"><span class="hljs-comment">/** * @return {string} */</span></span> Product.prototype.type = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix_ + <span class="hljs-string"><span class="hljs-string">": "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> product = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(<span class="hljs-string"><span class="hljs-string">"fruit"</span></span>); product.setType(<span class="hljs-string"><span class="hljs-string">"apple"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(product.type()); <span class="hljs-comment"><span class="hljs-comment">//logs fruit: apple</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/26/">jsfiddle</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Using a getter you can simplify this code. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {string} prefix * @constructor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Product</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * @private * @type {number} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix_ = prefix; <span class="hljs-comment"><span class="hljs-comment">/** * @private * @type {string} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_ = <span class="hljs-string"><span class="hljs-string">""</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * @param {string} newType */</span></span> Product.prototype = { <span class="hljs-comment"><span class="hljs-comment">/** * @return {string} */</span></span> get type () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix_ + <span class="hljs-string"><span class="hljs-string">": "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_; }, <span class="hljs-comment"><span class="hljs-comment">/** * @param {string} */</span></span> set type (newType) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_ = newType; } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> product = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Product(<span class="hljs-string"><span class="hljs-string">"fruit"</span></span>); product.type = <span class="hljs-string"><span class="hljs-string">"apple"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(product.type); <span class="hljs-comment"><span class="hljs-comment">//logs "fruit: apple" console.log(product.type = "orange"); //logs "orange" console.log(product.type); //logs "fruit: orange"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/3/">jsfiddle</a> <br><br>  The code remains a bit redundant, and the syntax is a bit unusual, but the benefits of using <code>get</code> and <code>set</code> become more pronounced during their direct use.  I found for myself that: <br><br><pre> <code class="javascript hljs">product.type = <span class="hljs-string"><span class="hljs-string">"apple"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(product.type);</code> </pre><br>  much more readable than: <br><br><pre> <code class="javascript hljs">product.setType(<span class="hljs-string"><span class="hljs-string">"apple"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(product.type());</code> </pre><br>  although my built-in alarm for bad javascript is still triggered when I see direct access and setting properties to instances of the object.  For a long time, I was taught by bugs and technical requirements to avoid arbitrarily assigning properties to instances of a class, since this certainly leads to the fact that information is distributed among them all.  There is also some nuance in the order in which the set values ‚Äã‚Äãare returned, see the example below. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(product.type = <span class="hljs-string"><span class="hljs-string">"orange"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//logs "orange" console.log(product.type); //logs "fruit: orange"</span></span></code> </pre><br>  Please note that first <code>‚Äúorange‚Äù</code> is output to the console and only then <code>‚Äúfruit: orange‚Äù</code> .  The getter is not executed while the set value is being returned, so with this form of abbreviated notation you may stumble into trouble.  Returns using <code>set</code> are ignored.  Add <code>return this.type;</code>  to <code>set</code> does not solve this problem.  This is usually solved by reusing the set value, but there may be problems with the property that has a getter. <br><br><h4>  defineProperty </h4><br>  The syntax <code>get propertyname ()</code> works with object literals and in the previous example I assigned a literal to the <code>Product.prototype</code> object.  There is nothing wrong with that, but using literals like this complicates the prototype call chain to implement inheritance.  It is possible to define getters and setters in the prototype without using literals - using <code>defineProperty</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** * @param {string} prefix * @constructor */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Product</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prefix</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * @private * @type {number} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix_ = prefix; <span class="hljs-comment"><span class="hljs-comment">/** * @private * @type {string} */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_ = <span class="hljs-string"><span class="hljs-string">""</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** * @param {string} newType */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(Product.prototype, <span class="hljs-string"><span class="hljs-string">"type"</span></span>, { <span class="hljs-comment"><span class="hljs-comment">/** * @return {string} */</span></span> get: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prefix_ + <span class="hljs-string"><span class="hljs-string">": "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_; }, <span class="hljs-comment"><span class="hljs-comment">/** * @param {string} */</span></span> set: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">newType</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.type_ = newType; } });</code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/4/">jsfiddle</a> <br><br>  The behavior of this code is the same as in the previous example.  Instead of adding getters and setters, preference is given to <code>defineProperty</code> .  The third argument in <code>defineProperty</code> is the handle and, in addition to <code>set</code> and <code>get</code> it gives you the opportunity to customize accessibility and set the value.  With <code>defineProperty</code> you can create something like a constant ‚Äî a property that will never be deleted or redefined. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, }; <span class="hljs-comment"><span class="hljs-comment">//A normal object property console.log(obj.foo); //logs "bar" obj.foo = "foobar"; console.log(obj.foo); //logs "foobar" delete obj.foo; console.log(obj.foo); //logs undefined Object.defineProperty(obj, "foo", { value: "bar", }); console.log(obj.foo); //logs "bar", we were able to modify foo obj.foo = "foobar"; console.log(obj.foo); //logs "bar", write failed silently delete obj.foo; console.log(obj.foo); //logs bar, delete failed silently</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/46/">jsfiddle</a> <br><br>  Result: <br><br><pre> <code class="javascript hljs">bar foobar <span class="hljs-literal"><span class="hljs-literal">undefined</span></span> bar bar bar</code> </pre><br>  The last two attempts to redefine <code>foo.bar</code> in the example failed (even if they were not interrupted by an error message), because this <code>defineProperty</code> behavior is to prohibit changes.  To change this behavior, you can use the <code>configurable</code> and <code>writable</code> .  If you use strict mode, errors will be thrown, as they are common JavaScript errors. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo); <span class="hljs-comment"><span class="hljs-comment">//logs "bar" obj.foo = "foobar"; console.log(obj.foo); //logs "foobar" delete obj.foo; console.log(obj.foo); //logs undefined</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/47/">jsfiddle</a> <br><br>  The <code>configurable</code> key prevents the property from being deleted from the object.  In addition, it makes it possible to prevent the subsequent change of a property with another call to <code>defineProperty</code> .  The <code>writable</code> key allows you to write to a property or change its value. <br><br>  If <code>configurable</code> set to <code>false</code> (as is the default), attempts to call <code>defineProperty</code> a second time will cause an error to be thrown. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>, }); <span class="hljs-comment"><span class="hljs-comment">// Uncaught TypeError: Cannot redefine property: foo</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/11/">jsfiddle</a> <br><br>  If <code>configurable</code> set to <code>true</code> , then you can change the property in the future.  This can be used to change the value of a recordable property. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); obj.foo = <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo); <span class="hljs-comment"><span class="hljs-comment">// logs "bar", write failed Object.defineProperty(obj, "foo", { value: "foobar", configurable: true, }); console.log(obj.foo); // logs "foobar"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/12/">jsfiddle</a> <br><br>  You also need to pay attention to the fact that the values ‚Äã‚Äãdefined with <code>defineProperty</code> not iterated in a <code>for in</code> loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, inventory; inventory = { <span class="hljs-string"><span class="hljs-string">"apples"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"oranges"</span></span>: <span class="hljs-number"><span class="hljs-number">13</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(inventory, <span class="hljs-string"><span class="hljs-string">"strawberries"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inventory) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i, inventory[i]); }</code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/13/">jsfiddle</a> <br><br><pre> <code class="javascript hljs">apples <span class="hljs-number"><span class="hljs-number">10</span></span> oranges <span class="hljs-number"><span class="hljs-number">13</span></span></code> </pre><br>  To allow this, you must use the <code>enumerable</code> property <code>enumerable</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, inventory; inventory = { <span class="hljs-string"><span class="hljs-string">"apples"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"oranges"</span></span>: <span class="hljs-number"><span class="hljs-number">13</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(inventory, <span class="hljs-string"><span class="hljs-string">"strawberries"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inventory) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i, inventory[i]); }</code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/14/">jsfiddle</a> <br><br><pre> <code class="javascript hljs">apples <span class="hljs-number"><span class="hljs-number">10</span></span> oranges <span class="hljs-number"><span class="hljs-number">13</span></span> strawberries <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  You can use <code>isPropertyEnumerable</code> to check whether a property appears in a <code>for in</code> <code>isPropertyEnumerable</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, inventory; inventory = { <span class="hljs-string"><span class="hljs-string">"apples"</span></span>: <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-string"><span class="hljs-string">"oranges"</span></span>: <span class="hljs-number"><span class="hljs-number">13</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(inventory, <span class="hljs-string"><span class="hljs-string">"strawberries"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(inventory.propertyIsEnumerable(<span class="hljs-string"><span class="hljs-string">"apples"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//console logs true console.log(inventory.propertyIsEnumerable("strawberries")); //console logs false</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/mohb4fx2/21/">jsfiddle</a> <br><br>  Calling <code>propertyIsEnumerable</code> will also return <code>false</code> for properties defined above in a chain of prototypes, or for properties not defined in any other way for this object, which, however, is obvious. <br>  And finally, a few words about the use of <code>defineProperty</code> : it will be an error to combine the <code>set</code> and <code>get</code> access methods with <code>writable: true</code> or combine them with <code>value</code> .  Defining a property with a number will result in the number to a string, as it would in any other circumstances.  You can also use <code>defineProperty</code> to define <code>value</code> as a function. <br><br><h4>  defineProperties </h4><br><br>  There is also <code>defineProperties</code> .  This method allows you to define several properties at once.  I caught the eye of jsperf, comparing the use of <code>defineProperties</code> with <code>defineProperty</code> and, at least in Chrome, there was not much difference in which of the methods to use. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = {} <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperties(foo, { <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bar); } }, }); foo.bar = <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>; foo.foo(); <span class="hljs-comment"><span class="hljs-comment">//logs "foobar"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/rxopg5qe/1/">jsfiddle</a> <br><br><h4>  Object.create </h4><br><br>  <code>Object.create</code> is an alternative to <code>new</code> , which <code>Object.create</code> it possible to create an object with a specific prototype.  This function takes two arguments: the first is the prototype from which you want to create an object, and the second is the same descriptor that is used when you call <code>Object.defineProperties</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prototypeDef = { <span class="hljs-attr"><span class="hljs-attr">protoBar</span></span>: <span class="hljs-string"><span class="hljs-string">"protoBar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">protoLog</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.protoBar); } }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertiesDef = { <span class="hljs-attr"><span class="hljs-attr">instanceBar</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"instanceBar"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">instanceLog</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instanceBar); } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prototypeDef, propertiesDef); foo.protoLog(); <span class="hljs-comment"><span class="hljs-comment">//logs "protoBar" foo.instanceLog(); //logs "instanceBar"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/pqdcxnep/">jsfiddle</a> <br><br>  Properties  described using the descriptor, overwrite the corresponding properties of the prototype: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prototypeDef = { <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-string"><span class="hljs-string">"protoBar"</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertiesDef = { <span class="hljs-attr"><span class="hljs-attr">bar</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"instanceBar"</span></span>, }, <span class="hljs-attr"><span class="hljs-attr">log</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bar); } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prototypeDef, propertiesDef); foo.log(); <span class="hljs-comment"><span class="hljs-comment">//logs "instanceBar"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/pqdcxnep/2/">jsfiddle</a> <br><br>  The use of a non-primitive type, for example, <code>Array</code> or <code>Object</code> as the values ‚Äã‚Äãof the defined properties may be an error, since these properties will be shared with all created instances. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prototypeDef = { <span class="hljs-attr"><span class="hljs-attr">protoArray</span></span>: [], }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertiesDef = { <span class="hljs-attr"><span class="hljs-attr">propertyArray</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: [], } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prototypeDef, propertiesDef); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bar = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prototypeDef, propertiesDef); foo.protoArray.push(<span class="hljs-string"><span class="hljs-string">"foobar"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(bar.protoArray); <span class="hljs-comment"><span class="hljs-comment">//logs ["foobar"] foo.propertyArray.push("foobar"); console.log(bar.propertyArray); //also logs ["foobar"]</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/pqdcxnep/4/">jsfiddle</a> <br><br>  This can be avoided by initializing <code>propertyArray</code> with a value of <code>null</code> , then adding the required array, or doing something hipster, for example, using a getter: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prototypeDef = { <span class="hljs-attr"><span class="hljs-attr">protoArray</span></span>: [], }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertiesDef = { <span class="hljs-attr"><span class="hljs-attr">propertyArrayValue_</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">propertyArray</span></span>: { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.propertyArrayValue_) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.propertyArrayValue_ = []; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.propertyArrayValue_; } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prototypeDef, propertiesDef); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bar = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(prototypeDef, propertiesDef); foo.protoArray.push(<span class="hljs-string"><span class="hljs-string">"foobar"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(bar.protoArray); <span class="hljs-comment"><span class="hljs-comment">//logs ["foobar"] foo.propertyArray.push("foobar"); console.log(bar.propertyArray); //logs []</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/pqdcxnep/5/">jsfiddle</a> <br><br>  This is an elegant way to combine variable initialization with their definition.  I think I would prefer to perform the definition of variables along with their initialization, and that would be much better than doing the same in the constructor.  In the past, I wrote a giant constructor, in which there was a lot of code that performs initialization. <br><br>  The previous example demonstrates the need to remember that the expressions passed to any value in the <code>Object.create</code> descriptor <code>Object.create</code> executed at the time the handle is defined.  This is the reason why arrays became common to all instances of a class.  I also recommend never counting on a fixed order when several properties are defined together.  If it is really necessary - to define one property before others - it is better to use <code>Object.defineProperty</code> for it in this case. <br><br>  Since <code>Object.create</code> does not call a constructor function, you cannot use <code>instanceof</code> to verify the identity of objects.  Instead, you can use <code>isPrototypeOf</code> , which checks against the object's <code>prototype</code> property.  This will be MyFunction.prototype in the case of the constructor, or the object passed as the first argument in <code>Object.create</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> prototypeDef = { <span class="hljs-attr"><span class="hljs-attr">protoArray</span></span>: [], }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertiesDef = { <span class="hljs-attr"><span class="hljs-attr">propertyArrayValue_</span></span>: { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }, <span class="hljs-attr"><span class="hljs-attr">propertyArray</span></span>: { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.propertyArrayValue_) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.propertyArrayValue_ = []; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.propertyArrayValue_; } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-comment"><span class="hljs-comment">//old way using instanceof works with constructors console.log(foo1 instanceof Foo); //logs true //You check against the prototype object, not the constructor function console.log(Foo.prototype.isPrototypeOf(foo1)); //true var foo2 = Object.create(prototypeDef, propertiesDef); //can't use instanceof with Object.create, test against prototype object... //...given as first agument to Object.create console.log(prototypeDef.isPrototypeOf(foo2)); //true</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/pqdcxnep/6/">jsfiddle</a> <br><br>  <code>isPrototypeOf</code> goes down the prototype chain and returns <code>true</code> if any of them corresponds to the object with which the comparison is made. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo1Proto = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo2Proto = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(foo1Proto); foo2Proto.bar = <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.create(foo2Proto); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo.foo, foo.bar); <span class="hljs-comment"><span class="hljs-comment">//logs "foo bar" console.log(foo1Proto.isPrototypeOf(foo)); // logs true console.log(foo2Proto.isPrototypeOf(foo)); // logs true</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/pqdcxnep/7/">jsfiddle</a> <br><br><h4>  "Sealing" objects, "freezing" and preventing the possibility of expansion </h4><br><br>  Adding arbitrary properties to random objects and class instances just because there is such an opportunity, the code, at least, does not do better.  On node.js and in modern browsers, in addition to the possibility of limiting changes to individual properties using <code>defineProperty</code> , it is possible to limit the changes to the object as a whole.  <code>Object.preventExtensions</code> , <code>Object.seal</code> and <code>Object.freeze</code> - each of these methods imposes more stringent restrictions on changes to the object.  In strict mode, violation of the restrictions imposed by these methods will lead to an error being thrown, otherwise errors will occur, but ‚Äúsilently‚Äù. <br><br>  The <code>Object.preventExtensions</code> method prevents the addition of new properties to an object.  It does not hurt either to change the properties that are open for writing, or to remove those that are customizable.  In addition, <code>Object.preventExtensions</code> also does not <code>Object.defineProperty</code> use of the <code>Object.defineProperty</code> call to modify existing properties. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, }; obj.bar = <span class="hljs-string"><span class="hljs-string">"bar"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// logs Object {foo: "foo", bar: "bar"} Object.preventExtensions(obj); delete obj.bar; console.log(obj); // logs Object {foo: "foo"} obj.bar = "bar"; console.log(obj); // still logs Object {foo: "foo"} obj.foo = "foobar" console.log(obj); // logs {foo: "foobar"} can still change values</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/dwyuz997/3/">jsfiddle</a> <br><br>  <i>(note that the previous jsfiddle will need to be restarted with an open developer console, since only the final values ‚Äã‚Äãof the object can be displayed in the console)</i> <br><br>  <code>Object.seal</code> goes further.  than <code>Object.preventExtensions</code> .  In addition to prohibiting the addition of new properties to an object, this method also limits the ability to further customize and delete existing properties.  Once the object has been ‚Äúsealed‚Äù, you can no longer modify existing properties with <code>defineProperty</code> .  As mentioned above, violation of these prohibitions in strict mode will result in an error being thrown. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(obj); <span class="hljs-comment"><span class="hljs-comment">//Uncaught TypeError: Cannot redefine property: foo Object.defineProperty(obj, "foo", { value: "bar" });</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/dwyuz997/6/">jsfiddle</a> <br><br>  You also cannot delete properties even if they were originally customizable.  It remains possible only to change the property values. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-attr"><span class="hljs-attr">writable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">configurable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(obj); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.foo); <span class="hljs-comment"><span class="hljs-comment">//logs "foo" obj.foo = "bar"; console.log(obj.foo); //logs "bar" delete obj.foo; //TypeError, cannot delete</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/dwyuz997/9/">jsfiddle</a> <br><br>  In the end, <code>Object.freeze</code> makes the object completely protected from changes.  You cannot add, delete or change the property values ‚Äã‚Äãof a frozen "object".  Also, there is no possibility to use <code>Object.defineProperty</code> to change the values ‚Äã‚Äãof existing properties of an object. <br><br><pre> <code class="javascript hljs"><span class="hljs-meta"><span class="hljs-meta">"use strict"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"foo1"</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze(obj); <span class="hljs-comment"><span class="hljs-comment">//All of the following will fail, and result in errors in strict mode obj.foo = "foo2"; //cannot change values obj.bar = "bar"; //cannot add a property delete obj.bar; //cannot delete a property //cannot call defineProperty on a frozen object Object.defineProperty(obj, "foo", { value: "foo2" });</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/dwyuz997/10/">jsfiddle</a> <br><br>  The methods to check whether the object is ‚Äúfrozen‚Äù, ‚Äúsealed‚Äù or protected from expansion are as follows: <br>  <code>Object.isFrozen</code> , <code>Object.isSealed</code> and <code>Object.isExtensible</code> <br><br><h4>  valueOf and toString </h4><br><br>  You can use <code>valueOf</code> and <code>toString</code> to customize the behavior of an object in context when JavaScript is expecting a primitive value. <br><br>  Here is an example of using <code>toString</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stuff</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff = stuff; } Foo.prototype.toString = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(f + <span class="hljs-string"><span class="hljs-string">"bar"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//logs "foobar"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/LgacxLbL/3/">jsfiddle</a> <br><br>  And <code>valueOf</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stuff</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff = stuff; } Foo.prototype.valueOf = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff.length; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-number"><span class="hljs-number">1</span></span> + f); <span class="hljs-comment"><span class="hljs-comment">//logs 4 (length of "foo" + 1);</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/LgacxLbL/5/">jsfiddle</a> <br><br>  Combining the use of these two methods you can get an unexpected result: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stuff</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff = stuff; } Foo.prototype.valueOf = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff.length; } Foo.prototype.toString = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(f + <span class="hljs-string"><span class="hljs-string">"bar"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//logs "3bar" instead of "foobar" console.log(1 + f); //logs 4 (length of "foo" + 1);</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/LgacxLbL/6/">jsfiddle</a> <br><br>  The proper way to use <code>toString</code> is to make the object hashed: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">stuff</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff = stuff; } Foo.prototype.toString = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.stuff; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; obj[f] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">//logs {foo: true}</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/LgacxLbL/8/">jsfiddle</a> <br><br><h4>  getOwnPropertyNames and keys </h4><br><br>  In order to get all the properties of an object, you can use <code>Object.getOwnPropertyNames</code> .  If you are familiar with python, then it is, in general, similar to the <code>keys</code> method of the dictionary, although the <code>Object.keys</code> method also exists.  The main difference between <code>Object.keys</code> and <code>Object.getOwnPropertyNames</code> is that the latter also returns ‚Äúnon-enumerable‚Äù properties, those that will not be taken into account when running the <code>for in</code> loop. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, <span class="hljs-string"><span class="hljs-string">"bar"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"bar"</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(obj)); <span class="hljs-comment"><span class="hljs-comment">//logs ["foo", "bar"] console.log(Object.keys(obj)); //logs ["foo"]</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/ookcucwm/1/">jsfiddle</a> <br><br><h4>  Symbol </h4><br><br>  <code>Symbol</code> is a special new primitive defined in ECMAScrpt 6 harmony, and it will be available in the next iteration of JavaScript.  You can already try it in Chrome Canary and Firefox Nightly and the following examples on jsfiddle will work only in these browsers, at least for the time of writing this post, in August 2014. <br><br>  <code>Symbol</code> can be used as a way to create and reference object properties. <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); obj[foo] = <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj[foo]); <span class="hljs-comment"><span class="hljs-comment">//logs "foobar"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/5c35eyav/">jsfiddle</a> <br><br>  <code>Symbol</code> is unique and unchanged. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//console logs false, symbols are unique: console.log(Symbol("foo") === Symbol("foo"));</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/5c35eyav/2/">jsfiddle</a> <br><br>  <code>Symbol</code> can be used with <code>Object.defineProperty</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, foo, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj[foo]); <span class="hljs-comment"><span class="hljs-comment">//logs "foobar"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/5c35eyav/3/">jsfiddle</a> <br><br>  Properties defined using <code>Symbol</code> will not be iterated in a <code>for in</code> loop, but the <code>hasOwnProperty</code> call will work fine: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, foo, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>, }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.hasOwnProperty(foo)); <span class="hljs-comment"><span class="hljs-comment">//logs true</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/5c35eyav/4/">jsfiddle</a> <br><br>  <code>Symbol</code> will not fall into an array returned by the <code>Object.getOwnPropertyNames</code> function, but there is an <code>Object. getOwnPropertySymbols</code> method <code>Object. getOwnPropertySymbols</code> <code>Object. getOwnPropertySymbols</code> <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj, foo, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>, }); <span class="hljs-comment"><span class="hljs-comment">//console logs [] console.log(Object.getOwnPropertyNames(obj)); //console logs [Symbol(foo)] console.log(Object.getOwnPropertySymbols(obj));</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/5c35eyav/5/">jsfiddle</a> <br><br>  Using <code>Symbol</code> can be handy if you want to not only protect a property from accidental changes, but you don‚Äôt even want to show it in the course of normal work.  I have not thought seriously about all the potentialities yet, but I think that there could be more of them. <br><br><h4>  Proxy </h4><br><br>  Another new feature in ECMAScript 6 is <code>Proxy</code> .  As of August 2014, proxies only work in Firefox.  The following example with jsfiddle will only work in Firefox and, in fact, I tested it in Firefox beta, which I had installed. <br><br>  I find the proxies delightful, because they make it possible to pick up all the properties, pay attention to the example: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">"foo"</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> handler = { <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target.hasOwnProperty(name)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target[name]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"foobar"</span></span>; }, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(p.foo); <span class="hljs-comment"><span class="hljs-comment">//logs "foo" console.log(p.bar); //logs "foobar" console.log(p.asdf); //logs "foobar"</span></span></code> </pre><br>  <a href="http://jsfiddle.net/btipling/d4he6u4t/4/">jsfiddle</a> <br><br>  In this example, we proxy the object <code>obj</code> .  We create a <code>handler</code> object that will handle the interaction with the created object.  The <code>get</code> method is pretty simple.  It takes an object and the name of a property to access.  This information can be returned at any time, but in our example the actual value is returned if the key is and ‚Äúfoobar‚Äù if it is not.  I see a huge field of possibilities and interesting ways to use proxies, one of which is a bit like a <code>switch</code> , such as in <code>Scala</code> . <br><br>  Another proxy application is testing.  In addition to <code>get</code> there are also other handlers: <code>set</code> , <code>has</code> , others.  When the proxy gets better support, I will not hesitate to give them a whole post on my blog.  I advise you to look at the MDN proxy documentation and pay attention to the examples given. <br>  In addition, there is also a great proxy report from jsconf, which I highly recommend: <a href="https://www.youtube.com/watch%3Fv%3DsClk6aB_CPk">video</a> |  <a href="http://jsconf.eu/2010/speaker/be_proxy_objects.html">slides</a> <br><br>  There are many ways to use objects in JavaScript more deeply than just a repository of random data.  Already available are powerful ways of defining properties, and in the future we are waiting for, as you can see, thinking about how a proxy can change the way that JavaScript is written, a lot more interesting.  If you have any clarifications or comments, please let me know about it, here is my twitter: @bjorntipling. </div><p>Source: <a href="https://habr.com/ru/post/241465/">https://habr.com/ru/post/241465/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241455/index.html">How recommender systems work. Lecture in Yandex</a></li>
<li><a href="../241457/index.html">In which countries does the Internet ‚Äúsleep‚Äù at night?</a></li>
<li><a href="../241459/index.html">Statistics of Russian IT-specialists on stackoverflow.com and github.com</a></li>
<li><a href="../241461/index.html">Something Better A / B Testing</a></li>
<li><a href="../241463/index.html">You want a delicious beer, Arduino to help</a></li>
<li><a href="../241469/index.html">Stop doing freemium - it's time to make money</a></li>
<li><a href="../241471/index.html">Zend Framework 2: Service Manager</a></li>
<li><a href="../241473/index.html">How programmers solve problems</a></li>
<li><a href="../241475/index.html">Business vs Service</a></li>
<li><a href="../241479/index.html">AppCompat v21 - Material Design for Pre-Lollipop Devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>