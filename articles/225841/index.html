<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Swift programming language. Russian version</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! On June 2, we all could witness how Apple began to revolutionize the Objective-C camp of developers by introducing its new programming langu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Swift programming language. Russian version</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/bf4/1ca/fc8/bf41cafc8cfd7ab00dddf727262b76c6.png" alt="image" align="right">  Hi, Habr!  On June 2, we all could witness how Apple began to revolutionize the Objective-C camp of developers by introducing its new programming language, Swift, to the world.  At the same time, she posted <a href="https://itunes.apple.com/ru/book/swift-programming-language/id881256329%3Fmt%3D11">in open access a</a> small documentation on the language, which we decided to translate, if there is demand.  We offer you the translation of the first chapter.  If the topic is interesting, we will continue to publish the translation every week. <a name="habracut"></a><br><br><h4>  Table of contents </h4><br>  <b>Welcome to swift</b> <b><br></b>  <b>About Swift</b> <b><br></b>  <b>Introduction to Swift</b> <br><br>  Language guide <br>  The basics <br>  Basic Operators <br>  String and Characters <br>  Collection types <br>  Control flow <br>  Functions <br>  Closures <br>  Enumerations <br>  Classes and Structures <br>  Properties <br>  Methods <br>  Subscripts <br>  Inheritance <br>  Initialization <br>  Deinitialization <br>  Automatic Reference Counting <br>  Optional chaining <br>  Type casting <br>  Nested types <br>  Extensions <br>  Protocols <br>  Generics <br>  Advanced operators 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Language Reference <br>  About the Language Reference <br>  Lexical Structure <br>  Types <br>  Expressions <br>  Statements <br>  Declarations <br>  Attributes <br>  Patterns <br>  Generic Parameters and Arguments <br>  Summary of the Grammar <br>  Trademarks <br><br><h4>  Welcome to swift </h4><br><h5>  About Swift </h5><br>  Swift is a new programming language for developing iOS and OS X applications, which combines all the best from C and Objective-C, but lacks the limitations imposed for compatibility with C. Swift uses secure programming patterns and adds modern functions that turn Creating an application in a simple, more flexible and fun process.  Swift, created by us from scratch, is an opportunity to re-imagine how applications are developed. <br><br>  Swift was developed by us for several years.  The basis of the new programming language was the existing compiler, debugger and frameworks.  We have simplified the memory management process with the Automatic Reference Counting (ARC) mechanism.  Our frameworks also underwent a major upgrade.  Objective-C began to support blocks, literals and modules - all this created favorable conditions for the introduction of modern technologies.  It was this preparatory work that served as the foundation for a new programming language that will be used to develop future software products for Apple. <br><br>  Objective-C developers will find Swift familiar.  It combines the readability of the named parameters and the power of the Objective-C dynamic object model.  It provides access to existing Cocoa frameworks and is compatible with code written in Objective-C.  A language built on this common basis offers many new features and unifies procedural and object-oriented aspects of a programming language. <br><br>  Swift does not scare novice programmers.  This is the first powerful programming language, as intuitive and fascinating as a scripting language.  It supports the so-called playgrounds, which allow programmers to experiment with the code, seeing the result in real time without having to compile and run the application. <br><br>  Swift has absorbed all the best from modern languages ‚Äã‚Äãand is designed with the extensive experience of Apple.  Our compiler is a synonym for performance, our language is optimized for development without looking at compromises.  It is designed in such a way that you can easily develop your first ‚Äúhello, world!‚Äù Application, and even the whole operating system.  All this makes Swift an important tool for developers and for Apple itself. <br><br>  Swift is a new fantastic way to create applications for iOS and OS X, and we will continue to develop it, adding new functionality and introducing new features.  Our goal is ambitious.  And we look forward to see what you can create with it. <br><br><h5>  Introduction to Swift </h5><br>  According to a long tradition, the first program in a new language should display the words <code>‚ÄúHello, world‚Äù</code> .  With Swift, this is done like this: <br><br><pre> <code class="objectivec hljs">println(<span class="hljs-string"><span class="hljs-string">"Hello, world"</span></span>)</code> </pre><br>  If you have ever developed C or Objective-C this syntax should seem painfully familiar to you - in Swift this line of code is a complete program.  You no longer need to import separate libraries to provide basic functionality like I / O to the console or work with strings.  The code written in the global scope is the entry point to the program, so the <code>main</code> function is no longer needed.  Also note the absence of a semicolon at the end of each line. <br><br>  This introduction contains enough information to start writing Swift code.  Do not worry if something is incomprehensible to you - we will explain everything in detail in subsequent chapters. <br><br><blockquote>  <i>Comment</i> <br>  For a better understanding of the material, we recommend using the playground mode in Xcode.  Playground allows you to see the result immediately in the code editing process without having to compile and run the application. </blockquote><br><h6>  Simple data types </h6><br>  Use <code>let</code> to create a constant and <code>var</code> to create a variable.  You don't need to specify a constant type; you can assign a value to it only once. <br><br><pre> <code class="objectivec hljs">var myVariable = <span class="hljs-number"><span class="hljs-number">42</span></span> myVariable = <span class="hljs-number"><span class="hljs-number">50</span></span> let myConstant = <span class="hljs-number"><span class="hljs-number">42</span></span></code> </pre><br>  The types of the constant and the variable must match the types of corresponding values ‚Äã‚Äãassigned to them.  However, this does not mean that you must directly indicate their type.  The compiler will automatically determine the type of the constant and the variable when they are assigned a value.  So, in the example above, the compiler will determine that <code>myVariable</code> is of integer type. <br><br>  If the initializer is missing or does not provide sufficient information, you can specify the type yourself after the variable, separating the name and type by a colon: <br><br><pre> <code class="objectivec hljs">let implicitInteger = <span class="hljs-number"><span class="hljs-number">70</span></span> let inplicitDouble = <span class="hljs-number"><span class="hljs-number">70.0</span></span> let inplicitDouble: Double = <span class="hljs-number"><span class="hljs-number">70</span></span></code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Create a constant with type Float and initialize it with the number 4. </blockquote><br>  Values ‚Äã‚Äãare never converted to another type implicitly.  If you need to convert a value to another type, do it explicitly: <br><pre> <code class="objectivec hljs">let label = <span class="hljs-string"><span class="hljs-string">"The width is "</span></span> let width = <span class="hljs-number"><span class="hljs-number">94</span></span> let widthLabel = label + String(width)</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Try removing the explicit conversion to the String type in the last line.  What error do you get? </blockquote><br>  There is an easier way to include values ‚Äã‚Äãin strings: to do this, enclose the expression in parentheses and put a backslash ( <code>\</code> ) in front of them.  Example: <br><br><pre> <code class="objectivec hljs">let apples = <span class="hljs-number"><span class="hljs-number">3</span></span> let oranges = <span class="hljs-number"><span class="hljs-number">5</span></span> let appleSummary = <span class="hljs-string"><span class="hljs-string">"I have \(apples) apples."</span></span> let fruitSummary = <span class="hljs-string"><span class="hljs-string">"I have \(apples + oranges) pieces of fruit."</span></span></code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Try using the <code>\()</code> construct and display a string that includes the result of the sum of two integer variables and someone's name. </blockquote><br>  When working with arrays and associative arrays (dictionaries, dictionary), square brackets ( <code>[]</code> ) are used: <br><br><pre> <code class="objectivec hljs">var shoppingList = [<span class="hljs-string"><span class="hljs-string">"catfish"</span></span>, <span class="hljs-string"><span class="hljs-string">"water"</span></span>, <span class="hljs-string"><span class="hljs-string">"tulips"</span></span>, <span class="hljs-string"><span class="hljs-string">"blue paint"</span></span>] shoppingList[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-string"><span class="hljs-string">"bottle of water"</span></span> var occupations = [ <span class="hljs-string"><span class="hljs-string">"Malcolm"</span></span>: <span class="hljs-string"><span class="hljs-string">"Captain"</span></span>, <span class="hljs-string"><span class="hljs-string">"Kaylee"</span></span>: <span class="hljs-string"><span class="hljs-string">"Mechanic"</span></span>, ] occupations[<span class="hljs-string"><span class="hljs-string">"Jayne"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Public Relations"</span></span></code> </pre><br>  To create an empty array or dictionary, use the following syntax: <br><br><pre> <code class="objectivec hljs">let emptyArray = String[]() let emptyDictionary = Dictionary&lt;String, Float&gt;()</code> </pre><br>  To create empty arrays and dictionaries, use <code>[]</code> and <code>[:]</code> respectively, for example, when you assign a new value to a variable or pass an argument to a function. <br><br><pre> <code class="objectivec hljs">shoppingList = [] <span class="hljs-comment"><span class="hljs-comment">// Went shopping and bought everything.</span></span></code> </pre><br><br><h6>  Conditions and cycles </h6><br>  To create conditions, use <code>if</code> and <code>switch</code> , to create loops - <code>for-in</code> , <code>for</code> , <code>while</code> and <code>do-while</code> .  In this case, it is not necessary to select conditions and initializing expressions in parentheses, while curly brackets are required. <br><br><pre> <code class="objectivec hljs">let individualScores = [<span class="hljs-number"><span class="hljs-number">75</span></span>, <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-number"><span class="hljs-number">103</span></span>, <span class="hljs-number"><span class="hljs-number">87</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>] var teamScore = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> score <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> individualScores { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> score &gt; <span class="hljs-number"><span class="hljs-number">50</span></span> { teamScore += <span class="hljs-number"><span class="hljs-number">3</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { teamScore += <span class="hljs-number"><span class="hljs-number">1</span></span> } } teamScore</code> </pre><br>  The condition inside the <code>if</code> should be logical, which in particular means that the expression <code>if score {‚Ä¶}</code> is erroneous, since there is no explicit comparison (for example, with zero). <br><br>  The conditional <code>if</code> can be used in conjunction with <code>let</code> and <code>var</code> to work with constants and variables that can be <code>nil</code> .  Such constants and variables are called optional (that is, they can either take a value or be equal to <code>nil</code> ).  To create an optional variable or constant add a question mark ( <code>?</code> ) After specifying the type. <br><br><pre> <code class="objectivec hljs"> var optionalString: String? = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> optionalString == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> var optionalName: String? = <span class="hljs-string"><span class="hljs-string">"John Appleseed"</span></span> var greeting = <span class="hljs-string"><span class="hljs-string">"Hello!"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let name = optionalName { greeting = <span class="hljs-string"><span class="hljs-string">"Hello, \(name)"</span></span> }</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Change <code>optionalName</code> to <code>nil</code> .  What do you see on the screen?  Add an <code>else</code> block to handle the case when <code>optionalName</code> is <code>nil</code> . </blockquote><br>  If the optional value is <code>nil</code> , the condition will be false and the code in braces after the <code>if</code> will not be executed.  Otherwise, the variable <code>greeting</code> will be assigned a new value. <br><br>  The <code>switch</code> multiple select <code>switch</code> supports many other comparison operators within it and is not limited to simple comparisons: <br><br><pre> <code class="objectivec hljs">let vegetable = <span class="hljs-string"><span class="hljs-string">"red pepper"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> vegetable { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"celery"</span></span>: let vegetableComment = <span class="hljs-string"><span class="hljs-string">"Add some raisins and make ants on a log."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"cucumber"</span></span>, <span class="hljs-string"><span class="hljs-string">"watercress"</span></span>: let vegetableComment = <span class="hljs-string"><span class="hljs-string">"That would make a good tea sandwich."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let x where x.hasSuffix(<span class="hljs-string"><span class="hljs-string">"pepper"</span></span>): let vegetableComment = <span class="hljs-string"><span class="hljs-string">"Is it a spicy \(x)?"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: let vegetableComment = <span class="hljs-string"><span class="hljs-string">"Everything tastes good in soup."</span></span> }</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Try removing the default condition.  What error do you get? </blockquote><br>  After executing a suitable block of code, the program leaves the <code>switch</code> without checking the subsequent conditions.  Thus, you do not need to manually add interrupts ( <code>break</code> ) at the end of each <code>case</code> block. <br><br>  To select the elements of an associative array, use the <code>for-in</code> operator along with a pair of names for each key-value pair. <br><br><pre> <code class="objectivec hljs">let interestingNumbers = [ <span class="hljs-string"><span class="hljs-string">"Prime"</span></span>: [<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">13</span></span>], <span class="hljs-string"><span class="hljs-string">"Fibonacci"</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>], <span class="hljs-string"><span class="hljs-string">"Square"</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>], ] var largest = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (kind, numbers) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> interestingNumbers { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> number &gt; largest { largest = number } } } largest</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Add another variable that will allow you to find out which of the three types the maximum number found is. </blockquote><br>  The <code>while</code> operator allows you to execute a block of code inside it until the condition becomes false.  The condition can also be specified after the block, which in this case will be executed at least once. <br><br><pre> <code class="objectivec hljs">var n = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">100</span></span> { n = n * <span class="hljs-number"><span class="hljs-number">2</span></span> } n var m = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { m = m * <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> m &lt; <span class="hljs-number"><span class="hljs-number">100</span></span> m</code> </pre><br>  You can use the for statement to iterate through a sequence of numbers using two points ( <code>..</code> ) or using an initializer, condition, and increment.  Look, these two cycles do the same thing: <br><br><pre> <code class="objectivec hljs">var firstForLoop = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> { firstForLoop += i } firstForLoop var secondForLoop = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; ++i { secondForLoop += <span class="hljs-number"><span class="hljs-number">1</span></span> } secondForLoop</code> </pre><br>  When creating a loop, use two points ( <code>..</code> ) if you do not want to include a larger value in the range, and three points ( <code>‚Ä¶</code> ) to include both smaller and larger values. <br><br><h6>  Functions and closures. </h6><br>  To declare functions, use the <code>func</code> keyword.  The function is called by specifying its name and the list of arguments in parentheses.  The return type should be separated from the list of formal arguments with <code>-&gt;</code> . <br><br><pre> <code class="objectivec hljs">func greet(name: String, day: String) -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hello \(name), today is \(day)."</span></span> } greet(<span class="hljs-string"><span class="hljs-string">"Bob"</span></span>, <span class="hljs-string"><span class="hljs-string">"Tuesday"</span></span>)</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Remove the day parameter.  Instead, add a variable denoting the name of the dish served for lunch. </blockquote><br>  If the function returns a set of values, use a tuple: <br><br><pre> <code class="objectivec hljs">func getGasPrices() -&gt; (Double, Double, Double) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-number"><span class="hljs-number">3.59</span></span>, <span class="hljs-number"><span class="hljs-number">3.69</span></span>, <span class="hljs-number"><span class="hljs-number">3.79</span></span>) } getGasPrices()</code> </pre><br>  Functions can also have an indefinite number of arguments: <br><br><pre> <code class="objectivec hljs">func sumOf(numbers: Int...) -&gt; Int { var sum = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> numbers { sum += number } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum } sumOf() sumOf(<span class="hljs-number"><span class="hljs-number">42</span></span>, <span class="hljs-number"><span class="hljs-number">597</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Write a function that allows you to find the arithmetic mean of an arbitrary number of its arguments. </blockquote><br>  Functions can be nested.  A nested function can refer to variables declared in an external function.  Use nested functions to tidy up a complex or large function code. <br><br><pre> <code class="objectivec hljs">func returnFifteen() -&gt; Int { var y = <span class="hljs-number"><span class="hljs-number">10</span></span> func add() { y += <span class="hljs-number"><span class="hljs-number">5</span></span> } add() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> y } returnFifteen()</code> </pre><br>  Functions are objects of the first class (first-class type), in other words, a function can return another function as its result. <br><br><pre> <code class="objectivec hljs">func makeIncrementer() -&gt; (Int -&gt; Int) { func addOne(number: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> + number } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addOne } var increment = makeIncrementer() increment(<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre><br>  A function can also take another function as one of the arguments. <br><br><pre> <code class="objectivec hljs">func hasAnyMatches(list: Int[], condition: Int -&gt; Bool) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> condition(item) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } func lessThanTen(number: Int) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> number &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> } var numbers = [<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>] hasAnyMatches(numbers, lessThanTen)</code> </pre><br>  Functions are a special case of closures.  You can create a closure without specifying its name and surrounding the closure body with curly braces ( <code>{}</code> ).  To separate the arguments and return type from the closure body, use the <code>in</code> operator. <br><br><pre> <code class="objectivec hljs">numbers.map({ (number: Int) -&gt; Int <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> let result = <span class="hljs-number"><span class="hljs-number">3</span></span> * number <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result })</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Rewrite the closure so that it returns zero for all unnecessary numbers. </blockquote><br>  There are several techniques that allow making closures more concise.  If the closure type is known a priori (for example, this is the delegate‚Äôs callback), you can omit the indication of the type of its parameters and / or the type of the return value.  Closures consisting of a single expression implicitly return the result of this expression. <br><br><pre> <code class="objectivec hljs">numbers.map({ number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> * number })</code> </pre><br>  In a closure, instead of specifying the name of a variable, you can use its sequence number ‚Äî this is especially useful when writing short circuits.  The closure, which is the last argument of the function, can be passed to it immediately after the parentheses with the list of other parameters. <br><br><pre> <code class="objectivec hljs">sort([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>]) { $<span class="hljs-number"><span class="hljs-number">0</span></span> &gt; $<span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre><br><br><h6>  Objects and Classes </h6><br>  To create a class, use the reserved word <code>class</code> .  Class members are declared in the same way as regular constants and variables.  Moreover, class methods are declared as ordinary functions. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Shape { var numberOfSides = <span class="hljs-number"><span class="hljs-number">0</span></span> func simpleDescription() -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"A shape with \(numberOfSides) sides."</span></span> } }</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Add a class constant member and a class method that takes it as its argument. </blockquote><br>  To create an instance (object) of a class, it is enough to add parentheses after the class name.  Access to methods and class members is done through a dot. <br><br><pre> <code class="objectivec hljs">var shape = Shape() shape.numberOfSides = <span class="hljs-number"><span class="hljs-number">7</span></span> var shapeDescription = shape.simpleDescription()</code> </pre><br>  In this example, we missed one important detail - the class constructor, the <code>init</code> method. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> NamedShape { var numberOfSides: Int = <span class="hljs-number"><span class="hljs-number">0</span></span> var name: String init(name: String) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.name = name } func simpleDescription() -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"A shape with \(numberOfSides) sides."</span></span> } }</code> </pre><br>  Notice how the member of the name class with <code>self</code> is separated from the argument of the <code>name</code> constructor.  Arguments are passed to the constructor in the usual way, as in any other class method.  Note that each member of the class must be initialized ‚Äî either when declaring (as, for example, <code>numberOfSides</code> ), or in the constructor (as <code>name</code> ). <br><br>  The destructor of the class is the <code>deinit</code> method, which can be rewritten if necessary. <br><br>  To inherit a class from an already existing class, after specifying the name of the child class, you must put a colon and specify the name of the parent.  In Swift, there are no restrictions on the mandatory inheritance of any standard class. <br><br>  Methods <code>override</code> child class must be marked with the <code>override</code> keyword ‚Äî overriding methods without override will result in an error.  The compiler also identifies methods labeled <code>override</code> , but not overriding any methods of their parent class. <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Square: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.sideLength = sideLength <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(name: name) numberOfSides = <span class="hljs-number"><span class="hljs-number">4</span></span> } func area() -&gt; Double { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sideLength * sideLength } override func simpleDescription() -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"A square with sides of length \(sideLength)."</span></span> } } let test = Square(sideLength: <span class="hljs-number"><span class="hljs-number">5.2</span></span>, name: <span class="hljs-string"><span class="hljs-string">"my test square"</span></span>) test.area() test.simpleDescription()</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Create a <code>Circle</code> class and inherit it from the <code>NamedShape</code> class.  The constructor of the <code>Circle</code> class takes two arguments, the radius and the name.  Override <code>area</code> methods and <code>describe</code> this class. </blockquote><br>  Class members can also have their own <code>getter</code> and <code>setter</code> . <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> EquilateralTriangle: NamedShape { var sideLength: Double = <span class="hljs-number"><span class="hljs-number">0.0</span></span> init(sideLength: Double, name: String) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.sideLength = sideLength <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(name: name) numberOfSides = <span class="hljs-number"><span class="hljs-number">3</span></span> } var perimeter: Double { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">3.0</span></span> * sideLength } set { sideLength = newValue / <span class="hljs-number"><span class="hljs-number">3.0</span></span> } } override func simpleDescription() -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"An equilateral triagle with sides of length \(sideLength)."</span></span> } } var triangle = EquilateralTriangle(sideLength: <span class="hljs-number"><span class="hljs-number">3.1</span></span>, name: <span class="hljs-string"><span class="hljs-string">"a triangle"</span></span>) triangle.perimeter triangle.perimeter = <span class="hljs-number"><span class="hljs-number">9.9</span></span> triangle.sideLength</code> </pre><br>  In the <code>setter</code> <code>perimeter</code> variable <code>perimeter</code> new value assigned is implicitly called <code>newValue</code> .  You can change the name of this variable by specifying it in brackets immediately after <code>set</code> . <br><br>  Pay attention to the constructor structure of the <code>EquilateralTriangle</code> class.  This method involves three consecutive steps: <br><ol><li>  initialization of members of the child class; </li><li>  call the parent class constructor; </li><li>  change the values ‚Äã‚Äãof the members of the parent class. </li></ol><br>  If you need to execute a specific code before or after assigning a new value to a variable, you can override the <code>willSet</code> and <code>didSet</code> methods in the way you want.  For example, in the class below, it is guaranteed that the length of the side of the triangle will always be equal to the length of the side of the square. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TriangleAndSquare { var triangle: EquilateralTriangle { willSet { square.sideLength = newValue.sideLength } } var square: Square { willSet { triangle.sideLength = newValue.sideLength } } init(size: Double, name: String) { square = Square(sideLength: size, name: name) triangle = EquilateralTriangle(sideLength: size, name: name) } } var triangleAndSquare = TriangleAndSquare(size: <span class="hljs-number"><span class="hljs-number">10</span></span>, name: <span class="hljs-string"><span class="hljs-string">"another test shape"</span></span>) triangleAndSquare.square.sideLength triangleAndSquare.triangle.sideLength triangleAndSquare.square = Square(sideLength: <span class="hljs-number"><span class="hljs-number">50</span></span>, name: <span class="hljs-string"><span class="hljs-string">"larger square"</span></span>) triangleAndSquare.triangle.sideLength</code> </pre><br>  Class methods have one important difference from functions.  The names of the function arguments are used only within this function, whereas in the class method, parameters are also used when calling this method (except for the first parameter).  By default, the class method has the same parameter names both during the call and within itself.  However, you can specify a different name (in the example below, <code>times</code> ) that will be used only inside this method.  In this case, to call this method, you must use the first name ( <code>numberOfTimes</code> ). <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Counter { var count: Int = <span class="hljs-number"><span class="hljs-number">0</span></span> func incrementBy(amount: Int, numberOfTimes times: Int) { count += amount * times } } var counter = Counter() counter.incrementBy(<span class="hljs-number"><span class="hljs-number">2</span></span>, numberOfTimes: <span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre><br>  When working with optional values, add a question mark ( <code>?</code> ) Before methods, class members, etc.  If the value before the question mark is <code>nil</code> , everything that follows ( <code>?</code> ) <code>?</code> ignored and the value of the whole expression is <code>nil</code> .  Otherwise, the expression is evaluated in the usual way.  In both cases, the result of the entire expression is an optional value. <br><br><pre> <code class="objectivec hljs">let optionalSquare: Square? = Square(sideLength: <span class="hljs-number"><span class="hljs-number">2.5</span></span>, name: <span class="hljs-string"><span class="hljs-string">"optional square"</span></span>) let sideLength = optionalSquare?.sideLength</code> </pre><br><br><h6>  Enumerations and Structures </h6><br>  The <code>enum</code> keyword is used to create <code>enum</code> .  Note that enumerations can also include methods. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Rank: Int { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Ace = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Jack, Queen, King func simpleDescription() -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Ace: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"ace"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Jack: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"jack"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Queen: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"queen"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .King: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"king"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> String(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.toRaw()) } } } let ace = Rank.Ace let aceRawValue = ace.toRaw()</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Write a function that compares 2 <code>Rank</code> type listings by their values. </blockquote><br>  In the above example, the enumeration elements are initially of integer type, and you only need to specify the value of the first element - the values ‚Äã‚Äãof the other elements will be determined in accordance with their order.  You can also choose string or real types as the initial type (raw value) of the element values. <br><br>  To convert a source value type to an enumeration type, use the <code>toRaw</code> and <code>fromRaw</code> . <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let convertedRank = Rank.fromRaw(<span class="hljs-number"><span class="hljs-number">3</span></span>) { let threeDescription = convertedRank.simpleDescription() }</code> </pre><br>  Note that the values ‚Äã‚Äãof the enumeration elements are actual, and not just another record of their original values.  Generally speaking, you may not specify their original values. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Suit { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Spades, Hearts, Diamonds, Clubs func simpleDescription() -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Spades: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"spades"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Hearts: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hearts"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Diamonds: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"diamonds"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Clubs: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"clubs"</span></span> } } } let hearts = Suit.Hearts let heartsDescription = hearts.simpleDescription()</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Add a <code>Color</code> method that returns the string <code>‚Äúblack‚Äù</code> for <code>Spades</code> and <code>Clubs</code> and <code>‚Äúred‚Äù</code> for <code>Hearts</code> and <code>Diamonds</code> . </blockquote><br>  Notice how the <code>Hearts</code> member accesses the <code>Suit</code> enumeration.  When assigning a value to the constant of <code>hearts</code> , the full name <code>Suit.Hearts</code> , since we obviously do not indicate the type of this constant.  And in <code>switch</code> we use the abbreviated form <code>.Hearts</code> , since the type of <code>self</code> is known a priori.  You can use the short form everywhere if the variable type is explicitly specified. <br><br>  The <code>struct</code> keyword is used to create structures.  Structures have many similar features with classes, including methods and constructors.  One of the most significant differences between structures and classes is that instances of structures, unlike instances of classes, are passed to functions by value (that is, they create a local copy first), while instances of classes are passed by reference. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Card { var rank: Rank var suit: Suit func simpleDescription() -&gt; String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"The \(rank.simpleDescription()) of \(suit.simpleDescription())"</span></span> } } let threeOfSpades = Card(rank: .Three, suit: .Spades) let threeOfSpadesDescription = threeOfSpades.simpleDescription()</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Add a method to the Card structure that creates a complete deck of cards. </blockquote><br>  An instance of an enumeration member may have its own values ‚Äã‚Äãand they may be different.  You assign these values ‚Äã‚Äãwhen you create an enumeration instance (the <code>success</code> constant in the example).  Associated and initial values ‚Äã‚Äãare different things: the initial value of an enumeration member is always constant for all instances of the enumeration and is indicated when it is declared. <br><br>  Consider an example of receiving from the server the time of sunrise and sunset.  The server responds with either relevant information or an error message. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ServerResponse { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Result(String, String) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Error(String) } let success = ServerResponse.Result(<span class="hljs-string"><span class="hljs-string">"6:00 am"</span></span>, <span class="hljs-string"><span class="hljs-string">"8:09 pm"</span></span>) let failure = ServerResponse.Error(<span class="hljs-string"><span class="hljs-string">"Out of cheese."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> success { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let .Result(sunrise, sunset): let serverResponse = <span class="hljs-string"><span class="hljs-string">"Sunrise is at \(sunrise) and sunset is at \(sunset)."</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> let .Error(error): let serverResponse = <span class="hljs-string"><span class="hljs-string">"Failure... \(error)"</span></span> }</code> </pre><br><blockquote>  Let's experiment <br>  Add a third option to the <code>switch</code> multiple select <code>switch</code> </blockquote><br>  Notice how the time of sunrise and sunset is ‚Äúpulled out‚Äù of the <code>ServerResponse</code> object. <br><br><h6>  Protocols and Extensions. </h6><br>  To declare a protocol, use the protocol keyword. <br><br><pre> <code class="objectivec hljs">protocol ExampleProtocol { var simpleDescription: String { get } mutating func adjust() }</code> </pre><br>  Protocols can be supported by classes, enums, and structures. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> SimpleClass: ExampleProtocol { var simpleDescription: String = <span class="hljs-string"><span class="hljs-string">"A very simple class."</span></span> var anotherProperty: Int = <span class="hljs-number"><span class="hljs-number">69105</span></span> func adjust() { simpleDescription += <span class="hljs-string"><span class="hljs-string">" Now 100% adjusted."</span></span> } } var a = SimpleClass() a.adjust() let aDescription = a.simpleDescription <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> SimpleStructure: ExampleProtocol { var simpleDescription: String = <span class="hljs-string"><span class="hljs-string">"A simple structure"</span></span> mutating func adjust() { simpleDescription += <span class="hljs-string"><span class="hljs-string">" (adjusted)"</span></span> } } var b = SimpleStructure() b.adjust() let bDescription = b.simpleDescription</code> </pre><br><blockquote>  <i>Let's experiment</i> <br>  Create an enumeration that will implement this protocol. </blockquote><br>  Notice the <code>mutating</code> keyword in the definition of the <code>SimpleStructure</code> structure, which informs the compiler that the corresponding method <code>SimpleStructure</code> structure change.  In contrast, <code>SimpleClass</code> class <code>SimpleClass</code> do not need to be labeled as <code>mutating</code> , since class methods can always change it freely. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To add new methods or class members to an existing type, you must use the extension - </font></font><code>extensions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">You can also use extensions to implement a protocol of an already existing type, even if it is imported from any library or framework.</font></font><br><br><pre> <code class="objectivec hljs">extension Int: ExampleProtocol { var simpleDescription: String { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"The number \(self)"</span></span> } mutating func adjust() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> += <span class="hljs-number"><span class="hljs-number">42</span></span> } } <span class="hljs-number"><span class="hljs-number">7.</span></span>simpleDescription</code> </pre><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's experiment</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create a type extension </font></font><code>Double</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a member variable </font></font><code>absoluteValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use a protocol name like any other type ‚Äî for example, to create an array of objects of different types, but implementing a common protocol. </font><font style="vertical-align: inherit;">Note that when working with objects of this type, methods declared outside the protocol will not be available.</font></font><br><br><pre> <code class="objectivec hljs">let protocolValue: ExampleProtocol = a protocolValue.simpleDescription <span class="hljs-comment"><span class="hljs-comment">// protocolValue.anotherProperty // Uncomment to see the error</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the fact that at runtime, the variable </font></font><code>protocolValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is of type </font></font><code>SimpleClass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the compiler assumes that its type is </font></font><code>ExampleProtocol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This means that you cannot accidentally gain access to methods or members of a class that are implemented outside the protocol </font></font><code>ExampleProtocol</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Generic types </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a generic type, enclose the name in angle brackets ( </font></font><code>&lt;&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><pre> <code class="objectivec hljs">func repeat&lt;ItemType&gt;(item: ItemType, times: Int) -&gt; ItemType[] { var result = ItemType[]() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.</span></span>.times { result += item } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result } repeat(<span class="hljs-string"><span class="hljs-string">"knock"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create generic functions, classes, enums, and structures. </font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// Reimplement the Swift standard library's optional type enum OptionalValue&lt;T&gt; { case None case Some(T) } var possibleInteger: OptionalValue&lt;Int&gt; = .None possibleInteger = .Some(100)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to specify certain requirements generic to a type, such as, for example, protocol implementation or the requirement to be inherited from a particular class, use </font></font><code>where</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="objectivec hljs">func anyCommonElements &lt;T, U where T: Sequence, U: Sequence, T.GeneratorType.Element: Equatable, T.GeneratorType.Element == U.GeneratorType.Element&gt; (lhs: T, rhs: U) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> lhsItem <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lhs { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rhsItem <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rhs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lhsItem == rhsItem { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } anyCommonElements([<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>], [<span class="hljs-number"><span class="hljs-number">3</span></span>])</code> </pre><br><blockquote> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's experiment.</font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modify the function </font></font><code>anyCommonElements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so that it returns an array of common elements.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In simple cases, you can omit </font></font><code>where</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and write the name of the protocol or class after the colon. </font><font style="vertical-align: inherit;">An expression is </font></font><code>&lt;T: Equatable&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equivalent to an expression </font></font><code>&lt;T where T: Equatable&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></div><p>Source: <a href="https://habr.com/ru/post/225841/">https://habr.com/ru/post/225841/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225825/index.html">Aptly - create your own repository</a></li>
<li><a href="../225827/index.html">Learning to understand the art of programming</a></li>
<li><a href="../225829/index.html">The method of self-determination of the response time of the LCD monitor screen or TV</a></li>
<li><a href="../225831/index.html">Algorithm for finding the smallest covering capacity of a finite set of its subsets</a></li>
<li><a href="../225837/index.html">Notification during call pickup in Asterisk</a></li>
<li><a href="../225845/index.html">Hexapod-robot running ROS</a></li>
<li><a href="../225847/index.html">ImEx.js will decorate your code</a></li>
<li><a href="../225849/index.html">Cisco has updated the product line of video communications equipment</a></li>
<li><a href="../225851/index.html">Phalcon Framework in production</a></li>
<li><a href="../225853/index.html">CoreMark processor rating</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>