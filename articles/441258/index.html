<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fully functional dynamic tracing in Linux using eBPF and bpftrace</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="‚ÄúIn the trace mode, the programmer sees the sequence of command execution and variable values ‚Äã‚Äãat this step of the program, which makes it easier to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fully functional dynamic tracing in Linux using eBPF and bpftrace</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/gd/t6/e_/gdt6e_wwaanx1prvqkhdhj5ptss.jpeg"><br><br>  ‚ÄúIn the trace mode, the programmer sees the sequence of command execution and variable values ‚Äã‚Äãat this step of the program, which makes it easier to detect errors,‚Äù Wikipedia tells us.  As Linux fans themselves, we regularly face the question of which tools are best to implement.  And we want to share the translation of the article by programmer Hongli Lai, who recommends bpftrace.  Looking ahead, I will say that the article ends concisely: "bpftrace is the future."  So why was he so impressed with Lai's colleague?  Detailed answer under the cut. <br><a name="habracut"></a><br>  Linux has two main trace tools: <br>  <a href="https://en.wikipedia.org/wiki/Strace">strace</a> allows you to see which system calls are being made; <br>  <a href="https://en.wikipedia.org/wiki/Ltrace">ltrace</a> allows you to see which dynamic libraries are called. <br><br>  Despite their usefulness, these tools are limited.  And if you need to figure out what's going on inside a system or library call?  And if you need to not only make a list of calls, but also, for example, collect statistics on certain behavior?  And if you need to trace multiple processes and compare data from multiple sources? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In 2019, we finally got a decent answer to these questions on Linux: <a href="https://github.com/iovisor/bpftrace">bpftrace</a> , based on <a href="https://lwn.net/Articles/740157/">eBPF</a> technology.  Bpftrace allows you to write small programs that run every time an event occurs. <br><br>  In this article I will describe how to install bpftrace and teach it basic usage.  And also I will review what the trace ecosystem looks like (for example, ‚Äúwhat is eBPF?‚Äù) And how it evolved into what we have today. <br><br><img src="https://habrastorage.org/webt/v9/vp/di/v9vpdivpv8a6roolw_kiz7wtnfs.png"><br><br><h3>  What is tracing? </h3><br>  As mentioned earlier, bpftrace allows you to write small programs that run every time an event occurs. <br><br>  What is an event?  This may be a system call, a function call, or even something that occurs within such requests.  It can also be a timer or a hardware event, for example, ‚Äú50 ms has passed since the last such event‚Äù, ‚Äúpage failure occurred‚Äù, ‚Äúcontext switch occurred‚Äù or ‚Äúprocessor cashe-miss occurred‚Äù. <br><br>  What can be done in response to an event?  You can pledge something, collect statistics and execute arbitrary shell commands.  You will have access to various contextual information, such as the current PID, stack trace, time, call arguments, return values, etc. <br><br>  When to use?  In many.  You can figure out why the application is running slowly by collecting a list of the slowest calls.  You can determine if the application has memory leaks and, if so, where it came from.  I use it to figure out why Ruby uses so much memory. <br><br>  The big plus bpftrace is that you do not need to recompile the application.  There is no need to prescribe calls to print or any other debugging code in the source code of the application under investigation.  There is even no need to restart applications.  And all this with very low overheads.  This makes bpftrace especially useful for debugging systems right on the prod or in another situation where there are difficulties with recompiling. <br><br><h3>  DTrace: Trace Father </h3><br>  For a long time, the best tracing tool was <a href="https://en.wikipedia.org/wiki/DTrace">DTrace</a> , a full-fledged dynamic tracing framework originally developed by Sun Microsystems (the creators of Java).  Like bpftrace, DTrace allows you to write small programs that run in response to events.  In fact, many of the key elements of the ecosystem are largely developed by <a href="http://www.brendangregg.com/">Brendan Gregg</a> , a famous DTrace expert who now works at Netflix.  That explains the similarities between DTrace and bpftrace. <br><br><img src="https://habrastorage.org/webt/2p/wc/4w/2pwc4wawnfzibvlwt7ia0xibodc.jpeg"><br>  <i><a href="https://www.slideshare.net/satyajit_t/solaris-dtrace-an-introduction">Solaris DTrace introduction (2009)</a> by S. Tripathi, Sun Microsystems</i> <br><br>  At some point, Sun discovered the DTrace source.  Today DTrace is available on Solaris, FreeBSD, and macOS (although the version for macOS is generally inoperable, since the Protection of System Integrity, SIP, broke many of the principles on which DTrace works). <br><br>  Yes, you correctly noted ... Linux is missing from this list.  This is not an engineering problem, it is a licensing problem.  DTrace was licensed under the CDDL instead of the GPL.  <a href="https://github.com/dtrace4linux/linux">The DTrace port on Linux has</a> been available since 2011, but it has never been supported by major Linux developers.  In early 2018, <a href="https://gnu.wildebeest.org/blog/mjw/2018/02/14/dtrace-for-linux-oracle-does-the-right-thing/">Oracle re-discovered DTrace under the GPL</a> , but by that time it was too late. <br><br><h3>  Linux Tracing Ecosystem </h3><br>  Without a doubt, the traceability feature is very useful, and the Linux community sought to develop their own solutions for this topic.  But, unlike Solaris, Linux is not regulated by one particular vendor, and therefore there was no deliberate effort to develop a fully functional replacement for DTrace.  The Linux trace ecosystem has evolved slowly and naturally, solving problems as they arise.  And only recently has this ecosystem grown enough to compete seriously with DTrace. <br><br>  Because of its natural growth, this ecosystem may seem a bit chaotic, consisting of many different components.  Fortunately, Julia Evans <a href="https://jvns.ca/blog/2017/07/05/linux-tracing-systems/">wrote a review of this ecosystem</a> (note, the publication date is 2017, before bpftrace appeared). <br><br><img src="https://habrastorage.org/webt/io/km/zq/iokmzq2fmqyechm1boqeks-w2za.png"><br>  <i>Linux tracing ecosystem described by Julia Evans</i> <br><br>  Not all elements are equally important.  Let me briefly summarize which elements I consider most important. <br><br>  <b>Sources of events</b> <br><br>  Event data can come from both the kernel and user space (applications and libraries).  Some of them are available automatically, without additional efforts of developers, the rest require manual announcements. <br><br><img src="https://habrastorage.org/webt/2t/xm/mm/2txmmm6rz5xfcwcglsxy8zopr6q.jpeg"><br>  <i>An overview of the most important sources of traced events in Linux.</i> <br><br>  From the side of the kernel, there is kprobes ( <i>from kernel probes, kernel sensor, approx. Lane</i> ) - a mechanism that allows you to trace any function call inside the kernel.  With it, you can trace not only the system calls themselves, but also what happens inside them (because the entry points of the system calls cause other internal functions).  You can also use kprobes to trace kernel events that are not system calls, for example, ‚Äúbuffered data is written to disk‚Äù, ‚ÄúTCP packet is sent over the network‚Äù or ‚Äúcontext switching is currently taking place‚Äù. <br><br>  Kernel tracepoints allow you to trace non-standard events defined by kernel developers.  These events are not at the level of function calls.  To create such points, kernel developers manually place the TRACE_EVENT macro in the kernel code. <br><br>  Both sources have pros and cons.  Kprobes works "automatically", because  does not require manual code markup from kernel developers.  But kprobe events can arbitrarily change from one version of the kernel to another, because functions are constantly changing ‚Äî they are added, deleted, renamed. <br><br>  Kernel trace points are generally more stable over time and can provide useful contextual information that may not be available when using kprobes.  Using kprobes, you can access the arguments of function calls.  But with the help of trace points, you can get any information that the kernel developer decides to manually describe. <br><br>  In user space, there is an analogue of kprobes - uprobes.  It is intended for tracing function calls in user space. <br><br>  USDT sensors (‚ÄúStatically Defined Traces of User Space‚Äù) are analogous to kernel trace points in user space.  Application developers need to manually add USDT sensors to their code. <br><br>  Interesting fact: DTrace for a long time provided the C API to determine its own analogue of USDT sensors (using the DTRACE_PROBE macro).  The Linux trace ecosystem developers decided to keep the source code compatible with this API, so any DTRACE_PROBE macros will automatically be converted to USDT sensors! <br><br>  Therefore, in theory, strace can be implemented using kprobes, and ltrace using uprobes.  I'm not sure if this is practiced already or not. <br><br>  <b>Interfaces</b> <br><br>  Interfaces are applications that allow users to easily use event sources. <br><br>  Let's take a look at how event sources work.  The workflow is as follows: <br><br><ol><li>  The kernel represents a mechanism ‚Äî usually the file / proc or / sys, open for writing ‚Äî that registers both the intention to trace the event and what should follow the event. </li><li>  By registering, the kernel localizes the kernel / function in user space / trace points / USDT sensors in memory and changes their code so that something else happens. </li><li>  The result of this ‚Äúsomething else‚Äù can be collected later with the help of some mechanism. </li></ol><br>  I would not like to do all this manually!  Therefore, interfaces come to the rescue: they do all this for you. <br><br>  There are interfaces for every taste and color.  In the area of <a href="http://www.brendangregg.com/ebpf.html">eBPF</a> - <a href="http://www.brendangregg.com/ebpf.html">based interfaces,</a> there are low-level ones that require a deep understanding of how to interact with event sources and how eBPF byte code works.  And there are high-level and easy to operate, although during their existence they have not demonstrated great flexibility. <br><br>  This is why bpftrace - the newest interface - is my favorite.  It is easy to use and flexible, like DTrace.  But it is quite new and requires grinding. <br><br><h3>  eBPF </h3><br>  <a href="https://lwn.net/Articles/740157/">eBPF</a> is a <a href="https://jvns.ca/blog/2017/04/07/xdp-bpf-tutorial/">new Linux tracing star</a> , on which bpftrace is based.  When you trace an event, you want something to happen in the kernel.  How flexible is it to determine that there is this ‚Äúsomething‚Äù?  Of course, using a programming language (or using machine code). <br><br>  eBPF (enhanced version of Berkeley Packet Filter).  This is a high-performance virtual machine that runs in the kernel and has the following properties / limitations: <br><br><ul><li>  All interactions with user space occur through eBPF ‚Äúmaps‚Äù, which are key-value data storage. </li><li>  There are no cycles for each eBPF program to complete at a specific time. </li><li>  Wait, did we say ‚Äúpacket filter‚Äù?  You are right: they were originally designed for filtering network packets.  This is a similar task: when forwarding packets (the occurrence of an event), you need to perform some administrative action (accept, drop, log, or redirect the packet, etc.) To perform such actions quickly, a virtual machine was invented (with JIT compilations).  The ‚Äúenhanced‚Äù version is considered due to the fact that, compared to the original version of Berkeley Packet Filter, eBPF can be used outside the network context. </li></ul><br>  Like this.  With bpftrace, you can determine which events to monitor and what should happen in response.  Bpftrace compiles your high-level bpftrace-written program into eBPF bytecode, tracks events, and loads the bytecode into the kernel. <br><br><h3>  Dark days before eBPF </h3><br>  Before the advent of eBPF, the solutions were, to put it mildly, awkward.  <a href="https://sourceware.org/systemtap/">SystemTap</a> is something like the ‚Äúmost serious‚Äù predecessor of bpftrace in the Linux family.  SystemTap scripts are translated to the C language and loaded into the kernel as modules.  The resulting kernel module is then loaded. <br><br>  This approach was very fragile and poorly supported outside of Red Hat Enterprise Linux.  He never worked well for me on Ubuntu, which tended to break SystemTap on every kernel update due to a change in the kernel data structure.  They also say that in the first days of its existence SystemTap <a href="https://news.ycombinator.com/item%3Fid%3D16377856">easily led to the kernel panic</a> . <br><br><h3>  Install bpftrace </h3><br>  It's time to roll up your sleeves!  In this guide, we will look at installing bpftrace on Ubuntu 18.04.  Newer versions of the distribution are undesirable because  during installation, we will need packages that have not yet been compiled for them. <br><br>  <b>Installing dependencies</b> <br><br>  First, install Clang 5.0, lbclang 5.0 and LLVM 5.0, including all header files.  We will use the packages provided by llvm.org, because those in the Ubuntu repositories are <a href="https://github.com/iovisor/bpftrace/issues/76">problematic</a> . <br><br><pre><code class="plaintext hljs">wget -O - https://apt.llvm.org/llvm-snapshot.gpg.key | sudo apt-key add - cat &lt;&lt;EOF | sudo tee -a /etc/apt/sources.list deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial main deb http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main deb-src http://apt.llvm.org/xenial/ llvm-toolchain-xenial-5.0 main EOF sudo apt update sudo apt install clang-5.0 libclang-5.0-dev llvm-5.0 llvm-5.0-dev</code> </pre> <br>  Further: <br><br><pre> <code class="plaintext hljs">sudo apt install bison cmake flex g++ git libelf-dev zlib1g-dev libfl-dev</code> </pre> <br>  And finally, install libbfcc-dev from upstream, and not from the Ubuntu repository.  In the package that is in Ubuntu, there are <a href="https://github.com/iovisor/bpftrace/pull/335">no header files</a> .  And this problem was not solved even at 18.10. <br><br><pre> <code class="plaintext hljs">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 4052245BD4284CDD echo "deb https://repo.iovisor.org/apt/$(lsb_release -cs) $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/iovisor.list sudo apt update sudo apt install bcc-tools libbcc-examples linux-headers-$(uname -r)</code> </pre> <br>  <b>Basic bpftrace installation</b> <br><br>  It's time to install bpftrace itself from source!  Let's clone it, build it, and install it in / usr / local: <br><br><pre> <code class="plaintext hljs">git clone https://github.com/iovisor/bpftrace cd bpftrace mkdir build &amp;&amp; cd build cmake -DCMAKE_BUILD_TYPE=DEBUG .. make -j4 sudo make install</code> </pre> <br>  And you're done!  The executable will be installed in / usr / local / bin / bpftrace.  You can change the target location using the argument for cmake, which by default looks like this: <br><br><pre> <code class="plaintext hljs">DCMAKE_INSTALL_PREFIX=/usr/local.</code> </pre> <br>  <b>Single line examples</b> <br><br>  Let's run a few bpftrace one-liners to understand our capabilities.  These I took from the <a href="">leadership of Brendan Gregg</a> , in which there is a detailed description of each of them. <br><br>  # 1. Display the list of sensors <br><br><pre> <code class="plaintext hljs">bpftrace -l 'tracepoint:syscalls:sys_enter_*'</code> </pre> <br>  # 2. Welcome word <br><br><pre> <code class="plaintext hljs">bpftrace -e 'BEGIN { printf("hello world\n"); }'</code> </pre> <br>  # 3. Opening a file <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_enter_open { printf("%s %s\n", comm, str(args-&gt;filename)); }'</code> </pre> <br>  4. Number of system calls per process <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[comm] = count(); }'</code> </pre> <br>  # 5. Distribution of read () calls by the number of bytes. <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:syscalls:sys_exit_read /pid == 18644/ { @bytes = hist(args-&gt;retval); }'</code> </pre> <br>  # 6. Dynamic tracing of read () content <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kretprobe:vfs_read { @bytes = lhist(retval, 0, 2000, 200); }'</code> </pre> <br>  # 7. Time spent reading () calls <br><br><pre> <code class="plaintext hljs">bpftrace -e 'kprobe:vfs_read { @start[tid] = nsecs; } kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); }'</code> </pre> <br>  8. Process level event counting <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched* { @[name] = count(); } interval:s:5 { exit(); }'</code> </pre> <br>  # 9. Profiling of core workstations. <br><br><pre> <code class="plaintext hljs">bpftrace -e 'profile:hz:99 { @[stack] = count(); }'</code> </pre> <br>  # 10. Tracer scheduler <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:sched:sched_switch { @[stack] = count(); }'</code> </pre> <br>  11. Tracing blocking I / O <br><br><pre> <code class="plaintext hljs">bpftrace -e 'tracepoint:block:block_rq_complete { @ = hist(args-&gt;nr_sector * 512); }'</code> </pre> <br>  Take a look at the Brendan Gregg website to find out <a href="http://www.brendangregg.com/ebpf.html">what output the commands listed above can generate</a> . <br><br>  <b>Script syntax and I / O timing example</b> <br><br>  The string passed through the '-e' key is the contents of the bpftrace script.  The syntax in this case is, conditionally, a set of structures: <br><br><pre> <code class="plaintext hljs">&lt;event source&gt; /&lt;optional filter&gt;/ { &lt;program body&gt; }</code> </pre> <br>  Let's look at the seventh example, about the file system read timings: <br><br><pre> <code class="plaintext hljs">kprobe:vfs_read { @start[tid] = nsecs; } &lt;- 1 -&gt;&lt;-- 2 -&gt; &lt;---------- 3 ---------&gt;</code> </pre> <br>  We trace the event from the <i>kprobe</i> mechanism, i.e., we trace the beginning of the kernel function. <br>  The kernel tracing function is <i>vfs_read</i> , this function is called when the kernel performs a read operation from the file system (VFS from ‚ÄúVirtual FileSystem‚Äù, file system abstraction inside the kernel). <br><br>  When <i>vfs_read</i> begins to <i>run</i> (i.e. before the function has completed any useful work), the bpftrace program is started.  It saves the current timestamp (in nanoseconds) to a global associative array called <i><a href="https://habr.com/ru/users/st/" class="user_link">st</a> art</i> .  The key is <i>tid</i> , a link to the current thread identifier (thread id). <br><br><pre> <code class="plaintext hljs">kretprobe:vfs_read /@start[tid]/ { @ns[comm] = hist(nsecs - @start[tid]); delete(@start[tid]); } &lt;-- 1 --&gt; &lt;-- 2 -&gt; &lt;---- 3 ----&gt; &lt;----------------------------- 4 -----------------------------&gt;</code> </pre> <br>  1. We trace the event from the <i>kretprobe</i> mechanism, which is similar to <i>kprobe</i> , except that it is called when the function returns the result of its execution. <br><br>  2. Kernel tracing function - <i>vfs_read</i> . <br><br>  3. This is an optional filter.  It checks if the start time has been previously recorded.  Without this filter, the program can be run while reading and catch only the end, resulting in getting the <i>estimated</i> time <i>nsecs - 0</i> , instead of <i>nsecs - start</i> . <br><br>  4. The body of the program. <br><br>  <i>nsecs - <a href="https://habr.com/ru/users/st/" class="user_link">st</a> rt [tid]</i> calculates how much time has passed since the start of the vfs_read function. <br>  <i>@ns [comm] = hist (...)</i> adds the specified data to a two-dimensional histogram stored in <i>@ns</i> .  The <i>comm</i> key refers to the name of the current application.  So we will have a pokandnaya histogram. <br><br>  <i>delete (...)</i> removes the start time from the associative array, because we no longer need it. <br><br>  This is the final conclusion.  Please note that all histograms are displayed automatically.  Explicit use of the "print histogram" command is not required.  <i>@ns</i> is not a special variable, so the histogram is not displayed because of it. <br><br><pre> <code class="plaintext hljs">@ns[snmp-pass]: [0, 1] 0 | | [2, 4) 0 | | [4, 8) 0 | | [8, 16) 0 | | [16, 32) 0 | | [32, 64) 0 | | [64, 128) 0 | | [128, 256) 0 | | [256, 512) 27 |@@@@@@@@@ | [512, 1k) 125 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ | [1k, 2k) 22 |@@@@@@@ | [2k, 4k) 1 | | [4k, 8k) 10 |@@@ | [8k, 16k) 1 | | [16k, 32k) 3 |@ | [32k, 64k) 144 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@| [64k, 128k) 7 |@@ | [128k, 256k) 28 |@@@@@@@@@@ | [256k, 512k) 2 | | [512k, 1M) 3 |@ | [1M, 2M) 1 | |</code> </pre> <br><br>  <b>USDT sensor example</b> <br><br>  Let's take this C code and save it in the <i>tracetest.c</i> file: <br><br><pre> <code class="plaintext hljs">#include &lt;sys/sdt.h&gt; #include &lt;sys/time.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; static long myclock() { struct timeval tv; gettimeofday(&amp;tv, NULL); DTRACE_PROBE1(tracetest, testprobe, tv.tv_sec); return tv.tv_sec; } int main(int argc, char **argv) { while (1) { myclock(); sleep(1); } return 0; }</code> </pre> <br>  This program runs infinitely, calling <i>myclock ()</i> once a second.  <i>myclock ()</i> requests the current time and returns the number of seconds since the beginning of the epoch. <br><br>  The <i>DTRACE_PROBE1</i> call here defines the static point of the USDT trace. <br><br><ul><li>  The <i>DTRACE_PROBE1</i> macro is taken from <i>sys / sdt.h.</i>  The official USDT macro, which does the same thing, is called <i>STAP_PROBE1</i> (STAP from SystemTap, which was the first Linux mechanism supported in USDT).  But since USDT is compatible with DTrace user-space sensors, <i>DTRACE_PROBE1</i> is simply a reference to <i>STAP_PROBE1</i> . </li><li>  The first parameter is the name of the provider.  I guess this is a rudiment from DTrace, because it doesn't seem like bpftrace does anything useful with it.  However, there is a nuance ( <a href="https://github.com/iovisor/bpftrace/issues/328">which I found when debugging the problem on request 328</a> ): the provider name must be identical to the name of the application's binary file, otherwise bpftrace will not be able to find the trace point. </li><li>  The second parameter is the proper name of the trace point. </li><li>  Any additional parameters are the context provided by the developers.  The number <i>1</i> in <i>DTRACE_PROBE1</i> means that we want to pass one additional parameter. </li></ul><br>  Let's make sure that sys / sdt.h is available to us and build the program: <br><br><pre> <code class="plaintext hljs">sudo apt install systemtap-sdt-dev gcc tracetest.c -o tracetest -Wall -g</code> </pre> <br>  We instruct bpftrace to display the PID and ‚Äútime is [number]‚Äù whenever the <i>testprobe is</i> reached: <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/full-path-to/tracetest:testprobe { printf("%d: time is %d\n", pid, arg0); }'</code> </pre> <br>  Bpftrace continues to work until we press Ctrl-C.  Therefore, we will open a new terminal and run <i>tracetest</i> there: <br><br>  # In the new terminal <br>  ./tracetest <br><br>  Go back to the first terminal with bpftrace, there you should see something like: <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... 30909: time is 1549023215 30909: time is 1549023216 30909: time is 1549023217 ... ^C</code> </pre> <br>  <b>An example of allocating a memory area with glibc ptmalloc</b> <br><br>  I use bpftrace to figure out why Ruby uses so much memory.  And in part of my research, I need an understanding of how the glibc memory allocator uses <a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">memory areas</a> . <br><br>  In order to optimize multi-core performance, the glibc memory allocator allocates several ‚Äúareas‚Äù from the OS.  When an application requests a memory allocation, the allocator selects an area that is not used, and marks part of that area as ‚Äúin use‚Äù.  Since threads use different regions, the number of locks decreases, resulting in improved multi-thread performance. <br><br>  But this approach generates a lot of garbage, and it seems that such a high memory consumption in Ruby is precisely because of it.  In order to better understand the nature of this garbage, I asked myself: what does it mean to ‚Äúchoose an area that is not used‚Äù?  This may mean one of: <br><br><ul><li>  With each call to <i>malloc (), the</i> allocator iterates through all areas and finds the one that is not currently locked.  And only if they are all blocked, will he try to create a new one. </li><li>  The first time <i>malloc () is</i> called for a specific thread (or at the start of a thread), the allocator will choose the one that is not currently blocked.  And if they are all blocked, he will try to create a new one. </li><li>  When you first call <i>malloc () on a</i> specific thread (or when starting a thread), the allocator will try to create a new area, regardless of whether there are unlocked areas.  Only if a new area cannot be created (for example, when the limit is exhausted) will it reuse the existing one. </li><li>  There are probably more options that I did not consider. </li></ul><br>  The documentation does not have a specific answer, which of these possibilities allows you to select an area that is not used.  I studied the glibc source code, which suggested that option 3 could do this.  But I wanted to experimentally check whether I interpreted the source code correctly, without having to enter the debugging code in glibc. <br><br>  Here is the glibc memory allocator function, which creates a new region.  But you can call it only after checking the limit. <br><br><pre> <code class="plaintext hljs">static mstate _int_new_arena(size_t size) { mstate arena; size = calculate_how_much_memory_to_ask_from_os(size); arena = do_some_stuff_to_allocate_memory_from_os(); LIBC_PROBE(memory_arena_new, 2, arena, size); do_more_stuff(); return arena; }</code> </pre> <br>  Is it possible to use <i>uprobes</i> to trace the <i>_int_new_arena</i> function?  Unfortunately not.  For some reason, this symbol is not available in glibc Ubuntu 18.04.  Even after installing debug symbols. <br><br>  Fortunately, there is a USDT sensor in this function.  <i>LIBC_PROBE</i> is a macro alias for <i>STAP_PROBE</i> . <br>  The name of the provider is libc. <br>  The sensor name is memory_arena_new. <br>  The number 2 means that there are 2 additional arguments given by the developer. <br>  arena is the address of the area that was allocated from the OS, and size is its size. <br><br>  Before we can use this sensor, we need <a href="https://github.com/iovisor/bpftrace/issues/328">to work around problem 328</a> .       glibc -    <i>libc</i> ,   bpftrace ,    (      <i>libc-2.27.so</i> )     <i>(libc)</i> . <br><br><pre> <code class="plaintext hljs">ln -s /lib/x86_64-linux-gnu/libc-2.27.so /tmp/libc</code> </pre> <br>    bpftrace   USDT  <i>memory_arena_new</i> ,     <i>libc</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'usdt:/tmp/libc:memory_arena_new { printf("PID %d: created new arena at %p, size %d\n", pid, arg0, arg1); }'</code> </pre> <br>      Ruby,           . -    Ruby <i>malloc()</i>      . <br><br><pre> <code class="plaintext hljs">ruby -e '3.times { Thread.new { } }; sleep 1'</code> </pre> <br>     bpftrace,  : <br><br><pre> <code class="plaintext hljs">Attaching 1 probe... PID 431: created new arena at 0x7f40e8000020, size 576 PID 431: created new arena at 0x7f40e0000020, size 576 PID 431: created new arena at 0x7f40e4000020, size 576</code> </pre> <br>     !        Ruby glibc     . <br><br> <b>   ?    ?</b> <br><br>     , , kprobe     ,  : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l</code> </pre> <br>       uprobe ( )   , : <br><br><pre> <code class="plaintext hljs">nm /path-to-binary</code> </pre> <br>       USDT   ,   : <br><br><pre> <code class="plaintext hljs">/usr/share/bcc/tools/tplist -l /path-to/binary</code> </pre> <br>  ,    :       ,    .      . <br><br> <b>:      </b> <br><br>       .   ,    ,   /sys/kernel/debug/tracing/events! <br><br> , ,      <i>madvise(..., MADV_DONTNEED)</i> : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -l | grep madvise</code> </pre> <br> ‚Äî  ,     tracepoint:syscalls:sys_enter_madvise. <br><br><pre> <code class="plaintext hljs">sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_madvise/format</code> </pre> <br> ‚Äî    : <br><br><pre> <code class="plaintext hljs">name: sys_enter_madvise ID: 569 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:unsigned long start; offset:16; size:8; signed:0; field:size_t len_in; offset:24; size:8; signed:0; field:int behavior; offset:32; size:8; signed:0; print fmt: "start: 0x%08lx, len_in: 0x%08lx, behavior: 0x%08lx", ((unsigned long)(REC-&gt;start)), ((unsigned long)(REC-&gt;len_in)), ((unsigned long)(REC-&gt;behavior))</code> </pre> <br>  madvise  : <i>(void *addr, size_t length, int advice)</i> .        ! <br><br>   MADV_DONTNEED?   grep MADV_DONTNEED /usr/include,   4: <br><br><pre> <code class="plaintext hljs">/usr/include/x86_64-linux-gnu/bits/mman-linux.h:80:# define MADV_DONTNEED 4 /* Don't need these pages. */</code> </pre> <br>     bpftrace : <br><br><pre> <code class="plaintext hljs">sudo bpftrace -e 'tracepoint:syscalls:sys_enter_madvise /args-&gt;behavior == 4/ { printf("madvise DONTNEED called\n"); }'</code> </pre> <br><h3>  Conclusion </h3><br> Bpftrace ! Bpftrace ‚Äî  ! <br><br>       ,      <a href=""> </a> ,    <a href="http://www.brendangregg.com/blog/2019-01-01/learn-ebpf-tracing.html">  2019 </a>    . <br><br>  ! </div><p>Source: <a href="https://habr.com/ru/post/441258/">https://habr.com/ru/post/441258/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441246/index.html">Qualcomm Introduces Snapdragon X55 Universal 5G Chip</a></li>
<li><a href="../441248/index.html">Russia ranked 9th in the global SSL rating, ahead of China, Denmark and Switzerland</a></li>
<li><a href="../441250/index.html">Quick start: Go + Apache Kafka + Redis</a></li>
<li><a href="../441252/index.html">"Article about blowjob": scientists have processed 109 hours of oral sex to develop an AI that sucks dick</a></li>
<li><a href="../441254/index.html">Seminar ‚ÄúWhy we contacted Kubernetes and what we get from this,‚Äù February 28, Moscow</a></li>
<li><a href="../441260/index.html">How Neural Networks Helped Graphics</a></li>
<li><a href="../441262/index.html">Simple and long tasks filter out candidates better than short and complex ones.</a></li>
<li><a href="../441264/index.html">Kibana User Guide. Visualization. Part 2</a></li>
<li><a href="../441266/index.html">How the tiOPF framework for delphi / lazarus works. Template "Visitor"</a></li>
<li><a href="../441268/index.html">Ceedling + Eclipse or unit tests for microcontrollers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>