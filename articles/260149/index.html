<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I found the best programming language in the world. Piece Yo (2.72)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since after the second part I had a break for work, I had the opportunity to get some feedback, which, although I haven‚Äôt processed yet, still makes m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I found the best programming language in the world. Piece Yo (2.72)</h1><div class="post__text post__text-html js-mediator-article">  Since after the <a href="http://habrahabr.ru/post/259841/">second part</a> I had a break for work, I had the opportunity to get some feedback, which, although I haven‚Äôt processed yet, still makes me write an unplanned part of Yo, which seems to me important for further discussion.  The third part is connected with the same work break, I apologize for those who really waited and did not wait. <br><a name="habracut"></a><br>  To those who were initially skeptical, I want to say that I did not intend and do not intend to agitate anyone for this or that language.  I just wrote with one sincere goal: to share the joy of discovery.  When rushing (and with age rushing less and less, especially from such, like, little things in life, like a programming language) I want to share.  Here is a rare and childish desire: guys, look how cool!  Especially since I really waited, searched, and worried about the question for many years, and the answer from him was not obvious to me, even though I passed it more than once. <br><br>  I am very grateful to you all, and simply have to (at least before a part of thinking and wanting young people) to finish the article, and more useful ideas can appear in their heads, and shit in these heads in any case throws life and the Internet.  Therefore, I will continue in a boring, non-technical way; it seems to me wrong to continue without setting the discourse: <br><br><h4>  Programming language - why? </h4><br>  Everyone agrees that the programming language is a tool, a means of expressing thought (if there is a thought, of course).  Since thoughts can be expressed in different ways, I will clarify what to express thoughts to me, as a rule, it is interesting only for solving set tasks.  The tool with which create software.  In this case, the only logical requirement that can, and should, be made to the programming language is an <i>increase in the programmer‚Äôs productivity</i> here and now.  <i>In the short, medium, and long term.</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many general purpose languages ‚Äã‚Äãare equally applicable to most tasks (therefore, they are called <i>general-purpose</i> ), and I will not consider cases where the language is uniquely focused on solving the problem.  In these cases, everything is more or less clear, and if disputes arise, they are more substantive.  The most frequent case is interesting, when the problem is quite normally solved in dozens of languages ‚Äã‚Äã(and this is just a common situation).  Well, for example, in the question: what to choose for the server from the list of Java, Go, or JavaScript - srach is provided. <br><br>  The thesis that a language is a tool for creating software is undeniable for me, and from this follows my requirement for the language to increase the productivity of a team.  Practice shows that not many talk about languages ‚Äã‚Äãfrom this position. <br><br>  In addition, in discussions about languages, we divide languages ‚Äã‚Äãinto classes (dynamic typing, managed runtime, and so on), divide tasks into classes, but for some reason, we almost never break up ‚Äúprogrammers‚Äù into classes.  Sometimes, of course, we do it, but most often breaking into programmers into ‚Äúbeginners‚Äù and other ‚Äúprogrammers‚Äù, and this usually happens only when the ‚Äúnovice‚Äù himself identifies himself to this class.  However, this classification is immediately lost, because even the very terry lamer, in response, can start broadcasting from the position of a guru, without thinking at all about which class he belongs to.  If, in addition to languages ‚Äã‚Äãand tasks, to begin to classify also the participants of the discussion (and this should be done), then the zoo is drawn as one. <br><br>  The topic of classifications of programmers is a separate and certainly most interesting story on the verge of psychology (or psychiatry), which you can do at your leisure.  Now I will give a couple of examples that already say that the influence of the subject and his motives in matters of language assessment is no less great (or rather more) than the language itself or the tasks for which it is chosen.  Well, for example: <br><br><h5>  Asshole </h5><br>  I have one not very good acquaintance (not very good, in the sense that I am not proud of meeting him).  He struck me a dozen years ago, telling a story about how, as a student, he wrote an order product to one counter.  He and his friend wrote a product on Clarion (there was such a beast, but I‚Äôm not so old to tell something about him - it took me by).  So a friend as a student, consciously chose Clarion, because he thought that it would be difficult to find a programmer on Clarion, and the customer would always contact his comrades for support and development of the system. <br><br>  Of course, I said that it was a madhouse, and that they had set themselves up with cancer, and had forgotten this story, until I met a friend once again, about six months ago.  An acquaintance told me that he was going to Brazil on a business trip.  Helping the Brazilians to do a very well-conceived system of something there on Scala.  Unfortunately, he drives alone, because his companions did not have enough intelligence to write such a clever code, but he and he can do nothing.  And in the end he added that he was very happy to work with such smart Brazilians and admired their plan.  The plan was simple: it is imperative to write everything on Scala, and the architecture should be such that the average person doesn‚Äôt get into it.  That will allow them to capture a small but monetary niche market in North America, and live happily ever after, receiving monthly checks for the support of the hardest product. <br><br>  In the matter of choosing the language of the assholes, the question of productivity, if it takes some place, is far from the first.  But there is another extreme. <br><br><h5>  Microblogger </h5><br>  There are many different frames showing genuine interest in programming languages.  Sometimes such personnel, by virtue of their own inferiority, are more than any other of us interested in increasing our own productivity (and, as it were, in this matter are on the right side).  For many years they have been accompanied by a feil for a feil, and now life is passing, and they have nothing to show as the result of their work.  I have seen quite a few such people, these people assembled teams, or did something alone, usually in the language and technologies that are gaining popularity, sincerely thinking that this is the language and tools that will lead them to success.  All previous failures such people associate with useless tools used in the past, but not with himself. <br><br>  There are, for example, microbloggers that are popular in narrow circles. They have been talking about the coolness of everything that I consider too clever for me, and don‚Äôt even bother with these stories. , but did not have time to appreciate the beauty of Idris (or something there).  The trouble is that the microblogging listens to young people, nods and draws in his head a picture of a successful programmer who does smart things, not bytovuha, as they probably want to be just as smart.  And they don‚Äôt know that in real life a ‚Äústar of functional programming‚Äù, for example, delves into millions of Perl lines in a team of 100 people, and has no experience whatsoever to use.  The star is the fourth decade, and in one place of work he was not kept more than three, and he could not leave a trace in life.  There is not a single line of his code in the whole Internet, except that ported other people's lines from something to Haskell, or from PHP to Perl. <br><br>  The microblogger is also looking for a magic wand in the language, which will finally give him the opportunity to create something himself, but does not find it, and jumps from one language to another, with the hope that here he is: the very language that will fall on his mental model, and he can create, but no, and no, and no.  And he is again in dismal work alone with Perl ... Now I will pay ... But the microblogger is not crying!  He goes to social networks, and now the world sees a guru of functional programming, a giant of thought, the pinnacle of a professional career.  And dozens of young men inspired to quit programming and begin to study Haskell (or what the microblogger is currently considering as a wand), hoping to become the same as him. <br><br>  Despite the fact that their own productivity for such people is the most important task of the paranoia being spurred on, and other mental problems, such people are not able to give an adequate assessment of the language in terms of productivity, for the reason that the nature of the productivity module was embarrassed for them to put ).  Such dudes can usefully be used as sources of objective information, but listening to their conclusions is quite harmful.  In defense of microblogging, I will say that of course not all of them are the same as the frame described above, many are just interested, someone has a hobby, someone has a science, and someone has a job.  But only a small part of them consciously consider the subject of which speaks in the context of their own productivity (in other matters, just like non-microbloggers). <br><br>  I cited the example of quite rare, though not unique cases, I will not go on detailing any further - there is work for a week.  But all I will note a certain extensive class of programmers, which is characterized by an adequate attitude towards the language, just because it is not important for them.  These are those whose work can hardly be called programming (during interviews they usually cannot ‚Äúexpand‚Äù the list or the proposal to implement a hash table, sincerely puzzled ‚Äúwhy, it's already done for me‚Äù, especially interesting individuals are surprised to ask about how this is generally possible (after all, hash tables appear in their languages ‚Äã‚Äãfrom creators from another planet - author's note.). These people are usually engaged in collecting from all that there is something working, and getting money for it. These dudes belong to  The hammer is calm as if it were a hammer, the impact of language on their performance is minimal, and many of them hardly ask this question. Their whole experience of assembling products from sticks and artifacts from other people shows that the language in their activities does not affect their productivity at all comparison with the quality and capabilities of the pieces they glue together. <br><br><h5>  Other diseases </h5><br>  In short, life shows that a person, as a rule, is an inadequate being, and that which should be logical and taken for granted is a rarity.  In addition to the various classifications of programmers and teams with different values ‚Äã‚Äãand interests, there are a number of intellectual dysfunctions transmitted from a programmer to a programmer in a viral way.  Young programmers with no experience are especially easy to infect, hitting a sick team as their first job (and viruses and microbes are everywhere, and, if anything, without hygiene and pills, any team is susceptible to infections).  Sometimes viruses are entered into the team consciously: there are examples when people consciously complicate systems to increase the budget (although this is a category of assholes), but more often viruses are spread around the offices in chronicles, or occur in stupidity in a nutrient medium. <br><br>  A young man struck with such a virus behaves approximately as follows: we had such a frame, which we only took and gave a separate task.  Well, the frame did something for a couple of weeks and comes to consult, saying that I‚Äôve been thinking up here and so, the scheme doesn‚Äôt fit on the board, but everything seems to be fine, but here‚Äôs another pair of use cases that don‚Äôt work at the same time, like let's choose only one -theorist, damn it).  Well, they say to him, but let's throw all this fuck up and make two such things.  The dude hangs for five minutes in the deadlok, then it starts producing some sounds: ‚Äúwell,‚Äù ‚Äúwell,‚Äù ... - ‚Äúwhat is it?‚Äù - ‚Äúwell, it's too simple.‚Äù  Virus chopping off the ability to think is simply generally common as a cold.  A student comes to some office, a monster has already been built there, which is crumbling and it is necessary to support this monster through various places, but God forbid, also to develop it.  Shit, sticks, crutches, holes, ten people instead of two, and all have long been infected with one of the brain programmer viruses.  By the way, most young men still come healthy, so we often hear that "inexperienced programmers tend to rewrite all the code."  But no one gives it to him, he gets used to it, relaxes, and pipets, fell ill.  After a couple of years he will never have a thought that this should not be so.  A software product is a complicated thing.  Programmers get a lot of money for what these complex things do, and there is no other way. <br><br>  By the way, in almost any city, when people from famous offices come to the sobesh, you can with a high degree of probability predict whether he is healthy or sick, and if he is sick then with what, since the infection eventually affects almost everyone.  I distinguish it from the culture, which is like a magnetic field, which ceases to influence the programmer after leaving the office, though sometimes leaving a trace in it.  Programmers affected by a variety of viruses rarely think about the main requirement for the language - they are worried about many different details, but not productivity, as well as the whole question <i>why?</i>  they care little. <br><br><h4>  Programming language - why? </h4><br>  But if not all programmers see language as a means of increasing their own productivity in production, then, perhaps, the creators create languages ‚Äã‚Äãin order to increase the productivity of programmers? <br><br>  As if not so.  The goals of the creators of languages ‚Äã‚Äãare also surprisingly diverse.  That is why Odersky created Scala?  Maybe these were purely academic (research) goals, and as a researcher, he was interested in doing something new around the idea of ‚Äã‚Äãa bundle of functional and object-oriented programming.  From the <a href="http://www.slideshare.net/Odersky/scala-evolution">presentation</a> : in the creation of Scala, he was motivated by two hypotheses.  Moreover, most other languages ‚Äã‚Äãare not motivated by one or both of these hypotheses.  And if the hypotheses are not true, then where will Scala be?  And if there are true, where will other languages ‚Äã‚Äãbe?  Or maybe these hypotheses are generally bullshit for ‚Äúbeauty‚Äù.  Maybe he was just doing a kind of university ‚Äúplan‚Äù and just like you ask: hypotheses and pants for birds.  Or maybe Sun offended him with something, while he worked with them: <br><br><blockquote>  Sun hired by Martin Odersky to the Generics for Java, and the Generic Java compiler actually became the standard javac compiler shipped with the SDK as early as Java 1.2.  Was released with java 1.5.  Odersky, of course, went on scoring, then his compiler still ships with Java 8. </blockquote><br><br>  Why not?  Imagine Martin is pushing ideas to Sana, that‚Äôs what he says, and they turn him around.  As a result, in general, his work in the world does not appear in either 1.2 or 1.3.  And in 1.5 something goes out that is not quite what he considered correct (I have no information just here just born conspiracy theory).  Well, he was so angry and like <i>‚Äúright now, I‚Äôll give you [synonyms] darned, I‚Äôll show you the language to which you will be what you are - [synonym]‚Äù</i> and it started ... And the language was created not for what you think, but to get someone, and to show who is the main language here. <br><br>  It is clear that a good language, especially written by brilliant dudes, such as Odersky, can be used in different ways, and it will be good.  But still, the maximum effect of the language will be in the case when it is used in accordance with the goals for which the language was created. <br><br>  Here is a wonderful Clojure.  She was born initially from <a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">Rich Hickey's</a> great ideas <a href="http://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey">about ‚Äústate, identity, value, time, types‚Äù</a> , the dude wondered about what new constructions are needed to solve current and future problems of cancarency and parallelism.  Initially there was a problem, an idea, and a solution that was in the area of ‚Äã‚ÄãPersistent Data Structures, STM, and so on.  I am absolutely sure that Persistent Vector first appeared and then Clojure.  And the fact that beloved by some Clojure looks like Lisp and the dialect of what it is can only be a coincidence.  Most likely Lisp was the language that Rich was ready to implement as quickly as possible, and which in principle suited him.  Stack stars differently, he could take or come up with another language.  I mean that the language here is generally secondary. <br><br>  I want to highlight the importance of the goals of the creators.  Someone says Clojure is cool because I can elegantly manage the state, cancarenci is there blah.  Not!  This is not a programming language (Clojure as a Lisp dialect) allows you to do this, but Rich's ideas.  Language has been added to these ideas as a means of using ideas.  These concepts, being implemented in other languages, and they do not need a special ‚Äúspecial‚Äù language, the programmer will receive all the same joys for which many people love Clojure.  You need to clearly understand what you like about the language: concepts that are easily transferred to other languages, such as the same PDS, are dragged into JavaScript or you are sprung from the language itself (the Lisp dialect in this case). <br><br>  I want to say that the creators of languages ‚Äã‚Äãare very rarely set out to <i>create a language with which the programmer will be more productive</i> .  Often they solve some other tasks and the language appears as a result of solving these problems.  A good example of javascript.  Nobody thinks that JavaScript was done so that you can increase your productivity and write code more powerful, faster, better.  Or does someone think?  (smile). <br><br>  From the creator: <a href="https://brendaneich.com/2008/04/popularity/">brendaneich.com/2008/04/popularity</a> .  In general, Brebdan Eich was invited to Mozilla to write a Scheme for the browser, and if this initial plan was not corrected, you would write everything to Scheme now and tell how cool it is, you can, youth (sorry, almost choked).  Why do you now write not to Scheme but to JavaScript ‚Äî it‚Äôs also not connected with the desire to make you more productive.  Starting from the fact that Scheme didn‚Äôt run it because management wanted a language with a syntax similar to Java exiting at the same time from Sun.  For a lot of reasons, not related to programming and productivity at all, they threw out the language made in record time on a shovel and the author himself doesn‚Äôt even understand whether he is popular in 2010 and how this applies, and the reasons for the popularity of the language are definitely not related to the fact that perfectly fulfills its main purpose (in my understanding) - an increase in the productivity of a programmer. <br><br><h4>  The main and only goal </h4><br>  Having such a variety of programmers, languages, and tasks, all these three parameters can come together absolutely in any way ideal for this case, and it would be silly to talk about ‚Äúthe world's best programming language‚Äù, but I will still insist.  I will still return to the language as an instrument and speak only for myself. <br><br><blockquote>  Language can be adequately assessed with only one purpose - production. </blockquote><br><br>  Production is when we know what we have to do (although we cannot know how), we have terms and other restrictions, and we have a real reward / penalty for the result or lack of it.  Under this definition fits both the actual production, and, for example, course work and assessment ka result (well, I mean the way it should be). <br><br>  The truth is (and perhaps one of the reasons for so diverse opinions about languages) that most of us are interested in languages ‚Äã‚Äãwith diverse goals (learning, curiosity, increasing CSW), but not for increasing productivity in production.  Often we simply do not have the ability to change language.  Therefore, most of our time is the most important - we have no industrial interest in languages.  He is at best either educational or just curiosity.  Either you design the language - but this is also a rarity. <br><br>  The programmer should consider the language as a tool to increase the productivity of themselves and colleagues, and here and now, and not in the distant future, then the view of the language will be more or less adequate.  If you are not ready to take the language right now in production - this is all in the sandbox, the purpose for which you are interested in the language is what is pleasing but not a production necessity.  And then you can argue with colleagues for a long time about the features and concepts of any language, and so on, with any result that makes no sense other than self-development or degradation of interlocutors. <br><br>  Language, as a means of production, must possess only one property.  <i>One</i> fucking property, and all the others are not important.  That is not important at all.  It does not matter whether you have generics or not, and so on, only the effect of the combination of these properties on productivity is important.  The production tool should increase team productivity in the short, medium and long term.  Everything. <br><br>  In 1999 I worked in a fairly large office and then two holivorny themes were popular, because there were only two, and not dozens like now, they were cut off for life and death.  These themes are naturally Windows vs Linux and C ++ vs Java.  So while people were fighting in the smoking room for Java or against, I stood by and quietly neigh (and sometimes loudly).  The reason was simple: I had a project then, well, let's say a search engine on the Intranet, or something like that.  And I got together to write foolishly in C for the reasons that young people are now citing as an argument (ecosystem).  So, following this argument, it was impossible to write to Java then (for 1.2, in my opinion, it was still only in beta), and there is no ecosystem at all.  And on the pros there were some types of useful frameworks and frameworks. <br><br>  In the Java world, even Lucene did not exist at that time, appeared a little later and was at the moment none.  Well, okay, so I kind of fell for it, that I should write on the pros, I ate shit (in the sense that instead of programming - I thought for the compiler, I crossed libraries, and so on).  Thank God I had a production opportunity to spit on everything and rewrite in Java.  First of all, the guys twirled at the temple, they said that the speed was not enough, I had to show that we only do what we read that file, but this doesn‚Äôt have anything to do with Java. <br><br>  It took me 10 times less time to creatively rework what I had to do with Java pluses than the original (yes, I was of course already in the subject, but at the time of writing the original version of the search, there were no documents describing the indexing and crawling algorithms from a couple of dudes from Stanford - Sergey and Larry called them in my opinion, everything was simple and clear, and their patented algorithm for ranking search results with our volumes was not needed and useless. Those guys, by the way, just then opened a company search in  Internet). <br><br>  Well, here I stand, it means in a smoking room, I listen to chatter for templates, overloading and redefining what is possible, macros-shmacros, allocators, performance and multiple inheritance (!).  C ++ gurus attack little students and dump the power of this language on them.  Type you here on your Java and so can not, and that's how you can not, and that's how it will not get (as in that joke, make me a cancer).  And I cho that to myself ryu, and quite smile.  I spit all these your allocators with templates on my multiple inheritance.  What a difference to me that you can do it, and how can you, if <i>I can write code 10 times faster than you</i> , well, an experienced C ++ programmer who already has everything in blood and other parts of the body will write faster, which means I will be faster it is 5 times.  Yes, at least 2-3 times. <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If I do the same thing 2 times faster, what do I care what he has there for templates</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . And the limitations? Yes, they are not - we had enough speed, memory, too, and we were not going to write OS kernels. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a crazy thrill when you write code freely, almost without thinking, not expecting core dumped before each launch, when features are added right before our eyes, now we can, and now, tell me please, what difference does it make to me I do not have templates if I did not even miss them? Productivity is the main goal of the programmer who does things, and the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> task of the tool he uses.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such bright flashes, when you seemed to be programming as usual, hard, as at the construction site, the bricks are dragged, and then suddenly I got a wonderful tool in hand, a magic wand, and the bricks began to fly wherever you want, I only experienced a couple of years ago. More than twenty years of programming for the money. I have already said about the transition from C ++ to Java. It was about the same when we programmed desktop applications in Visual C ++ 1.0, 1.5 or so. Then, to make a thread of dialogue with three buttons (which will not soon start working as it should) was a big task, for a day so. All these macros, and other crap, which I fortunately do not remember. In order, if anything, to understand how, in fact, your code communicates with Windows, it was necessary to go insane by going through the mountains of plus libraries.</font></font><br><br>    Delphi.    ,      (       ,   Delphi, Anders Hejlsberg  Microsoft   ,     Microsoft Anders    C#).  ,    Delphi    ,   ,   ,  flow ,   ,      (     Microsoft,      Dephi). ,                 (   ),   , <i>    ,     10,      </i> . ?   .  ,         . <br><br>       ,    .             :)  ,     Rich Hickey,   <a href="http://www.infoq.com/presentations/Simple-Made-Easy">‚Äú </a> ‚Äù ‚Äî   .           ,        .      ()       ‚Äî  ,     ,   : <i>  /,       </i> . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are good examples in the JVM world. Yes, and Java itself is such an example, if we compare Java with C ++, let's say it is as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">follows</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Java will lose, well, just with a crushing score. But there is a complicated thing inside the JVM that is not in the pros - the Garbage Collector. Java without GC (although it would not be Java at all) would not give me the opportunity to write code many times faster. As you do not simplify further or do not complicate again. The productivity of the programmer has grown many times by and large due to garbage collection (this is when the compiler and runtime think for you, all the time), and it does not create interferences (except recently, due to cheap memory and the trend to write everything in Java, GC in some cases it becomes a problem again).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generic 1.5, did not complicate the use of Java, but only increased productivity. The same thing seems to be with lambdas (but honestly I will say that I did not find it anymore). Exactly this reason - the increase in productivity, made me think about a more productive language than Java in 2008, and therefore I hoped for the Fantom. I want to give him as an example of a language whose main idea was and is to increase the productivity of the programmer. The guys who made Fantom their main goal were productivity, here and now, in our real work:</font></font><br><br><blockquote> Fantom is designed as a practical programming language to make it easy and fun to get real work done. It is not an academic language to explore bleeding edge theories, but based on solid real world experience. During its design we set out to solve what we perceived were some real problems with Java and C#. Our background is heavily Java, but many of Java's problems are shared by C# and .NET also. </blockquote><br><br>  -    ,    .          ,            ,         Java,           Java           ,    <i> </i> ( Fantom    Java    FFI  native classes,       ),    ‚Äî  ,    ,   , ,        . <br><br> Fantom           ,  ,        Java       .            ,        .   ,              ?       ,      ,   ,   .        . <br><br>    (  ),        ,          .   ,      .        .           ,          ,   .  ,   ,        ,       (  <i></i> ). <br><br>    ,     ‚Äî  .    _ _ .    ‚Äî        ,    , ,     ,    ,     ,    .             (,  ‚Äî    ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Separately taken parts of the body are certainly important, but not in the same way as the more important things that you subconsciously pay attention to in life. The proportions are important. In programming, quite often there are various misalignments in one direction or another. We all know about the dangers and benefits of abstractions. Finding a middle ground between abstraction and concrete is one of the talents necessary for a good programmer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At one time, I was shocked. Being a fan of object-oriented programming since the 90s, I have always strived to write the most abstract (but still reasonable enough to work) code. In general, writing object-oriented code in the 90s was rebellious. Object-oriented programmers were no more than those who wrote exclusively in the functional style.</font></font><br><br>  ,         ,   2002   ‚Äú‚Äù (,     ) eclipse. Eclipse      .   eclipse      ,          ,    ,     . <br><br>          ,      ‚Äî    Eclipse Platform ‚Äî Erich Gamma.       ‚Äî         Design Patterns.       ,    2000            . <br><br>   ,    eclipse   ,   .      , ,    ,    ‚Äî      ,  ,  ,      -. -   ,     ,    .                     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any fact of (re) using something, either explicitly or implicitly, creates a dependency on this thing. And where there is a benefit for me (effective reuse) and, as a result, an increase in productivity, then for people creating a platform on which hundreds of plug-ins are being launched simultaneously, of different versions and from a dozen vendors who do not know about each other, any extra dependency is evil. Actually, this all added adequacy to me, reminding me of yin and yang, and that in our profession you always pay for something. And when someone shows another feature that solves all problems, or speaks about a new programming language with high-level abstractions, the first adequate question in response should be: ‚Äúwhat do we have to pay for it?‚Äù, If the answer is ‚Äúfree,‚Äù then write yourself the question is ‚Äúwell and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when</font></font></i>     ?‚Äù <br><br>         ,       .         ,         . <br><br><h4>  Summarizing </h4><br>    .   ,     ‚Äî      .      ‚Äî    ,     90% .       ,   -.      ‚Äî        (   )  .   ¬´¬ª Java  1999 (    ),         .        ,     Java              .            Apple   ‚Äî     . <br><br> -.          ,      .      ‚Äî       .        ‚Äî      (   ),     ,       ,     .       ¬´¬ª eclipse  2002 ,   eclipse     ,        2008.          Java  eclipse   ,    ,    ‚Äî  .       ,           ,      ‚Äî       ? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Returning to choosing the right language. I do not care about the features of the language, there may be as many or as few as they want. I wonder how much the language will increase the productivity of me and the team, now and in the future, for known and unknown tasks.</font></font> That's all.    .   ,     .      ,     Scala  Rust.                  .                ,   ,     Scala   2.     ,         ,          ,    . <br><br>     ,   ,    ,     ,      ‚Äî   <a href="http://nim-lang.org/">Nim</a> .               .   .  ,      ,        .     ,    .   , ,  ,  <i></i>       .  ,    ,      ,          .      .         ‚Äî    ,              . <br><br>   ,      Reno Logan,       ,       - ,        -    ,         5 ?   ‚Äî       , ,      ,      ,   ,     .     <i></i> . <br><br> , <br>  <br><br><img src="https://habrastorage.org/files/387/274/796/387274796b3e48dcb518736b806ac006.JPG"></div><p>Source: <a href="https://habr.com/ru/post/260149/">https://habr.com/ru/post/260149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260133/index.html">NGINX - The story of rebirth under Windows</a></li>
<li><a href="../260135/index.html">Manage Azure DNS almost without PowerShell</a></li>
<li><a href="../260139/index.html">3CX Phone System v14: version for technical specialists</a></li>
<li><a href="../260141/index.html">Phalcon 2.0.3 release</a></li>
<li><a href="../260145/index.html">HL7 FHIR: Fast Healthcare Interoperability Resources</a></li>
<li><a href="../260151/index.html">Management and cleaning in D</a></li>
<li><a href="../260159/index.html">Comparison of Security Enhanced NGINX and Hiawatha Web Server in repelling attacks of level 7 (BOTS / SQL / XSS etc.)</a></li>
<li><a href="../260161/index.html">5 data visualization experiments</a></li>
<li><a href="../260163/index.html">Understanding the grid in Adobe Illustrator</a></li>
<li><a href="../260169/index.html">Understanding the Web Interface Architecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>