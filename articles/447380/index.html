<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exceptions in Kotlin and their features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Our company has been using Kotlin in production for more than two years. Personally, I ran into this language about a year ago. There are many topics ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exceptions in Kotlin and their features</h1><div class="post__text post__text-html js-mediator-article">  Our company has been using Kotlin in production for more than two years.  Personally, I ran into this language about a year ago.  There are many topics for conversation here, but today we'll talk about error handling, including in a functional style.  I'll tell you how this can be done in Kotlin. <br><br><img src="https://habrastorage.org/webt/mb/bh/cp/mbbhcprsketr78wg8twpwhijg0y.jpeg" alt="image"><br><br>  <i>(Photos from a meeting on this topic, which took place in the office of one of the companies of Taganrog. Alexey Shafranov spoke - the leader of the working group (Java) in Maxillect)</i> <br><a name="habracut"></a><br><h3>  How can you handle errors in principle? </h3><br>  I found several ways: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  You can use some <b>return value</b> as a pointer to what is an error; </li><li>  you can use <b>the indicator parameter</b> for the same purpose, </li><li>  enter a <b>global variable</b> </li><li>  handle <b>exceptions</b> </li><li>  add <b>contracts (DbC)</b> . </li></ul><br>  Let us dwell in more detail on each of the options. <br><br><h4>  Return value </h4><br>  Some ‚Äúmagic‚Äù value is returned if an error has occurred.  If you have ever used scripting languages, you probably have seen similar constructs. <br><br>  Example 1: <br><br><pre><code class="plaintext hljs">function sqrt(x) { if(x &lt; 0) return -1; else return ‚àöx; }</code> </pre> <br>  Example 2: <br><br><pre> <code class="plaintext hljs">function getUser(id) { result = db.getUserById(id) if (result) return result as User else return ‚ÄúCan't find user ‚Äù + id }</code> </pre><br><h4>  Parameter indicator </h4><br>  Some parameter passed to the function is used.  After returning the value of the parameter, you can see if there was an error inside the function. <br><br>  Example: <br><br><pre> <code class="plaintext hljs">function divide(x,y,out Success) { if (y == 0) Success = false else Success = true return x/y } divide(10, 11, Success) id (!Success) //handle error</code> </pre><br><h4>  Global variable </h4><br>  The global variable works in much the same way. <br><br>  Example: <br><br><pre> <code class="plaintext hljs">global Success = true function divide(x,y) { if (y == 0) Success = false else return x/y } divide(10, 11, Success) id (!Success) //handle error</code> </pre><br><h4>  Exceptions </h4><br>  We are all used to the exceptions.  They are used almost everywhere. <br><br>  Example: <br><br><pre> <code class="plaintext hljs">function divide(x,y) { if (y == 0) throw Exception() else return x/y } try{ divide(10, 0)} catch (e) {//handle exception}</code> </pre><br><h4>  Contracts (DbC) </h4><br>  Frankly, I never saw this approach live.  Through long googling, I found that in Kotlin 1.3 there is a library that actually allows you to use contracts.  Those.  You can put the condition on the variables that are passed to the function, the condition on the return value, the number of calls, where it is called from, etc.  And if all the conditions are met, it is considered that the function worked correctly. <br><br>  Example: <br><br><pre> <code class="plaintext hljs">function sqrt (x) pre-condition (x &gt;= 0) post-condition (return &gt;= 0) begin calculate sqrt from x end</code> </pre><br>  Frankly, this library has a terrible syntax.  Perhaps that is why I did not see this live. <br><br><h3>  Exceptions in java </h3><br>  Let's turn to Java and to how it all worked initially. <br><br><img src="https://habrastorage.org/webt/gk/oo/mw/gkoomw72k7yp5mhpi9ebpt02g-i.png" alt="image"><br><br>  When designing the language laid two types of exceptions: <br><br><ul><li>  checked - checked; </li><li>  unchecked - unchecked. </li></ul><br>  What are checked exceptions for?  Theoretically, they are needed so that people must check for errors.  Those.  if a defined exception is possible, then it must be checked later.  Theoretically, such an approach should have led to the absence of unprocessed errors and an improvement in the quality of the code.  But in practice it is not.  I think everyone at least once in their life saw an empty catch block. <br><br>  Why can it be bad? <br><br>  Here is a classic example straight from the Kotlin documentation - the interface from the JDK, implemented in StringBuilder: <br><br><pre> <code class="plaintext hljs">Appendable append(CharSequence csq) throws IOException; try { log.append(message) } catch (IOException e) { //Must be safe }</code> </pre><br>  I'm sure you have seen quite a lot of code wrapped in try-catch, where catch is an empty block, since such a situation should not have happened, according to the developer.  In many cases, checked exception handling is implemented in the following way: they simply throw a RuntimeException and catch it somewhere above (or not catch ...). <br><br><pre> <code class="plaintext hljs">try { // do something } catch (IOException e) { throw new RuntimeException(e); //  - ...</code> </pre><br><h3>  What can be in Kotlin </h3><br>  In terms of exceptions, the Kotlin compiler differs in that: <br><br>  1. Does not distinguish between checked and unchecked exceptions.  All exceptions are only unchecked, and you yourself decide whether to catch and process them. <br><br>  2. Try can be used as an expression - you can start a try block and either return the last line from it, or return the last line from a catch block. <br><br><pre> <code class="plaintext hljs">val value = try {Integer.parseInt(‚Äúlol‚Äù)} catch(e: NumberFormanException) { 4 } // </code> </pre><br>  3. It is also possible to use a similar construction when referring to an object that can be nullable: <br><br><pre> <code class="plaintext hljs">val s = obj.money ?: throw IllegalArgumentException(‚Äú , ‚Äù)</code> </pre><br><h4>  Java compatibility </h4><br>  Kotlin code can be used in Java and vice versa.  How to handle exceptions? <br><br><ul><li>  Checked exceptions from Java in Kotlin can not be checked and not declared (since there are no checked exceptions in Kotlin). </li><li>  Possible checked exceptions from Kotlin (for example, appearing originally from Java) are not necessary to check in Java. </li><li>  If verification is necessary, an exception can be made verifiable using the @Throws annotation in the method (you must specify which exceptions this method can throw).  This annotation is only for compatibility with Java.  But in practice many of us use it to declare that in principle such a method can convey some exceptions. </li></ul><br><h4>  Alternative to try-catch </h4><br>  The try-catch block has a significant drawback.  When it appears, a part of the business logic is transferred inside the catch, and this can occur in one of the many methods above.  When business logic is spread across blocks or the entire call chain, it‚Äôs more difficult to understand how an application works.  And the readability blocks themselves are not added to the code. <br><br><pre> <code class="plaintext hljs">try { HttpService.SendNotification(endpointUrl); MarkNotificationAsSent(); } catch (e: UnableToConnectToServerException) { MarkNotificationAsNotSent(); }</code> </pre><br>  What are the alternatives? <br><br>  One option offers us a functional approach to exception handling.  A similar implementation looks like this: <br><br><pre> <code class="plaintext hljs">val result: Try&lt;Result&gt; = Try{HttpService.SendNotification(endpointUrl)} when(result) { is Success -&gt; MarkNotificationAsSent() is Failure -&gt; MarkNotificationAsNotSent() }</code> </pre><br>  We have the ability to use the monad Try.  In essence, this is a container that stores some value.  flatMap is a method of working with this container, which, together with the current value, can take a function and return the monad again. <br><br>  In this case, the call is wrapped in a Try monad (we return a Try).  This can be processed in the only place where we need it.  If the output has a value, we perform subsequent actions with it; if we have thrown an exception, we process it at the very end of the chain. <br><br><h4>  Functional exception handling </h4><br>  Where can I get try? <br><br>  First, there are quite a few implementations of the Try and Either classes from the community.  You can take them or even write the implementation yourself.  In one of the ‚Äúcombat‚Äù projects, we used the samopisny implementation of Try ‚Äî we managed one class and did an excellent job. <br>  Secondly, there is the Arrow library, which in principle adds a lot of functionality to Kotlin.  Naturally, there is Try and Either. <br><br>  Well, and besides, in Kotlin 1.3 a Result class appeared, which I will discuss in more detail later. <br><br><h4>  Try using the example of the Arrow library </h4><br>  The Arrow library gives us a Try class.  In fact, it can be in two states: Success or Failure: <br><br><ul><li>  Success with successful output will keep our value, </li><li>  Failure stores an exception that occurred during the execution of a block of code. </li></ul><br>  The call looks like this.  Naturally, it is wrapped in the usual try - catch, but it will happen somewhere inside our code. <br><br><pre> <code class="plaintext hljs">sealed class Try&lt;out A&gt; { data class Success&lt;out A&gt;(val value: A) : Try&lt;A&gt;() data class Failure(val e: Throwable) : Try&lt;Nothing&gt;() companion object { operator fun &lt;A&gt; invoke(body: () -&gt; A): Try&lt;A&gt; { return try { Success(body()) } catch (e: Exception) { Failure(e) } } }</code> </pre><br>  The same class should implement the flatMap method, which allows you to pass a function and return our monad try: <br><br><pre> <code class="plaintext hljs">inline fun &lt;B&gt; map(f: (A) -&gt; B): Try&lt;B&gt; = flatMap { Success(f(it)) } inline fun &lt;B&gt; flatMap(f: (A) -&gt; TryOf&lt;B&gt;): Try&lt;B&gt; = when (this) { is Failure -&gt; this is Success -&gt; f(value) }</code> </pre><br>  What is it for?  In order not to handle errors for each of the results, when we have several of them.  For example, we received several values ‚Äã‚Äãfrom different services and want to combine them.  In fact, we can have two situations: either we received them successfully and combined them, or something fell.  Therefore, we can proceed as follows: <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { 4 } val sum = result1.flatMap { one -&gt; result2.map { two -&gt; one + two } } println(sum) //Success(value=15)</code> </pre><br>  If both calls succeed and we get the values, we execute the function.  If they are not successful, then Failure will return with an exception. <br><br>  Here‚Äôs what it looks like if something fell: <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { throw RuntimeException(‚ÄúOh no!‚Äù) } val sum = result1.flatMap { one -&gt; result2.map { two -&gt; one + two } } println(sum) //Failure(exception=java.lang.RuntimeException: Oh no!</code> </pre><br>  We used the same function, but the output is a Failure from RuntimeException. <br><br>  Also, the Arrow library allows you to use constructs that are in fact syntactic sugar, in particular binding.  All the same can be rewritten via a serial flatMap, but the binding makes it readable. <br><br><pre> <code class="plaintext hljs">val result1: Try&lt;Int&gt; = Try { 11 } val result2: Try&lt;Int&gt; = Try { 4 } val result3: Try&lt;Int&gt; = Try { throw RuntimeException(‚ÄúOh no, again!‚Äù) } val sum = binding { val (one) = result1 val (two) = result2 val (three) = result3 one + two + three } println(sum) //Failure(exception=java.lang.RuntimeException: Oh no, again!</code> </pre><br>  Given that one of the results has fallen, we get an error at the output. <br><br>  Such a monad can be used for asynchronous calls.  Here, for example, two functions that run asynchronously.  We also combine their results in the same way, without checking their states separately: <br><br><pre> <code class="plaintext hljs">fun funA(): Try&lt;Int&gt; { return Try { 1 } } fun funB(): Try&lt;Int&gt; { Thread.sleep(3000L) return Try { 2 } } val a = GlobalScope.async { funA() } val b = GlobalScope.async { funB() } val sum = runBlocking { a.await().flatMap { one -&gt; b.await().map {two -&gt; one + two } } }</code> </pre><br>  But a more ‚Äúcombat‚Äù example.  We have a request to the server, we process it, get the body out of it and try to map it to our class, from which we are already returning data. <br><br><pre> <code class="plaintext hljs">fun makeRequest(request: Request): Try&lt;List&lt;ResponseData&gt;&gt; = Try { httpClient.newCall(request).execute() } .map { it.body() } .flatMap { Try { ObjectMapper().readValue(it, ParsedResponse::class.java) } } .map { it.data } fun main(args : Array&lt;String&gt;) { val response = makeRequest(RequestBody(args)) when(response) { is Try.Success -&gt; response.data.toString() is Try.Failure -&gt; response.exception.message } }</code> </pre><br>  Try-catch would make this block much less readable.  And in this case, we get response.data at the output, which we can process depending on the result. <br><br><h4>  Result from Kotlin 1.3 </h4><br>  In Kotlin 1.3 introduced the class Result.  In fact, it is something like Try, but with a number of restrictions.  It is initially supposed to be used for various asynchronous operations. <br><br><pre> <code class="plaintext hljs">val result: Result&lt;VeryImportantData&gt; = Result.runCatching { makeRequest() } .mapCatching { parseResponse(it) } .mapCatching { prepareData(it) } result.fold{ { data -&gt; println(‚ÄúWe have $data‚Äù) }, exception -&gt; println(‚ÄúThere is no any data, but it's your exception $exception‚Äù) } )</code> </pre><br>  If I'm not mistaken, this class is currently experimental.  The developers of the language can change its signature, behavior, or even remove it, so at the moment it is forbidden to use it as a return value from a method or variable.  However, it can be used as a local (private) variable.  Those.  In fact, it can be used as a try from the example. <br><br><h3>  findings </h3><br>  Conclusions that I made for myself: <br><br><ul><li>  functional error handling in Kotlin is easy and convenient; </li><li>  no one bothers to handle them through try-catch in a classic style (and this and that has the right to life, and this and that is convenient); </li><li>  the absence of checked exceptions does not mean that you can not handle errors; </li><li>  not caught exceptions on production lead to sad consequences. </li></ul><br>  Article author: Alexey Shafranov, leader of the working group (Java), Maxilect company <br><br>  PS We publish our articles on several sites Runet.  Subscribe to our pages on the <a href="https://vk.com/maxilect">VK</a> , <a href="https://www.facebook.com/maxilectru/">FB</a> or <a href="https://t.me/maxilect">Telegram channel</a> to find out about all our publications and other news from Maxilect. </div><p>Source: <a href="https://habr.com/ru/post/447380/">https://habr.com/ru/post/447380/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../447368/index.html">Not just catching fleas. Why speed is so important for any store</a></li>
<li><a href="../447370/index.html">Why, because of a broken patent system, the shadow of Theranos still hangs over us</a></li>
<li><a href="../447372/index.html">IT transformation is inevitable: where to start</a></li>
<li><a href="../447374/index.html">Creating interface elements programmatically using PureLayout (Part 2)</a></li>
<li><a href="../447376/index.html">SNA Hackathon 2019</a></li>
<li><a href="../447382/index.html">The book "Unity and C #. Gamedev from idea to implementation. 2nd ed ¬ª</a></li>
<li><a href="../447384/index.html">Power semiconductors on guard environmental</a></li>
<li><a href="../447388/index.html">TL; ITMO University DR-digest: non-classical admission to university, upcoming events and the most interesting materials</a></li>
<li><a href="../447390/index.html">Recommendations for configuring AFA AccelStor when working with VMware vSphere</a></li>
<li><a href="../447392/index.html">Three problems of services for checking English grammar, and whether they can be solved</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>