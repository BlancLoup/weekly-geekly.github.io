<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding the life cycle of the React component</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="React provides developers with a variety of methods and hooks that are called during a component's life cycle, they allow us to update the UI and the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding the life cycle of the React component</h1><div class="post__text post__text-html js-mediator-article">  React provides developers with a variety of methods and hooks that are called during a component's life cycle, they allow us to update the UI and the state of the application.  When it is necessary to use each of them, what needs to be done and in what methods, and what is better to refuse, is the key to understanding how to work with React. <br><a name="habracut"></a><br>  <b>Update:</b> <br><br>  In React 16.3, two additional life-cycle methods appeared and several methods were declared obsolete, for details <a href="https://medium.com/%40baphemot/understanding-react-react-16-3-component-life-cycle-23129bc7a705">on the link</a> . <br>  <i>(Note of the translator: Although some methods are declared obsolete, their description, in my opinion, would still be useful, at least for those developers who work with previous versions of React and in general, instead of understanding which methods and for what new ones were introduced. Article link added below)</i> <br><br>  <b>Constructor:</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Designers are the main OOP - this is such a special function that will be called whenever a new object is created.  It is very important to call the super function in cases where our class extends the behavior of another class that has a constructor.  Executing this special function will call the constructor of our parent class and allow it to initialize itself.  That is why we have access to this.props only after calling super.  (meaning the call super (props) in the heir class React.Component) <br><br>  Therefore, constructors are a great place to initialize a component ‚Äî creating any fields (variables starting with this.) Or initializing the state of the component based on the received props. <br><br>  This is also the only place where you can change / set the state by directly overwriting the this.state field.  In all other cases, you must use this.setState. <br><br>  <u>DO:</u> <br><br><ul><li>  Set the initial state of the component </li><li>  If the <a href="https://babeljs.io/docs/plugins/transform-class-properties/">class properties</a> syntax is not used, prepare all the fields of the class and call bind on those functions that will be passed as callbacks. </li></ul><br>  <u>DO NOT DO IT:</u> <br><br><ul><li>  Do not perform any side effects (AJAX calls, etc.) </li></ul><br>  <b>[deprecated] componentWillMount</b> <br><br>  componentWillMount is not very different from the constructor ‚Äî it is also called only once in the initial life cycle.  In general, there have historically been some reasons to use componentWillMount over the constructor - <a href="https://github.com/reactjs/react-redux/issues/129">see the react-redux issue</a> , but at the moment the practice described there is outdated. <br><br>  Many may be tempted to use this function to send a request for receiving data and they will expect that the data will be available before the initial render is completed.  But this is not the case - although the requester will be initialized before the render, it will not have time to execute before the render will be called. <br><br>  In addition, with changes to React Fiber (after the release of React 16 beta), this function can be called several times before calling the initial render, which can lead to various side effects associated with this.  Therefore, it is not recommended to use this function to perform any operations that cause side effects. <br><br>  It is also important to note that this function is called when server-side rendering is used, when its antipode componentDidMount is not called on the server, but will be on the client.  Therefore, if some side effect is aimed at the server side, this function can be used as an exception. <br><br>  Finally, the setState function can be used freely and will not cause a component to be redrawn. <br><br>  <u>DO:</u> <br><br><ul><li>  Update the state with this.setState </li><li>  Perform the latest optimizations </li><li>  Cause side effects (AJAX call, etc.) <b>only in the case of server-side-rendering.</b> <br></li></ul><br>  <u>DO NOT DO IT:</u> <br><br><ul><li>  Do not perform any side effects (AJAX Challenge, etc.) on the client side. </li></ul><br>  <b>[deprecated] componentWillReceiveProps (nextProps)</b> <br><br>  This function will be called at each update of the life cycle, which will occur during changes in props (when the parent component is redrawn) and will accept mapping of all transmitted props, whether the value of a property has changed or not since the previous redrawing phase. <br><br>  This function will be ideal if you have any component whose state part (state) depends on the props transmitted from the parent component, since  calling this.setState here will not cause additional redrawing. <br><br>  Remember that because  This function is called with all props, even with those that have not changed, the developer is expected to write a check in order to understand whether the actual value of a property has changed or not. <br><br>  For example: <br><br><pre><code class="javascript hljs">componentWillReceiveProps(nextProps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nextProps.myProp !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.myProps) { <span class="hljs-comment"><span class="hljs-comment">// nextProps.myProp   ,    myProps //    -     . } }</span></span></code> </pre> <br>  Due to the fact that in React Fiber (after 16 beta) this function may be called several times before the render function, it is not recommended to perform here any operations that cause side effects. <br><br>  <u>DO:</u> <br><br><ul><li>  Synchronize state with props </li></ul><br>  <u>DO NOT DO IT:</u> <br><br><ul><li>  Do not perform any side effects (AJAX calls, etc.) </li></ul><br>  <b>shouldComponentUpdate (nextProps, nextState, nextContext)</b> <br><br>  By default, all components will redraw themselves whenever their state changes, their context changes, or they accept props from the parent.  If component redrawing is rather heavy (for example, generating charts, graphics) or is not recommended for any performance reasons, then developers have access to a special function that will be called every time during an update cycle. <br><br>  This function will be called with the following values ‚Äã‚Äãof props, state (state) and object.  And the developer can use these parameters in order to decide whether to redraw the component or return false and prevent it.  Otherwise, you are expected to return true. <br><br>  <u>DO:</u> <br><br><ul><li>  Use to optimize component performance </li></ul><br>  <u>DO NOT DO IT:</u> <br><br><ul><li>  Do not perform any side effects (AJAX calls, etc.) </li><li>  Do not call this.setState </li></ul><br>  <b>[deprecated] componentWillUpdate (nextProps, nextState)</b> <br><br>  If we have not implemented the function shouldComponentUpdate or have decided that the component should be updated in this render cycle, another life cycle function will be called.  This function is mainly used to make synchronization between the state and the props in case part of the component state is based on any props. <br><br>  In cases where shouldComponentUpdate is implemented, the componentWillUpdate function can be used instead of componentWillReceiveProps, since  it will be called only when the component is actually redrawn. <br><br>  Like all other componentWill * functions, this function can be called several times before render, so it is not recommended to perform any operations that cause side effects here. <br><br>  <u>DO:</u> <br><br><ul><li>  Synchronize state with props </li></ul><br>  <u>DO NOT DO IT:</u> <br><br><ul><li>  Do not perform any side effects (AJAX calls, etc.) </li></ul><br>  <b>componentDidUpdate (prevProps, prevState, prevContext)</b> <br><br>  This function will be called after the render function has completed, in each redraw cycle.  This means that you can be sure that the component and all its child components have already redrawn themselves. <br><br>  In this regard, this function is the only function that is guaranteed to be called only once in each redraw cycle, so it is recommended to perform any side effects here.  As componentWillUpdate and componentWillRecieveProps, previous props, state (state) and context are transferred to this function, even if there were no changes in these values.  Therefore, developers must manually check the transferred values ‚Äã‚Äãfor changes and only then perform various update operations. <br><br><pre> <code class="javascript hljs">componentDidUpdate(prevProps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(prevProps.myProps !== <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.myProp) { <span class="hljs-comment"><span class="hljs-comment">//  this.props.myProp   //         //    /  - //  AJAX     - this.props.myProp } }</span></span></code> </pre><br>  <u>DO:</u> <br><br><ul><li>  Perform side effects (AJAX calls, etc.) </li></ul><br>  <u>DO NOT DO IT:</u> <br><br><ul><li>  Do not call this.setState because  this will cause a cyclic redraw. </li></ul><br>  The exception to the rule above is a status update, which is based on any DOM properties that can be calculated only after the component has been redrawn (for example, the position / size of any DOM nodes).  But be careful and prevent re-updating if the value has not actually changed, because  this can lead to cyclic redrawing. <br><br>  <b>componentDidCatch (errorString, errorInfo)</b> <br><br>  Addition in React 16 - this method of the life cycle is special, because  it allows you to respond to events occurring in the child component, and specifically to any uncaught errors in any of the child components. <br><br>  With this add-on, you can make your parent element an error handler.  For example, write error information to the component state, return the corresponding message to the render, or make error logging. <br><br><pre> <code class="javascript hljs">componentDidCatch(errorString, errorInfo) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">error</span></span>: errorString }); ErrorLoggingTool.log(errorInfo); } render() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.error) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ShowErrorMessage</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">error</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.state.error}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> return ( // render normal component output ); }</span></span></code> </pre><br><br>  When any error occurs, this function is called with the following parameters: <br><br><ul><li>  errorString - .toString () error message </li><li>  errorInfo is an object with a single componentStack field that contains the framerays where the error occurred. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Thrower <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> div (created by App) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> App</code> </pre><br>  <b>componentDidMount</b> <br><br>  This function will be called only once in the entire life cycle of this component and will signal that the component and all its child components have been rendered without errors. <br><br>  Since  this function is guaranteed to be called only once, then it is an excellent candidate for performing any side effects, such as AJAX requests. <br><br>  <u>DO:</u> <br><br><ul><li>  Perform side effects (AJAX calls, etc.) </li></ul><br>  <u>DO NOT DO IT:</u> <br><br><ul><li>  Do not call this.setState because  this will cause a redraw. </li></ul><br>  The exception to the rule above is a status update, which is based on any DOM properties that can be calculated only after the component has been redrawn (for example, the position / size of any DOM nodes).  But be careful and prevent re-updating if the value has not actually changed, because  this can lead to cyclic redrawing. <br><br>  <b>componentWillUnmount</b> <br><br>  Use this function to ‚Äúclean up‚Äù after a component if it uses timers (setTimeout, setInterval), opens sockets, or performs any operations that need to be closed or deleted. <br><br>  <u>DO:</u> <br><br><ul><li>  Delete timers and listeners created during the life of the component. </li></ul><br>  <u>DO NOT DO IT:</u> <br><br><ul><li>  Do not call this.setState, do not start new listeners or timers. </li></ul><br><h3>  <b>Component cycles</b> </h3><br>  There are several reasons why a component may redraw, and depending on the cause, various functions are called to allow the developer to update certain parts of the component. <br><br>  <b>Create component</b> <br><br>  The first loop is the creation of a component, which usually occurs when the component is first detected in the parsed JSX tree: <br><img src="https://habrastorage.org/webt/kq/8a/nm/kq8anm2cgymtxl1cad5hriolu18.png"><br><br>  <b>The component is redrawn due to the redrawing of the parent component.</b> <br><br><img src="https://habrastorage.org/webt/oc/8w/hw/oc8whw24l7vjuze_s01n74uzgu4.png"><br><br>  <b>Component is redrawn due to internal changes (for example, call this.setState ())</b> <br><br><img src="https://habrastorage.org/webt/7i/si/wh/7isiwhyz5diakdk_fbbqr0cqnxk.png"><br><br>  <b>Component redrawn due to call this.forceUpdate</b> <br><br><img src="https://habrastorage.org/webt/8d/uk/wk/8dukwkh7kvowk1r_ealjsgsl9z0.png"><br><br>  <b>Component redrawn due to error interception</b> <br><br>  Entered in React 16 as ErrorBoundaries.  A component can define a special layer that can intercept errors and provide a new lifecycle method ‚Äî componentDidCatch ‚Äî that allows the developer to process or log these errors. <br><br><img src="https://habrastorage.org/webt/u7/zf/_z/u7zf_zrq_vxxggvpgbaoj0io8pg.png"><br><br>  <a href="https://twitter.com/james_k_nelson">@James_k_nelson</a> - Recently published componentWillRecieveProps simulator.  <a href="https://reactarmory.com/guides/lifecycle-simulators">HERE</a> you can find and play with this simulator. <br><br><h3>  <b>React 16.3+ component life cycle</b> </h3><br>  Release 16.3 introduced some new lifecycle functions that replaced existing ones to provide better support for the new asynchronous nature of React. <br><br>  <b>static getDerivedStateFromProps (nextProps, prevState)</b> <br><br>  The main responsibility of this new feature is to make sure that the state and props are synchronized when necessary.  Its main meaning is the replacement componentWillRecieveProps. <br><br>  getDerivedStateFromProps is a static function and therefore does not have access to this - instead you are expected to return an object that will be passed on to the future state of the component (just like working with setState!) <br><br>  This function is used when the component is updated, but also when it is mounted, immediately after the constructor call, so you no longer need to use the constructor if you want to set the initial state of the component from props. <br><br>  <b>getSnapshotBeforeUpdate (prevProps, prevState)</b> <br><br>  The other of the two new functions is called in the so-called ‚Äúpre-commit phase‚Äù, right before the changes from the VDOM that are to be mapped to the DOM. <br><br>  It can be used mainly if you need to read the current state of the DOM. <br>  For example, you have an application in which new messages are added on top of the screen - if the user scrolls down and a new message is added, the screen will ‚Äújump‚Äù and this will make the UI harder to use.  By adding getSnapshotBeforeUpdate, you can calculate the current position of the scroll and restore it via the DOM update. <br><br>  Although the function is not static, it is recommended to return the value, rather than update the component.  The return value will be passed to componentDidUpdate as the 3rd parameter. <br><br>  <b>Outdated features</b> <br><br>  Despite the fact that the new features make your transition to AsyncMode easier, you are not forced to migrate all your code.  The following features will be marked obsolete and renamed in the following releases: <br><br><ul><li>  componentWillRecieveProps - UNSAFE_componentWillRecieveProps </li><li>  componentWillUpdate - UNSAFE_componentWillUpdate </li></ul><br>  You will see the versions in the next major version, and the functions will be renamed (the renamed versions will be saved!) In version 17.0 <br><br>  <a href="https://twitter.com/dan_abramov/status/981712092611989509">Dan Abramov</a> summarized all the changes in one picture: <br><br><img src="https://habrastorage.org/webt/6t/7s/ls/6t7slszbqm-tvq5f8twwanrmdgw.jpeg"><br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/358090/">https://habr.com/ru/post/358090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358080/index.html">11 backlog optimization tips</a></li>
<li><a href="../358082/index.html">The influence of a small window on the user's memory, and what to do about it</a></li>
<li><a href="../358084/index.html">Three main principles for rapid product growth from Head of Growth Recruitee</a></li>
<li><a href="../358086/index.html">Not a single code: what affects the operation of blockchain systems</a></li>
<li><a href="../358088/index.html">Go assembler guide</a></li>
<li><a href="../358092/index.html">Why think about web security when it's too late?</a></li>
<li><a href="../358094/index.html">Friday JS: random mixing</a></li>
<li><a href="../358096/index.html">Dive into pyTorch</a></li>
<li><a href="../358100/index.html">How to write on Habrahabr and Geektimes</a></li>
<li><a href="../358102/index.html">The book "Swift. Basics of developing applications for iOS and macOS. 4th ed. supplemented and revised "</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>