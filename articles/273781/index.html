<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A little bit about building a mobile application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I remember that wonderful time when the assembly of the release version of the mobile application was reduced to the fact that it was necessary to set...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A little bit about building a mobile application</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9d3/56a/099/9d356a0995b2a521957734b50be9deaf.jpg" alt="image"><br><br>  I remember that wonderful time when the assembly of the release version of the mobile application was reduced to the fact that it was necessary to set debug = false and start exporting the apk-file.  It takes 2 minutes while the IDE puffs and you're done.  All efforts have focused on the need to specify the signature certificate data.  It was just recently.  Now the build process of that application has grown so much that if I suddenly need to do all the operations myself, and even if I remember and do everything correctly (which I don‚Äôt believe), it will not take an hour, which today seems to be unacceptably long , and, most likely, a day, after which the therapist will be obliged to prescribe me a sick leave due to tiredness for two weeks. <br><br>  So, the process of assembling a mobile application.  I will try to tell you what it is with us - not because it has recently become fashionable to roll posts about the CI of a particular mobile team (with poker, mermaids, and other essential attributes), but because it is a great experience that I got , working on Mail.Ru Mail for Android, and because this opportunity most likely would not have been, I worked in another team, on another project or in another company. <br><a name="habracut"></a><br>  For any process, an important decision is the choice of the system on the basis of which the entire assembly will be built.  Builds should be build server.  This is logical.  But which one to choose? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The question is ambiguous, each one chooses one or another solution, based on his experience, on the tasks that the system faces and on the resources that it has.  Some people like free solutions, because they don‚Äôt need to explain to their supervisor what you needed $ N000 a year for and why you shouldn‚Äôt do without it.  Someone is motivated by the presence of a community or the experience of a huge number of teams that have already taken advantage of these decisions and are satisfied with the result.  The number of points of view tends to the number of people who asked this question.  I cannot say that someone‚Äôs argument is correct, or someone‚Äôs objection is irrelevant.  But no matter what views a developer who has faced such a problem adheres to, the majority will agree that by and large all popular solutions presented on the market are distinguished only by the convenience of customization, integration with adjacent systems, expansion options and support from the community or system developers. <br><br>  In general, the choice of the build server is a topic for a separate holivar.  Let me just say that we chose the Atlassian solution of the Bamboo Build Server.  There are several main reasons, one of them is the simplicity of integration with the issue tracker that we use in the project, as well as with code review systems and hosting of repositories.  Well done guys here: everything is convenient, everything is at hand, and, most importantly, almost all the provided solutions and options fit perfectly into the development process of our team <br><br><h1>  Bamboo </h1><br>  Bamboo is a very common solution, it is used by a huge number of teams all over the world.  Details of the scheme of work of this CI / CD Tool can be found on the official documentation website, but I will allow myself the free translation of a small part of this document in order to avoid discrepancies in terminology. <br><br>  The task of Continuous Integration Server is to do all the work of building, testing, deploying to the test environment of the project.  The CI server communicates with the repository, receives a specific revision of the project, performs all the necessary actions, and provides the finished build result to the project team. <br><br><img src="https://habrastorage.org/files/a8a/216/925/a8a216925e844eea9fec8b586536cad1.jpg"><br><br><table><tbody><tr><td>  Project </td><td><ul><li>  consists of one or several build plans </li><li>  provides a report on all build plans of the project </li><li>  associated with other applications (Jira, Fisheye, Crucible, Stash) </li></ul></td></tr><tr><td>  Build plan <br>  (Plan) </td><td><ul><li>  consists of one or several stages (stage) </li><li>  all stages are run sequentially, use the same repositories </li><li>  contains rules for starting builds, dependencies on other project build plans </li></ul></td></tr><tr><td>  Stage <br>  (Stage) </td><td><ul><li>  consists of one or several works </li><li>  performs work in parallel, on free build agents considered complete when all work is done successfully </li><li>  conveys artifacts for later stages of assembly. </li></ul></td></tr><tr><td>  Job <br>  (Job) </td><td><ul><li>  consists of one or several tasks </li><li>  all tasks inside are executed sequentially on the same agent </li></ul></td></tr><tr><td>  Task <br>  (Task) </td><td><ul><li>  discrete operation, such as checkout project revisions, script launch, etc. </li></ul></td></tr></tbody></table><br><img src="https://habrastorage.org/files/22f/142/da6/22f142da61344f21883b2393cc7e6ab5.png"><br><br>  More or less similar separation is available in any build system, it provides the necessary flexibility in building the entire process.  At first glance it seems that this is an excessive complication.  So it was with our project, when we first started using Bamboo, but gradually everything settled down, a clear understanding of how much of the entire assembly process should be scaled, which should remain isolated, appeared, and a fairly well-formed structure formed within the framework of the proposed concepts. <br><br>  In general, you need to be well aware that a build server or a CI server is an important part of automating the software development process.  By assigning to this module all the tasks and work that needs to be done at different stages and levels of preparation of an application for release to the market, we get a kind of Application Release Pipeline.  He, in turn, makes it possible to easily determine which tasks were included in this or that build, at what stage the release is now, what problems arise when integrating the new functionality, at what stage of hotfix preparation we are now and much more. <br><br>  So, we smoothly approached the description of how this was done in our team. <br><br><h1>  Tasks </h1><br>  Our assembly project is divided into several stages, reflecting the main tasks at the moment: <br><br><ul><li>  Assembly - includes all the assembly options that may be needed during the Release pipeline: alpha, beta, release.  Yes, yes, we have precisely the project assembly, and not just their status.  Product differences: various resources, presence or absence of settings, etc. </li><li>  Verification is the most capacious and technically difficult part of the entire application assembly stage: static code analysis, unit testing, functional UI testing, and localization testing. </li><li>  Depla.  At the moment, abstracted from the entire assembly, it is as if on the side.  Thus, if necessary, we can plug into any medium (alpha, beta, release) any revision / branch / type of application. </li></ul><br>  On this, in principle, it is possible to finish the story, but I, perhaps, will show intrusiveness and provide details. <br><br><h1>  Assembly </h1><br>  Now we are developing three projects at once with a single code base, let's call them Project 1, Project 2 and Project 3. Of course, the differences between them are not as radical as between chess and a video player, since all three products fall into the category of mail clients.  However, they have a different design, there are differences in functionality, they interact with the server in different ways.  All this dictates its own requirements for the assembly, testing and product development. <br><br><h3>  Feature Branch Workflow </h3><br>  Any build begins with a project revision check checkout from a version control system.  It would seem, why focus on this - because everyone can make a checkout?  Really.  But which branch is it worth doing? <br><br>  We use Feature Branch Workflow to work on the product.  This approach <a href="https://ru.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow">can be read</a> separately.  Its main advantage for me is the isolation of changes.  With this approach, each developer can turn over the whole project, give it to testing, and if QA gives an appr, then the verified and functioning code will fall into a common thread.  This approach minimizes the risks of a defect in the release, due to the fact that a sequence of actions is defined: first check, then merge to the main branch of the project. <br><br>  To test these isolated changes, we must have an assembly on which we can run autotests, and which we will give to manual testing for approval from the QA team.  Bamboo provides out of the box the necessary solution.  It is called the Branch Plan and consists in the fact that the build has a main branch (for example, alpha), and all the branches that match the specified template are considered as a feature branch.  For them, a clone of the build plan is created, but with the difference that the checkout will come from this branch, and not from the main branch of the build plan.  It looks like this. <br><br><img src="https://habrastorage.org/files/58a/15c/2da/58a15c2da62341ef91d48376a20f7c5a.jpg"><br><br>  In the viewing of the build plan, we can switch between the main branch and the existing branch by viewing the results of all local statuses. <br><br>  The branch plan itself looks the same, except that it has a link to the task. <br><br><img src="https://habrastorage.org/files/10c/39b/4a3/10c39b4a31ba44a09023d574bbeae067.jpg"><br><br>  With such a flow, the branch inevitably begins to become obsolete from the moment it was created.  For early detection of conflicts with the main branch, in order to test the updated code, you need to constantly update your branch during development.  Bamboo can do this automatically before it starts to build a project.  In the event of a conflict, the build will not be baked, and the developer will have to first upgrade their branch and then push the changes.  Then there will be no conflict before assembling, and everything will go on as usual. <br><br><h1>  Product Flavors </h1><br>  Suppose we have a project that needs to be assembled in several variations, changing resources, code, and configs.  There are several options for how to implement this.  We were guided by the fact that all assembly conditions, all configurations and other descriptive part should be in the assembly script.  In our case, <a href="https://gradle.org/">Gradle</a> is ideally suited for this task.  For it, there is a good Android plugin that allows you to flexibly configure most standard and non-standard parameters for building a complex project. <br><br>  Let's see how many build options we actively use and support. <br><br><img src="https://habrastorage.org/files/c4e/2d7/26e/c4e2d726e5f548f387ea64f9fbed4c8f.png"><img src="https://habrastorage.org/files/6d9/ce4/707/6d9ce4707b8f42fa8c7a5d0eadff353f.png"><img src="https://habrastorage.org/files/f51/f46/5b7/f51f465b741342479e7f5ea7d768ad3e.png"><br><br>  Let's start with the fact that we have three main Product Flavors: Project 1, Project 2 and Project 3. <br><br>  Product Flavor is a representation of the product branch.  In most cases, these are different applications that have different packages, different signing certificates, different sources and resources.  For each application, we have several build options, namely: <br><br><ul><li>  <b>debug</b> - signed with debug key, can be debugged, not obfuscated; </li><li>  <b>alpha / branch alpha</b> - obfuscated assembly, different configurations for analytics, assemblies kreshy, resources, debazhnymi settings available in the application; </li><li>  <b>beta corp</b> - beta version, which has enabled logs, debug mode available; </li><li>  <b>beta</b> - as close as possible to the release of the assembly, which is different analytics, assembly kreshyh, has disabled logs, debug mode, and has no debugging settings; </li><li>  <b>release</b> - production-version of the application, almost all additional options are disabled, analytics and statistics collection are set up for combat projects in these systems, etc .; </li><li>  <b>unit / UI testing</b> - assemblies that have rewritten manifests, which allows, for example, to enable permissions to read SMS required for automated testing of input (authorization, registration, two-factor authorization) using an SMS code. </li></ul><br>  Total: <br><br>  8 Build Types * 3 Product Flavors = 24 Application Variants <br><br>  Why so much?  I'll try to answer.  One of the typical tasks that one has to solve, having three different products that are published in different environments, is to share analytics.  And it is necessary to do this, otherwise statistics from the alpha version of the application will distort the picture existing in production.  To collect statistics on kresham we use <a href="https://rink.hockeyapp.net/">HockeyApp</a> .  In it we have separate projects for different versions of the assembly.  This makes it easy to separate, for example, the crashes of Project 1 from those of Project 2, the beta version from the release version, etc. <br><br>  In the build.gradle of our project, this config looks like this. <br><br><pre><code class="java hljs">productFlavors { project1 { ... android.buildTypes { alpha { hockeyApp { [appId: <span class="hljs-string"><span class="hljs-string">'b45-------1b'</span></span>, note: project.issues, releaseType: <span class="hljs-string"><span class="hljs-string">'2'</span></span>] } } beta { hockeyApp { [appId: <span class="hljs-string"><span class="hljs-string">'c9d-------86'</span></span>, note: {<span class="hljs-string"><span class="hljs-string">''</span></span>}, releaseType: <span class="hljs-string"><span class="hljs-string">'0'</span></span>] } } publicBeta { ... } release { ... } } } project2 { ... android.buildTypes { alpha { hockeyApp { [appId: <span class="hljs-string"><span class="hljs-string">'1ac-------73'</span></span>, note: project.issues, releaseType: <span class="hljs-string"><span class="hljs-string">'2'</span></span>] } } ... } } project3 { ... android.buildTypes { alpha { hockeyApp { [appId: <span class="hljs-string"><span class="hljs-string">'dcd-------3c'</span></span>, note: project.issues, releaseType: <span class="hljs-string"><span class="hljs-string">'2'</span></span>] } } ... } }</code> </pre> <br>  Thus, we can configure different values ‚Äã‚Äãfor any build options.  As for resources and source codes, the same principle is used here, with the exception of one feature: it is possible to merge resources from different options.  Our project has resources that are the same for all applications ‚Äî for example, the screen layout for writing a letter.  If such files had to be copied to each resource bundle and kept separate, then if you change the layout of the screen for writing the letter, you would need to change as many as three files.  Fortunately, gradle + android plugin can do merge resources. <br><br>  I'll tell you a little more about how this happens - perhaps someone will be able to solve their everyday tasks using the same approach. <br><br>  We have identified several folders with resources (they all lie in the root of the project). <br><br><ul><li>  <b>res</b> - shared resources for all variants of the application: here are general selectors, markup, themes, styles, etc .; </li><li>  <b>res_project1</b> - resources that are unique to Project 1: almost all graphics that are used in the application, lines that contain the name of the project, specific logos or markup - in general, everything that applies only to Project 1; </li><li>  <b>res_project23</b> - here is a slightly different picture: all the resources that do not overlap with the Project but are the same for Project 2 and Project 3 fall into the res <b>_ project23</b> package. Such a grouping of resources helps to solve the problem when Product 2 and 3 are very similar to each other. This is quite different from Project 1. Otherwise, you would have to copy the same resources into the res_project2 and res_project3 folders; </li><li>  <b>res_project2</b> - resources unique to Project 2: currently they are colors, graphics, and texts.  Everything else lies in the general packages; </li><li>  <b>res_project3</b> - Likewise for Project 3, only a unique selection of resources for this application remains in this package. </li></ul><br><br>  As a result, for each build option, we merge several packages to get a common set of resources for the application: <br><br><ul><li>  Project 1 = res + res_project1; </li><li>  Project 2 = res + res_project23 + res_ project2; </li><li>  Project 3 = res + res_project23 + res_project3. </li></ul><br>  This is the basis.  For deeper customization, you can, for example, add specific resources, code for a test build, etc.  The whole closure with the source code looks like this: <br><br><pre> <code class="java hljs"> sourceSets { main { manifest.srcFile <span class="hljs-string"><span class="hljs-string">'AndroidManifest.xml'</span></span> java { srcDir <span class="hljs-string"><span class="hljs-string">'src'</span></span> exclude <span class="hljs-string"><span class="hljs-string">'**/instrumentTest/**'</span></span> } resources.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] aidl.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] renderscript.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src'</span></span>] res.srcDirs = [<span class="hljs-string"><span class="hljs-string">'res'</span></span>] assets.srcDirs = [<span class="hljs-string"><span class="hljs-string">'assets'</span></span>] } androidTest { manifest.srcFile <span class="hljs-string"><span class="hljs-string">'src/instrumentTest/AndroidManifest.xml'</span></span> java.srcDir <span class="hljs-string"><span class="hljs-string">'src/instrumentTest/Java'</span></span> } project2 { res.srcDirs = [<span class="hljs-string"><span class="hljs-string">'res_project2'</span></span>, <span class="hljs-string"><span class="hljs-string">'res_project23'</span></span>] java.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src_common'</span></span>] assets.srcDirs=[<span class="hljs-string"><span class="hljs-string">'assets_ project2] manifest.srcFile '</span></span>res_ project23/AndroidManifest.xml<span class="hljs-string"><span class="hljs-string">' } project3 { res.srcDirs = ['</span></span>res_project3<span class="hljs-string"><span class="hljs-string">', '</span></span>res_ project23] assets.srcDirs=[<span class="hljs-string"><span class="hljs-string">'assets_project3'</span></span>] java.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src_project3'</span></span>] manifest.srcFile <span class="hljs-string"><span class="hljs-string">'res_ project23/AndroidManifest.xml'</span></span> } project1 { res.srcDirs = [<span class="hljs-string"><span class="hljs-string">'res_project1'</span></span>] java.srcDirs = [<span class="hljs-string"><span class="hljs-string">'src_common'</span></span>] assets.srcDirs=[<span class="hljs-string"><span class="hljs-string">'assets_project1'</span></span>] manifest.srcFile <span class="hljs-string"><span class="hljs-string">'res_project1/AndroidManifest.xml'</span></span> } testingUi { manifest.srcFile <span class="hljs-string"><span class="hljs-string">'ui_testing/AndroidManifest.xml'</span></span> } }</code> </pre><br>  It remains the case for small.  In the build project, you need to run the correct task in order to get the desired .apk, for example, gradle assembleProject1PublicBeta.  Naturally, in the presence of such a large number of assembly options, we decided not to assemble them all consecutively, but to parallelize this process.  In total, we received 6 parallel works that are performed as part of the assembly stage.  Each work publishes 3 artifacts for each product. <br><br>  I suppose that those who read up to this point have a question: why collect the beta and release with each build of the project?  The question is really very interesting.  We came to this decision not immediately, but after a lot of time.  Historically, beta and release builds were built separately, using the same revision or contract stating that the code is the same there.  Then we realized that this approach is fraught with many problems, and the most unpleasant is that you will learn the status of the assembly after you decided to publish the beta.  By law, Murphy, naturally, the build turns out to be red.  For any reason.  The more changes, the more likely that they will negatively affect the assembly, and we can not do anything about it.  You can only shorten the time interval between the time the error was introduced and the time it was detected.  And in the ideal case, also to do it in isolation from the general branch.  If to abstract from the project and build exactly the beta or release version and look at the automation process, then one of the main indicators of the quality of the whole approach to build automation is what I see as an opportunity to learn about the problems as quickly as possible, and most importantly, find out BEFORE how these changes fell into a common thread. <br><br><h1>  Check </h1><br>  Automatic quality check in mobile applications is definitely the trend of the last year.  In my experience, for many it remains something unreal.  Everyone talks about it, but almost nobody has seen it.  We have been dealing with such tasks within our project for 2 years already, and during this time a fairly clear understanding of most of the subtleties that any developer has to face has already been established.  All these problems and solutions are a fairly new and untapped segment for mobile applications, although the web has long gone this way and has a sufficient number of standardized solutions. <br><br>  The first question that arises from the majority: what are we going to automate?  The developer will answer: we will test the code, the manager will immediately start arguing that the functionality needs to be tested.  I believe that you need to test both. <br><br>  In general, if we talk about our application, then all the checks are divided into several categories: <br><br><ul><li>  <b>Static analysis</b> : I do not know why so little attention is paid to this approach, it is a very powerful tool that allows you to apply formalized rules to the whole project, and not to individual classes; </li><li>  <b>UnitTesting</b> : good old unit tests that allow you to make sure that a class works exactly as the developer or user of this class expects; </li><li>  <b>UiTesting</b> : functional / end-to-end tests that check the final result: what the user sees and how he will work with it. </li></ul><br><h3>  Static analysis </h3><br>  As a static analyzer, we use ready-made solutions.  For Android, it is Lint, which has recently become a very effective tool for monitoring the quality of android-specific code, markup resources, graphics, etc.  In addition, it allows you to add your checks specific to the contract within the project.  One of these contracts is that no layout-related parameters should be in styles.  For example, the properties layout_margin \ layout_alignParentTop or something like that.  From the point of view of syntax, no one forbids putting these properties into styles, but in this case, the style itself is not used to determine the visual component of a UI component, but to store some values ‚Äã‚Äãthat you can then not write in the markup file.  In other words, a style is used as an attribute container.  We decided that these are different things that should be separated, because, firstly, LayoutParams still relate to markup, and secondly, they relate not to the control, in the tag of which these attributes are written, but to its parent in which he lies. <br><br>  If you look into it, then in any more or less completed project, in which there are guides on writing code, markup resources, there are templates for solving typical problems of this application, there are quite a lot of such things.  They can be monitored at the code review stage, documented, reminded about them each time at the beginning of the working day, or rely on the fact that, once familiarized with these wishes, everyone will continue to fulfill them.  As they say, blessed is he who believes, but personally I‚Äôm much calmer to work, knowing that I myself will not forget about it and will not miss anything, hurrying to close the annoying task sooner.  It is necessary to formalize such checks, add them to the build process with convenient reports, and not worry that, having taken on a new task, you suddenly find a code that has run through all the checks, from which hair stands on end. <br><br>  Writing your checks is easy enough, even fascinating.  In the course of adding any static checks, a bunch of ideas immediately appear on how to statically detect any other problems.  For Lint, guides and official documentation will help.  You can develop rules directly in Android Studio. <br><br>  <a href="http://tools.android.com/tips/lint-custom-rules">tools.android.com/tips/lint-custom-rules</a> <br>  <a href="http://tools.android.com/tips/lint/writing-a-lint-check">tools.android.com/tips/lint/writing-a-lint-check</a> <br><br>  For java-code, there are also invented static analyzers.  I will not list everything, I will tell only that we use FindBugs.  When we chose a tool, we wanted to get a convenient format, a sufficient amount of rules that will be checked, and the ability to add our own rules.  At the moment, we have written the necessary checks, such as checking the closed cursors, checking that the AccountManager instance is always obtained with the application context, checking that the onEventComplete method is required to be called during the template use of the event class, and others.  Adding your own rules, which will determine the teamwork arrangements, prevent common mistakes due to carelessness - this is an excellent practice, which reduces the time for code review and testing, and also ensures that such errors will not at least fall into the production version of the application in the future. .  We used the <a href="http://www.ibm.com/developerworks/library/j-findbug2/">FindBugs, Part 2</a> article <a href="http://www.ibm.com/developerworks/library/j-findbug2/">: Writing custom detectors</a> as a guide for writing checks.  It clearly shows how to create your own plugin, add detectors and use it in the verification process.  The report is provided either in a formatted HTML document, or in the form of an XML report, where it is written briefly and in the case, in which class / method an error was found, an error code, a string, etc.  This is usually enough to understand where you just did not clean up after you :-). <br><br>  Great, isn't it?  A huge set of rules and common mistakes are ready, there is an opportunity to supplement it, it remains only to find the courage to start and use it. <br><br>  Once I noticed that our project uses SNAPSHOT versions of libraries.  Obviously, this is permissible only in the brunch for the task, when these changes are made to the library used.  After the code is poured into the main branch, there should be no SNAPSHOTs in the project.  In this case, the reason is quite prosaic and characterizes the majority of such errors.  After the task was tested and it was decided that this version reached all the definition of done, the developer was so happy that he forgot to merge the library into the main branch, determine the new version of this library and change the version in the main project.  The problem is that neither Lint nor FindBugs can check the build script.  Moreover, even if these checks are added to build.gradle itself, it is necessary to know where it is permissible and where not.  Obviously, this is permissible in brunch, in which the library is now changing, but unacceptable after it falls into a common branch.  This is how we started using git pre-receive hooks in order to monitor what is happening in the project at the repository level. <br><br>  I know that many teams do not consider it necessary to spend time setting up rules that are suitable for a project at the version control system level, since ‚Äúwe have no fools, no one will delete all branches in the repository‚Äù, or for some other reasons, for example, due to lack of time.  For us, this is a past stage: we came to the decision that it is better to spend a little more time, but to be confident in the safety and quality of the product.  For these purposes, pre-receive hooks are very good: we can determine that changes are added to the common branch, and check that the HEAD of this common branch does not contain unwanted code.  At best, no one will ever know about the existence of such a check, but, as practice shows, a random error is enough to make it possible to pierce notably.  Pre-receive hook is perfect for checking all the corrected TODO and FIXME, which the developer willingly arranges, but forgets to fix.  It also perfectly copes with typical logging problems - adding new Throwable () output to all functions of interest to the developer, because there was a very complex and demanding set of details bug in the branch.  For us, the ability to track the errors committed is automatically important for understanding that we will not step on the same rake again.  Errors make everything, it is only what conclusions you draw after that.  Our conclusion is that, in addition to the correction, it is necessary to make efforts to ensure that these errors do not continue to be made. <br><br><h3>  Unit testing </h3><br>  Here, by and large, everything is ordinary.  For some classes, checks are written to make sure that the class works exactly as intended, and at the same time show the class client an example of how to use it.  Currently, unit tests are run on real devices but do not establish a real connection, if necessary.  By the way, the need to establish a connection: when a developer thinks about how to test a particular module, most often he first thinks about how to replace class dependencies in order to isolate testing from the current environment.  In the case of a network connection, this may seem like a daunting task, because network interaction is not replaced by a call to a single method; a whole layer of logic needs to be wet.  For some time we resisted using the hook in the application code to substitute the server response and perform all subsequent actions with it.  The fact is that such an approach increases the risk that the wrong code that works in the combat application will be tested.  Every time when the question arises whether to change the class interface for convenience of testing, whether it is worth adding additional conditions to the function execution process, I try to stick to the following position: first of all, all the written code should be safe in terms of application functions.  If the additional conditions added to the code require a separate check, then for tests there is no need to do this.  This is the main reason why the usual setter did not suit us, who would simply replace the answer, take it from another source. <br><br>  As a result, we came to a different decision, in my opinion, more honest.  This is how one of the tests looks like, which checks that with a certain answer the command issues the status ‚Äúerror_folder_not_exist‚Äù <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@AcquireCookie</span></span> <span class="hljs-meta"><span class="hljs-meta">@LargeTest</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDeleteNonExistingFolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ DeleteFolder delete = runDeleteFolder(<span class="hljs-number"><span class="hljs-number">999</span></span>); assertERROR_FOLDER_NOT_EXIST(delete); }</code> </pre><br>  In this test, we make an honest request to the server, that is, the team works exactly the same as in the application.  The problem is that the unit test depends on how the network is configured on the device on which it runs.  And below is the second test, which checks exactly the same thing, but already substituting the desired answer, not fulfilling the actual request and not interacting with the server. <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@MockMethod</span></span>(response = RESPONSE_NOT_EXISTS) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testDeleteNonExistingFolderMock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ testDeleteNonExistingFolder(); }</code> </pre><br>  Thus, we have the ability to control the execution of tests - this is necessary, for example, so that the build status does not take into account the response of the server.  We rely on the fact that the interaction protocol is described, and, having made sure that the request is correct (using unit tests, of course), we can be sure that the server will give the correct answer.  And with the correct answer, it remains only to make sure that the application interprets it accordingly.  However, for example, for the nightly assembly, it would be nice to make sure that the contract of interaction with the server is not broken.  To do this, all tests will be run, including those that actually interact with it.  This will give us an additional airbag in case if due to some bug the contract with the server is broken.  We will learn about this from the test results, not from user reviews in the market.  If it is so important for us to check the functionality from start to finish, then you can make these tests basic and run them for each application build. <br><br>  The fact is that we do not want to constantly depend on the service, but at the same time we need to monitor the situation and in the form of daily reports receive information that everything is fine, or that some part of the application is not in order.  Here I prefer to share our application and third-party services that are critical for its full-fledged work, but are not our area of ‚Äã‚Äãresponsibility.  We can detect in our application a problem related to the work of a third-party service, but we cannot fix it.  Our task is to report a problem, wait for a fix, and run tests for working with this service to make sure that the problem has been fixed. <br><br><h3>  UI Testing </h3><br>  From the user's point of view, these are the most honest tests.  From the point of view of the developer - the most complex.  The most honest, because they are testing the final product, and not some part of it.  Putting the blame on someone else will not work: any bug is an application bug, and it doesn't matter what the reason is, Android‚Äôs imperfection in the hands of another developer or something else.  In any case, the error needs to be corrected.  The advantages of such black-box testing include the fact that for us, in fact, there is no difference how the functionality is implemented, what is the architecture of the application, etc. If two bugs in the application overlap each other, and eventually the user saw the right result - it suits us.              ‚Äî        . <br><br>  - ,     ,   ,  UI-    ,           . <br><br>       .       ,    , ‚Äî  .   ,   .      ( ,    -  ,   -    )  ,     .         ,      ,   ,       . .    ,     ,        ,            .      ,   ,     ,     . <br><br> ,     ,  .     :    ,        .  ,    , ,     ,    - ,   99%  .      ,    ,      ,   ,  ,        ,   ,    ,     .       , , ,     .      ,       Android  iOS.    ,      ,  ,       .    ,      ,        ,     ,     ,            ,     . <br><br>      Robotium.    ,          ,    . ,           .  , ,     .  ,   ,     .    Espresso!    ,       . .        ,      .    Robotium 2 ,      ,           ,    .    .           Robotium,    ,           Sleep Pattern'.     ,     ,  sleep(N * 1000)   ,    .       :    ,      (UI Thread). , ,     Sleep(),     .  :  10      ,    .  Instrumentation-based   ,  ,   UI Thread   ,     .  android.app.Instrumentation  : <br><br><pre> <code class="java hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Synchronously wait for the application to be idle. Can not be called * from the main application thread -- use {</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@link</span></span></span><span class="hljs-comment"> #start} to execute * instrumentation in its own thread. */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waitForIdleSync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ validateNotAppThread(); Idler idler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Idler(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>); mMessageQueue.addIdleHandler(idler); mThread.getHandler().post(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EmptyRunnable()); idler.waitForIdle(); }</code> </pre><br>  ,      ,     ,  View  ,   ,   ,    ,  View    ,          .. <br><br> ,   ,  Espresso  ,    .        ;    Google        ,     ,  Espresso   .     Lead developer'  ,     Robotium  Espresso   TestRunner.  ,    .   ,      ,          Espresso.         .        . <br><br> Espresso   ,     .       ~26 ,      .          4%.   ,     .  ,    ,     waitForIdleSync     :       ,            ‚Äî   ,     ,     .    CustomIdlingResource       Espresso    Robotium.   ,    ,   ‚Äî        idle , custom idling resource       .    ,       , ,     idle   ,   ,          . <br><br> , Espresso ‚Äî    .       ,       ,           ,     . <br><br>      ,  ,        , ‚Äî       ,       .     , , Sharing    (     )  - .       ,     .  Robotium/Espresso-   ,      .  , ,    cross-app functional UI tests,     UI Automator.              ,        ,    Testing Support Library,     Google I/O 2015,          ,      .  ,    ,  ,     : <br><br><ol><li>  ,    . </li><li>    ,  , ,  . </li><li>  push-   . </li><li>   ,    . </li><li>       back-.,       ,      . </li></ol><br>           ,      ,  ,     ..,    3  4    uiAutomator framework,    , ,      ,      .      API Espresso,             .        ,         . <br><br> ,        .             ‚Äî  ,         . <br><br>       ,   ,       ,      product flavors   ,          , -   ..            adb, usb, VirtualBox      .    ,   ,   ,      . <br><br> PS  <a href="https://corp.mail.ru/ru/jobs/vacancy/865/"></a> Android-   .     ‚Äî   <a href=""></a> . </div><p>Source: <a href="https://habr.com/ru/post/273781/">https://habr.com/ru/post/273781/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273773/index.html">3D-lab for people from MIEM, sling their heads inside the prototype trace of printed circuit boards</a></li>
<li><a href="../273775/index.html">The design decision is made by the designer.</a></li>
<li><a href="../273777/index.html">How to run your own torrent search engine based on RuTracker?</a></li>
<li><a href="../273779/index.html">CLI for MarionetteJS</a></li>
<li><a href="../27378/index.html">Automatic detection of free text language on PHP - library PHPLangautodetect</a></li>
<li><a href="../273783/index.html">Non-standard city for non-standard people: a guide to the architecture of Innopolis</a></li>
<li><a href="../273785/index.html">RHCSA certification: preparation and delivery experience</a></li>
<li><a href="../27379/index.html">Ru 2.0 pre-seed</a></li>
<li><a href="../273791/index.html">Embedded Hyper-V Virtualization - First Step</a></li>
<li><a href="../273793/index.html">SID change during cloning and mass deployment</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>