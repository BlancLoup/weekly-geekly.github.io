<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>[1] + [2] - [3] === 9 !? Examination of internal type conversion mechanisms in JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript allows you to perform type conversion. If this is done intentionally, then we have an explicit type casting (type casting or explicit coerc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>[1] + [2] - [3] === 9 !? Examination of internal type conversion mechanisms in JavaScript</h1><div class="post__text post__text-html js-mediator-article">  JavaScript allows you to perform type conversion.  If this is done intentionally, then we have an explicit type casting (type casting or explicit coercion).  In the case where this is done automatically, when you try to perform any operations on values ‚Äã‚Äãof different types, this is called implicit type conversion (coercion or implicit coercion). <br>  The author of the material, the translation of which we are publishing today, suggests looking at how explicit and implicit type conversions look at a low level.  This will allow everyone to better understand the processes hidden in the depths of JavaScript and help give a reasoned answer to the question of why [1] + [2] - [3] === 9. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vv/lf/33/vvlf33ewcq37zfnnh0ibokb83po.jpeg"></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Explicit type conversion</font> </h2><br><h3>  <font color="#3AC1EF">‚ñçObject wrappers of primitive types</font> </h3><br>  Practically all primitive types in JavaScript (the exceptions are <code>null</code> and <code>undefined</code> ) have object wrappers including their values.  Read more about it <a href="https://wanago.io/2018/02/12/cloning-objects-in-javascript-looking-under-the-hood-of-reference-and-primitive-types/">here</a> .  The developer has access to the constructors of such objects.  This fact can be used to convert values ‚Äã‚Äãof one type into values ‚Äã‚Äãof another type. <br><br><pre> <code class="hljs ruby">String(<span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">'123'</span></span> Boolean(<span class="hljs-number"><span class="hljs-number">123</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> Number(<span class="hljs-string"><span class="hljs-string">'123'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span> Number(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  In the example shown here, wrappers for variables of primitive types do not exist for long: after the job is done, the system gets rid of them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Attention should be paid to this, since the above statement does not apply to cases where the keyword <code>new</code> used in such a situation. <br><br><pre> <code class="hljs pgsql">const <span class="hljs-type"><span class="hljs-type">bool</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-type"><span class="hljs-type">bool</span></span>.propertyName = <span class="hljs-string"><span class="hljs-string">'propertyValue'</span></span>; <span class="hljs-type"><span class="hljs-type">bool</span></span>.valueOf(); // <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-type"><span class="hljs-type">bool</span></span>) { console.log(<span class="hljs-type"><span class="hljs-type">bool</span></span>.propertyName); // <span class="hljs-string"><span class="hljs-string">'propertyValue'</span></span> }</code> </pre> <br>  Since in this case <code>bool</code> is a new object (and not a primitive value), it is converted to <code>true</code> in the <code>if</code> expression. <br><br>  Moreover, we can talk about the equivalence of the following two structures.  This one: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { console.log(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); }</code> </pre> <br>  And this: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-type"><span class="hljs-type">Boolean</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) ) { console.log(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); }</code> </pre> <br>  You can see for yourself by conducting the following experiment, which uses the Bash shell.  Place the first code fragment in the file <code>if1.js</code> , the second - in the file <code>if2.js</code>  Now do the following: <br><br>  <b>1.</b> Compile JavaScript code by converting it to assembler code using Node.js. <br><br><pre> <code class="hljs ruby">$ node --print-code ./if1.js <span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>./if1.asm $ node --print-code ./if2.js &gt;&gt; ./if2.asm</code> </pre> <br>  <b>2.</b> Prepare a script to compare the fourth column (here are commands in assembler) of the resulting files.  There is no intentional comparison of memory addresses, as they may differ. <br><br><pre> <code class="hljs kotlin">#!/bin/bash file1=$(awk <span class="hljs-string"><span class="hljs-string">'{ print $4 }'</span></span> ./if1.asm) file2=$(awk <span class="hljs-string"><span class="hljs-string">'{ print $4 }'</span></span> ./if2.asm) [ <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$file1</span></span></span><span class="hljs-string">"</span></span> == <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$file2</span></span></span><span class="hljs-string">"</span></span> ] &amp;&amp; echo <span class="hljs-string"><span class="hljs-string">"The files match"</span></span></code> </pre> <br>  <b>3.</b> Run this script.  It will display the following line, which confirms the identity of the files. <br><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"The files match"</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçParseFloat Function</font> </h3><br>  The <code>parseFloat</code> function works in almost the same way as the <code>Number</code> constructor, but it is more freely related to the arguments passed to it.  If it encounters a character that cannot be part of a number, then it returns a value, which is a number assembled from the digits before that character and ignores the remainder of the string passed to it. <br><br><pre> <code class="hljs ruby">Number(<span class="hljs-string"><span class="hljs-string">'123a45'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> NaN parseFloat(<span class="hljs-string"><span class="hljs-string">'123a45'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">123</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçParseInt Function</font> </h3><br>  The <code>parseInt</code> function, after parsing the argument passed to it, rounds the resulting numbers.  It can work with values ‚Äã‚Äãpresented in different number systems. <br><br><pre> <code class="hljs ruby">parseInt(<span class="hljs-string"><span class="hljs-string">'1111'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> parseInt(<span class="hljs-string"><span class="hljs-string">'0xF'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> parseFloat(<span class="hljs-string"><span class="hljs-string">'0xF'</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br>  The <code>parseInt</code> function can either ‚Äúguess‚Äù which number system is used to record the argument passed to it, or it can use the ‚Äúhint‚Äù as the second argument.  You can read about the rules applied when using this function in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt">MDN</a> . <br><br>  This function works incorrectly with very large numbers, so it should not be considered as an alternative to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor">Math.floor</a> function (by the way, it also performs type casting). <br><br><pre> <code class="hljs pgsql">parseInt(<span class="hljs-string"><span class="hljs-string">'1.261e7'</span></span>); // <span class="hljs-number"><span class="hljs-number">1</span></span> Number(<span class="hljs-string"><span class="hljs-string">'1.261e7'</span></span>); // <span class="hljs-number"><span class="hljs-number">12610000</span></span> Math.floor(<span class="hljs-string"><span class="hljs-string">'1.261e7'</span></span>) // <span class="hljs-number"><span class="hljs-number">12610000</span></span> Math.floor(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) // <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñçToString Function</font> </h3><br>  Using the <code>toString</code> function, you can convert other types of values ‚Äã‚Äãinto strings.  It should be noted that the implementation of this function in prototypes of objects of different types is different.  If you feel that you need to better understand the concept of prototypes in JavaScript, take a look at <a href="https://wanago.io/2018/03/19/prototype-the-big-bro-behind-es6-class/">this</a> material. <br><br><h4>  String.prototype.toString function </h4><br>  This function returns a value represented as a string. <br><br><pre> <code class="hljs pgsql">const dogName = <span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span>; dogName.toString() // <span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span> String.prototype.toString.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(<span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span>) // <span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span> String.prototype.toString.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>({}) // Uncaught TypeError: String.prototype.toString requires that <span class="hljs-string"><span class="hljs-string">'this'</span></span> be a String</code> </pre> <br><h4>  Number.prototype.toString function </h4><br>  This function returns a number converted to a string (as the first argument, you can pass to it the base of the number system in which the result returned by it should be presented). <br><br><pre> <code class="hljs ruby">(<span class="hljs-number"><span class="hljs-number">15</span></span>).toString(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">"15"</span></span> (<span class="hljs-number"><span class="hljs-number">15</span></span>).toString(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">"1111"</span></span> (-<span class="hljs-number"><span class="hljs-number">15</span></span>).toString(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">"-1111"</span></span></code> </pre> <br><h4>  Symbol.prototype.toString function </h4><br>  This function returns a string representation of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> object.  It looks like this: <code>`Symbol(${description})`</code> .  Here, in order to demonstrate the operation of this function, the concept of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template strings is used</a> . <br><br><h4>  Boolean.prototype.toString function </h4><br>  This function returns <code>true</code> or <code>false</code> . <br><br><h4>  Object.prototype.toString function </h4><br>  Objects have an internal value of <code>[[Class]]</code> .  It is a tag representing the type of object.  The <code>Object.prototype.toString</code> function returns a string of the following form: <code>`[object ${tag}]`</code> .  Here, as a tag, either standard values ‚Äã‚Äãare used (for example, ‚ÄúArray‚Äù, ‚ÄúString‚Äù, ‚ÄúObject‚Äù, ‚ÄúDate‚Äù), or values ‚Äã‚Äãspecified by the developer. <br><br><pre> <code class="hljs pgsql">const dogName = <span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span>; dogName.toString(); // <span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span> (  String.prototype.toString) <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.prototype.toString.<span class="hljs-keyword"><span class="hljs-keyword">call</span></span>(dogName); // <span class="hljs-string"><span class="hljs-string">'[object String]'</span></span></code> </pre> <br>  With the advent of ES6, tags are defined using objects of type <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> .  Let's give a couple of examples.  Here is the first. <br><br><pre> <code class="hljs pgsql">const dog = { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span> } console.log( dog.toString() ) // <span class="hljs-string"><span class="hljs-string">'[object Object]'</span></span> dog[Symbol.toStringTag] = <span class="hljs-string"><span class="hljs-string">'Dog'</span></span>; console.log( dog.toString() ) // <span class="hljs-string"><span class="hljs-string">'[object Dog]'</span></span></code> </pre> <br>  Here is the second. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dog = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } Dog.prototype[<span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span>.toStringTag] = <span class="hljs-string"><span class="hljs-string">'Dog'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog(<span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span>); dog.toString(); <span class="hljs-comment"><span class="hljs-comment">// '[object Dog]'</span></span></code> </pre> <br>  You can also use ES6 classes with getters. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(name) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> [Symbol.toStringTag]() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Dog'</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dog = new Dog(<span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span>); dog.toString(); <span class="hljs-comment"><span class="hljs-comment">// '[object Dog]'</span></span></code> </pre> <br><h4>  Array.prototype.toString Function </h4><br>  This function, when called from an <code>Array</code> object, makes a call <code>toString</code> for each element of the array, collects the results into a string whose elements are separated by commas, and returns this string. <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arr = [ {}, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> ] arr.toString() <span class="hljs-comment"><span class="hljs-comment">// "[object Object],2,3"</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Implicit type conversion</font> </h2><br>  If you know how explicit type conversion works in JavaScript, it will be much easier for you to understand the features of the work of implicit type conversion. <br><br><h3>  <font color="#3AC1EF">‚ñçMathematical operators</font> </h3><br><h4>  Plus sign </h4><br>  Expressions with two operands, between which there is a <code>+</code> sign, and one of which is a string, produce a string. <br><br><pre> <code class="hljs pgsql"><span class="hljs-string"><span class="hljs-string">'2'</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> // <span class="hljs-number"><span class="hljs-number">22</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-string"><span class="hljs-string">''</span></span> // <span class="hljs-string"><span class="hljs-string">'15'</span></span></code> </pre> <br>  If you use the <code>+</code> sign in an expression with one string operand, you can convert it to a number: <br><br><pre> <code class="hljs cs">+<span class="hljs-string"><span class="hljs-string">'12'</span></span> <span class="hljs-comment"><span class="hljs-comment">// 12</span></span></code> </pre> <br><h4>  Other Mathematical Operators </h4><br>  When using other mathematical operators, such as <code>-</code> or <code>/</code> , the operands are always converted to numbers. <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">Date</span></span>(<span class="hljs-string"><span class="hljs-string">'04-02-2018'</span></span>) - <span class="hljs-string"><span class="hljs-string">'1'</span></span> // <span class="hljs-number"><span class="hljs-number">1522619999999</span></span> <span class="hljs-string"><span class="hljs-string">'12'</span></span> / <span class="hljs-string"><span class="hljs-string">'6'</span></span> // <span class="hljs-number"><span class="hljs-number">2</span></span> -<span class="hljs-string"><span class="hljs-string">'1'</span></span> // <span class="hljs-number"><span class="hljs-number">-1</span></span></code> </pre> <br>  When converting dates to numbers get <a href="https://en.wikipedia.org/wiki/Unix_time">Unix-time</a> corresponding to the dates. <br><br><h3>  <font color="#3AC1EF">‚ñç exclamation mark</font> </h3><br>  Using an exclamation mark in expressions leads to the conclusion <code>true</code> if the initial value is perceived as false, and <code>false</code> for values ‚Äã‚Äãthat are perceived by the system as true.  As a result, an exclamation point applied twice can be used to convert different values ‚Äã‚Äãto their corresponding logical values. <br><br><pre> <code class="hljs erlang-repl">!<span class="hljs-number"><span class="hljs-number">1</span></span> // false !!({}) // true</code> </pre> <br><h3>  <font color="#3AC1EF">ToToInt32 function and bitwise OR operator</font> </h3><br>  It is worth <code>ToInt32</code> function, although it is an abstract operation (an internal mechanism that cannot be called in normal code).  <code>ToInt32</code> converts values ‚Äã‚Äãto <code>ToInt32</code> <a href="https://en.wikipedia.org/wiki/32-bit">32-bit integers</a> . <br><br><pre> <code class="hljs ruby"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-params"><span class="hljs-params">| </span><span class="hljs-literal"><span class="hljs-params"><span class="hljs-literal">true</span></span></span><span class="hljs-params">          // 1 0 |</span></span> <span class="hljs-string"><span class="hljs-string">'123'</span></span>         /<span class="hljs-regexp"><span class="hljs-regexp">/ 123 0 | '2147483647'  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2147483647 0 | '2147483648'  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -2147483648 ( ) 0 | '-2147483648' /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -2147483648 0 | '-2147483649' /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 2147483647 ( ) 0 | Infinity      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ 0</span></span></code> </pre> <br>  Applying a bitwise <code>OR</code> operator in the event that one of the operands is zero and the second is a string will cause the value of the other operand to not change, but will be converted to a number. <br><br><h3>  <font color="#3AC1EF">‚ñçOther cases of implicit type conversion</font> </h3><br>  In the process of work, programmers may encounter other situations in which implicit type conversion is performed.  Consider the following example. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bar = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = {}; x[foo] = <span class="hljs-string"><span class="hljs-string">'foo'</span></span>; x[bar] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(x[foo]); <span class="hljs-comment"><span class="hljs-comment">// "bar"</span></span></code> </pre> <br>  This is due to the fact that both <code>foo</code> and <code>bar</code> , when casting them to a string, turn into <code>"[object Object]"</code> .  This is what actually happens in this code snippet. <br><br><pre> <code class="hljs ruby">x[bar.toString()] = <span class="hljs-string"><span class="hljs-string">'bar'</span></span>; x[<span class="hljs-string"><span class="hljs-string">"[object Object]"</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-string"><span class="hljs-string">"bar"</span></span></code> </pre> <br>  Implicit type conversion also happens with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">patterned strings</a> .  In the following example we will try to override the function <code>toString</code> . <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Dog = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } Dog.prototype.toString = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> dog = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dog(<span class="hljs-string"><span class="hljs-string">'Fluffy'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${dog}</span></span></span><span class="hljs-string"> is a good dog!`</span></span>); <span class="hljs-comment"><span class="hljs-comment">// "Fluffy is a good dog!"</span></span></code> </pre> <br>  It is worth noting that the reason why it is not recommended to use the non-strict equality operator ( <code>==</code> ) is the fact that this operator, if the types of the operands do not match, produces an implicit type conversion.  Consider the following example. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>); foo === foo2 <span class="hljs-comment"><span class="hljs-comment">// false foo &gt;= foo2 // true</span></span></code> </pre> <br>  Since the <code>new</code> keyword is used here, <code>foo</code> and <code>foo2</code> are wrappers around primitive values ‚Äã‚Äã(which is the string <code>'foo'</code> ).  Since the corresponding variables refer to different objects, the result of comparing the form <code>foo === foo2</code> is <code>false</code> .  The <code>&gt;=</code> operator performs implicit type conversion by calling the <code>valueOf</code> function for both operands.  Because of this, a comparison of primitive values ‚Äã‚Äãis made here, and as a result of calculating the value of the expression <code>foo &gt;= foo2</code> turns out <code>true</code> . <br><br><h2>  <font color="#3AC1EF">[1] + [2] - [3] === 9</font> </h2><br>  We believe now it is clear to you why the expression <code>[1] + [2] ‚Äì [3] === 9</code> true.  However, nevertheless, we offer to disassemble it. <br><br>  <b>1.</b> In the expression <code>[1] + [2]</code> , the operands are transformed into strings using <code>Array.prototype.toString</code> , and then the result is concatenated.  As a result, here we have the string <code>"12"</code> . <br><br><ul><li>  It should be noted that, for example, the expression <code>[1,2] + [3,4]</code> will give the string <code>"1,23,4"</code> ; </li></ul><br>  <b>2.</b> When calculating the expression <code>12 - [3]</code> , subtraction <code>"3"</code> of <code>12</code> will be performed, which gives <code>9</code> . <br><br><ul><li>  Here we also consider an additional example.  Thus, the result of calculating the expression <code>12 - [3,4]</code> will be <code>NaN</code> , since the system cannot implicitly bring <code>"3,4"</code> to a number. </li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  You can find many recommendations, the authors of which advise simply to avoid implicit type conversions in JavaScript.  However, the author of this material believes that it is important to understand the features of the work of this mechanism.  Probably, you should not try to use it intentionally, but knowing how it works will undoubtedly prove useful in debugging code and help you avoid mistakes. <br><br>  <b>Dear readers!</b>  How do you feel about implicit type casting in javascript? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/353562/">https://habr.com/ru/post/353562/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353552/index.html">Reactive programming in Objective-C</a></li>
<li><a href="../353554/index.html">Improving Redux</a></li>
<li><a href="../353556/index.html">Postgres enum</a></li>
<li><a href="../353558/index.html">The digest of fresh materials from the world of the frontend for the last week No. 310 (April 9 - 15, 2018)</a></li>
<li><a href="../353560/index.html">Million, million, million ... blue certificates</a></li>
<li><a href="../353564/index.html">getDerivedStateFromState ‚Äîor how to make a complex problem out of a simple problem</a></li>
<li><a href="../353566/index.html">Overview of information security management architecture in Check Point R80.10. Part 1 (Translation)</a></li>
<li><a href="../353572/index.html">Global site tag (gtag.js) in Google Analytics. What is it and do you need it?</a></li>
<li><a href="../353574/index.html">Video about Panda Adaptive Defense on Aether platform</a></li>
<li><a href="../353576/index.html">Correct cryptographic answers: 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>