<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Building Command Line Applications (CLI)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article was written under the influence of the book ‚ÄúBuild Awesome Command-Line Application in Ruby‚Äù by David Copeland ( buy , download and study...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Building Command Line Applications (CLI)</h1><div class="post__text post__text-html js-mediator-article">  This article was written under the influence of the book ‚ÄúBuild Awesome Command-Line Application in Ruby‚Äù by David Copeland ( <a href="http://pragprog.com/book/dccar/build-awesome-command-line-applications-in-ruby">buy</a> , <a href="http://www.twirpx.com/file/883193/">download</a> and <a href="http://www.awesomecommandlineapps.com/">study additional materials</a> ).  Most of it will be devoted to designing CLI applications, regardless of the language used.  Along the way, things specific to ruby ‚Äã‚Äãwill be discussed, but it's not scary if you don't know it, the code will not be too much.  You can consider this article as a rather detailed review of the above-mentioned book interspersed with your own experience.  I recommend the book! <br><br>  To begin, I will ask a question.  If you look at the IT communities, you will notice that despite the abundance of programs with a beautiful graphical user interface, command-line applications remain quite popular.  Why? <br>  There are several answers.  Firstly, it is <s>beautifully</s> convenient - if you can describe a task with a command from the command line, then it is much easier to automate than if you have to analyze mouse movements and clicks on different menu items.  Secondly, it makes it possible to combine programs in an incredible number of ways, which is difficult to achieve with the help of graphical interfaces. <br>  To a large extent, the Unix philosophy is based on the principle that many small utilities, each of which is able to do its own specific task, are better than one multifunctional universal program.  And this is one of the reasons for the success of Unix-systems in the world of IT-Schnick. <br>  Probably everyone understands that the average user is unlikely to be able to lure out from the GUI to the CLI, let's focus on us, ‚Äúcomputer scientists,‚Äù and specify our wishes for CLI applications. <a name="habracut"></a><br><br><h4>  General requirements </h4><br>  In a nutshell, we want to use them was simple, but effective.  David Copeland has written an exhaustive list of application requirements to achieve this: <br><ul><li>  Easy to use - It should be easy to use and have a clear goal.  Preferably one.  Tula, which, like a Swiss knife, are able to do everything, are usually difficult to use and no one knows all their possibilities.  However, we'll also talk about how to design multi-functional applications to make them easier to use and to support. <br>  The minimum that you can do to simplify working with your program is to follow the option format agreements.  Do not force your users to relearn!  How it is accepted to specify options, and how to name them, I will write in detail. </li><li>  Helpful - This means that the user should have easy access to the help about how the application does, how to start it, and how to configure it.  It is desirable that the application adds its page to the man.  In addition, integration with the shell at the level of command completion will not hurt. </li><li>  Plays well with others - The application must be able to interact with other applications.  This means the modularity of applications, as is customary in Unix.  Do not neglect return codes, well-designed work with input-output streams and not only. </li><li>  Has sensible defaults but is configurable - Standard usage scenarios should be available without specifying thousands of options.  Non-standard scripts do not need to be easy to use, but should still be available.  In addition, the default set of options must be customizable. </li><li>  Installs painlessly - Easy to install along with all dependencies, installs the path to the application in environment variables for easier launch.  Updates should be just as easy. </li><li>  Fails gracefully - In case of an error in the call to the application, it should tell you what the error was and how to fix it.  In addition, the application must be non-destructive, i.e.  should not overwrite or erase files if an error is made in the arguments (and ideally, if it does not perform dangerous operations at all without confirmation) </li><li>  Gets new features and bug fixes easily - The application must be supported.  Crush the application into modules and scatter them across different files.  Write tests.  Use semantic versioning.  Use a version control system. </li><li>  Delights users - The output of the application should be nice looking.  To your order colors, formatting (for example, tabular or html).  It also includes interactive user interaction. </li></ul><br>  Now I will go through these points in more detail. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Easy to use </h4><br><h5>  Utilities and software packages.  What is more convenient? </h5><br>  So, all applications can be divided into two types: utilities and software packages (in the original, Command Suite). <br><br>  The first type is applications that have one goal, one mode of operation.  There are countless examples of this type of program, almost all Unix commands are: ls, grep, diff, ... (rubists can recall, for example, the rspec command). The convenience of these programs is that their capabilities are easier to remember and more difficult to get confused.  In addition, it is easier to glue them together in chains for consistent processing.  The following analogy will be relevant here.  Imagine that you are building a house, moreover a house is not a type specimen.  It is much more convenient to build it from bricks, and not from monolithic blocks, because in some places you would have to file these blocks, but somewhere you would have to stone the joints.  Yes, and the blocks can only be a crane, while bricks can be laid by hand. <br><br>  The second type of program can be compared with a Swiss knife or food processor.  Sometimes they are extremely convenient.  Look at git (in the world of Ruby, gem, rails, bundle are immediately remembered) - one program, and how much it can do.  And kommitit / checkout can, and searches in the history itself, and considers changes between files.  So grep, diff and others are built into it, nothing to combine with git and not necessary, he can do everything himself.  If you go back to the analogy with the house, then the guitar has a model project for each case of life (and try to remember them all). <br>  And yet, not all programs should be multifunctional: anyway, you will not overrun all use cases.  In confirmation of this thesis, I suggest you imagine a "multitool" that can do cd, ls, pwd, diff, df and a bunch of useful operations with one command, only the options will have to be slightly changed (for example, filesystem change, filesystem show, filesystem where, etc. ).  Will you use this?  I think that throw out for excessive bulkiness.  Although software packages are extremely convenient, it makes sense to think carefully before writing your centaur with eight tentacles. <br><br>  By the way, if you wrote a dozen utilities, and then realized that you want it to be a software package, then it is not so difficult to fix.  It is enough to write a wrapper that will route the commands.  You may not know, but git consists of dozens of utilities like git-commit, git-show, git-hash-object, git-cat-file, git-update-index, and so on, which is passed to the git command based on the type of command and options (of course, there can be a whole chain of utility calls behind one command).  So even large projects start better with a set of small programs that you will combine in the future.  They are easier to write, debug, maintain and use. <br><br><h5>  The syntax of the command line arguments or "this house has its own traditions." </h5><br>  I'll start with the terminology.  When you run a command line application, you specify a set of parameters.  They are divided into the following types: options and arguments.  David Copeland additionally divides options into two subtypes: flags and switches. <br>  It can be schematically depicted as follows <code>executable [options] &lt;arguments&gt;</code> .  I think that everything is already up to date, but just in case, I will explain that the parameters in square brackets are optional, and in the corner ones are mandatory. <br><br>  Arguments (or positional arguments) are the parameters that must be specified for the program to work.  Their order is strictly defined. <br>  Options are optional parameters.  They can be listed in any order. <br>  Switch type options are boolean options, the program checks for their presence or absence.  Example: <code>--ignore-case</code> (or, sometimes, <code>--no-ignore-case</code> ). <br>  Flag type options are options with a parameter.  This parameter can have a default value.  For example, <code>grep -C ...</code> and <code>grep -C 2 ...</code> in my version, the grep utilities are equivalent. <br>  Both arguments and options may have default values, but they may not. <br><br>  As an example, in the <code>grep --ignore-case -r - 4 "some string" /tmp</code> arguments are <code>"some string" /tmp</code> , and the options <code>--ignore-case -r - 4</code> .  At the same time, <code>--ignore-case</code> and <code>-r</code> are switches, and <code>-C 4</code> is a flag. <br><br><h5>  Agreement on the use of options </h5><br>  Options can be specified both in the short <code>-i</code> and in the long <code>--ignore-case</code> form.  In principle, nothing prevents you from having fun with the format of options in any way, because you can intercept command line options in the script directly.  But it is better to adhere to the rules developed by the Unix-community, as they are honed by time, and most people are accustomed to them.  In addition, there are ready-made libraries that allow you to conveniently work with these options. <br>  These rules are: <br><ul><li>  The long option ( <code>--long-option</code> ) starts with two hyphens.  There can be no spaces in the option name, but single hyphens are quite acceptable. </li><li>  The short option ( <code>-l</code> ) consists of one letter (as a rule, the register has a value) and the preceding hyphen - one.  Conveniently, when a short option is the first letter of a long analog, it is easier to remember its value. </li><li>  Several short options can be combined together as follows: <code>ls -a -l</code> equivalent to <code>ls -al</code> .  After a single hyphen, there may be any number of options without arguments. </li><li>  If a short option has a parameter, it can usually go either immediately after the option or be separated from it with a space.  <code>-C4</code> or <code>-C 4</code> .  I did not accidentally say ‚Äúusually‚Äù.  For example, the standard optparse Ruby library handles these two cases in the same way.  The ls utility handles similar options in the same way.  But the grep utility, for example, thinks that <code>-C</code> separate, and <code>4</code> is separate.  Maybe this is a bug.  I could not fail to mention that there are exceptions, but users are unlikely to be grateful to you if your program becomes another exception. <br>  I do not know how they usually do when the short option has a non-numeric parameter with a default value ( <code>-c [param]</code> ), because <code>-cxyz</code> can be interpreted as <code>- xyz</code> , and <code>-c -x -y -z</code> .  It is better for the user to always write a space if the option has an optional parameter.  It is better for the programmer to think in advance about how to minimize the problems associated with the continuous writing of options. </li><li>  In the case of a long option, the space in front of the parameter is usually allowed, but it is advisable to use an equal sign.  <code>ls --width=10</code> or <code>ls --width 10</code> <br>  Without a separating character after the long option, the parameter is not indicated (judge for yourself what confusion will come out, especially if the parameter is not numeric). </li><li>  Each option can be either short form or long.  And it may be that there is only short or only long.  However, the presence of a long form for each of the options is highly desirable. </li><li>  For boolean options, you can specify an optional prefix <code>no-</code> , for example: <code>--[no-]pager</code> .  The --pager option sets the pagination, <code>--no-pager</code> indicates that there should be no pagination, and the absence of the option retains the default value.  This is especially important when the default options are configurable.  Without a prefix, for example, it would be impossible to cancel the value of the option set by default. </li></ul><br><br><h5>  Why is it always advisable to have a long option </h5><br>  The long form of options is usually used in writing scripts that use your application.  Long options should be self-documenting.  Imagine that a sysadmin looks in cron and sees the launch of a database backup task with incomprehensible options <code>-zsf -m 100</code> .  If he is not the author of the script, then he will have to climb into the help to understand what he means.  Agree, the set of options <code>--scheme --max-size 100 --gzip --force</code> will tell him much more and will not make him spend too much time. <br>  In addition, it is not recommended to make short options for rarely used options.  First, the letters in the alphabet are not too many to spend on all options.  Secondly, and this is even more important, the lack of a short option prompts the user that this option is secondary or even undesirable during normal operation, and that one should not use it thoughtlessly, simply because it is possible. <br>  So, often used options have both a short form, and a long one, and rarely used ones - only a long one. <br><br><h5>  Differences in command line parameters for single-featured and feature-rich applications </h5><br>  These two types of applications have slightly different order of arguments when called. <br>  For the first type of application, the call usually looks like this: <code>executable [options] &lt;arguments&gt;</code> <br>  For software packages, the format is somewhat more complicated: <code>executable [global options] &lt;command&gt; [command options] &lt;arguments&gt;</code> <br>  Here is an example from the book: <code>git --no-pager push -v origin_master</code> Here <code>--no-pager</code> is an option that can be applied to any git command, and <code>-v</code> is an option specific to the push command.  It should be noted that global options and options specific to a command may have the same name.  But in this case, not all means will be suitable for their processing, for example, the standard OptionParser Ruby-Library will not cope with this task, since it does not distinguish where the option occurred.  If you are making a software package, use the GLI library better. <br><br>  Just in case, I remind the reader that, technically, the input programs do not receive a string of parameters, but an array of parameters already divided into elements.  In ruby, this array is called <code>ARGV</code> .  It is with him that we work, directly or with the help of special libraries.  It should be noted that it is not broken down into elements by spaces (otherwise it could not have, for example, file names with spaces), the shell has slightly more complex rules.  There is involved and the screening of characters, and the use of quotes for grouping.  If you need to screen, glue, or cut the parameter strings into arrays and back - look at the standard shellwords library.  It consists of three methods for this purpose: <code>String#shellsplit</code> , <code>String#shellescape</code> and <code>Array#shelljoin</code> . <br><br>  In the ruby ‚Äã‚Äãcommunity, most command-line applications use either OptionParser or a library based on it.  In the section on configuration - when we find out a little more - I will give an example of code written by using OptionParser. <br><br><h4>  Helpful </h4><br>  Imagine that you are seeing for the first time the awesome_program program that you are going to use.  As an experienced user, you will probably type in <code>awesome_program --help</code> in the hope of seeing the order of the arguments, a set of options, and examples of usage.  When you release your program, remember that the user who first saw it will probably do the same thing first thing, so let you have the keys <code>-h</code> , <code>--help</code> at the ready.  If you use a library of type OptionParser, you will automatically be included in the prompt line an enumeration of all the options that the program recognizes with the descriptions you give. <br><br>  In addition to the help line, it makes sense to write extended help in man.  However, as far as I know, rubygems does not automatically install pages in man.  However, there is a gem-man gem that allows you to display the man documentation pages for gems installed in the system. <br>  In order to create a man-documentation, you must create a file in a complex nroff format.  To simplify the task, use the ronn converter library, which allows you to write documentation pages in a simpler format.  When everything is ready, you can use the <code>gem man awesome_gem</code> - and see the help line.  In addition, you can write <code>alias gem='gem man -s'</code> .  At the same time, the man command is replaced by the gem man command, which allows you to search for man-help for gems.  For those requests that the gem-man could not process, an automatic redirection to the corresponding page of the usual man occurs. <br>  If you are thinking of making your own man-tips, look in the book, there is much more attention paid to it. <br><br>  To make it even easier for the user to launch a command, you can make the command completion at the shell level (it does not work in all shells).  This will allow clicking on the tab button to automatically supplement the names of commands, file names, etc.  The user will be less likely to make a spelling mistake, and he will spend much less time writing the command. <br><br>  In order to do tab-completion and store the history of commands within a program (online in programs like irb), it is enough to use the readline library built into Ruby.  It allows you to automatically save the history of all entered commands - due to the use of the <code>Readline.readline</code> command instead of <code>gets</code> . <br><br>  Tab-completion is done as follows: a <code>Readline.completion_proc=(block)</code> is returned to the <code>Readline.completion_proc=(block)</code> method, which returns an array of possible additions along the line of the text already entered, and that is the whole task.  For example: <br><pre> <code class="ruby hljs">Readline.completion_proc = proc { <span class="hljs-params"><span class="hljs-params">|input|</span></span> allowed_commands.grep /^<span class="hljs-comment"><span class="hljs-comment">#{input}/ }</span></span></code> </pre><br><br>  If you need a tab-completion not at the level of an already running program, but at the shell level, then this is somewhat more complicated.  You will have to tinker with the <code>.bashrc</code> . <br>  First add the <code>complete -F get_my_app_completions my_app</code> line to <code>complete -F get_my_app_completions my_app</code> <br>  Now every time you type <code>my_app()[- ]</code> , and then the tab key, the <code>get_my_app_completions</code> function will be called.  This function should return possible autocomplete options to the <code>COMPREPLY</code> variable, which the shell will use to provide the user with possible add-on options.  In the <code>.bashrc</code> you need to define this function.  I will give an example from the book for the todo application: <br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_todo_completions</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> [ -z <span class="hljs-variable"><span class="hljs-variable">$2</span></span> ] ; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-comment"><span class="hljs-comment">#    COMPREPLY=(`todo help -c`) else #      ,   $2 COMPREPLY=(`todo help -c $2`) fi } complete -F get_todo_completions todo</span></span></code> </pre><br>  Now the program needs to implement the following behavior (let's leave it as an easy exercise): <br>  1) if you manually type <code>todo help -c</code> on the command line, you should see a list of application commands: list, add, complete, help (each on its own line) <br>  2) if you type <code>todo help -c complete</code> - you should see a list of all the cases that have been started but not completed yet (those to which the complete command can be applied). <br><br>  <code>help -c [...]</code> is a service command, its presence can be not advertised in the brief help.  It is assumed that it will not be used by the user, but by the script in <code>.bashrc</code> . <br>  In this script, the function asks the application itself what can be substituted based on what is already typed (this one is transmitted after the <code>help -</code> option <code>help -</code> ).  The program monitors the situation when the application is given such a special set of parameters, and displays a list of all the options in the standard output (as you have already seen), from where they are sent straight to the shell script <code>COMPREPLY</code> . <br>  The author in the book uses its own GLI library, which automatically tracks such a set of options.  You can easily realize this opportunity without the help of GLI.  As you can see, there is no magic here. <br><br><h4>  Plays well with others </h4><br>  We will not discuss the need for convenient interaction between programs; anyone who worked in Unix can evaluate for himself how important this is.  The main question is how to achieve this? <br><br><h5>  Return codes </h5><br>  First, use return codes.  In case of successful completion of the program - 0, in case of error - various non-zero return codes.  This is important because the shell scripts can determine if the program has worked normally by requesting the status of the last completed program from the <code>$?</code> variable <code>$?</code>  .  To return the return status, ruby ‚Äã‚Äãuses the <code>exit(exit_status)</code> method. <br>  If you assign different return codes to different errors, then there is a chance that another program using yours will be able to decide whether the problem can be fixed and whether you should pay attention to it at all.  From the outside of the program, it‚Äôs better to see whether it‚Äôs scary that the program has ‚Äúdropped‚Äù or not.  Different return codes are like different exception classes, maybe you have a mistake in that there is no RAM, or maybe the network just disappeared for a second and you should try it one more time.  Some programs may crash simultaneously from several errors.  If you need to report several problems at once, use bitmasks.  The network has recommendations on which return codes are used for which errors, which you can read about on the <a href="http://www.gnu.org/software/libc/manual/html_node/Exit-Status.html">GNU</a> (very general) and <a href="http://www.freebsd.org/cgi/man.cgi%3Fquery%3Dsysexits%26sektion%3D3">FreeBSD</a> (very specific) sites.  If you do not want to bother with error codes, make at least the minimum effort - return at least some non-zero value in case of an error.  Otherwise, other programs will not even be able to find out if your program has worked normally. <br><br>  By the way, you can run the program not only from the shell script, but also from the ruby ‚Äã‚Äãscript.  There are several options to do this, for example, <code>Kernel.system</code> or <code>IO.popen</code> Read more about them in the documentation.  If you call another program using <code>system</code> , can you find out its return code in a similar shell variable of <code>$?</code>  . <br><br><h5>  I / O flows and error flow.  Pipe </h5><br>  The main way of interaction between programs launched from the command line is pipes.  A pipe is a way to redirect the output of one program to the input of another.  Denoted by a vertical bar <code>|</code>  .  For example, in the command <code>ls | sort</code>  <code>ls | sort</code> , the first part - ls does not display anything on the screen, but instead redirects its output to the input to the sorting program.  And the sort program picks up text from the input stream line by line and already sorted the list displays.  On the one hand, ls itself could sort the files, but it is not intended for this.  At the same time, sort is needed for this very purpose and has many options.  For example, you can sort strings not quite lexigraphically, if the names start with a number (otherwise the order will be as follows: 1.jpg, 10.jpg, 100.jpg, 2.jpg, ...).  Or sort in reverse order.  In addition, with the help of special programs (such as awk, sed), before sorting a string, you can correct it (for example, erase prefixes).  It should be noted that the pipe can be composed of an arbitrary number of programs.  So <code>ls | sort -n | tail</code> <code>ls | sort -n | tail</code>  <code>ls | sort -n | tail</code> will print the last ten lines of the file list, sorted by number. <br><br>  Think about why your program may need input and output streams.  What you write to the output stream, and what to write to the error stream.  We will first deal with the second question: what is the difference between output streams (stdout) and errors (stderr)?  The fact that one stream goes to the pipe, and the other does not.  The stderr stream is used to output not only errors, but also to output any information about the work process, such as the program execution stage, debug information, etc.  This information should not get to the input of another program, it is needed only for the convenience of the user.  The stdout stream is used for all other information, such as the output of the program. <br><br>  You need to think about the format of the output, because the output of your program will work not only man, but the machine.  It makes sense to make the option <code>--format=&lt;plain|csv|pretty|html|table|...&gt;</code> .  When specifying the human-readable format (pretty / html / table), you can display information in a way that is pleasing to the eye without thinking about the convenience of parsing the output.  When you specify a machine-readable format (plain / csv), it doesn't matter to you at all whether the result looks nice or not - the main thing is that it is easy to parse.  For the convenience of parsing, use tab-delimited values ‚Äã‚Äãor comma-separated values ‚Äã‚Äã(csv), or format one line - one value, or another format that suits you best.  We will talk more about how to make the most pleasant conclusion for a person in Delight Users. <br>  It is not always possible for the user to specify the output format each time the program is launched, and it is not always possible to choose one for all occasions.  Is there a trick that will help you automatically determine if the output is intended for the eyes of a person or a machine, namely the <code>IO#tty?</code> method <code>IO#tty?</code>  .  Call <code>$stdout.tty?</code>  will tell you whether your output is directed to the terminal or not.  If not, then the output of your program is sent to the pipe or redirected to a file (as follows: <code>ls &gt; output.txt</code> ).  For output sent to the terminal, and for output to the redirected stream, you can choose different default formatting <code>options[:format] = $stderr.tty? ? 'table' : 'csv'</code> : <code>options[:format] = $stderr.tty? ? 'table' : 'csv'</code> <code>options[:format] = $stderr.tty? ? 'table' : 'csv'</code> <br>  And if you want, for example, to output to a file the result in an output format intended for a person, just indicate the format explicitly. <br><br>  Now let's talk about the input stream.  What data should the program receive from the input stream?  This, of course, depends on the specifics of the program.  Let's think about what data can come in the input stream?  The obvious answer - those that are on the output of another program.  For example, I have a program that converts a matrix file to another format and writes to a file with a different extension.  Does it make sense to take matrices from the input stream?  In my opinion, it does not have: how and why does this matrix fall into the input stream?  It will be much more convenient to take a bundle of file names in order to immediately process multiple files.  This is the data that the ls command can give, for example. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can argue with this point of view, because you can write a script that will go through the list of files and run the program several times. </font><font style="vertical-align: inherit;">But then you lose the ability to do it directly from the command line with one I / O redirection, you have to write a loop. </font><font style="vertical-align: inherit;">In addition, some programs start and run quickly for a long time, so you can spend not one second, but one hundred one per hundred matrices (alas, this is a very real - and even optimistic - time scale when using multiple script launches from a heme on a Windows system) . </font><font style="vertical-align: inherit;">But, in any case, the choice is yours. </font><font style="vertical-align: inherit;">Do what is appropriate and do not forget to describe it in the manual. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, is another program trying to transfer data to the input of your script by calling the method already familiar to us</font></font><code>$stdin.tty?</code> <br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Signals </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, another way that programs can communicate (without taking into account sockets and everything connected with them) - signals - deserves mention. Suppose you have a long-running process, for example, a web server, and you need to ask it to read the new configuration without rebooting. You can send him a signal (usually SIGHUP), and he, having intercepted him, will do what he is asked for. Or hang up the handler on the SIGINT signal, which will neatly exit the program by pressing Ctrl + C. All this is achieved by the method</font></font><code>Signal.trap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This method takes as arguments the name of the signal and the block that is executed when the specified signal arrives to the program. </font><font style="vertical-align: inherit;">This works (like thread redirection, by the way) on all POSIX systems, i.e. </font><font style="vertical-align: inherit;">both in Unix and in Windows. </font><font style="vertical-align: inherit;">It is possible, however, that the set of supported signals in Windows will be smaller than in Unix, so if you are trying to cross-platform the application, the signals are a place to be thoroughly tested. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is an example of how to make sure that by pressing Ctrl + C, the program first cleaned up the unfinished files, and then closed, returning the error code:</font></font><br><pre> <code class="ruby hljs">Signal.trap(<span class="hljs-string"><span class="hljs-string">"SIGINT"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> FileUtils.rm output_file exit <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Has sensible defaults but is configurable </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, standard usage scenarios should be available without specifying thousands of options. Non-standard scripts do not need to be easy to use, but should still be available. In addition, the default set of options must be customizable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About standard scripts everything is clear. It is necessary to think over what the program will be used for and choose the most popular parameters - by default parameters.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All users have slightly different needs, so think of as many uses of your script as possible. If your application performs one task, but will be flexibly configured (within reasonable limits), users will thank you. Non-standard scripts should be, if they have an application. It doesn't matter if you have to specify many options for their execution - the user will think twice whether your script is intended. Let me remind you of the recommendation to make rare options long and not provide a short version for such options ( </font></font><code>--use-nonstandard-mode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">instead </font></font><code>-u</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will dwell on the last point in more detail. What does ‚Äúthe default option set have to be customizable‚Äù? Imagine that many people use your program and do it often. For example, you wrote a utility for database backup. Your sysadmin uses the utility every day and uses the default set of options (for example, </font></font><code>--no-scheme --gzip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), just typing </font></font><code>db_backup my_db</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But besides the admin, the program is used by your fellow developers, whose database schema changes every day. And they are forced to write every day </font></font><code>db_backup --scheme my_db</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, they cannot forget this key. You may be right, if you say that sisadminskie setting is important and will be the default setting ... but in reality there will be more options and </font></font><code>--login</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--password</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>--host</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>--force</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and such a set of parameters is already difficult to reproduce without errors even by a sysadmin, whose other settings go by default. Do not force the sysadmin or the programmer to enter all these parameters every time and think about the settings, because you can make the default values ‚Äã‚Äãconfigurable. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this are the files of the form </font></font><code>~/.myapp.rc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. There is no magic in the file, it is just an agreement. Each user in his / her home directory can create a file with his default settings. In the home directory - so that different users can set different defaults. The dot at the beginning of the file is to make it hidden. The .rc extension is a tribute to tradition.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What should be stored in this file? </font><font style="vertical-align: inherit;">Just a list of those options that differ from standard defaults. </font><font style="vertical-align: inherit;">For this configuration file is extremely convenient to use the format YAML. </font><font style="vertical-align: inherit;">I will give an example:</font></font><br><pre> <code class="hljs ruby">--- <span class="hljs-symbol"><span class="hljs-symbol">:gzip</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:force</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:user</span></span>: <span class="hljs-string"><span class="hljs-string">"Bob"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:password</span></span>: <span class="hljs-string"><span class="hljs-string">"Secr3t!"</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider how these options load. </font></font><br><pre> <code class="ruby hljs"><span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'yaml'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'optparse'</span></span> <span class="hljs-comment"><span class="hljs-comment">#  - options = { :gzip =&gt; true, :force =&gt; false } #     # (     ,    HOME) CONFIG_FILE = File.join(ENV['HOME'],'.db_backup.rc.yaml') if File.exists? CONFIG_FILE #     config_options = YAML.load_file(CONFIG_FILE) #     -     options.merge!(config_options) end #       #       ,    option_parser = OptionParser.new do |opts| #    . #__FILE__    ,        opts.banner = "Usage: #{__FILE__} [options] &lt;db_name&gt;" #   -u  --username   ,     opts.on("-u USER", "--username", "Database username, in first.last format") do |user| options[:user] = user end #     ,      opts.on("-p PASSWORD", "--password", "Database password") do |password| options[:password] = password end #     ,     .   ,   . #   --gzip      true. #      ,     - #     false     --no-gzip opts.on("--[no-]gzip", "Compress or not the backup file") do |gzip| options[:gzip] = gzip end end #       ,    option_parser. #    ARGV    , #        options # (     ) option_parser.parse!(ARGV) #    db_name = ARGV.shift</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are faced with the task of setting up a software package, this is done with the same configuration file. </font><font style="vertical-align: inherit;">Only in the hash this time there should be both global options and the options of each command - in the nested hash.</font></font><br><pre> <code class="hljs 1c">--- :filename: <span class="hljs-symbol"><span class="hljs-symbol">~/.todo.txt </span></span>:url: http:<span class="hljs-comment"><span class="hljs-comment">//jira.example.com :username: davec :password: S3cr3tP@ss :commands: :new: :f: true :group: Analytics Database :list: :format: pretty :done: {}</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are other ways to write data to a configuration file, YAML is just one of the most readable. </font><font style="vertical-align: inherit;">Anyway, configuration via configuration files is a widely used technique. </font><font style="vertical-align: inherit;">For example, gem and rspec utilities, as well as git, are configured this way.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Installs painlessly </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even a very good application no one will use if the installation process is too complicated. Fortunately, in the world of Ruby there is rubygems - a package manager that allows you to install and update programs in one line: A </font></font><br> <code>gem install/update gemname</code> <br> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gem is a package that contains source codes, as well as information about the version number and the author, package description, and a set of dependencies (which versions of which gems are used by your library or your application). By default, all gems are published on the server </font></font><a href="https://rubygems.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rubygems.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Thanks to this, when installing gems, you don‚Äôt need to look for where to download the package, it‚Äôs on a server common to everyone (of course, you can separately configure the corporate gems server so as not to give your gems to other hands) and the gem program automatically uses it to pump gems. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you execute a command</font></font><code>gem install</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the package manager searches the rubygems server for a package with the specified name and finds out what other gems (and which specific versions) it needs for work. Then it downloads all the necessary packages and installs them, compiles the native code, makes it possible to run the files listed as executable (it can be Ruby scripts, not just binaries). In the system, one gem can stand in any number of versions, each version can have its own set of dependency versions and not cause conflicts. For example, if you have rails 2.3.8 and rails 3.2, each of them will refer to its version of activesupport, the one with which it is agreed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About how to create gems, I will not write, this was already a </font><a href="http://habrahabr.ru/post/138582/"><font style="vertical-align: inherit;">great article</font></a><font style="vertical-align: inherit;"> on Habr√©</font></font><a href="http://habrahabr.ru/post/138582/"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if you still do not know how to do it - right now, break away from my article and take half an hour of your time to this question. It is very simple, very convenient and vital if you are going to engage in ruby ‚Äã‚Äãand further. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you create your gem, you have to specify the version number. There is a very consistent agreement called "semantic versioning." The version format consists of three numbers: Major.Minor.Patch. The lower number - patch-level is responsible only for bugfixes. The average number changes with API changes that are backward compatible. And the older number changes as you make changes that degrade backward compatibility. Notice, not a number, but a number, so the version number can easily be like this: 1.13.2.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semantic versioning is useful because you can specify in the dependencies not the exact version of the heme, but the version with the accuracy of the patch level or the minor version. This way you get the opportunity, without doing anything with your own package, to get fixes that fix bugs in dependency packages. But at the same time, you have the ability to prevent dependency versions from changing too much, so as not to get API changes incompatible with your package with the next update.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now - a couple of words about executable files. All files that you placed in the bin folder of your gem are considered executable (if you use the bundler in the default configuration to create a gem). When you install the package in the folder ... / ruby ‚Äã‚Äã/ bin, something like links to these files is created (in fact, a special Ruby script is created that knows where to find the executable file). The trick is that when installing ruby, this folder falls into the PATH environment variable - and thus becomes one of the places where executable files are searched. Thus, all executable files from the heme become available from anywhere in the system. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under Windows, the process, as I understand it, is a bit more complicated - around this file, a bat wrapper is also created, which transfers control to the script itself. However, from the programmer and from the user all these details are hidden.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What should be in the executable file? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, although it is a Ruby script, it does not need to specify the .rb extension. Neither on Unix, nor on Windows. This will only knock down the user, and for the successful launch of the script it is completely optional. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, in the first line it should be written: </font></font><code>#!/usr/bin/env ruby</code> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pay attention to the fact that there is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no</font></font></b> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> path in this line </font></font><code>/usr/bin/ruby</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Using </font></font><code>env</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it allows detecting ruby, even if it is located in another folder, which is simply necessary when rvm is installed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thirdly, it is better to put the entire script logic into a separate file, for example lib / my_exec.rb, and get it from the executable file using require. You can read more about this in the article on the manufacture of gems, which I mentioned above. As a result, the executable file looks like this:</font></font><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env ruby require 'rubygems' #    ruby 1.9   require 'your-gem' require 'your-gem/my_exec'</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What troubles are waiting for you if you decide not to collect your gem package? Well, apart from the obvious extra headache of dependency control, you will have another unpleasant surprise. Imagine that you wrote a script and write in the command line </font></font><code>my_app value1 value2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. What list of arguments do you expect? Probably </font></font><code>['value1', 'value2']</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. What do you really have? In Unix, everything will be as you expect. And running the script in Windows, you have an empty list of arguments, since </font></font><code>my_app</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is not perceived in Windows as a program that can receive arguments (instead, the ruby.exe program usually receives the arguments). In order to pass arguments to the script, it is necessary to run the script, assigning the word ruby ‚Äã‚Äãat the beginning.</font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each program launch will look like this: </font></font><code>ruby my_app value1 value2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and if you forget the word ruby, then you have a chance not even to understand why nothing works.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember, I mentioned that rubygems creates a bat-wrapper? This is necessary because the bat-file understands the command line arguments and can pass them to the script by calling the script appropriately. Thus rubygems solves this problem. But there is a fly in the ointment: such a cascade of calls slows down the start of the application. Sometimes the Hello World program runs for five seconds. After the application is started, everything works at normal speed, but the process of launching applications is unpleasantly long (as far as I understand, Windows processes are generally more heavyweight than Unix processes). This can be annoying when you run, for example, rspec after each code change. Or, every five minutes, spend five seconds waiting for the git reaction (which also suffers from this problem, although it is not written in ruby). But this is the pricewhich have to pay for the compatibility of programs with Windows, in a different way - no way.</font></font><br><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Fails gracefully </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It's all very simple. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your script has dropped. </font><font style="vertical-align: inherit;">Print an error message to stderr, suggest possible solutions (for example, tell me which argument is missing or which options conflict). </font><font style="vertical-align: inherit;">If necessary, print a help line describing the usage. </font><font style="vertical-align: inherit;">And certainly the program should not try to perform any actions if there are not enough arguments to perform them. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Does your script write something to the files or, maybe, erase the files? </font><font style="vertical-align: inherit;">If so, make sure that it does not overwrite existing files. </font><font style="vertical-align: inherit;">If the file exists, the script should say this and ask for confirmation of the file modification, or suggest using the key </font></font><code>--force</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Well, let the program display a message about which file it has overwritten or deleted.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The user specified strange options? </font><font style="vertical-align: inherit;">Ask him to confirm that he meant exactly that. </font><font style="vertical-align: inherit;">Imagine a command. </font></font><code>rm -rf * .log</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This random space will cost you a lot, so ask the user if there are suspicions that the program may behave too destructively.</font></font><br><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gets new features and bug fixes easily </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code support is too broad a concept to fully describe it. In a nutshell, make the application modular, split it into separate files. If necessary, break into several separate gems. In order to eliminate bugs and prevent new ones, it is necessary to write tests. And here there may be problems ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The fact is that testing usually involves the isolation of tests, and when working with the file system (which is often the purpose of the utilities), this is not easy. You may need to create, delete and overwrite files, as well as restore the state of the file system after each test. All this can be extremely unpleasant and a long matter (working with HDD is not a quick deal at all). There are at least two solutions to the problem. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first solution is </font><a href="https://github.com/cucumber/aruba"><font style="vertical-align: inherit;">aruba</font></a><font style="vertical-align: inherit;"> gem </font></font><a href="https://github.com/cucumber/aruba"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that provides specific Cucumber scripts for CLI testing. Scripts for filling files with content, for cleaning, for checking the existence of a file, as well as scripts for launching an application with certain arguments, checking the return code, the contents of input / output streams, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second solution (which I personally like much more) is the usual TestUnit or rspec tests with the </font></font><a href="https://github.com/defunkt/fakefs"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fakefs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heme </font><font style="vertical-align: inherit;">. This hem replaces the classes that work with the file system, and create a virtual file system in RAM - with its folder structure, its files with the content that you wish to put there. No mock-ups need to be created, the whole class </font></font><code>File</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font><code>Dir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(and those involved) turn into one big fake for a while, so the program code doesn't need to be changed at all to test the behavior. There are no traces in the file system after work.</font></font> Beauty!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We enable the fake file system mode, load (do not start the application using </font></font><code>Kernel.system</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, namely, load) the script from our lib / my_exec file and check the results. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How, without using aruba, to check that the program displays? To do this, you need to replace the stdout and stderr streams with objects of the class </font></font><code>StringIO</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Then after the work of the program it will be possible to check the contents of these ‚Äústreams‚Äù. You can use a ready-made solution: </font></font><code>out, err = MiniTest::Assertions.capture_io{ ... }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the standard testing library, or you can try to write code to intercept the contents of streams, it is not complicated at all. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important note! Ruby has two variables for I / O streams: a constant </font></font><code>STDOUT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and a global variable.</font></font><code>$stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. When you will substitute streams using StringIO, use a global variable, do not try to change the constant. It is not that scary that you will see a warning, but that it will not give the expected effect. Probably, commands of the type </font></font><code>puts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by default are tied to a global variable, and the constant only refers to it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, this remark does not apply to cases of explicitly specifying a stream ( </font></font><code>STDOUT.puts 'smth'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and this, by the way, is the reason not to use constants at all </font></font><code>STDOUT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>STDIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>STDERR</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is one more thing. We want the testing code to be as close to reality as possible. The script gets these variables as an array.</font></font><code>ARGV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. And we pass the arguments to the application in a string, not an array, right? We are faced with the question: how to get an array from an argument string. Recall the shellwords library mentioned above and break the string into elements using the method </font></font><code>String#shellsplit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we have an array of command line arguments, we can, for example, replace the contents of </font></font><code>ARGV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this array: </font></font><code>ARGV.replace(new_array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But it would be better to replace the array passed to the method.</font></font><code>OptionParser#parse!</code>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead, </font></font><code>ARGV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is enough to transfer our new array </font></font><code>OptionParser#parse!(new_array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and it will extract the options from it, and not from </font></font><code>ARGV</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Do not forget that it will be necessary to select positional arguments also from the new array - after isolating the options. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A separate question is how to test correct work with configuration files. </font><font style="vertical-align: inherit;">The author advises to make it possible to override the settings of these files through environment variables. </font><font style="vertical-align: inherit;">I personally find it inelegant and leave a curious reader the opportunity to get into the book and independently see the recommendations related to it.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Delights users </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A few comments about the beautiful in the format of the output. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tables </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose that your utility displays a list of the most popular bloggers: name, number of posts, comments, friends. </font><font style="vertical-align: inherit;">The obvious output format suggests itself: draw a label. </font><font style="vertical-align: inherit;">The solution is just as straightforward - use the </font></font><a href="https://github.com/visionmedia/terminal-table"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminal-table gem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h5>  Colors </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You will find another kind of prettiness if you use one of the utilities to compare files. </font><font style="vertical-align: inherit;">You will see lines with plus and minus lines for added and deleted lines. </font><font style="vertical-align: inherit;">But in addition, these lines for convenience are painted in different colors: red / green. </font><font style="vertical-align: inherit;">Coloring the colors in the console is done by adding special escape sequences at the places where the color changes. </font><font style="vertical-align: inherit;">Two popular solutions are </font></font><a href="https://github.com/sickill/rainbow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rainbow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://github.com/flori/term-ansicolor"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">term-ansicolor gems.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. They are also used very straightforward, read their manuals. It should be noted that - alas - not all terminals normally support working with colors. The standard Windows terminal for some programs instead of colored lines gives numbers encoding these colors, while for others it works correctly. So check the work of gems in different terminals before you start using them in the code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">David Copeland recalls that almost 10% of people are color blind. </font><font style="vertical-align: inherit;">From this it follows that the color should only help to navigate the output of the program, and not to assume the function of a single data transmission channel. </font><font style="vertical-align: inherit;">If the diff utility removes pluses and minus ones, then a significant part of people will lose the opportunity to use the results of the work. </font><font style="vertical-align: inherit;">Therefore, in the colored output should be colors, and other data, having that, the colors are no longer necessary. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Important note! </font><font style="vertical-align: inherit;">When your utility returns text in machine-readable format - it is desirable that color formatting be turned off. </font><font style="vertical-align: inherit;">Otherwise, the party accepting the input data has a chance to earn ‚Äúindigestion‚Äù from special characters in the string.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interactive communication with the user </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another library is designed to provide interactivity. Readline, which I mentioned. So, at your service: remembering the history of user answers and autocompletion. Also in rubygems and thor there are special modules responsible for user interaction and providing methods such as say and ask. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What type of interactive applications are there? Remember irb and rails console. The author of the book gave another example: suppose you come to a large JSON object and you want to explore what it is. To do this, you can write an interactive JSON viewer that allows you to browse the hierarchy with the commands cd, ls, and also change it with the commands rm and mknode. An example is given solely to awaken your imagination. You can come up with hundreds more uses for interactive applications.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Take care of the user's nerves </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine yourself in the place of a user who is pumping a large file through a mobile connection and does not know how much has already been downloaded. </font><font style="vertical-align: inherit;">The first ten minutes the user waits, knowing that the file is large. </font><font style="vertical-align: inherit;">And then begins to bite your elbows: what if there is no connection? </font><font style="vertical-align: inherit;">But can the program hang? </font><font style="vertical-align: inherit;">maybe the file is so large that at the end of the month the user will be turned off the mobile phone once and for all? </font><font style="vertical-align: inherit;">If the program can work for a long time, it would not hurt to display the status bar in stderr or in the log file (and do not forget that file operations are buffered, so do it from time to time </font></font><code>flush</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, otherwise you have a chance to see the results in the log file only after the program has completed).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would be ridiculous to count every percentage of loading on a new line! </font><font style="vertical-align: inherit;">Instead, let's rewrite one line, changing numbers each time. </font><font style="vertical-align: inherit;">The special symbol </font></font><code>\r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- carriage return </font><font style="vertical-align: inherit;">will help us with this </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When a line is encountered </font></font><code>\r</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the terminal cursor seems to shift to the beginning of the line and starts typing characters over the old ones (carefully, the ‚Äútail‚Äù of the old line is not automatically overwritten). </font><font style="vertical-align: inherit;">But be careful, the method </font></font><code>puts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not suit us, because </font><font style="vertical-align: inherit;">it automatically translates the cursor to a new line. </font><font style="vertical-align: inherit;">We need a method </font></font><code>print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and here is an example of its use:</font></font><br><pre> <code class="ruby hljs">(<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>).each <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-params"><span class="hljs-params">|i|</span></span> $stderr.print(<span class="hljs-string"><span class="hljs-string">"\r</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">#{i}</span></span></span><span class="hljs-string">% done"</span></span>) sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is worth a bit of caution, though: in the terminal window, the stderr and stdout streams are mixed, so you can start overwriting the wrong data. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In conclusion, I can not tell you about several popular libraries. </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have worked a little with Ruby projects, you probably already met the </font></font><a href="https://github.com/jimweirich/rake"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rake</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> team </font><font style="vertical-align: inherit;">, and maybe the </font></font><a href="https://github.com/wycats/thor"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> team </font><font style="vertical-align: inherit;">. These are specialized libraries that allow using a special DSL to describe a set of utilities as a set of automation tasks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rake is an improved analogue of the make program for ruby. He looks in the Rakefile of the current or parent directory and searches for a description of the task there. For example, the bundler creates for each new Rakefile gem with a set of tasks: build, install, release, which allows you to install and publish your own gems with one command. One of the distinctive features of rake is a system of dependencies between tasks - so rake release will first execute the build task and only then release. Unfortunately, it is either impossible or non-trivial to pass arguments to rake. On Habr√©, by the way, there was already an </font></font><a href="http://habrahabr.ru/post/111331/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introductory post</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about rake. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thor is a rake-like system. It also allows you to "install" tasks in the system. More is better to look at </font></font><a href="http://rubydev.ru/2012/06/thor-ruby-scripting-framework/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other sources</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I mention these libraries because they can make life easier for you if you don‚Äôt need any complicated handling of options and arguments. Simple software packages are fully described in terms of these two well-known libraries. In particular, in Ruby on Rails, they are both used for tasks such as running generators, migrations, clearing the application cache, and so on.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I used most of the narration to parse OptionParser options from the standard ruby ‚Äã‚Äãlibrary. This is a very convenient library, but some consider it rather heavy and write wrappers. Some wrappers concentrate on simplifying the setting of options, some on making the hash of options available globally, and so on. If it seems to you that OptionParser is slowing you down, you can pick up one of the ready-made wrappers (the list can be found on the book‚Äôs website - see the beginning of the article) or make your own.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OptionParser has other drawbacks: it is not able to distinguish global from local options in the software package (we did this separation ourselves; in general, it is not followed from anywhere except by successfully applying the concept in some large projects, such as git). Another OptionParser feature (this is not spelled out in the specification and I suppose that this is a bug) is that it understands the negative numbers in the arguments as options. I believe that sooner or later this bug will be fixed, but if your program accepts numeric arguments, be careful and carefully test the program. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For building software packages, the author of the book, David Copeland, made quite a good </font></font><a href="https://github.com/davetron5000/gli"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gem </font><font style="vertical-align: inherit;">. It distinguishes between global options, command options, and recognizes the command itself. The project is live and periodically receives updates.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, I can not fail to mention a rather crude, but extremely curious project - </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">docopt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This is a library that generates an options parser on the hint line, whereas OptionParser and related libraries do the opposite. </font><font style="vertical-align: inherit;">This library was originally written in python and ported to a fairly large number of languages. </font><font style="vertical-align: inherit;">About her features can be read </font></font><a href="http://docopt.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">I think with the proper attention of the community, it can turn into an extremely convenient and powerful library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS In addition to the one I described in the article, rubistu, who works with command line applications, it makes sense to read about a special variable </font></font><code>ARGF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If all the arguments of your script are file names, then </font></font><code>ARGF</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simply concatenate the contents of all files.</font></font></div><p>Source: <a href="https://habr.com/ru/post/150950/">https://habr.com/ru/post/150950/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150942/index.html">Notes on MODX Revo from newbie</a></li>
<li><a href="../150943/index.html">Where should Delphi develop instead of where it is developing now?</a></li>
<li><a href="../150944/index.html">Neutrino - a tiny js framework with full inheritance and events</a></li>
<li><a href="../150946/index.html">Add Bundling and Minification to ASP.NET Web Pages</a></li>
<li><a href="../150947/index.html">Nokia Lumia 920 and 820 with wireless charging and Windows Phone 8</a></li>
<li><a href="../150951/index.html">How to get your web screenshots service - version 1.1</a></li>
<li><a href="../150954/index.html">Combing "Similar posts"</a></li>
<li><a href="../150955/index.html">Kinect for Windows SDK. Part 1. Sensor</a></li>
<li><a href="../150957/index.html">There was a native ŒºTorrent client for Android</a></li>
<li><a href="../150958/index.html">Nostalgia: how ‚Äúsaving on paper‚Äù works</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>