<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hash strings at compile time with annotation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I began to develop an application for Android and I faced the task of protecting it from reverse. A quick look at Google suggested that ProG...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hash strings at compile time with annotation</h1><div class="post__text post__text-html js-mediator-article">  Recently, I began to develop an application for Android and I faced the task of protecting it from reverse.  A quick look at Google suggested that ProGuard, part of Android Studio, will cope with the task.  The result really suited me except for one small detail - the line. <br>  The program communicates with the service information using the Intent.  The key part of which is the action string.  And if a line must have a certain format for interaction with the system or other applications, then its uniqueness is sufficient for exchanges within the application.  For convenience, it is recommended to compile this string from the package name and the action name.  For example: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerConst</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ACTION_LOGIN = <span class="hljs-string"><span class="hljs-string">"com.example.app.ACTION_LOGIN"</span></span>; }</code> </pre> <br>  This is convenient for debugging, but it greatly reduces the quality of code obfuscation.  I would like to see, for example, in the release of the program, instead of this line, its MD5 hash. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerConst</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ACTION_LOGIN = <span class="hljs-string"><span class="hljs-string">"7f315954193d1fd99b017081ef8acdc3"</span></span>; }</code> </pre><br>  Under the cut it is told how to achieve this behavior with the help of an improvised bicycle. <br><a name="habracut"></a><br><h5>  Some lyrics </h5><br>  I was very surprised to learn that ProGuard does not work with strings.  From the documentation on the official website, it was possible to find out that the advanced paid version can work with strings.  That's just it encrypts strings in order to decrypt them into the original version while the program is running.  I could not find a solution to turn the string into its MD5 value. <br>  Attempts to find a solution to this problem led me to an article demonstrating the wonders of optimizing C ++ compilers: <a href="http://habrahabr.ru/post/143975/">Computing CRC32 strings in compile-time</a> .  But in Java, a similar method did not take off.  ProGuard turned the methods down hard enough, but stumbled upon getting an array of bytes from a string. <br>  After that, I decided not to waste effort on trying to automate and just solve the problem with my hands: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerConst</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ACTION_LOGIN; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (BuildConfig.DEBUG) ACTION_LOGIN = <span class="hljs-string"><span class="hljs-string">"com.example.app.ACTION_LOGIN"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ACTION_LOGIN = <span class="hljs-string"><span class="hljs-string">"7f315954193d1fd99b017081ef8acdc3"</span></span>; } }</code> </pre><br>  But when I saw the <a href="http://habrahabr.ru/post/200354/">Custom Annotation Preprocessor</a> article on Habr√© <a href="http://habrahabr.ru/post/200354/">- the creation of an Android application and configuration in IntelliJ IDEA</a> , I realized that this is the solution to my problem. <br><br><h5>  Annotation implementation </h5><br>  The study of annotations by tradition began with the lack of necessary information in Russian.  Most articles cover runtime annotations.  However, a suitable article was found in Habr√©: <a href="http://habrahabr.ru/post/88908/">Calculation of the execution time of the method through the annotation</a> . <br>  To create a compile-time annotation we need: <br><ol><li>  Describe the annotation; </li><li>  Implement the heir of the <i>AbstractProcessor</i> class, which will process our annotation; </li><li>  Tell the compiler where to look for our processor. </li></ol><br><br>  An annotation description might look like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.annotation; <span class="hljs-meta"><span class="hljs-meta">@Target</span></span>({ElementType.FIELD}) <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RetentionPolicy.SOURCE) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> Hashed { <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> "MD5"</span></span>; }</code> </pre><br>  <b>Target</b> - defines objects for which annotation is applicable.  In this case, the annotation can be applied to variable declarations in the class.  Unfortunately, to anyone, but more on that later. <br>  <b>Retention</b> - annotation lifetime.  We indicate that it exists only in the source code. <br>  In the annotation itself, we start a field defining the method of hashing.  The default is MD5. <br>  This is enough to use annotation in the code, but there is no point in it until we write an annotation processor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An annotation handler is inherited from <i>javax.annotation.processing.AbstractProcessor</i> .  The minimum class of the handler looks like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> com.example.annotation; <span class="hljs-meta"><span class="hljs-meta">@SupportedAnnotationTypes</span></span>(value = {<span class="hljs-string"><span class="hljs-string">"com.example.annotation.Hashed"</span></span>}) <span class="hljs-meta"><span class="hljs-meta">@SupportedSourceVersion</span></span>(SourceVersion.RELEASE_7) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashedAnnotationProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } }</code> </pre><br>  <b>SupportedAnnotationTypes</b> - defines the names of annotation classes that will be processed by our processor. <br>  <b>SupportedSourceVersion</b> - supported source version.  The point is that the processor does not break when processing annotations language constructs that appeared in newer versions of the language. <br>  Instead of annotation data, you can override the <i>getSupportedAnnotationTypes</i> and <i>getSupportedSourceVersion methods</i> . <br>  The <i>process</i> method gets a list of the raw supported annotations and a compiler interaction object.  If the method returns false, the compiler passes the annotation for processing to the next processor that supports this type of annotation.  If the method returns true, the annotation is considered processed and will not get anywhere else.  This should be taken into account in order not to accidentally nail other people's annotations. <br>  If during the operation of any processor the source codes have changed or been added, the compiler will go to the next pass. <br><br>  To change the source code <i>RoundEnvironment</i> will not be enough for <i>us,</i> so we override the <i>init</i> method and get <i>JavacProcessEnvironment</i> from it.  This class allows you to access source codes, a system for throwing warnings and compilation errors, and more.  In the same place we will receive <i>TreeMaker</i> - the auxiliary tool for change of source codes. <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> JavacProcessingEnvironment javacProcessingEnv; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TreeMaker maker; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.init(procEnv); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.javacProcessingEnv = (JavacProcessingEnvironment) procEnv; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.maker = TreeMaker.instance(javacProcessingEnv.getContext()); }</code> </pre><br><br>  Now it remains for us to go through our annotated fields and replace the values ‚Äã‚Äãof string constants.  I bring the code in abbreviation.  Link to GitHub at the end of the article. <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( annotations == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || annotations.isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (TypeElement annotation : annotations) { <span class="hljs-comment"><span class="hljs-comment">//   ,      final Set&lt;? extends Element&gt; fields = roundEnv.getElementsAnnotatedWith(annotation); JavacElements utils = javacProcessingEnv.getElementUtils(); for (final Element field : fields) { // ,      . Hashed hashed = field.getAnnotation(Hashed.class); //     JCTree blockNode = utils.getTree(field); if (blockNode instanceof JCTree.JCVariableDecl) { //,       . JCTree.JCVariableDecl var = (JCTree.JCVariableDecl) blockNode; //  (    = ) JCTree.JCExpression initializer = var.getInitializer(); //      ,     : // "" + 1 // new String("new string") if ((initializer != null) &amp;&amp; (initializer instanceof JCTree.JCLiteral)){ JCTree.JCLiteral lit = (JCTree.JCLiteral) initializer; //  String value = lit.getValue().toString(); try { MessageDigest md = MessageDigest.getInstance(hashed.method()); //      . md.update(value.getBytes("UTF-8")); byte[] hash = md.digest(); StringBuilder str = new StringBuilder(hash.length * 2); for (byte val : hash) { str.append(String.format("%02X", val &amp; 0xFF)); } value = str.toString(); lit = maker.Literal(value); var.init = lit; } catch (NoSuchAlgorithmException e) { // :    } catch (UnsupportedEncodingException e) { // :   ?? } }else{ // :   . } } } } }</span></span></code> </pre><br>  In the method we run according to the list of annotations (do we remember that in general the processor processes more than one annotation?), For each annotation we select the list of elements.  After this magic begins.  We use the tools from the delivery <i>com.sun.tools.javac</i> to convert the elements into a tree of source code, which has a huge number of possibilities and traditionally a complete lack of Russian-language documentation.  Therefore, I ask you not to be surprised that the code for working with this tree is far from ideal. <br>  When we received the declaration of a variable in the form of a tree <i>JCTree.JCVariableDecl var</i> - we can make sure that it is a string variable.  In my case, this test is carried out with a crutch: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-string"><span class="hljs-string">"String"</span></span>.equals(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>.vartype.toString())){ <span class="hljs-comment"><span class="hljs-comment">// :     . continue; }</span></span></code> </pre><br>  vartype is a field type that can certainly be compared with any constant or determine its membership in a particular class, but, as I said, there is no documentation, and a quick check showed that casting to a string gives us the name of the type. <br><br>  The second interesting point is that we can process only lines similar to the example from the very beginning of the article.  The thing is that at this stage we are working with the source text.  Therefore, if the variable is initialized in the constructor, then <i>JCTree.JCExpression initializer = var.getInitializer ();</i>  will return us <i>null</i> .  Not less unpleasant situation will turn out if we try to process constructions of the form: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String demo1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> String(<span class="hljs-string"><span class="hljs-string">"habrahabr"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String demo2 = <span class="hljs-string"><span class="hljs-string">"habra"</span></span>+<span class="hljs-string"><span class="hljs-string">"habr"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> String demo3 = <span class="hljs-string"><span class="hljs-string">""</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  For this, a second check is introduced <i>(initializer instanceof JCTree.JCLiteral)</i> .  This cuts out all the examples described, since they are not literals in their pure form and will be represented in the tree by an expression of several elements. <br>  Further code is obvious.  Take a string, hash, replace, rejoice?  Not. <br>  Comments noted several places in which there are obvious errors.  And in our case, ignoring them is not the correct behavior.  In order to inform the user about the error, we need a <i>javax.annotation.processing.Messager</i> object.  It allows you to throw out a warning, compilation error, or just an informational message.  For example, we can report an invalid hash algorithm: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (NoSuchAlgorithmException e) { javacProcessingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, String.format(<span class="hljs-string"><span class="hljs-string">"Unsupported digest method %s"</span></span>, hashed.method()), field); }</code> </pre><br>  It should be understood that the release of an error message does not interrupt the execution of the method.  The compiler will wait for at least the end of our method before interrupting the compilation process.  This allows you to immediately throw away all errors in the application of annotations to the user.  The third argument of the <i>printMessage</i> method allows us to specify the object on which we stumbled.  It is not mandatory, but makes life much easier. <br><br><h5>  Connecting Annotation Processor </h5><br>  It remains to inform the compiler that we are and are ready to accept annotations to be torn apart.  Many articles contain instructions on how to add your processor to &lt;development environment name&gt;.  Apparently this is rooted in the distant times, when such things were done on the knees of folk craftsmen.  However, the annotation processing engine has been part of javac for quite some time and, in fact, our class processor is a plugin for javac.  This means that by standard means we can connect our annotation to any environment without shamanism with settings. <br>  We will need to create a <b>services</b> subdirectory in the <b>META-INF</b> directory, and in it the <b>javax.annotation.processing.Processor</b> file.  In the file itself, we need to put a list of our processor classes.  In the specific case of <b>com.example.annotation.HashedAnnotationProcessor</b> .  And that's all.  Now we compile our library containing the annotation and its processor.  We connect this library to the project.  And it works. <br>  At the same time, neither the library itself, nor the remnants of annotations will fall into the compiled code. <br><br><h5>  Using </h5><br>  Abstract is ready.  Strings are hashed.  But the problem is still not solved. <br>  If we connect the annotation to the project in this form, we will always hash the lines.  And we only need to release. <br>  In Java, the concept of debug and release builds is very conditional and depends on the user's views.  Therefore, we ensure that the <b>assembleDebug</b> task for the Android project does not hash lines, and in all other cases MD5 hashes remain from the lines. <br>  To solve this problem, we will pass an additional parameter to our annotation processor. <br>  First, we will refine the processor: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@SupportedOptions</span></span>({<span class="hljs-string"><span class="hljs-string">"Hashed"</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HashedAnnotationProcessor</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractProcessor</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> enable = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ProcessingEnvironment procEnv)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  java.util.Map&lt;java.lang.String,java.lang.String&gt; opt = javacProcessingEnv.getOptions(); if (opt.containsKey(ENABLE_OPTIONS_NAME) &amp;&amp; opt.get(ENABLE_OPTIONS_NAME).equals("disable")){ enable = false; } } @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) { if (!enable){ javacProcessingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, "Annotation Hashed is disable"); return false; } //... } }</span></span></code> </pre><br>  We announced that we are waiting for the ‚ÄúHashed‚Äù option and if it is ‚Äúdisable‚Äù, then we do nothing and output the information to the user.  Messages such as Diagnostic.Kind.NOTE are informational and with the default settings many development environments will not show these messages at all. <br>  At the same time, we inform the compiler that we did not process the annotation.  If there are more processors in the system that process annotations of this type, or do not understand the type at all, they can receive our annotation.  True, I can say absolutely nothing about the order in which the compiler will try to manage the annotation.  So far we have only our library and exactly one annotation - this is not relevant, but when using several libraries of annotations be prepared for the emergence of pitfalls. <br>  It remains to pass this option to the compiler.  Options for processors are passed to the compiler with the "-A" key.  In our case, "-AHashed = disable". <br>  It remains only to set Gradle to pass this option at the right moment.  And again crutches: <br><pre> <code class="java hljs">tasks.withType(JavaCompile) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == <span class="hljs-string"><span class="hljs-string">"compileDebug"</span></span>){ options.compilerArgs &lt;&lt; <span class="hljs-string"><span class="hljs-string">"-AHashed=disable"</span></span> } }</code> </pre><br>  This is for the current version of Android Studio.  For earlier tasks.withType (Compile). <br>  A crutch, because this block is called for each type of assembly, regardless of the task.  In theory, there should be something similar to buildTypes from the android block, but I no longer had the strength to look for a beautiful solution.  All have already guessed that the documentation in Russian is traditionally not? <br>  In code, annotations might look like this: <br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Hashed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String demo1 = <span class="hljs-string"><span class="hljs-string">"habr"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Hashed</span></span> (method=<span class="hljs-string"><span class="hljs-string">"SHA-1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String demo2 = <span class="hljs-string"><span class="hljs-string">"habrahabr"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Hashed</span></span>(method=<span class="hljs-string"><span class="hljs-string">"SHA-256"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String demo3 = <span class="hljs-string"><span class="hljs-string">"habracadabra"</span></span>;</code> </pre><br>  The method can be any of the supported <b>MessageDigest</b> . <br><br><h5>  Total </h5><br>  Problem solved.  Of course, only for one very specific way of declaring constants, of course, not the most effective way, and for many, the very formulation of the problem will raise more questions than the material of the article.  And I just hope that someone will spend less time and nerves if they meet a similar task on their way. <br>  But even more, I hope that someone will be interested in this topic and Habr will see articles in which it will be told why all this magic works. <br>  And, of course, the promised code: <a href="https://github.com/MadHacker666/DemoAnnotation">GitHub :: DemoAnnotation</a> </div><p>Source: <a href="https://habr.com/ru/post/200878/">https://habr.com/ru/post/200878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200866/index.html">Advanced chat on Node.JS</a></li>
<li><a href="../200868/index.html">SRVCC technology in 4th generation mobile networks</a></li>
<li><a href="../200870/index.html">RabbitMQ tutorial 3 - Publish / Subscribe</a></li>
<li><a href="../200872/index.html">Integration of LMS Moodle and Microsoft Active Directory. Part 1</a></li>
<li><a href="../200874/index.html">Immersive Mode (dive mode) in Android 4.4 KitKat</a></li>
<li><a href="../200880/index.html">Multiplayer Games: Inside Look</a></li>
<li><a href="../200882/index.html">Six rules for effective management of promotion and "lead generation" using social media</a></li>
<li><a href="../200884/index.html">There is nothing wrong with types in C #</a></li>
<li><a href="../200886/index.html">Install and configure XBMC on Raspberry Pi</a></li>
<li><a href="../200888/index.html">About informational freedom</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>