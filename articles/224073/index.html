<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js: Overview of General Library Development Technologies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I want to summarize and share the experience gained in developing the node-queue-lib library. I will talk about the technologies that hel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js: Overview of General Library Development Technologies</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e7a/b04/244/e7ab042443cbea28640c9ba2651d61ed.png" alt="node.js" align="left"><br>  In this post I want to summarize and share the experience gained in developing the <a href="https://github.com/AndyGrom/node-queue-lib">node-queue-lib</a> library.  I will talk about the technologies that helped me bring the matter to the final end - workable code that is already running on one of my services.  A feature of this library is a cross-platform client, i.e.  client running in node.js and browser and based on the same code.  The post will describe the following tools, without which the development of this library would turn into hell: <br><ul><li>  Testing ( <a href="https://github.com/mhevery/jasmine-node">jasmine_node</a> ) </li><li>  Code Coverage Tests ( <a href="https://github.com/gotwarlost/istanbul">Istanbul</a> ) </li><li>  Build client part of the library ( <a href="https://github.com/substack/node-browserify">browserify</a> ) </li><li>  Automated client testing ( <a href="https://github.com/ariya/phantomjs">phantomjs</a> ) </li><li>  Memory leak <a href="https://github.com/lloyd/node-memwatch">detection</a> ( <a href="https://github.com/lloyd/node-memwatch">memwatch</a> ) </li></ul><br>  If you haven‚Äôt heard anything about it yet and you want to write a finished product that you will be sure of, this review article will help you get acquainted with one of the options of the toolkit for the full quality control of the javascript library code. <br><br>  And additionally, I will repeat that the article is an overview, and does not set a goal to teach you to use all the listed tools masterly.  I will only show the door, but you will open it yourself ... <br><a name="habracut"></a><br><h2>  Retreat </h2><br>  All examples will contain code for the <a href="https://github.com/gruntjs/grunt">grunt</a> build system.  If you are not familiar with what it is, it's time to do it, otherwise you will regularly stumble over the console on the way to success.  If you are "advanced", do not shout in the comments <a href="https://github.com/gulpjs/gulp">"gulp"</a> , adapting the code for your build system for you will not be a problem. <br><br><h2>  Testing </h2><br>  There are now plenty of libraries to test.  And you have to make it and choose the testing model you like.  I do not impose the library I use to you, because the main thing is to have tests, and the choice of the library is secondary.  My choice in this case was made for the following reasons: <br><ol><li>  Some historical moments in which I have already used jasmine. </li><li>  Support for node.js and browser by one library, since there is a reuse of code. </li><li>  The maturity of the library, and as a result, the presence of integration in various tools. </li></ol>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Installation <br><pre><code class="bash hljs">npm install grunt-jasmine-node --save-dev</code> </pre> <br><br>  Gruntfile.js configuration <br><pre> <code class="javascript hljs">jasmine_node: { <span class="hljs-attr"><span class="hljs-attr">options</span></span>: { <span class="hljs-attr"><span class="hljs-attr">forceExit</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">match</span></span>: <span class="hljs-string"><span class="hljs-string">'.'</span></span>, <span class="hljs-attr"><span class="hljs-attr">matchall</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">extensions</span></span>: <span class="hljs-string"><span class="hljs-string">'js'</span></span>, <span class="hljs-attr"><span class="hljs-attr">specFolders</span></span> : [<span class="hljs-string"><span class="hljs-string">'./spec/'</span></span>] }, <span class="hljs-attr"><span class="hljs-attr">all</span></span>: [<span class="hljs-string"><span class="hljs-string">'spec/'</span></span>] }</code> </pre><br><br>  I will not teach you how to write tests, there is plenty of such material.  I'd rather go to the second tool, the purpose of which is to show that you not only write tests, but also which parts of the code your tests are testing.  After all, it is completely pointless to write tests without presenting the general picture of the tested code. <br><br><h2>  Code Coverage Analysis </h2><br>  There is no valid reason for the library code not being 100% covered by tests.  Each condition in the code must be covered with a test, otherwise you will encounter unexpected behavior or write code that never works.  If the code is not covered by tests for 100% confidence in the library falls.  To check the code coverage with tests, you must use the istanbul library.  By itself, Istanbul in the "bare" form is not interesting to us.  It is necessary to integrate it into the test run system.  This is <a href="https://github.com/jribble/grunt-jasmine-node-coverage">what the grunt-jasmine-node-coverage</a> module does.  It will allow you to get a report in html-form (and not only) for comfortable analysis of source code coverage. <br><br>  Installation <br><pre> <code class="bash hljs">npm install grunt-jasmine-node-coverage --save-dev</code> </pre><br><br>  Since we integrate jasmine with istanbul, you just need to change the configuration of jasmine <br><pre> <code class="javascript hljs">jasmine_node: { <span class="hljs-attr"><span class="hljs-attr">coverage</span></span>: {}, <span class="hljs-comment"><span class="hljs-comment">//     options: { forceExit: true, match: '.', matchall: false, extensions: 'js', specFolders : ['./spec/'] }, all: ['spec/'] }</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/448/c33/458/448c3345803e058aa17ed7a28508328f.png" align="left">  By the way, the analysis of code coverage by tests made me take a little different look at some fragments.  For example, from the analysis of some parts of the code, I found that the behavior of the function in some if constructions is not defined.  Simply put, there was no else block.  Refactoring one of these functions led me to understand that the whole class and interaction with it was written incorrectly and a decent amount of code was rewritten.  It also revealed quite a few weak points in error control.  Somewhere they did not exist at all, somewhere they were poorly checked, and so on.  So <b>use code coverage analysis - it really makes you look at your code completely different</b> .  Moreover, the use of the tool is so simple, and the reports are completely predictable. <br><br>  These tools are enough to make sure that you control the quality of your code.  And further material will reveal more complex aspects of the development of libraries. <br><br><h2>  Build the client part of the library </h2><br>  If you are creating a cross-platform library (node.js and browser) you will need a tool to build the client part of the library.  To turn the code for node.js into code that can be connected to the browser, you need to use the <a href="https://github.com/substack/node-browserify">browserify</a> tool. <br><br>  Installation <br><pre> <code class="bash hljs">npm install grunt-browserify --save-dev</code> </pre><br><br>  Configuration <br><pre> <code class="javascript hljs">browserify: { <span class="hljs-attr"><span class="hljs-attr">dist</span></span>: { <span class="hljs-attr"><span class="hljs-attr">files</span></span>: { <span class="hljs-string"><span class="hljs-string">'dist/my-library.js'</span></span>: [<span class="hljs-string"><span class="hljs-string">'lib/my-library.js'</span></span>] } } }</code> </pre><br>  The configuration is quite understandable, provided that you have the final files in the / dist folder, and the sources in the / lib folder.  Do not forget to minimize the resulting file using uglify.  The topic is so jaded that I will not disclose it in my article.  Just in case I will leave only the <a href="https://github.com/gruntjs/grunt-contrib-uglify">link</a> . <br><br><h2>  Automated client testing </h2><br>  No need to rely on transparency, which gives technology from the previous chapter.  Test your code in a browser.  Especially if it uses external libraries like yours, compiled using browserify.  Given that jasmine is available both under node.js and under browser, tests can be reused.  Just add a test file to your browserify configuration and configure jasmine to run it.  The configuration will look something like this: <br><br><pre> <code class="javascript hljs">browserify: { <span class="hljs-attr"><span class="hljs-attr">dist</span></span>: { <span class="hljs-attr"><span class="hljs-attr">files</span></span>: { <span class="hljs-string"><span class="hljs-string">'dist/my-library.js'</span></span>: [<span class="hljs-string"><span class="hljs-string">'lib/my-library.js'</span></span>], <span class="hljs-string"><span class="hljs-string">'dist/my-library.spec.js'</span></span>: [<span class="hljs-string"><span class="hljs-string">'spec/my-library.spec.js'</span></span>] } } }</code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/448/c33/458/448c3345803e058aa17ed7a28508328f.png" align="left">  In my case, I used the rather popular socket.io library and when I first started integration tests in the browser, I found that not a single test passed, because I completely in vain set the socket.io option, which for each request creates a new connection.  For the browser, it was fatal and I had to pretty well refactor my code under node.js to work without the above option.  <b>Test your code in the browser after using various tools</b> . <br><br>  So, customer testing is required, but it has not yet been automated.  jasmine assumes that the browser opens an html page (called TestRunner).  But we need to test conducted in automatic mode.  For this, a project called <a href="https://github.com/ariya/phantomjs">phantomjs</a> will help us.  The essence of the technology is that it is a full-fledged browser, but only without UI.  That is, in general, without any UI, - graphic or text.  This browser is controlled by a simple javascript script run in phantomjs. <br><br>  Installation <br><pre> <code class="bash hljs">npm install phantomjs --save-dev</code> </pre><br><br>  Using.  To run our TestRunner.html and get the test results you need the following: <br>  1. Write a node.js specification file that will run phantom.js (to run automatically in jasmine) <br>  2. Write a phantomjs script that will do the following: <br><ul><li>  Wait until the end of jasmine. </li><li>  Parry the DOM of the resulting page and find out how many tests have dropped.  (There are suspicions that there is a better way than parsing the DOM). </li><li>  Finish phantomjs. </li></ul><br>  3. To analyze the result of phantomjs for messages about the fall of the tests. <br><br>  In general, this part will have to tinker well.  I perfectly imagine that the person who hears for the first time about the technology of phantom.js did not understand anything at all from the list above.  It does not matter.  You only need to open the corresponding pages of the phantomjs documentation, read and understand.  And you just have to master this technology, you have pretty good prospects for automating the testing of UI. <br>  For inspiration, you can look at the already implemented scenario in the aforementioned library, on the experience of the development of which this article appeared. <br><div class="spoiler">  <b class="spoiler_title">Links to files for inspiration</b> <div class="spoiler_text">  1. <a href="https://github.com/jcarver989/phantom-jasmine">The official startup automation script for jasmine-tests for phantomjs</a> . <br>  2. <a href="">Real spec file</a> .  1st and 3rd points. <br>  3. <a href="">Real phantomjs script for downloading TestRunner.html jasmine`ovskogo and analyzing it</a> .  2nd point.  At the moment, it is already completely different from the official version. <br></div></div><br><br>  Well, now that your code is 100% tested;  tested in various environments, with some small reservations of course, you should rightly be bursting with pride in your brainchild.  But ... there is another obstacle on your way without overcoming which your fingers will most likely be cut off. <br><br><h2>  Memory leak detection </h2><br>  Even if you did everything correctly and your code is 100% tested, it does not give you any guarantee that the library is not ‚Äúflowing.‚Äù  And if in the browser, for objective reasons, it was killed, the ‚Äúflowing‚Äù server service, as it is not difficult to guess, is a failure. <br>  A less working tool for finding memory leaks that I could find is <a href="https://github.com/lloyd/node-memwatch">memwatch</a> ( <a href="http://habrahabr.ru/company/nordavind/blog/195494/">article on habre</a> ).  Unfortunately, I failed to automate its use.  There is no stability of the results (or I missed something). <br>  As stated in the memwatch itself, the heap dump is always removed after running the garbage collector.  But nevertheless, some allegedly unclaimed objects still flash in the report.  The real test with billions of iterations of sample test-case `s showed that the library does not eat memory and works stably. <br>  But this, of course, is not an argument against using the tool.  Perhaps in the future it will work stably.  I even hope that these are not his problems, but node.js.  And in new versions it can show the best results. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/448/c33/458/448c3345803e058aa17ed7a28508328f.png" align="left">  By the way, with the help of this tool, I found that socket.io does not flow.  And I found a decent amount of leaks in my code.  And these leaks were exclusively in the use of the same class: EventEmitter.  In principle, a lot has been written about this, that EventEmitter is ‚Äúgifts bringing ...‚Äù.  But as they say, experience is an invaluable thing.  Purchase it, use automation tools in your work and we will see a lot of quality work. </div><p>Source: <a href="https://habr.com/ru/post/224073/">https://habr.com/ru/post/224073/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../224063/index.html">Hacking the D-Link DSP-W215 Smart Plug: Again, Again, Again</a></li>
<li><a href="../224065/index.html">Python-digest # 28. News, interesting projects, articles and interviews [May 19, 2014 - May 25, 2014]</a></li>
<li><a href="../224067/index.html">Profishop - solution for receiving orders from wholesale customers</a></li>
<li><a href="../224069/index.html">Splitting algorithms and van der Waerden numbers</a></li>
<li><a href="../224071/index.html">Popularizing 3D printing in an adult way ... in schools</a></li>
<li><a href="../224075/index.html">Haskell. We test the multithreaded application</a></li>
<li><a href="../224077/index.html">Testing through abstract classes in TestNG</a></li>
<li><a href="../224079/index.html">Amazon hides books from Hachette</a></li>
<li><a href="../224081/index.html">How to write parsers on javascript</a></li>
<li><a href="../224083/index.html">Lenovo ThinkServer RD540 Server New Corporate Standard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>