<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>5 ways to deploy PHP code in terms of hayload</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If the highload were taught at school, there would be such a task in the textbook on this subject. ‚ÄúThe N social network has 2,000 servers, on which t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>5 ways to deploy PHP code in terms of hayload</h1><div class="post__text post__text-html js-mediator-article">  If the highload were taught at school, there would be such a task in the textbook on this subject.  ‚ÄúThe N social network has 2,000 servers, on which there are 150,000 files of 900 MB of PHP code and a staging cluster for 50 machines.  The code is deployed to servers 2 times a day, the staging cluster code is updated every few minutes, and there is also ‚Äúhotfixes‚Äù - small sets of files that are laid out out of turn on all or on a dedicated part of servers, without waiting for the full calculation.  Question: are such conditions considered a highload and how are they deployed?  Write at least 5 deployment options. ‚Äù  We can only dream about a task book on a highload, but now we know that <strong>Yuri Nasretdinov</strong> ( <a href="https://habr.com/ru/users/yourock/" class="user_link">youROCK</a> ) would definitely have solved this problem and received a ‚Äútop five‚Äù. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qMu4YHJV1Z8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Yuri didn‚Äôt stop at a simple solution, but additionally gave a report in which he revealed the topic of the concept of ‚Äúdeploy code‚Äù, told about classic and alternative solutions of large-scale code deployment in PHP, analyzed their performance and presented a self-writing system of MDK deployment. <br><a name="habracut"></a><br><h2>  The concept of "warm code" </h2><br>  In English, the term ‚Äúdeploy‚Äù means bringing the troops on alert, and in Russian we sometimes say ‚Äúpour code into battle‚Äù, which means the same thing.  You take the code in the already compiled or in the original, if it is PHP, form, upload to servers that serve user traffic, and then, with magic, in some way, switch the load from one version of the code to another.  All this is included in the concept of "code deployment". <br><br>  Deploy process usually consists of several stages. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <strong>Getting the code from the repository</strong> , in any way you want: clone, fetch, checkout. </li><li>  <strong>Build - build</strong> .  For PHP code, the build phase may be missing.  In our case, this is, as a rule, autogeneration of translation files, uploading static files to CDNs and some other operations. </li><li>  <strong>Delivery to end servers</strong> - deployment. </li></ul><br>  After everything is collected, the phase of the deployment itself begins - uploading the <strong>code to the production servers</strong> .  It is about this phase on the example of <a href="https://habr.com/ru/company/badoo/">Badoo</a> and will be discussed. <br><br><h2>  Old Depoo System in Badoo </h2><br>  If you have a file with a file system image, then how to mount it?  In Linux, you need to create <strong>an intermediate Loop device</strong> , attach a file to it, and after that you can already mount this block device. <br><br>  A loop device is a crutch that Linux needs to mount a file system image.  There are operating systems in which this crutch is not required. <br><br><img src="https://habrastorage.org/webt/gd/ch/h6/gdchh68qpl5ikkpddsvxzwcwvlm.png"><br><br>  How does the deployment process happen with the help of files, which we also call loops for simplicity?  There is a directory in which the source code and automatically generated content are located.  We take an empty image of the file system - now it is EXT2, and earlier we used ReiserFS.  Mount an empty file system image in a temporary directory, copy all the contents there.  If we don‚Äôt need production to get something, then we don‚Äôt copy everything.  After that, unmount the device, and get an image of the file system in which the necessary files are located.  Next, we <strong>archive the image and upload it to all servers</strong> , unzip it and mount it. <br><br><h2>  Other existing solutions </h2><br>  To begin with, let‚Äôs thank <strong>Richard Stallman</strong> - without his license, there wouldn‚Äôt be a majority of the utilities that we use. <br><br><img src="https://habrastorage.org/webt/8h/oa/yh/8hoayhyyicam7izl-q7egj8bitq.png"><br><br>  I divided the methods of PHP code deployment into 4 categories. <br><br><ul><li>  <strong>Based on version control system</strong> : svn up, git pull, hg up. </li><li>  <strong>On the basis of the utility rsync</strong> - in a new directory or "on top". </li><li>  <strong>A single file</strong> - no matter how: phar, hhbc, loop. </li><li>  A special way that <strong>Rasmus Lerdorf</strong> suggested is <strong>rsync, 2 directories and realpath_root</strong> . </li></ul><br>  Each method has both advantages and disadvantages, because of which we refused them.  Consider these 4 ways in more detail. <br><br><h3>  Depla based on version control system svn up </h3><br>  I chose SVN not by chance - according to my observations, in such a form deploy exists exactly in the case of SVN.  The system is quite <strong>lightweight</strong> , it allows you <strong>to quickly and easily</strong> deploy it - just run svn up and everything is ready. <br><br>  But this method has one big disadvantage: if you do svn up, and in the process of updating the source code, when new requests come from the repository, they will see the state of the file system, which did not exist in the repository.  You will have some new files, and some old ones - this is a <strong>non-atomic way of deployment</strong> , which is not suitable for high loads, but only for small projects.  Despite this, I know projects that are still so deplorable, and so far everything is working for them. <br><br><h3>  Rsync based warmup </h3><br>  There are two options for how to do this: upload files using the utility directly to the server and upload ‚Äúon top‚Äù to update. <br><br><h4>  rsync to a new directory </h4><br>  Since you first completely fill all the code into a directory that does not already exist on the server, and only then switch traffic, this method is <strong>atomic</strong> - no one sees the intermediate state.  In our case, creating 150,000 files and deleting the old directory, in which there are also 150,000 files, creates a <strong>heavy load on the disk subsystem</strong> .  We have very hard drives, and the server doesn‚Äôt feel very good after such an operation for about a minute.  Since we have 2000 servers, it takes 2000 MB to fill up 2000 times. <br><br>  This scheme can be improved by first pouring on some number of intermediate servers, for example, 50, and then adding them to the rest.  This solves possible problems with the network, but the problem of creating and deleting a huge number of files does not disappear anywhere. <br><br><img src="https://habrastorage.org/webt/wj/c9/pt/wjc9ptyfin79_dn6jmnornudzt8.png"><br><br><h4>  rsync "on top" </h4><br>  If you used rsync, you know that this utility can not only fill directories, but also update existing ones.  Sending only changes is a plus, but since we upload changes to the same directory in which we serve the combat code, there will also be some intermediate state there - this is a minus. <br><br>  Posting changes works like this.  Rsync lists the files on the server side, from which it is deployed, and on the receiving side.  After that, it counts stat from all files and sends the entire list to the receiving side.  On the server from which it is deployed, the difference between these values ‚Äã‚Äãis considered, and it is determined which files should be sent. <br><br>  In our conditions, this process takes about <strong>3 MB of traffic and 1 second of CPU time</strong> .  It seems that it is a little, but we have 2000 servers, and everything turns out at least one minute of CPU time.  This is not such a fast way, but definitely better than sending it entirely through rsync.  It remains to somehow solve the problem of atomicity and will be almost perfect. <br><br><h3>  Warm one file </h3><br>  Whatever single file you upload, it is relatively easy to do with BitTorrent or the UFTP utility.  One file is easier to unpack, you can atomically replace it in Unix, and it is easy to check the integrity of the file generated on the build server and delivered to the end machines by calculating the MD5 or SHA-1 amounts from the file (in the case of rsync, you do not know what is on the end servers ). <br><br>  For hard drives, sequential recording is a big plus - a 900 MB file for an unallocated hard drive will be recorded in about 10 seconds.  But you still need to record these same 900 MB and transfer them over the network. <br><br><h4>  Lyrical digression about UFTP </h4><br>  This Open Source utility was originally designed to transfer files over the network with long delays, for example, through a network based on satellite communications.  But UFTP turned out to be suitable for uploading files to a large number of machines, because it works via UDP protocol based on Multicast.  One Multicast address is created, all the machines that want to receive the file subscribe to it, and the switches ensure delivery of the package copies to each machine.  So we shift the burden of data transmission to the network.  If your network can handle it, then this method works much better than BitTorrent. <br><br>  You can try this open source utility on your cluster.  Despite the fact that it works via the UDP protocol, it has a NACK - negative acknowledgment mechanism, which forces to re-send packets lost during delivery.  <strong>This is a reliable way to deploy</strong> . <br><br><h4>  Deploy options in one file </h4><br>  <strong>tar.gz</strong> <br><br>  An option that combines the disadvantages of both approaches.  Not only do you have to write 900 MB to the disk sequentially, after that you need to randomly read and write once again to write the same 900 MB and create 150,000 files.  The performance of this method is even worse than rsync. <br><br>  <strong>phar</strong> <br><br>  PHP supports archives in the format of phar (PHP Archive), is able to give their contents and include files.  But not all projects are easy to put in one phar - code adaptation is needed.  Just because the code from this archive does not work.  In addition, one file cannot be changed in the archive ( <em>Yuri from the future: in theory it is still possible</em> ), it is required to reload the entire archive.  Also, despite the fact that the phar-archives work with OPCache, when the cache is deployed, you need to reset it, because otherwise there will be garbage in the OPCache from the old phar-file. <br><br>  <strong>hhbc</strong> <br><br>  This method is native for HHVM - HipHop Virtual Machine and it is used by Facebook.  This is something like a phar-archive, but it does not contain the source code, but the compiled byte-code of the HHVM virtual machine - a PHP interpreter from Facebook.  It is forbidden to change anything in this file: you cannot create new classes, functions and some other dynamic features in this mode are disabled.  Due to these limitations, the virtual machine can use additional optimizations.  According to Facebook, this can bring up to 30% of the speed of code execution.  This is probably a good option for them.  It is also impossible to change one file here ( <em>Yuri from the future: in fact, it is possible, because it is sqlite-base</em> ).  If you want to change one line, you need to redo the entire archive again. <br><br>  For this method it is <strong>forbidden to use eval and dynamic include.</strong>  This is true, but not quite.  Eval can be used, but if it does not create new classes or functions, and you cannot include include from directories that are outside this archive. <br><br>  <strong>loop</strong> <br><br>  This is our old version, and it has two big advantages.  First, it looks like a regular directory <strong>.</strong>  You are mounting the loop, and for the code it doesn't matter - it works with files, both on the develop-environment and on the production-environment.  The second is that the loop can be mounted in read and write mode, and you can change one file, if you need to change something urgently to production. <br><br>  But the loop has cons.  The first is that it works strangely with the docker.  I will tell about it a bit later. <br><br>  The second is if you use symlink on the last loop as a document_root, then you will have problems with OPCache.  He is not very good at having symlink on the way, and starts to confuse which versions of the files to use.  Therefore, OPCache has to be discarded during a delay. <br><br>  Another problem is that <strong>superuser privileges are required</strong> to mount file systems.  And you should not forget to mount them at the start / restart of the machine, because otherwise there will be an empty directory instead of the code. <br><br><h4>  Docker problems </h4><br>  If you create a docker-container and forward a folder inside it in which loops or other block devices are mounted, then two problems arise: the new mount points do not get inside the docker container, and those loops that were at the time of creation docker-container <strong>cannot be unmounted</strong> because they are occupied by the docker-container. <br><br>  Naturally, this is generally incompatible with deployment, because the number of loop devices is limited, and it is unclear how the new code should fall into the container. <br><br>  We tried to do strange things, for example, to raise a local <strong>NFS server</strong> or mount a directory using SSHFS, but for various reasons, this did not stick to us.  As a result, we assigned rsync from the last ‚Äúmagnifying glass‚Äù to the real directory in cron, and it executed the command once a minute: <br><pre><code class="php hljs">rsync /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/loop/&lt;N&gt;/ /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/</code> </pre> <br>  Here, <code>/var/www/</code> is the directory that is promoted to the container.  But on machines with docker containers, we don‚Äôt need to run PHP scripts often, so the fact that rsync is not atomic suits us.  But still this method is very bad, of course.  I would like to make a deployment system that works well with docker. <br><br><h3>  rsync, 2 directories and realpath_root </h3><br>  This method was suggested by Rasmus Lerdorf, the author of PHP, and he knows how to deploy. <br><br>  How to make an atomic deployment, and in any of the ways that I talked about?  Take symlink and write it as document_root.  At any given time, symlink points to one of two directories, and you make rsync to a neighboring directory, that is, to the one in which the code does not point. <br><br><img src="https://habrastorage.org/webt/x7/qh/49/x7qh49aslgwu3loufk6wixt8fcg.png"><br><br>  But the problem arises: the PHP code does not know in which of the directories it was launched.  Therefore, you need to use, for example, a variable that you set somewhere at the beginning in the config - it will fix from which directory the code was run, and from which to add new files.  In the slide, it is called <code>ROOT_DIR</code> . <br><br>  Use this constant when referring to all files within the code you use in production.  So you get the property of atomicity: requests that arrive before you switch symlink continue to include files from the old directory in which you did not change anything, and new requests that came after switching symlink start working from the new directory and serviced new code. <br><br><img src="https://habrastorage.org/webt/ny/o3/hh/nyo3hhqqs2iwthucxiquyf-org4.png"><br><br>  But it needs to be written in the code.  Not all projects are ready for this. <br><br><h3>  Rasmus-style </h3><br>  <a href="https://github.com/etsy/mod_realdoc">Rasmus suggests</a> instead of manually modifying the code and creating constants, modify Apache a little bit, or use nginx. <br><br><img src="https://habrastorage.org/webt/8f/c3/xy/8fc3xyhs8rgmrtp45qeguvtzufi.png"><br><br>  As document_root, specify the symlink for the latest version.  If you have nginx, then you can register <code>root $realpath_root</code> , Apache will need a separate module with settings that can be seen on the slide.  It works like this - when a request arrives, nginx or Apache, once in a while, consider realpath () from the path, saving it from the symlinks, and pass this path as document_root.  In this case, document_root will always point to the usual directory without symlinks, and your PHP code may not think about the directory from which it is called. <br><br>  This method has some interesting advantages - OPCache PHP already comes with real paths, they do not contain symlink.  Even the very first file to which the request came will already be full, and there will be no problems with OPCache.  Since document_root is used, this works with any PHP project.  You do not need to adapt anything. <br><br>  There is no need for fpm reload, it is not necessary to reset OPCache during a deployment, which is why the processor server is heavily loaded, because it has to re-parse all the files again.  In my experiment, the OPCache reset increased the CPU consumption by about 2-3 times by about half a minute.  It would be nice to reuse it and this method allows you to do it. <br><br>  Now the cons.  Since you do not reuse OPCache, and you have 2 directories, you need to store copies of the file in memory for each directory - under OPCache, 2 times more memory is required. <br><br>  There is another limitation that may seem strange - <strong>you can not deploy more often than once in max_execution_time</strong> .  Otherwise there will be the same problem, because while rsync is going to one of the directories, requests from it can still be processed. <br><br>  If you use Apache for some reason, then a <a href="https://github.com/etsy/mod_realdoc">third-party module is</a> needed, which Rasmus also wrote. <br><br>  Rasmus says the system is good and I recommend it to you too.  For 99% of projects, it is suitable, both for new projects and for existing ones.  But, of course, we are not like that and decided to write our decision. <br><br><h2>  New system - MDK </h2><br>  Basically, our requirements are no different from the requirements for most web projects.  We just want <strong>fast deploying</strong> on styling and production, <strong>low resource consumption</strong> , reusable OPCache and fast rollback. <br><br>  But there are two more requirements that may differ from the rest.  First of all, it is an opportunity to <strong>apply patches atomically</strong> .  We call patches changes in one or several files that rule something in production.  We want to do it quickly.  Basically, the system that Rasmus offers is coping with the task of patches. <br><br>  We also have <strong>CLI scripts</strong> <strong>that can work for several hours</strong> , and they still need to work with a consistent version of the code.  In this case, these solutions, unfortunately, either do not suit us, or we must have very many directories. <br><br>  Possible solutions: <br><br><ul><li>  loop xN (-staging, -docker, -opcache); </li><li>  rsync xN (-production, -opcache xN); </li><li>  SVN xN (-production, -opcache xN). </li></ul><br>  Here N is the number of calculations that occur in a few hours.  We can have dozens of them, which means having to spend a very large amount of space for additional copies of the code. <br><br>  Therefore, we invented a new system and called it <strong>MDK.</strong>  It stands for <strong>Multiversion Deployment Kit</strong> - a multi-version deployment tool.  We made it based on the following prerequisites. <br><br>  <strong>Took the tree storage architecture from Git.</strong>  We need to have a consistent version of the code in which the script works, that is, snapshots are needed.  Snapshots are supported by LVM, but there they are implemented inefficiently, with experimental file systems like Btrfs and Git.  We took the implementation of snapshots from git. <br><br>  <strong>Renamed all files from file.php to file.php. &lt;Version&gt;.</strong>  Since all our files are stored simply on disk, then if we want to store several versions of the same file, we must add a suffix with the version. <br><br>  <strong>I love Go, so for speed wrote a system on Go.</strong> <br><br><h3>  How the Multiversion Deployment Kit works </h3><br>  We took the idea of ‚Äã‚Äãsnapshots from Git.  I simplified it a little bit and tell you how it is implemented in MDK. <br><br>  There are two types of files in MDK.  The first is <strong>maps.</strong>  The pictures below are green and correspond to the directories in the repository.  The second type is <strong>the files themselves,</strong> which are in the same place as usual, but with a suffix in the form of a file version.  Files and maps are versioned based on their content, in our case simply MD5. <br><br><img src="https://habrastorage.org/webt/-n/wz/1s/-nwz1str78y7hua15pfwxrrl14o.png"><br><br>  Suppose we have a certain hierarchy of files in which the <strong>root map refers to certain versions of files from other maps</strong> , and they, in turn, refer to other files and maps, and fix certain versions.  We want to change some file. <br><br><img src="https://habrastorage.org/webt/7d/up/_b/7dup_biyh7msgtsp7kejinaulwc.png"><br><br>  Perhaps you have already seen a similar picture: we change the file at the second nesting level, and in the corresponding map ‚Äî map *, the three * version of the file is updated, its contents are modified, the version changes ‚Äî and the version also changes in the root map.  If we change something, we always get a new root card, but all files that we have not changed are reused. <br><br>  Links remain on the same files as they were.  This is the basic idea of ‚Äã‚Äãcreating snapshots in any way, for example, in <strong>ZFS</strong> it is implemented in about the same way. <br><br><h3>  How MDK is on disk </h3><br><img src="https://habrastorage.org/webt/2r/vb/k4/2rvbk4ucmbe8upitkgczvy1dbns.png"><br><br>  On the disk we have: <strong>symlink to the most recent root card</strong> ‚Äî the code that will be served from the web, several versions of root maps, several files, possibly with different versions, and in the subdirectories there are maps for the corresponding directories. <br><br>  I foresee the question: " <em>And how do you handle this web request? What files will the custom code come in?</em> " <br><br>  Yes, I deceived you - there are also files without versions, because if you receive a request for index.php, and you don‚Äôt have it in the directory, then the site will not work. <br><br><img src="https://habrastorage.org/webt/-e/fl/9k/-efl9kqt3-go-tvg0qpu0lnvauo.png"><br><br>  All PHP files have files that we call <strong>stubs</strong> , because they contain two lines: require from the file in which the function is declared, which can work with these cards, and require from the correct version of the file. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">"mdk.inc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> mdk_resolve_path(<span class="hljs-string"><span class="hljs-string">"a.php"</span></span>);</code> </pre><br>  It is done this way, and not with the symlinks to the latest version, because if you use <strong>b.php</strong> without a version from the <strong>a.php</strong> file, then since it is written to require_once, the system will remember which root card it started from, it will use it, and get a consistent version of the files. <br><br>  For the rest of the files, we just have symlink to the latest version. <br><br><h3>  How to Deploy with MDK </h3><br>  The model is very similar to git push. <br><br><ul><li>  We send the contents of the root card. </li><li>  On the receiving side, we look at which files are missing.  Since the file version is determined by the content, we don‚Äôt need to download it a second time ( <em>Yuri from the future: except for the case when a shortened MD5 collision happens, which did happen once in production</em> ). </li><li>  We are requesting the missing file. </li><li>  We turn to the second point and continue in a circle. </li></ul><br><h4>  Example </h4><br>  Suppose there is a file named "one" on the server.  We send to him the root card. <br><br><img src="https://habrastorage.org/webt/_h/sz/h_/_hszh_rruyekpqegz6-blz5xkeq.png"><br><br>  In the root map, intermittent arrows indicate links to files that we do not have.  We know their names and versions because they are in the map.  We request them from the server.  The server sends, and it turns out that one of the files is also a map. <br><br><img src="https://habrastorage.org/webt/zp/--/ec/zp--ecfpdqqkgjq4zciljreqkk0.png"><br><br>  We look - we do not have a single file at all.  Again we request files that are missing.  The server sends them.  No more cards left - the deployment process is complete. <br><br><img src="https://habrastorage.org/webt/mp/jk/tc/mpjktcmgb80dpamvqjkwp_ya1lg.png"><br><br>  You can easily guess what will happen if the files are 150,000, and one has changed.  We will see in the root map that one card is missing, go to the level of nesting and get the file.  In terms of computational complexity, the process hardly differs from copying files directly, but it also preserves consistency and code snapshots. <br><br>  MDK has no minuses :) It allows you to <strong>quickly and atomically deploy small changes</strong> , and <strong>scripts to work for days</strong> , because we can keep all the files that are deposited during the week.  They will occupy an adequate amount of space.  You can also reuse OPCache, and the CPU eats almost nothing. <br><br>  <strong>Monitoring is quite difficult, but possible</strong> .  All files are versioned by content, and you can write a cron that will go through all the files and check the name and content.  You can also check that the root map refers to all files, that there are no broken links in it.  Moreover, the integrity is checked during the delay. <br><br>  You can <strong>easily roll back the changes</strong> , because all the old maps are in place.  We can just throw a card, everything will be there right away. <br><br>  For me, plus the fact that <strong>MDK is written in Go</strong> means it works fast. <br><br>  I deceived you again, there are still minuses.  For the project to work with the system, <strong>a significant modification of the code is required,</strong> but it is simpler than it might seem at first glance.  <strong>The system is very complex</strong> , I would not recommend it to implement, if you do not have such requirements as that of Badoo.  Also, anyway, sooner or later the place runs out, so the <strong>Garbage Collector is required</strong> . <br><br>  We wrote special utilities to edit the files ‚Äî real ones, not stubs, for example, mdk-vim.  You specify a file, it finds the version you need and edits it. <br><br><h3>  MDK in numbers </h3><br>  We have 50 servers on the staging, on which we deploy in 3-5 seconds <strong>.</strong>  Compared to everything except rsync, this is very fast.  On <strong>production</strong> we deploy about <strong>2 minutes</strong> , small patches - <strong>5-10 s</strong> . <br><br>  If for some reason you have lost the entire folder with the code on all servers (which should never happen :)) then the <strong>process of full filling takes about 40 minutes</strong> .  We have this happened once, though at night in a minimum of traffic.  Therefore, no one was hurt.  The second file was on a pair of servers for 5 minutes, so it is not worthy of mention. <br><br>  The system is not in Open Source, but if you're interested, write in the comments - maybe we will post it ( <em>Yuri from the future: the system is still not in Open Source at the time of this writing</em> ). <br><br><h2>  Conclusion </h2><br>  <strong>Listen to Rasmus, he is not lying</strong> .  In my opinion, its rsync method in conjunction with realpath_root is the best, although loops also work quite well. <br><br>  <strong>Think with your head</strong> : look at what exactly your project needs, and do not try to create a spacecraft where there is enough "corncob".  But if all the same your requirements are similar, then a system similar to MDK will suit you. <br><br><blockquote>  We decided to return to this topic, which was discussed at <a href="https://www.highload.ru/">HighLoad ++</a> and, perhaps, then did not receive due attention, because it was only one of many bricks to achieve high performance.  But now we have a separate professional conference <a href="https://phprussia.ru/2019">PHP Russia</a> , completely dedicated to PHP.  And here we will come off in full.  We will talk in detail about <a href="https://phprussia.ru/2019/abstracts/5154">performance</a> , <a href="https://phprussia.ru/2019/abstracts/5049">standards</a> , and <a href="https://phprussia.ru/2019/abstracts/4799">tools</a> - a lot about that, including <a href="https://phprussia.ru/2019/abstracts/5187">refactoring</a> . <br><br>  Subscribe to the <a href="https://t.me/PHPRussiaConfChannel">Telegram channel</a> with the updates of <a href="https://phprussia.ru/2019/abstracts">the</a> conference <a href="https://phprussia.ru/2019/abstracts">program</a> , and see you on May 17th. </blockquote></div><p>Source: <a href="https://habr.com/ru/post/449916/">https://habr.com/ru/post/449916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../44990/index.html">Results of the NORD industrial design competition</a></li>
<li><a href="../449906/index.html">Self-documenting REST server (Node.JS, TypeScript, Koa, Joi, Swagger)</a></li>
<li><a href="../449908/index.html">DDR3 or DDR4? Why did we offer the Dell R420 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps at $ 99 in the Netherlands?</a></li>
<li><a href="../44991/index.html">Triumph of Belarusians in the final of Code Jam 2008</a></li>
<li><a href="../449910/index.html">GitLab Shell Runner. Competitive launch of test services with Docker Compose</a></li>
<li><a href="../449918/index.html">Infrared Thermometer with Sensor MLX90614</a></li>
<li><a href="../44992/index.html">Live game without graphics</a></li>
<li><a href="../449922/index.html">Test drive nanoCAD SPDS Metal structures 1.2. Part 3</a></li>
<li><a href="../449926/index.html">The digest of fresh materials from the world of the frontend for the last week No. 362 (April 22 - 28, 2019)</a></li>
<li><a href="../449928/index.html">Not just processing: How we made a distributed database from Kafka Streams, and what came of it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>