<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>jWidget - object-oriented JavaScript MV * framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There is a wonderful site http://todomvc.com/ , which demonstrates the solution of the same task using different JavaScript MV * ( Model-View- [Contro...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>jWidget - object-oriented JavaScript MV * framework</h1><div class="post__text post__text-html js-mediator-article">  There is a wonderful site <a href="http://todomvc.com/">http://todomvc.com/</a> , which demonstrates the solution of the same task using different JavaScript MV * ( <a href="http://ru.wikipedia.org/wiki/Model-View-Controller">Model-View- [Controller]</a> ) frameworks.  Now there are dozens of different frameworks, each of which has its own advantages and disadvantages.  There are such giants as <a href="https://angularjs.org/">Angular</a> , <a href="http://emberjs.com/">Ember</a> and <a href="http://backbonejs.org/">Backbone</a> .  Despite the high competition, I would still like to demonstrate my MV * framework - <a href="http://enepomnyaschih.github.io/jwidget/index.html">jWidget</a> . <br><br>  I quickly looked through all the solutions presented on the TodoMVC website and did not find any framework similar to jWidget.  The fact is that, in addition to JavaScript, I program a lot in object-oriented programming languages ‚Äã‚Äãsuch as Java, C #, and in the past in C ++.  Therefore, I am a big fan of object-oriented programming, <a href="http://ru.wikipedia.org/wiki/SOLID_(%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">SOLID principles,</a> and <a href="http://ru.wikipedia.org/wiki/Design_Patterns">object-oriented design patterns</a> .  I do not need a framework that would hamper my ability to use standard object-oriented solutions.  What I saw in existing TodoMVC solutions does not inspire confidence in this regard.  As a rule, they provide some declarative syntax and a powerful template engine, but the object-oriented basis of all this, even if it exists, is hidden from our eyes. <br><br><a name="habracut"></a><br>  <b>Documentation in English:</b> <a href="http://enepomnyaschih.github.io/jwidget/index.html">http://enepomnyaschih.github.io/jwidget/index.html#!/guide/home</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>Documentation in Russian:</b> <a href="http://enepomnyaschih.github.io/jwidget/index.html">http://enepomnyaschih.github.io/jwidget/index.html#!/guide/ruhome</a> <br><br>  <b>Project on GitHub:</b> <a href="https://github.com/enepomnyaschih/jwidget">https://github.com/enepomnyaschih/jwidget</a> <br><br>  <b>Twitter:</b> <a href="https://twitter.com/jwidgetproject">@jwidgetproject</a> <br><br>  <b>Implement TodoMVC on jWidget:</b> <a href="http://enepomnyaschih.github.io/todomvc/labs/architecture-examples/jwidget/release/">http://enepomnyaschih.github.io/todomvc/labs/architecture-examples/jwidget/release/</a> <br><br>  The Source link does not work there right now, because jWidget is only in my fork.  Below is the correct link to the source code. <br><br>  <b>TodoMVC source code on jWidget:</b> <a href="https://github.com/enepomnyaschih/todomvc/tree/gh-pages/labs/architecture-examples/jwidget/">https://github.com/enepomnyaschih/todomvc/tree/gh-pages/labs/architecture-examples/jwidget/</a> <br><br>  Briefly list the main characteristics of jWidget: <br><br>  1. Strict compliance with the principles of the PLO.  A fully documented bilingual class library with examples of tutorials. <br>  2. The speed of the script is above all.  Hence the explicit declaration of the class constructor and the minimal use of closures when declaring classes, since  In Google Chrome, inheritance through prototypes is <a href="http://jsperf.com/class-constructors">much more efficient than</a> inheritance using the Module pattern (in Firefox, on the contrary, but there the difference is not so great). <br>  3. No manipulation in the model requires a complete re-rendering of the view.  Each component is rendered only once, after which it only updates its individual elements, thereby ensuring a high speed of the application. <br>  4. The framework runs on <a href="http://jquery.com/">jQuery</a> . <br>  5. It has the simplest template engine that does not require preprocessing before being sent to the function <a href="https://api.jquery.com/jQuery.parseHTML/">https://api.jquery.com/jQuery.parseHTML/</a> .  No magic in the templates, no inline-code: all Data binding is done in the component's JavaScript code.  Due to this, the same Data binding techniques can be used both for linking a view with a model, and for connecting objects within a model or within a view, which is often helpful. <br>  6. All objects after use are completely destroyed.  This ensures an economical consumption of client resources and the absence of unforeseen errors in the console from "dead" objects trying to handle some event.  For example, you can use the same model for the duration of the application, on the fly changing its presentation.  Any view listens to model events, but after the view is removed from the DOM, it must unsubscribe from these events so as not to waste processor time processing these events and so that the garbage collector can clear the memory.  There is an easy way to destroy objects - the so-called.  object aggregation mechanism. <br>  7. Own application <a href="https://github.com/enepomnyaschih/jwsdk/wiki/ru">builder</a> - <a href="https://github.com/enepomnyaschih/jwsdk/wiki/ru">jWidget SDK</a> - simplifies application development and performs code optimization before release to production.  It is planned to replace it with a stack of plugins for <a href="http://gruntjs.com/">GruntJS</a> .  Just when I started developing jWidget, GruntJS or something like that did not exist. <br><br><blockquote>  To confirm that jWidget is very fast, I measured the time to add 500 entries to TodoMVC with a wait of 0 milliseconds after adding each entry to give the browser time to redraw the view.  Also, I roughly measured the time of the Select all and Clear completed operations for 500 entries.  The results are as follows: <br><br><ul><li>  <b>Angular JS</b> - 16847 milliseconds.  The Select all and Clear completed operations are performed instantly. </li><li>  <b>Angular JS</b> (performance optimized version) - 13287 milliseconds.  The Select all and Clear completed operations are performed instantly. </li><li>  <b>Ember JS</b> - 13095 milliseconds.  The Select all and Clear completed operations take about 3 seconds. </li><li>  <b>Backbone</b> - 9506 milliseconds.  The Select all and Clear completed operations take about 3 seconds. </li><li>  <b>jWidget</b> - 9974 milliseconds.  The Select all and Clear completed operations are performed instantly. </li><li>  <b>YUI</b> - more than a minute.  Not wait. </li></ul><br><br>  As you can see, only Backbone slightly surpassed jWidget in the speed of adding records, but it was far behind the speed of Select all and Clear completed.  At the same time, note that the lag of Angular and Ember in 3 seconds is actually significant, since in all cases a lot of time was consumed by a 500-fold call to setTimeout.  In general, of the 3 most popular frameworks, not one managed to cope with large amounts of data, while jWidget showed itself at the height. </blockquote><br><br>  Now I‚Äôll tell you about the jWidget operation mechanism.  The framework consists of 5 layers: <br><br><ol><li>  <a href="https://habr.com/ru/post/219995/">Classes and objects</a> .  Class inheritance  The mechanism of aggregation of objects. </li><li>  <a href="https://habr.com/ru/post/219995/">Events</a>  Announcement of events.  Subscribe, unsubscribe and generate events. </li><li>  <a href="https://habr.com/ru/post/219995/">Properties and their helpers</a> .  Creating new properties based on existing ones.  Data binding based on properties. </li><li>  <a href="https://habr.com/ru/post/219995/">Collections and their synchronizers</a> .  Array, dictionary, set.  Creating new collections based on existing ones.  Data binding based on collections. </li><li>  <a href="https://habr.com/ru/post/219995/">Components</a> .  Templates  Connection of template elements with the component code.  Creating child components using Data binding based on properties and collections. </li></ol><br><br><h1><a name="class"></a>  1. Classes and objects. </h1><br><br>  Below is an example of a jWidget class declaration.  The class is created by standard inheritance through the prototype, diluted with a small amount of syntactic sugar. <br><br><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  . var Hand = function(side) { //    . Hand._super.call(this); //  . this.side = side; //    ,     . //  ,         . this.grabbedObject = null; }; //  Hand  JW.Class. JW.extend(Hand, JW.Class, { //    ,   . // String side; // Grabbable grabbedObject; //  . grab: function(obj) { this.grabbedObject = obj; }, //    . destroy: function() { console.log("Destroying " + this.side + " hand"); //         _super. this._super(); } });</span></span></code> </pre> <br><br>  One of the key features of <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Class</a> is an object aggregation mechanism that serves to destroy objects that are under the control of another object.  I drew this idea from the introduction to the book <a href="http://ru.wikipedia.org/wiki/Design_Patterns">Object-Oriented Design.</a>  <a href="http://ru.wikipedia.org/wiki/Design_Patterns">Design patterns</a> from the "gang of four."  It says that all pointers to objects are divided into two types: aggregation and awareness.  Awareness means that the object that owns the pointer does not bear any responsibility for the object to which it refers.  He simply has access to his public fields and methods, but the lifetime of this object is not under his control.  Aggregation means that the object owning the link is responsible for the destruction of the object to which it refers.  As a rule, an aggregated object lives while the owner object is alive, although there are more complex cases. <br><br>  In jWidget, the aggregation is implemented through the <a href="http://enepomnyaschih.github.io/jwidget/index.html">own</a> method of the <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Class</a> class.  By passing object B to object A's own method, you made object A to own object B. When object A is destroyed, object B will be destroyed automatically.  For convenience, the own method returns object B. Below is an example of code that uses this feature. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Soldier = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ Soldier._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   .  -   , //   . this.leftHand = this.own(new Hand("left")); this.rightHand = this.own(new Hand("right")); }; JW.extend(Soldier, JW.Class, { // Hand leftHand; // Hand rightHand; destroy: function() { console.log("Destroying soldier"); this._super(); } });</span></span></code> </pre><br><br>  Now we can create a soldier and destroy it by calling the <a href="http://enepomnyaschih.github.io/jwidget/index.html">destroy</a> method. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> soldier = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Soldier(); soldier.destroy();</code> </pre><br><br>  As a result, we will see the following lines in the browser console: <br><br><pre> Destroying soldier
 Destroying right hand
 Destroying left hand
</pre><br><br>  As you can see, when a soldier is destroyed, the hands are destroyed automatically.  Alternatively, we could explicitly destroy the hands in the destroy method of the Soldier class by calling their destroy method.  But aggregation allows us to achieve this with less code.  In general, in a real application, the destroy method has to be overloaded very rarely.  For example, in <a href="https://github.com/enepomnyaschih/todomvc/tree/gh-pages/labs/architecture-examples/jwidget/">my implementation of TodoMVC,</a> this method is never overloaded - everything is achieved by a single object aggregation mechanism. <br><br>  Aggregated objects are destroyed in the reverse order, which guarantees integrity in the presence of connections between them. <br><br><h1><a name="event"></a>  2. Events. </h1><br><br>  Events are an integral part of any MV * framework.  If the view has direct access to the model, then the model knows nothing about the view.  Feedback is carried out in no other way than through events.  Here, standard user interface events such as <i>click</i> , <i>mousedown,</i> or <i>keypress are not meant</i> , but events like <i>‚Äúdocument name has changed‚Äù</i> , <i>‚Äúnew document added to folder‚Äù</i> , <i>‚Äúdocuments in folder are sorted by date‚Äù</i> .  This is not embedded in the standard programming language tools, so this is the task of the framework. <br><br>  As I wrote at the beginning of the article, the speed of the script in jWidget is paramount.  Therefore, the standard subscription scheme for events, which is offered, for example, in jQuery, does not suit us. <br><br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">"#document"</span></span>).bind(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, onClick); $(<span class="hljs-string"><span class="hljs-string">"#document"</span></span>).unbind(<span class="hljs-string"><span class="hljs-string">"click"</span></span>, onClick);</code> </pre><br><br>  The problem here is that the algorithm for unsubscribing from an event has a linear computational complexity (brute force).  I managed to implement a scheme in which the time for unsubscribing from an event is equal to the time for deleting a key from the dictionary, which is much faster.  In addition, the jWidget event scheme is implemented according to all OOP principles and is perfectly combined with the object aggregation mechanism. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Document = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">title</span></span></span><span class="hljs-function">) </span></span>{ Document._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title; <span class="hljs-comment"><span class="hljs-comment">//   . this.titleChangeEvent = this.own(new JW.Event()); }; JW.extend(Document, JW.Class, { // String title; // JW.Event titleChangeEvent; setTitle: function(title) { if (this.title === title) { return; } this.title = title; //  . this.titleChangeEvent.trigger(new JW.ValueEventParams(this, title)); } }); var Client = function(document) { Client._super.call(this); this.document = document; //   .  ,     //     . this.own(document.titleChangeEvent.bind(this._onTitleChange, this)); }; JW.extend(Client, JW.Class, { // Document document; _onTitleChange: function(params) { console.log("Changed title to " + params.value); } }); //  . var doc = new Document("apple"); var client = new Client(doc); doc.setTitle("banana"); // : Changed title to banana doc.setTitle("cherry"); // : Changed title to cherry //    ,  . client.destroy(); doc.destroy();</span></span></code> </pre><br><br>  The event is represented by the <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Event</a> class.  Subscribing to an event is returned by the <a href="http://enepomnyaschih.github.io/jwidget/index.html">bind</a> method as an instance of the <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.EventAttachment</a> class.  Destroying a subscription is equivalent to unsubscribing from an event.  When we throw an event using the <a href="http://enepomnyaschih.github.io/jwidget/index.html">trigger</a> method, we pass an instance of <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.EventParams there</a> to pass it to the event handler as an argument. <br><br><h1><a name="property"></a>  3. Properties and their helpers </h1><br><br>  A framework cannot be called a full-fledged MV * framework if it does not provide Data binding capabilities.  jWidget provides this feature.  Objects of the following classes automatically throw out events about their change, and, therefore, can be used for Data binding: <br><br><ul><li>  <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Property</a> </li><li>  <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.ObservableArray</a> </li><li>  <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.ObservableMap</a> </li><li>  <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.ObservableSet</a> </li></ul><br><br>  I will talk about collections (Array, Map, Set) in the next paragraph, but now I would like to explain what a property ( <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Property</a> ) is.  <b>A property</b> is a "variable" that throws events about a change in its value.  Hence the simplest interface of this class: <br><br><ul><li>  <a href="http://enepomnyaschih.github.io/jwidget/index.html">Get</a> method </li><li>  <a href="http://enepomnyaschih.github.io/jwidget/index.html">Set</a> method </li><li>  Event <a href="http://enepomnyaschih.github.io/jwidget/index.html">changeEvent</a> </li></ul><br><br>  When you pass the value of x to the set method, the property checks to see if it is equal to this value x.  If equal, nothing happens.  If not equal, the property assigns itself to the value x and throws the changeEvent event. <br><br>  Despite the fact that the class interface is simple beyond recognition, it provides ample opportunities for Data binding, which reduces the amount of application code by an order of magnitude.  First, we can link two properties by copying the value of one property to another: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property(<span class="hljs-string"><span class="hljs-string">"apple"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Copier(source, {<span class="hljs-attr"><span class="hljs-attr">target</span></span>: target}); assertEqual(<span class="hljs-string"><span class="hljs-string">"apple"</span></span>, target.get()); source.set(<span class="hljs-string"><span class="hljs-string">"banana"</span></span>); assertEqual(<span class="hljs-string"><span class="hljs-string">"banana"</span></span>, target.get());</code> </pre><br><br>  The <a href="http://enepomnyaschih.github.io/jwidget/index.html">bindTo</a> method does the same thing, which allows us to make the code more understandable.  In addition, I draw your attention to the fact that the target property in this case also throws events about its change, so you can link as many properties as you want along the chain: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property(<span class="hljs-string"><span class="hljs-string">"apple"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property(); target1.bindTo(source); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property(); target2.bindTo(target1); source.set(<span class="hljs-string"><span class="hljs-string">"banana"</span></span>); assertEqual(<span class="hljs-string"><span class="hljs-string">"banana"</span></span>, target2.get());</code> </pre><br><br>  Copying properties on the fly is just the beginning.  Let's try to create a new property based on two existing properties using the formula <code>text = value + " " + unit</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unit = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Property(<span class="hljs-string"><span class="hljs-string">"MW"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> functor = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.Functor([ value, unit ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, unit</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value + <span class="hljs-string"><span class="hljs-string">" "</span></span> + unit; }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = functor.target; assertEqual(<span class="hljs-string"><span class="hljs-string">"1000 MW"</span></span>, target.get()); value.set(<span class="hljs-number"><span class="hljs-number">1500</span></span>); assertEqual(<span class="hljs-string"><span class="hljs-string">"1500 MW"</span></span>, target.get()); unit.set(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    assertEqual("1500 ", target.get());</span></span></code> </pre><br><br>  Finally, we tie the text inside some element of the view to the constructed property: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JW.UI.TextUpdater(<span class="hljs-string"><span class="hljs-string">"#capacity"</span></span>, target);</code> </pre><br><br>  Now when you change the value and unit, you will automatically update the text inside the #capacity element. <br><br>  See the <a href="http://enepomnyaschih.github.io/jwidget/index.html">documentation for a</a> complete list of JW.Property class features. <br><br>  jWidget transfers the usual Data binding through HTML-templates to the JavaScript-code of the application.  This provides tremendous opportunities for optimizing the application and expanding its capabilities.  Data binding is not limited to the layer between the model and the view.  You can easily associate properties within a model and within a view.  The algorithm of the application is completely transparent, and you can control what is connected with what, based on the specific use cases of your application.  It becomes possible to reuse all the functions of the application.  The framework does not perform any precompilation of HTML templates in order to isolate formulas for Data binding from there, thanks to which the speed of the application increases. <br><br>  The property value can be aggregated using the <a href="http://enepomnyaschih.github.io/jwidget/index.html">ownValue</a> method. <br><br><h1><a name="collection"></a>  4. Collections and Synchronizers </h1><br><br>  jWidget introduces 3 native collection classes: <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.AbstractArray</a> , <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.AbstractMap</a> and <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.AbstractSet</a> .  This does not mean that you are not allowed to use native Array and Object - jWidget collections are easily converted to native and vice versa.  Each jWidget collection has two implementations ‚Äî simple and notifying: <br><br>  - <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.AbstractArray</a> : <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Array</a> and <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.ObservableArray</a> <br>  - <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.AbstractMap</a> : <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Map</a> and <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.ObservableMap</a> <br>  - <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.AbstractSet</a> : <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Set</a> and <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.ObservableSet</a> <br><br>  Simple collections work a little faster than notifying, but alerting collections emit events about their change, which makes Data binding freely applied to them.  Also, classes of simple collections have an identical set of static methods that are designed to perform the same operations with native Array and Object.  As an example, I will give the operation of creating an array of view objects by an array of model objects: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// @param {JW.AbstractArray} documents function createDocumentViews(documents) { return documents.$map(function(document) { return new DocumentView(document); }, this); }</span></span></code> </pre><br><br>  In doing so, we simply created a new instance of JW.Array and filled it with view objects.  No connection between arrays of documents and their representations has been preserved, so a change in the documents array will not entail a change in the array of representations.  To link them together, you need to configure Data binding.  In jWidget this is done by creating a synchronizer.  In this case, you need to create a <a href="http://enepomnyaschih.github.io/jwidget/index.html">mapper</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createDocumentViews</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">documents</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> documents.createMapper({ <span class="hljs-attr"><span class="hljs-attr">createItem</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">document</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentView(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">destroyItem</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">documentView</span></span></span><span class="hljs-function">) </span></span>{ documentView.destroy(); }, <span class="hljs-attr"><span class="hljs-attr">scope</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }).target; }</code> </pre><br><br>  As you can see, instead of one kollbek we now transfer two.  The second callback is needed so that Mapper can destroy the presentation of the document if it is deleted from the documents array.  The mapper forms the <a href="http://enepomnyaschih.github.io/jwidget/index.html">target</a> array and keeps it in full accordance with the source array.  When destroying the Mapper, he will destroy all remaining views in the target ... By the way, we forgot to destroy the Mapper.  We use aggregation: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DocumentList = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">documents</span></span></span><span class="hljs-function">) </span></span>{ DocumentList._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.documentViews = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createDocumentViews(documents); }; JW.extend(DocumentList, JW.Class, { <span class="hljs-attr"><span class="hljs-attr">createDocumentViews</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">documents</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(documents.createMapper({ <span class="hljs-attr"><span class="hljs-attr">createItem</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">document</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DocumentView(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>); }, <span class="hljs-attr"><span class="hljs-attr">destroyItem</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">documentView</span></span></span><span class="hljs-function">) </span></span>{ documentView.destroy(); }, <span class="hljs-attr"><span class="hljs-attr">scope</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> })).target; } });</code> </pre><br><br>  Notice how the round brackets stand.  We aggregate Mapper, and we return its target. <br><br>  The <a href="http://enepomnyaschih.github.io/jwidget/index.html">createMapper</a> method works for both JW.Array and JW.ObservableArray.  Only in the first case, it will not be able to perform persistent data binding, since JW.Array does not throw out any events.  But on the other hand, you can develop an absolutely polymorphic solution with the possibility of replacing JW.Array with JW.ObservableArray at any time, if necessary. <br><br>  jWidget provides a wide range of synchronizers.  See the complete list in the <a href="http://enepomnyaschih.github.io/jwidget/index.html">documentation</a> . <br><br>  Elements of the collection can be aggregated using the <a href="http://enepomnyaschih.github.io/jwidget/index.html">ownItems</a> method. <br><br><h1><a name="component"></a>  5. Components </h1><br><br>  Finally got to the presentation.  jWidget provides the <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.UI.Component</a> class as the base class for all view components.  Each component class has its own template, which is inherited along with this class.  A template is plain HTML with 2 new attributes added: <i>jwclass</i> and <i>jwid</i> .  The template is bound to the component class using the <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.UI.template</a> method. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyComponent = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message, link</span></span></span><span class="hljs-function">) </span></span>{ MyComponent._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.message = message; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.link = link; }; JW.extend(MyComponent, JW.UI.Component, { <span class="hljs-comment"><span class="hljs-comment">// String message; // String link; renderComponent: function() { this._super(); this.getElement("hello-message").text(this.message); this.getElement("link").attr("href", this.link); } }); JW.UI.template(MyComponent, { main: '&lt;div jwclass="my-component"&gt;' + '&lt;div jwid="hello-message" /&gt;' + '&lt;a href="#" jwid="link"&gt;Click me!&lt;/a&gt;' + '&lt;/div&gt;' });</span></span></code> </pre><br><br>  The jwclass attribute is set only for the root element of the component, and it is a prefix to the CSS classes of elements.  The jwid attribute is a suffix to the CSS class of this element.  For example, the above template will expand into the following HTML: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-component"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-component-hello-message"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"my-component-link"</span></span></span><span class="hljs-tag">&gt;</span></span>Click me!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  To render a component in the DOM, you can use the following statement: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> component = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyComponent(<span class="hljs-string"><span class="hljs-string">"Hello, Wanderer!"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://google.com"</span></span>); component.renderTo(<span class="hljs-string"><span class="hljs-string">"body"</span></span>);</code> </pre><br><br>  In the component code, you can see that using the <a href="http://enepomnyaschih.github.io/jwidget/index.html">getElement</a> method, you can get the jQuery wrapper of an element by its jwid. <br><br>  The <a href="http://enepomnyaschih.github.io/jwidget/index.html">renderComponent</a> method is a component's life cycle method.  By overloading it, you can manipulate the elements of the component and create child components. <br><br>  Child components are of three types: <br><br><ol><li>  Named child components </li><li>  Easily replaceable child components </li><li>  Arrays of child components </li></ol><br><br>  <b>Named child components</b> completely replace the specified template elements.  For example, let an application consist of a title and content.  Design them with named child components.  This is done by adding them to the <a href="http://enepomnyaschih.github.io/jwidget/index.html">children</a> dictionary: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Application = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ Application._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }; JW.extend(Application, JW.UI.Component, { <span class="hljs-attr"><span class="hljs-attr">renderComponent</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._super(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Header()), <span class="hljs-string"><span class="hljs-string">"header"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.children.set(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.own(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Content()), <span class="hljs-string"><span class="hljs-string">"content"</span></span>); } }); JW.UI.template(Application, { <span class="hljs-attr"><span class="hljs-attr">main</span></span>: <span class="hljs-string"><span class="hljs-string">'&lt;div jwclass="application"&gt;'</span></span> + <span class="hljs-string"><span class="hljs-string">'&lt;div jwid="header" /&gt;'</span></span> + <span class="hljs-string"><span class="hljs-string">'&lt;div jwid="content" /&gt;'</span></span> + <span class="hljs-string"><span class="hljs-string">'&lt;/div&gt;'</span></span> });</code> </pre><br><br>  The title and content will be rendered and will replace the ‚Äúheader‚Äù and ‚Äúcontent‚Äù elements.  You can add and remove components from the dictionary on the fly, thereby manipulating the contents of the component. <br><br>  <b>Easily replaceable child components</b> are similar to the named ones, but they are based on JW.Property.  They are added by the <a href="http://enepomnyaschih.github.io/jwidget/index.html">addReplaceable</a> method.  Such components are conveniently rendered using <a href="http://enepomnyaschih.github.io/jwidget/index.html">JW.Mapper</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Application = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">selectedDocument</span></span></span><span class="hljs-function">) </span></span>{ Application._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedDocument = selectedDocument; }; JW.extend(Application, JW.UI.Component, { <span class="hljs-comment"><span class="hljs-comment">// JW.Property selectedDocument; renderComponent: function() { this._super(); var documentView = this.own(new JW.Mapper([ this.selectedDocument ], { createValue: function(document) { return new DocumentView(document); }, destroyValue: function(documentView) { documentView.destroy(); }, scope: this })).target; this.addReplaceable(documentView, "document"); } }); JW.UI.template(Application, { main: '&lt;div jwclass="application"&gt;' + '&lt;div jwid="document" /&gt;' + '&lt;/div&gt;' });</span></span></code> </pre><br><br>  Thus, we implemented Data binding to the selectedDocument property.  If you change the value of this property, the representation of the old document will be automatically destroyed, and the representation of the new document will be created and take the place of the old one. <br><br>  <b>Arrays of child components</b> are based on JW.AbstractArray.  They are added by the <a href="http://enepomnyaschih.github.io/jwidget/index.html">addArray</a> method.  If the array is JW.ObservableArray, then the method will provide continuous synchronization of the view with this array.  Arrays of child components are conveniently rendered via the createMapper method: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Application = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">documents</span></span></span><span class="hljs-function">) </span></span>{ Application._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.documents = documents; }; JW.extend(Application, JW.UI.Component, { <span class="hljs-comment"><span class="hljs-comment">// JW.AbstractArray documents; renderComponent: function() { this._super(); var documentViews = this.own(this.documents.createMapper({ createItem: function(document) { return new DocumentView(document); }, destroyItem: function(documentView) { documentView.destroy(); }, scope: this })).target; this.addArray(documentViews, "documents"); } }); JW.UI.template(Application, { main: '&lt;div jwclass="application"&gt;' + '&lt;div jwid="documents" /&gt;' + '&lt;/div&gt;' });</span></span></code> </pre><br><br>  Unlike named and easily replaceable child components, an array does not replace the specified element, but adds child components inside this element.  So, you can add an array of child components directly to the root element of the component, by passing the second argument of the addArray method. <br><br>  For convenience, jWidget allows you to define the renderChildId method, where ChildId is the jwid element recorded in CamelCase with a capital letter.  The method accepts a template element as input.  Below are the various features of this method: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Application = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">title, documents, selectedDocument</span></span></span><span class="hljs-function">) </span></span>{ Application._super.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.documents = documents; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.selectedDocument = selectedDocument; }; JW.extend(Application, JW.UI.Component, { <span class="hljs-comment"><span class="hljs-comment">// JW.Property&lt;String&gt; title; // JW.AbstractArray&lt;Document&gt; documents; // JW.Property&lt;Document&gt; selectedDocument; //     ,       . renderTitle: function(el) { this.own(new JW.UI.TextUpdater(el, this.title)); }, //    JW.UI.Component,     . renderHeader: function() { return this.own(new Header()); }, //    JW.AbstractArray,     . renderDocumentList: function() { return this.own(this.documents.createMapper({ createItem: function(document) { return new DocumentListItem(document); }, destroyItem: JW.destroy, //  scope: this })).target; }, //    JW.Property,      . renderSelectedDocument: function() { return this.own(new JW.Mapper([ this.selectedDocument ], { createValue: function(document) { return new DocumentPanel(document); }, destroyValue: JW.destroy, //  scope: this })).target; }, //    false,       DOM renderHappyNewYear: function() { return new Date().getMonth() === 0; } }); JW.UI.template(Application, { main: '&lt;div jwclass="application"&gt;' + '&lt;div jwid="title" /&gt;' + '&lt;div jwid="header" /&gt;' + '&lt;div jwid="document-list" /&gt;' + '&lt;div jwid="selected-document" /&gt;' + '&lt;div jwid="happy-new-year"&gt;Happy new year!&lt;/div&gt;' + '&lt;/div&gt;' });</span></span></code> </pre><br><br>  The HTML component template can be rendered into a separate HTML file using the <a href="https://github.com/enepomnyaschih/jwsdk/wiki/ru">jWidget SDK</a> .  Read more about this in the <a href="http://enepomnyaschih.github.io/jwidget/0.9.0/index.html">Infrastructure</a> section of the <a href="http://enepomnyaschih.github.io/jwidget/0.9.0/index.html">project</a> manual.  If the framework finds success, I plan to create a plugin for GruntJS that would replace the jWidget SDK.  <a href="http://habrahabr.ru/post/140034/">I wrote</a> about the jWidget SDK <a href="http://habrahabr.ru/post/140034/">earlier</a> , but it did not find much support.  And now the equivalent GruntJS project appeared, which immediately found enormous support and formed a community.  So I turn off the development of the jWidget SDK. <br><br>  Hope this article was of interest to you.  I am quite sure that among JavaScript programmers there will be those who, like me, are fan of real object-oriented programming and appreciate the high speed of code execution.  If this is you, try jWidget in your work, and you will not be disappointed.  Even with a huge amount of MV * frameworks, I still prefer jWidget.  I spend a lot of effort on maintaining documentation, a beginner‚Äôs guide and dense unit test coverage.  If you want the project to further develop and grow, do not be lazy to put a star on <a href="https://github.com/enepomnyaschih/jwidget">GitHub</a> and follow me on Twitter <a href="https://twitter.com/jwidgetproject">@jwidgetproject</a> .  Also, I appreciate constructive criticism and good suggestions.  Thank. <br></div><p>Source: <a href="https://habr.com/ru/post/219995/">https://habr.com/ru/post/219995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../219985/index.html">SpaceX space truck Dragon from successfully launched for the ISS for the third time</a></li>
<li><a href="../219987/index.html">The first launch of the SpaceX Falcon-9 rocket with folding supports for landing was successful</a></li>
<li><a href="../219989/index.html">History of checkers (in illustrations)</a></li>
<li><a href="../219991/index.html">Telepresence Tod Bot - go for coffee without getting up from the table</a></li>
<li><a href="../219993/index.html">Encoding of binary data into a string with an arbitrary length alphabet (BaseN)</a></li>
<li><a href="../219997/index.html">Serialization of objects in MultiCAD.NET. Management of compatibility of drawings and proxies</a></li>
<li><a href="../219999/index.html">Arbitrary order of template initialization list</a></li>
<li><a href="../220001/index.html">Kenju fork Kendo UI Web (GPL3)</a></li>
<li><a href="../220003/index.html">How browsers implement digital certificate revocation</a></li>
<li><a href="../220005/index.html">Some interesting and useful things for web developer # 16</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>