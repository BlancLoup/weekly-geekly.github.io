<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Node.js on fire</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We are creating a new generation of Netflix.com web application using node.js. You can learn more about our campaign from the presentation that we pre...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Node.js on fire</h1><div class="post__text post__text-html js-mediator-article">  We are creating a new generation of Netflix.com web application using node.js.  You can learn more about our campaign from the <a href="https://www.youtube.com/watch%3Fv%3DgtjzjiTI96c%26list%3DPLfXiENmg6yyUpIVY9XVOkbdmBPx6PUm9_">presentation</a> that we presented at NodeConf.eu a few months ago.  Today I want to share my experience in tuning the performance of a new stack of our application. <br><br>  We first encountered problems when we noticed that the delay in the request in our node.js application increases over time.  In addition, it used more processor resources than we expected, and this correlated with the delay time.  We had to use the reboot as a temporary solution while we were looking for a reason with the help of new tools and performance analytics techniques in our Linux EC2 environment. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  The fire is burning </h4><br><br>  We noticed that the request delay in our node.js application increases over time.  So, on some of our servers, the delay grew from 1 millisecond to 10 milliseconds every hour.  We also saw the dependence of increasing CPU utilization. <br><br><img src="https://habrastorage.org/files/21d/9fd/663/21d9fd66375e4b1e9b42fb516aef0422.png" alt="image"><br><br>  This graph shows the request delay in milliseconds relative to time.  Each color denotes a different copy of AWS AZ.  You can see that the delay is constantly increasing by 10 milliseconds per hour and reaches 60 milliseconds before rebooting. <br><br><h4>  Fire extinguishing </h4><br><br>  Initially, we assumed that these could be memory leaks in our own request handlers, which, in turn, caused delays.  We tested this assumption by using load testing of an isolated application by adding metrics to measure delays only on our request handlers and the total request delay time, and also increasing the memory used in node.js to 32 gigabytes. <br><br>  We found out that the delay in our handlers remains constant and equals 1 millisecond.  We also found that the amount of memory used by the process also remains unchanged, reaching approximately 1.2 gigabytes.  Nevertheless, the overall delay and processor usage continued to grow.  This meant that our handlers had nothing to do with it, and the problems are deeper on the stack. <br><br>  Something added an extra 60 milliseconds to query service.  We needed a way to profile the CPU usage of the application and visualize the data.  We came to the aid of Linux <a href="https://perf.wiki.kernel.org/index.php/Main_Page">Perf Events</a> and flame graphs processor. <br><br>  If you are not familiar with flame graphs, then I advise you to read Brendan Gregg's <a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">excellent article</a> in which he explains everything in detail.  Here is its summary (directly from the article): <br><ul><li>  Each block denotes a function on the stack (stack frame) </li><li>  The y-axis indicates the stack depth (the number of frames in the stack).  The upper block denotes the function that was executed by the processor, all that is lower is its call stack. </li><li>  The X axis indicates the number of function calls.  It does not show the amount of time spent by the function, as on most graphs.  The order of location does not matter, the blocks are simply sorted in lexicographical order. </li><li>  The width of the block shows the total execution time of the function by the processor or part of the execution time of the function that called it.  Wide function blocks can be performed more slowly than narrow ones, and can simply be called more often. </li><li>  The number of calls may exceed the time if the function was executed in several threads. </li><li>  Colors have no special meaning and are determined in random order from ‚Äúwarm‚Äù tones.  Flame graphs <i>[literally "flame graphics";</i>  <i>approx.</i>  <i>translator]</i> are called so because they show the ‚Äúhottest‚Äù places in the application code. </li></ul><br><br>  Previously, node.js flame graphs could only be used on DTrace systems in conjunction with <a href="http://dtrace.org/blogs/dap/2012/04/25/profiling-node-js/">jstack ()</a> from Dave Pacheco.  However, the Google V8 team recently added support for perf_events to the V8 engine, which allows profiling JavaScript on Linux.  In <a href="http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html">this</a> article, Brendan described the use of a new feature that appeared in node.js 0.11.13 to create flame graphs in Linux. <br><br><img src="https://habrastorage.org/files/b4b/fbc/965/b4bfbc9651be4649a6fab7a73e130c6c.png" alt="image"><br><br>  From this <a href="">link</a> you can see the original interactive flame graph of our application in SVG. <br><br>  Immediately, you can note the incredibly large stacks in the application (Y-axis).  It is also obvious that they have a lot of time (axis X).  Upon closer inspection, it will <code>route.handle</code> that these stack frames are full of references to the <code>route.handle</code> and <code>route.handle.next</code> from <a href="http://expressjs.com/">Express</a> . <br><br>  We found two interesting points in the Express source code <sup><a href="https://habr.com/ru/post/243945/">1</a></sup> : <br><ul><li>  Route handlers for all paths are stored in one <b>global array.</b> </li><li>  Express recursively iterates and calls all handlers until it finds a suitable route. </li></ul><br><br>  A global array is not the most appropriate data structure in this case, since in order to find a route, on average, <i>O (n)</i> operations are required.  It is not clear why the Express developers decided not to use a constant data structure, for example, a hash table for storing handlers.  Compounding the situation and the fact that the array is treated recursively.  This explains why we have seen such high stacks in flame graphs.  Another interesting fact is that Express allows you to install multiple handlers for a single route. <br><br><pre> <code class="javascript hljs">[a, b, c, c, c, c, d, e, f, g, h]</code> </pre><br><br>  In this case, the search for route <code>c</code> would be terminated when the first suitable handler was found (position 2 in the array).  However, in order to find the route handler <code>d</code> (position 6 in the array), it would be necessary to spend extra time calling several instances <code>c</code> .  We checked it with a simple Express application: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> express = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'express'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = express(); app.get(<span class="hljs-string"><span class="hljs-string">'/foo'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">req, res</span></span></span><span class="hljs-function">) </span></span>{ res.send(<span class="hljs-string"><span class="hljs-string">'hi'</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">//         app.get('/foo', function (req, res) { res.send('hi2'); }); console.log('stack', app._router.stack); app.listen(3000);</span></span></code> </pre><br><br>  Once launched, the application displays these handlers: <br><br><pre> <code class="javascript hljs">stack [ { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">regexp</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/^\/?(?=/</span></span>|$)/i, <span class="hljs-attr"><span class="hljs-attr">handle</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>: query] }, { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">regexp</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/^\/?(?=/</span></span>|$)/i, <span class="hljs-attr"><span class="hljs-attr">handle</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>: expressInit] }, { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">regexp</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/^\/foo\/?$/i</span></span>, <span class="hljs-attr"><span class="hljs-attr">handle</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>], <span class="hljs-attr"><span class="hljs-attr">route</span></span>: { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>], <span class="hljs-attr"><span class="hljs-attr">methods</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>] } }, { <span class="hljs-attr"><span class="hljs-attr">keys</span></span>: [], <span class="hljs-attr"><span class="hljs-attr">regexp</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/^\/foo\/?$/i</span></span>, <span class="hljs-attr"><span class="hljs-attr">handle</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Function</span></span>], <span class="hljs-attr"><span class="hljs-attr">route</span></span>: { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: <span class="hljs-string"><span class="hljs-string">'/foo'</span></span>, <span class="hljs-attr"><span class="hljs-attr">stack</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>], <span class="hljs-attr"><span class="hljs-attr">methods</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>] } } ]</code> </pre><br><br>  Note that there are two identical handlers for the <code>/foo</code> route.  It would be nice if Express threw an error every time one route has multiple handlers. <br><br>  Now our assumption was that delays occurred due to the constant increase in the array with handlers.  Most likely, handlers were duplicated somewhere in our code.  We added additional logging, which output an array of request handlers, and noticed that it grows 10 elements per hour.  These handlers were identical to each other, as in the example above. <br><br>  Something added to the application 10 identical handlers for static routes per hour.  Next, we found that when iterating through these handlers, the cost of calling each of them takes about 1 millisecond.  This correlates with what we saw earlier, when the response latency grew by 10 milliseconds per hour. <br><br>  It turned out that this was caused by a periodic (10 times per hour) update of handlers in our code from an external source.  We implemented this by removing the old handlers and adding new ones to the array.  Unfortunately, we also always added a handler for the static route during this operation.  Since Express allows you to add multiple handlers for one route, all these duplicates were added to the array.  Worst of all, they were all added before the others, which meant that before Express found the API handler for our service, it would call the handler for the static route several times. <br><br>  This fully explains why request delays grew by 10 milliseconds per hour.  In fact, after we eliminated the error in our code, the constant increase in the delay time and the increase in CPU usage ceased. <br><br><img src="https://habrastorage.org/files/94d/f72/10f/94df7210fc8c4763811bd5456a8a864a.png" alt="image"><br><br>  This graph shows that the delay time was reduced to one millisecond after the code was updated. <br><br><h4>  When the smoke cleared </h4><br><br>  What kind of experience have we got?  First, we must fully understand how the dependencies in our code are arranged before using it in production.  We made a wrong assumption about the operation of the Express API without examining its code.  Improper use of the Express API is the ultimate cause of our performance problems. <br><br>  Secondly, visibility is paramount in solving performance problems.  Flame graphs gave us a tremendous understanding of where our application spends the most CPU time and resources.  I can't imagine how we could solve this problem by not being able to get the node.js stacks and visualize them using flame graphs. <br><br>  Wanting to improve visibility, we migrate to <a href="http://mcavage.me/node-restify/">Restify</a> , which will allow us to improve our control over our application <sup><a href="https://habr.com/ru/post/243945/">2</a></sup> .  This is beyond the scope of this article, so read our blog on how we use node.js in Netflix. <br><br>  Want to solve similar problems with us?  Our team is <a href="http://jobs.netflix.com/jobs.php%3Fid%3DNFX01717">looking for an engineer</a> to work with the node.js stack. <br><br>  Posted by: Yunong Xiao <a href="https://twitter.com/YunongX">@yunongx</a> <br><br>  Notes: <br><ol><li><a name="footnote-1"></a>  In particular, this <a href="">code snippet</a> .  Note that the <code>next()</code> function is called recursively to iterate through the array of handlers. </li><li><a name="footnote-2"></a>  Restify provides many mechanisms for getting the best visibility of our application, from <a href="http://mcavage.me/presentations/dtrace_conf_2012-04-03/">DTrace</a> support to <a href="https://github.com/trentm/node-bunyan">node-bunyan</a> c integration. </li></ol><br><br>  <i>Translator's Notes:</i> <br><ol><li>  I have nothing to do with Netflix.  But I left the link to the vacancy intentionally, I will be sincerely glad if it is useful to someone. </li><li>  The comments to the original article explain why Express does not use hash tables as a data structure for storing handlers.  The reason lies in the fact that the regular expression by which the required handler is selected cannot be the key in the hash table.  And if you store it as a string, you will also have to compare all the keys from the hash table (although this does not negate the fact that if you add a second handler to the route, you could throw at least a warning). </li><li>  You can also read the detailed <a href="https://gist.github.com/hueniverse/a3109f716bf25718ba0e">answer from</a> Eran Hammer (one of the contributors to <a href="http://hapijs.com/">hapi</a> ) and the discussion that followed. </li></ol><br><br>  Comments and comments regarding the translation are welcome in personal messages. <br><br>  <b>UPD</b> : attentive readers noticed that the translator did a wrong transcription of the author's name of the original article.  Thanks for the <a href="https://habrahabr.ru/users/domix32/" class="user_link">domix32</a> and <a href="https://habrahabr.ru/users/lany/" class="user_link">lany tips</a> . </div><p>Source: <a href="https://habr.com/ru/post/243945/">https://habr.com/ru/post/243945/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243933/index.html">Using TTreeView in Firemonkey Applications</a></li>
<li><a href="../243937/index.html">Overview of the Hantek DSO-6022BL USB Oscilloscope with a Logic Analyzer and Diffuser</a></li>
<li><a href="../243939/index.html">Media Restart: Overview</a></li>
<li><a href="../243941/index.html">A pair of small life hacking search for products in the online store</a></li>
<li><a href="../243943/index.html">Conference materials on Wolfram technologies: Wolfram Language, Mathematica 10, SystemModeler 4, Wolfram Cloud</a></li>
<li><a href="../243947/index.html">An article about the untypical exploitation of SQL injections and a trick in sqlmap. And also about Counter Strike</a></li>
<li><a href="../243953/index.html">Docker in the browser, or how to create and "share" the development environment</a></li>
<li><a href="../243955/index.html">The digest of interesting materials for the mobile developer # 80 (November 17-23)</a></li>
<li><a href="../243961/index.html">Python Web Development through the eyes of a PHP programmer</a></li>
<li><a href="../243963/index.html">Open tab in Chrome</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>