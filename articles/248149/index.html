<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>2D lighting system for Unity3D running on a GPU</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. As you know, Unity3D lacks lighting support for 2D games. In the Asset Store, you can find such a system , but it has one drawback - it runs on...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>2D lighting system for Unity3D running on a GPU</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/bda/d1e/005/bdad1e005c6c4651aa24b21925f8fda1.png"><br><br>  Hello.  As you know, Unity3D lacks lighting support for 2D games.  In the Asset Store, you can find <a href="https://www.assetstore.unity3d.com/en/">such a system</a> , but it has one drawback - it runs on the CPU and consumes a lot of resources (64-4096 raikes per frame to each light source).  Therefore, I decided to make my own lighting, the performance of which would be enough for mobile devices.  For this, the calculations were transferred to the GPU.  It turned out something similar light Terraria or Starbound. <br><a name="habracut"></a><br>  <a href="http://webplayerbuild.ru/view.php%3Fid%3D758597">Link to the demo.</a>  Arrows - movement, space - chassis, R - restart.  Screenshots are taken from it. <br><br>  All lighting is considered on small textures, in the example 160x88 pixels are used.  If you increase the resolution, you can achieve a very fine grid, which will be difficult to see, although this is no longer for mobile platforms.  Due to the fact that calculations are made on such small textures, you can use rather heavy shaders. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Three cameras are used for lighting, each of which is responsible for its own part of the system: light sources, light obstacles, and ambient light.  Then the light sources and the ambient light are mixed and superimposed on the game camera. <br><br>  Now more, in order of rendering. <br><br><h3>  Light obstacles </h3><br><img src="https://habrastorage.org/files/f97/04e/1c8/f9704e1c89e848a0820a98b2f87bd54b.png"><br>  <i>The texture of the obstacles of light.</i>  <i>RGB channels.</i>  <i>This and subsequent similar textures have a scale of 400%.</i> <br><br>  This is the texture of the camera.  The black areas are completely transparent, the white areas are completely opaque.  Color areas are also supported, for example, a completely red pixel will block the red part of the light and skip the green and blue. <br><br><h3>  Light of the environment </h3><br><img src="https://habrastorage.org/files/e98/d52/c43/e98d52c430b645bbad09c088d1bac23e.png"><br>  <i>Ambient light sources</i> <br><br><img src="https://habrastorage.org/files/8c6/99b/1dc/8c699b1dccbc4ede9266531975dd82ca.png"><br>  <i>Sources of light environment.</i>  <i>Alpha channel</i> <br><br><img src="https://habrastorage.org/files/e5f/0a5/a28/e5f0a5a28ceb45f4b60f68f89077e17e.png"><br>  <i>Iteratively generated ambient light texture</i> <br><br><img src="https://habrastorage.org/files/daf/f9d/c42/daff9dc42609471ebfd9ee80d2f7beb5.png"><br>  <i>This is a slightly enhanced ambient light, without the usual light sources.</i> <br><br>  It's all a bit more complicated.  I implemented this type of lighting in order to add weak light to the space where there are no light sources.  In the example, with the help of it, a soft illumination of all free space is implemented.  RGB channel controls the color, alpha channel luminous intensity.  The main difference between this type of light and ordinary sources is that it is considered iterative and has no direction. <br><br>  <i>Calculation algorithm for one pixel:</i> <br><br><ol><li>  Take the initial pixel value from the previous iterative texture. </li><li>  Subtract from the pixel the strength of the obstacles from the texture of the obstacles. </li><li>  Add to the pixel the power of the glow from the texture of the surrounding light sources. </li><li>  Add to pixel the average value of the neighboring pixels </li></ol><br><br><h3>  Sources of light </h3><br><img src="https://habrastorage.org/files/d4e/727/856/d4e72785668840eda8671e2bbb848234.png"><br>  <i>Sources of light</i> <br><br>  Conventional sources - the main part of the lighting system.  For their drawing uses something like sprites.  All color comes from the center, although if desired, the point can be moved anywhere. <br>  For light sources, several shaders are available with a trace path and one without it.  Traced shaders differ in the number of points traced.  I use two such - one on 9 points, working with Shader Model 2.0, another on 20 points for Shader Model 3.0.  A shader without path tracing is used for particle systems, since it does not need any additional information to work. <br><br>  <i>Path Tracing Algorithm:</i> <br><br><ol><li>  Take the pixel brightness of the texture. </li><li>  Find the position of the light source and the current pixel in the texture of the obstacles. </li><li>  Reduce the current brightness by the pixel values ‚Äã‚Äãof the obstacles that lie between two points from the previous step. </li></ol><br><div class="spoiler">  <b class="spoiler_title">9 point tracing shader</b> <div class="spoiler_text"><pre><code class="cpp hljs">Shader <span class="hljs-string"><span class="hljs-string">"Light2D/Light 9 Points"</span></span> { Properties { _MainTex (<span class="hljs-string"><span class="hljs-string">"Light texture"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>D) = <span class="hljs-string"><span class="hljs-string">"white"</span></span> {} _ObstacleMul (<span class="hljs-string"><span class="hljs-string">"Obstacle Mul"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">500</span></span> _EmissionColorMul (<span class="hljs-string"><span class="hljs-string">"Emission color mul"</span></span>, Float) = <span class="hljs-number"><span class="hljs-number">1</span></span> } SubShader { Tags {<span class="hljs-string"><span class="hljs-string">"Queue"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span> <span class="hljs-string"><span class="hljs-string">"IgnoreProjector"</span></span>=<span class="hljs-string"><span class="hljs-string">"True"</span></span> <span class="hljs-string"><span class="hljs-string">"RenderType"</span></span>=<span class="hljs-string"><span class="hljs-string">"Transparent"</span></span>} LOD <span class="hljs-number"><span class="hljs-number">100</span></span> Blend OneMinusDstColor One Cull Off ZWrite Off Lighting Off Pass { CGPROGRAM <span class="hljs-comment"><span class="hljs-comment">// Upgrade </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">NOTE:</span></span></span><span class="hljs-comment"> excluded shader from DX11 and Xbox360; has structs without semantics (struct v2f members sp) #pragma exclude_renderers d3d11 xbox360 #pragma vertex vert #pragma fragment frag #pragma glsl_no_auto_normalization #include "UnityCG.cginc" struct appdata_t { float4 vertex : POSITION; float2 texcoord : TEXCOORD0; fixed4 color : COLOR0; fixed4 normal : TEXCOORD1; }; struct v2f { float4 vertex : SV_POSITION; half2 texcoord : TEXCOORD0; fixed4 color : COLOR0; half4 scrPos : TEXCOORD2; half4 scrPosCenter : TEXCOORD1; }; sampler2D _ObstacleTex; sampler2D _MainTex; half _ObstacleMul; half _EmissionColorMul; v2f vert (appdata_t v) { v2f o; o.vertex = mul(UNITY_MATRIX_MVP, v.vertex); o.texcoord = v.texcoord; o.scrPos = ComputeScreenPos(o.vertex); o.scrPosCenter = v.normal; o.color = v.color; return o; } fixed3 maximize(fixed3 vec){ vec = max(vec, fixed3(0.01, 0.01, 0.01)); return vec/max(vec.x, max(vec.y, vec.z)); } half sum(half3 vec){ return vec.x + vec.y + vec.z; } fixed4 frag (v2f i) : COLOR { fixed2 thisPos = (i.scrPos.xy/i.scrPos.w); fixed2 centerPos = i.scrPosCenter; const fixed sub = 0.111111111111; fixed m = _ObstacleMul*length((thisPos - centerPos)*fixed2(_ScreenParams.x/_ScreenParams.y, 1)*sub); fixed4 tex = tex2D(_MainTex, i.texcoord); clip(tex.a - 0.005); fixed4 col = i.color*fixed4(tex.rgb, 1)*tex.a; fixed pos = 1; pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); pos -= sub; col *= saturate(1 - tex2D(_ObstacleTex, lerp(centerPos, thisPos, pos))*m); col.rgb *= _EmissionColorMul; return col; } ENDCG } } }</span></span></code> </pre> <br></div></div><br><br><h3>  <b>Mixing and blending light</b> </h3><br><img src="https://habrastorage.org/files/6a9/388/511/6a9388511d414eaaa5aa6200c3d29003.png"><br>  <i>Light Sources + Environment Light</i> <br><br>  After the light sources and the ambient light are rendered, you can mix them with each other.  For this, textures are multiplied by their alpha and added together.  Then all this is superimposed on the image of the game and displayed on the screen. <br><br> <a href=""><img width="400" src="https://habrastorage.org/files/a5c/50e/2ab/a5c50e2ab60e4a11b965617c51559e9a.png"></a> <a href=""><img width="400" src="https://habrastorage.org/files/044/92f/627/04492f6274b14954a5c6049dd846dc48.png"></a> <a href=""><img width="400" src="https://habrastorage.org/files/dfe/728/89c/dfe72889c8e548f5aeebb8ca6bc9484f.png"></a> <a href=""><img width="400" src="https://habrastorage.org/files/d20/53b/6c6/d2053b6c68bb4cc0b24a35b34db3ea58.png"></a> <br>  <i>Screenshots of the result, higher resolution on click.</i> <br><br><h3>  <b>And finally, the pros and cons</b> </h3><br>  Pros: <br><ul><li>  Calculations take place on the GPU. </li><li>  Light sources are regular sprites, respectively, you can make a light source of any shape. </li><li>  Each light source consumes very few resources. </li><li>  Works on mobile devices, consuming ~ 8 ms per frame on Nexus 4. </li><li>  Fully dynamic lighting.  Obstacles can be created and destroyed on the fly without any loss of performance. </li><li>  Support for ambient light. </li><li>  The system itself generates 6 DrawCalls, all light sources can fit one plus one more for the ambient light. </li><li>  Multi-colored light sources and obstacles. </li><li>  The ability to emit light sources in the particle system.  Performance is almost the same as ordinary particle. </li><li>  Flexible quality settings. </li></ul><br>  Minuses: <br><ul><li>  The system illuminates the grid, in consequence of which small obstacles can be ignored.  On powerful platforms, you can make the grid very small. </li><li>  It is necessary to generate meshes for ambient light and obstacles. </li><li>  The size of the cameras in which the lighting is created must be larger than the size of the game camera so that the light sources behind the screen are correctly displayed. </li><li>  The computational complexity of the system is almost independent of the number of sources.  This means that if it consumes 8 ms per frame with 10 light sources, then without sources it will consume about 8 ms. </li></ul><br><br>  PS In the presence of community interest, I will finalize and post it in the Asset Store. <br>  PPS posted, <a href="https://www.assetstore.unity3d.com/en/">here is the link</a> <br>  PPPS is now free and open-source.  <a href="https://github.com/SSS135/Light2D">Github</a> </div><p>Source: <a href="https://habr.com/ru/post/248149/">https://habr.com/ru/post/248149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248135/index.html">High DPI values ‚Äã‚Äãin Windows</a></li>
<li><a href="../248137/index.html">Annotation to "Effective Modern C ++" by Scott Myers</a></li>
<li><a href="../248139/index.html">IO.js or old rake with new sauce</a></li>
<li><a href="../248145/index.html">SoC: we raise simple DMA on FPGA</a></li>
<li><a href="../248147/index.html">Tree - killer JSON, XML, YAML and their ilk</a></li>
<li><a href="../248153/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 1 of 6</a></li>
<li><a href="../248155/index.html">Sex-inspired startups: pros, cons, pitfalls</a></li>
<li><a href="../248157/index.html">Programming languages. Compositional view</a></li>
<li><a href="../248159/index.html">A short course in computer graphics: we write a simplified OpenGL do it yourself, article 2 of 6</a></li>
<li><a href="../248161/index.html">The digest of interesting materials for the mobile # 86 developer (on January 12-18)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>