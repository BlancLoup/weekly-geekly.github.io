<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Common mistakes beginners work with images</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Digital image processing is a very interesting area, but it is fraught with many pitfalls that beginners constantly stumble upon. We are actively attr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Common mistakes beginners work with images</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/4a0/6a1/bee/4a06a1bee4254eb8ab14e8ab8f7a303a.png" align="left">  Digital image processing is a very interesting area, but it is fraught with many pitfalls that beginners constantly stumble upon.  We are actively attracting students to participate in grants and projects, but when we tried to give students real tasks that require the implementation of new image processing algorithms, we were horrified by their children's mistakes. </p><br><p>  Therefore, before setting full-fledged tasks, we began to give students a number of practical tasks for implementing standard image processing algorithms: basic image operations (rotate, blur), convolution, interpolation using simple filters (bilinear, bicubic), directional interpolation, selection of boundaries using an algorithm Canny, detect key points, etc.  The programming language could be any, however, when performing tasks, the use of third-party libraries is not allowed, with the exception of reading and writing images.  This is due to the fact that assignments are educational in nature, self-realization of algorithms is a good practice in programming and allows you to understand how the methods work from the inside. </p><br><p>  This article describes the most common mistakes made by students in performing practical tasks in image processing.  Images are ordinary, no exotics such as 16-bit color depth, panchromaticity and 3D images are present. </p><a name="habracut"></a><br><h2 id="oshibka-1-rabota-s-pikselyami-ispolzuya-sistemnye-obekty-bitmap-hbitmap-i-im-podobnye-dlya-hraneniya-izobrazheniy">  Error 1. Working with pixels using system objects Bitmap, HBITMAP and the like to store images </h2><br><p>  These objects are designed to interact with the graphics subsystem (drawing primitives and text, output to the screen) and do not provide direct access to the section of memory in which image pixels are stored.  Access to the pixels is carried out using the functions GetPixel and SetPixel.  Calling these functions is very expensive - two to three orders of magnitude slower than direct access to pixels.  The temptation is especially great to do this in C #, where the Bitmap type is available out of the box. </p><br><p>  <strong>Solution:</strong> use these classes only for reading from a file, writing to a file and outputting to the screen, otherwise working with classes that have effective access to the pixels. </p><br><p>  <strong>Note:</strong> in some cases in Windows it is convenient to work with DIB (device independent bitmap): there is also direct access to the pixels, and the possibility of displaying on the screen, minus is a restriction on the type of pixel. </p><br><h2 id="oshibka-2-ispolzovanie-bibliotek-dlya-raboty-s-izobrazheniyami-pri-otsutstvii-opyta-obrabotki-izobrazheniy">  Mistake 2. Using image libraries with no image processing experience. </h2><br><p>  The use of libraries is fraught with misunderstanding of the work of algorithms and further difficulties in solving practical problems that require the development of their own algorithms, which are not found in libraries.  I came across well-programmed students who could not even implement elementary operations such as convolutions: either they couldn‚Äôt connect the library, it didn‚Äôt work that well, but the mind was not enough to write a function of 10 lines. </p><br><p>  <strong>Solution:</strong> do not use third-party libraries, but write your own classes for working with images and independently implement the basic algorithms.  This is especially useful for those who do not have sufficient programming experience.  It‚Äôs better to break a bike several times than to overwhelm a whole project because of silly mistakes. </p><br><h2 id="oshibka-3-poterya-v-tochnosti-pri-okruglenii">  Error 3. Loss in accuracy when rounding </h2><br><p>  As a result of the application of various image processing algorithms, intermediate results with real type arise.  Example: almost any averaging filter, for example, a Gaussian filter.  Reduction of results to the byte type leads to the introduction of an additional error and less accurate operation of the algorithms. </p><br><p>  Below is an example of the operation of the Canny contour detection algorithm, one of the components of which is the calculation of the gradient modulus.  On the left - the gradient module after the calculation is stored in the float type, on the right - rounded to byte. </p><br><p><img src="https://habrastorage.org/files/868/49e/11e/86849e11eb134295af071890ffce8929.png" alt="No rounding"><img src="https://habrastorage.org/files/d8b/caa/a1f/d8bcaaa1fe974af6af33a3085745ba7d.png" alt="With rounding"></p><br><p>  It is easy to see that when rounding the contours become ragged. </p><br><p>  <strong>Solution:</strong> if accuracy is critical for the algorithm, then use the float type instead of byte to store pixel values, do not prematurely optimize - first achieve the normal operation of the float algorithm and then think about where you can use byte so that quality does not decrease. </p><br><p>  <strong>Note: the</strong> speed of modern processors with real numbers is comparable to integers.  In some cases, the compiler may use automatic vectorization, which will lead to faster code with float.  Also, the code with float can be faster with a large number of byte-float transformations, rounding and clipping.  But the use of double is rarely justified, but a hodgepodge of float and double is generally the result of a misunderstanding of the types and principles of working with them. </p><br><p>  Using integer types (byte, int16, uint16) is especially effective when using vector operations, when memory access speed becomes a bottleneck. </p><br><h2 id="oshibka-4-vyhod-znacheniy-pikseley-za-predely-diapazona-0-255">  Error 4. Out of pixel values ‚Äã‚Äãout of range [0, 255] </h2><br><p>  You have no problems with accuracy and you still want to use the byte type to store pixel values?  Then another problem arises: many operations, such as bicubic interpolation or sharpening, lead to the appearance of values ‚Äã‚Äãoutside the specified range.  If this fact is not taken into account, an effect appears, called wrapping: the value 260 turns into 4, and ‚Äì3 - into 253. Bright points and lines appear on a dark background and dark ones - on a light (on the left - the correct implementation, on the right - with an error) . </p><br><p><img src="https://habrastorage.org/files/20f/3d6/0c3/20f3d60c3a394970a44fc40c3f246010.png" alt="Using clamp"><img src="https://habrastorage.org/files/088/e3e/e2f/088e3ee2f0e34bb29708e3e2cc436f0d.png" alt="Without clamp"></p><br><p>  <strong>Solution:</strong> when performing intermediate operations, check the range of possible values ‚Äã‚Äãat each step, and when converting to byte type, check that the range is out of range, for example: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clamp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">0.0f</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : (x &gt; <span class="hljs-number"><span class="hljs-number">255.0f</span></span> ? <span class="hljs-number"><span class="hljs-number">255</span></span> : (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)x); }</code> </pre> <br><h2 id="oshibka-5-poterya-znacheniy-v-rezultate-privedeniya-k-diapazonu-0-255">  Error 5. Loss of values ‚Äã‚Äãas a result of reduction to the range [0, 255] </h2><br><p>  Do you prefer to work with the byte type and use the <code>clamp</code> function?  Are you sure that you have nothing to lose, as in the case of rounding? </p><br><p>  I saw in practice how students, when calculating a derivative or applying a Sobel filter, thus lost negative values. </p><br><p>  <strong>Solution:</strong> use types of sufficient size to store intermediate results, and the clamp function only to save to a file or display on the screen.  To visualize the derivative, add 128 to the pixel value, or take the module. </p><br><h2 id="oshibka-6-nepravilnyy-poryadok-obhoda-po-pikselyam-izobrazheniya-privodyaschiy-k-zamedleniyu-raboty-programmy">  Error 6. Wrong order to bypass pixels of the image, resulting in slowing down the program </h2><br><p>  Memory in the computer is one-dimensional.  Two-dimensional images are stored in memory as one-dimensional arrays.  Usually they are written line by line: first comes the 0th line, then the 1st, and so on. <br>  Serial memory access is faster than random access.  This is due to the work of the processor cache, which places data from the memory into the cache in large blocks, for example, 64 bytes for modern processors.  Several horizontally adjacent pixels fall into this block at once.  This means that when referring to subsequent pixels in the same row, the access speed will be higher than to subsequent pixels in the column. </p><br><p>  <strong>Solution:</strong> Bypassing the image must be done in such a way that the memory access is consistent: in the external loop, the bypass is performed vertically, and in the internal loop - horizontally: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; image.Height(); y++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; image.Width(); x++) ...</code> </pre> <br><p>  <strong>Note:</strong> In different languages, the way of representing multidimensional arrays in memory may be different.  <a href="http://eli.thegreenplace.net/2015/memory-layout-of-multi-dimensional-arrays">Keep this in mind.</a> </p><br><h2 id="oshibka-7-putanica-s-shirinoy-i-vysotoy">  Mistake 7. Confusion with width and height. </h2><br><p>  The classic problem: testing is either absent or is carried out only on square images; in the field, when working with rectangular images, the array goes beyond the boundary. </p><br><p>  <strong>Solution:</strong> do not forget about testing!  I propose not to raise the argument about TDD: its use is a personal matter for everyone. </p><br><h2 id="oshibka-8-otkaz-ot-abstrakciy">  Error 8. Refusal of abstractions </h2><br><p>  Fear of producing entities is a typical mistake for beginners, it leads to problems with readability and perception of the code.  There are many examples here. </p><br><p>  1. <code>getPixel(x, y)</code> pixels by directly calculating the indices in the array instead of using the <code>getPixel(x, y)</code> and <code>setPixel(x, y)</code> methods.  In addition to convenience, in these methods you can check and correctly handle the overrun of the image.  For example, not to give an error, but to extrapolate image values. </p><br><div class="spoiler">  <b class="spoiler_title">Just look at this wonderful code (in the code, by the way, there is an error, and not one)</b> <div class="spoiler_text"><pre> <code class="cs hljs">b1 = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)<span class="hljs-number"><span class="hljs-number">0.25</span></span> * ( w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>); b2 = -(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)<span class="hljs-number"><span class="hljs-number">0.25</span></span> * w1 * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>); b3 = -(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)<span class="hljs-number"><span class="hljs-number">0.25</span></span> * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>); b4 = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)<span class="hljs-number"><span class="hljs-number">0.25</span></span> * w1 * h1 * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>); b5 = -(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">12</span></span>) * w1 * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>); b6 = -(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">12</span></span>) * h1 * (w1- <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>); b7 = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">12</span></span>) * w1 * h1 * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>); b8 = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">12</span></span>) * w1 * h1 * (w1- <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) *( h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>); b9 = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">12</span></span>) * w1 * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>); b10 = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">12</span></span>) * w1 * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1+ <span class="hljs-number"><span class="hljs-number">1</span></span>); b11 = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">36</span></span>) * w1 * h1 * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1- <span class="hljs-number"><span class="hljs-number">2</span></span>); b12 = -(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">12</span></span>) * w1 * h1 * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>); b13 = -(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">12</span></span>) * w1 * h1 * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>); b14 = -(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">36</span></span>) * w1 * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">2</span></span>); b15 = -(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">36</span></span>) * w1 * h1 * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 - <span class="hljs-number"><span class="hljs-number">2</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>); b16 = (<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">36</span></span>) * w1 * h1 * (w1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (w1 + <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 - <span class="hljs-number"><span class="hljs-number">1</span></span>) * (h1 + <span class="hljs-number"><span class="hljs-number">1</span></span>); image2.rawdata[y1 * image2.Width + x1].b = image1.rawdata[h * image1.Width + w].b * b1 + image1.rawdata[h * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].b * b2 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w].b * b3 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].b * b4 + image1.rawdata[h * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].b * b5 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w].b * b6 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].b * b7 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].b * b8 + image1.rawdata[h * image.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].b * b9 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w].b * b10 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].b * b11 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].b * b12 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].b * b13 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].b * b14 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].b * b15 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].b * b16; image2.rawdata[y1 * image2.Width + x1].g = image1.rawdata[h * image1.Width + w].g * b1 + image1.rawdata[h * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].g * b2 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w].g * b3 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].g * b4 + image1.rawdata[h * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].g * b5 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w].g * b6 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].g * b7 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].g * b8 + image1.rawdata[h * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].g * b9 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w].g * b10 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].g * b11 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].g * b12 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].g * b13 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].g * b14 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].g * b15 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].g * b16; image2.rawdata[y1 * image2.Width + x1].r = image1.rawdata[h * image1.Width + w].r * b1 + image1.rawdata[h * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].r * b2 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w].r * b3 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].r * b4 + image1.rawdata[h * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].r * b5 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w].r * b6 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].r * b7 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].r * b8 + image1.rawdata[h * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].r * b9 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w].r * b10 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].r * b11 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].r * b12 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">1</span></span>].r * b13 + image1.rawdata[(h - <span class="hljs-number"><span class="hljs-number">1</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].r * b14 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w - <span class="hljs-number"><span class="hljs-number">1</span></span>].r * b15 + image1.rawdata[(h + <span class="hljs-number"><span class="hljs-number">2</span></span>) * image1.Width + w + <span class="hljs-number"><span class="hljs-number">2</span></span>].r * b16;</code> </pre> <br><p>  This is the implementation of bicubic interpolation performed by the student. <br>  Only a few students have guessed that the bicubic interpolation is separable, and managed to do with four coefficients instead of sixteen. </p></div></div><br><p>  2. Duplication of code when working with color images, leading to errors (see example above).  Instead of copy-paste code and replacing <code>r</code> with <code>g</code> and <code>b</code> , it would be enough to use operator overloading.  Three times less code, three times clearer. </p><br><p>  3. Using two-dimensional arrays instead of creating a separate class for the image. <br>  The problem is that the indexing is unnatural - <code>(y, x)</code> instead of <code>(x, y)</code> , and the dimensions of the array are not obvious: it is not clear that from <code>GetLength(0)</code> and <code>GetLength(1)</code> there is width, and that is height.  High risk just to confuse the indices. </p><br><p>  4. Using three-dimensional arrays to store color images instead of creating a separate class for the image.  In addition to the preceding paragraph, we have to remember which of the indices corresponds to which color component.  I also saw how three-dimensional arrays are used to store vectors, both in the form <code>(vx, vy)</code> and in the form <code>(v, angle)</code> .  Get confused easily. </p><br><p>  5. Using an array instead of a class.  Guess what the next function returns? </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HoughTransform2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GrayscaleFloatImage image, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params">[][] direction, ColorFloatImage cimage</span></span></span><span class="hljs-function">)</span></span></code> </pre> <br><p>  Answer: an array of 11 elements, each of the elements has its own sacred meaning, incomprehensible without a long code analysis.  Do not do this!  Start a class and name each of the fields humanly. </p><br><p>  6. Reuse of variables with changing semantics.  <code>grady</code> you see in the code <code>gradx</code> and <code>grady</code> and think that this is a primer of <code>x</code> and <code>y</code> ?  But no, this is the module and the angle: </p><br><pre> <code class="cs hljs">gradx[x, y] = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Math.Sqrt(temp1 * temp1 + temp2 * temp2); grady[x, y] = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)(Math.Abs(Math.Atan2(temp2, temp1)) * <span class="hljs-number"><span class="hljs-number">180</span></span> / Math.PI);</code> </pre> <br><p>  <strong>Solution:</strong> there should be no magic constants and indexes.  Decorate images as separate classes, the pixels themselves should also be typed, and access to the pixels should be carried out only through special methods. </p><br><h2 id="oshibka-9-primenenie-nekotoryh-matematicheskih-funkciy-nepravilno-ili-ne-k-mestu">  Error 9. The use of some mathematical functions incorrectly or out of place. </h2><br><p>  Here, the poor understanding of the processor architecture, a set of instructions and the time of their execution is to blame.  Forgivably, comes with experience, but some points I will note: </p><br><p>  1. Squaring as <code>Math.Pow(x, 2)</code> or <code>pow(x, 2)</code> instead of <code>x * x</code> . <br>  Compilers do not optimize these constructions; instead of one-cycle multiplication, they generate a rather complex code, including the calculation of the exponent and the logarithm, which leads to a decrease in speed by an order of two. </p><br><div class="spoiler">  <b class="spoiler_title">Explanation</b> <div class="spoiler_text"><p>  The call to <code>pow(x, y)</code> takes place in <code>exp(log(x) * y)</code> .  This takes about 300 cycles when using x87 commands.  In SSE, there is still no exponent and logarithm, there are many implementations of <code>exp</code> and <code>log</code> with different performance, for example, <a href="">here</a> .  At best, exponentiation will take 30-50 cycles.  The multiplication will take just one measure. </p></div></div><br><p>  2. Taking the integer part as <code>(int)Math.Floor((float)(j) / k)</code> , with <code>k</code> real and not changing inside the loop. </p><br><p>  Here it would be enough to write <code>(int)(j / k)</code> , and even better <code>(int)(j * inv_k)</code> , where <code>float inv_k = 1.0f / k</code> . </p><br><p>  The fact is that floor returns a real number, which must then be further converted into an integer.  It turns out an extra rather expensive operation.  Well, replacing division by multiplication is just optimization, the division operation is still expensive. </p><br><div class="spoiler">  <b class="spoiler_title">Comment</b> <div class="spoiler_text"><p>  <code>(int)floor(x)</code> and <code>(int)x</code> equivalent only for non-negative x.  The <code>floor</code> function always rounds down, while <code>(int)x</code> towards zero. </p></div></div><br><p>  3. Calculate the inverse value. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> _sum = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(sum, <span class="hljs-number"><span class="hljs-number">-1</span></span>);</code> </pre> <br><p>  Why do so when you can write <code>_sum = 1.0 / sum?</code> </p><br><p>  <strong>Solution:</strong> use math functions only where they are needed. </p><br><h2 id="oshibka-10-neznanie-yazyka">  Error 10. Ignorance of the language </h2><br><p>  And again problems with math: </p><br><p>  1. Confusion with types.  Using <code>long long</code> for pixel indices instead of <code>int</code> , constant conversions between <code>float</code> , <code>double</code> and <code>int</code> .  For example, why write <code>(float)(1.0 / 16)</code> when you can write <code>1.0f / 16.0f</code> ? </p><br><p>  2. Calculate the polar angle through fussing with <code>atan</code> and the problem of dividing by zero instead of using <code>atan2</code> , which does exactly what is needed. </p><br><p>  3. Unusual exponent and magic constants: </p><br><pre> <code class="java hljs">g=(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Math.pow(<span class="hljs-number"><span class="hljs-number">2.71</span></span>,-(d*d)/(<span class="hljs-number"><span class="hljs-number">2</span></span>*sigma*sigma)); t=((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)<span class="hljs-number"><span class="hljs-number">1</span></span>/((<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Math.sqrt(<span class="hljs-number"><span class="hljs-number">6.28</span></span>)*sigma));</code> </pre> <br><p>  Here, the student simply forgot about the existence of the function <code>exp</code> and the constant <code>pi</code> .  And instead of <code>(float)1</code> you can simply write <code>1.0f</code> . </p><br><p>  <strong>Solution:</strong> program more, the only way you will gain experience. </p><br><h2 id="oshibka-11-obfuskaciya-koda">  Error 11. Obfuscation Code </h2><br><p>  Novice programmers love to show their skills, preferring to write a short code, rather than understandable. </p><br><p>  1. Complex cycles </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x1 = x - <span class="hljs-number"><span class="hljs-number">1</span></span>, x2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; x1 &lt;= x + <span class="hljs-number"><span class="hljs-number">1</span></span>; x1++, x2++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y1 = y - <span class="hljs-number"><span class="hljs-number">1</span></span>, y2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; y1 &lt;= y + <span class="hljs-number"><span class="hljs-number">1</span></span>; y1++, y2++) {</code> </pre> <br><p>  Here it would be right to make a cycle from -1 to 1, and calculate <code>x1</code> and <code>x2</code> already inside the cycle, well, change the order: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">-1</span></span>; j &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; j++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y1 = y + j, y2 = j + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">-1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x1 = x + i, x2 = i + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  It would turn out even faster due to the fact that compilers easily optimize simple cycles. </p><br><p>  2. Cool features </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ksize = llround(fma(<span class="hljs-built_in"><span class="hljs-built_in">ceil</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span> * sigma), <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)), rad = ksize &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  And normal people just write </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rad = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)(<span class="hljs-number"><span class="hljs-number">3.0f</span></span> * sigma); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ksize = <span class="hljs-number"><span class="hljs-number">2</span></span> * rad + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br><p>  And this is generally beyond good and evil: </p><br><pre> <code class="cpp hljs">kernel[idx] = <span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">ldexp</span></span>(-<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(_sigma * (rad - idx), <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>));</code> </pre> <br><p>  For those who do not understand: <code>ldexp(x, -1)</code> - this is just a division by 2. </p><br><p>  <strong>Solution:</strong> just remember that sooner or later you will beat off your fingers with a hammer for such a code. </p><br><h2 id="oshibka-12-porcha-znacheniy-obrabatyvaemyh-izobrazheniy">  Error 12. Corruption of the values ‚Äã‚Äãof processed images </h2><br><p>  Here is a piece of code from the non-maximum suppression, which is part of the Canny algorithm: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(grad.shape[<span class="hljs-number"><span class="hljs-number">0</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(grad.shape[<span class="hljs-number"><span class="hljs-number">1</span></span>]): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((angle[x, y] == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((grad[x, y] &lt;= grad[getinds(grad, x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y)]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (grad[x, y] &lt;= grad[getinds(grad, x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y)]))) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>\ ((angle[x, y] == <span class="hljs-number"><span class="hljs-number">0.25</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((grad[x, y] &lt;= grad[getinds(grad, x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y + <span class="hljs-number"><span class="hljs-number">1</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (grad[x, y] &lt;= grad[getinds(grad, x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y - <span class="hljs-number"><span class="hljs-number">1</span></span>)]))) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>\ ((angle[x, y] == <span class="hljs-number"><span class="hljs-number">0.5</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((grad[x, y] &lt;= grad[getinds(grad, x, y + <span class="hljs-number"><span class="hljs-number">1</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (grad[x, y] &lt;= grad[getinds(grad, x, y - <span class="hljs-number"><span class="hljs-number">1</span></span>)]))) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>\ ((angle[x, y] == <span class="hljs-number"><span class="hljs-number">0.75</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ((grad[x, y] &lt;= grad[getinds(grad, x + <span class="hljs-number"><span class="hljs-number">1</span></span>, y - <span class="hljs-number"><span class="hljs-number">1</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> (grad[x, y] &lt;= grad[getinds(grad, x - <span class="hljs-number"><span class="hljs-number">1</span></span>, y + <span class="hljs-number"><span class="hljs-number">1</span></span>)]))): grad[x, y] = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Here, some values ‚Äã‚Äãvanish <code>grad[x, y] = 0</code> , and on subsequent iterations of the cycles they are addressed.  An error would not have occurred if a new image were created to calculate the intermediate result and the current one was not overwritten. </p><br><p>  <strong>Solution:</strong> do not seek to save memory ahead of time, think about the functional paradigm. </p><br><h2 id="ostalnye-oshibki">  The remaining errors </h2><br><p>  The remaining errors are already non-programmatic.  These are errors in the implementation of algorithms due to their misunderstanding, they are individual.  For example, the wrong choice of kernel size for a Gaussian filter. </p><br><p>  The Gauss filter is one of the main filters in image processing.  It underlies a huge number of algorithms: detection of edges (edges) and ridges (ridges), searching for key points, sharpening, etc.  The Gauss filter has a ‚Äúsigma‚Äù parameter that determines the level of blur, its core is described by the formula: </p><br><p><img src="https://habrastorage.org/files/37a/506/47c/37a50647cecb44639ac624f406ff77f1.png" alt="Formula"></p><br><p>  and the schedule has the form: </p><br><p><img src="https://habrastorage.org/files/a63/550/268/a63550268b2f432eac608dc44a66e72c.png" alt="Schedule"></p><br><p>  This function never vanishes, and a bundle with a kernel of infinite size does not make sense.  Therefore, the core size is chosen so that the error is negligible.  For practical tasks, it is enough to take a kernel with a radius <code>(int)(3 * sigma)</code> - the error will be less than <code>1/1000</code> .  Selecting a too small core (red function on the graph above) will result in a distortion of the Gauss filter.  The use of a fixed-size kernel, for example, 5x5, leads to incorrect results already at <code>sigma = 1.5</code> . </p><br><h2>  Outcome: general guidelines for beginners to work with images </h2><br><ol><li>  Do not use system objects Bitmap, HBITMAP and the like. </li><li>  Before using the library for working with images, start by writing bicycles, and only then rush into battle. </li><li>  Use the float type to store pixel values ‚Äã‚Äãif byte is not enough to store pixel values ‚Äã‚Äãin terms of both precision and range.  And having gained experience, you can use fixed-point arithmetic and achieve maximum efficiency. </li><li>  When converting from float to byte, be aware of rounding errors and overruns of the type. </li><li>  Remember negative values. </li><li>  Traverse image pixels in the correct order. </li><li>  Test the code thoroughly. </li><li>  Do not be afraid to produce entities.  The code should be clear. </li><li>  Use math operations wisely. </li><li>  Learn the language. </li><li>  Do not try to show skill. </li><li>  Read image processing tutorials - they write a lot of useful stuff. </li></ol><br><p>  To make it easier to write programs, I created projects that already read and write images, create classes for storing images with the lowest possible functionality, and give an example of an operation on images: </p><br><p>  ‚Üí <a href="https://github.com/e673/improcbase-cpp">Visual Studio 2015, C ++</a> <br>  ‚Üí <a href="https://github.com/e673/improcbase-cs">Visual Studio 2015, C #</a> </p><br><p>  There are no Linux versions - students using Linux usually have no problems with such things. </p><br><p>  Well, for a snack - just pictures. </p><br><p>  Selecting contours using the Kanni algorithm.  At the top left - the input image, the second from the left - the correct result, the rest - erroneous results. </p><br><table><tbody><tr><td><img src="https://habrastorage.org/files/4dd/a6a/1fa/4dda6a1fa65347c58da707e4f1c97fed.png"></td><td><img src="https://habrastorage.org/files/7d9/934/20e/7d993420e9f84cefb4f6d63143f5505c.png"></td><td><img src="https://habrastorage.org/files/841/91c/e8d/84191ce8dcb54cfeb024ec8b8f98a34a.png"></td><td><img src="https://habrastorage.org/files/bbe/830/50c/bbe83050c4d84833b531d109a931f1b2.png"></td><td><img src="https://habrastorage.org/files/d24/485/205/d24485205a394d54a021fad73d3aba71.png"></td></tr><tr><td><img src="https://habrastorage.org/files/a43/439/552/a434395522284b3f92666bcc18dfb893.png"></td><td><img src="https://habrastorage.org/files/564/981/954/5649819545914187803a6a0540f9dff2.png"></td><td><img src="https://habrastorage.org/files/7b5/8f3/1ca/7b58f31caa6641c5ab8de667dee8359d.png"></td><td><img src="https://habrastorage.org/files/bd0/814/a27/bd0814a2782c4c43be7dc1b86f0f3806.png"></td><td><img src="https://habrastorage.org/files/53b/0a6/e17/53b0a6e175724723b13cdc0bf0f5acc9.png"></td></tr></tbody></table><br><p>  Increase using bicubic interpolation. </p><br><table><tbody><tr><td><img src="https://habrastorage.org/files/0f8/2d7/2f2/0f82d72f2dc44b19bddc7792f4737993.png"></td><td><img src="https://habrastorage.org/files/1bd/c3a/237/1bdc3a23763a4feabe388c8fd680aec7.png"></td><td><img src="https://habrastorage.org/files/9ea/baa/29c/9eabaa29c4ff4b2bb46dff8f5bec3144.png"></td><td><img src="https://habrastorage.org/files/c21/65b/910/c2165b91016a446bac73d0e747a9c5bb.png"></td><td><img src="https://habrastorage.org/files/5a9/9db/0f9/5a99db0f9b2a4abca607a08a26b8f4b4.png"></td></tr></tbody></table></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/319606/">https://habr.com/ru/post/319606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319594/index.html">How IT professionals work. Evgeny Bevz, Smart-Soft company</a></li>
<li><a href="../319598/index.html">GDG DevFest Nizhny Novgorod 2016: how it was</a></li>
<li><a href="../319600/index.html">Formulas on Habr√©</a></li>
<li><a href="../319602/index.html">Unicode is very exciting.</a></li>
<li><a href="../319604/index.html">Data Serialization: Performance Test and Application Description</a></li>
<li><a href="../319610/index.html">Unboxing: What's Inside a NetApp AFF A300 Storage System</a></li>
<li><a href="../319612/index.html">VMware Introduces HTML5 Client vSphere Client Fling v3.0</a></li>
<li><a href="../319614/index.html">* aaS dictionary: 50 materials on IT terminology</a></li>
<li><a href="../319616/index.html">Digest: All about working with IaaS and examples of practical cases for IT-GRAD clients</a></li>
<li><a href="../319618/index.html">D-Wave Systems sold their first 2000-qubit quantum computer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>