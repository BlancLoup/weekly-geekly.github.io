<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Shadow rendering using Parallel-Split Shadow Mapping</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! My previous post on graphics programming was well received by the community, and I ventured another one. Today I will talk about the Paralle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Shadow rendering using Parallel-Split Shadow Mapping</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/ca7/ded/b43/ca7dedb43c8a0a06437baf1ff10e57c2.png" alt="image" align="right">  Hi, Habr!  My <a href="http://habrahabr.ru/post/224003/">previous post</a> on graphics programming was well received by the community, and I ventured another one.  Today I will talk about the Parallel-Split Shadow Mapping (PSSM) shadow rendering algorithm, which I first encountered when there was a working need to display shadows at a great distance from the player.  Then I was limited to the Direct3D 10 feature set, now I implemented the algorithm on Direct3D 11 and OpenGL 4.3.  The PSSM algorithm is described in more detail in <a href="http.developer.nvidia.com/GPUGems3/gpugems3_ch10.html">GPU Gems 3,</a> both from a mathematical point of view, and from the point of view of implementation on Direct3D 9 and 10. For details, I ask for cat. <br><a name="habracut"></a><br>  A demo can be found <a href="https://github.com/rokuz/GraphicsDemo">here</a> .  The project is called Demo_PSSM.  You will need Visual Studio 2012/2013 and <a href="http://www.cmake.org/">CMake</a> to build. <br><br><h4>  Shadow mapping </h4><br>  The original <a href="http://en.wikipedia.org/wiki/Shadow_mapping">shadow mapping</a> algorithm was invented a long time ago.  The principle of its operation is as follows: <br><ol><li>  Draw a scene into the texture (shadow map) from the position of the light source.  It is important to note here that for different types of light sources everything happens a little differently. <br>  Directional sources of light (such as, in a certain approximation, sunlight can be attributed) do not have a position in space, but in order to form a shadow map this position has to be chosen.  Usually it is tied to the observer's position, so that objects that are directly in the field of view of the observer fall into the shadow map.  When rendering using <a href="http://en.wikipedia.org/wiki/Orthographic_projection">orthographic projection</a> . <br>  Projection sources of light (lamps with an opaque shade, spotlights) have a certain position in space and limit the propagation of light in certain directions.  When rendering a shadow map in this case, the usual <a href="http://www.scratchapixel.com/lessons/3d-advanced-lessons/perspective-and-orthographic-projection-matrix/perspective-projection-matrix">perspective projection matrix is ‚Äã‚Äãused</a> . <br>  Omnidirectional light sources (incandescent lamps, for example), although they have a certain position in space, propagate light in all directions.  In order to correctly construct the shadows from such a light source, it is necessary to use cubic textures (cube maps), which, as a rule, means drawing a scene into a shadow map 6 times.  Not every game can afford dynamic shadows from such light sources, and not every game needs it.  If you are interested in the principles of this approach, there is <a href="http.developer.nvidia.com/GPUGems/gpugems_ch12.html">an old article</a> on this topic. <br>  In addition, there is a subclass of shadow mapping algorithms ( <a href="http://www.cg.tuwien.ac.at/~scherzer/files/papers/LispSM_survey.pdf">LiSPSM</a> , <a href="http://www.comp.nus.edu.sg/~tants/tsm.html">TSM</a> , <a href="http://www-sop.inria.fr/reves/Marc.Stamminger/psm/">PSM</a> , etc.) that use non-standard projection view matrices to improve the quality of shadows and eliminate the drawbacks of the original approach. <br>  Whatever way the shadow map is formed, it invariably contains the distance from the light source to the nearest visible (from the position of the light source) point or function from this distance in more complex varieties of the algorithm. </li><li>  We draw a scene from the main camera.  In order to understand whether a point of any object is in the shadow, it is enough to translate the coordinates of this point into the space of a shadow map and make a comparison.  The space of the shadow map is determined by the projection view matrix that was used in the formation of this map.  Transferring the coordinates of the object point to this space and converting the coordinates from the range <i>[-1; -1]</i> to <i>[0; 1]</i> , we obtain the texture coordinates.  If the obtained coordinates turned out to be outside the range <i>[0; 1]</i> , then this point did not fall into the shadow map, and it can be considered unshadowed.  Making a sample of the shadow map on the received texture coordinates, we get the distance between the light source and the nearest point of an object.  If we compare this distance with the distance between the current point and the light source, then the point is in the shadow if the value in the shadow map is smaller.  It is quite simple from a logical point of view, if the value from the shadow map is smaller, it means that at this point there is some object that is closer to the light source, and we are in its shadow. </li></ol><br>  Shadow mapping is by far the most common algorithm for rendering dynamic shadows.  The implementation of one or another modification of the algorithm can be found in almost any graphics engine.  The main advantage of this algorithm is that it ensures the rapid formation of shadows from arbitrarily geometrically complex objects.  However, the existence of a wide range of variations of the algorithm is largely due to its shortcomings, which can lead to very unpleasant graphic artifacts.  PPSM-specific problems and ways to overcome them will be discussed below. <br><br><h4>  Parallel-Split Shadow Mapping </h4><br>  Consider the following task: <i>it is necessary to draw dynamic shadows from objects that are at a considerable distance from the player without prejudice to the shadows from closely located objects.</i>  <i>We confine ourselves to directed sunlight.</i> <br>  A task of this kind can be especially relevant in outdoor games, where in some situations a player can see the landscape hundreds of meters in front of him.  In this case, the further we want to see the shadow, the more space should fall into the shadow map.  In order to maintain the proper resolution of objects in the shadow map, we are forced to increase the resolution of the card itself, which first leads to a decrease in performance, then we rest on the limit on the maximum size of the target target.  As a result, balancing between the performance and the quality of the shadow, we get the shadow with a well-marked aliasing effect, which is poorly masked even by blurring.  It is clear that such a decision cannot satisfy us. <br>  To solve this problem, we can come up with a projection matrix so that the objects close to the player receive in the shadow map an area larger than objects that are far away.  This is the basic idea of ‚Äã‚Äãthe Perspective Shadow Mapping (PSM) algorithm and a number of other algorithms.  The main advantage of this approach is the fact that we practically did not change the process of rendering the scene, only the method of calculating the projection view matrix has changed.  This approach can be easily integrated into an existing game or engine without the need for major modifications of the latter.  The main disadvantage of this type of approach is the boundary conditions.  Imagine the situation that we draw the shadows from the sun at sunset.  When the sun approaches the horizon, the objects in the shadow map begin to overlap each other.  In this case, an atypical projection matrix can exacerbate the situation.  In other words, PSM class algorithms work well in certain situations, for example, when the game draws shadows from the ‚Äúfixed Sun‚Äù close to the zenith. <br>  A fundamentally different approach is proposed in the PSSM algorithm.  For some, this algorithm may be known as <a href="http://developer.download.nvidia.com/SDK/10.5/opengl/src/cascaded_shadow_maps/doc/cascaded_shadow_maps.pdf">Cascaded Shadow Mapping</a> (CSM).  Formally, these are different algorithms, I would even say that PSSM is a special case of CSM.  In this algorithm, it is proposed to divide the frustum of the main camera into segments.  In the case of PSSM, with boundaries parallel to the near and far cut-off planes, in the case of CSM, the type of separation is not strictly regulated.  For each segment ( <i>split</i> in the terminology of the algorithm) its own shadow card is built.  An example of separation is shown in the figure below. <br><img src="https://habrastorage.org/getpro/habr/post_images/deb/419/4bc/deb4194bcda21b50f3a5fde407826552.png"><br>  In the figure you can see the division of the pyramid of visibility into 3 segments.  Each of the segments is highlighted by a bounding box (in three-dimensional space there will be a parallelepiped, a bounding box).  For each of these limited parts of the space will be built its own shadow map.  The attentive reader will notice that here I used bounding box parallelepipeds.  You can also use unaligned ones, this will add additional complexity to the object clipping algorithm and will slightly change the way the matrix of the view is formed from the position of the light source.  As the pyramid of visibility expands, the area of ‚Äã‚Äãthe segments closer to the camera can be significantly less than the area of ‚Äã‚Äãthe farthest.  With the same resolution of shadow maps, this means a higher resolution for the shadow of closely located objects.  In the above-mentioned <a href="http.developer.nvidia.com/GPUGems3/gpugems3_ch10.html">article in GPU Gems 3</a> , the following scheme was proposed for calculating the distances of the partition of the pyramid of visibility: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/680/edd/5fb/680edd5fb1fb61ecec78800307e01ac7.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/c73/1a6/b14/c731a6b14ea7086562c154fccdb60c74.jpg"><br><img src="https://habrastorage.org/getpro/habr/post_images/b6e/e21/b6f/b6ee21b6f992559f2d971a3a6e784098.jpg"><br>  where <i>i</i> is the partitioning index, <i>m</i> is the number of partitions, <i>n</i> is the distance to the near cut plane, <i>f</i> is the distance to the far cut plane, <i>Œª</i> is the coefficient determining the interpolation between the logarithmic and uniform split scale. <br><br><h5>  Common in implementation </h5><br>  The PSSM algorithm in the implementation on Direct3D 11 and OpenGL has a lot in common.  To implement the algorithm it is necessary to prepare the following: <br><ol><li>  Several shadow maps (by the number of splits).  At first glance, it seems that in order to obtain several shadow maps, it is necessary to draw objects several times.  Actually, it is not necessary to do this explicitly, we will use the mechanism of hardware instansing.  To do this, we need a so-called array of textures for rendering and a simple geometric shader. </li><li>  The mechanism of clipping objects.  The objects of the game world can be of different geometric shapes and have a different position in space.  Extended objects can be seen in several shadow maps, small objects - only in one.  The object may be directly on the border of neighboring segments and must be drawn in at least 2 shadow maps.  Thus, a mechanism is needed to determine which subset of the shadow maps falls on an object. </li><li>  A mechanism for determining the optimal number of partitions.  Rendering shadow maps for each segment per frame can be a waste of computational resources.  In many situations, the player sees in front of him only a small portion of the game world (for example, he looks at his feet, or his gaze rested on the wall in front of him).  It is clear that this greatly depends on the type of review in the game, but it would be nice to have such optimization. </li></ol><br>  As a result, we obtain the following algorithm for generating projection view matrices for rendering shadow maps: <br><ol><li>  Calculate the distances to divide the visibility pyramid for the worst case.  The worst case here is we see the shadows to the far clipping plane of the camera. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateMaxSplitDistances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearPlane = m_camera.getInternalCamera().GetNearPlane(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> farPlane = m_camera.getInternalCamera().GetFarPlane(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; m_splitCount; i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)i / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)m_splitCount; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> l = nearPlane * <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(farPlane / nearPlane, f); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u = nearPlane + (farPlane - nearPlane) * f; m_maxSplitDistances[i - <span class="hljs-number"><span class="hljs-number">1</span></span>] = l * m_splitLambda + u * (<span class="hljs-number"><span class="hljs-number">1.0f</span></span> - m_splitLambda); } m_farPlane = farPlane + m_splitShift; }</code> </pre> </div></div></li><li>  Determine the distance between the camera and the most distant visible point of the object casting a shadow.  It is important to note here that objects can cast and not cast shadows.  For example, a flat-hilly landscape can be made without casting shadows; in this case, the lighting algorithm can be responsible for shading.  Only shadow objects will be drawn into the shadow map. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateFurthestPointInCamera</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> matrix44&amp; cameraView)</span></span></span><span class="hljs-function"> </span></span>{ bbox3 scenebox; scenebox.begin_extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_entitiesData.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_entitiesData[i].isShadowCaster) { bbox3 b = m_entitiesData[i].geometry.lock()-&gt;getBoundingBox(); b.transform(m_entitiesData[i].model); scenebox.extend(b); } } scenebox.end_extend(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxZ = m_camera.getInternalCamera().GetNearPlane(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { vector3 corner = scenebox.corner_point(i); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = -cameraView.transform_coord(corner).z; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (z &gt; maxZ) maxZ = z; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(maxZ, m_farPlane); }</code> </pre></div></div></li><li>  On the basis of the values ‚Äã‚Äãobtained at steps 1 and 2, we determine the number of segments that we really need and the separation distances for them. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateSplitDistances</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// calculate how many shadow maps do we really need m_currentSplitCount = 1; if (!m_maxSplitDistances.empty()) { for (size_t i = 0; i &lt; m_maxSplitDistances.size(); i++) { float d = m_maxSplitDistances[i] - m_splitShift; if (m_furthestPointInCamera &gt;= d) m_currentSplitCount++; } } float nearPlane = m_camera.getInternalCamera().GetNearPlane(); for (int i = 0; i &lt; m_currentSplitCount; i++) { float f = (float)i / (float)m_currentSplitCount; float l = nearPlane * pow(m_furthestPointInCamera / nearPlane, f); float u = nearPlane + (m_furthestPointInCamera - nearPlane) * f; m_splitDistances[i] = l * m_splitLambda + u * (1.0f - m_splitLambda); } m_splitDistances[0] = nearPlane; m_splitDistances[m_currentSplitCount] = m_furthestPointInCamera; }</span></span></code> </pre></div></div></li><li>  For each segment (the boundaries of the segment are determined by the near and far distances) we calculate the bounding box. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">bbox3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateFrustumBox</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> nearPlane, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> farPlane)</span></span></span><span class="hljs-function"> </span></span>{ vector3 eye = m_camera.getPosition(); vector3 vZ = m_camera.getOrientation().z_direction(); vector3 vX = m_camera.getOrientation().x_direction(); vector3 vY = m_camera.getOrientation().y_direction(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fov = n_deg2rad(m_camera.getInternalCamera().GetAngleOfView()); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> aspect = m_camera.getInternalCamera().GetAspectRatio(); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearPlaneHeight = n_tan(fov * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * nearPlane; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> nearPlaneWidth = nearPlaneHeight * aspect; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> farPlaneHeight = n_tan(fov * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>) * farPlane; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> farPlaneWidth = farPlaneHeight * aspect; vector3 nearPlaneCenter = eye + vZ * nearPlane; vector3 farPlaneCenter = eye + vZ * farPlane; bbox3 box; box.begin_extend(); box.extend(vector3(nearPlaneCenter - vX * nearPlaneWidth - vY * nearPlaneHeight)); box.extend(vector3(nearPlaneCenter - vX * nearPlaneWidth + vY * nearPlaneHeight)); box.extend(vector3(nearPlaneCenter + vX * nearPlaneWidth + vY * nearPlaneHeight)); box.extend(vector3(nearPlaneCenter + vX * nearPlaneWidth - vY * nearPlaneHeight)); box.extend(vector3(farPlaneCenter - vX * farPlaneWidth - vY * farPlaneHeight)); box.extend(vector3(farPlaneCenter - vX * farPlaneWidth + vY * farPlaneHeight)); box.extend(vector3(farPlaneCenter + vX * farPlaneWidth + vY * farPlaneHeight)); box.extend(vector3(farPlaneCenter + vX * farPlaneWidth - vY * farPlaneHeight)); box.end_extend(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> box; }</code> </pre></div></div></li><li>  We calculate the shadow matrix of the projection view for each segment. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">matrix44 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculateShadowViewProjection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bbox3&amp; frustumBox)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> LIGHT_SOURCE_HEIGHT = <span class="hljs-number"><span class="hljs-number">500.0f</span></span>; vector3 viewDir = m_camera.getOrientation().z_direction(); vector3 size = frustumBox.size(); vector3 center = frustumBox.center() - viewDir * m_splitShift; center.y = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> lightSource = m_lightManager.getLightSource(<span class="hljs-number"><span class="hljs-number">0</span></span>); vector3 lightDir = lightSource.orientation.z_direction(); matrix44 shadowView; shadowView.pos_component() = center - lightDir * LIGHT_SOURCE_HEIGHT; shadowView.lookatRh(shadowView.pos_component() + lightDir, lightSource.orientation.y_direction()); shadowView.invert_simple(); matrix44 shadowProj; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(size.x, size.z); shadowProj.orthoRh(d, d, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">2000.0f</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shadowView * shadowProj; }</code> </pre></div></div></li></ol><br>  Clipping of objects is realized with the help of a simple test for the intersection of two bounding parallelepipeds (an object and a segment of the pyramid of visibility).  There is one feature that is important to consider.  We may not see the object, but see the shadow of it.  It is not hard to guess that with the approach described above we will cut off all the objects that are not visible in the main camera, and there will be no shadows from them.  To prevent this from happening, I used a fairly common technique - stretching the bounding box of the object along the direction of light propagation, which gave a rough approximation of the region of space in which the shadow of the object is visible.  As a result, for each object, an array of shadow map indices was formed, in which this object should be drawn. <br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateShadowVisibilityMask</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bbox3&amp; frustumBox, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;framework::Geometry3D&gt;&amp; entity, EntityData&amp; entityData, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> splitIndex)</span></span></span><span class="hljs-function"> </span></span>{ bbox3 b = entity-&gt;getBoundingBox(); b.transform(entityData.model); <span class="hljs-comment"><span class="hljs-comment">// shadow box computation auto lightSource = m_lightManager.getLightSource(0); vector3 lightDir = lightSource.orientation.z_direction(); float shadowBoxL = fabs(lightDir.z) &lt; 1e-5 ? 1000.0f : (b.size().y / -lightDir.z); bbox3 shadowBox; shadowBox.begin_extend(); for (int i = 0; i &lt; 8; i++) { shadowBox.extend(b.corner_point(i)); shadowBox.extend(b.corner_point(i) + lightDir * shadowBoxL); } shadowBox.end_extend(); if (frustumBox.clipstatus(shadowBox) != bbox3::Outside) { int i = entityData.shadowInstancesCount; entityData.shadowIndices[i] = splitIndex; entityData.shadowInstancesCount++; } }</span></span></code> </pre></div></div><br>  Now consider the rendering process and parts specific to Direct3D 11 and OpenGL 4.3. <br><br><h5>  Implementation on Direct3D 11 </h5><br>  To implement the algorithm on Direct3D 11, we need: <br><ol><li>  An array of textures for rendering shadow maps.  To create this kind of object in the <code>D3D11_TEXTURE2D_DESC</code> structure, <code>D3D11_TEXTURE2D_DESC</code> is an <code>D3D11_TEXTURE2D_DESC</code> field.  Thus, in C ++ code, we will not have anything similar to <code>ID3D11Texture2D* array[N]</code> .  From the point of view of the Direct3D API, an array of textures is slightly different from a single texture.  An important feature when using such an array in a shader is that we can determine exactly which texture in the array we will draw this or that object (semantics of <code>SV_RenderTargetArrayIndex</code> in HLSL).  This is the main difference between this approach and MRT (multiple render targets), in which one object is drawn at once into all specified textures.  For objects that need to be drawn into several shadow maps at once, we will use hardware instansing, which allows you to clone objects at the GPU level.  In this case, an object can be drawn in one texture in an array, and its clones in others.  In the shadow maps we will only store the depth value, so we will use the texture format <code>DXGI_FORMAT_R32_FLOAT</code> . </li><li>  Special texture sampler.  In the Direct3D API, you can set special parameters for sampling from a texture, which will allow you to compare values ‚Äã‚Äãin a texture with a given number.  The result in this case will be 0 or 1, and the transition between these values ‚Äã‚Äãcan be smoothed by a linear or anisotropic filter.  To create a sampler in the <code>D3D11_SAMPLER_DESC</code> structure <code>D3D11_SAMPLER_DESC</code> set the following parameters: <br><br><pre> <code class="cpp hljs">samplerDesc.Filter = D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT; samplerDesc.ComparisonFunc = D3D11_COMPARISON_LESS; samplerDesc.AddressU = D3D11_TEXTURE_ADDRESS_BORDER; samplerDesc.AddressV = D3D11_TEXTURE_ADDRESS_BORDER; samplerDesc.BorderColor[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; samplerDesc.BorderColor[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; samplerDesc.BorderColor[<span class="hljs-number"><span class="hljs-number">2</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; samplerDesc.BorderColor[<span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>;</code> </pre><br>  Thus, we will have bilinear filtering, the comparison with the ‚Äúless‚Äù function, and a sample of the texture by coordinates outside the <i>[0; 1]</i> range will return 1 (that is, no shadow). </li></ol><br>  Rendering will be carried out according to the following scheme: <br><ol><li>  Cleaning an array of shadow maps.  Since the smallest distance between objects and the light source is stored in the shadow map, we will clear the value <code>FLT_MAX</code> . </li><li>  Render the scene into an array of shadow maps.  To do this, we transfer to the shaders an array of shadow matrices of the projection type and an array of indexes of shadow maps for each object.  Objects that need to be drawn in several shadow maps are drawn with instancing using the <code>DrawIndexedInstanced</code> method.  HLSL shaders for shadow map generation are shown below. <br><div class="spoiler">  <b class="spoiler_title">Vertex shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;common.h.hlsl&gt; struct VS_OUTPUT { float4 position : SV_POSITION; float depth : TEXCOORD0; uint instanceID : SV_InstanceID; }; VS_OUTPUT main(VS_INPUT input, unsigned int instanceID : SV_InstanceID) { VS_OUTPUT output; float4 pos = mul(float4(input.position, 1), model); output.position = mul(pos, shadowViewProjection[shadowIndices[instanceID]]); output.depth = output.position.z; output.instanceID = instanceID; return output; }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Geometric Shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;common.h.hlsl&gt; struct GS_INPUT { float4 position : SV_POSITION; float depth : TEXCOORD0; uint instanceID : SV_InstanceID; }; struct GS_OUTPUT { float4 position : SV_POSITION; float depth : TEXCOORD0; uint index : SV_RenderTargetArrayIndex; }; [maxvertexcount(3)] void main(triangle GS_INPUT pnt[3], inout TriangleStream&lt;GS_OUTPUT&gt; triStream) { GS_OUTPUT p = (GS_OUTPUT)pnt[0]; p.index = shadowIndices[pnt[0].instanceID]; triStream.Append(p); p = (GS_OUTPUT)pnt[1]; p.index = shadowIndices[pnt[1].instanceID]; triStream.Append(p); p = (GS_OUTPUT)pnt[2]; p.index = shadowIndices[pnt[2].instanceID]; triStream.Append(p); triStream.RestartStrip(); }</span></span></span></span></code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Pixel shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PS_INPUT</span></span></span><span class="hljs-class"> {</span></span> float4 position : SV_POSITION; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth : TEXCOORD0; uint index : SV_RenderTargetArrayIndex; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PS_INPUT input)</span></span></span><span class="hljs-function"> : SV_TARGET </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> input.depth; }</code> </pre></div></div><br>  As a result, an array of shadow maps will look something like this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d7/406/873/5d7406873ccb4df98c7fa647b89c88c4.png"><br></li><li>  Render the scene from the main camera.  In order for the shadow to turn out to be a bit blurred, we will use the <a href="http.developer.nvidia.com/GPUGems/gpugems_ch11.html">Percentage Closer Filtering</a> algorithm.  When calculating the shading of a point, we will take samples from all shadow maps and mix the result.  As a result, we get a float value, where 0.0 would mean a fully shaded point, and 1.0 - not completely shaded.  The functions on the HLSL for calculating shading are shown below. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShadowCoords</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> splitIndex, float3 worldPos)</span></span></span><span class="hljs-function"> </span></span>{ float4 coords = mul(float4(worldPos, <span class="hljs-number"><span class="hljs-number">1</span></span>), shadowViewProjection[splitIndex]); coords.xy = (coords.xy / coords.ww) * float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">-0.5</span></span>) + float2(<span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coords.xyz; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sampleShadowMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index, float3 coords, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> bias)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (coords.x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || coords.x &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> || coords.y &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || coords.y &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0f</span></span>; float3 uv = float3(coords.xy, index); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> receiver = coords.z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sum = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FILTER_SIZE = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> HALF_FILTER_SIZE = <span class="hljs-number"><span class="hljs-number">0.5</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>(FILTER_SIZE); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; FILTER_SIZE; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; FILTER_SIZE; j++) { float3 offset = float3(shadowBlurStep * (float2(i, j) - HALF_FILTER_SIZE) / HALF_FILTER_SIZE, <span class="hljs-number"><span class="hljs-number">0</span></span>); sum += shadowMap.SampleCmpLevelZero(shadowMapSampler, uv + offset, receiver - bias); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum / (FILTER_SIZE * FILTER_SIZE); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shadow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 worldPos)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadowValue = <span class="hljs-number"><span class="hljs-number">0</span></span>; [unroll(MAX_SPLITS)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; splitsCount; i++) { float3 coords = getShadowCoords(i, worldPos); shadowValue += (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - sampleShadowMap(i, coords, SHADOW_BIASES[i])); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span> - saturate(shadowValue); }</code> </pre><br>  Finally, it is necessary to take into account the fact that, in addition to shadows, there is also shading from the lighting algorithm (I used the <a href="http://en.wikipedia.org/wiki/Blinn%25E2%2580%2593Phong_shading_model">Blinna-Phong</a> lighting model).  To avoid double shading, I added the following code to the pixel shader. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadowValue = shadow(input.worldPos); shadowValue = lerp(<span class="hljs-number"><span class="hljs-number">1</span></span>, shadowValue, ndol);</code> </pre><br>  Here the advantage is given to the lighting model, i.e.  where it is dark according to the Blinna-Phong model, the shadow will not be superimposed.  The decision does not claim to be ideal, but to some extent eliminates the problem. <br>  As a result, we get the following picture. <br><br><img src="//habrastorage.org/files/b33/142/881/b3314288109d4a97b0226753f1fb9975.jpg"><br></li></ol><br><br><h5>  Implementation on OpenGL 4.3 </h5><br>  To implement the algorithm on OpenGL 4.3, we need all the same as for Direct3D 11, but there are subtleties.  In OpenGL, we can only <code>GL_DEPTH_COMPONENT32F</code> samples with comparisons for textures that contain a depth value (for example, in the <code>GL_DEPTH_COMPONENT32F</code> format).  Consequently, we will render the rendering only to the depth buffer, and write to color in color (more precisely, attach only the array of textures for storing the depth buffer to the framebuffer).  On the one hand, this will save us a little bit of video memory and ease the graphics pipeline, on the other hand, it will force us to work with normalized depth values. <br>  OpenGL's selection parameters can be tied directly to the texture.  They will be identical to those discussed earlier for Direct3D 11. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> BORDER_COLOR[] = { <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> }; glBindTexture(m_shadowMap-&gt;getTargetType(), m_shadowMap-&gt;getDepthBuffer()); glTexParameteri(m_shadowMap-&gt;getTargetType(), GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(m_shadowMap-&gt;getTargetType(), GL_TEXTURE_MAG_FILTER, GL_LINEAR); glTexParameteri(m_shadowMap-&gt;getTargetType(), GL_TEXTURE_COMPARE_MODE, GL_COMPARE_REF_TO_TEXTURE); glTexParameteri(m_shadowMap-&gt;getTargetType(), GL_TEXTURE_COMPARE_FUNC, GL_LESS); glTexParameteri(m_shadowMap-&gt;getTargetType(), GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER); glTexParameteri(m_shadowMap-&gt;getTargetType(), GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER); glTexParameterfv(m_shadowMap-&gt;getTargetType(), GL_TEXTURE_BORDER_COLOR, BORDER_COLOR); glBindTexture(m_shadowMap-&gt;getTargetType(), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  Interesting is the process of creating an array of textures, which inside OpenGL is represented by a three-dimensional texture.  There is no special function for its creation, both of which are created using <code>glTexStorage3D</code> .  The analog of <code>SV_RenderTargetArrayIndex</code> in GLSL is the built-in variable <code>gl_Layer</code> . <br>  The rendering scheme also remained the same: <br><ol><li>  Clear the shadow map array.  Since there is no color channel in framebuffer, we will only clear the depth buffer.  For a normalized depth buffer, the maximum value will be 1.0. </li><li>  Render shadow maps.  Since only depth buffers are formed, we do not need a fragment shader. <br><div class="spoiler">  <b class="spoiler_title">Vertex shader</b> <div class="spoiler_text"><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">430</span></span> core const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_SPLITS = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 position; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(location = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 normal; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(location = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 uv0; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(location = <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 tangent; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(location = <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 binormal; out VS_OUTPUT { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth; flat <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> instanceID; } vsoutput; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 modelMatrix; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 shadowViewProjection[MAX_SPLITS]; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shadowIndices[MAX_SPLITS]; void main() { vec4 wpos = modelMatrix * vec4(position, <span class="hljs-number"><span class="hljs-number">1</span></span>); vec4 pos = shadowViewProjection[shadowIndices[gl_InstanceID]] * vec4(wpos.xyz, <span class="hljs-number"><span class="hljs-number">1</span></span>); gl_Position = pos; vsoutput.depth = pos.z; vsoutput.instanceID = gl_InstanceID; }</code> </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Geometric Shader</b> <div class="spoiler_text"><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">430</span></span> core const <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MAX_SPLITS = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(triangles) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>(triangle_strip, max_vertices = <span class="hljs-number"><span class="hljs-number">3</span></span>) out; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> VS_OUTPUT { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth; flat <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> instanceID; } gsinput[]; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> shadowIndices[MAX_SPLITS]; void main() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; gl_in.length(); i++) { gl_Position = gl_in[i].gl_Position; gl_Layer = shadowIndices[gsinput[i].instanceID]; EmitVertex(); } EndPrimitive(); }</code> </pre></div></div><br></li><li>  Render the scene from the main camera.  When calculating the shadows, the main thing to remember is to translate the distance between the current point and the light source ( <code>coords.z</code> in the code) into the range <i>[0; 1]</i> . <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">vec3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShadowCoords</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> splitIndex, vec3 worldPos</span></span></span><span class="hljs-function">)</span></span> { vec4 coords = shadowViewProjection[splitIndex] * vec4(worldPos, <span class="hljs-number"><span class="hljs-number">1</span></span>); coords.xyz = (coords.xyz / coords.w) * vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>) + vec3(<span class="hljs-number"><span class="hljs-number">0.5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coords.xyz; }</code> </pre><br>  As a result, we get a picture slightly different from Direct3D 11 (for the sake of interest, I‚Äôll show it from a different angle). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/82e/1d3/fdf/82e1d3fdfb28ae554604e6f20f58f6c6.jpg"><br></li></ol><br><h4>  Problems </h4><br>  The shadow mapping algorithm and its modifications have many problems.  Often, the algorithm has to be carefully customized for a particular game or even a specific scene.  A list of the most frequent problems and their solutions can be found <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ee416324(v%3Dvs.85).aspx">here</a> .  When implementing PSSM, I encountered the following: <br><ol><li>  The disappearance of shadows from objects that are behind the observer.  We position the shadow maps so that their coverage most closely matches the visibility pyramid from the main camera.  Accordingly, the objects located behind the observer, simply will not get into them.  I smoothed this artifact by entering into the algorithm for calculating the shadow matrices of the form-projection a shift in the direction opposite to the vector of vision.  Although this certainly does not solve the problem in the case of long shadows at sunset or shadows from tall objects. </li><li>  Truncation of object shadows.  If the object is large enough, it can be partially cut off when rendering shadow maps of the first segments.  This can be solved by adjusting the position of the camera from which the shadow is rendered, and the shift from the previous point.  With unsuccessful settings, you can see such an artifact. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d6/209/a0c/1d6209a0c4f51f4fc8f8d3cad3c193a0.jpg"><br></li><li>  Erroneous self-shadowing.  Probably the most famous graphic artifact that occurs when using shadow maps.  This problem is quite successfully solved by introducing an error when comparing the value in the shadow map with the calculated value.  In practice, I had to use individual error values ‚Äã‚Äãfor each shadow map.  The figure below on the left shows the wrong choice of errors, on the right - the successful one. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cf/9b5/6e0/2cf9b56e060f028be1d008cebe8f3e77.jpg"><br></li><li>  Unfortunately, the elimination of erroneous self-shadowing by introducing an error when comparing depths leads to another artifact called Peter Panning (it can be roughly translated as ‚ÄúPeter Pan effect‚Äù into Russian).  For those who do not remember the book, the shadow of Peter Pan lived their lives and often ran away from the owner.  It looks like this (the shadow at the corner of the house is slightly shifted). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/828/02f/a6c/82802fa6c11b981cf37fd3164f88e9c3.jpg"><br>  This artifact is sometimes quite difficult to notice, especially on objects of complex shape, but it is almost always there. </li></ol><br><h4>  Performance </h4><br>  Performance measurements were taken on a computer with the following configuration: AMD Phenom II X4 970 3.79GHz, 16Gb RAM, AMD Radeon HD 7700 Series, running Windows 8.1. <br><br>  Average frame time.  Direct3D 11 / 1920x1080 / MSAA 8x / full screen / small scene (~ 12k polygons per frame, ~ 20 objects) <br><table><tbody><tr><th>  Number of splits / Size of shadow map (N x N pixels) </th><th>  1024 </th><th>  2048 </th><th>  4096 </th></tr><tr><td>  2 </td><td>  4.5546ms </td><td>  5.07555ms </td><td>  7.1661ms </td></tr><tr><td>  3 </td><td>  5.50837ms </td><td>  6.18023ms </td><td>  9.75103ms </td></tr><tr><td>  four </td><td>  6.00958ms </td><td>  7.23269ms </td><td>  12.1952ms </td></tr></tbody></table><br>  Average frame time.  OpenGL 4.3 / 1920x1080 / MSAA 8x / full screen / small scene (~ 12k polygons per frame, ~ 20 objects) <br><table><tbody><tr><th>  Number of splits / Size of shadow map (N x N pixels) </th><th>  1024 </th><th>  2048 </th><th>  4096 </th></tr><tr><td>  2 </td><td>  3.2095ms </td><td>  4.05457ms </td><td>  6.06558ms </td></tr><tr><td>  3 </td><td>  3.9968ms </td><td>  4.87389ms </td><td>  8.65781ms </td></tr><tr><td>  four </td><td>  4.68831ms </td><td>  5.93709ms </td><td>  10.4345ms </td></tr></tbody></table><br>  Average frame time.  4 splits / 1920x1080 / MSAA 8x / full screen / large scene (~ 1000k polygons per frame, ~ 1000 objects, ~ 500 instances of objects) <br><table><tbody><tr><th>  API / Shadow Map Size (N x N pixels) </th><th>  1024 </th><th>  2048 </th><th>  4096 </th></tr><tr><td>  Direct3d 11 </td><td>  29.2031ms </td><td>  33.3434ms </td><td>  40.5429ms </td></tr><tr><td>  Opengl 4.3 </td><td>  21.0032ms </td><td>  26.4095ms </td><td>  41.8098ms </td></tr></tbody></table><br>  The results showed that on large and small scenes, the implementation on OpenGL 4.3 works, in general, faster.  With an increase in the load on the graphics pipeline (an increase in the number of objects and their instances, an increase in the size of shadow maps), the difference in work speed between implementations is reduced.  I associate the advantage of implementation on OpenGL with a method of forming a shadow map other than Direct3D 11 (we used only the depth buffer without writing to the color).  Nothing prevents us from doing the same on Direct3D 11, while accepting the use of normalized depth values.  However, this approach will work only as long as we do not want to store in the shadow map any additional data or function of the depth value instead of the depth value.  And some improvements of the algorithm (for example, <a href="http://steps3d.narod.ru/tutorials/vsm-tutorial.html">Variance Shadow Mapping</a> ) will be difficult for us to implement. <br><br><h4>  findings </h4><br>  The PSSM algorithm is one of the most successful ways to create shadows in large open spaces.  It is based on a simple and clear principle of splitting, which can be easily scaled by increasing or decreasing the quality of shadows.  This algorithm can be combined with other shadow mapping algorithms for more beautiful soft shadows or more physically correct shadows.  At the same time, shadow mapping algorithms often lead to the appearance of unpleasant graphic artifacts that must be eliminated by fine-tuning the algorithm for a particular game. </div><p>Source: <a href="https://habr.com/ru/post/226421/">https://habr.com/ru/post/226421/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../226407/index.html">Mobile Application Design</a></li>
<li><a href="../226411/index.html">The biggest black hole in the known universe</a></li>
<li><a href="../226413/index.html">The sum of opinions: what users say in the test drive Nokia Lumia 1520</a></li>
<li><a href="../226417/index.html">Logic of auto-robot: from engine vision to transmission control</a></li>
<li><a href="../226419/index.html">Django on production. uWSGI + nginx. Detailed guide</a></li>
<li><a href="../226423/index.html">Launch Internet Explorer Developer Channel</a></li>
<li><a href="../226425/index.html">About encryption of referrers in Yandex</a></li>
<li><a href="../226427/index.html">The evolution of Microsoft web frameworks. ASP.NET vNext</a></li>
<li><a href="../226429/index.html">Amateur astronomy: a view from the inside of the community on hobbies and newcomers' rakes</a></li>
<li><a href="../226431/index.html">Wi-Fi networks: penetration and protection. 3) WPA. OpenCL / CUDA. Pick statistics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>