<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Puppet. Part 1: An Introduction to Hiera</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is the first of three articles in which I want to give my vision of the problem of managing large infrastructures with Puppet. The first ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Puppet. Part 1: An Introduction to Hiera</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/files/89d/af3/365/89daf3365e114253a0824d4651683504.png"><br>  This article is the first of three articles in which I want to give my vision of the problem of managing large infrastructures with Puppet.  The first part is an introduction to the powerful hierarchy organization tool Puppet Hiera.  This article is aimed at people already familiar with Pappet, but not yet familiar with Hiera.  In it, I will try to give basic knowledge about this powerful tool and how it facilitates the management of a large number of servers. <br><br>  You probably know or imagine that managing a large infrastructure with <a href="https://puppetlabs.com/">Puppet</a> is not an easy task.  If for ten servers Pappet is not needed, for fifty at the most time and the code can be written as you like, when it comes to 500+ servers, in this case you have to seriously think about optimizing your efforts.  It is bad that Pappet initially, apparently, did not think about how a solution for large infrastructures, at least the hierarchy in it was initially laid down very badly.  Standard <a href="https://docs.puppetlabs.com/puppet/latest/reference/lang_node_definitions.html">node definitions are</a> completely inapplicable in large companies.  <a href="https://docs.puppetlabs.com/puppet/latest/reference/lang_node_definitions.html">Node inheritance</a> (as well as <a href="https://docs.puppetlabs.com/puppet/latest/reference/lang_classes.html">class inheritance</a> ) Puppetlabs do not recommend using more at all; instead, it is better to download hierarchy data from external sources such as <a href="https://docs.puppetlabs.com/hiera/latest">Hiera</a> and <a href="https://docs.puppetlabs.com/guides/external_nodes.html">External Node Classifier</a> (ENC). <a name="habracut"></a><br>  Despite the fact that initially the concept of ENC is not much different from Hiera, nevertheless, for some reason, I don‚Äôt really like specific ENC implementations such as <a href="https://docs.puppetlabs.com/dashboard/manual/1.2/bootstrapping.html">Puppet Dashboard</a> and <a href="http://theforeman.org/">Foreman</a> .  Let me explain why: <br><br>  <b>1)</b> My infrastructure data is somewhere in the application database.  How to get them from there in case of application crash?  I dont know.  I can speculate, but I don‚Äôt know for sure. <br>  <b>2)</b> Powerful ENC because of its power is bad and difficult to scale.  In contrast, Hiera stores all her data in text form.  Text data is very easy to synchronize via git and <a href="https://github.com/adrienthebo/r10k">r10k</a> between several Pappet masters, if such a need arises.  In general, textual configurations are a UNIX way, however old-fashioned it may sound. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Again, I do not reject the potential of Puppet Dashboard and Foreman as a means of monitoring and reporting.  A beautiful web interface with graphs and images is necessary, but only as a means of viewing, not as a means of changing the configuration of your infrastructure.  And I also know that Foreman does a lot of things besides Pappet (the <a href="https://access.redhat.com/products/red-hat-satellite">Red Hat Satellite Server 6</a> and <a href="http://www.katello.org/">Katello project</a> based on Foreman are vivid examples).  But nevertheless, I like it more as a place to store the configuration of my entire Hiera infrastructure. <br><br>  <b>What is Hiera?</b>  This is the Ruby library, which by default is included in the Pappet and helps to better organize your data in Pappet.  Is it possible to do without it?  Can.  You can write all the numbers and parameters in manifests, but then from a certain stage of development they will take on a completely intimidating form, and it will become harder and harder for you to remember where things are stored and what they are responsible for. <br><br>  <b>What is the profit of using Heera?</b>  You begin to separate the specific parameters of your infrastructure (user uids, ssh keys, dns settings, various centralized files, etc.) from Pappet code, which actually applies them to your infrastructure.  This leads to the fact that if one day you need to find out which UID of such and such a user on such a server or even a group of servers, you will immediately know exactly where this information is stored, and you will not frantically flick through all your manifests in search of the desired user and try to predict what the UID‚Äôs change "here in this place" will lead to.  Of course, no need to expect a miracle from Hiera.  In the end, this is just a way to store and organize your data. <br><br>  <b>But enough of the lyrics</b> , get down to business.  Hiera (from hierarchy) operates a hierarchy.  And I wrote the following hierarchy in /etc/puppet/hiera.yaml: <br><pre><code class="ruby hljs"><span class="hljs-symbol"><span class="hljs-symbol">:hierarchy</span></span>: - <span class="hljs-string"><span class="hljs-string">"%{::environment}/nodes/%{::fqdn}"</span></span> - <span class="hljs-string"><span class="hljs-string">"%{::environment}/roles"</span></span> - <span class="hljs-string"><span class="hljs-string">"%{::environment}/%{::environment}"</span></span> - common <span class="hljs-symbol"><span class="hljs-symbol">:backends</span></span>: - yaml <span class="hljs-symbol"><span class="hljs-symbol">:yaml</span></span>: <span class="hljs-symbol"><span class="hljs-symbol">:datadir</span></span>: <span class="hljs-string"><span class="hljs-string">'/etc/puppet/hiera'</span></span></code> </pre> <br>  Remember this hierarchy, in the future I will actively use it. <br>  For those who are not very familiar with Hiera, I will explain.  We set the folder "/ etc / puppet / hiera" as Hiera's data store.  Files in this folder must have the extension <b>.yaml</b> and data format <a href="http://www.yaml.org/YAML_for_ruby.html">YAML</a> .  Next, we set the file names that Hiera would expect to see in her folder.  Since Hiera is called from the Pappet code, the same variables are available to her as Pappet, including the <a href="https://docs.puppetlabs.com/puppet/latest/reference/lang_facts_and_builtin_vars.html">facts</a> .  The built-in fact of each node is its environment, which can be used in Hiere as a variable <b>% {:: environment}</b> .  <a href="https://ru.wikipedia.org/wiki/FQDN">The FQDN of the</a> node in Hiera predictably looks like <b>% {:: fqdn}</b> .  Thus, this hierarchy corresponds to a similar file structure: <br><br>  <b>/ etc / puppet / hiera /</b> <b><br></b>  <b>| - common.yaml</b> <b><br></b>  <b>| - production /</b> <b><br></b>  <b>| ----- production.yaml</b> <b><br></b>  <b>| ----- roles.yaml</b> <b><br></b>  <b>| ----- nodes /</b> <b><br></b>  <b>| -------- prod-node1.yaml</b> <b><br></b>  <b>| -------- prod-node2.yaml</b> <b><br></b>  <b>| - development /</b> <b><br></b>  <b>| ----- development.yaml</b> <b><br></b>  <b>| ----- roles.yaml</b> <b><br></b>  <b>| ----- nodes /</b> <b><br></b>  <b>| -------- dev-node1.yaml</b> <b><br></b>  <b>| -------- dev-node2.yaml</b> <br><br>  The order of the levels in hiera.yaml (not in the file structure) is important.  Hiera starts viewing from top to bottom, and then it all depends on the method of calling Hiera, which you use in the Pappet manifest.  There are <a href="https://docs.puppetlabs.com/hiera/1/lookup_types.html">three methods</a> , I will demonstrate them by example.  Let our hierarchy be described by the hiera.yaml file described above, we will create three files of the following content: <br><div class="spoiler">  <b class="spoiler_title">/etc/puppet/hiera/common.yaml</b> <div class="spoiler_text"><pre>  classes:
   - common_class1
   - common_class2
 roles:
   common_role1:
     key1: value1
     key2: value2
 common: common_value </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/puppet/hiera/production/production.yaml</b> <div class="spoiler_text"><pre>  classes:
   - production_class1
   - production_class2
 roles:
   production_role1:
     key1: value1
     key2: value2
 production: production_value </pre></div></div><br><div class="spoiler">  <b class="spoiler_title">/etc/puppet/hiera/production/nodes/testnode.yaml</b> <div class="spoiler_text"><pre>  classes:
   - node_class1
   - node_class2
 roles:
   node_role1:
     key1: value1
     key2: value2
 node: node_value </pre></div></div><br>  Hiera supports command line prompts.  In fact, the easiest way to understand how it works is from the console.  Hiera by default keeps its config in /etc/hiera.yaml.  You need to make this file a symbolic link to /etc/puppet/hiera.yaml.  After that we make a simple call: <br><blockquote><pre> <code class="bash hljs">[root@testnode]<span class="hljs-comment"><span class="hljs-comment"># hiera classes ["common_class1", "common_class2"]</span></span></code> </pre></blockquote>  Because in this query we did not provide information about the environment and fqdn Hiera takes data from the lowest level of the hierarchy, the common.yaml file.  Array elements are displayed in square brackets.  Let's try to provide information about the environment: <blockquote><pre> <code class="bash hljs">[root@testnode]<span class="hljs-comment"><span class="hljs-comment"># hiera classes ::environment=production ["production_class1", "production_class2"] [root@testnode]# hiera classes ::environment=production ::fqdn=testnode ["node_class1", "node_class2"]</span></span></code> </pre></blockquote>  The data from production.yaml are higher in the hierarchy, so they are more priority and overwrite data obtained from common.yaml.  Similarly, data from testnode.yaml overwrites data from production.yaml.  However, if the data is not in the parent hierarchy, then the data is logically taken from the downstream: <br><blockquote><pre> <code class="bash hljs">[root@testnode]<span class="hljs-comment"><span class="hljs-comment"># hiera common ::environment=production common_value [root@testnode]# hiera production ::environment=production ::fqdn=testnode production_value</span></span></code> </pre></blockquote>  In this case, strings are returned, not arrays, according to the above files. <br>  This type of request is called the <a href="https://docs.puppetlabs.com/hiera/1/lookup_types.html">priority lookup</a> .  As you can see, it always returns the first found value in the hierarchy (with the highest priority), and then it is completed without examining the underlying hierarchies.  In Pappet, it corresponds to the standard function hiera ().  In our example, this would be a call to hiera ('classes').  Since Pappet always calls Hyerra from the appropriate context, we don‚Äôt need to additionally specify something in the query string. <br><br>  The next type of request is <a href="https://docs.puppetlabs.com/hiera/1/lookup_types.html">Array merge</a> .  We look: <br><blockquote><pre> <code class="bash hljs">[root@testnode]<span class="hljs-comment"><span class="hljs-comment"># hiera --array classes ["common_class1", "common_class2"] [root@testnode]# hiera --array classes ::environment=production ["production_class1", "production_class2", "common_class1", "common_class2"] [root@testnode]# hiera --array classes ::environment=production ::fqdn=testnode ["node_class1", "node_class2", "production_class1", "production_class2", "common_class1", "common_class2"]</span></span></code> </pre></blockquote>  This type of query passes through all levels of the hierarchy and collects all found values ‚Äã‚Äã(strings and arrays) into one large single array.  In Pappet's terminology, this request is called hiera_array ().  However, this type of request is not able to collect hashes.  If during its passage it encounters a hash, it will give an error: <br><blockquote><pre> <code class="bash hljs">[root@testnode]<span class="hljs-comment"><span class="hljs-comment"># hiera --array roles /usr/share/ruby/vendor_ruby/hiera/backend/yaml_backend.rb:38:in `block in lookup': Hiera type mismatch: expected Array and got Hash (Exception)</span></span></code> </pre></blockquote>  In a similar situation, the priority lookup will go fine and return a hash (in curly brackets): <br><blockquote><pre> <code class="bash hljs">[root@testnode]<span class="hljs-comment"><span class="hljs-comment"># hiera roles {"common_role1"=&gt;{"key1"=&gt;"value1", "key2"=&gt;"value2"}}</span></span></code> </pre></blockquote><br>  What to do if we need to collect hashes?  Use the third query type: <a href="https://docs.puppetlabs.com/hiera/1/lookup_types.html">Hash merge</a> : <br><blockquote><pre> <code class="bash hljs">[root@testnode]<span class="hljs-comment"><span class="hljs-comment"># hiera --hash roles {"common_role1"=&gt;{"key1"=&gt;"value1", "key2"=&gt;"value2"}} [root@testnode]# hiera --hash roles ::environment=production {"common_role1"=&gt;{"key1"=&gt;"value1", "key2"=&gt;"value2"}, "production_role1"=&gt;{"key1"=&gt;"value1", "key2"=&gt;"value2"}} [root@testnode]# hiera --hash roles ::environment=production ::fqdn=testnode {"common_role1"=&gt;{"key1"=&gt;"value1", "key2"=&gt;"value2"}, "production_role1"=&gt;{"key1"=&gt;"value1", "key2"=&gt;"value2"}, "node_role1"=&gt;{"key1"=&gt;"value1", "key2"=&gt;"value2"}}</span></span></code> </pre></blockquote>  This query, similar to the previous one, passes through all levels of the hierarchy and collects all the hashes into one large common hash.  It is easy to guess that when you try to build them arrays or strings, it will return an error: <br><blockquote><pre> <code class="bash hljs">[root@testnode]<span class="hljs-comment"><span class="hljs-comment"># hiera --hash classes /usr/share/ruby/vendor_ruby/hiera/backend/yaml_backend.rb:42:in `block in lookup': Hiera type mismatch: expected Hash and got Array (Exception)</span></span></code> </pre></blockquote>  On Pappet, this request is called hiera_hash ().  What happens if, at different levels of the hierarchy, the same hash has different sets of ‚Äúkey =&gt; value‚Äù?  For example, test user at the common level has UID = 100, and at the node level testnode has UID = 200?  In this case, for each specific key, hash lookup will behave as an priority lookup, that is, return a higher priority value.  You can read more about it <a href="https://docs.puppetlabs.com/hiera/1/lookup_types.html">here</a> . <br><br>  <b>Okay, cool</b> <i>( <a href="">or not</a> )</i> , <b>but why is this all of us?</b> <br>  Pappet <a href="https://docs.puppetlabs.com/hiera/1/lookup_types.html">automatically</a> (in versions 3.x, for this, even nothing needs to be set up) looks at Heer for parameters that can be used by him. <br>  For a start, a simple slightly modified example from <a href="https://docs.puppetlabs.com/hiera/1/complete_example.html">the Pappet site</a> (by the way, the example now shows the outdated parameters ntp :: autoupdate and ntp :: enable, I have below their actual names).  We will torment the long-suffering module <a href="https://forge.puppetlabs.com/puppetlabs/ntp">puppetlabs-ntp</a> .  Suppose we want to express in the Pappet the following ntp configuration: <br><div class="spoiler">  <b class="spoiler_title">/etc/ntp.conf</b> <div class="spoiler_text">  tinker panic 0 <br>  restrict restrict default kod nomodify notrap nopeer noquery <br>  restrict restrict -6 default kod nomodify notrap nopeer noquery <br>  restrict restrict 127.0.0.1 <br>  restrict restrict -6 :: 1 <br>  server 0.pool.ntp.org iburst burst <br>  server 1.pool.ntp.org iburst burst <br>  server 2.pool.ntp.org iburst burst <br>  server 3.pool.ntp.org iburst burst <br>  driftfile / var / lib / ntp / drift </div></div><br>  To do this, add the following lines to common.yaml in Hiera: <br><blockquote><pre> <code class="ruby hljs"><span class="hljs-symbol"><span class="hljs-symbol">classes:</span></span> - ntp ntp::<span class="hljs-symbol"><span class="hljs-symbol">restrict:</span></span> - restrict default kod nomodify notrap nopeer noquery - restrict -<span class="hljs-number"><span class="hljs-number">6</span></span> default kod nomodify notrap nopeer noquery - restrict <span class="hljs-number"><span class="hljs-number">127.0</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> - restrict -<span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">1</span></span> ntp::<span class="hljs-symbol"><span class="hljs-symbol">service_ensure:</span></span> running ntp::<span class="hljs-symbol"><span class="hljs-symbol">service_enable:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> ntp::<span class="hljs-symbol"><span class="hljs-symbol">servers:</span></span> - <span class="hljs-number"><span class="hljs-number">0</span></span>.pool.ntp.org iburst burst - <span class="hljs-number"><span class="hljs-number">1</span></span>.pool.ntp.org iburst burst - <span class="hljs-number"><span class="hljs-number">2</span></span>.pool.ntp.org iburst burst - <span class="hljs-number"><span class="hljs-number">3</span></span>.pool.ntp.org iburst burst</code> </pre></blockquote>  It is easy to notice that here the concrete values ‚Äã‚Äãof the ntp class variables are simply listed, which will be passed to the class when it is called.  These variables are declared in the ntp class header (modules / ntp / manifests / init.pp file).  With this method of passing parameters to the class from Hiera, it is necessary to use <a href="https://docs.puppetlabs.com/puppet/latest/reference/lang_variables.html">fully qualified</a> variable names in order for Pappet to correctly load them into the required <a href="https://docs.puppetlabs.com/puppet/latest/reference/lang_scope.html">scope</a> . <br>  The only thing left to do is to add one line to the main Pappet manifesto of your environment (site.pp): <br><blockquote><pre> <code class="ruby hljs">hiera_include(<span class="hljs-string"><span class="hljs-string">'classes'</span></span>)</code> </pre></blockquote>  This line, despite its simplicity and brevity, produces a lot of work behind the scenes.  First, Pappet goes through all (!) Hiera hierarchies and loads <u>all</u> classes declared in <u>all</u> sections of the " <b>classes:</b> " Hiera.  Then Pappet passes through all the fully qualified variables in Hiera and loads them into the scope of the corresponding class.  It is easy to guess that if you remove the ntp class from the classes list, but forget to remove the variables of this class in the YAML file, Pappet will generate an error like ‚Äúcannot find named class ntp‚Äù.  Without a loaded class, its variables lose all meaning. <br>  Here I have to say that the word classes (like all the others) in HAMA‚Äôs YAML files does not carry any special or reserved meaning.  Instead of classes, you can write any other word, for example, production_classes, my_classes, my -% {:: environment}.  Yes, the latter is also true; Pappet <a href="https://docs.puppetlabs.com/hiera/1/puppet.html">variables</a> can also be used in the names of the Hiera sections and hash keys.  In the values ‚Äã‚Äãof hashes, as well as in string variables and arrays, variables cannot be used, and sometimes it's a pity! <br><br>  Thus, we effectively removed the ntp service parameters from the Pappet manifest to the Hyera hierarchy.  Now, in accordance with the hierarchy described at the beginning of the article, these ntp parameters will be applied to absolutely all the nodes in your infrastructure.  But if you want to redefine these parameters at a higher environment level or at a specific server level, you can easily do this by specifying the variable values ‚Äã‚Äãyou need at the hierarchy level you need. <br><br>  In fact, this method of automatically importing data from Hyera to Pappet is not the only one. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac2/057/0de/ac20570deeffc2c63339243b31b5b2e5.jpg" alt="image"></div></div></div><br>  The previous method has one major drawback: it is <u>too</u> automatic.  If on simple configurations we can easily predict its behavior, then in the case of a large number of hosts it is not always possible to say with certainty what the addition of another class to the list of imported ones will lead to.  For example, you can use the <a href="https://forge.puppetlabs.com/puppetlabs/apache">puppetlabs-apache</a> module to add a specific Apache configuration to some nodes.  If you include a harmless phrase <br><blockquote><pre> <code class="ruby hljs"><span class="hljs-symbol"><span class="hljs-symbol">classes:</span></span> - apache</code> </pre></blockquote>  to the <b>production.yaml</b> file, this will install, configure, and start up Apache on all production hosts.  Moreover, the apache module will erase the <u>entire previous</u> Apache <u>configuration</u> , which has already been configured before it. <br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c29/cca/a60/c29ccaa605ad0f9d80004303d0cc930d.jpg" alt="image"></div></div></div><br>  Here is his <a href="https://forge.puppetlabs.com/puppetlabs/apache">fun default behavior</a> !  So a simple 'include apache' can sometimes be costly if you don‚Äôt read the documentation. <br><br>  But what to do?  To enter the Apache in YAML only the nodes we need?  Somehow this is not quite centrally obtained ... <br>  To have a choice of what we want to include and what we do not want, the Pappet function <a href="https://docs.puppetlabs.com/references/latest/function.html">create_resources ()</a> was created.  Its use is beautifully described <a href="http://puppetlunch.com/puppet/hiera.html">here</a> . <br>  Function <b>create_resources (resource, hash1, hash2)</b> : creates a resource <b>resource for</b> Pappet, passing it <b>hash1</b> and <b>hash2 to it</b> .  Hash2 is optional, but if it is specified, its keys and values ‚Äã‚Äãwill be added to hash1.  If the same parameter is specified in both hash1 and hash2, then hash1 takes precedence.  A Pappet resource can be either from the list of standard (see <a href="https://docs.puppetlabs.com/references/latest/type.html">Puppet type reference</a> ), either previously declared ( <a href="https://docs.puppetlabs.com/learning/definedtypes.html">defined type</a> ) by us or in a class.  An example of a standard resource is the user resource, an example of the declared one is apache :: vhost from the apache module.  Consider an example with an Apache (here I allow myself to copy a good example from the above <a href="http://puppetlunch.com/puppet/hiera.html">link</a> ). <br><br>  Suppose we want to transfer the following configuration of two virtual hosts of Apache to Hieru: <br><blockquote><pre> <code class="ruby hljs">apache::vhost { <span class="hljs-string"><span class="hljs-string">'foo.example.com'</span></span>: port =&gt; <span class="hljs-string"><span class="hljs-string">'80'</span></span>, docroot =&gt; <span class="hljs-string"><span class="hljs-string">'/var/www/foo.example.com'</span></span>, docroot_owner =&gt; <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, docroot_group =&gt; <span class="hljs-string"><span class="hljs-string">'foo'</span></span>, options =&gt; [<span class="hljs-string"><span class="hljs-string">'Indexes'</span></span>,<span class="hljs-string"><span class="hljs-string">'FollowSymLinks'</span></span>,<span class="hljs-string"><span class="hljs-string">'MultiViews'</span></span>], proxy_pass =&gt; [ { <span class="hljs-string"><span class="hljs-string">'path'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/a'</span></span>, <span class="hljs-string"><span class="hljs-string">'url'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'http://backend-a/'</span></span> } ], } apache::vhost { <span class="hljs-string"><span class="hljs-string">'bar.example.com'</span></span>: port =&gt; <span class="hljs-string"><span class="hljs-string">'80, docroot: =&gt; '</span></span>/var/www/bar.example.com<span class="hljs-string"><span class="hljs-string">', }</span></span></code> </pre></blockquote><br>  In Hiera, it will look like this: <br><blockquote><pre> <code class="ruby hljs">apache::<span class="hljs-symbol"><span class="hljs-symbol">vhosts:</span></span> foo.example.<span class="hljs-symbol"><span class="hljs-symbol">com:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">port:</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-symbol"><span class="hljs-symbol">docroot:</span></span> /var/www/foo.example.com <span class="hljs-symbol"><span class="hljs-symbol">docroot_owner:</span></span> foo <span class="hljs-symbol"><span class="hljs-symbol">docroot_group:</span></span> foo <span class="hljs-symbol"><span class="hljs-symbol">options:</span></span> - Indexes - FollowSymLinks - MultiViews <span class="hljs-symbol"><span class="hljs-symbol">proxy_pass:</span></span> - <span class="hljs-symbol"><span class="hljs-symbol">path:</span></span> <span class="hljs-string"><span class="hljs-string">'/a'</span></span> <span class="hljs-symbol"><span class="hljs-symbol">url:</span></span> <span class="hljs-string"><span class="hljs-string">'http://localhost:8080/a'</span></span> bar.example.<span class="hljs-symbol"><span class="hljs-symbol">com:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">port:</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-symbol"><span class="hljs-symbol">docroot:</span></span> /var/www/bar.example.com</code> </pre></blockquote>  All that remains to be written in the Pappet Manifesto is: <br><blockquote><pre> <code class="ruby hljs">$myvhosts = hiera(<span class="hljs-string"><span class="hljs-string">'apache::vhosts'</span></span>, {}) create_resources(<span class="hljs-string"><span class="hljs-string">'apache::vhost'</span></span>, $myvhosts)</code> </pre></blockquote>  Here in the first line we asked Hiera to load the entire configuration from the apache :: vhosts section.  The information was loaded in the form of two hashes: 'foo.example.com' and 'bar.example.com' (if absolutely accurate, then the nameless hash consisting of two named hashes fell into the $ myvhosts variable).  After that, the data hashes in turn were passed to the input resource apache :: vhosts, which will lead to their creation Pappet. <br><br>  Another good example of how you can transfer data from manifests to Hieru.  User management.  If you write the following code in Hiera: <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="ruby hljs"><span class="hljs-symbol"><span class="hljs-symbol">users:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">user1:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">ensure:</span></span> present <span class="hljs-symbol"><span class="hljs-symbol">home:</span></span> /home/user1 <span class="hljs-symbol"><span class="hljs-symbol">shell:</span></span> /bin/sh <span class="hljs-symbol"><span class="hljs-symbol">uid:</span></span> <span class="hljs-number"><span class="hljs-number">10001</span></span> <span class="hljs-symbol"><span class="hljs-symbol">managehome:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-symbol"><span class="hljs-symbol">user2:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">ensure:</span></span> present <span class="hljs-symbol"><span class="hljs-symbol">home:</span></span> /home/user2 <span class="hljs-symbol"><span class="hljs-symbol">shell:</span></span> /bin/sh <span class="hljs-symbol"><span class="hljs-symbol">uid:</span></span> <span class="hljs-number"><span class="hljs-number">10002</span></span> <span class="hljs-symbol"><span class="hljs-symbol">groups:</span></span> - secondary_group1 - secondary_group2 <span class="hljs-symbol"><span class="hljs-symbol">user3:</span></span> <span class="hljs-symbol"><span class="hljs-symbol">ensure:</span></span> present <span class="hljs-symbol"><span class="hljs-symbol">home:</span></span> /home/user3 <span class="hljs-symbol"><span class="hljs-symbol">shell:</span></span> /bin/sh <span class="hljs-symbol"><span class="hljs-symbol">uid:</span></span> <span class="hljs-number"><span class="hljs-number">10003</span></span> <span class="hljs-symbol"><span class="hljs-symbol">groups:</span></span> - secondary_group3 - secondary_group4</code> </pre></div></div><br>  And then in site.pp write: <br><blockquote><pre> <code class="ruby hljs">$node_users = hiera_hash(<span class="hljs-string"><span class="hljs-string">'users'</span></span>) create_resources(user, $users, {})</code> </pre> </blockquote>  then it will create all of the above users.  Notice that calling hiera_hash will effectively bring together all the users declared in the users: section with your entire hierarchy.  If conflicts arise somewhere (different user UIDs in different files), Hiera will take the value described in a higher hierarchy level.  Is logical. <br><br>  Also, create_resources () along with defined types is one of the ways to organize iteration over the cycle in Pappet, which is initially deprived of this function (at least without the future parser, are you not so insane to use it yet?).  Both ways of iteration are well described <a href="https://tobrunet.ch/2013/01/iterate-over-datastructures-in-puppet-manifests/">here</a> . <br><br>  Here to begin with and all.  I gave the basics of using Hyera.  Using the standard functions of Pappet, hiera (), hiera_array (), hiera_hash (), hiera_include () and create_resources (), as you probably already guessed, you can think of a lot of things. <br>  In the next article I will try to describe the management of server roles using Pappet and Hiera. </div><p>Source: <a href="https://habr.com/ru/post/242657/">https://habr.com/ru/post/242657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242643/index.html">Create a portfolio based on photos from Instagram</a></li>
<li><a href="../242645/index.html">‚ÄúNever say never‚Äù or working with timezone correctly</a></li>
<li><a href="../242647/index.html">The simplest SMTP server for development</a></li>
<li><a href="../242649/index.html">Lattice inheritance</a></li>
<li><a href="../242653/index.html">New profession at the first attempt or sincerity at the interview</a></li>
<li><a href="../242659/index.html">As I suddenly cut interest in the texts</a></li>
<li><a href="../242665/index.html">About the applied aspects of managing people in an organization or where are the children?</a></li>
<li><a href="../242669/index.html">The digest of interesting materials for mobile developer # 78 (November 2-9)</a></li>
<li><a href="../242673/index.html">Registration of RES through the portal of state services</a></li>
<li><a href="../242675/index.html">Electronic signature. The history of the emergence and development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>