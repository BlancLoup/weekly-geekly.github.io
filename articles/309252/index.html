<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Voronoi diagram and its applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good all the time of day, dear visitors Habrahabr site. In this article I would like to tell you about what the Voronoi diagram is (shown in the pictu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Voronoi diagram and its applications</h1><div class="post__text post__text-html js-mediator-article">  Good all the time of day, dear visitors Habrahabr site.  In this article I would like to tell you about what the Voronoi diagram is (shown in the picture below), about the various algorithms for its construction (for <img src="https://habrastorage.org/getpro/habr/post_images/779/d1d/ce6/779d1dce68f0e915837b5e3686dd33a1.gif" title="O (n ^ 4)">  , <img src="https://habrastorage.org/getpro/habr/post_images/06c/fca/fd3/06cfcafd30903e22872fa03ce2bd746e.gif" title="O (n ^ 2 * log (n))">  - the intersection of half-planes, <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))">  - Forchun's algorithm) and some implementation intricacies (in C ++). <br><br> <a href="https://habrahabr.ru/post/309252/"><img src="https://habrastorage.org/files/b40/0a5/4aa/b400a54aa65b461f92fe802acee5ac40.jpg"></a> <br><br>  There will also be considered many interesting applications of the chart and some interesting facts about it.  It will be interesting! <br><a name="habracut"></a><br>  Article layout: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - <a href="https://habr.com/ru/post/309252/">Required concepts and definitions</a> <br>  - <a href="https://habr.com/ru/post/309252/">Algorithms of construction</a> <br>  - <a href="https://habr.com/ru/post/309252/">Applications</a> <br>  - <a href="https://habr.com/ru/post/309252/">Interesting facts</a> <br>  - <a href="https://habr.com/ru/post/309252/">References</a> <br><br>  It should be noted that in this article only algorithms for constructing a Voronoi diagram on a plane will be considered.  Along the way, some other algorithms needed to construct a diagram will be considered - an algorithm for determining the point of intersection of two segments, an algorithm O'Rourt the intersection of two convex polygons, an algorithm for constructing a "coastline". <br><br><a name="Part1"></a><h2>  Necessary concepts and definitions </h2><br>  At once I will say that <b>everything</b> that will continue to happen is <b>on the plane</b> . <br><br>  Well, before you begin to understand what it is - the Voronoi diagram, I recall some concepts of the geometric objects we need (however, it is assumed that you are already familiar with the definitions of point, line, ray, segment, polygon, vertex and edge of a polygon, vector and intuitive notion of plane partitioning): <br><br>  <i>A simple polygon</i> is a self-intersected polygon.  We will consider only simple polygons. <br><br>  <i>A non-convex polygon</i> is a polygon in which there are two vertices such that through them a line intersects the given polygon somewhere other than the edge connecting these vertices (see the picture), <br><br>  <i>A convex polygon</i> is a polygon whose extensions of the sides do not intersect its other sides (see picture).  Other definitions can be found on <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B8%25D0%25BA">Wikipedia</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/543/76a/71654376a6eb6e19c2ef27e3d22cb901.png"></div><br>  It is from convex polygons that the diagram will consist.  Why precisely convex?  Because they are nothing more than the intersection of half-planes (as we will see later), which are convex figures, but why intersection of convex figures is a convex figure, I suggest you find out for yourself (there is evidence, for example, in the book <a href="https://habr.com/ru/post/309252/">[2]</a> ). <br><br>  Since I started talking about the half-plane, then you can smoothly go to the diagram itself - it consists of the so-called <b>loci</b> - areas in which there are all points that are closer to a given point than to all the others.  In the Voronoi diagram, the loci are convex polygons. <br><br>  How to build a <b>locus</b> ?  By definition, it will be constructed as follows: let given a set of n points for which we build a diagram.  Take a specific point <b>p</b> for which we are building a locus, and another point from the given set - <b>q</b> (not equal to <b>p</b> ).  Let's draw a segment connecting these two points and draw a straight line that will be the middle perpendicular of this segment.  This line divides the plane into two half-planes - in one lies the point <b>p</b> , in the other lies the point <b>q</b> .  In this case, the loci of these two points are the resulting half-planes.  That is, in order to build a locus of a point <b>p</b> , one must obtain the intersection of all such half-planes (that is, all points of a given set, except <b>p</b> , will be in place of <b>q</b> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f56/757/432/f56757432d1ba9cbbba544dd0a695052.png"></div><br>  The point for which the locus is built is called the <b>site</b> .  In the next picture loci are marked with different colors. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a59/8db/e24/a598dbe24747f5ca5e75f1f97ac53665.png" height="25%" width="25%"></div><br>  Algorithms for constructing a diagram are precisely nothing more than algorithms for constructing these same <i>loci</i> for all points from a given set.  Loci in this problem are also called <i>Voronoi polygons</i> or <i>Voronoi cells</i> . <br><br>  Finally, we formulate the definition of <b>the Voronoi diagram of n points on a plane</b> (n is natural) ‚Äîthis is a <b>partition of a plane</b> consisting <b>of n loci</b> (for each point along the locus).  Again, another definition of the definition can be found on <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE">Wikipedia</a> . <br><br>  By the way, here is a <a href="http://alexbeutel.com/webgl/voronoi.html">site with an interactive color visualizer of</a> the Voronoi diagram, you can click on the area <s>yourself</s> and <s>stick</s> to see how the diagram is constructed. <br><br>  If you wonder how the diagram appeared and why it bears the name of Voronoi, then you should look under the spoiler below. <br><br><div class="spoiler">  <b class="spoiler_title">Historical facts</b> <div class="spoiler_text"><h2>  A bit of history </h2><br>  (material taken from <a href="http://botinok.co.il/node/42783">this</a> site) <br>  In general, the first use of this diagram is found in the work of Rene Descartes (1596‚Äì1650) ‚ÄúBeginning of Philosophy‚Äù (1644).  Descartes proposed the division of the Universe into zones of the gravitational influence of stars. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4f8/fe8/8b4/4f8fe88b403c4849672b70c2c888cd2e.jpg" height="105%"><img src="https://habrastorage.org/getpro/habr/post_images/7b4/8f6/b39/7b48f6b39f03035d20a0bdcd26a7eb1b.jpg" height="5%" width="20%"><br><br>  Only two centuries later, the famous German mathematician Johann Peter Gustave Lejeune-Dirichlet (1805-1859) introduced diagrams for two- and three-dimensional cases.  Therefore, they are sometimes called Dirichlet diagrams. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/936/de6/ed6/936de6ed60da0d14c5d27b22bf269457.jpg" height="25%" width="25%"><br><br>  But already in 1908, the Russian mathematician Georgy Feodosievich Voronoy (April 16 (28), 1868 - November 7 (20), 1908) described this diagram for spaces of higher dimensions, and since then the diagram bears his last name.  Here is his brief biography (taken from <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B9,_%25D0%2593%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B3%25D0%25B8%25D0%25B9_%25D0%25A4%25D0%25B5%25D0%25BE%25D0%25B4%25D0%25BE%25D1%2581%25D1%258C%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2587">Wikipedia</a> ): <br><br>  Georgiy Feodosevich Voronoy was born in the village of Zhuravka, Poltava province (now Chernihiv region).  From 1889 he studied at St. Petersburg University from <i>Andrei Markov</i> .  In 1894 he defended his master's thesis "On integers that depend on the root of an equation of the third degree."  In the same year he was elected a professor at the University of Warsaw, where he studied continued fractions.  Voronoi studied <i>Wenceslas Sierpinski</i> .  In 1897, Voronoi defended his doctoral thesis "On a generalization of the continuous fraction algorithm", which was awarded the Bunyakovsky Prize. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/5bb/76f/ec75bb76f4186cabc0cc49b37b7e3f38.jpg"><br></div></div><br><a name="Part2"></a><h2>  Algorithms of construction </h2><br>  Learn to build a Voronoi diagram.  We will look at 4 algorithms, 2 of which in detail (1 with implementation, a full implementation of the Forchun algorithm will be covered in a separate article), 2 more briefly (and without implementation): <br><br><ol><li>  Algorithm for constructing a Voronoi diagram "head on."  Complexity: <img src="https://habrastorage.org/getpro/habr/post_images/779/d1d/ce6/779d1dce68f0e915837b5e3686dd33a1.gif" title="O (n ^ 4)">  ; </li><li>  Algorithm for constructing a Voronoi diagram by intersecting half-planes.  Complexity: <img src="https://habrastorage.org/getpro/habr/post_images/06c/fca/fd3/06cfcafd30903e22872fa03ce2bd746e.gif" title="O (n ^ 2 * log (n))">  ; </li><li>  Forchun's algorithm for constructing a Voronoi diagram on a plane.  Complexity: <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))">  ; </li><li>  Recursive Voronoi diagram building algorithm.  Complexity: <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))">  . </li></ol><br>  After describing some algorithms, its implementation in C ++ will be given.  For the implementation we used the SplashGeom ¬© library written by us - a <a href="https://github.com/izaharkin/SplashGeom">link to github</a> , which has everything necessary for implementing many algorithms of computational geometry on a plane and some in space.  Please do not judge strictly this library, it is still under active development and improvement, but all comments will be heard. <br><br>  If you are interested in other implementations, here are some more: <br><br><ul><li>  <a href="http://www.boost.org/doc/libs/1_52_0/libs/polygon/doc/voronoi_main.htm">boost.polygon</a> </li><li>  <a href="http://ect.bell-labs.com/who/sjf/">Steve Forchun website</a> </li><li>  <a href="https://github.com/aewallin/openvoronoi">aewllin / openvoronoi</a> </li><li>  <a href="http://obi2ru.blogspot.ru/2012/12/spatial-voronoi-diagram-by-java.html">Java implementation</a> </li><li>  <a href="http://www.raymondhill.net/voronoi/rhill-voronoi.html">Implementation on JavaScript (there is also a visualizer there)</a> </li></ul><br>  We now turn to the direct consideration of the algorithms: <br><br><h3>  The algorithm for constructing the Voronoi diagram "head on" for <img src="https://habrastorage.org/getpro/habr/post_images/779/d1d/ce6/779d1dce68f0e915837b5e3686dd33a1.gif" title="O (n ^ 4)"></h3><br>  Here the idea is to intersect not half-planes, namely, the mid-perpendiculars of the segments (because it is simpler, you should agree) connecting this point with all the other points.  That is, following the definition of the Voronoi cell, we will build a locus for point <b>p</b> like this: <br><br><ol><li>  We obtain the n-1 straight line (median perpendiculars), since we conducted the median perpendiculars of all segments connecting this point <b>p</b> with the rest; </li><li>  We intersect in pairs all straight lines, we get <img src="https://habrastorage.org/getpro/habr/post_images/292/1ee/1a0/2921ee1a04b859ecfbd55ae57372282f.gif" title="O (n ^ 2)">  intersection points (because each line can intersect all others, in the ‚Äúworst case‚Äù); </li><li>  We check all these <img src="https://habrastorage.org/getpro/habr/post_images/292/1ee/1a0/2921ee1a04b859ecfbd55ae57372282f.gif" title="O (n ^ 2)">  points on the membership of each of the n-1 half-planes, that is, we already get the asymptotics <img src="https://habrastorage.org/getpro/habr/post_images/6f7/213/141/6f72131413f34769d0296c07ccba44de.gif" title="O (n ^ 3)">  .  Accordingly, those points that belong to all half-planes are the vertices of the Voronoi cell of the point <b>p</b> ; </li><li>  Perform the first three steps for all n points, we get the final asymptotics <img src="https://habrastorage.org/getpro/habr/post_images/779/d1d/ce6/779d1dce68f0e915837b5e3686dd33a1.gif" title="O (n ^ 4)">  . </li></ol><br>  The algorithm can also be found on <a href="http://e-maxx.ru/algo/voronoi_diagram_2d_n4">e-maxx.ru</a> . <br><br>  If you wish, you can independently implement this algorithm using SplashGeom ¬©.  In this article, its implementation is not given, because in practice this algorithm is much inferior to at least the following ... <br><br><h3>  The algorithm for constructing a Voronoi diagram by intersecting half-planes in <img src="https://habrastorage.org/getpro/habr/post_images/06c/fca/fd3/06cfcafd30903e22872fa03ce2bd746e.gif" title="O (n ^ 2 * log (n))"></h3><br>  This algorithm can already be used in practice, since it does not have such a large computational complexity.  For it we will need: to be able to intersect segments and straight lines, to be able to intersect convex polygons, to be able to intersect half-planes, to be able to combine the obtained loci into a diagram. <br><br><h4>  Algorithm </h4><br><ol><li>  We obtain the n-1 line for the current site (as in the previous algorithm, the perpendicular bisectors).  These will be "forming" half-planes; </li><li>  Now we have the n-1 half-plane.  Each of these half-planes is defined by a straight line from the pre.  point and orientation, that is, from which side of the line it is located.  The orientation can be determined by the current site for which we are building a locus - it lies in the desired half-plane, and therefore its locus must lie in it; </li><li>  We intersect all half-planes - we can do it for <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))">  - we get the locus for the current site; </li><li>  Perform the first three steps for all n points, we get the final asymptotics <img src="http://habrastorage.org/getpro/habr/post_images/c7f/092/d48/c7f092d481acb49c8a0f96178ceb3119.gif" title="n">  * <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))">  = <img src="https://habrastorage.org/getpro/habr/post_images/06c/fca/fd3/06cfcafd30903e22872fa03ce2bd746e.gif" title="O (n ^ 2 * log (n))">  . </li></ol><br><h4>  Implementation </h4><br>  The main snag here, I believe, is to realize the normal intersection of convex polygons, because there are unpleasant degenerate cases (coincidence of vertices and / or sides of polygons; if the polygon intersects with itself, it is necessary to think well enough to adapt the O'Rourke algorithm to work correctly in this case). <br><br>  At once I will say that we limit the whole area of ‚Äã‚Äãaction <i><b>to the bounding rectangle</b></i> - the half-planes will cut off the parts from it, which we intersect with each other.  This solves the problem of infinite cells in a diagram. <br><br><h5>  The intersection of lines and segments </h5><br>  And we need exactly the point of intersection, and not just the definition of its presence.  In SplashGeom ¬© this is - for example, the implementation of the intersection of lines and segments: <br><br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   // kInfPoint -  , kNegInfPoint -   Point2D Line2D::GetIntersection(const Line2D&amp; second_line) const { double cross_prod_norms = Vector2D(this-&gt;A, this-&gt;B).OrientedCCW(Vector2D(second_line.A, second_line.B)); Point2D intersect_point; if (fabs(cross_prod_norms) &lt;= EPS) /* A1 / A2 == B1 / B2 */ { if (fabs(this-&gt;B * second_line.C - second_line.B * this-&gt;C) &lt;= EPS) /* .. == C1 / C2 */ { intersect_point = kNegInfPoint2D; } else { intersect_point = kInfPoint2D; } } else { double res_x = (second_line.C * this-&gt;B - this-&gt;C * second_line.B) / cross_prod_norms; double res_y = (second_line.A * this-&gt;C - this-&gt;A * second_line.C) / cross_prod_norms; intersect_point = Point2D(res_x, res_y); } return intersect_point; } //   Point2D Segment2D::GetIntersection(const Segment2D&amp; second_seg) const { Line2D first_line(*this); Line2D second_line(second_seg); Point2D intersect_point = first_line.GetIntersection(second_line); if (intersect_point == kNegInfPoint2D) { if (this-&gt;Contains(second_seg.b)) { intersect_point = second_seg.b; } else if (this-&gt;Contains(second_seg.a)) { intersect_point = second_seg.a; } else if (second_seg.Contains(this-&gt;b)) { intersect_point = this-&gt;b; } else if (second_seg.Contains(this-&gt;a)) { intersect_point = this-&gt;a; } else { intersect_point = kInfPoint2D; } } else if (!(this-&gt;Contains(intersect_point) &amp;&amp; second_seg.Contains(intersect_point))) { intersect_point = kInfPoint2D; } return intersect_point; }</span></span></code> </pre> <br></div></div><br><h5>  Intersection of convex polygons </h5><br>  Now we realize the intersection of polygons.  You can certainly do it for <img src="https://habrastorage.org/getpro/habr/post_images/a8b/d9e/055/a8bd9e0555fc46227a11ecc868c4deea.gif" title="O (nm)">  where n and m are the number of vertices of the first and second polygons, respectively ‚Äî intersect each side of the first polygon with each side of the second, recording intersection points, and also check the points for belonging to another polygon, but we will cross the algorithm to achieve the best speed O`Rourke (original description of the algorithm - <a href="https://habr.com/ru/post/309252/">[3]</a> ). <br><br>  Also with one of the options for its description can be found on <a href="http://algolist.manual.ru/maths/geom/intersect/convex_intersect.php">algolist.ru</a> .  Our implementation is based on the description of the algorithm in the book <a href="https://habr.com/ru/post/309252/">[1]</a> (p. 334), with some complementary ideas.  Immediately, I note that this implementation <b>does not take into account cases</b> where polygons <b>have common sides</b> (as noted in the book <a href="https://habr.com/ru/post/309252/">[1]</a> , this case requires separate consideration), however, cases with common vertices work correctly. <br><br>  Under the spoiler below you can see a general description of the algorithm. <br><br><div class="spoiler">  <b class="spoiler_title">I want to know the algorithm O`Rourke!</b> <div class="spoiler_text">  Algorithm (for additional explanations, refer to the above sources): <br><ol><li>  Until the maximum number of iterations passes (it is proved that it is not more than 2 * (n + m)), we execute the following instructions: <br>  but).  Take the current edges of the first and second polygons; <br>  b).  If they intersect, then we consider a point from the intersection: it may be that we just added it to the intersection polygon, then just ignore the addition, otherwise, if it is not the initial intersection point (that is, we have already made a circle), then we add intersection, otherwise we finish the algorithm - we met the intersection point that was at the beginning; <br>  at).  Next (regardless of whether the current edges intersect or not) call the <b>Motion</b> function, which is responsible for moving the window of the first (or second) polygon one edge forward, as well as for possible adding a vertex to the intersection polygon.  The main actions take place in the <b>Movement</b> . </li><li>  If there were no intersection points, determine whether one polygon lies inside the other (checking that a point is a convex polygon by O (log (the number of vertices of the polygon)) <a href="https://habr.com/ru/post/309252/">[1]</a> , pp. 59-60).  If it is, then return it, otherwise return an empty intersection. </li></ol><br>  The function of the <b>Motion</b> can be implemented in different ways, with us it returns the number (label) of the polygon whose edge we are moving.  Conceptually, she does three things inside herself: <br>  - determines <b>the case number</b> - the current relative position of the edge of the first polygon and the edge of the second polygon.  This is the <b>main idea of ‚Äã‚Äãthe algorithm</b> - viewing the cases of the position of the ribs relative to each other.  All these four positions are well described in <a href="https://habr.com/ru/post/309252/">[1]</a> , in our implementation the position is determined using the skew product of vectors on the plane; <br>  - determines which edge of a polygon is now ‚Äúinside‚Äù, that is, it lies ‚Äúto the left‚Äù of another edge, in our case this is also verified by skew product (lies ‚Äúto the left‚Äù if the end point lies to the ‚Äúleft‚Äù); <br>  - decides whether the current end of one of the edges is written to the intersection polygon.  If it fits the right case and the edge is inside, then you need to add, otherwise not. <br></div></div><br>  Well, in SplashGeom ¬© it looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Polygon intersection code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,       Convex2D Rectangle::GetIntersectionalConvex2D(const Point2D&amp; cur_point, const Line2D&amp; halfplane) const { vector&lt;Point2D&gt; convex_points; Segment2D cur_side; Point2D intersection_point; for (int i = 0, sz = vertices_.size(); i &lt; sz; ++i) { int j = (i + 1) % sz; cur_side = Segment2D(vertices_[i], vertices_[j]); intersection_point = halfplane.GetIntersection(cur_side); if (intersection_point != kInfPoint2D) convex_points.push_back(intersection_point); if (halfplane.Sign(cur_point) == halfplane.Sign(vertices_[i])) convex_points.push_back(vertices_[i]); } Convex2D result_polygon(MakeConvexHullJarvis(convex_points)); return result_polygon; } //       NumOfCase EdgesCaseNum(const Segment2D&amp; first_edge, const Segment2D&amp; second_edge) { bool first_looks_at_second = first_edge.LooksAt(second_edge); bool second_looks_at_first = second_edge.LooksAt(first_edge); if (first_looks_at_second &amp;&amp; second_looks_at_first) { return NumOfCase::kBothLooks; } else if (first_looks_at_second) { return NumOfCase::kFirstLooksAtSecond; } else if (second_looks_at_first) { return NumOfCase::kSecondLooksAtFirst; } else { return NumOfCase::kBothNotLooks; } } // ,    "" WhichEdge WhichEdgeIsInside(const Segment2D&amp; first_edge, const Segment2D&amp; second_edge) { double first_second_side = Vector2D(second_edge).OrientedCCW(Vector2D(second_edge.a, first_edge.b)); double second_first_side = Vector2D(first_edge).OrientedCCW(Vector2D(first_edge.a, second_edge.b)); if (first_second_side &lt; 0) { return WhichEdge::kSecondEdge; } else if (second_first_side &lt; 0) { return WhichEdge::kFirstEdge; } else { return WhichEdge::Unknown; } } //   WhichEdge MoveOneOfEdges(const Segment2D&amp; first_edge, const Segment2D&amp; second_edge, Convex2D&amp; result_polygon) { WhichEdge now_inside = WhichEdgeIsInside(first_edge, second_edge); NumOfCase case_num = EdgesCaseNum(first_edge, second_edge); WhichEdge which_edge_is_moving; switch (case_num) { case NumOfCase::kBothLooks: { if (now_inside == WhichEdge::kFirstEdge) { which_edge_is_moving = WhichEdge::kSecondEdge; } else { which_edge_is_moving = WhichEdge::kFirstEdge; } break; } case NumOfCase::kFirstLooksAtSecond: { which_edge_is_moving = WhichEdge::kFirstEdge; break; } case NumOfCase::kSecondLooksAtFirst: { which_edge_is_moving = WhichEdge::kSecondEdge; break; } case NumOfCase::kBothNotLooks: { if (now_inside == WhichEdge::kFirstEdge) { which_edge_is_moving = WhichEdge::kSecondEdge; } else { which_edge_is_moving = WhichEdge::kFirstEdge; } break; } } if (result_polygon.Size() != 0 &amp;&amp; (case_num == NumOfCase::kFirstLooksAtSecond || case_num == NumOfCase::kSecondLooksAtFirst)) { Point2D vertex_to_add; if (now_inside == WhichEdge::kFirstEdge) { vertex_to_add = first_edge.b; } else if (now_inside == WhichEdge::kSecondEdge) { vertex_to_add = second_edge.b; } else { if (case_num == NumOfCase::kFirstLooksAtSecond) vertex_to_add = first_edge.b; // ?! else vertex_to_add = second_edge.b; } if (vertex_to_add != result_polygon.GetCurVertex()) result_polygon.AddVertex(vertex_to_add); } return which_edge_is_moving; } //    (    ,      ) Convex2D Convex2D::GetIntersectionalConvex(Convex2D&amp; second_polygon) { Convex2D result_polygon; size_t max_iter = 2 * (this-&gt;Size() + second_polygon.Size()); Segment2D cur_fp_edge; // current first polygon edge Segment2D cur_sp_edge; // current second polygon edge Point2D intersection_point; bool no_intersection = true; WhichEdge moving_edge = WhichEdge::Unknown; for (size_t i = 0; i &lt; max_iter; ++i) { cur_fp_edge = this-&gt;GetCurEdge(); cur_sp_edge = second_polygon.GetCurEdge(); intersection_point = cur_fp_edge.GetIntersection(cur_sp_edge); if (intersection_point != kInfPoint2D) { if (result_polygon.Size() == 0) { no_intersection = false; result_polygon.AddVertex(intersection_point); } else if (intersection_point != result_polygon.GetCurVertex()) { if (intersection_point == result_polygon.vertices_[0]) { break; // we already found the intersection polygon } else { result_polygon.AddVertex(intersection_point); } } } moving_edge = MoveOneOfEdges(cur_fp_edge, cur_sp_edge, result_polygon); if (moving_edge == WhichEdge::kFirstEdge) { this-&gt;MoveCurVertex(); } else { second_polygon.MoveCurVertex(); } } if (no_intersection == true) { if (second_polygon.Contains(this-&gt;GetCurVertex())) { result_polygon = *this; } else if (this-&gt;Contains(second_polygon.GetCurVertex())) { result_polygon = second_polygon; } } return result_polygon; }</span></span></code> </pre><br></div></div><br>  I hope this description and code will be useful to you. <br><br><h5>  Intersection of half-planes </h5><br>  So, we have everything necessary for constructing the intersection of half-planes.  Well, let's do it, but let's do it not just, but rationally - due to the associativity of the intersection operation of the half-planes, we can intersect them in any order, which means we intersect two planes, then intersect two more, and then intersect their intersections, because already faster than crossing all separately. <br><br>  So here it is advisable to use <i>recursion</i> <s>(the mood has immediately spoiled)</s> - her work here is quite understandable, see for yourself: <br><br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Convex2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHalfPlanesIntersection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Point2D&amp; cur_point, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;Line2D&gt;&amp; halfplanes, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Rectangle&amp; border_box)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (halfplanes.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-function"><span class="hljs-function">Convex2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cur_convex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(border_box.GetIntersectionalConvex2D(cur_point, halfplanes[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">]))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cur_convex; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> middle = halfplanes.size() &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Line2D&gt; first_half(halfplanes.begin(), halfplanes.begin() + middle); <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Line2D&gt; second_half(halfplanes.begin() + middle, halfplanes.end()); <span class="hljs-function"><span class="hljs-function">Convex2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first_convex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GetHalfPlanesIntersection(cur_point, first_half, border_box))</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Convex2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second_convex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GetHalfPlanesIntersection(cur_point, second_half, border_box))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> first_convex.GetIntersectionalConvex(second_convex); } }</code> </pre><br></div></div><br><h5>  Adding a locus to a chart </h5><br>  Now we have the Voronoi polygon of this point, it's time to add it to the chart.  There are no problems with this here, because we get the regions in an arbitrary order, and they are not connected to each other (unlike the implementation in the Forchun algorithm, where you can go to the next locus by pointing to an edge): <br><br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      Voronoi2DLocus VoronoiDiagram2D::MakeVoronoi2DLocus(const Point2D&amp; site, const vector&lt;Point2D&gt;&amp; points, const Rectangle&amp; border_box) { Voronoi2DLocus cur_locus; vector&lt;Line2D&gt; halfplanes; for (auto cur_point : points) { if (cur_point != site) { Segment2D cur_seg(site, cur_point); Line2D cur_halfplane(cur_seg.GetCenter(), cur_seg.NormalVec()); halfplanes.push_back(cur_halfplane); } } *cur_locus.region_ = GetHalfPlanesIntersection(site, halfplanes, border_box); cur_locus.site_ = site; return cur_locus; } //    VoronoiDiagram2D VoronoiDiagram2D::MakeVoronoiDiagram2DHalfPlanes(const vector&lt;Point2D&gt;&amp; points, const Rectangle&amp; border_box) { Voronoi2DLocus cur_locus; for (auto cur_point : points) { cur_locus = MakeVoronoi2DLocus(cur_point, points, border_box); this-&gt;diagram_.push_back(cur_locus); } return *this; }</span></span></code> </pre><br></div></div><br>  So, we learned how to build a Voronoi diagram for <img src="https://habrastorage.org/getpro/habr/post_images/06c/fca/fd3/06cfcafd30903e22872fa03ce2bd746e.gif" title="O (n ^ 2 * log (n))">  , it has the form of a vector (list) of loci.  The disadvantage of this solution is that no information about the neighbors can be obtained (it is possible that this deficiency can be eliminated with an improved implementation). <br><br>  Much more information can be obtained from the <abbr title="double connected edge list">RSDS</abbr> ( <abbr title="double-connected (linked) edge list">DCEL</abbr> ).  This structure will be used in the Forchun algorithm. <br><br>  Next, the Forchun algorithm will be described using a sweeping straight line and a ‚Äúshoreline‚Äù <s>(prepare swimsuits and swimming trunks ‚Äî go to the beach)</s>  In my opinion, this is the most acceptable option if you want to implement the construction of the Voronoi diagram and build it with the "speed" of <s>light.</s> <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))">  . <br><br><h3>  Forchun's algorithm for constructing the Voronoi diagram <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))"></h3><br>  In 1987, Steve Fortune (Steve Fortune) proposed an algorithm for constructing diagrams for <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))">  .  Of course, it is not the only construction algorithm with such asymptotics, but it is quite understandable and not very difficult to implement (and, moreover, very beautiful <s>and mathematical!</s> ), So I chose it. <br><br>  Forchun's materials can be found <a href="https://en.wikipedia.org/wiki/Fortune%2527s_algorithm">here</a> , <a href="http://www.ams.org/samplings/feature-column/fcarc-voronoi">here</a> , <a href="http://blog.ivank.net/fortunes-algorithm-and-implementation.html">here</a> and <a href="http://home.rmrf.org/h/haha/course_3.2/CMVVR/qa/karabtcev_diss.pdf">here again</a> . <br><br>  By the way, the <a href="https://habrahabr.ru/post/110790/">article on Habrahabr</a> was already devoted to the consideration of this algorithm. <br><br>  So, the basic idea of ‚Äã‚Äãthe algorithm is the so-called <b>sweep line</b> .  It is used in many algorithms of computational geometry, because it allows you to conveniently simulate the movement of a straight line over a certain set of objects (for example, the sweep line is also used in the intersection algorithm of n segments). <br><br>  Before we start talking about how and what we are going to do, let's see how the sweep line moves (taken <a href="http://blog.ivank.net/fortunes-algorithm-and-implementation.html">from here</a> ): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c3/80f/dbb/7c380fdbb5463b8cd9a1669beef2d518.gif"></div><br>  Beautiful, isn't it?  In the implementation, everything is approximately the same, only the RFP usually moves from top to bottom, not from left to right, and in fact everything is not so smooth, but it comes from an event to an event (see below), that is, it is <i>discrete</i> . <br><br><h4>  The essence of the algorithm </h4><br>  There are n sites (points on the plane).  There is a sweeping line that moves (for example) ‚Äúfrom top to bottom,‚Äù that is, from the site with the greatest ordinate to the site with the smallest (from event to event, to be exact).  Immediately it should be noted that <i>only</i> those sites that are <i>above or on the</i> sweeping line have an impact on the construction of the diagram. <br><br>  When the RFP reaches the next site (a <b>point event</b> occurs), a new parabola (arch) is created, the <b>focus of</b> which is the site, and the <b>directrix</b> is a sweeping line ( <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B0%25D1%2580%25D0%25B0%25D0%25B1%25D0%25BE%25D0%25BB%25D0%25B0">about a parabola on Wikipedia</a> ).  This parabola divides the plane into two parts - the ‚Äúinner‚Äù area of ‚Äã‚Äãthe parabola corresponds to points that are now closer to the site, and the ‚Äúouter‚Äù area - to points that are closer to the sweep line, and the points lying on the parabola are equidistant from the site and the RFP.  Parabola will vary depending on the position of the RFP to the site - the further the RFP goes down from the site, the more the parabola expands, but at the very beginning it is generally a segment ("directed" up). <br><br>  Then the parabola expands, it has two <b>control points (break points)</b> - the points of its intersection with the other parabolas ("coastline").  In the ‚Äúcoastline‚Äù we store parabolic arcs from one point of intersection with each other to another, and the beach line is obtained.  In fact, in this algorithm we model the movement of this ‚Äúcoastline‚Äù.  because these same break points` move exactly along the edges of the Voronoi cells (after all, it turns out that the control points are equidistant from both sites to which these parabolas correspond, and also from the ZP). <br><br>  And just at the moment when two control points ‚Äî one of the different parabolas ‚Äî ‚Äúmeet‚Äù, that is, turn into one, as it were, this point becomes the top of the Voronoi cell <b>(a circle event</b> occurs). at this time, the arc that was between these two points - ‚Äúcollapses‚Äù and is removed from the ‚Äúcoastline‚Äù.  Then we simply connect this point with the previous corresponding one and get the edge of the Voronoi cell. <br><br><h4>  Algorithm </h4><br>  So, while moving the sweep line down, we meet with two <i>types of events</i> : <br><br><h5>  Point event </h5><br>  The event point is the hit of the RFP on one of the sites, so we create a new parabola corresponding to this site, and two <b>break points</b> are added (in fact, first one, and when the arch extends already two) ‚Äîthe intersection points of this parabolas with a coastline (that is, with the front of existing parabolas).  It should be noted that in this algorithm the parabola (or rather its part belonging to the ‚Äúcoastline‚Äù - <b>arch</b> ) ‚Äúis inserted into the coastline‚Äù <b>only</b> in case of a point event, that is, a new arch can appear only when processing a <b>point event</b> . <br><br>  By the way, the following pictures show why the unions of such ‚Äúparabolic pieces‚Äù are called the ‚Äúcoastline‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/951/f0e/3ef/951f0e3ef0eeb5a866598c830554bef4.png"><img src="https://habrastorage.org/getpro/habr/post_images/abe/531/784/abe53178466269225466414ad9854c8b.jpg" height="30%" width="30%"><br><br><h5>  Circle event </h5><br>  The circle event is the occurrence of a new vertex of the Voronoi cell together with the removal of one arch, because the appearance of a new vertex of the diagram means that there were three arches, left, middle and right, the middle ‚Äúcollapses‚Äù due to the convergence of the left and right points of the arches and we get Voronoi diagrams.  It is worth noting that in this algorithm the parabola (arch) is removed from the ‚Äúcoastline‚Äù <b>only</b> in the event of a circle event, that is, the arch can be removed only when processing a <b>circle event</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/442/63b/6ce/44263b6ceb1269d2f8b3ee8e47c049a5.png"></div><br>  There is a theorem that says that the top of the Voronoi diagram always lies at the intersection of exactly three edges of the diagram, and there is a consequence of this theorem, which says that the top of the diagram is the center of a circle passing through three sites and the distance from this point to the sweeping line equal to the radius of this circle (this is a property of points lying on the "coastline").  This is a <b>key moment</b> , because when <b>the lowest point of the circle</b> passing through the three sites lies <b>below or on the</b> sweeping line, we push the event of a circle with this lowest point to the event queue, because when the line hits it, we will get the top Voronoi diagrams. <br><br>  <b>It is important</b> that one specific arch is connected with any event (point or circle), and vice versa.  This is useful when handling events.  You should also not forget that you need to add edges to the <abbr title="double connected edge list">RSDS</abbr> ( <abbr title="double-connected (linked) edge list">DCEL</abbr> ) in time (point 1 in the structures, see below), so you need to understand the connection between the arches and the edges. <br><br>  Thus, the motion of a straight line is discrete ‚Äî a straight line at any moment in time <b>either at the site</b> <b>or at the lowest point of the circle</b> passing through three sites, the center of which is the new vertex of the Voronoi diagram.  Perfectly. <br><br>  <b>General algorithm</b> : <br><br><ol><li>  We create a queue (with priority) of events, initially initiating events at a point ‚Äî a given set of sites (for each site corresponds to a point event); <br><br></li><li>  While the queue is not empty: <br><br>  but).  We take from it an event; <br>  b).  If this is <i>a point event</i> , then we <i>process the point event;</i> <br>  at).  If this is <i>a circle event</i> , then we <i>process the circle event;</i> <br><br></li><li>  Finish all remaining edges (work with border_box). </li></ol><br><h4>  Implementation </h4><br>  The implementation of the Forchun algorithm <i>will be discussed in detail in a separate article</i> , but here are some developments that may help in its understanding. <br><br><h5>  Required structures </h5><br>  To implement this algorithm, we need several structures (classes), namely: <br><br><ul><li>  <abbr title="double connected edge list">RSDS</abbr> ( <abbr title="double-connected (linked) edge list">DCEL</abbr> ) - a list for storing the already found edges of the Voronoi diagram; </li><li>  Priority queue with events; </li><li>  Binary tree (we have this BeachSearchTree) - to store the "coastline" - the current position of parabolas and points.  It should be noted that this tree is balanced - the node has either exactly two sons or zero (is a leaf).  More information about this structure can be found, for example, in <a href="https://habrahabr.ru/post/112581/">this article on Habr√©</a> (here it is presented a little differently). </li></ul><br>  Having such data structures, we can write an implementation of a general algorithm: <br><br><div class="spoiler">  <b class="spoiler_title">View code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">VoronoiDiagram2D VoronoiDiagram2D::MakeVoronoiDiagram2DFortune(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Point2D&gt;&amp; points, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Rectangle&amp; border_box) { priority_queue&lt;Event&gt; events_queue(points.begin(), points.end()); <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;Event&gt; cur_event; BeachSearchTree beach_line; DCEL edges; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!events_queue.empty()) { cur_event = make_shared&lt;Event&gt;(events_queue.top()); <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PointEvent&gt; is_point_event(<span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> PointEvent *&gt;(cur_event.get())); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (is_point_event) { events_queue.pop(); beach_line.HandlePointEvent(*is_point_event, border_box, events_queue, edges); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CircleEvent&gt; is_circle_event(<span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CircleEvent *&gt;(cur_event.get())); events_queue.pop(); beach_line.HandleCircleEvent(*is_circle_event, border_box, events_queue, edges); } } edges.Finish(border_box); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;dcel_ = edges; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br></div></div><br>  All the logic and complexity in HandlePointEvent () and HandleCircleEvent (), and a separate article will be devoted to them, further I will provide some auxiliary functions that will later help in implementation. <br><br><h5>  Secondary functions </h5><br><h6>  Crossing Parabolas (arches) </h6><br>  We need to be able to get the intersection of two parabolas (arches), depending on the position of the RFP.  The equation of a parabola with a focus at the point x 'and y' and a directrix, whose position along the y axis is equal to l, is given by the following equation (it can be derived): <br><br> <a href="http://www.codecogs.com/eqnedit.php%3Flatex%3Dy%26space%3B%3D%26space%3B%5Cfrac%7B1%7D%7B2(%7By%7D%27%26space%3B-%26space%3Bl)%7D((x%26space%3B-%26space%3B%7Bx%7D%27)%5E2%26space%3B%26plus%3B%26space%3B%7By%7D%27%5E2%26space%3B-%26space%3Bl%5E2)"><img src="https://habrastorage.org/getpro/habr/post_images/650/7d9/d26/6507d9d2607a5dc9bf85f51852633e02.gif" title="y = \ frac {1} {2 ({y} '- l)} ((x - {x}') ^ 2 + {y} '^ 2 - l ^ 2)"></a> <br><br>  By the way, the fraction in front of the bracket is the <i>focal parameter of</i> this parabola.  From here we can ‚Äúpull out‚Äù the corresponding coefficients of the parabola equation and solve a system of two non-linear equations in a simple way - subtract one from the other, and then we substitute the found roots into the first, we get two points.  We are interested in the point that is lower (that is, with a smaller ordinate), because the highest point lies beyond the "coastline".  The described actions are reflected in the following code: <br><br><div class="spoiler">  <b class="spoiler_title">Parabolic intersection code</b> <div class="spoiler_text"><pre> <code class="cpp hljs">pair&lt;Point2D, Point2D&gt; Arch::GetIntersection(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Arch&amp; second_arch, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> line_pos) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { pair&lt;Point2D, Point2D&gt; intersect_points; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> p1 = <span class="hljs-number"><span class="hljs-number">2</span></span> * (line_pos - <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;focus_-&gt;y); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> p2 = <span class="hljs-number"><span class="hljs-number">2</span></span> * (line_pos - second_arch.focus_-&gt;y); <span class="hljs-comment"><span class="hljs-comment">// is not 0.0, because line moved down if (fabs(p1) &lt;= EPS) { intersect_points.first = this-&gt;GetIntersection(Ray2D(*this-&gt;focus_, Point2D(this-&gt;focus_-&gt;x, this-&gt;focus_-&gt;y + 1))); intersect_points.second = intersect_points.first; } else { // solving the equation double a1 = 1 / p1; double a2 = 1 / p2; double a = a2 - a1; double b1 = -this-&gt;focus_-&gt;x / p1; double b2 = -second_arch.focus_-&gt;x / p2; double b = b2 - b1; double c1 = pow(this-&gt;focus_-&gt;x, 2) + pow(this-&gt;focus_-&gt;y, 2) - pow(line_pos, 2) / p1; double c2 = pow(second_arch.focus_-&gt;x, 2) + pow(second_arch.focus_-&gt;y, 2) - pow(line_pos, 2) / p1; double c = c2 - c1; double D = pow(b, 2) - 4 * a * c; if (D &lt; 0) { intersect_points = make_pair(kInfPoint2D, kInfPoint2D); } else if (fabs(D) &lt;= EPS) { double x = -b / (2 * a); double y = a1 * pow(x, 2) + b1 * x + c1; intersect_points = make_pair(Point2D(x, y), Point2D(x, y)); } else { double x1 = (-b - sqrt(D)) / (2 * a); double x2 = (-b + sqrt(D)) / (2 * a); double y1 = a1 * pow(x1, 2) + b1 * x1 + c1; double y2 = a1 * pow(x2, 2) + b1 * x2 + c1; intersect_points = make_pair(Point2D(x1, y1), Point2D(x2, y2)); } } return intersect_points; }</span></span></code> </pre><br></div></div><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Construction of a circle on three points </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When processing a circle event, we will need to determine the center and the lowest point of the circle constructed from the foci of the three arches (sites). </font><font style="vertical-align: inherit;">There are some analytical algorithms for constructing a circle on three points (by construction, we mean getting its center and radius), in our program this is done so ( </font></font><a href="http://algolist.manual.ru/maths/geom/equation/circle.php"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thanks to the alguolist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - we connect the first two points and the second two points with segments. </font><font style="vertical-align: inherit;">The center lies at the intersection of the middle perpendiculars, the radius is the distance from the center to any of the three points. </font><font style="vertical-align: inherit;">Quick and beautiful:</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View the code for constructing a circle on three points.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">Circle::Circle(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point2D&amp; p1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point2D&amp; p2, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Point2D&amp; p3) { <span class="hljs-function"><span class="hljs-function">Segment2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first_segment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1, p2)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Segment2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second_segment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p2, p3)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Line2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first_perpendicular</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(first_segment.GetCenter(), first_segment.NormalVec())</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Line2D </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second_perpendicular</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(second_segment.GetCenter(), second_segment.NormalVec())</span></span></span></span>; center_ = first_perpendicular.GetIntersection(second_perpendicular); little_haxis_ = big_haxis_ = center_.l2_distance(p1); }</code> </pre><br></div></div><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Point event handling </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The event point is when we pulled PointEvent out of the queue. What is in it? In it there is only a site with which this event is associated. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What do we do when processing it? We add a new arch to the ‚Äúcoastline‚Äù, setting up all the ‚Äúas needed‚Äù links in the tree, and checking if a circle event has appeared in one of three possible cases - we need to check all cases in which the new site can participate. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What do we do when adding an arch? We are looking for a place for it in our ‚Äúshoreline‚Äù binary tree (at the x coordinate), then we insert it.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f5/b83/2e5/6f5b832e5c9a77368c543e60c8138db5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What do we do when inserting? We have found a pointer to the arch, from which the new has an intersection at two points (the case where the intersection point hits exactly one of the control points is considered separately - there the intersection will be with two parabolas - left and right). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That is, we take the arch, which is ‚Äúbroken‚Äù, and instead we insert as many as 5 nodes (was 1, became 5, yes) - arch1, bp1, arch2, bp2, arch3. Arch1 is the left piece of the arch that the new intersect crosses, that is, the piece to the left of the left break point, bp1 is the left break point (the left intersection of the new arch), arch2 is the new arch in person, bp2 is the right break point (right intersection of the new arch), arch3 is the right-hand piece of the arch that the new one crosses.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that the point event gives rise to a new edge (or edges, there are cases) of the Voronoi diagram. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the possible options for adding a new arch to the ‚Äúcoastline‚Äù is presented </font></font><a href="https://habrahabr.ru/post/112581/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in this article on Habr√©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , our version is described above, and looks more like the one proposed </font></font><a href="http://blog.ivank.net/fortunes-algorithm-and-implementation.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Handling a circle event </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A circle event is when we pulled CircleEvent from the queue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is in it? There is a point in it - this is the lowest point of a certain circle, which passes through three sites, and an arch, which should be removed. There are two control points in the tree and it itself, the control points will eventually turn into one, and the arch must be carefully removed from the tree, rebuilding all the ‚Äúparent-child connections‚Äù. In fact, the processing of this event replaces three nodes in the tree with one (two break points and an arch with one break point). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that the circle event completes two edges of the Voronoi diagram, that is, when processing this event, the edges will be terminated.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I would also say that an important part of event processing is how we monitor the growth of the ribs, adding them to the list and completing the edges, that is, so that in the end they are all ‚Äúfinished‚Äù and either are finite or rest on the limiting rectangle. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Small analysis of the result </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since we will get the </font></font><abbr title="double connected edge list"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RSDS</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><abbr title="double-connected (linked) edge list"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DCEL</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">output </font><font style="vertical-align: inherit;">, we will be able to get enough information - for each edge we know the corresponding site, we can get a ‚Äútwin‚Äù of this edge, find out the site for it and voila - we recognized our neighbor (this way list, we can create lists of neighbors for all sites, and this is an achievement, since everything happened as a result of</font></font><img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n ^ 2)">  + <img src="http://habrastorage.org/getpro/habr/post_images/39a/ed9/498/39aed9498a90431e37a7b32ffe2338cd.gif" title="O (n)">  = <img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))">  ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if the edge has a ‚Äúzero‚Äù site, then we are on the ‚Äúboundary site‚Äù - a site with an ‚Äúinfinite‚Äù locus. </font><font style="vertical-align: inherit;">Hmm, but this will allow us to build a convex hull of the initial set of points for </font></font><img src="http://habrastorage.org/getpro/habr/post_images/39a/ed9/498/39aed9498a90431e37a7b32ffe2338cd.gif" title="O (n)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the end, great. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, in general, RSDS is, in fact, a graph, so you can continue to work with this list in many algorithms on graphs.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recursive Voronoi diagram generation algorithm </font></font><img src="https://habrastorage.org/getpro/habr/post_images/0ed/5cf/b0b/0ed5cfb0b42f9409c4fdcd8939d74e9b.gif" title="O (n * log (n))"></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This algorithm is given in book </font></font><a href="https://habr.com/ru/post/309252/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (p. 260), here I will give only the construction algorithm itself, since we did not implement this option, although it is a good analogy to the Forchun algorithm.</font></font><br><br><h4>  Algorithm </h4><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We divide the entire set of sites S into two approximately equal parts (there may be an odd number of points) S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursively construct Voronoi diagrams for S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and S </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combine the resulting diagrams and get a diagram for S. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The general description of the algorithm is not complicated, but the algorithm has its own subtleties, which you can find in this book. </font></font><br><br><a name="Part3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Applications </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An exhaustive list of all applications of the Voronoi diagram is </font></font><a href="http://www.voronoi.com/wiki/index.php%3Ftitle%3DVoronoi_Applications"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I will mention some of them that seemed to me the most interesting (many of the information is taken from </font></font><a href="https://habr.com/ru/post/309252/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In programming, game development and cartography </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In computational geometry, the Voronoi diagram is needed first of all to solve the problem of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proximity of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> points, or rather, a special gain is given in the solution of the problem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ALL closest neighbors </font></font></b> <s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(not those that loudly turn on music, but though)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , because the methods similar to it are not so simple ( </font></font><a href="https://habr.com/ru/post/309252/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Using the Voronoi diagram, you can construct a convex hull behind </font></font><img src="http://habrastorage.org/getpro/habr/post_images/39a/ed9/498/39aed9498a90431e37a7b32ffe2338cd.gif" title="O (n)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(look at the "ray" edges, find the sites to which they belong, and include them in the hull). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is also an important connection between the Voronoi diagram and the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delaunay triangulation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which allows one to construct one after another</font></font><img src="http://habrastorage.org/getpro/habr/post_images/39a/ed9/498/39aed9498a90431e37a7b32ffe2338cd.gif" title="O (n)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because they are dual to each other (we connect adjacent sites with edges, we end up with the Delone triangulation - </font></font><a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2594%25D0%25B8%25D0%25B0%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0_%25D0%2592%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wiki considerations</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of using the Voronoi diagram </font><font style="vertical-align: inherit;">in game </font><font style="vertical-align: inherit;">development can be found, for example, </font></font><a href="https://cs.hse.ru/data/2015/09/28/1074663134/Smoothing%2520paths.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - here the navigation system in the game engine is based on a diagram. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is possible, and even likely, that different geolocation software uses Voronoi diagrams. Geolocation recommender systems can use the Voronoi diagram to determine, for example, the nearest grocery store, for various searches and location analyzes.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/217/78a/9b8/21778a9b8c8a23f53c18b16861706e19.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can also mention the use of charts in cartography - for delineating the boundaries of regions and further analysis based on them. </font><font style="vertical-align: inherit;">Anyway, any geographic diagrams showing the distribution of something can be clearly illustrated using colored Voronoi diagrams, and there we will see a transition of the indicator we need (for example, temperature):</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8af/96b/b54/8af96bb54e7f62ea4131cb6e6e35f645.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And, of course, you can make various filter photo handlers using the Voronoi diagram, getting a certain ‚Äúmosaic‚Äù. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/8fb/640/3cd8fb640020f9d7f2d289080d16c6c4.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But this is only the beginning of its application. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In architecture and design </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is quite logical that people came up with the idea of ‚Äã‚Äãusing the Voronoi diagram in architecture and design, since it is in itself a beautiful pattern, a kind of ‚Äúgeometric web‚Äù, so there are many cases of using it as one of the main elements of a composition or even a frame of all creation. </font></font> Examples: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e06/ac1/45d/e06ac145d474225e9843bfea15fa9507.jpg" height="50%" width="50%"><img src="https://habrastorage.org/getpro/habr/post_images/bed/c7a/186/bedc7a1867bbac418a34c4aac9882a7d.jpg" height="25%" width="25%"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e0/aa9/454/8e0aa94541f50f9a467b79c4e6c26c67.jpg" height="33%" width="33%"><img src="https://habrastorage.org/getpro/habr/post_images/dd9/34e/1e3/dd934e1e320b305aa716558d6858bb02.jpg" height="58%" width="58%"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In archeology </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From </font></font><a href="https://habr.com/ru/post/309252/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In archeology, Voronoi polygons are used to map the range of use of tools in ancient cultures and to study the influence of rival trading centers. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In ecology, the body‚Äôs ability to survive depends on the number of neighbors with whom it must fight for food and light.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - which is quite logical, because usually it is the neighboring regions that fight for any ‚Äúsurvival‚Äù. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In modeling and recognition </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, the 3D Voronoi diagram is not considered, but it has many applications in physics and 3D modeling of objects. </font><font style="vertical-align: inherit;">Various types of grids (and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">skeletons</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) of objects in space can be constructed using the Voronoi diagram (but more often using the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delaunay triangulation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b0f/d7f/728/b0fd7f728b2c2e92e32f712c44008121.jpg" height="30%" width="30%"><img src="https://habrastorage.org/getpro/habr/post_images/f81/bf1/978/f81bf19781af0c6712d6db82a85dd0c7.png" height="50%" width="50%"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3D scanning (and </font></font><a href="https://habrahabr.ru/company/yandex/blog/203136/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">computer vision (computer vision)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) of various objects can also use the Voronoi diagram and Delaunay triangulation, it is also closely related to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">robotics</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - the movement of the robot, taking into account the obstacles in the way.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/869/e3e/d55/869e3ed5518b49e22782dac5857a6c0f.jpg"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In biology and chemistry </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From </font></font><a href="https://habr.com/ru/post/309252/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The combined effect of electrical and short-range forces, for the study of which complex Voronoi diagrams are constructed, helps determine the structure of molecules. </font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is another </font></font><a href="http://hijos.ru/2011/12/28/kazhdyj-v-svoej-oblasti-i-voronoj-dlya-vsex/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interesting article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about the use of the Voronoi diagram.</font></font><br><br><a name="Part4"></a><h2>  Interesting Facts </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nature is an amazing thing, because it turns out that the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">color of a giraffe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> actually looks like a Voronoi diagram. </font><font style="vertical-align: inherit;">This is visible to the naked eye:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d28/9e2/2e6/d289e22e656d140e6d036c22cb0bd6c9.jpg" height="50%" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Also noteworthy is the following observation, which shows that the diagram can be seen even on the leaves of trees: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/277/4c9/f55/2774c9f55be4fedf1a756af2f20ce7f7.jpg" height="50%" width="50%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> By the way, a little less than a year ago, one incident was also associated with the Voronoi diagram - here it was used in the New Moscow project logo. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e1/883/7d0/3e18837d02c4a29afe6e6ff0556bdf7e.png" height="50%" width="50%"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And - finally - a video in which you can see how the diagram appears with the growth of circles with centers in the sites: </font></font><br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/q-Ya01iGO0E%3Ffeature%3Doembed&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiHuOvIHTpIwVqWpmQOaumrWi2jOg" frameborder="0" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here you can draw an analogy with the spread of fire, which has several fires. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, that‚Äôs the end of our little journey to a world where everyone knows who is closest to them. </font><font style="vertical-align: inherit;">I hope you enjoyed this article and you really learned something new, useful and interesting.</font></font><br><br>  Thanks for attention! <br><br><a name="Part5"></a><h2>  Bibliography </h2><br><a name="Book1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1] Preparate F., Sheimos M. Computational geometry. </font><font style="vertical-align: inherit;">Introduction (1989)</font></font><br><a name="Book2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2] Alexandrov, A. D., Werner, A. L., Ryzhik, V. I. Stereometry. </font><font style="vertical-align: inherit;">Geometry in space</font></font><br><a name="Book3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] Joseph O'Rourke. </font><font style="vertical-align: inherit;">Computational Geometry in C </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ªThe article was prepared by a first-year student of the FIVT MIPT </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zakharkin Ilya</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"In writing libraries have also helped students 1st course FIVT MIPT </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kirilenko Elena</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kasimov Hope</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yaroslav Spirin</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> helped to test the library </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Special</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> thanks to the mentors </font><b><font style="vertical-align: inherit;">Gadelshin Ilnur</font></b><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gafarov Rustam</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i> </div><p>Source: <a href="https://habr.com/ru/post/309252/">https://habr.com/ru/post/309252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309240/index.html">We test Web UI on F # and canopy</a></li>
<li><a href="../309242/index.html">We write an elegant parser on Python</a></li>
<li><a href="../309244/index.html">Data Science Week 2016</a></li>
<li><a href="../309246/index.html">Data Science Tools as an Alternative to Classic IT Systems Integration</a></li>
<li><a href="../309248/index.html">ACIT will assume the role of an ‚Äúarbitrator‚Äù in conflicts between online sellers and consumers</a></li>
<li><a href="../309254/index.html">Apple vs cryptocurrency Dash: privacy is at stake</a></li>
<li><a href="../309256/index.html">Writing our first Brackets plugin</a></li>
<li><a href="../309258/index.html">Online data analysis software on Stepik.org</a></li>
<li><a href="../309260/index.html">The hunt for Lurk: from the study of malicious code to a criminal case</a></li>
<li><a href="../309262/index.html">4 thieves of productivity</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>