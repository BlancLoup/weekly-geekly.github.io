<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the Haar cascade to compare images</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The signs of Haar, about which I will tell, are known to most people who are somehow connected with the recognition and machine learning systems, but,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the Haar cascade to compare images</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/cd5/8fe/a31cd58fe11546926966f3e49e584de3.jpg" alt="image"></div><br>  The signs of Haar, about which I will tell, are known to most people who are somehow connected with the recognition and machine learning systems, but, apparently, few people use them to solve problems outside the standard field of application.  The article is devoted to the use of the Haar cascades for comparing close images, in object tracking tasks between adjacent video frames, matching search on several photos, image search on the image and other similar tasks. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2f/cac/785/d2fcac785e6b4c08b669643fd1f692a6.jpg" alt="image"></div><br>  In most cases, when a simple comparison of two rather similar fragments of an image is needed, it is realized through their <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B2%25D0%25B0%25D1%2580%25D0%25B8%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">covariance</a> (or something similar).  A sample is taken (in the photo is a flower) and moves along the image along X and Y in search of a point where the difference between the sample ( <b>J</b> ) and the image ( <b>I</b> ): <br><img src="https://habrastorage.org/getpro/habr/post_images/51c/b7c/cc7/51cb7ccc77f907abcbaa5bdf06b86477.png" alt="image"><br>  reaches its minimum. <br><br>  This method is very fast to implement, intuitive and well known.  Perhaps I have not met a single group of developers, wherever it was used.  Of course, everyone perfectly knows his flaws: <br><ul><li>  Instability when changing lighting </li><li>  Instability when zooming or rotating an image </li><li>  Instability if part of the image is a changing background </li><li>  Low speed - if you need to find the region n * n in the image m * m, then the number of operations will be proportional to n2 (mn) 2. </li></ul><br>  How to deal with these shortcomings, everyone also knows. <br><ul><li>  Illumination is neutralized by normalization or transition to <a href="http://habrahabr.ru/post/120562/">binarization of the region</a> . </li><li>  Changes in scale and small turns are neutralized by changing the resolution during correlation. </li><li>  With this approach, no one fights. </li><li>  The speed is optimized by searching with a big step or with a small resolution. </li></ul><br>  In situations where the results of the correlation are not enough - go to more complex methods, such as comparing point of <a href="http://habrahabr.ru/post/103107/">interest</a> ( <a href="http://habrahabr.ru/post/103107/">SURF</a> ) maps, boundaries, or directly selecting objects.  But these algorithms are completely different: in most cases they are quite slow, they are difficult to write from scratch (especially on some DSP processor), there are restrictions on the image structure. <br><br>  At some point, while thinking about another project, I rested on a task where it was necessary to compare several changeable areas in the image.  And I thought until I remembered the <a href="http://habrahabr.ru/post/116824/">Predator</a> algorithm once mentioned on Habr√©, where fast and stable object <a href="http://habrahabr.ru/post/116824/">tracking</a> was shown in the video.  After a little reflection, I realized that this whole approach, which allowed solving a large class of problems, passed by me. <br>  Let me remind you that such signs of Haar.  Cascades of <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25B7%25D0%25BD%25D0%25B0%25D0%25BA%25D0%25B8_%25D0%25A5%25D0%25B0%25D0%25B0%25D1%2580%25D0%25B0">features</a> are commonly referred to as a base for building systems for the extraction of complex objects, such as <a href="http://habrahabr.ru/post/133826/">faces</a> , hands, or <a href="http://habrahabr.ru/post/67937/">other objects</a> .  In most articles, this approach is inextricably linked with the <a href="http://habrahabr.ru/post/80323/">AdaBoosta</a> learning <a href="http://habrahabr.ru/post/80323/">algorithm</a> .  By itself, the Haar cascade is a set of primitives for which their convolution with an image is considered.  The simplest primitives are used, consisting of rectangles and having only two levels, +1 and -1.  In addition, each rectangle is used several times of different sizes.  Convolution here means <b>s = XY</b> , where <b>Y</b> is the sum of the image elements in the dark area, and <b>X</b> is the sum of the image elements in the light area (you can also take <b>X / Y</b> , then there will be stability when changing the scale). <br><img src="https://habrastorage.org/getpro/habr/post_images/dd0/3af/963/dd03af9639fa83ed93d60e3d92402a25.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/0c7/6fe/9e8/0c76fe9e86af750d6f9d100ed5e9d50b.jpg" alt="image"><br>  Such convolutions emphasize the structural information of an object: for example, the following convolution will always be negative for the center of a person‚Äôs face: <br><img src="https://habrastorage.org/getpro/habr/post_images/a57/d23/2d7/a57d232d7a298be86fa53d25529aad52.jpg" alt="image"><img src="https://habrastorage.org/getpro/habr/post_images/9fe/9f7/e14/9fe9f7e149241ae7ad67af861937cc2b.jpg" alt="image"><br>  The eyes will be darker than the area between them, just as the area of ‚Äã‚Äãthe mouth will be darker than the forehead.  The more various primitives are used, the more accurately the object can be classified.  Moreover, if the exact classification is not needed - you can use a smaller number of primitives. <br>  Here we can mention that in the object recognition problem, after the feature sets have been constructed from the test sample, the learning algorithms ( <a href="http://ru.wikipedia.org/wiki/AdaBoost">AdaBoost</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D0%25BE%25D0%25BF%25D0%25BE%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B2%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BE%25D1%2580%25D0%25BE%25D0%25B2">SVM</a> ) determine the sequence (cascade) of the bundles corresponding to the object.  When an object is recognized on an image, it is compared with a test image. <br>  What is the plus of Haar and why it is impossible to use such remarkable and physical curves as, for example, sinusoids and Gaussians instead of these ugly rectangles? <br>  Plus the fact that the Haar cascades are very quickly calculated through the <a href="http://habrahabr.ru/post/102919/">integral representation of the images</a> .  This is described in more detail by reference, and here I will only briefly say that the integral image is represented as: <br><img src="https://habrastorage.org/getpro/habr/post_images/ed5/da8/cec/ed5da8cecf59029c49f2e4ba15c1e507.png" alt="image"><br>  The value at point <b>X, Y of the</b> matrix ( <b>II</b> ) obtained from the original image ( <b>I</b> ) is the sum of all points in the rectangle (0.0, X, Y).  Then the integral over any rectangle (ABCD) in the image is represented as: <br>  <b>SumOfRect (ABCD) = II (A) + II (C) - II (B) - II (D)</b> <br>  This gives only 4 memory accesses and 3 mathematical operations for calculating the sum of all elements of a rectangle, regardless of its size.  When calculating other convolutions other than Haar primitive convolutions, the number of actions required is proportional to the square of the primitive size (if you do not count through the FFT, which is not possible for any patterns). <br>  Let's return to our task.  Suppose we want to find a small fragment ( <b>J</b> ) in a large image ( <b>I</b> ).  No training is required to do this.  One fragment is still impossible to produce.  The primitives of Haar will help to get an image of <b>J</b> and look for it on <b>I.</b>  It is enough to obtain convolutions of <b>J</b> with a set of Haar-signs and compare them with the set of convolutions of the same primitives calculated for <b>I</b> in windows proportional to a small fragment. <br>  Pros: <br><ul><li>  Resistance to changing lighting, even if it is a local change of lighting, resistance to noise (primitives are the simplest <a href="http://en.wikipedia.org/wiki/Band-pass_filter">band-pass filter</a> ). </li><li>  If the primitives were not very small, then the correlations are much more stable with the change of scale (the size of the primitives will not affect the accuracy if the walk is a short step). </li><li>  If the signs on a large image are calculated in advance and when you shift the search window, you take the already calculated and relevant for him - the search will be much faster than the correlation (you need to compare fewer elements). </li></ul><br>  At the same time, it can be seen that a number of fairly simple optimizations can be made that will speed up and refine this approach. <br>  If someone wanted to play, I wrote a small <a href="https://github.com/ZlodeiBaal/HaarTesting">program</a> that implements the simplest version of this algorithm.  The program maintains the selected fragment in the video stream.  <a href="http://www.emgu.com/">EmguCV</a> for <a href="http://www.emgu.com/">hooking</a> up the camera and simple image transformations (Haar is done manually). </div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/198338/">https://habr.com/ru/post/198338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198324/index.html">Nvidia announced full support for Linux on equal terms</a></li>
<li><a href="../198328/index.html">Dependency Injection in Objective-C with Magic and Blood</a></li>
<li><a href="../198330/index.html">6 tips for creating complex AJAX sites</a></li>
<li><a href="../198332/index.html">Creating extensions in PostgreSQL</a></li>
<li><a href="../198336/index.html">Apogee: Man Orchestra and Online Game Publisher 1987 (continued)</a></li>
<li><a href="../198340/index.html">Standard charge for laptops</a></li>
<li><a href="../198346/index.html">Twitter Bootstrap 3 Compilation</a></li>
<li><a href="../198350/index.html">Apple will replace 64 and 128GB SSD for MacBook Air mid 2012 for free</a></li>
<li><a href="../198354/index.html">Zabbix 2.2 riding on nginx + php-fpm and mariadb</a></li>
<li><a href="../198356/index.html">AppsMafia: Hackathon in Moscow (November 9 - 10)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>