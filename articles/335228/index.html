<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: Steps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- I haven't taken checkers for a long time! 
 - said Chichikov, moving the sword too. 
 - We know you, how you play badly! 
 - said Nozdrev, speaking ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: Steps</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <b><i>- I haven't taken checkers for a long time!</i></b> <b><i><br></i></b>  <b><i>- said Chichikov, moving the sword too.</i></b> <b><i><br></i></b>  <b><i>- We know you, how you play badly!</i></b> <b><i><br></i></b>  <b><i>- said Nozdrev, speaking with a sword.</i></b> <b><i><br><br></i></b>  <b><i>Nikolai Vasilyevich Gogol "Dead Souls"</i></b> <b><i><br></i></b> <br>  I very vaguely remember the dialectic of Hegel, which we were given at the institute.  Usually, unstoppable drowsiness defeated me at the very beginning of the lectures.  I only remember that something was said about the fact that ‚Äúthe history is developing in a spiral‚Äù.  It seems to be associated with the principle of "denial of denial."  I am not quite sure of the universality of this law, but with respect to me it is being carried out.  How many can remember, I do the same thing again and again.  This is my way to get better.  Anyway, I make checkers again.  And this is great! <br><a name="habracut"></a><br>  As I have repeatedly said, checkers are difficult!  <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B">Chess</a> games themselves are possibly and easier <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B">Chess</a> (although comparing them is not entirely correct, the games are fundamentally different), it's not about that.  Implementing drafts is much more complicated!  If Chess is ‚Äúplanted with a pig‚Äù with cascading moves ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">castling</a> ), then in the games of the drafts family there are at once two even more complex ‚Äúoptions‚Äù: <br><br><ul><li>  <b>Priorities</b> and ... </li><li>  <b>Composite moves!</b> </li></ul><br>  Priorities are what make checkers special!  In almost all checkers games (with very few exceptions), taking is mandatory, whether you like it or not.  The whole matching game is built on this.  You can "poddat" your checkers, building the opponent's figures in such a way, then to pick them up with one blow (and at the same time hold the queen).  Give less to pick more!  But this is only the tip of the iceberg! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/zMpxcNG2UDQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In this game (the position is taken from the book of Y. Barsky and B. Gerzenson ‚ÄúAdventures on the Draftsboard‚Äù), White does not just sacrifice pieces, forcing the opponent to walk in a certain way.  They use the fact that blacks are obliged to complete all captures and (at this time) freely move their pieces around the board, preparing the final trap.  With his moves, whites create "breakthroughs" and this is an excellent illustration of how beautiful positional play in drafts can be. <br><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  Taking in checkers was not always strictly obligatory.  And in Russian drafts and in English, and even in an even earlier Alquerque, there existed the ‚Äú <a href="https://habrahabr.ru/post/258437/">rule of anger</a> ‚Äù, which allowed to pick up a ‚Äúyawning‚Äù figure who had not fulfilled the capture.  Such an action was not considered a move and was called ‚Äútake for a fook‚Äù (Huffing - in ‚ÄúEnglish checkers‚Äù).  I still found this rule in early childhood, but it seems the story has already made a final verdict. <br><br>  The rule of anger puts an end to any matching game!  An experienced draftsman would prefer to lose a ‚Äúyawning‚Äù figure, instead of deliberately getting into the trap, because of which he will lose the entire game.  Currently, this rule applies only to some African game varieties, traditionally played on large boards and at high speed. <br></div></div><br>  For me, priorities are, first of all, optimization.  In fact, using Dagaz's ‚Äú <a href="https://habrahabr.ru/post/320474/">proprietary magic</a> ‚Äù, I can prohibit the execution of any previously formed moves at the post-processing stage (this is exactly what I do in <a href="">chess</a> <a href="">games</a> ).  Moreover, I can change the generated moves and even add new ones to them.  But all this is at the cost of memory and time (and when the <a href="">UCT bot</a> is taken over, both become very critical).  Productivity, in my case, is not so much interactivity, but the rationality of a computer opponent.  Working faster, the bot will have time to disassemble a greater number of positions! <br><br>  In the case of checkers, the generation of moves comes down to two possible situations.  When there are no takes, there are not so many "quiet" moves.  Everything changes when the take appears.  Since I generate all the composite moves entirely, combinatorics is involved.  For example, here in this <a href="">test</a> , a mediocre position with a woman generates 42 possible moves!  And these moves would be <b>much</b> more if, according to the rules of " <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2583%25D1%2580%25D0%25B5%25D1%2586%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">Turkish checkers</a> ", I did not <a href="">filter the</a> moves with taking the maximum number of pieces!  Adding to this list also ‚Äúquiet‚Äù moves, with their subsequent filtering in post-processing, would be a waste. <br><br><div class="spoiler">  <b class="spoiler_title">This is where I caught the first non-trivial bug</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/tid7yT7UnFc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="http://homepages.di.fc.ul.pt/~jpn/gv/gauntlet.htm">Gauntlet</a> is a very dynamic and quite interesting checker game.  Developed its Phillip L. Leduc in 1980.  The game is asymmetric.  White needs to break through (at least one piece) to the last rank.  Black - try not to allow this.  Takes are similar to checkers, but since all the pieces move only in one direction, full implementation of composite moves is not required (by the way, there is another traditional <a href="https://glukkazan.github.io/stalemate/konane.htm">Hawaiian game</a> with a similar capture mechanism).  Priorities in this game, on the contrary, are used, since taking is obligatory and this is an important component of the game. <br><br>  In certain situations, the model stopped generating moves, which caused the game to immediately stop.  It was clear that the error is related to the mechanism for processing priorities, but I did not immediately figure out what was wrong.  At first, I even transferred the logic of filtering to an extension, disabling priorities (as I said, this is just a performance issue).  When the error began to repeat in checkers, it became clear that the problem needed to be sorted out. <br><br><div class="spoiler">  <b class="spoiler_title">It's all about this code.</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> priors = []; _.chain(_.keys(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pieces)) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Dagaz.Model.sharedPieces || Dagaz.Model.isFriend(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pieces[pos], <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.player); }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pieces[pos]; _.chain(design.pieces[piece.type]) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (move.type == <span class="hljs-number"><span class="hljs-number">0</span></span>); }) .each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = Dagaz.Model.createGen(move.template, move.params, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.game.design); g.init(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, pos); addPrior(priors, move.mode, g); }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); ... for (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;= design.modes.length; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_.isUndefined(priors[i])) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (priors[i].length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = priors[i].pop(); g.generate(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (g.completed &amp;&amp; !g.move.isPass()) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cont &amp;&amp; (g.moveType == <span class="hljs-number"><span class="hljs-number">0</span></span>)) { CompleteMove(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, g); } f = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (f) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &gt;= design.modes.length) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre> </div></div><br>  All the player's pieces are moved here and generators are created for each of them, for each possible move.  The generators are decomposed into a small hash, in accordance with the priorities of the moves.  Then the hash is viewed starting from the highest priority.  If it is possible to generate at least one move, the move generators of lower priorities are not considered. <br><br>  The error was that I marked the course as generated ahead of time, at the first capture.  As a result, the generator saw a take, marked a move, and then went further and ran across a busy field, in the place where he was to place the figure.  This led to a reset of the nearly completed move, but since the move was already marked, low-priority "quiet" moves were simply discarded.  After the <a href="https://github.com/GlukKazan/Dagaz/commit/1eaaf2e94466fa9f734b682f66a902c8e6661949">correction</a> , AI Gauntlet began to play much better.  Performance is important! <br></div></div><br>  I think it's time to talk a little about checkers.  Many of us are familiar only with the <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D1%2583%25D1%2581%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">Russian</a> and, possibly, the <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B6%25D0%25B4%25D1%2583%25D0%25BD%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B4%25D0%25BD%25D1%258B%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">international</a> version of this game.  In fact, checkers (even if we consider only traditional games) are more.  Much more!  Games are very similar to each other and, often, differ only in small details. <br><br> <a href=""><img src="https://habrastorage.org/web/6ab/8fd/883/6ab8fd883ec241869244560307faf63d.PNG"></a> <br><br>  The picture is clickable.  Twice!  <a href="https://glukkazan.github.io/checkers-like/alquerque.htm">Take the</a> medieval <a href="https://glukkazan.github.io/checkers-like/alquerque.htm">Alquerque</a> and the <a href="https://glukkazan.github.io/elimination/fox-and-geese-british.htm">Fox and the Geese as a</a> starting <a href="https://glukkazan.github.io/checkers-like/alquerque.htm">point</a> .  It seems that this is the first game in which the composite take appeared.  The idea here is that by completing the ‚Äúcheck‚Äù capture, the figure gets the right to continue the move by taking another figure.  And so, as long as there is someone to take. <br><br>  The links in my diagram are rather arbitrary.  They do not reflect the historical development (it, in our time, is unlikely to be restored), but rather the interrelationships of the various variants of the rules of the game.  For example, the ‚Äú <a href="https://glukkazan.github.io/checkers/senegalese-checkers.htm">Senegalese checkers</a> ‚Äù are hardly the forerunners of the ‚Äú <a href="https://glukkazan.github.io/checkers/turkish-dama.htm">Turkish checkers</a> ‚Äù and, accordingly, the entire ‚Äúorthogonal‚Äù direction.  They are more archaic, it is a fact, but most likely there was a parallel development from some unknown common ancestor. <br><br>  On the part of another family, two important historical events occurred simultaneously - the rejection of orthogonal movements (in favor of the diagonal ones) and the use of the traditional chessboard (in the wake of the growing popularity of Chess, this decision had the most beneficial effect on the spread of the game).  We again do not know where and when this happened.  Perhaps the link was ‚Äú <a href="http://skyruk.livejournal.com/256132.html">Dan</a> ‚Äù - Philippine drafts, hard to say. <br><br>  " <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BD%25D0%25B3%25D0%25BB%25D0%25B8%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B5_%25D1%2588%25D0%25B0%25D1%2588%25D0%25BA%25D0%25B8">English checkers</a> " are the root of the "diagonal" family, because they use the most primitive version of the rules.  Non-transformed figures in them cannot move backwards (even while performing a take), queens differ only in that they have the right to move in any direction.  This is a very leisurely game.  The Italians "turned" the board 90 degrees and made the ladies inviolable (simple figures can not "chop" them).  By the way, there is an interesting <a href="https://glukkazan.github.io/checkers/italian-damone.htm">kind of game</a> that develops this idea: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HSZc3RGZO_0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  In the ‚Äú <a href="https://glukkazan.github.io/checkers/spanish-checkers.htm">Spanish checkers</a> ‚Äù, the board is also rotated 90 degrees, but here ‚Äúflying‚Äù long-range queens appear (simple figures still cannot ‚Äúchop‚Äù back).  The ladies become very strong and for the first time the problem of their "catching" arises. <br><br><div class="spoiler">  <b class="spoiler_title">Every drafts player must be able to do it!</b> <div class="spoiler_text">  Three ladies catch one (provided that she did not occupy the ‚Äúbig one‚Äù - the main diagonal of the board).  This is an interesting task, for the solution of which you can use at least two tactical constructions: the famous <a href="http://www.gambiter.ru/checkers/item/63-treugolnik-petrova.html">Petrov's Triangle</a> and the less well-known <a href="http://www.gambiter.ru/checkers/item/73-shtyk-gonyaeva.html">Gonyayev Bayonet</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/6Lzw0rcUDbI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Those who wish to practice can do it <a href="https://glukkazan.github.io/checkers/russian-checkers-ending.htm">here</a> . <br></div></div><br>  <a href="https://glukkazan.github.io/checkers/argentinian-checkers.htm">The Argentinean</a> and <a href="https://glukkazan.github.io/checkers/thai-checkers.htm">Thai</a> versions of the game limit the mobility of the ladies, allowing them to stop only on the first field behind the taken figure (if it is free, of course).  By the way, in exactly the same way ‚Äú <a href="https://glukkazan.github.io/checkers/greek-checkers.htm">Greek checkers</a> ‚Äù limit the mobility of ‚ÄúTurkish ladies‚Äù.  Next come the familiar to us variants of the game, allowing "taking back" by simple figures. <br><br><div class="spoiler">  <b class="spoiler_title">More about taking</b> <div class="spoiler_text">  Practically all variants of drafts with long-range queens (except for ‚ÄúTurkish‚Äù and ‚ÄúGreek‚Äù) use the ‚Äú <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2583%25D1%2580%25D0%25B5%25D1%2586%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2583%25D0%25B4%25D0%25B0%25D1%2580">Turkish strike</a> ‚Äù rule, also aimed at restricting the mobility of the queens.  Its essence is that the taken pieces are removed from the board only at the end of the turn.  This limits the queen, interfering with her movements (of course, repeated taking of figures during the course is prohibited).  The second complex bug of the current iteration was associated with this rule. <br><br>  I decided to do just that - <a href="">move</a> all the moves of the composite move to its last partial move.  It worked as it was intended - the pieces remained on the board for the entire turn and were removed from the board after its completion.  Of course, I had to make <a href="https://github.com/GlukKazan/Dagaz/commit/b79cc66a783bca9d450d8ee197d12a3c64790305">changes to the model</a> that prevented the re-taking of figures (otherwise, the generator of the moves simply went in cycles and it simply did not reach any ‚Äúextension magic‚Äù).  Unfortunately, I forgot to do the main thing - run the <a href="">tests</a> after this change!  As a result, I spent a lot of time.  The logic of the compound takes "broke" in a very non-trivial and rather imperceptible way.  It was sudden and terrible.  It broke! <br><br><div class="spoiler">  <b class="spoiler_title">In the end, I found a solution</b> <div class="spoiler_text"><pre> <code class="javascript hljs">ZrfMoveGenerator.prototype.isCaptured = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos, level</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.parent.isCaptured(pos, level); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.captured)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.captured = []; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.captured[pos] &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.captured[pos] &lt; level)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; _.each(Dagaz.Model.getDesign().allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.captured[p] &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.captured[p] &gt;= level)) { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.captured[p]; } }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.captured[pos] = level; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } ZrfMoveGenerator.prototype.capturePiece = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Dagaz.Model.deferredStrike) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isCaptured(pos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.level)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.move.capturePiece(pos, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.level); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Dagaz.Model.deferredStrike) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setPiece(pos, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre></div></div><br>  But time and effort was spent on this very much.  Never forget the tests!  And yet, never do this: <br><pre> <code class="javascript hljs">_.chain(move.actions) .filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (action[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (action[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }) .each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ action[<span class="hljs-number"><span class="hljs-number">3</span></span>] = mx; });</code> </pre>  The consequences will be wonderful, but you are unlikely to like it!  Do not change the fields (even the most innocuous) inside the collection you are iterating.  It is better to re-create it, let it remain immutable: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actions = []; _.each(move.actions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pn = action[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((action[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (action[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { pn = mx; } actions.push([ action[<span class="hljs-number"><span class="hljs-number">0</span></span>], action[<span class="hljs-number"><span class="hljs-number">1</span></span>], action[<span class="hljs-number"><span class="hljs-number">2</span></span>], pn ]); }); move.actions = actions;</code> </pre></div></div><br>  <a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Russian checkers</a> (by the way, there is <a href="https://glukkazan.github.io/checkers/80-cells-checkers.htm">another</a> very original way of solving the problem ‚Äúdam on the big one‚Äù) differ from the <a href="https://glukkazan.github.io/checkers/international-checkers.htm">international</a> (besides the size of the board, of course) by just one significant detail.  In Russian drafts, the transformation into a lady happens on the fly.  The move is not interrupted and the figure continues to take like a lady (from the point of view of software implementation, this was the most obvious behavior).  In international - the figure continues to take, even after hitting the transformation field, but ‚Äúcuts‚Äù like a simple figure, and the transformation itself takes place only if the figure finishes its turn on the last horizontal.  Here I had to write a <a href="">special extension</a> , however, its debugging did not cause any problems. <br><br>  Meanwhile, Alquerke also evolved.  The development took place in parallel with the development of drafts and gathered from the latter such ideas as the course of simple figures ‚Äúonly forward‚Äù, ‚Äúflying ladies‚Äù and even the rule of ‚ÄúTurkish strike‚Äù.  It turned out quite original and very original games " <a href="https://glukkazan.github.io/checkers-like/zamma.htm">Zamm</a> " and " <a href="https://glukkazan.github.io/checkers-like/kharbaga.htm">Harbaga</a> ", I can recommend them to those who are tired of the chessboard. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/3fPM0KSQEmk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">The Finns have kept another ancient game for us.</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/web/6bd/a45/f85/6bda45f85a1b4530b734899a1ec71750.PNG"></div><br>  <a href="https://en.wikipedia.org/wiki/Dablot_Prejjesne">This game is</a> much closer to Alquerque.  There are no ‚Äúflying ladies‚Äù in it, there is not even a transformation!  The game has a "king" and "prince", but these posts are for life.  Simple figures can not become "royal persons".  Also, they can not threaten "titled" figures (in this respect, the game is similar to the "Italian Checkers").  The game is quite slow, but it has its fans. <br><br>  For me, <a href="https://glukkazan.github.io/checkers-like/dablot-prejjesne.htm">Dablot</a> was interested in a more complex system of priorities.  Taking in the game is mandatory, but not for the "king" or "prince."  That is, if there is a possibility of taking by a simple figure - it is necessary to take (it is possible to take another figure, even a ‚Äúking‚Äù, if there is such a move), but if the threat is created only by the ‚Äúking‚Äù or ‚Äúprince‚Äù, it is allowed to make a ‚Äúsilent‚Äù move.  All this resulted in a fairly simple <a href="">extension</a> (at the level of ZRF, priorities had to be turned off).  However, even here I managed to <a href="https://github.com/GlukKazan/Dagaz/commit/85e09de4570ab560560c13bf1dabcee9aa6454a2">plow a</a> little: <br><br><pre> <code class="diff hljs"> if (_.chain(board.moves) .filter(function(move) { return _.isUndefined(move.failed); }) .filter(function(move) { return move.actions.length &gt; 1; }) .filter(function(move) { ... - }).value().length &gt; 1) { + }).value().length &gt;= 1) { _.chain(board.moves) .filter(function(move) { return move.actions.length == 1; }) .each(function(move) { move.failed = true; }); }</code> </pre></div></div><br>  The culmination of this direction of the games, I think Madagascar " <a href="https://glukkazan.github.io/checkers-like/fanorona-normal.htm">Fanorona</a> ".  It is already quite unlike checkers, since it uses a completely different capture mechanism.  Of course there are similarities - taking is also compound.  At the same time, Fanorona is the only known game in which the player has the right to interrupt the chain of captures (the capture itself still remains obligatory)! <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/NAVVsEBT8W8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  This game has become for me a real test of strength.  Everything was there: breaking the model and rewriting the controller and new funny bugs.  But all is well that ends well.  The iteration is complete and I can go on vacation with a clear conscience! <br></div><p>Source: <a href="https://habr.com/ru/post/335228/">https://habr.com/ru/post/335228/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335218/index.html">CNCF offered free open source cloud for DevOps / microservices</a></li>
<li><a href="../335220/index.html">How Discord Scaled Elixir to 5 Million Concurrent Users</a></li>
<li><a href="../335222/index.html">Microsoft Office Automation: Another Macro Virus Hole</a></li>
<li><a href="../335224/index.html">Optimization Method Trust-Region DOGLEG. Python implementation example</a></li>
<li><a href="../335226/index.html">ML Boot Camp V, solution history for 2nd place</a></li>
<li><a href="../335230/index.html">The number game: how algorithmic trading will change the sphere of finance</a></li>
<li><a href="../335232/index.html">Daniel Story Comics (Part 2)</a></li>
<li><a href="../335234/index.html">"There are pluses for both admins and developers": Oleg Anastasyev about the Odnoklassniki cloud</a></li>
<li><a href="../335238/index.html">What can and can not neural network: a five-minute guide for beginners</a></li>
<li><a href="../335240/index.html">Extending, modifying, and creating controls on the UWP platform. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>