<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another logging system, now on ElasticSearch, Logstash, Kibana and Prometheus</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All developers know the situation when the application has started and the user cannot do what he needs. The reasons are different: the user entered t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another logging system, now on ElasticSearch, Logstash, Kibana and Prometheus</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/b08/dce/224/b08dce224dc44b979cee979b0e2260c9.png"><br><p><br>  All developers know the situation when the application has started and the user cannot do what he needs.  The reasons are different: the user entered the wrong data, he has a slow Internet and much more.  Without a logging system, disassembling these errors is difficult, and sometimes impossible.  On the other hand, the logging system is a good indicator of problem areas in the system operation.  I will tell you how to build a logging system in your project (yes, again).  In the article I will talk about Elasticsearch + Logstash + Kibana and Prometheus and how to integrate them with my application. </p><a name="habracut"></a><br><p>  2GIS is a web map and directory of organizations.  The company may have additional content - photos, discounts, logo and so on.  And so that business owners can conveniently manage this good, a Personal Account has been created.  Using the Personal Account, you can: </p><br><ul><li>  Add or edit organization contacts </li><li>  Upload photos, logo </li><li>  See what users do when they open an organization, and more. </li></ul><br><p>  Personal account consists of two projects: backend and front-end.  The backend is written in PHP version 5.6, using the Yii 1 framework (yes, yes).  Actively use omposer to manage dependencies in the project, autoloading of classes in accordance with PSR-4, namespace, trait.  In the future we plan to update the version of PHP to the seven.  We use Nginx as a web server, data is stored in MongoDB and PostgreSQL.  The frontend is written in JavaScript, using our <a href="https://github.com/catbee/catbee">Catbee</a> cooking <a href="https://github.com/catbee/catbee">framework</a> .  The backend provides an API for the frontend.  Further in the report I will speak exclusively about the backend. </p><br><p>  Here is the scheme of our integrations.  It reminds us of the starry sky.  If you look closely, you can see the Big Dipper: </p><br><img src="https://habrastorage.org/web/fb7/b90/5a7/fb7b905a7a0c412eac3e0f151bdac767.jpg"><br><p>  External services are heterogeneous - developed by a dozen teams, with their own stack of technologies and API.  Integration scenarios are non-trivial - first we go to one service, we get data, we impose our business logic, we go to several more services with new data, we combine the answers and give the result to the frontend.  And if the user has a problem and cannot fulfill the desired, for example, extend the advertising campaign, then without a logging system, we cannot understand where the problem was - either we send the data incorrectly to an external service, or we interpret the answer incorrectly, or the external service is not available, incorrectly impose your business logic. </p><br><p>  We had error logging, but with the advent of new services, it became increasingly difficult to track integration and respond to technical support requests for an emerging problem.  Therefore, we have developed new requirements for our logging system: </p><br><ul><li>  Need more context about errors - what happened and which user. </li><li>  Collect incoming requests in a convenient form. </li><li>  If the methods take a long time to respond, you need to notify the team about it </li></ul><br><h2 id="logirovanie-oshibok">  Error logging </h2><br><p>  Historically, our company uses the <a href="https://www.elastic.co/">Elasticsearch</a> + <a href="https://www.elastic.co/products/logstash">Logstash</a> + <a href="https://www.elastic.co/products/kibana">Kibana</a> technology stack, ELK for short, to collect and view logs.  Elasticsearch is a NoSQL document repository with full text search capability.  Logstash is configured to receive logs using TCP / UDP protocols, reads messages from Redis and saves them to Elasticsearch.  Kibana provides a visual interface to search and display collected data. </p><br><p>  If the client has something wrong, then he contacts technical support from his account with a description of the problem.  We had error logging, but there was no user email, no API method called, no call stack.  In the messages there was only a line from the raw Exception of the form "The request returned an incorrect result".  Because of this, we were looking for a problem according to the time of the client's request and keywords, which was not always accurate - the client could turn in a day, and it was very difficult to help. </p><br><p>  Having tormented, we decided to do something and added the necessary information - the user's email, API-method, request body, call stack and our controller and action, which processed the request.  As a result, we have simplified the life of technical support and ourselves - the guys give us the user's email, and we find records in the logs and deal with the problem.  We know exactly which user had the problem, which method was called and how much of our code processed it.  No comparisons on the time of treatment! </p><br><p>  Error messages are sent while the application is running via UDP protocol in Graylog Extended Log Format, or <a href="http://docs.graylog.org/en/2.2/pages/gelf.html">GELF for</a> short.  The format is good because messages can be compressed by popular algorithms and divided into parts, thereby reducing the amount of traffic sent from our application to Logstash.  Although the UDP protocol does not guarantee the delivery of messages, it imposes minimal overhead on the response time, so this option suits us.  In the application we use the library <a href="https://github.com/bzikarsky/gelf-php">gelf-php</a> , which provides opportunities for sending logs in different formats and protocols.  I recommend using it in your PHP applications. </p><br><p>  Conclusion - if your application works with external users and you need to search for answers to emerging technical support questions, feel free to add information that will help identify the client and its actions. <br>  An example of our message: </p><br><pre><code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"user_email"</span></span>: <span class="hljs-string"><span class="hljs-string">"test@test.ru"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"api_method"</span></span>: <span class="hljs-string"><span class="hljs-string">"orgs/124345/edit"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"method_type"</span></span>: <span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"payload"</span></span>: <span class="hljs-string"><span class="hljs-string">"{'name': ' '}"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"controller"</span></span>: <span class="hljs-string"><span class="hljs-string">"branches/update"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"message"</span></span>: <span class="hljs-string"><span class="hljs-string">"Undefined index: 'name' File: /var/www/protected/controllers/BranchesController.php Line: 50"</span></span> }</code> </pre> <br><h2 id="logirovanie-zaprosov">  Request logging </h2><br><p>  Logging requests in a structured form and collecting statistics were absent, so it was not clear which methods are most often called and how much time they answer.  This led to what we could not: </p><br><ul><li>  estimate the allowed response time of the methods. </li><li>  the cause of the brakes - on our side or on the side of the external service (remember the scheme with a starry sky?) </li><li>  how can we optimize our code to reduce response time. </li></ul><br><p>  Within the framework of this task, we had to solve the following questions: </p><br><ol><li>  selection of response parameters for logging </li><li>  send parameters to Logstash </li></ol><br><p>  We use the Nginx web server, and it can write access logs to a file.  To solve the first problem, a new format for saving logs in the configuration was specified: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">log_format</span></span> main_logstash <span class="hljs-string"><span class="hljs-string">'{'</span></span> <span class="hljs-string"><span class="hljs-string">'"time_local": "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$time_local</span></span></span><span class="hljs-string">",'</span></span> <span class="hljs-string"><span class="hljs-string">'"request_method": "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request_method</span></span></span><span class="hljs-string">",'</span></span> <span class="hljs-string"><span class="hljs-string">'"request_uri": "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request_uri</span></span></span><span class="hljs-string">",'</span></span> <span class="hljs-string"><span class="hljs-string">'"request_time": "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request_time</span></span></span><span class="hljs-string">",'</span></span> <span class="hljs-string"><span class="hljs-string">'"upstream_response_time": "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$upstream_response_time</span></span></span><span class="hljs-string">",'</span></span> <span class="hljs-string"><span class="hljs-string">'"status": "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$status</span></span></span><span class="hljs-string">",'</span></span> <span class="hljs-string"><span class="hljs-string">'"request_id": "</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$request_id</span></span></span><span class="hljs-string">"'</span></span> <span class="hljs-string"><span class="hljs-string">'}'</span></span>; <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">access_log</span></span> /var/log/nginx/access.log main_logstash; }</code> </pre> <br><p>  Most of the metrics, I think, do not cause any questions, I will tell you more about the most interesting one - $ request_id.  This is a unique identifier, UUID version 4, which is generated by Nginx for each request.  We are forwarding this header in the request to external services and can track the response of the request in the logs of other services.  It is very convenient when searching for problems in other services - no comparisons of time, url of the method called. </p><br><p>  To send logs to Logstash, use the <a href="https://github.com/python-beaver/python-beaver">Beaver</a> utility.  It is installed on all nodes of the application from which the logs are scheduled to be sent.  The configuration specifies the file that will be parsed to receive new logs, the fields that will be sent with each message are indicated.  Messages are sent to the Redis cluster, from which Logstash collects data.  Here is our Beaver configuration: </p><br><pre> <code class="hljs pgsql">[/var/<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>/nginx/<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">log</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: nginx_accesslog add_field: team,lk,project,backend tags: nginx_json</code> </pre> <br><p>  In the type and tags fields in Logstash, according to our values, filtering and processing of logs are done, you can have your own values.  In addition, we add the team and project fields so that we can identify the team and the project that owns the logs. </p><br><p>  Having learned to collect access logs, we moved on to defining SLA methods.  SLA, the contract for the level of service, in our case, we guarantee that the 95th percentile of the response time of the methods will be no more than 0.4 seconds.  If we do not fit into the allowable time, it means that in the application either one of the integrations slows down and we appeal to the associated team, or something is wrong in our code and optimization is necessary. </p><br><p>  Conclusion on the collection of access-logs - we have defined the most frequently called methods and their allowable response time. </p><br><p>  Here are examples of our reports on one of the measured methods.  The first is equal to 50, 95, and 99 percentile response times and average response times: </p><br><img src="https://habrastorage.org/web/05a/58e/929/05a58e929cab415f8835fcf9955ab091.jpg"><br><p><br>  Answer Status Chart: </p><br><img src="https://habrastorage.org/web/420/a45/324/420a45324ca14cf5b78525581ce02a3e.jpg"><br><p><br>  Average response time for a period of time: </p><br><img src="https://habrastorage.org/web/906/789/391/906789391622469a8f02193692472f99.jpg"><br><p><br></p><br><h2 id="opovescheniya-komandy-o-padenii-sla">  SLA fall command alerts </h2><br><p>  After collecting the logs we got the idea that we need to quickly find out about the fall in speed.  Keeping the browser open with Kibana all the time, pressing F5, comparing the current value of the 95th percentile with the allowable in mind was not very practical - there are many other interesting tasks in the project.  Therefore, for the formation of alerts, we added integration with the Prometheus system.  Prometheus is an open source system for collecting, storing and analyzing the metrics of a running application.  <a href="https://prometheus.io/">Official website with documentation</a> . </p><br><p>  We liked the system because if the trigger is triggered, you can send an alert to the mail.  The opportunity is provided out of the box, without problems with access to servers and without writing custom scripts to generate an alert.  The system is written in Go, the creators are SoundCloud.  There are libraries for collecting metrics in different languages ‚Äã‚Äã- Go, PHP, Python, Lua, C #, Erlang, Haskell and others. </p><br><p>  I will not tell you how to install and run Prometheus.  If you are interested in this, I suggest reading the <a href="https://habrahabr.ru/company/selectel/blog/275803/">article</a> .  I will focus on those points that were of practical importance for us. </p><br><p>  The integration scheme looks like this - the client application at the address gives a set of metrics, Prometheus comes to this address, collects and stores the metrics in its repository. </p><br><img src="https://habrastorage.org/web/91f/efc/77b/91fefc77b716497d8df5f20ab4c070eb.jpg"><br><p><br>  Let's see what the metrics look like. </p><br><img src="https://habrastorage.org/web/125/078/1e2/1250781e28be4d2ea09f3c7c49f7f5de.jpg"><br><p><br></p><br><ol><li>  The name is the identifier of the characteristic being studied.  For example, the number of incoming requests. </li><li>  A metric has a specific value at a time.  Time puts Prometheus when collecting metrics. </li><li>  A metric can have labels.  They contain additional information about the collected number.  In the example, the application node and the API method are specified.  The main feature of labels is that you can search for them and make the necessary data sampling. </li></ol><br><p>  Time-value data storage is called Time Series Databases.  This is a highly specialized NoSQL storage for storing time-varying indicators.  For example, the number of users on the site at 10 am, per day, per week, and so on.  Due to the nature of the tasks and storage method, such databases provide high performance and compact data storage. </p><br><p>  Prometheus supports several types of metrics.  Consider the first type, called the Counter.  Counter value at new measurements always grows upwards.  Ideal for measuring the total number of incoming requests for the entire history - there can not be such that today there were 100 total requests, and tomorrow the number decreased to 80. </p><br><p>  But what about the response time measurement?  It does not necessarily grow up, moreover, it can fall down, be for some time on the same level, and then grow up.  A change can occur in less than 10 seconds, and we want to see the dynamics of change in response time for each request.  Fortunately, there is a type of histogram.  For the formation, it is necessary to determine the response time measurement interval.  In the example, we take from 0.1 to 0.5 seconds, all that more we will consider as Infinity. </p><br><p>  Here is the initial state of the Histogram: </p><br><pre> <code class="hljs pgsql">api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.1"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.2"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.3"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.4"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.5"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="+Inf"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_sum{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_count{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users"} <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  For each value in the interval, we create a Counter according to certain rules: </p><br><ol><li>  The title must have postfix _bucket </li><li>  There must be a label le, which indicates the value of the interval.  Plus there should be a Counter with a value of + Inf. </li><li>  Must be Counters with the _sum and _count postfixes.  They store the total total time of all responses and the number of requests.  Needed for convenient calculation of the 95th percentile with Prometheus. </li></ol><br><p>  Let's see how to properly fill in the Histogram with the response time.  To do this, you need to find a series in which the value of the le label is greater than or equal to the response time, and increase them by one.  Suppose that our method responded in 0.4 seconds.  We find those Counters whose le label is greater than or equal to 0.4, and add one to the value: </p><br><pre> <code class="hljs pgsql">api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.1"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.2"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.3"} <span class="hljs-number"><span class="hljs-number">0</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.4"} <span class="hljs-number"><span class="hljs-number">1</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="0.5"} <span class="hljs-number"><span class="hljs-number">1</span></span> api_request_time_bucket{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users",le="+Inf"} <span class="hljs-number"><span class="hljs-number">1</span></span> api_request_time_sum{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users"} <span class="hljs-number"><span class="hljs-number">0.4</span></span> api_request_time_count{node="api1.2gis.com",<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>="/users"} <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><img src="https://habrastorage.org/web/bc9/e89/787/bc9e897876d545dda1289cfca743673a.jpg"><br><p>  If the method is responsible for 0.1 second, then we increase all series.  If it answers for 0.6 seconds, then we increase only the counter with the value "+ Inf".  Do not forget to increase the counters api_request_time_sum and api_request_time_count.  Using the Histogram, you can measure the response time, which in a short period can often change. </p><br><p>  Prometheus supports two more types of metrics ‚Äî Scale and Results Summary.  The scale describes the characteristic, the value of which can either increase or decrease.  We do not use them in tasks, since such indicators are not measured here.  The results summary is an extended Bar Graph that stores quantiles calculated on the application side.  Theoretically, it would be possible to calculate a 95% percentile, or 0.95 quantile, but this would add code to the calculation on the client side and would deprive the flexibility in the reports ‚Äî we could only use the quantiles we calculated.  Therefore, their choice was stopped on the histogram. </p><br><p>  Histogram generation was implemented in Lugin in Nginx.  Found a finished project on <a href="https://github.com/knyar/nginx-lua-prometheus">GitHub</a> , which connects to the Nginx configuration and generates a histogram in the manner described above.  We need to collect data from the most frequently called methods, which, as you remember, we determined after sending access logs to Logstash.  Therefore, it was necessary to add business logic to check whether the request should be logged or not. </p><br><p>  As a result, integration took a week, along with the study of the hardware Prometheus and the foundations of the language Lua.  In our opinion, this is an excellent result.  Another great thing is that a minor amount, about 5-10 ms, is added to the response time, the overhead is due to the formation of the Histograms and the verification of our business logic, which is less than expected. </p><br><p>  But there are also disadvantages to this solution - we do not take into account the time of requests for which the status is not 200. The reason is the log_by_lua directive, to which we added logging, is not called in this case.  Here is the <a href="https://github.com/openresty/lua-nginx-module">confirmation</a> .  On the other hand, we are not interested in the response time of such requests, because this is a mistake.  Another disadvantage is that the histogram is stored in Nginx shared memory.  When Nginx is restarted, the memory is cleared and the collected metrics are lost.  You can also live with this - restart Nginx with the reload command, and configure Prometheus so that it takes metrics more often. </p><br><p>  Here is the Nginx configuration for creating the Histogram: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">lua_shared_dict</span></span> prometheus_metrics <span class="hljs-number"><span class="hljs-number">10M</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">init_by_lua</span></span> <span class="hljs-string"><span class="hljs-string">' prometheus = require("prometheus").init("prometheus_metrics") prometheusHelper = require("prometheus_helper") metric_request_time = prometheus:histogram("nginx_http_request_time", {"api_method_end_point", "request_method"}) '</span></span></code> </pre> <br><p>  Here we allocate shared memory, connect the library and helper with our business logic and initialize the Histogram - assign the name and labels. </p><br><p>  This configuration is responsible for logging the request: </p><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> / { <span class="hljs-attribute"><span class="hljs-attribute">log_by_lua</span></span> <span class="hljs-string"><span class="hljs-string">' api_method_end_point = prometheusHelper.convert_request_uri_to_api_method_end_point(ngx.var.request_uri, ngx.var.request_method) if (api_method_end_point ~= nil) then metric_request_time:observe(tonumber(ngx.var.request_time),{api_method_end_point, ngx.var.request_method}) '</span></span> }</code> </pre> <br><p>  Here, in the log_by_lua directive, we check whether the request should be logged, and if so, add its response time to the Histogram. </p><br><p>  Metrics are given via Nginx at endpoint: </p><br><pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">9099</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">server_name</span></span> api1.2gis.com; <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /metrics { <span class="hljs-attribute"><span class="hljs-attribute">content_by_lua</span></span> <span class="hljs-string"><span class="hljs-string">'prometheus:collect()'</span></span>; } }</code> </pre> <br><p>  Now, in the Prometheus configuration, specify the nodes of our application for collecting metrics: </p><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">targets</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">api1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.2gis</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:9099</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">api2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.2gis</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.com</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:9199</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">labels</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">job</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">bizaccount</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">type</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">nginx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">role</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">monitoring-api-methods</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">team</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">lk</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">project</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">backend</span></span></code> </pre> <br><p>  In the targets section, endpoint of our nodes is specified, in the labels section - labels that are added to the metrics collected.  According to them we determine the purpose of the metric and the sender. </p><br><p>  We set up collecting metrics every 15 seconds - Prometheus enters the specified nodes and keeps the metrics for itself. </p><br><p>  After we dealt with the metrics, learned how to collect them, give them to Prometheus, we moved on to what was started integration - alerts to the command mail when the speed of our application drops.  Here is an example alert: </p><br><pre> <code class="hljs pgsql">ALERT BizaccountAPI95PercentileUnreachebleGetUsers <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> (sum(rate(nginx_http_request_time_bucket{le="0.4",api_method_end_point="/users",request_method="GET"}[<span class="hljs-number"><span class="hljs-number">5</span></span>m])) <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (api_method_end_point, request_method) / sum(rate(nginx_http_request_time_count{api_method_end_point="/users",request_method="GET"}[<span class="hljs-number"><span class="hljs-number">5</span></span>m])) <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> (api_method_end_point, request_method)) * <span class="hljs-number"><span class="hljs-number">100</span></span> &lt; <span class="hljs-number"><span class="hljs-number">95</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>m LABELS { severity = "critical", team = "lk"} ANNOTATIONS { <span class="hljs-keyword"><span class="hljs-keyword">summary</span></span> = "API-method {{ $labels.request_method}} {{ $labels.api_method_end_point}} is not in SLA", description = "For API-method {{ $labels.request_method}} {{ $labels.api_method_end_point }} 95 percentile is unreacheble in last 5 minutes. Current percentile is {{ $value }}.", }</code> </pre> <br><p>  Prometheus has a laconic query generation language, with which you can select values ‚Äã‚Äãof metrics for a period and filter by labels.  In the IF directive, we use the language constructs to specify the trigger trigger condition - if less than 95 percent of requests in the last 5 minutes are answered in 0.4 seconds.  This is considered an attitude.  In the numerator, we calculate how many requests fit in 0.4 seconds in the last 5 minutes: </p><br><pre> <code class="hljs lisp">sum(<span class="hljs-name"><span class="hljs-name">rate</span></span>(<span class="hljs-name"><span class="hljs-name">nginx_http_request_time_bucket</span></span>{le=<span class="hljs-string"><span class="hljs-string">"0.4"</span></span>,api_method_end_point=<span class="hljs-string"><span class="hljs-string">"/users"</span></span>,request_method=<span class="hljs-string"><span class="hljs-string">"GET"</span></span>}[<span class="hljs-number"><span class="hljs-number">5</span></span>m])) by (<span class="hljs-name"><span class="hljs-name">api_method_end_point</span></span>, request_method)</code> </pre> <br><p>  In the denominator, we consider the total number of requests for the last 5 minutes: </p><br><pre> <code class="hljs lisp">sum(<span class="hljs-name"><span class="hljs-name">rate</span></span>(<span class="hljs-name"><span class="hljs-name">nginx_http_request_time_count</span></span>{api_method_end_point=<span class="hljs-string"><span class="hljs-string">"/users"</span></span>,request_method=<span class="hljs-string"><span class="hljs-string">"GET"</span></span>}[<span class="hljs-number"><span class="hljs-number">5</span></span>m])) by (<span class="hljs-name"><span class="hljs-name">api_method_end_point</span></span>, request_method)</code> </pre> <br><p>  The resulting fraction is multiplied by 100 and we get the percentage of requests that are responsible for 0.4 seconds.  The rate function here returns the response time for each moment in the specified interval.  The sum function summarizes the resulting row.  The by operator is an analogue of the GROUP BY operator, which performs grouping by the specified labels. </p><br><p>  The FOR section indicates the interval between the first trigger and the moment when it is necessary to send alerts.  Our interval is 5 minutes - if in 5 minutes the situation does not change, then you need to send an alert.  In the LABELS section, labels with the command and criticality of the problem are indicated.  The ANNOTATIONS section indicates the problematic method and what percentage of requests is answered in 0.4 seconds. </p><br><p>  In case of repeated alerts, Prometheus can do deduplication, and will send one alert to the team mail.  And this is all out of the box, we just need to specify the rules and the trigger interval. </p><br><p>  The alerts in Prometheus turned out exactly as we wanted - with a clear configuration, without their bikes with alert deduplication and without implementing the alert triggering logic in any language. </p><br><p>  Here is the message: </p><br><img src="https://habrastorage.org/web/14d/7a0/b26/14d7a0b2698a4b47985eac7743262cb4.jpg"><br><p><br></p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  We have improved our logging system and now we have no problems with the lack of information. </p><br><ol><li>  When an error occurs, we have enough information about the problem.  Now, for 99 percent of technical support requests, we have an idea of ‚Äã‚Äãwhat happened to the user and accurately orient technical support about the problem and possible fixes. </li><li>  With the help of alerts, we identify problem areas in application performance and optimize them, making the application faster and more reliable. </li><li>  Through Prometheus, we quickly find out about the fall in speed, and after that we look in ELK and begin to study in detail what happened.  We see a great potential for the ELK + Prometheus bundle, we plan to add alerts in case of increasing errors and monitoring external services. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329128/">https://habr.com/ru/post/329128/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329110/index.html">Terminology. Fight against complexity</a></li>
<li><a href="../329118/index.html">3CX technical support responds: how to get the credentials of the 3CX user portal and how to change the FQDN of the PBX server</a></li>
<li><a href="../329120/index.html">[Java Archeology] Context-dependent inlayning of traces in Java</a></li>
<li><a href="../329122/index.html">How to build a voice bot: speech recognition, speech synthesis and NLP in a few lines of code</a></li>
<li><a href="../329124/index.html">New life utility</a></li>
<li><a href="../329130/index.html">The digest of interesting materials for Mobile Developer # 204 (May 15-21)</a></li>
<li><a href="../329132/index.html">Big data for big science. Lecture in Yandex</a></li>
<li><a href="../329134/index.html">Palmistry UX</a></li>
<li><a href="../329136/index.html">What is the essence of the Moby project and why the main Docker repository suddenly became moby / moby?</a></li>
<li><a href="../329138/index.html">ENTRYPOINT vs CMD: Back to Basics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>