<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Does your AngularJS work on 3.5Mb of RAM?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In early spring, ABBYY LS together with Xerox launched a service for translating documents Xerox Easy Translator Service. The highlight of this servic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Does your AngularJS work on 3.5Mb of RAM?</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/83c/c5f/a8c/83cc5fa8cbd244aa8b6e9396a8994f7b.jpg"><br>  In early spring, <a href="http://abbyy-ls.ru/">ABBYY LS</a> together with Xerox launched a service for translating documents Xerox Easy Translator Service.  The highlight of this service is an application that runs on the Xerox MFP and allows you to scan the required number of documents, wait for the translation into one of the 38 languages ‚Äã‚Äãselected, print the translation - and all this without departing from the MFP. <br><br>  The application runs on a specific series of Xerox MFPs based on the Xerox ConnectKey technology with a 800x480 pixel touch screen.  The hardware of the MFP depends on the specific model, for example, our test little Xerox WorkCentre 3655 has a 1Ghz Dual Core processor and 2Gb of RAM on board.  Surprisingly, the MFP has a built-in webkit browser, and our application is a regular html application developed on AngularJS 1.3.15. <br><br>  We <a href="https://habrahabr.ru/company/abbyy/blog/282636/">wrote</a> about the project itself in the blog earlier, and this article is devoted to one of the exciting stages of the project, namely the optimization of AngularJS for work on the Xerox MFP.  As it turned out, the MFP platform practically does not impose any serious restrictions on the development of applications, and they work almost the same way as on desktop webkit browsers, except for one BUT - <a name="habracut"></a>  The html application for JS execution will be allocated only 3.5 Mb of RAM (at this point, Xerox has already released an update for its platform, raising the threshold of allocated memory to 10 Mb).  AngularJS ate these 3.5 Mb in a few minutes of work in the application, and the garbage collector of the built-in MFP browser did not have time for such voracity and simply knocked out our application on the main screen of the MFP.  In addition, Xerox has no tools for analyzing and debugging applications running on the multifunction printer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      At first it seemed that it would not be possible to do anything (especially not having the knowledge of the voracity of modern browsers), but having correctly assessed the situation, we still decided to try to tame AngularJS and make the application consume the minimum possible amount of memory.  Starting with 220kb compiled (minimized, not gzip) JS application code, we finished 97kb (AngularJS takes 56kb, all the rest is our code), removing all the unused code to the maximum, or modifying it for the least memory consumption.  The result is a stable operation of the application for several tens of minutes on a platform with 3.5 Mb of memory and complete non-killability on a new platform from 10 Mb.  What have we done? <br><br><h4>  <font color="#cc0000">Http Requests</font> </h4><br>  The main problem we encountered right away is ‚Äúheavy‚Äù http requests.  Their ‚Äúseverity‚Äù is not measured in quantities or volumes of transmitted data, but in the new XmlHttpRequest object created at every request under the hood of $ http of the AngularJS service.  The official information in the recommendations section of the Xerox SDK indicated that it is highly desirable to use only one XmlHttpRequest object in the application and to perform all requests sequentially using only one object. <br><br>  Examples from the SDK were very simple - literally a couple of requests for the entire application, which, in principle, does not complicate the use of a single XmlHttpRequest object in its bare form using the native callback of this object.  In our application, a very tricky logic of synchronizing user orders, oauth authorization, requests for MFP soap-services for launching scanning or printing is organized.  In addition, requests to the MFP were performed using code from the Xerox SDK, which created its XmlHttpRequest object, pulled methods for working with the xml response of soap services, and generally created additional complexity when parsing this xml response and resulted in writing non-angular-way code. <br><br>  Thus, we are faced with really serious problems: the lack of normal examples of real use of a single XmlHttpRequest object, a wide range of query usage, and semi-legacy code from the SDK.  Despite the complexity, the way out was simple - write your $ http service, discard the code from the Xerox SDK and write your Angular services to support scanning and printing. <br><br>  One of the main difficulties was also that our custom service should have the same software interface as the Angular $ http service in order to keep the already working and tested code of our controllers and $ http dependent services.  Since only get and post requests were used in the application, in the simple annotation $ http.get (...) and $ http.post (...), the service itself looks like this: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$q</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> queue = []; <span class="hljs-comment"><span class="hljs-comment">// execute request function query() { var request = queue[0]; var defer = request.defer; xhr.open(request.method, request.url, true); // set headers var headers = request.headers; for (var i in headers) { xhr.setRequestHeader(i, headers[i]); } // load callback xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; !defer.promise.$$state.status) { var status = xhr.status; var data = JSON.parse(xhr.response); (200 &lt;= status &amp;&amp; status &lt; 300 ? defer.resolve : defer.reject)({ data: data, status: status }); queue.shift(); if (queue.length) { query(); } } }; // send data xhr.send(request.data); } // add request to queue function push(method, url, data, headers) { var defer = $q.defer(); queue.push({ data: typeof data === "string" ? data : JSON.stringify(data), defer: defer, headers: headers, method: method, url: url }); if (queue.length == 1) query(); return defer.promise; } return { // get request get: function (url, data, headers) { return push("GET", url, data, headers); }, // post request post: function (url, data, headers) { return push("POST", url, data, headers); } }; }</span></span></code> </pre> <br><br>  This is the minimal type of our service, which, using one XmlHttpRequest object, is able to perform any number of http requests in succession without the threat of aggressive MFP memory consumption.  In the end result, this service contains http interceptor functionality (without the ability to make changes to the final response of the request, it would be better to call http listeners, use for error logging), cancel the request queue $ http.cancel (), plus additional properties of the resulting object, which allow you to understand that the request was canceled by the user or fell off by timeout (30 seconds per request), for example: <br><br><pre> <code class="javascript hljs">$http.get(...).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.canceled) { ... } });</code> </pre><br><br>  The next step is to wrap the calls of the MFP soap services into the corresponding Angular services.  The main problem here is that we get the answer from the multifunctional device in the form of cumbersome soap xml, and the actual data required is only a few bytes.  To simplify this stage, from the source xml (which came to us as a string), we use the regular expression to ‚Äúpull out‚Äù only the tag that interests us: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DOMParser(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toXml</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xml, tag</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tag) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'((&lt;|&amp;lt;)[\\w:]*'</span></span> + tag + <span class="hljs-string"><span class="hljs-string">'(&gt;|&amp;gt;|\\s).*\/[\\w:]*'</span></span> + tag + <span class="hljs-string"><span class="hljs-string">'(&gt;|&amp;gt;))'</span></span>, <span class="hljs-string"><span class="hljs-string">'g'</span></span>).exec(xml); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node &amp;&amp; node.length ? parse(node[<span class="hljs-number"><span class="hljs-number">1</span></span>]) : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parse(xml); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">xml</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser.parseFromString(xml .replace(<span class="hljs-regexp"><span class="hljs-regexp">/amp;/g</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;/g</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/&gt;/g</span></span>, <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/"/g</span></span>, <span class="hljs-string"><span class="hljs-string">'"'</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;\w+:/g</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>) .replace(<span class="hljs-regexp"><span class="hljs-regexp">/&lt;\/\w+:/g</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;\/'</span></span>), <span class="hljs-string"><span class="hljs-string">'text/xml'</span></span>).documentElement; }</code> </pre><br><br>  As a result, we get a DOM-tree, taking data from which is no longer difficult.  In addition, the DOM tree can be used to search for tags of interest using the capabilities of the querySelector.  Initially, the Xerox SDK code always parsed the entire xml response, and the DOM search was performed by custom traversing the tree to find the desired element (something like a custom XPath in JS).  It's really hard to answer which of the approaches consumes memory and system resources better and less, but for some reason we personally trust the native functions of the DomParser.parseFromString browser, querySelector (querySelectorAll) to work with the DOM tree, rather than manually traversing. <br><br>  <b>Total:</b> <br>  It has developed its own functionality for executing http-requests and simple parsing of xml, in a reduced form, occupying 2.3kb.  The entire dependent Xerox SDK code, which occupied 17kb in the minified form, was deleted from the application. <br>  The $ http and $ httpBackend services have been removed from AngularJS. <br><br><h4>  <font color="#cc0000">Routing</font> </h4><br>  Initially, the project used the well <a href="https://github.com/angular-ui/ui-router">-</a> known <a href="https://github.com/angular-ui/ui-router">ui-router</a> version 0.2.13.  This is truly a wonderful, versatile and unique solution for AngularJS.  Using it, we did quite normal application routing, nested states were used for modal windows. <br><br>  Of course, there is a less functional and lightweight <a href="https://docs.angularjs.org/api/ngRoute">solution</a> directly from the AngularJS developers themselves, which initially did not fit in its pure form and required improvements for modal windows.  But it was the source code of this module that was actively used to develop its own solution.  In the process of optimizing the application, we found that we did not need all the functionality of the ui-router module, namely, we did not need url-routing (the application on the multifunction device opens to full screen and no access to the address bar), nested states, resolve, etc. All that we need from the routing is: <br><br>  1. The ability to easily configure the states (screens and modal windows) of an application. <br>  2. Related directives and services for caching and navigation between screens and (or) modal windows. <br>  3. Correct substitution and deletion of the visited screens html templates from the DOM tree, as well as the display of modal windows on top of the original screen (similar to the nested states of the ui-router, but we need only one nesting level). <br><br>  The first point is implemented very easily: <br><br><pre> <code class="javascript hljs">xerox.provider(<span class="hljs-string"><span class="hljs-string">"$route"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ ... var base = <span class="hljs-string"><span class="hljs-string">"/"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> routes = {}; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-comment"><span class="hljs-comment">// add new route function add(name, templateUrl, controller, modal) { routes[name] = { name: name, modal: modal, controller: controller, templateUrl: base + templateUrl + ".html" }; return self; } // set start state self.start = function (name) { start = name; return self; }; // add modal self.modal = function (name, templateUrl, controller) { return add(name, templateUrl, controller, true); }; // add state self.state = function (name, templateUrl, controller) { return add(name, templateUrl, controller, false); }; self.$get = [...]; });</span></span></code> </pre><br><br>  At the configuration stage: <br><br><pre> <code class="javascript hljs">xerox.config([<span class="hljs-string"><span class="hljs-string">"$routeProvider"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$routeProvider</span></span></span><span class="hljs-function">) </span></span>{ $routeProvider <span class="hljs-comment"><span class="hljs-comment">// default state .start("settings") // modals .modal("login", "login/login", "login") .modal("logout", "login/logout", "logout") .modal("processing", "new-order/processing", "processing") // states .state("settings", "new-order/settings", "settings") .state("languages", "new-order/languages", "languages"); }]);</span></span></code> </pre><br><br>  The second item is implemented through services: <br><br>  $ view <br><br><pre> <code class="javascript hljs">xerox.factory(<span class="hljs-string"><span class="hljs-string">"$view"</span></span>, [<span class="hljs-string"><span class="hljs-string">"$http"</span></span>, <span class="hljs-string"><span class="hljs-string">"$locale"</span></span>, <span class="hljs-string"><span class="hljs-string">"$q"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$http, $locale, $q</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> views = {}; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-comment"><span class="hljs-comment">// get view get: function (url) { var self = this; if (views[url]) { return $q.when(views[url]); } else { return $http.get(url).then(function (response) { var template = response.data; self.put(url, template); return template; }); } }, // put view put: function (url, text) { views[url] = text; } }; }]);</span></span></code> </pre><br><br>  and $ route <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-comment"><span class="hljs-comment">// route history var history = []; // $route interface var $route = { // current route current: null, // history back back: function () { if ($route.current.modal) { $rootScope.$broadcast("$routeClose"); } else { $route.go(history.pop() &amp;&amp; history.pop()); } }, // goto route go: function (name, params) { prepare(name, params); } }; // prepare and load route function prepare(name, params) { var route = routes[name]; $view.get(route.templateUrl).then(function (template) { route.template = template; commit(route, params); }); } // commit route function commit(route, params) { route.params = params || {}; if (!route.modal) { history.push(route.name); } $route.current = route; $rootScope.$broadcast("$routeChange"); } // routing start prepare(start); return $route; }];</span></span></code> </pre><br><br>  And also xrx-back directives: <br><br><pre> <code class="javascript hljs">xerox.directive(<span class="hljs-string"><span class="hljs-string">"xrxBack"</span></span>, [<span class="hljs-string"><span class="hljs-string">"$route"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$route</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, element</span></span></span><span class="hljs-function">) </span></span>{ element.on(xrxClick, $route.back); } }; }]);</code> </pre><br><br>  xrx-sref: <br><br><pre> <code class="javascript hljs">xerox.directive(<span class="hljs-string"><span class="hljs-string">"xrxSref"</span></span>, [<span class="hljs-string"><span class="hljs-string">"$route"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$route</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, element, attr</span></span></span><span class="hljs-function">) </span></span>{ element.on(xrxClick, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ $route.go(attr.xrxSref); }); } } }]);</code> </pre><br><br>  and scriptDirective (for text / ng-template caching): <br><br><pre> <code class="javascript hljs">xerox.directive(<span class="hljs-string"><span class="hljs-string">"script"</span></span>, [<span class="hljs-string"><span class="hljs-string">"$view"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$view</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">"E"</span></span>, <span class="hljs-attr"><span class="hljs-attr">terminal</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">compile</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element, attr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attr.type == <span class="hljs-string"><span class="hljs-string">"text/ng-template"</span></span>) { $view.put(attr.id, element[<span class="hljs-number"><span class="hljs-number">0</span></span>].text); } } }; }]);</code> </pre><br><br>  In the $ route service, we will organize additional logic for modal windows, namely: 1) we do not put them in the history of states and 2) when we try to call $ route.back when the modal window is open, we trigger a trigger event that we need to close the modal window.  The xrx-view directive is signed for the event, which implements clause 3: <br><br><pre> <code class="javascript hljs">xerox.directive(<span class="hljs-string"><span class="hljs-string">"xrxView"</span></span>, [<span class="hljs-string"><span class="hljs-string">"$compile"</span></span>, <span class="hljs-string"><span class="hljs-string">"$controller"</span></span>, <span class="hljs-string"><span class="hljs-string">"$route"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$compile, $controller, $route</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stateScope; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modalScope; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> modalElement; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> targetElement; <span class="hljs-comment"><span class="hljs-comment">// destroy scope function $destroy(scope) { scope &amp;&amp; scope.$destroy(); } // on route change scope.$on("$routeChange", function () { var current = $route.current; var newScope = scope.$new(); // prepare scopes and DOM element $destroy(modalScope); if (current.modal) { modalScope = newScope; // find or create modal container modalElement = element.find(".modals"); if (!modalElement.length) { modalElement = xrxElement("&lt;div class=modals&gt;"); element.append(modalElement); } targetElement = modalElement; } else { $destroy(modalScope); $destroy(stateScope); modalScope = null; stateScope = newScope; targetElement = element; } // append controller and inject { $scope, $routeParams } if (current.controller) { targetElement.data("$ngControllerController", $controller(current.controller, { $routeParams: current.params, $scope: newScope })); } // append Template to DOM and compile targetElement.html(current.template); $compile(targetElement.contents())(newScope); }); // on modal close scope.$on("$routeClose", function () { $destroy(modalScope); modalScope = null; modalElement.remove(); }); } }; }]);</span></span></code> </pre><br><br>  That's all.  Routing is as lightweight as possible, supports work with both real html-templates and their counterparts from &lt;script type = text / ng-template&gt; ... &lt;/ script&gt;, it implements the logic of modal windows we need.  Additionally, it has a syntax similar to ui-router for working and configuring application states. <br><br>  <b>Total:</b> <br>  The ui-router with the size of 28kb was excluded from the application and its own functionality was developed in a minimal form occupying only 1.8kb. <br><br>  The following services and directives have been removed from AngularJS: <br><ul><li>  ng-controller </li><li>  ng-include </li><li>  scriptDirective (puts scripts with text / ng-template type in $ templateCache) </li><li>  $ anchorScroll </li><li>  $ location </li><li>  $ cacheFactory </li><li>  $ templateCache </li></ul><br><br><h4>  <font color="#cc0000">Localization of the application</font> </h4><br>  By the time we started full-scale application optimization, we already had an almost completely localized application in six languages ‚Äã‚Äã‚Äî English, German, French, Italian, Spanish, and Portuguese.  Texts of languages ‚Äã‚Äãwere stored by type key-value in JSON, and were substituted in the application using one-way binding {{:: locale.HELLO_HABR}}.  In loading localization from JSON, everything is quite simple and there is nothing more to optimize: <br><br><pre> <code class="javascript hljs">angular.element(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>).ready(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.$locale(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ angular.bootstrap(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body, [<span class="hljs-string"><span class="hljs-string">"xerox"</span></span>]); }); });</code> </pre><br><br>  Inside the $ locale function, the interface language is defined and the most suitable language is loaded from JSON using the global xhr. <br><br>  But here the stage of real-time localization of the application can and should be optimized, although it uses one-sided binding, but still this is additional work within the digest cycle each time the page is accessed.  In addition, in the localization there are texts with layout that require the use of ng-bind-html, and that in turn also entails additional checks by the $ sanitize service.  The solution is far from the best, but actually it was practically impossible to do anything more convenient until such time as your routing was developed.  With the advent of its own service for loading and caching html-templates $ view, of course, the idea came to use it to localize the application. <br><br>  What did we have to do for this?  In principle, quite a bit: <br><br>  1. In all html templates, the places requiring localization, wrapped with double square brackets, a la, was {{:: locale.HELLO_HABR}}, it became - [[HELLO_HABR]] <br>  2. Since such a combination of square brackets in the application is unique, we can make a regular replace using a regular expression, bypassing the stage of the finished DOM and the whole digest cycle, or more precisely, localizing before the template is compiled and inserted into DOM: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">2.</span></span> xerox.factory(<span class="hljs-string"><span class="hljs-string">"$view"</span></span>, [<span class="hljs-string"><span class="hljs-string">"$http"</span></span>, <span class="hljs-string"><span class="hljs-string">"$locale"</span></span>, <span class="hljs-string"><span class="hljs-string">"$q"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$http, $locale, $q</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> views = {}; <span class="hljs-comment"><span class="hljs-comment">// locale inject RegExp var localeRegExp = /\[\[(\w+)\]\]/mg; // template localization function localization(template) { var match; while (match = localeRegExp.exec(template)) { template = template.replace(match[0], $locale[match[1]]); } return template; } return { ... // put view put: function (url, text) { views[url] = localization(text); } }; }]);</span></span></code> </pre><br><br>  Thus, localization is triggered once at the time of the start of the Angular application, and we already store localized html templates in memory. <br><br>  <b>Total:</b> <br>  Localization of the application is removed from the digest cycle to the stage of application loading. <br>  The following services and directives have been removed from AngularJS: <br><ul><li>  ng-bind </li><li>  ng-bind-html </li><li>  ng-bind-template </li><li>  ng-pluralize </li><li>  $$ sanitizeUri </li><li>  $ sce </li><li>  $ sceDelegate </li></ul><br><br><h4>  <font color="#cc0000">ng-model</font> </h4><br>  The ng-model directive (and the other directives for working with html forms associated with it) is one of the pearls of AngularJS, it‚Äôs an incredible tool that you fall in love with from your first acquaintance.  But few know what is hidden under the hood of the ng-model.  This is actually a very heavy code that tracks events on the element (cut, paste, change, keydown), synchronizes the real value of the model with the displayed value on the screen, checks our model for each change, providing an interface controller for working with the model in our directives. <br><br>  In fact, it turned out that we do not need all these opportunities.  For example, validation is not needed, since even the authorization form, according to all guidelines, displays an error in a modal window only after an unsuccessful server request.  Custom checkboxes, select boxes and lists also do not require verification, and the directives that implement them work with the model in read-write-watch mode.  That is, the checkbox directive looks something like this: <br><br><pre> <code class="javascript hljs">xerox.directive(<span class="hljs-string"><span class="hljs-string">"checkbox"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">"E"</span></span>, <span class="hljs-attr"><span class="hljs-attr">scope</span></span>: { <span class="hljs-attr"><span class="hljs-attr">xrxModel</span></span>: <span class="hljs-string"><span class="hljs-string">"="</span></span> }, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> icon = xrxElement(<span class="hljs-string"><span class="hljs-string">"&lt;div class=checkbox-icon&gt;"</span></span>); element.prepend(icon); icon.on(xrxClick, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!element.attr(xrxDisabled)) { scope.$apply(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ scope.xrxModel = !scope.xrxModel; }); } }); scope.$watch(<span class="hljs-string"><span class="hljs-string">"xrxModel"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ element[value ? <span class="hljs-string"><span class="hljs-string">"addClass"</span></span> : <span class="hljs-string"><span class="hljs-string">"removeClass"</span></span>](<span class="hljs-string"><span class="hljs-string">"checked"</span></span>); }); } }; });</code> </pre><br><br>  The only thing is that we have an authorization form on which we use text inputs.  Therefore, the keyboard directive, like the ng-model, tracks cut, change, paste events, but in a more lightweight form, without starting the validation flywheel and other AngularJS goodies when working with models. <br><br>  A few words about the keyboard, once it has been touched, here is its real look: <br><img src="https://habrastorage.org/files/858/af6/078/858af607820a4b3d849562b72bf7302d.gif"><br><br>  The entire layout is built on the JS side (the directive does not have an html template), from interesting optimizations - the click event is hung on a common container, and not on each button.  This achieves a small, but still savings on event handlers, and consequently, the memory occupied by the application. <br><br>  <b>Total:</b> <br>  The following directives have been removed from AngularJS: <br>  ng-model <br>  ng-list <br>  ng-change <br>  pattern <br>  required <br>  minlength <br>  maxlength <br>  ng-value <br>  ng-model-options <br>  ng-options <br>  ng-init <br>  ng-form <br>  input <br>  form <br>  select <br><br><h4>  <font color="#cc0000">Scroll</font> </h4><br>  A lot of fuel added to the fire to us and scrolling lists: <br><br><img src="https://habrastorage.org/files/b47/211/0cc/b472110cc30b4789ae382c1e0e263ddd.gif"><br><br>  Optimizing the memory consumption, we abandoned ng-repeat (which creates its scope for each element), wrote our lightweight decision and thought that was all, but rendering the list of 38 languages ‚Äã‚Äãpretty much slowed down on the MFP.  In addition, it also worsened that the MFP does not draw a system scroll in the browser and has to draw it with its own means.  We tried many tricks, from using -webkit-scrollbar and ending with custom scrolling through element.scrollTop or -webkit-transform: translate (x, y) using overflow: hidden.  Attempts to understand the principle of rendering the browser also failed.  Either the scrolling itself slowed down, or the list was rebuilt (the user chose a different Source language and needed to rebuild the Target language list, which does not contain the selected Source language in itself). <br>  Having almost lost hope, in one of the next experiments, we noticed that if you insert several elements into the list and change only their innerHTML, the rendering does not slow down, and the scrolling is carried out smoothly and without delays.  In this difficult way, the directive for scrolling appeared in the application, the principle of its operation is simple and tricky at the same time: <br><br>  1. The required number of elements is inserted into the container to fill its entire height, for example, 7 elements of the list. <br>  2. Based on the offset value (indent from the beginning of the data array) and the html template, the innerHTML of our elements are changed. <br>  3. We catch events of clicking on the scrolling arrows or ‚Äúdragging‚Äù (mouseDown-mouseMove-mouseUp) of the slider, calculate the offset, change the position of the slider and return to step 2. <br>  Thus, the sensation of data scrolling is created, although in reality only the internal contents of the same 7 elements of the list change. <br><br>  <b>Total:</b> <br>  The ng-repeat directive was removed from AngularJS, since there was no longer any sense in it, and all the work we needed was performed by a new scroll directive. <br><br><h4>  <font color="#cc0000">Additionally</font> </h4><br>  Additionally, a number of shamanism was produced over AngularJS: <br><ul><li>  the animation functionality has been completely removed ($ animate, $$ rAF); </li><li>  removed directives for working with classes and attributes (ng-class, ng-class-even, etc.); </li><li>  ng-if and ng-switch are replaced by their optimized counterparts ‚Äî display: none is set for html elements that do not satisfy the condition, bypassing the creation of their scope, as in the original directives, and ng-show and ng-hide are completely removed; </li><li>  removed $ filter and $ locale, and all the necessary data is prepared directly in our services on the basis of small samopisny solutions. </li></ul><br>  As a result, all directives were removed from the box from AngularJS, and the list of services acquired the following form: <br><ul><li>  $ compile </li><li>  $ browser </li><li>  $ controller </li><li>  $ exceptionHandler </li><li>  $ interpolate </li><li>  $ log </li><li>  $ parse </li><li>  $ rootScope </li><li>  $ q </li></ul><br>  We did not interfere with the initialization and the cycle of work of AngularJS, but slightly modified jqLite. <br><br><h4>  <font color="#cc0000">findings</font> </h4><br>  Modern development of web applications comes by including rather large third-party solutions for the sake of one small function or feature, thereby increasing the gluttonousness of the application as if by leaps and bounds.  Although, perhaps, this voracity is not so noticeable on desktops and laptops, devices with weak hardware stuffing such applications are digested with difficulty, additionally heating up considerably. <br><br>  We learned from our experience that when the time comes for the necessary optimization, it is quite within its power to make almost any creative development team.  The time spent on all the described optimizations was about 12-15% of the total project development time, which, in principle, is more than enough and we were very pleased with the results achieved. <br><br>  AngularJS is truly a modular framework, and although it does not allow you to configure the required set of functions and download it (as you can do with jQuery UI, for example), we did not experience any discomfort when we exclude directives and services that we don‚Äôt need from AngularJS.  It is a modular approach to application development that allows for virtually painless large-scale optimization and refactoring. <br><br>  And yet I want to believe that such optimization is carried out not only forcedly, but also as part of caring for the end users of the system and the entire development team, and, perhaps, just on the wave of unrestrained enthusiasm. <br><br>  Thanks to <a href="http://www.simbirsoft.com/">SimbirSoft</a> specialists <a href="http://www.simbirsoft.com/">for</a> their active participation in the work on the project. </div><p>Source: <a href="https://habr.com/ru/post/302960/">https://habr.com/ru/post/302960/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302950/index.html">C # client generation for Wargaming API</a></li>
<li><a href="../302952/index.html">20 most notable events in the history of backup and recovery</a></li>
<li><a href="../302954/index.html">Reduce the pain in the navigation of the application on Yii2</a></li>
<li><a href="../302956/index.html">Unicast multicast traffic routing</a></li>
<li><a href="../302958/index.html">Pitfalls when using Linked Server</a></li>
<li><a href="../302962/index.html">Delimobil agreement. We abstract and divide</a></li>
<li><a href="../302964/index.html">Documentation - the basis of the game</a></li>
<li><a href="../302966/index.html">Intel Media SDK 2016 R2 - what's new?</a></li>
<li><a href="../302968/index.html">D3.js. Graph visualization</a></li>
<li><a href="../302970/index.html">Interview with Andrei Svetlov about the Python language and not only</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>