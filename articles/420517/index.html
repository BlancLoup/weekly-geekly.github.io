<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementation of integer FFT on the FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 Once customers asked me if I had any integer FFT in my projects, to which I always replied that it was already done by others in the form of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementation of integer FFT on the FPGA</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  Once customers asked me if I had any integer FFT in my projects, to which I always replied that it was <u>already done by others</u> in the form of ready-made, albeit crooked, but free IP cores (Altera / Xilinx) - take and use.  However, these kernels are <b>not optimal</b> , possess a set of "features" and require further refinement.  In this connection, having gone to the next planned vacation, which I did not want to spend foolishly, I started to implement a configurable kernel of the integer FFT. <br><br><img src="https://habrastorage.org/webt/rn/s4/d1/rns4d1s48360ir8tjj1pwu7qcee.png"><br>  <sub><i>KDPV (process of debugging data overflow errors)</i></sub> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the article I want to tell you what ways and means implemented mathematical operations when calculating the fast Fourier transform in the integer format on modern FPGA crystals.  The basis of any FFT is the node, which is called "butterfly".  In a butterfly, mathematical actions are realized - addition, multiplication and subtraction.  It is about the implementation of the "butterfly" and its completed nodes that the story will go first.  Based on the current FPGA family of Xilinx firms - these are the Ultrascale and Ultrascale + series, as well as the older 6- (Virtex) and 7- (Artix, Kintex, Virtex) series are affected.  Older series in modern projects are not of interest in 2018.  The purpose of the article is to reveal the implementation features of custom cores of digital signal processing using the example of an FFT. <br><a name="habracut"></a><br><h3>  Introduction </h3><br>  It's no secret that the FFT algorithms have become firmly established in the life of digital signal processing engineers, and therefore, this tool is needed all the time.  Leading FPGA manufacturers, such as Altera / Xilinx, already have flexible, configurable FFT / IFFT cores, but they have a number of limitations and features, and therefore I have often had to use my own experiences.  So this time I had to implement the FFT in the integer format according to the Radix-2 scheme on the FPGA.  In <a href="https://habr.com/post/322728/">my last article, I already did a</a> floating-point <a href="https://habr.com/post/322728/">FFT</a> , and from there you know that the algorithm with double parallelism is used to implement the FFT, that is, the <b>core can process two complex samples at the same frequency</b> .  This is a key feature of the FFT, which is not found in the ready-made Xilinx FFT cores. <br><br>  <i>Example:</i> it is required to develop an FFT node that performs continuous operation of the input stream of complex numbers at a frequency of 800 MHz.  The core from Xilinx does not pull this (actually achievable processing clock frequencies in modern FPGAs are about 300-400 MHz), or it will require to somehow decimate the input stream.  The custom kernel allows, without prior intervention, clocking two input samples at 400 MHz instead of one reference at 800 MHz.  Another <u>minus of the Xilinx FFT core is related to the inability to receive the input stream in a bit-reverse order</u> .  In this connection, an enormous resource of memory of the FPGA crystal is spent for rearranging data into a normal order.  For the tasks of fast convolution of signals, when two FFT nodes are located one after another, this can be a critical moment, that is, the task simply does not fall into the selected FPGA chip.  Custom FFT core allows you to receive data in the normal order, and output - in a bit-reverse, and the inverse FFT core - on the contrary, receives data in a bit-reverse order, and gives in the normal.  Two buffers are saved at once for data permutation !!! <br><br>  Since most of the material of this article could <a href="https://habr.com/post/322728/">intersect with the previous one</a> , I decided to focus on uncovering the topic of mathematical operations in an integer format on FPGA for the implementation of FFT. <br><br><h3>  FFT core parameters </h3><br><ul><li>  <i>NFFT</i> - the number of butterflies (length of the FFT), </li><li>  <i>DATA_WIDTH</i> - input data width (4-32), </li><li>  <i>TWDL_WIDTH</i> - the width of the turning factors (8-27). </li><li>  <i>SERIES</i> - sets the FPGA family on which the FFT is implemented (‚ÄúNEW‚Äù - Ultrascale, ‚ÄúOLD‚Äù - 6/7 Xilinx FPGA series). </li></ul><br><img src="https://habrastorage.org/webt/jr/ko/rp/jrkorpz6jkzl7tiltyajcgy_2ns.png"><br><br>  Like any other links in the circuit, the FFT has input control ports ‚Äî a clock signal and a reset, as well as input and output data ports.  In addition, the USE_FLY signal is used in the core, which allows you to dynamically turn off FFT butterflies for debugging processes or to view the original input stream. <br><br>  The table below shows the amount of FPGA resources occupied depending on the NFFT FFT length for DATA_WIDTH = 16 and two digits TWDL_WIDTH = 16 and 24 bits. <br><br><img src="https://habrastorage.org/webt/12/cg/5d/12cg5dao_i8ihsv3-_0bqjufmgy.png"><br><br>  The kernel with NFFT = 64K stably operates at a processing frequency <b>FREQ = 375 MHz</b> on a Kintex-7 (410T) chip. <br><br><h3>  Project structure </h3><br><br>  A schematic graph of the FFT node is shown in the following figure: <br><img src="https://habrastorage.org/webt/af/4t/zx/af4tzxcjc6sltju9ldyi8clctz8.png"><br><br>  For the convenience of understanding the features of certain components, here is a list of project files and a brief description in a hierarchical order: <br><ul><li>  <b>FFT cores:</b> <br><ul><li>  <i>int_fftNk</i> - FFT node, Radix-2 circuit, frequency decimation (DIF), input stream - normal, output - bit-reverse. </li><li>  <i>int_ifftNk</i> - <i>OBPF</i> node, Radix-2 scheme, time decimation (DIT), input stream - bit-reverse, output - normal. </li></ul></li><li>  <b>Butterflies:</b> <br><br><ul><li>  <i>int_dif2_fly</i> - Radix-2 butterfly, frequency decimation, </li><li>  <i>int_dit2_fly</i> - Radix-2 butterfly, time decimation, </li></ul></li><li>  <b>Complex multipliers:</b> <br><br><ul><li>  <i>int_cmult_dsp48</i> - common configurable multiplier, includes: </li><li>  <i>int_cmult18x25_dsp48</i> - a multiplier for small data digits and turning factors, </li><li>  <i>int_cmult_dbl18_dsp48</i> - doubled multiplier, the width of the turning factors to 18 bits, </li><li>  <i>int_cmult_dbl35_dsp48</i> - doubled multiplier, the width of the turning factors to 25 * bit, </li><li>  <i>int_cmult_trpl18_dsp48</i> - the triple multiplier, the width of the turning factors to 18 bits, </li><li>  <i>int_cmult_trpl52_dsp48</i> - the triple multiplier, the width of the turning factors is up to 25 * bits, </li></ul></li><li>  <b>Multipliers:</b> <br><br><ul><li>  <i>mlt42x18_dsp48e1</i> - a multiplier with operand <i>widths</i> up to 42 and 18 bits based on DSP48E1, </li><li>  <i>mlt59x18_dsp48e1</i> - a multiplier with operand <i>sizes</i> up to 59 and 18 bits based on DSP48E1, </li><li>  <i>mlt35x25_dsp48e1</i> - a multiplier with operand <i>sizes</i> up to 35 and 25 bits based on DSP48E1, </li><li>  <i>mlt52x25_dsp48e1</i> - a multiplier with the resolution of the operands of up to 52 and 25 bits based on DSP48E1, </li><li>  <i>mlt44x18_dsp48e2</i> - a multiplier with operands of up to 44 and 18 bits based on DSP48E2, </li><li>  <i>mlt61x18_dsp48e2</i> - a multiplier with operand <i>widths</i> up to 61 and 18 bits based on DSP48E2, </li><li>  <i>mlt35x27_dsp48e2</i> - a multiplier with operand <i>sizes</i> up to 35 and 27 bits based on DSP48E2, </li><li>  <i>mlt52x27_dsp48e2</i> is a multiplier with operand <i>widths</i> up to 52 and 27 bits based on DSP48E2. </li></ul></li><li>  <b>Adder:</b> <br><br><ul><li>  <i>int_addsub_dsp48</i> - universal adder, operand width up to 96 bits. </li></ul></li><li>  <b>Delay lines:</b> <br><br><ul><li>  <i>int_delay_line</i> - baseline delay line, provides data <i>swapping</i> between butterflies, </li><li>  <i>int_align_fft</i> - alignment of input data and turning factors at the input of the FFT butterfly, </li><li>  <i>int_align_fft</i> - alignment of the input data and the turning factors at the input of the IFFT butterfly, </li></ul></li><li>  <b>Turning factors:</b> <br><br><ul><li>  <i>rom_twiddle_int</i> is a generator of turning factors, with a certain length, the FFT counts the coefficients on the basis of DSP FPGA cells, </li><li>  <i>row_twiddle_tay</i> - the turning factors generator using the Taylor series (NFFT&gt; 2K) **. </li></ul></li><li>  <b>Data buffer:</b> <br><br><ul><li>  <i>inbuf_half_path</i> is the input buffer, receives the stream in the normal mode and outputs two sequences of samples shifted by half the FFT length ***, </li><li>  <i>outbuf_half_path</i> - output buffer, collects two sequences and outputs one continuous equal to the length of the FFT, </li><li>  <i>iobuf_flow_int2</i> - the buffer operates in two modes: it receives the stream in the Interleave-2 mode and provides two sequences shifted by half the length of the FFT.  Or vice versa, depending on the ‚ÄúBITREV‚Äù option. </li><li>  <i>int_bitrev_ord</i> is a simple data converter from natural order to bit-reverse. </li></ul></li></ul><br>  <i>* - for DSP48E1: 25 bits, for DSP48E2 - 27 bits.</i> <br>  <i>** - from a certain stage of the FFT, you can use a fixed amount of block memory to store the turning coefficients, and calculate the intermediate coefficients using DSP48 nodes using the Taylor formula to the first derivative.</i>  <i>Due to the fact that the memory resource is more important for the FFT, we can safely sacrifice the computing blocks for the sake of memory.</i> <i><br></i>  <i>*** - input buffer and delay lines - make a significant contribution to the amount of FPGA memory resources</i> <br><br>  <b>"Butterfly"</b> <br><br>  Anyone who has encountered the Fourier transform algorithm at least once knows that the basis of this algorithm is an elementary operation - the ‚Äúbutterfly‚Äù.  It converts the input stream by multiplying the input data by the twiddle factor.  For FFT, there are two classic conversion schemes - frequency decimation (DIF, decimation-in-frequency) and time decimation (DIT, decimation-in-time).  The DIT algorithm is characterized by splitting the input sequence into two half-length sequences, and for the DIF algorithm - into two sequences of even and odd samples with a duration of NFFT.  In addition, these algorithms are different mathematical operations for the operation "butterfly". <br><br><img src="https://habrastorage.org/webt/ka/d9/hr/kad9hr8dktrs2l7jhb9iq3lm6em.png"><br><br>  <i>A, B</i> - input pairs of complex samples, <br>  <i>X, Y</i> - output pairs of complex samples, <br>  <i>W</i> - complex turning factors. <br><br>  Since the input data are complex values, the butterfly requires one complex multiplier (4 multiplication operations and 2 addition operations) and two complex adders (4 addition operations).  This is the whole mathematical basis that must be implemented on the FPGA. <br><br><h3>  Multiplier </h3><br>  It should be noted that all mathematical operations on FPGA are often performed in additional code (2's complement).  The FPGA multiplier can be implemented in two ways - on logic, using triggers and LUT tables, or on special DSP48 calculation blocks, which have long been firmly incorporated into all modern FPGAs.  On logical blocks, multiplication is implemented using the Bout algorithm or its modifications; it occupies a decent amount of logical resources and does not always satisfy the time constraints at high frequencies of data processing.  In this regard, multipliers on the FPGA in modern projects are almost always designed on the basis of DSP48 nodes and only occasionally on logic.  The DSP48 node is a complex, complete cell that implements mathematical and logical functions.  Basic operations: multiplication, addition, subtraction, accumulation, counter, logical operations (XOR, NAND, AND, OR, NOR), squaring, comparison of numbers, shift, etc.  The following figure shows the DSP48E2 cell for the Xilinx Ultrascale + FPGA family. <br><br><img src="https://habrastorage.org/webt/rz/_w/bu/rz_wbuxd3sx1d1llz0psh-8tt1e.png"><br><br>  By uncomplicated configuration of input ports, computing operations at the nodes and setting delays inside the node, you can make a high-speed mathematical data thresher. <br>  Note that all top FPGA vendors in the design environment have standard and free IP cores for calculating mathematical functions based on the DSP48 node.  They allow you to calculate primitive mathematical functions and expose various delays at the input and output of the node.  In Xilinx, this is the IP-Core multiplier (ver. 12.0, 2018), which allows you to configure the multiplier to any input data width from 2 to 64 bits.  In addition, you can specify the way to implement a multiplier - on logical resources or embedded DSP48 primitives. <br><br>  <b>Estimate how much logic the multiplier eats</b> with the input data width on ports A and B = 64 bits.  If you use the DSP48 nodes, then they will need only 16. <br><br><img src="https://habrastorage.org/webt/r5/_e/pb/r5_epbvkf-45ayqoi8jebye_rcu.png"><br><br>  The main limitation imposed on the DSP48 cells is the input data width.  In the DSP48E1 node, which is the base cell of the Xilinx 6 and 7 series FPGAs, the input ports for multiplication are: ‚ÄúA‚Äù - 25 bits, ‚ÄúB‚Äù - 18 - bits, Therefore, the result of the multiplication is a 43-bit number.  For the Xilinx Ultrascale and Ultrascale + family, the node has undergone several changes, in particular, the capacity of the first port has grown by two bits: ‚ÄúA‚Äù - 27 bits, ‚ÄúB‚Äù - 18 - bits.  In addition, the node itself is called DSP48E2. <br><br>  In order not to be tied to a specific family and FPGA chip, to ensure ‚Äúsource code purity‚Äù, and to take into account all possible bit widths of input data, it was decided to design its own set of multipliers.  This will allow for the most efficient implementation of complex multipliers for FFT ‚Äúbutterflies‚Äù, namely, multipliers and an adder-subtractor based on DSP48 blocks.  The first input of the multiplier is the input data, the second input of the multiplier is the turning factors (the harmonic signal from the memory).  A set of multipliers is implemented using the built-in UNISIM library, from which you need to connect the DSP48E1 and DSP48E2 primitives for further use in the project.  A set of multipliers is presented in the table.  It should be noted that: <br><br><ul><li>  The operation of multiplying numbers leads to an increase in the digit of the product as the sum of the digits of the operands. </li><li>  Each of the multipliers 25x18 and 27x18 are duplicated, in fact - this is one component for different families. </li><li>  The greater the stage of parallelism of the operation - the greater the delay in the calculation and the greater the amount of resources occupied. </li><li>  With a smaller bit width at the input ‚ÄúB‚Äù, it is possible to realize multipliers with a higher bit width at another input. </li><li>  The main limitation in increasing the bit depth is the ‚ÄúB‚Äù port (the real port of the DSP48 primitive) and the internal shift register to 17-bit. </li></ul><br><img src="https://habrastorage.org/webt/aw/ma/p9/awmap93marfh0kvrj8loqdrekoo.png"><br><br>  A further increase in bit depth is not of interest within the framework of the task, for the reasons described below: <br><br><h3>  The width of the turning factors </h3><br>  It is known that the greater the bit depth of the harmonic signal - the more accurately the number appears (the more signs in the fractional part).  But the port size is B &lt;25 bits due to the fact that for turning factors in the FFT nodes of this capacity is enough to ensure high-quality multiplication of the input stream with harmonic signal elements in the ‚Äúbutterflies‚Äù (for any real attainable FFT lengths on modern FPGAs).  The typical value of the bitness of the turning coefficients in the tasks I implement is equal to 16 bits, 24 less often, 32 never. <br><br><h3>  The width of the input samples </h3><br>  The data width of the typical reception and registration nodes (ADC, DAC) is not great - from 8 to 16 bits, and rarely - 24 or 32 bits.  Moreover, in the latter case, it is more efficient to use the floating-point data format according to the IEEE-754 standard.  On the other hand, each ‚Äúbutterfly‚Äù stage in the FFT adds one bit of data to the output samples due to the execution of mathematical operations.  For example, for a length of NFFT = 1024, log2 (NFFT) = 10 butterflies are used. <br><br>  Consequently, the output bit depth will be ten bits greater than the input, WOUT = WIN + 10. In general, the formula looks like this: <br><br>  WOUT = WIN + log2 (NFFT); <br><br>  Example: <br><br>  The width of the input stream WIN = 32 bits <br>  The width of the turning factors TWD = 27, <br>  The port ‚ÄúA‚Äù width from the list of implemented multipliers in this article does not exceed 52 bits.  This means that the maximum number of FFT butterflies = 52-32 = 20. That is, it is possible to implement an FFT of up to 2 ^ 20 = 1M samples.  (However, in practice, direct means is impossible due to the limited resources of even the most powerful FPGA crystals, but this relates to another topic and will not be considered in the article). <br><br>  As you can see, this is one of the main reasons why I did not implement multipliers with a higher input port capacity.  <b>The used multipliers cover the full range of required values ‚Äã‚Äãof the</b> input data <b>width</b> and the turning factors for the task of calculating the integer FFT.  In all other cases, you can use the <a href="https://habr.com/post/322728/"><b>floating-point FFT</b></a> calculation! <br><br><h3>  The implementation of the "wide" multiplier </h3><br>  Based on a simple example of multiplying two numbers that do not fit into the width of a standard DSP48 node, I will show how you can implement a wide data multiplier.  The following figure shows its block diagram.  The multiplier implements the multiplication of two signed numbers in the additional code, the width of the first operand X is 42 bits, the second Y is 18 bits.  It contains two DSP48E2 nodes.  To align the delays in the top node, two registers are used.  This is done for the reason that in the upper adder you need to correctly add the numbers from the upper and lower nodes of the DSP48.  Lower adder is not actually used.  At the output of the lower node, there is an additional delay in the product to align the output number with time.  The total delay is 4 cycles. <br><br><img src="https://habrastorage.org/webt/rp/_t/he/rp_the-qaroc7pgzedutsbcb-ee.png"><br><br>  The product consists of two components: <br><br><ul><li>  The younger part: <b>P1 = '0' &amp; X [16: 0] * Y [17: 0];</b> </li><li>  The <b>major</b> part: <b>P2 = X [42:17] * Y [17: 0] + (P1 &gt;&gt; 17);</b> </li></ul><br><h3>  Adder </h3><br>  Similar to a multiplier, an adder can be built on logical resources using a carry chain, or on DSP48 blocks.  To achieve maximum throughput, the second method is preferred.  One DSP48 primitive allows the addition operation to 48 bits, two nodes up to 96 bits.  For the realizable task such digit capacity is quite enough.  In addition, the DSP48 primitive has a special mode ‚ÄúSIMD MODE‚Äù, which parallelizes the built-in 48-bit ALU for several operations with different data of small bitness.  That is, in the ONE mode, a full bit grid of 48 bits and two operands is used, and in the TWO mode, the bit grid is divided into several parallel streams of 24 bits each (4 operands).  This mode, using only one adder, helps to reduce the amount of FPGA crystal resources occupied at small digits of the input samples (in the first stages of the calculation). <br><br><h3>  The increase in data width </h3><br>  The operation of <b>multiplying</b> two numbers with digit capacity N and M in the binary additional code leads to an increase in the output digit capacity to <b>P = N + M.</b> <br><br>  Example: for multiplying three-bit numbers, N = M = 3, the maximum positive number is +3 = <i>(011) <sub>2</sub></i> , and the most negative number is 4 = <i>(100) <sub>2</sub></i> .  The high bit is responsible for the sign of the number.  Therefore, the maximum possible number when multiplying is +16 = <i>(010000) <sub>2</sub></i> , which is formed as a result of multiplying the two most negative numbers -4.  The bit width of the output data is equal to the sum of the input bits P = N + M = 6 bits. <br><br>  The operation of <b>adding</b> two numbers with digit capacity N and M in the binary additional code leads to an increase in the output digit capacity by one bit. <br><br>  Example: we add two positive numbers, N = M = 3, the maximum positive number is 3 = <i>(011) <sub>2</sub></i> , and the maximum negative number is 4 = <i>(100) <sub>2</sub></i> .  The high bit is responsible for the sign of the number.  Therefore, the maximum positive number is 6 = <i>(0110) <sub>2</sub></i> , and the maximum negative number is -8 = <i>(1000) <sub>2</sub></i> .  The bit width of the output is increased by one bit. <br><br><h3>  Algorithm Considerations </h3><br>  <i><b>Truncation truncation from the top:</b></i> <br>  To minimize FPGA resources in the FFT algorithm, it was decided to never use the maximum possible negative number for the turning factors when multiplying the data in the butterfly.  This amendment does not contribute to the outcome.  For example, when using the 16-bit representation of the turning factors, the minimum number is -32768 = 0x8000, and the following number is -32767 = 0x8001.  The error in replacing the most negative number with the nearest neighboring value will be <b>~ 0.003%</b> and is fully acceptable for the implementation of the task. <br><br>  By removing the minimum number in the product of two numbers, at each iteration it is possible to reduce one unused leading digit.  Example: data - 4 = (100) <sub>2</sub> , coefficient +3 = (011) <sub>2</sub> .  The result of the multiplication = -12 = (110100) <sub>2</sub> .  The fifth bit can be discarded, because  it duplicates the neighboring, fourth, sign bit. <br><br>  <i><b>Truncation bottom:</b></i> <br><br>  Obviously, multiplying the input signal for a harmonic effect in a ‚Äúbutterfly‚Äù does not require pulling the output bit into the next butterflies, but rounding or truncation is required.  The rotating multipliers are presented in a convenient M-bit format, but in reality this is the usual sine and cosine normalized to one.  That is, the number 0x8000 = -1, and the number 0x7FFF = +1.  Therefore, the result of the multiplication is necessarily truncated to the original data width (that is, the M bits from the turning factors are truncated below).  In all implementations of FFT, as I have seen, the turning factors are normalized to 1 in one way or another.  Therefore, from the result of the multiplication it is necessary to take the bits in the following grid [N + M-1-1: M-1].  The most significant bit is not used (we subtract an additional 1), the least significant ones are truncated. <br><br>  Adding / subtracting data in butterfly operations is in no way minimized, and only this operation contributes to the <b>increase</b> in the <b>output data by one bit at each stage of the calculation</b> . <br><br>  Note that at the first stage of the FFT DIT algorithm or at the last stage of the FFT DIF algorithm, the data must be multiplied by the turning factor with the zero index W0 = {Re, Im} = {1, 0}.  Due to the fact that multiplication by one and zero is a primitive operation, they can not be executed.  In this case, the operation of complex multiplication is not required at all: the real and imaginary components undergo a "turn" without any changes.  In the second stage, two coefficients are used: W0 = {Re, Im} = {1, 0} and W1 = {Re, Im} = {0, -1}.  Similarly, operations can be reduced to elementary transformations and a multiplexer can be used to select the output sample.  This allows you to significantly save DSP48 blocks on the first two butterflies. <br><br>  The complex multiplier is constructed in the same way - on the basis of multipliers and adder-subtractor, however, for some variants of the input data width, additional resources will not be needed, which will be discussed below. <br><br>  The input buffer and delay lines and cross-switches are similar to those described in the previous article.  The rolling multipliers became integer with configurable bit depth.  For the rest, there is no global change in the design of the FFT core. <br><br><h3>  Features of the FFT core INT_FFTK </h3><br><ul><li>  Fully pipelined data processing circuit. </li><li>  NFFT transform length = 8-512K points. </li><li>  Flexible adjustment of NFFT conversion length. </li><li>  Integer format of input data, bit width is configured. </li><li>  Integer format of the turning factors, the digit capacity is configured. </li><li>  Compact storage of turning factors through expansion in a Taylor series to the first derivative. </li><li>  The growth of digit capacity at each stage of computation and at the output of the core! </li><li>  Storage of a quarter of a period of coefficients to save crystal resources. </li><li>  FFT: input data - in the direct order, at the output in binary inverse. </li><li>  OBPF: input data in binary-inverse order, output - in the forward. </li><li>  Conveyor processing scheme with double parallelism.  Radix-2. </li><li>  The minimum non-breaking data burst is NFFT samples *. </li><li>  High computation speed and small amount of resources. </li><li>  Realization on the last FPGA crystals (Virtex-6, 7-Series, Ultrascale). </li><li>  Kernel frequency <b>~ 375MHz</b> at Kintex-7 </li><li>  Description Language - VHDL. </li><li>  No need for a bitreverse transform operation for a bunch of FFT + OBPF. </li><li>  Open Source project without the inclusion of third-party IP-Cores. </li></ul><br><h3>  Source </h3><br>  The source code for the FFT INTFFTK kernel on VHDL (including basic operations and a set of multipliers) and Matlab / Octave m-scripts <b><a href="https://github.com/capitanov/intfftk">are available in my github profile</a></b> . <br><br><h3>  Conclusion </h3><br>  In the course of development, a new core FFT was designed, which provides greater performance compared to analogues.  A bundle of FFT and OBPF cores does not require conversion to the natural order, and the maximum conversion length is limited only by the FPGA resources.  Double parallelism allows processing of doubled frequency input streams, which IP-CORE Xilinx cannot do.  The resolution at the output of the integer FFT increases linearly depending on the number of conversion stages. <br><br>  In the last article I wrote about future plans: Radix-4 FFT cores, Radix-8, Ultra-Long FFT for many millions of points, FFT-FP32 (in IEEE-754 format).  In short, they are practically all allowed, but for one reason or another, at the moment they cannot be made public.  An exception is the FFT Radix-8 algorithm, which I didn‚Äôt even add to (difficult and lazy). <br><br>  Once again, I thank <a href="https://habr.com/users/dsmv2014/" class="user_link">dsmv2014</a> , who always welcomed my adventurous ideas.  Thanks for attention! <br><br><h3>  UPDATE 2018/08/22 </h3><br><br>  <b>Added the SCALED FFT / IFFT</b> option to the source codes.  On each butterfly truncate LSB is truncated.  Output data width = input bit. <br><br>  In addition, I will give two graphs of the passage of a real signal through the FPGA to show the integral property of the transformation, that is: how truncation affects the result of the accumulation of error at the FFT output.  It is known from theory that as a result of the Fourier transform, the signal-to-noise ratio deteriorates when the input signal is truncated relative to the non-truncated version. <br><br>  Example: The input amplitude swing is 6 bits.  The signal is a sinusoid at 128 PF count.  NFFT = 1024 samples, DATA_WIDTH = 16, TWDL_WIDTH = 16. <br><div class="spoiler">  <b class="spoiler_title">Two graphs of the signal passing through the FFT</b> <div class="spoiler_text">  <b>Fig.</b>  <b>1 The signal-to-noise ratio is weak:</b> <br><img src="https://habrastorage.org/webt/ww/4b/rg/ww4brg3lv-rb1i_52hqggjfv4fw.png"><br><br>  <b>Fig.</b>  <b>2 Signal-to-noise ratio strong:</b> <br><img src="https://habrastorage.org/webt/kx/uh/go/kxuhgoybynu2kiduizld8r6fvmo.png"><br><ul><li>  Pink - UNSCALED FFT, </li><li>  Blue - SCALED FFT. </li></ul><br></div></div><br>  As you can see, the SCALED variant ‚Äúdid not pull out‚Äù the sinusoid from the noise, while the UNSCALED variant showed a good result. </div><p>Source: <a href="https://habr.com/ru/post/420517/">https://habr.com/ru/post/420517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420507/index.html">Reference: global Internet for all and its creators</a></li>
<li><a href="../420509/index.html">Unobvious problem of using assert</a></li>
<li><a href="../420511/index.html">Work as an IT specialist in the Far East - Amur Region</a></li>
<li><a href="../420513/index.html">Pirated copy of paid service in 39 lines of Python code</a></li>
<li><a href="../420515/index.html">Diarization based on GMM-UBM model and MAP adaptation algorithm</a></li>
<li><a href="../420519/index.html">Popularization of science</a></li>
<li><a href="../420521/index.html">Now officially: TLS 1.3 is recognized as standard</a></li>
<li><a href="../420523/index.html">Analysis of binary options charts or how I once again proved to myself that freebies do not exist</a></li>
<li><a href="../420525/index.html">Networks for the harshest. Part fifteen. QoS</a></li>
<li><a href="../420527/index.html">A smile can sound and it is contagious.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>