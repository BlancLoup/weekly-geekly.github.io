<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Recommender systems: You can (not) advise</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="More than six months ago, in search of what to see, I was flipping through the top works. This occupation was repeated many times and had time to get ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Recommender systems: You can (not) advise</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/8b8/df2/345/8b8df23451d4d5b996841832ea115bd0.png"><br>  More than six months ago, in search of what to see, I was flipping through the top works.  This occupation was repeated many times and had time to get bored - I constantly had to miss what I didn‚Äôt want to watch.  Imhonetami did not use before, and did not trust them because of the specificity of the desired works.  On the site where I made searches, it was possible to create my own list of viewed works and rate it, other users' ratings were also available.  Then a brilliant idea came to my mind, as it turned out later to be trivial, using the ratings of other users to make recommendations.  This activity is called collaborative filtering, and the program implementing it is called the Recommender System (PC).  Looking back, I understand that I made a lot of mistakes due to the lack of information and its inaccessibility in this topic, and most importantly, I greatly overestimated the RS.  In this post, I will review the main types and algorithms of the PC, and also try to transfer some of my knowledge and experience. <br><a name="habracut"></a><br>  A recommendation system is a program that provides recommendations based on the data about the user (User) and the item (Item). <br>  Such a system includes the entire process - from receiving information to its presentation to the user. <br>  Every stage is important.  From the information that you will collect depends on what algorithms you can apply.  Good algorithms give good, useful recommendations.  Criteria for evaluating the result allow you to choose the most appropriate algorithms.  And this doesn‚Äôt work if you don‚Äôt correctly present and explain the advice to the user.  I will talk about the algorithms, but do not forget about the rest of the system. <br><br>  Initially, the task seems very simple, but with such an approach it is difficult to create a good system.  It is necessary to carefully approach the construction of the system.  Even the best algorithms do not give very good results, and if you still use clustering algorithms or otherwise worsen the accuracy, then nothing will come out at all.  If you have no experience in this field - get ready for a long study, well, or take the SVD) <br><br><h4>  Test data </h4><br>  On the site where I took the data, a ten-point grading system, about a million users and 30k items. <br>  You can certainly start like me, just take the algorithm and do it, but soon you will realize that this is a bad idea.  After the implementation of several types of systems, questions arise - what type to choose, what have we achieved and can we do better?  To answer these questions, it is necessary to evaluate the results according to some criteria. <br>  It is necessary to create equal conditions for all algorithms - to fix some data with the help of which the algorithms will make their predictions and find some reference result with which you can compare the obtained predictions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Remember that you have to test a lot of algorithms with various options and it is desirable to speed up this process as much as possible.  When we have already chosen the algorithm, we can use all the data, but before that, to speed up the experiments, we need to take only a part of them.  This is also a science, called sampling. <br>  In my case, everything was simple - I already had a lot of user ratings and as the results showed, using 100%, 25% and 10% of the data, the results practically did not change, so I conducted all my experiments by 10%.  Out of 200k users (30kk ratings) with more than five ratings, I randomly selected 30k users (3kk ratings).  I divided each user‚Äôs scores into two sets according to the following algorithm: if the scores are more than ten, I transferred the first six marks (made earlier in time) to the training sample, and the last six scores to the test sample (reference), if less than ten, then to the test one. the sample fell less than estimates. <br><br><h4>  Performance </h4><br>  To conduct a study, it is sometimes necessary to restart the algorithm hundreds of times changing parameters, and what happens if one calculation takes several hours?  That's right - a very strong character in Terraria, but this was not my main goal. <br>  Initially, all algorithms were written in Python, since I know this language best of all, but then I had to rewrite a lot in Java, which worked up to twenty times faster and consumed significantly less OP (mainly due to primitive types and arrays).  Java was chosen only because it is in second place for me on the basis of knowledge.  Perhaps my solution to the problem is not the best (in numpy and scipy, much is implemented natively, there are many specialized frameworks and languages), but it was more interesting for me to do everything myself. <br>  There were also problems with data storage - serialization was not suitable, because sometimes it was necessary to transfer data from python to Java and vice versa, SQL was not convenient, and then I met MongoDB.  She fit me perfectly.  Again, it is likely that this is not the best solution and you may need to use some Hadoop. <br>  The calculation of Java SVD on the full amount of data takes approximately ten minutes and consumes 2 GB of memory.  But for SVD ++ you need to wait about an hour. <br><br><h4>  MS assessment criteria </h4><br>  Before considering the types of MS, you need to talk about the criteria for evaluating the result. <br>  There are many different criteria by which a recommendation system can be evaluated - such as accuracy, novelty, ability to surprise, resistance to attacks, dependence on a cold start, persuasiveness, and so on, but one of the most important is accuracy.  It shows how much our predictions are close to the standard result.  To measure accuracy, there are many methods, I recommend to approach the choice carefully, since much depends on it.  I took one of the most popular methods - the calculation of the root-mean-square error (RMSE).  After the algorithm makes predictions based on the test data, the error can be calculated using the following formula: <br><img src="https://habrastorage.org/storage2/c41/da9/c7f/c41da9c7fc6958c7545348f590e0841c.png"><br>  u - user <br>  i - subject <br>  r - score <br>  p - predicted estimate <br>  T is the total number of test scores <br>  less is better <br><br>  In the future, I will specify the accuracy for the algorithms in rmse. <br>  As practice has shown, less than rmse does not always mean a better algorithm.  I managed to achieve the best rmse results with the timeSVD ++ algorithm - 1.29, for the knowledge-based recommender system 1.41 (where users themselves specified dependencies).  The second system subjectively gave me some very good advice that the first system did not find. <br><br>  More details about the criteria can be found in the Recommendation System Handbook, which I indicated in the literature section. <br><br>  The starting point of my research I took the result which is obtained if the predicted estimate is taken as the average rating of each item - then rmse will be equal to 1.53.  This is done because there is practically nothing to do to obtain this assessment, and very often we already have it.  Let's see how much we can beat this result. <br><br><h4>  PC types </h4><br>  There are four main types of recommender systems: <br><ul><li>  Content-based </li><li>  Collaborative (Collaboration) </li><li>  Knowledge Based (Knowlege base) </li><li>  Hybrid </li></ul><br><br><h4>  Content based PCs </h4><br>  The main steps in this system are: analyze the content of objects and make a set of its criteria (genres, tags, words), find out what criteria the user likes, compare this data and get recommendations.  Criteria unite users and objects in a single coordinate system, and here everything is already simple - if the user and the object point are nearby, then the user will probably like the object. <br>  One of the simplest types of this system is the genre system, here our criteria are genres. <br>  My genre PC showed a result of 1.48, which is slightly better than if you just take the average rating.  But not everything is so bad - the genre system, combined with an average rating of the hybrid system, showed a result of 1.40.  This system is very easy to do. <br><br>  Another type of this PC uses words describing the subject.  On the site where I took the information, there is a section with descriptions of the subject.  I took this data and drove through the tf-idf algorithm (which allows us to determine the similarity of the two texts) and the result was 1.46. <br><br>  As you can see, this type of PC when using basic algorithms does not give much accuracy, but it does have other advantages: high performance, warmer ‚Äúcold start‚Äù, to get the recommendation, only data about the user and objects are needed. <br>  Very often, these systems are used before collaborative filtering, when user ratings are not yet sufficient. <br>  I also recommend reading about this type of PC in the Recommendation System Handbook or <a href="http://habrahabr.ru/company/surfingbird/blog/170081/">on the web</a> . <br><br><h4>  Collaborative PC </h4><br>  These are systems in which recommendations to the user are calculated based on the ratings of other users.  There are many algorithms here, but the most popular ones are User / User (we are looking for neighbors by estimates), Item / Item (we are looking for similarity of objects according to users' estimates) and SVD (self-learning algorithm).  All of them are described on habre - <a href="http://habrahabr.ru/company/surfingbird/blog/139518/">User / User &amp; Item / Item</a> , <a href="http://habrahabr.ru/company/surfingbird/blog/139863/">SVD</a> and in Recommendation System Handbook.  If you decide to create a collaborative PC, I recommend to look at the SVD algorithm, it has the best accuracy, high performance and low memory consumption. <br><br>  When choosing User / User or Item / Item, it is necessary to take into account who is more - users or items.  If there are more users, then Item / Item is preferable, if on the contrary, User / User. <br>  The essence of these algorithms is finding the nearest neighbors.  The proximity of two users or items is determined by similarity metrics (similarity metrics) <br>  The most commonly used cosine metric or Pearson correlation.  On my data, both methods gave similar results. <br><br>  Before I met them, I came up with my own similarity metric: <br>  sim = cross_count / euclid <br>  sim - result <br>  cross_count - the number of intersections <br>  euclid - Euclidean distance <br><br>  On my test data, it showed itself better than a pierson and cosine.  This clearly shows the importance of the number of intersections.  I warn you!  Before using, be sure to test using other metrics, since it is not known what you can do for skyline.  In the future, I will indicate the results without taking into account this metric. <br><br>  For User / User, the best result that I was able to achieve was when using the correlation of the pierson and was equal to 1.49.  This is even worse than the content system.  Mainly due to the fact that the User / User algorithm badly takes into account the number of intersections of the user and gives recommendations based on just a few estimates, this can be overcome by imposing restrictions on the minimum number of intersections. <br><br>  For Item / Item, the best result was also with Pearson - 1.35, which is significantly better than User / User.  The reason is that there are significantly fewer items and when calculating the similarity of two items, they have many intersections of assessments. <br><br>  The first time when I implemented SVD I was delighted with his work and watched with admiration as the error in teaching the model was reduced.  I recommend everyone to implement it for review. <br>  I tried 3 types of SVD: SVD, SVD ++ and timeSVD ++.  I had the following results: <br>  SVD - 1.30 <br>  SVD ++ - 1.29 <br>  timeSVD ++ - 1.29 <br><br>  As you can see, these algorithms allow to achieve the greatest accuracy.  Of these three, I recommend using a simple SVD, as it is the most productive.  Other algorithms take much longer to execute, and accuracy is not significantly increased. <br><br><h4>  Knowledge based PC </h4><br>  These are mainly systems in which knowledge obtained in some way is used to receive recommendations, most often this knowledge is added manually. <br>  On the site where I took the information, users could indicate other similar items to the subject.  Based on this data, I made recommendations as in Item / Item.  The result was 1.41.  As I indicated earlier, many of the recommendations of this system that I liked, could not find collaborative algorithms. <br><br>  More information about these PCs is written in the Recommendation System Handbook. <br><br><h4>  Hybrid PCs </h4><br>  These systems combine several of the above algorithms into one.  There are several types of them, but I didn‚Äôt go deep and I used a simple formula with weights: <br>  res = w1 * a + w2 * b <br>  w1 - weight for algorithm a <br>  w2 - weight for algorithm b <br>  Here the weights are always constant, but it is desirable that they be in the form w = f (x), that is, dependent on some parameters. <br>  Here is a small example for the average rating and the genre algorithm: <br>  w1 w2 - rmse <br>  0.2 0.8 - 1.4330 <br>  0.3 0.7 - 1.4173 <br>  0.4 0.6 - 1.4092 <br>  0.45 0.55 - 1.4083 <br>  0.5 0.5 - 1.4095 <br>  0.6 0.4 - 1.4180 <br>  0.7 0.3 - 1.4347 <br><br>  As you can see, two algorithms with an accuracy of 1.5 made it possible to obtain an accuracy of 1.40 <br><br>  I managed the best result with the hybrid system w1 * (Item / Item) + w2 * (SVD), where w1 = 0.5 and w2 = 0.5.  RMSE decreased by 0.01.  This result does not contradict the fact that the winners of the competition NetFlix - BellKor received.  To win, they used a hybrid of 27 algorithms.  This allowed them to achieve an accuracy of 0.86, and the use of one SVD - 0.88 (the error is two times less than mine because of the fact that they have a 5-point system, I have a 10-point system).  In their case, it was necessary, in my opinion it is completely unjustified, since productivity drops, complexity increases, and the result improvement is not significant. <br>  You can use the best hybrid, which does not greatly complicate the system, but it will slightly increase the accuracy. <br><br>  Pro hybrid systems are also described in detail in the Recommender Systems Handbook. <br><br><h4>  Literature and links </h4><br>  There are three books on MS: <br>  <a href="http://www.amazon.com/Programming-Collective-Intelligence-Building-Applications/dp/0596529325">Programming Collective Intelligence</a> <br>  Already obsolete since it was written before the Netflix Prize.  There are examples on Python. <br><br>  <a href="http://www.amazon.com/Recommender-Systems-Introduction-Dietmar-Jannach/dp/0521493366">Recommender Systems An Introduction</a> <br>  The average level of complexity, more about the PC as a whole.  Some things are written in more detail than in the next book.  There are descriptions of algorithms.  There are no code examples. <br><br>  <a href="http://www.amazon.com/Recommender-Systems-Handbook-Francesco-Ricci/dp/0387858199">Recommender Systems Handbook</a> <br>  The best book about the PC, everything is here.  Algorithms are well described, but without examples of implementation - they will have to be sought on the side. <br><br>  Information on the Internet: <br>  On Habr√© there is a blog <a href="http://habrahabr.ru/company/surfingbird/">Surfingbird</a> , they often write about the PC <br><br>  I strongly recommend BellKor collaborative filtering materials: <br>  <a href="http://www2.research.att.com/~volinsky/netflix/">BellKor</a> - some of this information is published in the Recommender Systems Handbook <br><br>  there is also an opensource library for collaborative filtering, C #: <br>  <a href="http://www.mymedialite.net/">MyMediaLite Recommender System Library</a> <br><br><h4>  Conclusion </h4><br><img src="https://habrastorage.org/storage2/3ed/961/1e1/3ed9611e19ef7a2c26f45eb48c151f76.png"><br><br>  After these experiments, I implemented a system on the basis of SVD, but the recommendations received with its help have a lot of complaints and often miss. <br><br>  After reading a little about MS, at first I thought ‚Äúhow did we live without it before?‚Äù, But later it turned out that even the most advanced methods give poor results and there is no possibility to completely trust them with the choice.  Having conducted a broad study, I was not able to create a system that would be used often, and most importantly - that would be trusted, so I will continue my research. <br><br>  This area is not yet twenty years old, it is actively developing and here is full of tasks where you can express yourself. <br>  This is a very interesting problem, after which I became interested in Data Mining and enrolled in several courses on machine learning, let's see what happens. </div><p>Source: <a href="https://habr.com/ru/post/176549/">https://habr.com/ru/post/176549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../176535/index.html">The digest of interesting news and materials from the world of ayti for the last week No. 52 (April 6 - 12, 2013)</a></li>
<li><a href="../176537/index.html">Five dialers for Android</a></li>
<li><a href="../176539/index.html">Do-it-yourself laser show. Part 2</a></li>
<li><a href="../176541/index.html">Two simple rules to prevent deadlocks on mutexes</a></li>
<li><a href="../176547/index.html">"Russian Public Initiative" under the onslaught of Habr and LJ. [UPD]</a></li>
<li><a href="../176551/index.html">Right now there is a lecture ‚ÄúPractical Font Course‚Äù</a></li>
<li><a href="../176555/index.html">Samsung Galaxy S4 review and comparison with S3</a></li>
<li><a href="../176557/index.html">DARPA created a chip for navigation without GPS</a></li>
<li><a href="../176559/index.html">Basics of Android NDK on the example of working with OpenAL</a></li>
<li><a href="../176561/index.html">Mobilefest 2013 - Short Report</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>