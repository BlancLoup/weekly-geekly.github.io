<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fortran 2003: teach Fortran and C to be friends</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the language of Fortran written a huge amount of code, debugged and worked for many years. I'm not going to raise the question "which is better - F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fortran 2003: teach Fortran and C to be friends</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/936/bbd/d08/936bbdd082844793bca5d4047e16c73c.png"></div><br>  In the language of Fortran written a huge amount of code, debugged and worked for many years.  I'm not going to raise the question "which is better - Fortran or C?".  Each language has its strengths and weaknesses.  But, given the large distribution of the C language, cases of ‚Äúhybrid‚Äù applications are becoming more and more popular in certain circles, when part of the code is written (rather, already written) in the Fortran language, and the other - in C. Here only these languages ‚Äã‚Äãhave certain specificity, about which I partially <a href="http://habrahabr.ru/company/intel/blog/254235/">mentioned</a> , and in order for the application written by us to work correctly, you need to take into account many nuances.  Differences in data types, calling conventions (calling conventions), naming conventions make the task of creating a mixed language application far nontrivial.  It is good that in Fortran 2003 there appeared a whole set of tools specially developed for solving the problem of interoperability of C and Fortran.  By the way, I don‚Äôt remember other languages ‚Äã‚Äãthat would standardize this kind of work - one more ‚Äúplus‚Äù to Fortran for the outstretched ‚Äúhand of friendship‚Äù. <br><a name="habracut"></a><br>  What is this inter-opera and so on?  The term ‚Äúinteroperability‚Äù means the possibility of calling the function C in the Fortran code and vice versa.  In addition, you can use global variables, as well as declare local variables, data structures, and enumerations that have a match in C. The main idea is that everything should work the same in C, as well as in Fortran.  It is worth noting that C means standard C99 (ISO / IEC 9899: 1999).  By the way, the concrete implementation of the Fortran compiler has the right to choose which of the C compilers to be friends with.  In the case of Intel Fortan, this is Microsoft Visual C ++ on Windows and gcc on Linux and OS X. What about Intel C ++?  Since it is compatible with Visual C ++ and gcc, there are no problems with it (as one would expect). <br><br>  Fortran implements support for the very interoperability through the following means: <br><br><ul><li>  Restrictions on data types that can be interoperable </li><li>  BIND construction (C) </li><li>  ISO_C_BINDING module </li><li>  Attribute VALUE </li></ul><br>  One of the main difficulties in developing ‚Äúmixed‚Äù applications is that the types in C and Fortran are different: the concepts of pointers, working with strings, with pointers to functions, and so on.  Yes, and with the basic types are not so simple.  Let's say in C we have types from <i>short int</i> to <i>long long int</i> .  They may or may not have analogues in FORTRAN. <br>  In order for all this to work well, a module appeared in Fortran that is responsible for the ‚Äúfriendship‚Äù of these languages ‚Äã‚Äã- <i>ISO_C_BINDING</i> .  What is there?  A set of tools that allows you to ensure that the data types in Fortran are ‚Äúcorrect‚Äù for working with the code in C. <br>  For example, for the <i>int</i> type we can use the <i>INTEGER (C_INT) type</i> in Fortran, and <i>C_INT</i> is defined in the <i>ISO_C_BINDING</i> module.  In the case of Intel Fortran, the length of the INTEGER is 4 bytes, but in other implementations it is not a fact.  Using a named constant ensures portability. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here are the C objects that may be available to the application in Fortran: <br><br><ul><li>  Numeric types: integer, floating point, complex </li><li>  Boolean types (there are LOGICAL types in Fortran) </li><li>  Strings </li><li>  Structures </li><li>  Pointers </li><li>  Arrays </li><li>  Global variables </li><li>  Functions </li></ul><br>  At the same time, the Fortran types remain old, but we modify them with the help of the interoperable parameter KIND and constants from the module.  This will serve as a kind of "link" between types C and Fortran.  The correspondence between the types can be found in the following table: <table><tbody><tr><th>  Fortran Type </th><th>  KIND parameter </th><th>  Type C </th></tr><tr><th rowspan="6">  INTEGER </th><td>  C_INT </td><td>  int <br>  signed int <br></td></tr><tr><td>  C_SHORT </td><td>  short int <br>  signed short int <br></td></tr><tr><td>  C_LONG </td><td>  long int <br>  signed long int <br></td></tr><tr><td>  C_LONG_LONG </td><td>  long long int <br>  signed long long int <br></td></tr><tr><td>  C_SIGNED_CHAR </td><td>  signed char <br>  unsigned char <br></td></tr><tr><td>  C_SIZE_T </td><td>  size_t <br></td></tr><tr><th rowspan="3">  REAL </th><td>  C_FLOAT </td><td>  float </td></tr><tr><td>  C_DOUBLE </td><td>  double </td></tr><tr><td>  C_LONG_DOUBLE </td><td>  long double </td></tr><tr><th rowspan="3">  COMPLEX </th><td>  C_COMPLEX </td><td>  _Complex </td></tr><tr><td>  C_DOUBLE_COMPLEX </td><td>  double _Complex </td></tr><tr><td>  C_LONG_DOUBLE_COMPLEX </td><td>  long double _Complex </td></tr><tr><th>  LOGICAL </th><td>  C_BOOL </td><td>  _Bool </td></tr><tr><th>  CHARACTER <br></th><td>  C_CHAR </td><td>  char </td></tr></tbody></table>  I want to note that the <i>unsigned int</i> type is not supported in Fortran. <br>  Another feature is that logical types are set to true / false differently in C and Fortran. <br>  If C uses 0 for false and any number other than 0 for true, then in Fortran even numbers are false, odd numbers are true. <br>  Do not forget to use the option -fpscomp logicals (/ fpscomp: logicals on Windows), which changes the rules as in C. <br>  By the way, it connects implicitly if using the option-standard-semantics (/ standard-semantics on Windows) is a highly recommended option when working with the Fortran 2003 standard. <br><br>  Now let's see how everything works with an example.  If we write in Fortran <br><pre><code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">INTEGER</span></span>(KIND=C_LONG) :: I</code> </pre> <br>  The use of <i>KIND = C_LONG</i> guarantees that the variable <i>I</i> will not have problems with the type when it is used in the C code, and there it will be of the type <i>long int</i> (in accordance with the table).  With built-in types, everything is simple - we are looking for the corresponding constant for the <i>KIND</i> in the tablet and it's in the <i>bag</i> .  By the way, since all this functionality is available as a module, then we should connect it using the <i>USE</i> keyword: <br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span>, INTRINSIC :: ISO_C_BINDING</code> </pre><br>  Thus, we will have access to all constants for types from the module.  In order not to clutter up the namespace, it is recommended to limit the scope to only those types that we are actually going to use, like this: <br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span>, INTRINSIC :: ISO_C_BINDING, <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> C_LONG</code> </pre><br>  In addition to the types themselves, there is also a <i>BIND</i> construct (not part of the module ‚Äî part of the Fortran 2003 standard), which tells the Fortran compiler that the corresponding name is an object C. And it can be done explicitly and implicitly.  For example, we have such global variables in C: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_int; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b_long;</code> </pre><br>  And we want to use them correctly in our Fortran code, for example, in a module: <br><pre> <code class="hljs sql">MODULE TEST_BINDING <span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> ISO_C_BINDING !  binding A_INT  a_int <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>(C_INT), BIND(C) :: A_INT !  binding B  b_long <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>(C_LONG) :: B BIND(C, <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>=<span class="hljs-string"><span class="hljs-string">' b_long '</span></span>) :: B <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MODULE</span></span> TEST_BINDING</code> </pre><br>  This "bundle" is needed for objects.  In this example, we will be able to work in Fortran code with the same global variables created in C. If we have a certain function, for example <br><pre> <code class="cpp hljs">Cfunc(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a1, <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> a2);</code> </pre><br>  You can use such data as arguments, and you don‚Äôt need to do <i>BIND</i> : <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">REAL</span></span>(C_FLOAT) :: A1 COMPLEX(C_DOUBLE) :: A2</code> </pre><br>  One of the problems of FORTRAN and C was the differences when working with strings.  Therefore, in order to pass a line to such a function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> in[], </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> out[])</span></span></span></span>;</code> </pre><br>  You need to use <i>KIND = C_CHAR</i> and the character of the end of the line <i>C_NULL_CHAR</i> (analogue of <i>\ 0</i> in Fortran): <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">CHARACTER</span></span>(LEN=<span class="hljs-number"><span class="hljs-number">10</span></span>, KIND=C_CHAR) :: DIGIT_STRING = C_CHAR <span class="hljs-string"><span class="hljs-string">'123456789'</span></span> // C_NULL_CHAR <span class="hljs-type"><span class="hljs-type">CHARACTER</span></span>(KIND=C_CHAR) :: DIGIT_ARR(<span class="hljs-number"><span class="hljs-number">10</span></span>)</code> </pre><br>  And our line from Fortran will be great to ‚Äúbe friends‚Äù with C - you can safely pass to the function! <br>  But the function also needs to be somehow connected with its counterpart from C. This is done in Fortran using interfaces: <br><pre> <code class="hljs pgsql">INTERFACE SUBROUTINE <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">OUT</span></span>), BIND(C) USE ISO_C_BINDING <span class="hljs-type"><span class="hljs-type">CHAR</span></span>(KIND=C_CHAR), DIMENSION(*) :: <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">OUT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> SUBROUTINE <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> INTERFACE</code> </pre><br>  And now we can boldly write <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">CALL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span>(DIGIT_STRING, DIGIT_ARR)</code> </pre><br>  The most interesting thing is working with pointers.  For function with pointers as arguments <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">short</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *a; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *b; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">]; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *d)</span></span></span></span></code> </pre><br>  You can use the following variables in FORTRAN: <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">REAL</span></span>(C_DOUBLE) :: A ! A  *,         <span class="hljs-type"><span class="hljs-type">INTEGER</span></span>(C_INT) :: B, V(<span class="hljs-number"><span class="hljs-number">10</span></span>) ! B    *b  c[] <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span>(C_PTR), <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> :: D !D  *d,      <span class="hljs-type"><span class="hljs-type">void</span></span>*</code> </pre><br><br>  Besides the fact that there is a <i>KIND</i> parameter for <i>pointers</i> , there is also a number of additional features, for example, there is a ‚Äúnull‚Äù pointer <i>C_NULL_PTR</i> , an analogue of the <i>null</i> from C. There are also special functions available. <br><br>  <i>C_F_POINTER</i> associates a Fortran pointer with object C. The syntax of this function is as follows: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">CALL</span></span> C_F_POINTER( CPTR, FPTR [,SHAPE] ) <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span>(C_PTR), INTENT(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>) :: CPTR &lt;type_spec&gt;, POINTER, INTENT(<span class="hljs-keyword"><span class="hljs-keyword">OUT</span></span>) :: FPTR <span class="hljs-type"><span class="hljs-type">INTEGER</span></span>, INTENT(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>), OPTIONAL :: SHAPE</code> </pre><br>  As an input argument to the <i>CPTR, we</i> pass a pointer to an object in C, and at the output we have a Fortran pointer <i>FPTR</i> to this object. <br><br>  <i>C_LOC</i> returns the address of the object C or Fortran: <br><pre> <code class="hljs lisp">C_ADDRESS = C_LOC(<span class="hljs-name"><span class="hljs-name">OBJECT</span></span>)</code> </pre><br><br>  <i>C_ASSOCIATED</i> checks <i>whether</i> our pointer is <i>null</i> or not, and whether it is associated with object C. <br><br>  Derived types also did not stand aside.  For example, such a <i>ctype</i> structure <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, b; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c; } ctype;</code> </pre><br><br>  will work with the FTYPE type: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span>, BIND(C) :: FTYPE <span class="hljs-type"><span class="hljs-type">INTEGER</span></span>(C_INT) :: A, B <span class="hljs-type"><span class="hljs-type">REAL</span></span>(C_FLOAT) :: C <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> FTYPE</code> </pre><br><br>  Of course, to describe in detail all the details of the standard within the framework of the post will not work, but I did not set this goal, but I think that I shed light on how this whole thing works.  Well, the final example, close to reality, which shows how the <i>ISO_C_BINDING</i> module can be used to call functions from both Fortran and C. <br>  Let's start with the example of Fortran, which calls the C function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C_Library_Function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sendbuf, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sendcount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *recvcounts)</span></span></span></span>;</code> </pre><br>  So, we create an interface with the necessary KIND parameters: <br><pre> <code class="hljs pgsql">MODULE FTN_C_2 INTERFACE <span class="hljs-type"><span class="hljs-type">INTEGER</span></span> (C_INT) <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> C_LIBRARY_FUNCTION (SENDBUF, SENDCOUNT, RECVCOUNTS) BIND(C, <span class="hljs-type"><span class="hljs-type">NAME</span></span>=<span class="hljs-string"><span class="hljs-string">'C_LIBRARY_FUNCTION'</span></span>) USE, INTRINSIC :: ISO_C_BINDING IMPLICIT <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> (C_PTR), <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> :: SENDBUF <span class="hljs-type"><span class="hljs-type">INTEGER</span></span> (C_INT), <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> :: SENDCOUNT <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> (C_PTR), <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> :: RECVCOUNTS <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> C_LIBRARY_FUNCTION <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> INTERFACE <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> MODULE FTN_C_2</code> </pre><br>  And now the function call itself: <br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">USE</span></span>, INTRINSIC :: ISO_C_BINDING, <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span>: C_INT, C_FLOAT, C_LOC <span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> FTN_C_2 ... <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> (C_FLOAT), TARGET :: SEND(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> (C_INT) :: SENDCOUNT <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> (C_INT), ALLOCATABLE, TARGET :: RECVCOUNTS(<span class="hljs-number"><span class="hljs-number">100</span></span>) ... <span class="hljs-keyword"><span class="hljs-keyword">ALLOCATE</span></span>( RECVCOUNTS(<span class="hljs-number"><span class="hljs-number">100</span></span>) ) ... <span class="hljs-keyword"><span class="hljs-keyword">CALL</span></span> C_LIBRARY_FUNCTION(C_LOC(SEND), SENDCOUNT, C_LOC(RECVCOUNTS)) ...</code> </pre><br>  And no problems with the names or data types. <br>  On the contrary, if we have the task of calling some Fortran function (a very frequent task), then this module will also help in solving problems here.  If we have the <i>Simulation</i> function: <br><pre> <code class="hljs sql">SUBROUTINE SIMULATION(ALPHA, BETA, GAMMA, DELTA, ARRAYS) BIND(C) <span class="hljs-keyword"><span class="hljs-keyword">USE</span></span>, INTRINSIC :: ISO_C_BINDING IMPLICIT <span class="hljs-keyword"><span class="hljs-keyword">NONE</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> (C_LONG), <span class="hljs-keyword"><span class="hljs-keyword">VALUE</span></span> :: ALPHA <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> (C_DOUBLE), INTENT(INOUT) :: BETA <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> (C_LONG), INTENT(<span class="hljs-keyword"><span class="hljs-keyword">OUT</span></span>) :: GAMMA <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> (C_DOUBLE),<span class="hljs-keyword"><span class="hljs-keyword">DIMENSION</span></span>(*),INTENT(<span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>) :: DELTA <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span>, BIND(C) :: PASS <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> (C_INT) :: LENC, LENF <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> (C_PTR) :: C, F <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> PASS <span class="hljs-keyword"><span class="hljs-keyword">TYPE</span></span> (PASS), INTENT(INOUT) :: ARRAYS <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> (C_FLOAT), ALLOCATABLE, TARGET, <span class="hljs-keyword"><span class="hljs-keyword">SAVE</span></span> :: ETA(:) <span class="hljs-built_in"><span class="hljs-built_in">REAL</span></span> (C_FLOAT), POINTER :: C_ARRAY(:) ... !  C_ARRAY  ,   C <span class="hljs-keyword"><span class="hljs-keyword">CALL</span></span> C_F_POINTER (ARRAYS%C, C_ARRAY, (/ARRAYS%LENC/) ) ... !           ARRAYS%LENF = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ALLOCATE</span></span> (ETA(ARRAYS%LENF)) ARRAYS%F = C_LOC(ETA) ... <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> SUBROUTINE SIMULATION</code> </pre><br>  We declare a structure in C: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pass</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lenc, lenf; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *c, *f;};</code> </pre><br>  And function: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> alpha, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *beta, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *gamma, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> delta[], struct pass *arrays)</span></span></span></span>;</code> </pre><br>  And we can safely call it: <br><pre> <code class="cpp hljs">simulation(alpha, &amp;beta, &amp;gamma, delta, &amp;arrays);</code> </pre><br><br>  That's all.  I think that the use of this feature of the new standard will allow many developers to avoid a large number of problems, and Fortran and C will be more friendly than ever. </div><p>Source: <a href="https://habr.com/ru/post/255305/">https://habr.com/ru/post/255305/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../255285/index.html">The first two weeks of the course Artificial Intelligence CS188.1x or self-learning algorithms AI</a></li>
<li><a href="../255287/index.html">Understanding Web Design Trends</a></li>
<li><a href="../255291/index.html">Wall Street is changing the approach to data centers</a></li>
<li><a href="../255293/index.html">How to make a table cell movable to display additional options in iOS applications</a></li>
<li><a href="../255295/index.html">Bugs. Bugs never change</a></li>
<li><a href="../255307/index.html">HuaQiangBei electronic market in Shenzhen</a></li>
<li><a href="../255309/index.html">QGIS is the main tool for working with spatial information. An overview of thematic resources for beginners.</a></li>
<li><a href="../255311/index.html">Global Education: Russian government scholarship program for study abroad</a></li>
<li><a href="../255315/index.html">AppStore comprehension path or how much experience?</a></li>
<li><a href="../255317/index.html">openEMS is an open source electromagnetic simulator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>