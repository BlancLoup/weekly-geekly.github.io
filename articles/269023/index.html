<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HikariCP - the fastest pool of connections in java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Java recently turned 20 years old. It would seem that today everything is written on java. Any idea, any project, any tool in java? - it is already th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>HikariCP - the fastest pool of connections in java</h1><div class="post__text post__text-html js-mediator-article">  Java recently turned 20 years old.  It would seem that today everything is written on java.  Any idea, any project, any tool in java?  - it is already there.  Especially when it comes to such trivial things as a pool of connections to the database, which is used by millions of developers around the world.  But it was not there!  Meet the - <a href="https://github.com/brettwooldridge/HikariCP">HikariCP</a> project - the fastest connection pool to date in java. <br><br>  HikariCP is another vivid example of the fact that it is always worth to question the effectiveness of some decisions, even if they are used by millions of people and they live for decades.  Hikari is a great example of how micro-optimizations that, individually, can never give you more than 0.00001% gain, all together make it possible to create a very fast and efficient tool. <br><br>  This post is a free and partial translation of the article <a href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole">Down the Rabbit Hole</a> by HikariCP mixed with the flow of my mind. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/e85/844/ff6/e85844ff65dc1fbffeecf8bce31368f8.png" alt="image"><br><br><a name="habracut"></a><br><br><h1>  Down the Rabbit Hole </h1><br><br>  This article is a recipe for our secret sauce.  When you begin to look at all sorts of benchmarks, you, like a normal person, should have a healthy share of skepticism towards them.  When you think about performance and the pool of connections, it's hard to avoid the insidious idea that the pool is the most important part of it.  In fact this is not true.  The number of <i>getConnection ()</i> calls in comparison with other operations of a typical JDBC is quite small.  A huge number of performance improvements are achieved by optimizing wrappers around <i>Connection</i> , <i>Statement</i> , and so on. <br><br>  In order to make HikariCP fast (which it is), we had to dig down to the bytecode level and below.  We used all the tricks we know to help JIT.  We studied the compiled bytecode for each method and even modified the methods to fit the inline limit.  We reduced the number of inheritance levels, limited access to some variables to reduce their scope, and removed any type conversions. <br>  Sometimes, seeing that the method exceeds the inlineing limit, we thought about how to change it in such a way as to get rid of several byte instructions.  For example: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> SQLException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SQLException sqle)</span></span></span><span class="hljs-function"> </span></span>{ String sqlState = sqle.getSQLState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sqlState == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sqle; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sqlState.startsWith(<span class="hljs-string"><span class="hljs-string">"08"</span></span>)) _forceClose = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (SQL_ERRORS.contains(sqlState)) _forceClose = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sqle; }</code> </pre> <br><br>  A fairly simple method that checks if there is a connection loss error.  And now baytkod: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: aload_1 <span class="hljs-number"><span class="hljs-number">1</span></span>: invokevirtual #<span class="hljs-number"><span class="hljs-number">148</span></span> <span class="hljs-comment"><span class="hljs-comment">// Method java/sql/SQLException.getSQLState:()Ljava/lang/String; 4: astore_2 5: aload_2 6: ifnonnull 11 9: aload_1 10: areturn 11: aload_2 12: ldc #154 // String 08 14: invokevirtual #156 // Method java/lang/String.startsWith:(Ljava/lang/String;)Z 17: ifeq 28 20: aload_0 21: iconst_1 22: putfield #144 // Field _forceClose:Z 25: goto 45 28: getstatic #41 // Field SQL_ERRORS:Ljava/util/Set; 31: aload_2 32: invokeinterface #162, 2 // InterfaceMethod java/util/Set.contains:(Ljava/lang/Object;)Z 37: ifeq 45 40: aload_0 41: iconst_1 42: putfield #144 // Field _forceClose:Z 45: aload_1 46: return</span></span></code> </pre><br><br>  Probably it‚Äôs no secret to anyone that the inlining limit in the Hostpot JVM is 35 bytecode instructions.  Therefore, we paid some attention to this method to shorten it and changed it as follows: <br><br><pre> <code class="java hljs">String sqlState = sqle.getSQLState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sqlState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (sqlState.startsWith(<span class="hljs-string"><span class="hljs-string">"08"</span></span>) || SQL_ERRORS.contains(sqlState))) _forceClose = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sqle;</code> </pre><br><br>  It turned out pretty close to the limit, but still 36 instructions.  Therefore, we did this: <br><br><pre> <code class="java hljs">String sqlState = sqle.getSQLState(); _forceClose |= (sqlState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; (sqlState.startsWith(<span class="hljs-string"><span class="hljs-string">"08"</span></span>) || SQL_ERRORS.contains(sqlState))); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sale;</code> </pre><br><br>  It looks easier.  Is not it?  In fact, this code is worse than the previous one - 45 instructions. <br>  One more attempt: <br><br><pre> <code class="java hljs">String sqlState = sqle.getSQLState(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sqlState != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) _forceClose |= sqlState.startsWith(<span class="hljs-string"><span class="hljs-string">"08"</span></span>) | SQL_ERRORS.contains(sqlState); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sqle;</code> </pre><br><br>  Note the use of unary OR (|).  This is a great example of sacrificing theoretical performance (as in theory || it will be faster) for the sake of real performance (as the method will now be inline).  Result bytecode: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">0</span></span>: aload_1 <span class="hljs-number"><span class="hljs-number">1</span></span>: invokevirtual #<span class="hljs-number"><span class="hljs-number">153</span></span> <span class="hljs-comment"><span class="hljs-comment">// Method java/sql/SQLException.getSQLState:()Ljava/lang/String; 4: astore_2 5: aload_2 6: ifnull 34 9: aload_0 10: dup 11: getfield #149 // Field forceClose:Z 14: aload_2 15: ldc #157 // String 08 17: invokevirtual #159 // Method java/lang/String.startsWith:(Ljava/lang/String;)Z 20: getstatic #37 // Field SQL_ERRORS:Ljava/util/Set; 23: aload_2 24: invokeinterface #165, 2 // InterfaceMethod java/util/Set.contains:(Ljava/lang/Object;)Z 29: ior 30: ior 31: putfield #149 // Field forceClose:Z 34: return</span></span></code> </pre><br><br>  Just below the limit of 35 bytecode instructions.  This is a small method and in fact is not even heavily loaded, but you get the idea.  Small methods not only allow JIT to embed them in code, they also mean fewer actual machine instructions, which increases the amount of code that fits in the processor's L1 cache.  Now multiply all this by the number of such changes in our library and you will understand why HickaryCP is really fast. <br><br><h2>  Micro optimizations </h2><br><br>  HikariCP has a lot of micro optimizations.  Individually, they certainly do not make paintings.  But all together greatly increase the overall performance.  Some of these optimizations are fractions of a microsecond for millions of calls. <br><br><h4>  ArrayList </h4><br><br>  One of the most non-trivial optimizations was deleting the <i>ArrayList &lt;Statement&gt;</i> collection in the <i>ConnectionProxy</i> class, which was used to track open <i>Statement</i> objects.  When <i>Statement is</i> closed, it must be removed from this collection.  Also, if the connection is closed, you need to go through the collection and close any open <i>Statement</i> and after that - clear the collection.  As it is known, <i>ArrayList</i> checks the index ranges for each <i>get (index)</i> call.  But, since we can guarantee the choice of the correct index - this check is superfluous.  Also, the implementation of the <i>remove (Object)</i> method performs a pass from the beginning to the end of the list.  At the same time, the generally accepted pattern in JDBC is either to immediately close <i>Statements</i> after use or in the reverse order of opening (FILO).  For such cases, the passage that begins at the end of the list will be faster.  Therefore, we replaced the <i>ArrayList &lt;Statement&gt;</i> with a <i>FastStatementList</i> in which there is no range check and the removal of elements from the list starts from the end. <br><br><h4>  Slow singleton </h4><br><br>  In order to generate proxies for the <i>Connection</i> , <i>Statement</i> , <i>ResultSet</i> objects, HikariCP initially used the singleton factory.  In the case of, for example, <i>ConnectionProxy,</i> this factory was in the static field <i>PROXY_FACTORY</i> .  And there were several dozens of places in the code that referred to this field. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> PreparedStatement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sql, String[] columnNames)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> PROXY_FACTORY.getProxyPreparedStatement(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, delegate.prepareStatement(sql, columnNames)); }</code> </pre><br><br>  In baytkode, it looked like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> java.sql.<span class="hljs-function"><span class="hljs-function">PreparedStatement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String, java.lang.String[])</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> java.sql.SQLException</span></span>; flags: ACC_PRIVATE, ACC_FINAL Code: stack=<span class="hljs-number"><span class="hljs-number">5</span></span>, locals=<span class="hljs-number"><span class="hljs-number">3</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: getstatic #<span class="hljs-number"><span class="hljs-number">59</span></span> <span class="hljs-comment"><span class="hljs-comment">// Field PROXY_FACTORY:Lcom/zaxxer/hikari/proxy/ProxyFactory; 3: aload_0 4: aload_0 5: getfield #3 // Field delegate:Ljava/sql/Connection; 8: aload_1 9: aload_2 10: invokeinterface #74, 3 // InterfaceMethod java/sql/Connection.prepareStatement:(Ljava/lang/String;[Ljava/lang/String;)Ljava/sql/PreparedStatement; 15: invokevirtual #69 // Method com/zaxxer/hikari/proxy/ProxyFactory.getProxyPreparedStatement:(Lcom/zaxxer/hikari/proxy/ConnectionProxy;Ljava/sql/PreparedStatement;)Ljava/sql/PreparedStatement; 18: return</span></span></code> </pre><br><br>  You can see that the <i>getstatic</i> call comes first to get the value of the static field <i>PROXY_FACTORY</i> .  Also note the last <i>invokevirtual</i> call for the <i>getProxyPreparedStatement ()</i> method of the <i>ProxyFactory</i> object. <br>  The optimization was that we removed the singleton factory and replaced it with a class with static methods.  The code began to look like this: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> PreparedStatement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String sql, String[] columnNames)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> SQLException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ProxyFactory.getProxyPreparedStatement(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, delegate.prepareStatement(sql, columnNames)); }</code> </pre><br><br>  Where <i>getProxyPreparedStatement ()</i> is a static method of the <i>ProxyFactory</i> class.  And this is what baytcode looks like: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> java.sql.<span class="hljs-function"><span class="hljs-function">PreparedStatement </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepareStatement</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(java.lang.String, java.lang.String[])</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> java.sql.SQLException</span></span>; flags: ACC_PRIVATE, ACC_FINAL Code: stack=<span class="hljs-number"><span class="hljs-number">4</span></span>, locals=<span class="hljs-number"><span class="hljs-number">3</span></span>, args_size=<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: aload_0 <span class="hljs-number"><span class="hljs-number">1</span></span>: aload_0 <span class="hljs-number"><span class="hljs-number">2</span></span>: getfield #<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">// Field delegate:Ljava/sql/Connection; 5: aload_1 6: aload_2 7: invokeinterface #72, 3 // InterfaceMethod java/sql/Connection.prepareStatement:(Ljava/lang/String;[Ljava/lang/String;)Ljava/sql/PreparedStatement; 12: invokestatic #67 // Method com/zaxxer/hikari/proxy/ProxyFactory.getProxyPreparedStatement:(Lcom/zaxxer/hikari/proxy/ConnectionProxy;Ljava/sql/PreparedStatement;)Ljava/sql/PreparedStatement; 15: areturn</span></span></code> </pre><br><br>  Here you should pay attention to 3 points at once.  The <i>getstatic call</i> no longer <i>exists</i> .  <i>invokevirtual has</i> been replaced by <i>invokestatic</i> , which in turn is better optimized by the virtual machine.  And the last point, which is difficult to see - the size of the stack has decreased from 5 elements to 4.  Since prior to optimization in the case of <i>invokevirtual,</i> the stack should also <i>receive a</i> reference to the <i>ProxyFactory</i> object <i>itself</i> .  This also means an extra pop instruction for getting this link from the stack when <i>getProxyPreparedStatement () is</i> called.  In general, if we sum up, we got rid of access to the static field, removed the extra push and pop operations on the stack and made the method call more suitable for JIT optimization. <br><br>  The end. <br><br>  Full original <a href="https://github.com/brettwooldridge/HikariCP/wiki/Down-the-Rabbit-Hole">Down the Rabbit Hole</a> . <br><br>  UPDATE: <br>  In the comments part of the article ‚ÄúSlow Singleton‚Äù caused a lot of discussion.  <a href="http://habrahabr.ru/users/apangin/" class="user_link">apangin</a> argues that all these micro optimizations are meaningless and do not give any gain.  The <a href="http://habrahabr.ru/post/269023/">comment</a> is a simple benchmark of the same value <i>invokeVirtual</i> and <i>invokeStatic</i> .  And <a href="http://habrahabr.ru/post/269023/">then the</a> benchmark pool of classmates connections, which is supposedly 4 times faster than HickaryCP.  To which the author HickaryCP gives the <a href="https://github.com/brettwooldridge/HikariCP/issues/464">following answer</a> : <br><br>  First I would like to comment on @odnoklassniki comment that their pool is 4x faster.  I have added their pool.  Here is the result vs.  HikariCP: <br><br><pre> <code class="java hljs">./benchmark.sh clean quick -p pool=one,hikari <span class="hljs-string"><span class="hljs-string">".*Connection.*"</span></span> Benchmark (pool) Mode Cnt Score Error Units ConnectionBench.cycleCnnection one thrpt <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">4991.293</span></span> ¬± <span class="hljs-number"><span class="hljs-number">62.821</span></span> ops/ms ConnectionBench.cycleCnnection hikari thrpt <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">39660.123</span></span> ¬± <span class="hljs-number"><span class="hljs-number">1314.967</span></span> ops/ms</code> </pre><br><br>  This is showing HikariCP at 8x faster than <a href="https://github.com/odnoklassniki/one-datasource">one-datasource</a> . <br><br>  JMH test harness itself has changed.  I checked out the results. I just checked it out.  I ran both using the benchmark harness available at that time: <br><br>  Before static proxy factory methods: <br><pre> <code class="java hljs">Benchmark (pool) Mode Samples Mean Mean error Units ConnectionBench.testConnectionCycle hikari thrpt <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">9303.741</span></span> <span class="hljs-number"><span class="hljs-number">67.747</span></span> ops/ms</code> </pre><br><br>  After static proxy factory methods: <br><pre> <code class="java hljs">Benchmark (pool) Mode Samples Mean Mean error Units ConnectionBench.testConnectionCycle hikari thrpt <span class="hljs-number"><span class="hljs-number">16</span></span> <span class="hljs-number"><span class="hljs-number">9436.699</span></span> <span class="hljs-number"><span class="hljs-number">71.268</span></span> ops/ms</code> </pre><br><br>  It shows a slight improvement. <br><br>  If you‚Äôre not sure, you‚Äôre not sure what you‚Äôve seen. <br><br>  EDIT: And wow has HikariCP performance improved since January 2014! </div><p>Source: <a href="https://habr.com/ru/post/269023/">https://habr.com/ru/post/269023/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269009/index.html">Altera + OpenCL: we program under FPGA without knowledge of VHDL / Verilog</a></li>
<li><a href="../269015/index.html">Office as Platform, edition 8 - contextual Office application with Visual Studio Code on OS X, Linux and Windows</a></li>
<li><a href="../269017/index.html">What is ReactOS?</a></li>
<li><a href="../269019/index.html">Remote execution of system commands on request via sockets in Python 3. Part 2. Data transfer protocol</a></li>
<li><a href="../269021/index.html">JCoro ‚Äã‚Äã- asynchronous on coroutines in Java</a></li>
<li><a href="../269025/index.html">Amazon Web Services Infrastructure Inside. Part 2</a></li>
<li><a href="../269027/index.html">Comparison of MaxMind and Sypex bases</a></li>
<li><a href="../269029/index.html">Hibernate Developer Documentation - Chapter IV. Batch processing</a></li>
<li><a href="../269035/index.html">Volkswagen TDD</a></li>
<li><a href="../269037/index.html">Program modification and what is better to change: executable code or AST program?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>