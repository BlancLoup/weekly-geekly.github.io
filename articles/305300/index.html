<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Improving user interaction paths through page transitions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The post is a translation of the article ‚ÄúImproving User Flow Through Page Transitions‚Äù with Smashing Magazine about creating smooth transitions. The ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Improving user interaction paths through page transitions</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>The post is a translation of the article <a href="https://www.smashingmagazine.com/2016/07/improving-user-flow-through-page-transitions/">‚ÄúImproving User Flow Through Page Transitions‚Äù</a> with Smashing Magazine</em> about creating smooth transitions.  The author of this article, Luigi De Rosa, is a front-end developer at <a href="http://epic.net/">EPIC</a> .  Further, the story will go on behalf of the author.  Enjoy reading. </p><a name="habracut"></a><br><p>  <strong>Every time a user experiences an interaction experience (UX), the chance of his leaving increases.</strong>  <strong>Changing pages from one to the other often causes interruptions in the form of white blink with no content, causing a long load, or pulling the user out of the context of the page that was opened earlier.</strong> </p><br><p>  Transitions between pages can enhance this experience by preserving (or even improving) the user's context, keeping their attention and providing a visual continuation.  At the same time, transitions between pages can be pleasing to the eye and be interesting with good performance. </p><br><p>  In this article, we will, step by step, create transitions between pages.  We will also talk about the pros and cons of this technique and how to use it to the maximum. </p><br><h2>  Examples </h2><br><p>  Many mobile apps use excellent transitions between views.  In this example below, which follows the recommendations of the Google material design, we see how the animation transmits the hierarchical and spatial relationships between the pages. </p><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/173269145&amp;xid=25657,15700023,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgKu0jt5GsJf2oODzWJr54OPRjvGg" width="420" height="315" frameborder="0" title="Example of transition from Google Material Design" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br><p>  Why don't we take a similar approach to our websites?  Why do we agree with the fact that the user feels as if he is teleported every time he changes the page? </p><br><h2>  How to link transitions between pages </h2><br><h3>  SPA frameworks </h3><br><p>  Before getting our hands dirty, I have to say something about single-page application frameworks (SPA).  If you are using a SPA framework (such as AngularJS, Backbone.js or Ember), then creating transitions will be much easier, because all the paths are processed by JavaScript.  In this case, you should refer to the relevant documentation to look at the implementation of transitions between pages in the framework of your choice, because there may have good examples and instructions. </p><br><h3>  Bad way </h3><br><p>  My first attempt to create a transition between pages looked like this: </p><br><pre><code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'DOMContentLoaded'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Animate in }); document.addEventListener('beforeunload', function() { // Animate out });</span></span></code> </pre> <br><p>  The concept is simple: Use animation when the user leaves the page, and another animation when the new page loads. </p><br><p>  However, I soon noticed that this solution has a number of limitations: </p><br><ul><li>  We do not know how long the page will load, so the animation may not look smooth. </li><li>  We cannot create transitions that combine content from the previous and next pages. </li></ul><br><p>  In fact, the only way to achieve a smooth transition is to gain complete control over the process of changing pages and, therefore, not to change the whole page. <br>  Thus, we need to change the approach to the problem. </p><br><h3>  The right way </h3><br><p>  Let's take a look at the steps involved in creating a simple, smooth transition between pages in the right way.  There is something here called <code>pushState</code> AJAX (or PJAX) navigation, which essentially turns our site into something like a one-page site. </p><br><p>  This is not only a method of achieving smooth and pleasant transitions, but we will also take advantage of some of the other advantages that we will cover in detail later in this article. </p><br><h3>  Prevent default link behavior </h3><br><p>  The first step is to create a click event handler for all links, preventing them from standard behavior and changing the way the page breaks are handled. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,         // ,      ,   . document.addEventListener('click', function(e) { var el = e.target; //     ,      .href (HTMLAnchorElement) while (el &amp;&amp; !el.href) { el = el.parentNode; } if (el) { e.preventDefault(); return; } });</span></span></code> </pre> <br><p>  This method of adding a handler to the parent element, instead of adding to a particular node, is called <a href="http://stackoverflow.com/a/1688293/2065702">event delegation</a> , which is possible due to the nature of the HTML <a href="http://stackoverflow.com/a/4616720/2065702">bubble events of the</a> DOM API. </p><br><h3>  Page retrieval </h3><br><p>  Now that we have interrupted the browser loading of the page, we can manually get the page using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch API</a> .  Let's look at the following function, which gets the contents of the HTML page when it receives its URL. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadPage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.text(); }); }</code> </pre> <br><p>  For browsers that do not support the Fetch API, you should add a <a href="https://github.com/github/fetch">polyfill</a> , or use <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> . </p><br><h3>  Change current URL </h3><br><p>  HTML5 has a fantastic API called <code>pushState</code> , which allows websites to access and change browser history without loading any pages.  Below we use this to change the current URL to the URL of the next page.  Notice that this is a modification of the click handler announced earlier. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (el) { e.preventDefault(); history.pushState(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, el.href); changePage(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br><p>  As you can see, we also added a call to the <code>changePage</code> function, which we will take a <code>changePage</code> look at in more detail.  A similar function will also be called in the <code>popstate</code> event, which will occur when the active browser history is changed (for example, when the user presses the back button): </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'popstate'</span></span>, changePage);</code> </pre> <br><p>  Thus, we build a very primitive routing system in which we have active and passive modes. </p><br><p>  Active mode occurs when the user clicks on the link, and we change the URL using <code>pushState</code> , while passive mode occurs when the URL changes, and we receive a notification from the <code>popstate</code> event.  In any case, we are going to call <code>changePage</code> , which will take care of reading our new URL and loading the page. </p><br><h3>  Parsing and adding new content </h3><br><p>  Usually, the pages on which the transition is carried out, have such basic elements as header and footer.  We will use the following DOM structure on all of our pages (which, by itself, is the structure of Smashing Magazine): </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">header</span></span></span><span class="hljs-tag">&gt;</span></span> ‚Ä¶ <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">header</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">main</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cc"</span></span></span><span class="hljs-tag">&gt;</span></span> ‚Ä¶ <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">main</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">footer</span></span></span><span class="hljs-tag">&gt;</span></span> ‚Ä¶ <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">footer</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  The only part that we need to change on each page is the contents of the <code>cc</code> container.  Thus, we can build our <code>changePage</code> function <code>changePage</code> this: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> main = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'main'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,  URL   var url = window.location.href; loadPage(url).then(function(responseText) { var wrapper = document.createElement('div'); wrapper.innerHTML = responseText; var oldContent = document.querySelector('.cc'); var newContent = wrapper.querySelector('.cc'); main.appendChild(newContent); animate(oldContent, newContent); }); }</span></span></code> </pre> <br><h3>  Animation! </h3><br><p>  When a user clicks on a link, the <code>changePage</code> function <code>changePage</code> HTML of this page, then <strong>extracts the</strong> <code>cc</code> container and <strong>adds</strong> it to the <code>main</code> element.  At the moment we have two containers <code>cc</code> on our page, the first belongs to the previous page, and the second to the next. </p><br><p>  The next function, <code>animate</code> , takes care of smoothly overlapping the two containers, hiding the old one, revealing the new one and removing the old container.  In this example, I use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API">Web Animations API</a> to create an appearance animation, but you can use any other method or library that you like. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">animate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">oldContent, newContent</span></span></span><span class="hljs-function">) </span></span>{ oldContent.style.position = <span class="hljs-string"><span class="hljs-string">'absolute'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fadeOut = oldContent.animate({ <span class="hljs-attr"><span class="hljs-attr">opacity</span></span>: [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fadeIn = newContent.animate({ <span class="hljs-attr"><span class="hljs-attr">opacity</span></span>: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] }, <span class="hljs-number"><span class="hljs-number">1000</span></span>); fadeIn.onfinish = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ oldContent.parentNode.removeChild(oldContent); }; }</code> </pre> <br><p>  The resulting code <a href="https://gist.github.com/luruke/0704bc594c81e3f4c491ba919b96450a">is available on Github</a> . </p><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/173269151&amp;xid=25657,15700023,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhW_kxjyBZu_JuiL0OXLJA1Rcaz9w" width="422" height="315" frameborder="0" title="Result of the cross-fade transition between pages on SmashingMagazine" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br><p>  All this is just the basics of navigating through the pages! </p><br><h3>  Cautions and limitations </h3><br><p>  The small example we just created is far from ideal.  In fact, we did not take into account a number of things: </p><br><ul><li>  <strong>Make sure we touch the correct links.</strong> <br>  Before changing the link behavior, we need to add a check to make sure that it should be changed.  For example, we need to ignore all links with <code>target="_blank"</code> (which opens the page in a new tab), all links to external domains, and some other special cases, such as <code>Control/Command + click</code> (which also open the page in a new tab). </li><li>  <strong>Update items outside the main container.</strong> <br>  At the moment, while the page is changing, all elements outside the <code>cc</code> container remain the same.  However, some of these elements need to be changed (now it is only possible to change it manually), including the <code>title</code> document, the menu element with the class <code>active</code> and potentially many other dependencies on our site. </li><li>  <strong>JavaScript lifecycle management.</strong> <br>  Now our page behaves in approximately the same way as the SPA, in which the browser does not change the page on its own.  So, we need to manually take care of the JavaScript life cycle, for example, by linking (binding) and unleashing certain events, executing plugins, including polyfills and third-party code. </li></ul><br><h3>  Browser support </h3><br><p>  The only requirement for this navigation mode is the <code>pushState</code> API, which <a href="http://caniuse.com/">is available in all modern browsers</a> .  This method <strong>works completely as a progressive improvement</strong> .  Pages are still available in the usual way, and the website will continue to function normally if JavaScript is disabled. </p><br><p>  If you are using a SPA framework, consider using PJAX navigation instead, to speed up navigation.  In return, you will get support from older browsers and create a SEO-friendly website. </p><br><h2>  Moving on </h2><br><p>  We can continue to squeeze the most out of this way by optimizing some aspects.  The following pair of tricks <strong>will speed up</strong> navigation, greatly improving the user experience. </p><br><h3>  Use cache </h3><br><p>  <code>loadPage</code> slightly changing our <code>loadPage</code> function, we can add a simple cache that will make sure that pages that have already been visited will not be loaded again. </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cache = {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadPage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cache[url]) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) </span></span>{ resolve(cache[url]); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span> }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ cache[url] = response.text(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cache[url]; }); }</code> </pre> <br><p>  As you might have guessed, we can use a more durable cache with the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Cache">Cache API</a> or other persistent storage on the user's side (for example, IndexedDB). </p><br><h3>  Animate current page </h3><br><p>  Our damping effect requires the next page to be loaded and ready before the transition is completed.  We would like to start the animation on the old page immediately after clicking on the link, which will give the user instant responsiveness and perception of performance. </p><br><p>  Using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promises</a> , handling such situations can seem very simple.  The <code>.all</code> method creates a new promise that will be fulfilled after all promises passed in the form of arguments are fulfilled. </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    animateOut()  loadPage() Promise.all[animateOut(), loadPage(url)] .then(function(values) { ‚Ä¶</span></span></code> </pre> <br><h3>  Preloading the next page </h3><br><p>  Using PJAX navigation, the page is replaced almost <strong>twice as fast</strong> as the default navigation, because the browser does not have to parse and calculate any scripts or styles on a new page. </p><br><p>  However, we can go further by starting to preload the next page when the user hovers over the link. </p><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/173269150&amp;xid=25657,15700023,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgy2CbpJr6JZjWlMc3bQVm4hRQ8PQ" width="363" height="315" frameborder="0" title="InstantClick demo" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br><p>  As you can see, the delay between clicking and hovering the cursor is usually 200 to 300 milliseconds.  This time is usually enough to load the next page. </p><br><p>  But it can easily go sideways.  For example, if you have a long list of links, and the user scrolls through the page through them, this method will preload all the pages, because the links appear under the cursor. </p><br><p>  Another point that we may have noticed and taken into account is the prediction of the speed of the user's connection.  (Perhaps this will be possible in the future with the <a href="http://wicg.github.io/netinfo/">Network Information API</a> .) </p><br><h3>  Partial withdrawal </h3><br><p>  In our <code>loadPage</code> function <code>loadPage</code> we get the entire HTML document, although we only need the <code>cc</code> container.  If we were using the language on the server side, we would be able to detect if a request comes from a particular user-defined AJAX call and, if so, only display the correct container.  Using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Headers">Headers API,</a> we can send a custom HTTP header in our request. </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadPage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myHeaders = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Headers(); myHeaders.append(<span class="hljs-string"><span class="hljs-string">'x-pjax'</span></span>, <span class="hljs-string"><span class="hljs-string">'yes'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fetch(url, { <span class="hljs-attr"><span class="hljs-attr">method</span></span>: <span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: myHeaders, }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response.text(); }); }</code> </pre> <br><p>  Then, on the server side (using PHP in this case), we can determine if our custom header exists before outputting the required container: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">isset</span></span>($_SERVER[<span class="hljs-string"><span class="hljs-string">'HTTP_X_PJAX'</span></span>])) { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p>  This will reduce the size of HTTP messages, as well as reduce the load on the server. </p><br><h3>  Summing up </h3><br><p>  After the introduction of this technique in a number of projects, it seemed to me that a reusable library would be extremely useful.  This would save time the next time, allowing you to focus on the transition effects themselves. </p><br><p>  Thus, <a href="http://barbajs.org/">Barba.js</a> was born - a small library (4 KB in compressed state), which abstracts all this complexity and provides a pleasant, clean and simple API for developers.  It also takes into account different views and comes with ready-made transitions, caching, preloading and events.  The library has open source code and <a href="">is available on GitHub</a> . </p><br><iframe src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/173269144&amp;xid=25657,15700023,15700043,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhFl9KlWwLWkqgHOl08xaFwvJ5eQA" width="394" height="315" frameborder="0" title="Demo of a transition created with Barba.js" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""></iframe><br><h3>  Conclusion </h3><br><p>  We have just looked at how to create a smooth overlap effect, the pros and cons of using PJAX navigation to effectively turn our website into a SPA.  Besides the advantages of the transition itself, we also considered the introduction of simple caching and preloading mechanisms to speed up the loading of new pages. </p><br><p>  This whole article is based on my personal experience and what I learned during the implementation of transitions in the projects I worked on. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/305300/">https://habr.com/ru/post/305300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305290/index.html">Security Week 27: Android encryption bypass, medical Conficker resurrection, IoT botnet</a></li>
<li><a href="../305292/index.html">Making cool Single Page Application on basis.js - part 3. Client for VKontakte</a></li>
<li><a href="../305294/index.html">Summer Homework: Top 10 Microsoft Virtual Academy Courses</a></li>
<li><a href="../305296/index.html">MIPT launched an online magistracy in modern combinatorics</a></li>
<li><a href="../305298/index.html">Pass a technical interview (Level 2)</a></li>
<li><a href="../305304/index.html">Accidents on server farms</a></li>
<li><a href="../305306/index.html">Making a multi-channel full duplex walkie-talkie</a></li>
<li><a href="../305308/index.html">In the footsteps of Google I / O 2016 - the new Firebase: integration with Android</a></li>
<li><a href="../305312/index.html">Review of physics in Sonic games. Parts 5 and 6: the loss of rings and being under water</a></li>
<li><a href="../305314/index.html">It seems that Github is again unavailable in Russia ... and other sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>