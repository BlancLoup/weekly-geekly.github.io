<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Selenium and Node.js: we write reliable browser tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are many good articles on how to start writing automated browser tests using the Node.js version of Selenium. 

  

 Some materials talk about h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Selenium and Node.js: we write reliable browser tests</h1><div class="post__text post__text-html js-mediator-article">  There are many good articles on how to start writing automated browser tests using the Node.js version of Selenium. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/338984/"><img src="https://habrastorage.org/webt/59/ce/2c/59ce2c9a3fff3075665372.jpeg"></a> <br><br>  Some materials talk about how to wrap tests in Mocha or Jasmine, some automate everything using npm, Grunt or Gulp.  In all such publications, you can find information on how to install and configure everything you need.  There you can see simple examples of working code.  All this is very useful, since, for a beginner, it may not be so easy to assemble a working test environment consisting of many components. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, as far as the Selenium pitfalls are concerned, with regard to the analysis of the best practical techniques for developing tests, these articles usually do not justify expectations. <br><br>  Today we will start with what other materials on automation of browser tests usually end with using Selenium for Node.js.  Namely, we will talk about how to increase the reliability of tests and "untie" them from the unpredictable phenomena that browsers and web applications are full of. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Sleep is evil</font> </h2><br>  The Selenium <code>driver.sleep</code> method is the worst enemy of the test developer.  However, despite this, it is used everywhere.  Perhaps this is due to the brevity of the documentation for the Node-version of <a href="http://seleniumhq.github.io/selenium/docs/api/javascript/">Selenium</a> , and because it covers only the syntax of the API.  She lacks real life examples. <br><br>  Perhaps the reason is that this method is used in a variety of code examples on blogs and question and answer sites like StackOverflow. <br><br>  In order to understand the features of the <code>driver.sleep</code> method, consider an example.  Suppose we have an animated panel that, during the appearance on the screen, changes its size and position.  Take a look at her. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/02e/478/cbb02e4789f76b75dfcdaaf7f557f278.gif"></div><br>  <i><font color="#999999">Animation panel</font></i> <br><br>  This happens so quickly that you may not notice that the buttons and controls inside the panel also change in size and change position. <br>  Here is a slow version of the same process.  Notice how the green <code>Close</code> button changes with the panel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/04d/cf0/1a004dcf0b8ec7ed44ecf461674f9f6a.gif"></div><br>  <i><font color="#999999">Slow Motion Panel Animation</font></i> <br><br>  It is unlikely that this behavior of the panel can interfere with the normal operation of real users, since the animation happens very quickly.  If it is slow enough, as in the second example, and you try to click the <code>Close</code> button during the animation process, you may very well just not get to it. <br><br>  Typically, these animations occur so quickly that the user does not have the desire to "catch" changing buttons.  People are just waiting for the completion of the animation.  However, this does not apply to Selenium.  It is so fast that it can try to click on an element that is still animated.  As a result, you may encounter something like this error message: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.InvalidOperationException : Element <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> clickable at <span class="hljs-type"><span class="hljs-type">point</span></span> (<span class="hljs-number"><span class="hljs-number">326</span></span>, <span class="hljs-number"><span class="hljs-number">792.5</span></span>)</code> </pre> <br>  In this situation, many programmers will say: ‚ÄúYeah, I need to wait for the animation to complete, so I just use the <code>driver.sleep(1000)</code> in order for the panel to <code>driver.sleep(1000)</code> to its normal state.‚Äù  It seems that the problem is solved?  However, not all so simple. <br><br><h2>  <font color="#3AC1EF">Driver.sleep problems</font> </h2><br>  The <code>driver.sleep(1000)</code> command does exactly what you can expect from it.  It stops the test for 1000 milliseconds and allows the browser to continue to work: load pages, place fragments of documents on them, animate or smoothly display elements, or do anything else. <br><br>  Returning to our example, assuming that the panel reaches the normal state in 800 milliseconds, the <code>driver.sleep(1000)</code> command usually helps achieve what it is called for.  So why not use it? <br><br>  The main reason is that this behavior is <a href="https://en.wikipedia.org/wiki/Deterministic_algorithm">non-deterministic</a> .  This means that sometimes such code will work, and sometimes it will not.  Since this does not always work, we come to unreliable tests that, under certain conditions, fail.  Hence the bad reputation of automated browser tests. <br><br>  Why constructions with <code>driver.sleep</code> not always efficient?  In other words, why is this a non-deterministic mechanism? <br><br>  A web page is much more than what you can see.  And the animation of the elements is a great example.  However, while everything is working as it should, nothing special is needed to be seen. <br><br>  It is worth saying that web pages are designed in the expectation that people will work with them.  During testing using Selenium, a program that interacts much faster with humans will interact with the pages.  For example, if you tell Selenium to first find an element and then click on it, it can take only a few milliseconds between these operations. <br><br>  When a person is working with a website, he waits for the element to appear fully before clicking on it.  And when the appearance of an element takes less than a second, we probably won't even notice this ‚Äúwait‚Äù.  Selenium is not only faster and more demanding than a regular user.  Tests, in the course of working with pages, have to face various unpredictable factors.  Consider some of them: <br><br><ol><li>  A designer can change the animation time from 800 milliseconds to 1200 milliseconds.  As a result, a test with <code>driver.sleep(1000)</code> will fail. <br></li><li>  Browsers do not always do exactly what is required of them.  Because of the load on the system, the animation can slow down and take more than 800 milliseconds.  Perhaps even longer than the wait time set to 1000 milliseconds.  As a result, the test failed again. <br></li><li>  Different browsers have different data visualization mechanisms, assign different priorities to the operations of placing elements on the screen.  Add a new browser to the testing suite and the test will crash again with an error. <br></li><li>  Browsers that control pages, JavaScript calls that change their content, are asynchronous in nature.  If the animation in our example is applied to a block that needs information from the server, then before starting the animation you will have to wait for something like the result of an AJAX call.  Now, among other things, we are dealing with network delays.  As a result, it is impossible to accurately estimate the time required to display the panel on the screen.  The test will not work properly again. <br></li><li>  Of course, there are other reasons for test failures that I don‚Äôt know about.  Even the browsers themselves, without taking into account external factors, are complex systems in which, besides, there are errors.  Different errors in different browsers.  As a result, trying to write reliable tests, we strive to ensure that they work in different browsers of different versions and in several operating systems of different releases.  Nondeterministic tests in such conditions sooner or later fail.  If you take into account all this, it becomes clear why programmers refuse automated tests and complain about how unreliable they are. <br></li></ol><br>  What will the programmer do to fix one of the above problems?  He will start looking for the source of the failure, find out that the whole thing is in the time it takes the animation and will come to the obvious solution - to increase the waiting time in the <code>driver.sleep</code> call.  Then, relying on luck, the programmer will hope that this improvement will work in all possible test scenarios, that it will help to cope with various system loads, smooth out differences in the visualization systems of various browsers, and so on.  But we still have a non-deterministic approach.  Therefore, it is impossible to do so. <br><br>  If you have not yet verified that <code>driver.sleep</code> is a harmful command in many situations, think about this.  Without <code>driver.sleep</code> tests will run much faster.  For example, we hope that the animation from our example takes only 800 milliseconds.  In a real test suite, such an assumption would lead to using something like <code>driver.sleep(2000)</code> , again, in the hope that 2 seconds would be enough for the animation to complete successfully, whatever the additional factors affecting on the browser and page. <br><br>  This is more than a second lost by just one step of the automated test.  If there are many such steps, a lot of such ‚Äúspare‚Äù seconds will come very quickly.  For example, a recently reworked test for just one of our web pages, which took a few minutes due to excessive use of <code>driver.sleep</code> , now takes less than fifteen seconds. <br><br>  I offer you specific examples of getting rid of <code>driver.sleep</code> and converting tests to robust, fully deterministic constructs. <br><br><h2>  <font color="#3AC1EF">A couple of words about promises</font> </h2><br>  JavaScript-Selenium intensively uses promises.  At the same time, the details are hidden from the programmer due to the use of the integrated promis manager.  It is expected that this functionality <a href="https://github.com/SeleniumHQ/selenium/issues/2969">will be removed</a> , so in the future you will either have to figure out how to independently combine promises in chains, or how to use the new JavaScript async / await mechanism. <br><br>  In this material, the examples still use the traditional embedded manager of Selenium promises and the possibility of combining promises into chains.  If you understand how promises work, this will be a big plus when analyzing the following code examples.  However, you will get benefit from this material even if you haven‚Äôt properly dealt with the promises. <br><br><h2>  <font color="#3AC1EF">We write tests</font> </h2><br>  Let's continue the example with the button located on the animated panel.  We want to click on this button.  Let's look at a few specific features that our tests may break. <br><br>  What about an item that is dynamically added to the page and does not exist immediately after the page completes the download? <br><br><h3>  Waiting for an item to appear in the DOM </h3><br>  The following code will not work if an element with a CSS id <code>my-button</code> was added to the DOM after the page loads: <br><br><pre> <code class="hljs pgsql">//   Selenium    //  . driver.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https:/foobar.baz'</span></span>); //  . const button = driver.findElement(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'my-button'</span></span>)); button.click();</code> </pre> <br>  The <code>driver.findElement</code> method expects the element to already be present in the DOM.  It will give an error if the item cannot be found immediately.  In this case, ‚Äúimmediately,‚Äù due to a call to <code>driver.get</code> , means: ‚Äúafter the page has finished loading.‚Äù <br><br>  Remember that the current version of Selenium for JavaScript independently manages promises.  Therefore, each expression will be fully completed before proceeding to the next expression. <br><br>  Please note that the above scenario is not always desirable.  The <code>driver.findElement</code> call <code>driver.findElement</code> can be handy if you are sure that the element is already in the DOM. <br><br>  To begin, take a look at how you should not correct this error.  Suppose we know that adding an element to the DOM can take several seconds: <br><br><pre> <code class="hljs pgsql">driver.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https:/foobar.baz'</span></span>); //  ,     driver.sleep(<span class="hljs-number"><span class="hljs-number">3000</span></span>); // ,      ,            . const button = driver.findElement(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'my-button'</span></span>)); button.click();</code> </pre> <br>  For the reasons mentioned above, such a construction can lead to failure, and is likely to result.  We need to figure out how to wait for an element to appear in the DOM.  It's pretty simple, like this is often found in the examples that can be found on the Internet.  Let's use the <a href="http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/ie_exports_Driver.html">well-documented</a> <code>driver.wait</code> method to wait no more than twenty seconds for the element to appear in the DOM. <br><br><pre> <code class="hljs pgsql">const button = driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'my-button'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ); button.click();</code> </pre> <br>  This approach will immediately give us a bunch of advantages.  For example, if an item is added to the DOM within one second, the <code>driver.wait</code> method will exit in one second.  He will not wait all the twenty seconds that are allotted to him. <br><br>  Because of this behavior, we can set timeouts with a large margin, without worrying that they will slow down the tests.  This model of behavior compares favorably with the <code>driver.sleep</code> , which will always wait for the entire specified time. <br><br>  This works in many situations.  But the only case in which such an approach does not help us is to try to click on an element that is present in the DOM but is not yet visible on the screen. <br><br>  Selenium is intelligent enough to not try to click on an invisible element.  This is good, because the user cannot click on such an element, but this complicates the work of creating reliable automated tests. <br><br><h3>  Waiting for item to appear on screen </h3><br>  We will build on the previous example, since, before we wait for the element to become visible, it makes sense to wait until it is added to the DOM.  In addition, in the code below, you can see the first example of using a chain of promises: <br><br><pre> <code class="hljs pgsql">const button = driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'my-button'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(element =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver.wait(    <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementIsVisible(element),    <span class="hljs-number"><span class="hljs-number">20000</span></span>  ); }); button.click();</code> </pre> <br>  On this, in general, it would be possible to stop, as we have already considered enough to significantly improve the tests.  Using this code, you can avoid a lot of situations that would otherwise cause the test to fail because the element is not in the DOM immediately after the page has finished loading.  Or due to the fact that it is invisible immediately after loading the page because of something like an animation.  Or even for both of these reasons. <br><br>  If you master the above approach, you should not have any reason to write nondeterministic code for Selenium.  However, writing such code is simply not always the case. <br><br>  When the complexity of a task grows, developers often give up their positions and again turn to <code>driver.sleep</code> .  Consider a few more examples that will help to do without <code>driver.sleep</code> in more difficult circumstances. <br><br><h3>  Description of own conditions </h3><br>  Thanks to the <code>until</code> method, the JavaScript API for Selenium already has a number of <a href="http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/until.html">helper methods</a> that can be used with <code>driver.wait</code> .  In addition, you can arrange to wait until the element no longer exists, wait for an element containing specific text to appear, wait for a notification to show, or use many other conditions. <br><br>  If you cannot find what you need, among the standard methods, you will need to write your own conditions.  It is, in fact, quite simple.  The main problem here is that it is difficult to find examples of such conditions.  Here is another pitfall that we need to deal with. <br><br>  According to the <a href="http://seleniumhq.github.io/selenium/docs/api/javascript/module/selenium-webdriver/lib/webdriver_exports_WebDriver.html">documentation</a> , you can provide the <code>driver.wait</code> method with a function that returns <code>true</code> or <code>false</code> . <br><br>  Let's say we need to wait for the <code>opacity</code> property of a certain element to become equal to one: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  . const element = driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(By.id(<span class="hljs-string"><span class="hljs-string">'some-id'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> driver.wait    ,   <span class="hljs-literal"><span class="hljs-literal">true</span></span>  <span class="hljs-literal"><span class="hljs-literal">false</span></span>. driver.wait(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element.getCssValue(<span class="hljs-string"><span class="hljs-string">'opacity'</span></span>)        .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(opacity =&gt; opacity === <span class="hljs-string"><span class="hljs-string">'1'</span></span>); });</code> </pre> <br>  Such a construction seems useful and suitable for reuse, so we put it in a function: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> waitForOpacity = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver.wait(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function"> =&gt;</span></span> element.getCssValue(<span class="hljs-string"><span class="hljs-string">'opacity'</span></span>)        .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">opacity</span></span></span><span class="hljs-function"> =&gt;</span></span> opacity === <span class="hljs-string"><span class="hljs-string">'1'</span></span>); ); };</code> </pre> <br>  Now use this function: <br><br><pre> <code class="hljs pgsql">driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'some-id'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(waitForOpacity);</code> </pre> <br>  And here we are faced with a problem.  What if you want to click on an element when it becomes completely opaque?  If we try to use the value returned by the above code, nothing good will come of it: <br><br><pre> <code class="hljs pgsql">const element = driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'some-id'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(waitForOpacity); //  .  element   <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>,   ,     click(). element.click();</code> </pre> <br>  For the same reason, we cannot use the combination of promises in chains in such a construction. <br><br><pre> <code class="hljs pgsql">const element = driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'some-id'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(waitForOpacity) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(element =&gt; { //    , element     . element.click(); });</code> </pre> <br>  This is all, however, easy to fix.  Here is the improved method: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> waitForOpacity = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> driver.wait(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">element</span></span></span><span class="hljs-function"> =&gt;</span></span> element.getCssValue(<span class="hljs-string"><span class="hljs-string">'opacity'</span></span>)        .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">opacity</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (opacity === <span class="hljs-string"><span class="hljs-string">'1'</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element;     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;   }); ); };</code> </pre> <br>  This piece of code returns an element if the condition is true, otherwise returns <code>false</code> .  This template is suitable for reuse, it can be used when writing your own conditions. <br><br>  Here's how to apply this together with the combination of promises in chains: <br><br><pre> <code class="hljs pgsql">driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'some-id'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(waitForOpacity) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(element =&gt; element.click());</code> </pre> <br>  Or even like this: <br><br><pre> <code class="hljs pgsql">const element = driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'some-id'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(waitForOpacity); element.click();</code> </pre> <br>  Creating your own conditions allows you to expand the capabilities of tests and make them deterministic.  However, this is not always enough. <br><br><h3>  Leaving in the minus </h3><br>  That's right, sometimes you need to go into the minus, and not to strive to get a plus.  I am referring here to checking something that no longer exists, or something that is no longer visible on the screen. <br><br>  Suppose an element is already present in the DOM, but you do not need to interact with it before some data is loaded via AJAX.  The item can be covered with a panel that says "Loading ...". <br><br>  If you paid close attention to the conditions that the <code>until</code> method suggests, you might have noticed methods like the <code>elementIsNotVisible</code> or <code>elementIsDisabled</code> or the not-so-obvious <code>stalenessOf</code> method. <br><br>  Thanks to one of these methods, you can organize a check to hide the panel with the load indicator: <br><br><pre> <code class="hljs pgsql">//     DOM,     . const desiredElement = driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'some-id'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ); //        ,      //  . driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementIsNotVisible(<span class="hljs-keyword"><span class="hljs-keyword">By</span></span>.id(<span class="hljs-string"><span class="hljs-string">'loading-panel'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ); //        ,     ,   . desiredElement.click();</code> </pre> <br>  Exploring the above methods, I found that the <code>stalenessOf</code> method <code>stalenessOf</code> particularly useful.  It waits until the item is removed from the DOM, which, among other reasons, may occur due to a page refresh. <br><br>  Here is an example of waiting for an update of the <code>iframe</code> content to continue: <br><br><pre> <code class="hljs ruby">let iframeElem = driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.elementLocated(By.className(<span class="hljs-string"><span class="hljs-string">'result-iframe'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,     iframe. someElement.click(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    iframe  : driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.stalenessOf(iframeElem), <span class="hljs-number"><span class="hljs-number">20000</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    iframe. driver.wait( <span class="hljs-keyword"><span class="hljs-keyword">until</span></span>.ableToSwitchToFrame(By.className(<span class="hljs-string"><span class="hljs-string">'result-iframe'</span></span>)), <span class="hljs-number"><span class="hljs-number">20000</span></span> ); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,    ,     iframe.</code> </pre> <br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  The main recommendation that can be given to those who seek to write reliable tests on Selenium is that one should always strive for determinism and abandon the <code>sleep</code> method.  Relying on the <code>sleep</code> method is based on arbitrary assumptions.  And this, sooner or later, leads to failures. <br><br>  I hope that the examples given here will help you to move towards the creation of high-quality tests on Selenium. <br><br>  Dear readers!  Do you use Selenium to automate tests? </div><p>Source: <a href="https://habr.com/ru/post/338984/">https://habr.com/ru/post/338984/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338970/index.html">Changed the way to create chat bots in Viber</a></li>
<li><a href="../338974/index.html">National roaming in different countries of the world</a></li>
<li><a href="../338978/index.html">How the AI ‚Äã‚Äãsenses system was created in Thief: The Dark Project</a></li>
<li><a href="../338980/index.html">What is known about the attack on the supply chain CCleaner</a></li>
<li><a href="../338982/index.html">More Apple Surprises: Updated Posting Guidelines on the App Store</a></li>
<li><a href="../338986/index.html">Sonata import bundle</a></li>
<li><a href="../338988/index.html">What is ERP-Platfoma</a></li>
<li><a href="../338990/index.html">Checklist: how to choose a model of an access rights management system and not miscalculate</a></li>
<li><a href="../338992/index.html">Simulation of the physical world</a></li>
<li><a href="../338994/index.html">404 pages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>