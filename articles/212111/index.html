<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write your component for iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Controls - one of the most important components of any application. In essence, they are graphical components that allow users to interact in one way ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write your component for iOS</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/930/67a/c0a/93067ac0a3cc558d9ac0291c9bb126d0.png" alt="image"><br><br>  Controls - one of the most important components of any application.  In essence, they are graphical components that allow users to interact in one way or another with the application and its data.  This lesson is about creating a custom control that can later be used in any application. <br><a name="habracut"></a><br>  Apple provides the developer with about 20 different UI components, including <code>UITextField</code> , <code>UIButton</code> and <code>UISwitch</code> .  Using all the power of standard controls, you can create many different interface options.  Be that as it may, sometimes there is a need for something that cannot be realized by standard components. <br><br>  I will give an example.  Let's say you are developing an application that makes a list of real estate in sale.  It allows the user to view search results in a specific price range.  Alternatively, you can use two <code>UISlider</code> , one of which sets the minimum price, the other - the maximum, as shown in the screenshot: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/41c/08c/1d7/41c08c1d7b4cf30c6e8d0527ad1e137b.png" alt="image"><br><br>  Although this option will work, it does not illustrate well the concept of the price range.  It would be much better to use one slider with two sliders responsible for the minimum and maximum: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b40/007/041/b400070413361827f5998c4a3c88220d.png" alt="image"><br><br>  Such an element is much more convenient to use, the user immediately understands that he sets the range of values, and not fixed numbers.  Unfortunately, this slider is not included in the set of standard elements.  To implement its functionality, it is necessary to develop a custom control. <br><br>  You can make this slider subclass <code>UIView</code> .  And if in the context of one particular application, such a solution is justified, then its reuse in other developments will require some effort.  A much better idea would be to make this component universal, available for use in any application.  This is the meaning of custom controls. <br><br>  As already mentioned, custom components are controls that you create; they are not part of the <code>UIKit Framework</code> .  As well as the standard components, they must be fully versatile and customizable for any needs.  Recently, a whole community of developers has been formed, who spread their components to open access. <br><br>  This tutorial will show you how to develop your own <code>RangeSlider</code> control, which solves the above problem.  Such issues as extending existing components, developing an API, and even putting your creation into public access will be affected. <br><br>  So, enough theory!  It's time to start customizing! <br><br><h4>  Start </h4><br>  This section is devoted to the development of the basic structure of the component, which will be enough to display a simple slider on the screen.  Launch <b>Xcode</b> and select <b>File -&gt; New -&gt; Project</b> .  In the window that appears, select <b>iOS -&gt; Application -&gt; Single View Application</b> and click <b>Next</b> .  On the next screen, enter <b>CERangeSlider</b> as the project <b>name</b> and fill in the remaining fields: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b7f/33d/f9a/b7f33df9ae9d0a0e44de00f990506022.png" alt="image"><br><br>  In this project, Storyboards are not used, as we operate with just one screen.  You can use any other class as a prefix - most importantly, do not forget that the corresponding changes will occur in the application code.  In the fields <i>"Organization Name"</i> and <i>"Company Identifier"</i> you can enter your own values.  When done, click <b>Next</b> .  Select the project storage location and click <b>Create</b> . <br><br>  The first decision that you will need to make when creating a custom control is which existing class you will inherit or extend.  It is important that the class inherit <code>UIView</code> . <br><br>  If you look closely at the various components of <code>Apple UIKit</code> , you will notice that many elements such as <code>UILabel</code> and <code>UIWebView</code> directly inherit <code>UIView</code> .  But be that as it may, there are such elements that inherit <code>UIControl</code> , as shown in this figure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d6/720/21d/4d672021de1e68103d72d1286196a899.png" alt="image"><br><br><blockquote>  <b>Note: A</b> detailed hierarchy of interface elements can be found here: <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIKit_Framework/Introduction/Introduction.html">UIKit Framework Reference</a> . </blockquote><br><br>  The <code>UIControl</code> class implements the <i>Target-Action</i> pattern, which is essentially a way of notifying component changes.  Also, <code>UIControl</code> has several properties related to controlling the state of an object.  To create our component you will use just such a template, so that <code>UIControl</code> will serve as an excellent start. <br><br>  Right-click on the <b>CERangeSlider</b> group in the <b>Project Navigator</b> and select <b>New File</b> , then <b>iOS -&gt; Cocoa Touch -&gt; Objective-C class</b> and click <b>Next</b> .  Name the class <b>CERangeSlider</b> , and in the <i>"subclass of"</i> field <i>,</i> enter <b>UIControl</b> .  Click <b>Next</b> and <b>Create</b> to select the storage location for the class. <br><br>  Although writing code in itself is a pleasant process, you most likely want to watch how the item is displayed on the screen.  Before you start writing code, add your component to the <i>View Controller</i> . <br><br>  Open <b>CEViewController.m</b> and insert the following line: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CERangeSlider.h"</span></span></span></span></code> </pre><br><br>  Further in the same file add a variable: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CEViewController</span></span></span><span class="hljs-class"> </span></span>{ CERangeSlider* _rangeSlider; }</code> </pre><br><br>  Replace the standard <code>viewDidLoad</code> following code block: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; <span class="hljs-comment"><span class="hljs-comment">// Do any additional setup after loading the view, typically from a nib. NSUInteger margin = 20; CGRect sliderFrame = CGRectMake(margin, margin, self.view.frame.size.width - margin * 2, 30); _rangeSlider = [[CERangeSlider alloc] initWithFrame:sliderFrame]; _rangeSlider.backgroundColor = [UIColor redColor]; [self.view addSubview:_rangeSlider]; }</span></span></code> </pre><br><br>  This code creates an object of your class with the required dimensions and adds it to the screen.  The background color of the component is set to red so that it is visible on the main background of the application.  If the color is not indicated, the component will remain transparent, and you will long be puzzled over where it went.  :] <br><br>  Build and run the application;  You will need to see the following screen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec7/191/e6c/ec7191e6c52161ee3f21136555ad2bda.png" alt="image"><br><br>  Before you add visual elements to a project, you will need to create several properties to keep track of the various information stored in the component.  This will serve as the basis for creating a future API. <br><br><blockquote>  <b>Note:</b> Your component's API defines the methods and properties that you intend to expose to other developers.  Further in the article you will read about the structure of the API - for now stay in touch! </blockquote><br><br><h4>  Add standard component properties </h4><br>  Open <b>CERangeSlider.h</b> and add the following properties between <code>@interface</code> and <code>@end:</code> <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maximumValue; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minimumValue; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upperValue; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowerValue;</code> </pre><br>  These four properties are enough to describe the state of the component ‚Äî the maximum and minimum values ‚Äã‚Äãof the range, and the current lower and upper thresholds. <br><br>  Well-designed controls should contain standard settings, otherwise they will look a bit strange when drawn on the screen.  Open <b>CERangeSlider.m</b> , locate the <code>initWithFrame:</code> method generated by <b>Xcode</b> , and replace it with the following code: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)initWithFrame:(<span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>)frame { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> initWithFrame:frame]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Initialization code _maximumValue = 10.0; _minimumValue = 0.0; _upperValue = 8.0; _lowerValue = 2.0; } return self; }</span></span></code> </pre><br>  Now it's time to work with the interactive elements of the component: sliders and a progress bar on which they are located. <br><br><h4>  Images vs.  CoreGraphics </h4><br>  There are two ways to display items on the screen: <br><ol><li>  Use as part of the image component, </li><li>  Use a combination of layers and <i>Core Graphics</i> . </li></ol><br>  Each of the methods has its pros and cons. <br><br><ul><li>  Using images is the easiest option, at least if you can draw.  If you intend to give other developers the opportunity to replace these images with their own, then you can set them as <code>UIImage</code> properties. </li><li>  The use of images provides the component with sufficient flexibility.  Third-party developers can change everything, up to each pixel - but on the other hand, it requires certain drawing skills - and changing something through the code is very difficult. </li></ul><br><br>  The application code is fully responsible for displaying the component by <i>Core Graphics</i> , as a result of which much more effort is required from the programmer.  But this method allows you to build a more flexible API.  Using <i>Core Graphics</i> , you can set virtually any component property ‚Äî its colors, thickness, curvature ‚Äî and indeed, any parameter that is responsible for rendering.  This approach allows developers using your control to easily customize it. <br><br>  In this tutorial we will use the second approach - <i>Core Graphics</i> . <br><br><blockquote>  <b>Note:</b> Curiously, Apple prefers using graphic resources in its components.  Most likely, this is due to the fact that they have set the standard dimensions for each element and do not allow its complete customization. </blockquote><br>  In <b>Xcode,</b> go to the project settings window.  Then select the <b>Build Phases</b> tab and the <b>Link Binary With Libraries</b> section.  Add to the list <b>QuartzCore.framework</b> .  The classes and methods of this framework will be used to manually draw the component. <br><br>  This screenshot clearly shows how to find and add <b>QuartzCore.framework</b> if you mess up: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b8/a94/fa3/6b8a94fa3c9b9482e0f376c0afffc05f.jpg" alt="image"><br><br>  Open <b>CERangeSlider.m</b> and add the following line: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QuartzCore/QuartzCore.h&gt;</span></span></span></span></code> </pre><br>  Add the following variables to the same file immediately after <code>@implementation</code> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CERangeSlider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">CALayer</span></span>* _trackLayer; <span class="hljs-built_in"><span class="hljs-built_in">CALayer</span></span>* _upperKnobLayer; <span class="hljs-built_in"><span class="hljs-built_in">CALayer</span></span>* _lowerKnobLayer; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _knobWidth; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _useableTrackLength; }</code> </pre><br>  These three layers - <code>_trackLayer</code> , <code>_upperKnobLayer</code> and <code>_lowerKnobLayer</code> will be used to display the various elements of your component.  The two variables <code>_knobWidth</code> and <code>_useableTrackLength</code> are used to set the parameters of these elements. <br><br>  In <b>CERangeSlider.m,</b> find the <code>initWithFrame:</code> and add the following code to the <code>if (self) { }</code> block: <br><br><pre> <code class="objectivec hljs">_trackLayer = [<span class="hljs-built_in"><span class="hljs-built_in">CALayer</span></span> layer]; _trackLayer.backgroundColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> blueColor].CGColor; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:_trackLayer]; _upperKnobLayer = [<span class="hljs-built_in"><span class="hljs-built_in">CALayer</span></span> layer]; _upperKnobLayer.backgroundColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> greenColor].CGColor; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:_upperKnobLayer]; _lowerKnobLayer = [<span class="hljs-built_in"><span class="hljs-built_in">CALayer</span></span> layer]; _lowerKnobLayer.backgroundColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> greenColor].CGColor; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:_lowerKnobLayer]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> setLayerFrames];</code> </pre><br>  This block of code creates three layers and adds them to the main one as children.  Now in the same file add the following methods: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) setLayerFrames { _trackLayer.frame = <span class="hljs-built_in"><span class="hljs-built_in">CGRectInset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds.size.height / <span class="hljs-number"><span class="hljs-number">3.5</span></span>); [_trackLayer setNeedsDisplay]; _knobWidth = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds.size.height; _useableTrackLength = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds.size.width - _knobWidth; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> upperKnobCentre = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> positionForValue:_upperValue]; _upperKnobLayer.frame = <span class="hljs-built_in"><span class="hljs-built_in">CGRectMake</span></span>(upperKnobCentre - _knobWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _knobWidth, _knobWidth); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lowerKnobCentre = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> positionForValue:_lowerValue]; _lowerKnobLayer.frame = <span class="hljs-built_in"><span class="hljs-built_in">CGRectMake</span></span>(lowerKnobCentre - _knobWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, _knobWidth, _knobWidth); [_upperKnobLayer setNeedsDisplay]; [_lowerKnobLayer setNeedsDisplay]; } - (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) positionForValue:(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)value { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _useableTrackLength * (value - _minimumValue) / (_maximumValue - _minimumValue) + (_knobWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre><br>  <code>setLayerFrames</code> sets sizes for both sliders and progress bars based on the current values ‚Äã‚Äãof the slider.  <code>positionForValue</code> binds the value to screen coordinates, using a simple proportion to scale the distance between the maximum and minimum values ‚Äã‚Äãof the component. <br><br>  Compile and run the application.  Your slider is starting to take shape!  It should look something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/554/cd1/55b/554cd155b8c30e03cb8f722735381843.png" alt="image"><br><br>  Although your component has acquired a form, the work is just beginning - after all, each control should provide the user with the ability to manage it.  In your case, the user should be able to move each slider, setting the required range.  You will track these changes and update both the properties of the component and its appearance based on their values. <br><br><h4>  Add the interactivity component </h4><br>  The code responsible for user interaction with the component should track which slider is being moved, and accordingly update the appearance.  The best place to do this will be the layers of our component. <br><br>  Add a new file to the <b>CERangeSlider</b> group: <b>New File -&gt; iOS -&gt; Cocoa Touch -&gt; Objective-C class</b> , make it a subclass of <code>CALayer</code> and name it <b>CERangeSliderKnobLayer</b> . <br><br>  Open the newly created <b>CERangeSliderKnobLayer.h</b> and replace its contents with the following: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QuartzCore/QuartzCore.h&gt;</span></span></span><span class="hljs-meta"> @class CERangeSlider; @interface CERangeSliderKnobLayer : CALayer @property BOOL highlighted; @property (weak) CERangeSlider* slider; @end</span></span></code> </pre><br>  This code adds two properties, one of which indicates whether the slider is highlighted and the other points to the parent slider.  Now open <b>CERangeSliderKnobLayer.m</b> and add <code>#import</code> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CERangeSliderKnobLayer.h"</span></span></span></span></code> </pre><br><br>  Then change the <code>_upperKnobLayer</code> and <code>_lowerKnobLayer</code> in the <code>@implementation</code> block: <br><br><pre> <code class="objectivec hljs">CERangeSliderKnobLayer* _upperKnobLayer; CERangeSliderKnobLayer* _lowerKnobLayer;</code> </pre><br>  These layers are now objects of the newly created class <b>CERangeSliderKnobLayer</b> . <br><br>  In the same <b>CERangeSlider.m,</b> find the <code>initWithFrame:</code> and replace the <code>upperKnobLayer</code> and <code>lowerKnobLayer</code> initialization code with the following code block: <br><br><pre> <code class="objectivec hljs">_upperKnobLayer = [CERangeSliderKnobLayer layer]; _upperKnobLayer.slider = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; _upperKnobLayer.backgroundColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> greenColor].CGColor; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:_upperKnobLayer]; _lowerKnobLayer = [CERangeSliderKnobLayer layer]; _lowerKnobLayer.slider = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; _lowerKnobLayer.backgroundColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> greenColor].CGColor; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:_lowerKnobLayer];</code> </pre><br>  This code uses the class we just created to initialize the layers and sets their <code>slider</code> property to <code>self</code> .  Run your project and make sure that everything looks the same as in the screenshot: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/636/43e/ca8/63643eca82d93e96a7718a7e671e63ef.png" alt="image"><br><br>  Now that your layers are in place, you need to implement the ability to move the sliders. <br><br><h4>  Add click handlers </h4><br>  Open <b>CERangeSlider.m</b> and add the following code under the variable declaration block: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> _previousTouchPoint;</code> </pre><br>  This variable will be used to track click coordinates.  And how do you plan to track various press and release events for your component? <br><br>  <code>UIControl</code> provides several methods for tracking clicks.  UIControl <code>UIControl</code> can override these methods to implement their own logic.  In your control, you override the following three methods: <code>beginTrackingWithTouch</code> , <code>continueTrackingWithTouch</code> and <code>endTrackingWithTouch</code> . <br><br>  Add the following method to <b>CERangeSlider.m</b> : <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)beginTrackingWithTouch:(<span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *)touch withEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event { _previousTouchPoint = [touch locationInView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// hit test the knob layers if(CGRectContainsPoint(_lowerKnobLayer.frame, _previousTouchPoint)) { _lowerKnobLayer.highlighted = YES; [_lowerKnobLayer setNeedsDisplay]; } else if(CGRectContainsPoint(_upperKnobLayer.frame, _previousTouchPoint)) { _upperKnobLayer.highlighted = YES; [_upperKnobLayer setNeedsDisplay]; } return _upperKnobLayer.highlighted || _lowerKnobLayer.highlighted; }</span></span></code> </pre><br>  This method is called when the user first touches the component.  It translates a click event into the component's coordinate system.  He then checks each slider to determine if the click falls within the scope of one of them.  As a result, the method informs its parent class about whether to track the current click. <br><br>  Push tracking continues if one of the sliders is highlighted.  Calling the <code>setNeedsDisplay</code> method allows <code>setNeedsDisplay</code> to make sure that the layers have been updated - then you will understand why this is important. <br><br>  Now that you have a first-click handler, you need to handle events when the user's finger moves across the screen.  Add the following method to <b>CERangeSlider.m</b> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define BOUND(VALUE, UPPER, LOWER) MIN(MAX(VALUE, LOWER), UPPER) - (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event { CGPoint touchPoint = [touch locationInView:self]; // 1. determine by how much the user has dragged float delta = touchPoint.x - _previousTouchPoint.x; float valueDelta = (_maximumValue - _minimumValue) * delta / _useableTrackLength; _previousTouchPoint = touchPoint; // 2. update the values if (_lowerKnobLayer.highlighted) { _lowerValue += valueDelta; _lowerValue = BOUND(_lowerValue, _upperValue, _minimumValue); } if (_upperKnobLayer.highlighted) { _upperValue += valueDelta; _upperValue = BOUND(_upperValue, _maximumValue, _lowerValue); } // 3. Update the UI state [CATransaction begin]; [CATransaction setDisableActions:YES] ; [self setLayerFrames]; [CATransaction commit]; return YES; }</span></span></code> </pre><br>  Let us analyze this code, comment by comment: <br><br><ol><li>  First, you calculate <code>delta</code> - the number of pixels on which the finger was moved.  Then you convert them depending on the minimum and maximum values ‚Äã‚Äãof the component. </li><li>  Here you change the upper and lower bound depending on where the user moved the slider.  Note that you use the <code>BOUND</code> macro, which is more readable than the <code>MIN/MAX</code> . </li><li>  This block of code sets the <code>disabledActions</code> flag in <code>CATransaction</code> .  This allows you to make sure that changes to the borders of each layer are applied immediately and are not animated.  At the end, the <code>setLayerFrames</code> method is <code>setLayerFrames</code> , moving the slider to the right place. </li></ol><br><br>  You have implemented a slider move - but you still need to handle the end of the interaction with the component.  Add the following method to <b>CERangeSlider.m</b> : <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)endTrackingWithTouch:(<span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *)touch withEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event { _lowerKnobLayer.highlighted = _upperKnobLayer.highlighted = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; [_lowerKnobLayer setNeedsDisplay]; [_upperKnobLayer setNeedsDisplay]; }</code> </pre><br>  This code returns both sliders to the inactive state.  Start your project and play a little with your new slider!  It should look the same as in the screenshot: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7dd/7dc/5bc/7dd7dc5bc298ced516320de041f28081.png" alt="image"><br><br>  You may notice that it is possible to move a finger beyond the boundaries of a component and then return to its boundaries without interrupting the execution of the method.  This is a very important feature of usability of devices with small screens and stylus with low accuracy (if you do not understand, then we are talking about fingers).  :] <br><br><h4>  Change Notifications </h4><br>  So, we have an interactive control with which the user can set the upper and lower limits of the range.  But how to associate these changes with the rest of the code so that they can be used by the application?  There are many different options that can be used for change notifications: <i>NSNotification</i> , <i>Key-Value-Observing (KVO)</i> , delegation pattern, Target-Action pattern, and others. <br><br>  If you look at the <code>UIKit</code> components, you will see that they do not use <i>NSNotification</i> or <i>KVO</i> , so for compatibility with <code>UIKit</code> we have to abandon these two options.  The other two templates - delegation and <i>Target-Action</i> - are very often used in <code>UIKit</code> . <br><br>  I will give a detailed analysis of both templates: <br><br><ul><li>  Using delegation, you create a protocol containing a variety of methods used for different notifications.  A component has a property, commonly referred to as delegate, that accepts any class that implements this protocol.  The classic example is UITableView, which provides the UITableViewDelegate protocol.  Note that controls can have only one delegate object.  A delegated method can take any number of parameters, so you can pass as much information as you need. </li><li>  The <i>Target-Action</i> pattern is implemented by the <code>UIControl</code> base class.  When the state of the component changes, the target <i>(target) is</i> notified of the action <i>(action)</i> , which is described by one of the enum values ‚Äã‚Äãof <code>UIControlEvents</code> .  You can provide multiple targets to control all actions, and although it is possible to add your own events ( <code>UIControlEventApplicationReserver</code> ), their number is limited to four.  These actions cannot transmit any information along with the event.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Therefore, they cannot be used to transmit additional data. </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The main differences between the two patterns are as follows: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Target-Action</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> template </font><font style="vertical-align: inherit;">broadcasts its changes, while delegation is limited to a single object.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You independently implement the protocols when using delegation, that is, you can determine what specific information you want to send. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Target-Action</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not allow the transfer of additional data.</font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Your component does not have as many possible states or possible events to be notified of. The only thing that plays a role is the maximum and minimum values ‚Äã‚Äãof the slider. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this situation, using the template </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Target-Action is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> most justified. This is one of the reasons why we inherited </font></font><code>UIControl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the very beginning of the lesson. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The slider readings are updated inside the method </font></font><code>continueTrackingWithTouch:withEvent:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so this is where the notification mechanism should be implemented. Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSlider.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , find the method </font></font><code>continueTrackingWithTouch:withEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and add the following code before </font></font><code>return YES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> sendActionsForControlEvents:<span class="hljs-built_in"><span class="hljs-built_in">UIControlEventValueChanged</span></span>];</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is all that is required of you in order to notify the desired goal of change. </font><font style="vertical-align: inherit;">Well, that was easier than expected! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CEViewController.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and add the following code to the end of the method </font></font><code>viewDidLoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="objectivec hljs">[_rangeSlider addTarget:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> action:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(slideValueChanged:) forControlEvents:<span class="hljs-built_in"><span class="hljs-built_in">UIControlEventValueChanged</span></span>];</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code runs the method </font></font><code>slideValueChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each time the slider sends an event </font></font><code>UIControlEventValueChanged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now add the following method to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CEViewController.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)slideValueChanged:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)control { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Slider value changed: (%.2f,%.2f)"</span></span>, _rangeSlider.lowerValue, _rangeSlider.upperValue); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method sends all slider values ‚Äã‚Äãto the log as proof that everything works as it should. </font><font style="vertical-align: inherit;">Launch the application and move the sliders. </font><font style="vertical-align: inherit;">You will see the coordinates values ‚Äã‚Äãdisplayed in the log: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/23d/6db/156/23d6db1568d6d71715c6c7322b49b7f7.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You are probably already tired of the multi-colored interface, similar to a terrible fruit salad. </font><font style="vertical-align: inherit;">It's time to give the component the right look!</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Change the appearance of a component using Core Graphics </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin, let's update the appearance of the progress bar, on which sliders move. </font><font style="vertical-align: inherit;">In the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSlider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> group </font><font style="vertical-align: inherit;">add a new class </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSliderTrackLayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is a subclass of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CALayer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSliderTrackLayer.h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and replace its contents with the following:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QuartzCore/QuartzCore.h&gt;</span></span></span><span class="hljs-meta"> @class CERangeSlider; @interface CERangeSliderTrackLayer : CALayer @property (weak) CERangeSlider* slider; @end</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code adds a link to the slider on the model of what we did for the slider layer. </font><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSlider.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and add the following </font></font><code>#import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CERangeSliderTrackLayer.h"</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just below find the variable </font></font><code>_trackLayer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and change its type to the class you just created:</font></font><br><br><pre> <code class="objectivec hljs">CERangeSliderTrackLayer* _trackLayer;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now find the method </font></font><code>initWithFrame:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and update the layer creation code:</font></font><br><br><pre> <code class="objectivec hljs">_trackLayer = [CERangeSliderTrackLayer layer]; _trackLayer.slider = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:_trackLayer]; _upperKnobLayer = [CERangeSliderKnobLayer layer]; _upperKnobLayer.slider = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:_upperKnobLayer]; _lowerKnobLayer = [CERangeSliderKnobLayer layer]; _lowerKnobLayer.slider = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.layer addSublayer:_lowerKnobLayer];</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code allows you to make sure that a new stripe is used, and the vivid colors no longer apply to the background. </font><font style="vertical-align: inherit;">:] It </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remains to do a little more - remove the red background from the component. </font><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CEViewController.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , find the following line of code in the method </font></font><code>viewDidLoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and delete it:</font></font><br><br><pre> <code class="objectivec hljs">_rangeSlider.backgroundColor = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> redColor];</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Build and run the application ... What do you see? </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/108/d48/9e6/108d489e63772ab63b52532a32d9c29d.png" alt="image"><br><br>  Nothing?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's great! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You ask - what's great about it? All the fruits of hard work are gone! Do not worry - you just removed the bright colors that were applied to the layers used. Your component is still in place - but now it is transparent. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since most developers like when the components can be customized to the style of each particular application, we will add several properties that are responsible for the appearance of our slider. Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSlider.h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and add the following code:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>* trackColour; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>* trackHighlightColour; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>* knobColour; <span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> curvaceousness; - (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) positionForValue:(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)value;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The purpose of the various color properties is quite obvious. </font><font style="vertical-align: inherit;">As for </font></font><code>curvaceousness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- learn a little later. </font><font style="vertical-align: inherit;">And finally </font></font><code>positionForValue:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We have already managed to implement this method, and now we are making it available to various layers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need to add initial values ‚Äã‚Äãfor color properties. </font><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSlider.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and add the following code to the method </font></font><code>initWithFrame:,</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">under the code block responsible for initializing the remaining variables:</font></font><br><br><pre> <code class="objectivec hljs">_trackHighlightColour = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> colorWithRed:<span class="hljs-number"><span class="hljs-number">0.0</span></span> green:<span class="hljs-number"><span class="hljs-number">0.45</span></span> blue:<span class="hljs-number"><span class="hljs-number">0.94</span></span> alpha:<span class="hljs-number"><span class="hljs-number">1.0</span></span>]; _trackColour = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> colorWithWhite:<span class="hljs-number"><span class="hljs-number">0.9</span></span> alpha:<span class="hljs-number"><span class="hljs-number">1.0</span></span>]; _knobColour = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> whiteColor]; _curvaceousness = <span class="hljs-number"><span class="hljs-number">1.0</span></span>; _maximumValue = <span class="hljs-number"><span class="hljs-number">10.0</span></span>; _minimumValue = <span class="hljs-number"><span class="hljs-number">0.0</span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSliderTrackLayer.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and add the following </font></font><code>#import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CERangeSlider.h"</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This layer displays a bar on which both sliders are located. </font><font style="vertical-align: inherit;">At the moment, it inherits a class </font></font><code>CALayer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that makes it possible to use only solid color. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to draw the strip correctly, you need to implement the method </font></font><code>drawInContext:</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and use the CoreGraphics API for rendering.</font></font><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you want to learn more about Core Graphics, then the </font></font><a href="http://www.raywenderlich.com/2033/core-graphics-tutorial-for-ios-lines-rectangles-and-gradients"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Core Graphics 101 tutorial series</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> course is recommended </font><font style="vertical-align: inherit;">, since a detailed review of Core Graphics is beyond the scope of this lesson.</font></font></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Add the following method to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSliderTrackLayer.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> under </font></font><code>@implementation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)drawInContext:(<span class="hljs-built_in"><span class="hljs-built_in">CGContextRef</span></span>)ctx { <span class="hljs-comment"><span class="hljs-comment">// clip float cornerRadius = self.bounds.size.height * self.slider.curvaceousness / 2.0; UIBezierPath *switchOutline = [UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:cornerRadius]; CGContextAddPath(ctx, switchOutline.CGPath); CGContextClip(ctx); // 1) fill the track CGContextSetFillColorWithColor(ctx, self.slider.trackColour.CGColor); CGContextAddPath(ctx, switchOutline.CGPath); CGContextFillPath(ctx); // 2) fill the highlighed range CGContextSetFillColorWithColor(ctx, self.slider.trackHighlightColour.CGColor); float lower = [self.slider positionForValue:self.slider.lowerValue]; float upper = [self.slider positionForValue:self.slider.upperValue]; CGContextFillRect(ctx, CGRectMake(lower, 0, upper - lower, self.bounds.size.height)); // 3) add a highlight over the track CGRect highlight = CGRectMake(cornerRadius/2, self.bounds.size.height/2, self.bounds.size.width - cornerRadius, self.bounds.size.height/2); UIBezierPath *highlightPath = [UIBezierPath bezierPathWithRoundedRect:highlight cornerRadius:highlight.size.height * self.slider.curvaceousness / 2.0]; CGContextAddPath(ctx, highlightPath.CGPath); CGContextSetFillColorWithColor(ctx, [UIColor colorWithWhite:1.0 alpha:0.4].CGColor); CGContextFillPath(ctx); // 4) inner shadow CGContextSetShadowWithColor(ctx, CGSizeMake(0, 2.0), 3.0, [UIColor grayColor].CGColor); CGContextAddPath(ctx, switchOutline.CGPath); CGContextSetStrokeColorWithColor(ctx, [UIColor grayColor].CGColor); CGContextStrokePath(ctx); // 5) outline the track CGContextAddPath(ctx, switchOutline.CGPath); CGContextSetStrokeColorWithColor(ctx, [UIColor blackColor].CGColor); CGContextSetLineWidth(ctx, 0.5); CGContextStrokePath(ctx); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this image you can see how all blocks of code are combined, separated by comments: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/575/0b5/18b/5750b518b43743593ff3bcb2f3eb12d3.jpg" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numbered sections correspond to numbered comments:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After the strip shape is drawn, its background is filled. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The selected range is highlighted. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Additional lighting is added to give the strip a volume. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The shadow is drawn. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drawn volumetric edges of the strip. </font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that everything is in steps, you can see how the various properties of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSlider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> affect its appearance.</font></font><br><br>  Run the application.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should look like this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5c/65c/81d/e5c65c81d2fdf108501852c51e1a9fe9.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Play around with the values ‚Äã‚Äãof the properties we entered to see how they affect the appearance of the slider. </font><font style="vertical-align: inherit;">If you are still curious about what the property is doing </font></font><code>curvaceousness</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, now is the time to try it! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To draw the sliders, we will use a similar approach. </font><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSliderKnobLayer.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and add the following </font></font><code>#import</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"CERangeSlider.h"</span></span></span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Add the following method: </font></font><br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)drawInContext:(<span class="hljs-built_in"><span class="hljs-built_in">CGContextRef</span></span>)ctx { <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span> knobFrame = <span class="hljs-built_in"><span class="hljs-built_in">CGRectInset</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.bounds, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> *knobPath = [<span class="hljs-built_in"><span class="hljs-built_in">UIBezierPath</span></span> bezierPathWithRoundedRect:knobFrame cornerRadius:knobFrame.size.height * <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.slider.curvaceousness / <span class="hljs-number"><span class="hljs-number">2.0</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// 1) fill - with a subtle shadow CGContextSetShadowWithColor(ctx, CGSizeMake(0, 1), 1.0, [UIColor grayColor].CGColor); CGContextSetFillColorWithColor(ctx, self.slider.knobColour.CGColor); CGContextAddPath(ctx, knobPath.CGPath); CGContextFillPath(ctx); // 2) outline CGContextSetStrokeColorWithColor(ctx, [UIColor grayColor].CGColor); CGContextSetLineWidth(ctx, 0.5); CGContextAddPath(ctx, knobPath.CGPath); CGContextStrokePath(ctx); // 3) inner gradient CGRect rect = CGRectInset(knobFrame, 2.0, 2.0); UIBezierPath *clipPath = [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:rect.size.height * self.slider.curvaceousness / 2.0]; CGGradientRef myGradient; CGColorSpaceRef myColorspace; size_t num_locations = 2; CGFloat locations[2] = { 0.0, 1.0 }; CGFloat components[8] = { 0.0, 0.0, 0.0 , 0.15, // Start color 0.0, 0.0, 0.0, 0.05 }; // End color myColorspace = CGColorSpaceCreateDeviceRGB(); myGradient = CGGradientCreateWithColorComponents (myColorspace, components, locations, num_locations); CGPoint startPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMinY(rect)); CGPoint endPoint = CGPointMake(CGRectGetMidX(rect), CGRectGetMaxY(rect)); CGContextSaveGState(ctx); CGContextAddPath(ctx, clipPath .CGPath); CGContextClip(ctx); CGContextDrawLinearGradient(ctx, myGradient, startPoint, endPoint, 0); CGGradientRelease(myGradient); CGColorSpaceRelease(myColorspace); CGContextRestoreGState(ctx); // 4) highlight if (self.highlighted) { // fill CGContextSetFillColorWithColor(ctx, [UIColor colorWithWhite:0.0 alpha:0.1].CGColor); CGContextAddPath(ctx, knobPath.CGPath); CGContextFillPath(ctx); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Again analyze the results of this method: </font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As soon as the shape of the sliders is ready, their background is filled. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Next, draw the borders of the slider. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A light gradient is added. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the last thing - if the slider is highlighted - it remains so, if you move it - it becomes gray. </font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Run the application again: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/06a/dee/f9c/06adeef9cffd843145a2323da82eeaba.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You see that drawing a component with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Core Graphics is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> worth the effort. </font><font style="vertical-align: inherit;">Using this framework allows you to create a much more customizable and flexible control than with the use of graphic resources.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We process changes of properties of a component </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So what do we have to do? The component looks quite catchy, the appearance is fully customizable and it supports the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Target-Action</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pattern </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Think about what will happen if one of the slider properties is changed in the application code after it is drawn on the screen. For example, you may want to change the range of values ‚Äã‚Äãof the slider or change the backlight slider. At the moment, support for these features is not implemented. You need to add this to your code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To determine which component properties are set externally, you will need to write your </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. Your first guess will most likely be this code:</font></font><br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setTrackColour:(<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> *)trackColour { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_trackColour != trackColour) { _trackColour = trackColour; [_trackLayer setNeedsDisplay]; } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a property changes </font></font><code>trackColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, this block of code notifies the slider bar layer that it needs to be updated. </font><font style="vertical-align: inherit;">But, given the fact that eight variables are used in the slider API, rewriting the same code so many times is not the best solution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looks like being able to use macros! </font><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSlider.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and add the following code above the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initWithFrame method</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define GENERATE_SETTER(PROPERTY, TYPE, SETTER, UPDATER) \ - (void)SETTER:(TYPE)PROPERTY { \ if (_##PROPERTY != PROPERTY) { \ _##PROPERTY = PROPERTY; \ [self UPDATER]; \ } \ }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This code block defines a macro that takes four parameters and uses them to generate a synthesized property and its </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Under this code, add another block:</font></font><br><br><pre> <code class="objectivec hljs">GENERATE_SETTER(trackHighlightColour, <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>*, setTrackHighlightColour, redrawLayers) GENERATE_SETTER(trackColour, <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>*, setTrackColour, redrawLayers) GENERATE_SETTER(curvaceousness, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, setCurvaceousness, redrawLayers) GENERATE_SETTER(knobColour, <span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span>*, setKnobColour, redrawLayers) GENERATE_SETTER(maximumValue, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, setMaximumValue, setLayerFrames) GENERATE_SETTER(minimumValue, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, setMinimumValue, setLayerFrames) GENERATE_SETTER(lowerValue, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, setLowerValue, setLayerFrames) GENERATE_SETTER(upperValue, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>, setUpperValue, setLayerFrames) - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) redrawLayers { [_upperKnobLayer setNeedsDisplay]; [_lowerKnobLayer setNeedsDisplay]; [_trackLayer setNeedsDisplay]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We generate </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> methods </font><font style="vertical-align: inherit;">for all variables in one fell swoop. </font><font style="vertical-align: inherit;">The method </font></font><code>redrawLayers</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is called for the variables associated with the appearance of the component, and </font></font><code>setLayerFrames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for those responsible for the markup. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is all that is required for the slider to react adequately to changes in its properties. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anyway, you need to add some more code in order to test new macros and be sure that everything works as it should. </font><font style="vertical-align: inherit;">Open </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CEViewController.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and add the following code to the end of the method </font></font><code>viewDidLoad</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> performSelector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(updateState) withObject:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> afterDelay:<span class="hljs-number"><span class="hljs-number">1.0</span></span>f];</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This line will call the method </font></font><code>updateState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after the second delay. </font><font style="vertical-align: inherit;">Add this method to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CEViewController.m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)updateState { _rangeSlider.trackHighlightColour = [<span class="hljs-built_in"><span class="hljs-built_in">UIColor</span></span> redColor]; _rangeSlider.curvaceousness = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This method changes the color of the bar from blue to red, and the shape of the sliders to square. </font><font style="vertical-align: inherit;">Run the project and see how the slider changes its shape from this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/917/14c/9be/91714c9be56e659c46907d12e65b9667.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to this:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8c6/572/d66/8c6572d669e108d52ed36cfa38593705.png" alt="image"><br><br><blockquote> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The code that you just added clearly illustrates one of the most interesting (and, by the way, often forgotten by developers) sides of the development of custom components - their testing. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you develop your control, check all possible values ‚Äã‚Äãof its properties and their influence on the appearance of the component - your responsibility. </font><font style="vertical-align: inherit;">A good way would be to add several buttons and sliders, each of which is responsible for some property of the component. </font><font style="vertical-align: inherit;">This way, it will be possible to test the control without being distracted by changing the code.</font></font></blockquote><br><br><h4>  What's next? </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now your slider is fully functional and ready to use in any applications! One of the key advantages of custom components is the possibility of using them in various applications by various developers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, are you ready for the premiere of your slider?</font></font><br><br>  Not really.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to complete several tasks: </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Favorite occupation of each programmer. :] Although you think that your code is perfect and does not require additional documentation, the opinion of other developers may be completely different. A good practice is to have documentation for everything that is open to other developers. At a minimum, this is a description of all publicly available classes and their properties. For example, your </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CERangeSlider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requires the following documents - an explanation of purpose variables </font></font><code>max</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>min</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>upper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>lower</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reliability.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happens if you set a value </font></font><code>upperValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">greater than</font></font><code>maximumValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Of course, you yourself will never do this - it is at least silly. But you can not guarantee that someone else will try! You need to make sure that the component is always working properly - regardless of the level of developer nonsense. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API structure</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The previous item on reliability is closely related to a much broader topic - the structure of the API. Creating a flexible, intuitive and reliable structure will help the component to become widely used and popular. In my company, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ShinobiControls</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we can spend hours discussing every small detail of our API! The API structure is a very deep topic that goes beyond the scope of this lesson. If this topic has become interesting to you, I recommend reading </font></font><a href="http://mattgemmell.com/api-design/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matt Gemmell's 25 rules of API design</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many places where you can start distributing your component. </font><font style="vertical-align: inherit;">Here are a few options:</font></font><br><br><ul><li>  <a href="https://github.com/">Github</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub has become one of the most popular platforms for hosting open source components. </font><font style="vertical-align: inherit;">Now on GitHub presented countless different controls for iOS. </font><font style="vertical-align: inherit;">What is especially good about GitHub is that it allows you to quickly and conveniently view the component's code, use it in other projects, and leave various comments.</font></font></li><li> <a href="http://cocoapods.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CocoaPods</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">To allow people to easily add your component to your project, you can add it to CocoaPods, the extension manager for iOS and OSX.</font></font></li><li> <a href="http://www.cocoacontrols.com/">Cocoa Controls</a> .    ,    .        GitHub,      . </li><li> <a href="http://www.binpress.com/">Binpress</a> .    ,     .          ,    ‚Äî          ?  , , -          API. </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope you were interested in developing a custom control, and perhaps you were inspired by the idea of ‚Äã‚Äãcreating your own component. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The source code for the project is </font></font><a href="https://github.com/ColinEberhardt/CERangeSlider"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">published on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with a commit history corresponding to the development stages. </font><font style="vertical-align: inherit;">If you get lost, you can easily continue working from the last completed stage! </font><font style="vertical-align: inherit;">:] </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can download the whole project </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via this link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div><p>Source: <a href="https://habr.com/ru/post/212111/">https://habr.com/ru/post/212111/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212101/index.html">Cross-platform https server with non-blocking sockets. Part 3</a></li>
<li><a href="../212103/index.html">Web Analytics Popularity</a></li>
<li><a href="../212105/index.html">Tim Berners-Lee: we need to decentralize the Internet again</a></li>
<li><a href="../212107/index.html">Creating a simple Chrome application</a></li>
<li><a href="../212109/index.html">Godot game engine put into public use</a></li>
<li><a href="../212113/index.html">Date.prototype.getTimezoneOffset - the difference in return values ‚Äã‚Äãin different browsers</a></li>
<li><a href="../212115/index.html">C ++ IDE from JetBrains: when?</a></li>
<li><a href="../212117/index.html">Bitcoin protocol feature that led to delays in Mtgox pinouts and general commotion</a></li>
<li><a href="../212119/index.html">4 billion rubles for an intelligent video surveillance system for the Moscow Metro</a></li>
<li><a href="../212121/index.html">Classic Scala Design Patterns</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>