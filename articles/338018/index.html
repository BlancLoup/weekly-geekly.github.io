<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QuadBraces III</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good health to all! 

 It has been almost exactly two years since my first publication on the QuadBraces parser , an MODX Evolution alternative for th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QuadBraces III</h1><div class="post__text post__text-html js-mediator-article">  Good health to all! <br><br>  It has been almost exactly two years since my <a href="https://habrahabr.ru/post/266865/">first publication on the QuadBraces parser</a> , an MODX Evolution alternative for the simplest projects that require standardization.  These can be single pages with typical publications, portfolios, business cards, consisting of almost static pages, and so on.  Since then, I updated my development and unnoticed by the community crawled to the third version.  The current version of the QuadBraces parser contains so many changes that I just have to publish a detailed tutorial.  So‚Ä¶ <br><a name="habracut"></a><br><h2>  Tags </h2><br>  Let's start with tag handlers.  In QuadBraces, 3 tag handlers are rendered into separate classes.  Now the developer is free to define his tag types without changing the code of the parser itself.  To do this, create a descendant of the QuadBracesTagPrototype class, where you need to define the following: <br><br><ul><li>  <b>$ _name</b> - tag name </li><li>  <b>$ _start</b> - initial tag sequence </li><li>  <b>$ _rstart</b> is the initial tag sequence for the MODX Revolution syntax mode.  Without square brackets. </li><li>  <b>$ _finish</b> - final tag sequence </li><li>  <b>$ _order</b> - optional;  processing order </li><li>  <b>function main (array $ m, $ key = '')</b> - a function that returns the result of processing the tag.  $ m - data of PCRE-regular, key (most important) - key of the found tag. </li></ul><br>  On the example of a constant tag handler: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuadBracesTagConstant</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuadBracesTagPrototype</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_name = <span class="hljs-string"><span class="hljs-string">'constant'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_start = <span class="hljs-string"><span class="hljs-string">'\{\*'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_rstart = <span class="hljs-string"><span class="hljs-string">'\/'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_finish = <span class="hljs-string"><span class="hljs-string">'\*\}'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $_order = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(array $m,$key=</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ $v = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>($key) || !defined($key)) { <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;_error = <span class="hljs-string"><span class="hljs-string">'not found'</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { $v = constant($key); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $v; } }</code> </pre> <br>  Yeah, right - everything is just that simple.  Although I, as a programmer of the old school, are terribly enraged by the need to store files of microscopic size.  But this is a personal matter, as they say. <br><br>  For those who have not read the previous publication.  The syntax of QuadBraces tags is the same for all tag types: <br><br><ol><li>  The initial sequence of characters.  For example, "{{". </li><li>  Entity ID.  It should consist of Latin, numerals, "logs", a dash and / or a dot.  For example, "my-chunk".  Note!  The point in the identifier plays the role of a nesting level separator.  That is, looking ahead, for example, the variable "my.var" will be located in fact here - $ parser-&gt; data ['my'] ['var'].  About chunks, snippets and templates - below. </li><li>  A number of handler extensions (optional).  Each is a construction of the form ": some_id" or ": some_id =` some_data` "(without a space between the colon and the identifier).  Handler extensions work with the end result of tag processing.  That is, for example, we received a variable containing a phone number, and then formatted it for human comprehension. </li><li>  For compatibility with the MODX syntax, a question mark may follow. </li><li>  A certain number of arguments (optional).  Each argument is a construction of the form "&amp; some_name =` certain_value` ".  Yes, variables can even have arguments.  Yes, they work.  In most cases, the arguments passed are used in local placeholders. </li><li>  The final sequence of characters.  For example, "}}". </li></ol><br>  In the third version of the parser, as you probably already understood, there is a MODX Revolution syntax mode.  In this mode, tags start with two opening square brackets, followed by some symbol that defines the type of tag.  And the tag is always closed with two closing square brackets. <br><br>  An example of a certain chunk tag: <br><br><pre> <code class="xml hljs">{{news-item? &amp;title=`   ` &amp;date=`15-09-17` &amp;url=`/news/150917.html`}}</code> </pre> <br>  If the chunk is: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span>[+title+]<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"date"</span></span></span><span class="hljs-tag">&gt;</span></span>[+date+]<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"[+url+]"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Then, as a result, on the site of the chunk will be displayed: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"date"</span></span></span><span class="hljs-tag">&gt;</span></span>15-09-17<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/news/150917.html"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  <i>Speaking of flies.</i>  <i>Didn‚Äôt they eat the HTML item from the ‚Äúsource code‚Äù menu of the editor in our Cozy?</i> <br><br>  Out of the box, QuadBraces supports the following types of tags (the starting and ending sequences for two modes are indicated): <br><br><ul><li>  <b>[+ +]</b> or <b>[[+]]</b> - <b>Local variables</b> .  In most cases, are used for variable snippets, in cycles.  When setting the arguments of any element, except for snippets, the local placeholders of the element are replaced by the values ‚Äã‚Äãfrom the arguments. </li><li>  <b>{{}}</b> or <b>[[$]]</b> - <b>Chunks</b> .  Pieces of html code.  One file contains one chunk.  One of the main elements of templating. </li><li>  <b>{[]}</b> or <b>[[-]]</b> - <b>Single-line library chunks</b> .  Pieces of html code.  One file contains several chunks.  Each row contains one chunk. </li><li>  <b>{()}</b> or <b>[[=]]</b> - <b>Multiline library chunks</b> .  Pieces of html code.  One file contains several chunks.  Chunks are separated by the construction: "&lt;! - tags: splitter -&gt;" </li><li>  <b>{* *}</b> or <b>[[/]]</b> - <b>PHP Constants</b> .  Display the PHP constants defined in the system (including the user). </li><li>  <b>[()]</b> or <b>[[++]]</b> - <b>Settings</b> .  Variables from the SETTINGS array.  Usually used to display CMS variables using a parser. </li><li>  <b>[* *]</b> or <b>[[*]]</b> - <b>Variables</b> .  Parser variables  One of the main elements of templating. </li><li>  <b>[^ ^]</b> or <b>[[^]]</b> - <b>Debug data</b> .  Parser debug data. </li><li>  <b>[%%]</b> or <b>[[%]]</b> - <b>Language variables</b> .  Vocabulary variables.  Replaced depending on the current language when the language system is enabled. </li><li>  <b>[!</b>  <b>!]</b> or <b>[[!</b>  <b>]]</b> - <b>Snippies</b> .  Essentially pieces of PHP code. </li><li>  <b>[[]]</b> or <b>[[]]</b> - <b>Snippeta with caching flag</b> .  Same as above, only with the caching flag set.  Roughly speaking, the $ cached argument with the value true is passed to the execute function of the parser. </li><li>  <b>[~ ~]</b> or <b>[[~]]</b> - <b>Links from resource identifiers</b> .  Turn the number placed inside the link to the resource.  About resources below. </li><li>  <b>[::]</b> or <b>[[:]]</b> - <b>Custom variable handlers</b> .  About them separately. </li></ul><br>  In the current version of the parser, it is possible to cram a so-called set into the parser object.  resources.  In essence, this is about the same as the resources in MODX.  Roughly speaking, a table is stored in the database of the final project, in which the entries with posts for the blog are stored.  The main thing is to remember that each entry must contain a numeric ID, a parent ID or NULL and an alias for creating a URL.  Setting the resources property of the parser object sets the idx property of the parser object.  It is an index of the branches of the resource tree.  This allows you to work with the structure of the final set of resources.  Actually, the link tag works with all this <s>garbage</s> functionality. <br><br>  Custom variable handlers are such micro-parsers that arbitrarily process parser variables.  For example, if a certain variable of the parser (let's call it, say, top-menu) contains an array with URLs of the form: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/'</span></span>,<span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">''</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/about.html'</span></span>,<span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">' '</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'url'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/news/'</span></span>,<span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">''</span></span>,<span class="hljs-string"><span class="hljs-string">'children'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/news/10-09-17.html'</span></span>,<span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'   '</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/news/15-09-17.html'</span></span>,<span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'   '</span></span>) ) ), <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'url'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/contacts.html'</span></span>,<span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">''</span></span>), );</code> </pre> <br>  From it you can make a menu.  To do this, it is enough to place the structure in the right place: <br><br><pre> <code class="xml hljs">[:menu@top-menu:]</code> </pre> <br>  In its place will be displayed menu with the help of bulleted lists.  In the best traditions of Wayfinder, so to speak. <br><br>  In general, on custom handlers, I think, you will need to write a separate article. <br><br>  Separately, about one important piece of templates, namely about the metafield.  Almost from the first version, it is possible to set meta fields in the template code.  They are essentially variables defined in the template itself by this construction: <br><br> <code>&lt;!-- FIELD:_? [] --&gt;</code> <br> <br>  Arguments are about the same as in parser tags.  Regardless of which arguments will be specified in the field, the final field will contain three attributes: <br><br><ul><li>  default (text) is the default </li><li>  type (integer) - type </li><li>  caption (string) - header </li></ul><br>  All metafields will be available through the parser's fields property. <br><br>  Meta values ‚Äã‚Äãare no less important.  Imagine that in our parser the variable somevar is defined.  The meta value in the set pattern can override the current value of the variable.  Meta values ‚Äã‚Äãare determined by the construction: <br><br> <code>&lt;!-- DATA:_ ` ` --&gt;</code> <br> <br>  When a template is installed, both are removed from the final template code. <br><br><h2>  Class API </h2><br><h3>  Class properties (most important) </h3>  : <br><ul><li>  <b>owner</b> (object) - object owner (read only; set during initialization); </li><li>  <b>paths</b> (array) - pattern paths;  can be set as an array, it can be a string, where comma-separated paths are listed; </li><li>  <b>fields</b> (array) - template fields (read only); </li><li>  <b>data</b> (array) - variable parsers; </li><li>  <b>settings</b> (array) - "settings"; </li><li>  <b>debug</b> (array) - debug data; </li><li>  <b>language</b> (string) - current language;  signature according to generally accepted standards; </li><li>  <b>loadLanguage</b> (flag) - autoloading of the language (false by default); </li><li>  <b>dictionary</b> (array) - the current dictionary;  can be set by raw text, divided into lines; </li><li>  <b>maxLevel</b> (integer) - the maximum level of nesting (by default 32); </li><li>  <b>level</b> (integer) - current level; </li><li>  <b>notice</b> (array) - the level of notifications;  understands the meaning of "strict" - all elements, "common" (by default) - chunks and snippets. </li><li>  <b>template</b> (text) - template;  when setting to specify the name, returns the contents; </li><li>  <b>templateName</b> (string) - the name of the current template (read only); </li><li>  <b>autoTemplate</b> (flag) - flag of automatic extraction and installation of a template from installed content;  roughly speaking, if the flag is enabled to feed content to the parser with the template metafield, the parser will automatically install the template (false by default); </li><li>  <b>content</b> (text) - content;  in general, essentially a variable called "content"; </li><li>  <b>resources</b> (array) - an array of resources; </li><li>  <b>idx</b> (array) - index of the branches of the resource tree (read only); </li><li>  <b>SEOStrict</b> (flag) - compliance with SEOStrict standards (false by default); </li><li>  <b>MODXRevoMode</b> (flag) - switch to the MODX Revolution syntax mode (false by default); </li></ul><br><h3>  Methods </h3>  : <br><ul><li>  <b>registerTag (QuadBracesTagPrototype $ o)</b> - registration tag;  accepts an initialized tag;  returns the registered tag; </li><li>  <b>parseStart ($ m)</b> - start processing;  accepts input from the preg_match_callback function;  returns item key; </li><li>  <b>parseFinish ($ m, $ t, $ k, $ v)</b> - end of processing;  accepts input from regular data, tag type, tag key, current processing value;  returns the processed result; </li><li>  <b>setting ($ key, $ value = null)</b> - read / write settings;  if null, read; </li><li>  <b>variable ($ key, $ value = null)</b> - read / write variable;  if null, read; </li><li>  <b>search ($ type, $ name)</b> - search for the item file;  takes into account localization;  returns the name of the found file; </li><li>  <b>setTemplate ($ v)</b> - set the template by name;  a very necessary method when working with callbacks for setting a template; </li><li>  <b>getChunk ($ key, $ type = 'chunk')</b> - getting the contents of the chunk;  returns the contents of the found chunk or false; </li><li>  <b>execute ($ name, $ args = array (), $ input = '', $ cached = false)</b> - execute a snippet or extension;  accepts a snippet name, arguments, input text and caching flag;  returns the result of processing; </li><li>  <b>parse ($ t = '', $ d = null, $ e = '', $ k = '')</b> - the main method of the parser is processing;  there is no need to set arguments for processing the entire template;  arguments are needed for internal needs or discrete processing (a piece of code QuadBraces);  input arguments - input code, data variables, element, key element;  output - processed data; </li><li>  <b>sanitize ($ t = '')</b> - sanitizes the input code from QuadBraces; </li><li>  <b>extensions ($ v, $ e)</b> - the implementation of extensions;  input - current code and string with extensions; </li><li>  <b>registerEvent ($ n, $ f)</b> - event registration;  at the entrance - the name of the event and the function; </li><li>  <b>registerMethod ($ n, $ f)</b> - register API method;  at the entrance - the name of the method and the function; </li><li>  <b>invoke ()</b> - call the event;  the first argument is the name of the event, the rest is the call arguments; </li></ul><br><h2>  Where to look? </h2><br>  One of the most important properties of the QuadBraces parser is the paths property.  It determines where the parser will look for chunks, snippets, extensions, templates.  The language system works a bit isolated.  In the process of searching for an element, the parser iterates through all the registered paths.  Each time, the search function adds a folder to the selected path, depending on the type of item.  Chunks - chunks, templates - snippets - snippets.  And already there is searched for the desired item.  I recall that the dot in the keys of the chunks, snippets and templates in fact replaces the directory separator. <br><br>  Example: <br><br><pre> <code class="php hljs">$parser-&gt;paths = <span class="hljs-string"><span class="hljs-string">'D:/projects/mysite/content,D:/repo/templates/default'</span></span>; $fn = $parser-&gt;search(<span class="hljs-string"><span class="hljs-string">'snippet'</span></span>,<span class="hljs-string"><span class="hljs-string">'basis.snipcon'</span></span>);</code> </pre> <br>  In fact, the parser in this case will check for the existence of the following files: <br><br> <code>D:/projects/mysite/content/snippets/basis/snipcon.php <br> D:/repo/templates/default/snippets/basis/snipcon.php</code> <br> <br>  The last found file will be returned.  When the language system is enabled, paths with language signatures are actually added to the search.  Suppose the installed language is Russian, that is, the signature is ‚Äúru‚Äù.  Thus the file list is as follows: <br><br> <code>D:/projects/mysite/content/snippets/basis/snipcon.php <br> D:/projects/mysite/content/snippets/basis/ru/snipcon.php <br> D:/repo/templates/default/snippets/basis/snipcon.php <br> D:/repo/templates/default/snippets/basis/ru/snipcon.php</code> <br> <br>  Everything else is obtained through properties and methods. <br><br><h2>  Language system </h2><br>  First, at once I will make a reservation that the language system should be included explicitly.  This is done by connecting the QuadBracesLang class.  This is done with the simplest code <u>before the</u> main class includes: <br><br><pre> <code class="php hljs">define(<span class="hljs-string"><span class="hljs-string">"QUADBRACES_LOCALIZED"</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>);</code> </pre> <br>  It is best to enable the loadLanguage flag.  Then the dictionaries will be loaded automatically.  In principle, by default, when installing parser paths, the paths of the language system are set.  In fact, the language system is looking for its files on the same principle as the search engine of elements.  Only the language system folder is lang. <br><br>  Example: <br><br><pre> <code class="php hljs">$parser-&gt;paths = <span class="hljs-string"><span class="hljs-string">'D:/projects/mysite/content,D:/repo/templates/default'</span></span>; $parser-&gt;language = <span class="hljs-string"><span class="hljs-string">'ru'</span></span>;</code> </pre> <br>  Folders will be scanned: <br><br> <code>D:/projects/mysite/content/lang/ru/ <br> D:/repo/templates/default/lang/ru/</code> <br> <br>  In this, all files with the extension ‚Äúlng‚Äù will be searched.  Each file is read line by line.  Each line contains four elements - a language key, title, description, placeholder.  The language key is what is later used in the language tag.  Caption - replaces the default language tag.  Description (description) - usually used for hints or descriptions of fields.  Placeholder (placeholder) - most often used for the corresponding attribute of input elements. <br><br><h2>  Developments </h2><br>  The parser object supports events.  Handlers, as I wrote above, are installed by the registerEvent method. <br><br><h3>  Supported events (everywhere $ p is a parser object): </h3><br><ul><li>  <b>init ($ p)</b> - Completion of the constructor; </li><li>  <b>beforeChangeData ($ v, $ p)</b> - Before changing these variables;  $ v - settable variables; </li><li>  <b>changeData ($ v, $ p)</b> - Change of data variables;  $ v - settable variables; </li><li>  <b>beforeChangeSettings ($ v, $ p)</b> - Before changing these settings;  $ v - set options; </li><li>  <b>changeSettings ($ v, $ p)</b> - Change settings data;  $ v - set options; </li><li>  <b>beforeLoadDictionary ($ v, $ p)</b> - Before the dictionary is loaded;  $ v - dictionary; </li><li>  <b>loadDictionary ($ v, $ p)</b> - Download dictionary;  $ v - dictionary; </li><li>  <b>methodNotFound ($ n, $ p)</b> - Method not found;  $ n - Name of the method; </li><li>  <b>beforeSetLanguage ($ v, $ p)</b> - Before setting the language;  $ v - language; </li><li>  <b>setLanguage ($ v, $ p)</b> - When setting the language;  $ v - language; </li><li>  <b>setContent ($ v, $ p)</b> - When setting content;  $ v - content; </li><li>  <b>setResources ($ v, $ p)</b> - When setting resources;  $ v - resource data; </li><li>  <b>invalidHandler ($ n, $ a, $ p)</b> - In the absence of an event handler;  $ n is the name of the handler, $ a is the arguments passed; </li><li>  <b>setResources ($ v, $ p)</b> - When setting resources;  $ v - resource data; </li><li>  <b>defaultTemplate ($ p)</b> - Default template (attempt to set an empty template); </li><li>  <b>loadTemplate ($ v, $ p)</b> - When the template is installed;  $ v - the name of the template; </li><li>  <b>templateMotFound ($ v, $ p)</b> - In the absence of a template;  $ v - the name of the template; </li><li>  <b>templateFields ($ v, $ p)</b> - Get template fields;  $ v - template fields; </li><li>  <b>templateData ($ v, $ p)</b> - Receive template data;  $ v - template data; </li><li>  <b>beforeLocalParse ($ v, $ d, $ p)</b> - Before local processing;  $ v - processed code, $ d - data; </li><li>  <b>beforeParse ($ v, $ p)</b> - Before processing;  $ v - processed code; </li><li>  <b>localParse ($ v, $ p)</b> - After processing the local template (before sanitizing);  $ v - processed code; </li><li>  <b>parse ($ v, $ p)</b> - After template processing (before sanitization);  $ v - processed code; </li></ul><br><br>  I repent, unknowingly ran into one feature of PHP.  If, say, you assign a function to the event handler for templateNotFound, and in it try to set the template property, nothing happens.  This is due to the limitations of recursion when calling accessors on properties of a PHP object.  In short, you cannot set a property through an accessor and the accessor of the same property.  No  From the word "absolutely."  So if you want to make the 404th through the templateNotFound event handler, call the <s>setTemplate</s> method inside it. <br><br><h2>  Handler Extensions </h2><br>  All tags support final value handlers.  For example, we received a variable, and it is empty.  The notempty handler allows you to set the output text for this case.  Some extensions have additional "extensions".  For example, the base logic has the extensions ‚Äúthen‚Äù and ‚Äúelse‚Äù. <br><br><h3>  Supported Handlers </h3><br><ul><li>  <b>is, eq</b> - equality (compared value, then, else) </li><li>  <b>isnot, neq</b> - inequality (compared value, then, else) </li><li>  <b>lt</b> - less than (compared value, then, else) </li><li>  <b>lte</b> - less than, or equal to (compared value, then, else) </li><li>  <b>gt</b> - more than (compared value, then, else) </li><li>  <b>gte</b> - greater than or equal to (compared value, then, else) </li><li>  <b>even</b> - a sign of parity (compared value, then, else) </li><li>  <b>odd</b> - a sign of oddness (compared value, then, else) </li><li>  <b>empty</b> - a sign of an empty value (the value of "then", else) </li><li>  <b>notempty</b> - sign of a non-empty value (the value of "then", else) </li><li>  <b>null, isnull</b> - whether the value is NULL (value "then", else) </li><li>  <b>notnull</b> - whether the value is not NULL (value "then", else) </li><li>  <b>isarray</b> - whether the value is an array (value ‚Äúthen‚Äù, else) </li><li>  <b>for</b> - integer iterator (number of iterations, start, splitter) </li><li>  <b>foreach</b> - index iterator (comma-separated list of indexes, splitter) </li><li>  <b>js-link</b> - turns the value into a link to the script </li><li>  <b>css-link</b> - turns a value into a link to a style sheet </li><li>  <b>import</b> - turns a value into a link to a style sheet (@import for CSS) </li><li>  <b>link</b> - turns a value into a link (title) </li><li>  <b>link-external</b> - turns a value into an external link (title) </li><li>  <b>links</b> - converts all URLs in the value into links (link attributes) </li><li>  <b>ul, ol</b> - turns a multi-line value into a list (list item template) </li></ul><br>  The ul / ol extension has two internal placeholders: [+ classes +] - element classes (first, last), [+ item +] - the actual string.  An internal placeholder [+ iterator +] is available for the for extension, containing the current iteration number.  For the foreach extension, internal placeholders are available: [+ iterator.index +] - the position number of the current iteration, [+ iterator +] - the current index. <br><br><h2>  Practical work </h2><br>  Actually, working with the parser class is very easy.  Basic example: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'quadbraces/parser.php'</span></span>; $parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuadBracesParser(<span class="hljs-string"><span class="hljs-string">'//__'</span></span>); $parser-&gt;template = <span class="hljs-string"><span class="hljs-string">'my-template'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $parser-&gt;parse(); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  In it, we connect the class of the parser, initialize the object with passing the path to the template data, set the template and parsim.  Of course, prior to processing, you can pass in the "settings" parser, variables.  And before turning on the class of the parser, turn on the language system, as described above.  A more practical example: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> define(<span class="hljs-string"><span class="hljs-string">"QUADBRACES_LOCALIZED"</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> <span class="hljs-string"><span class="hljs-string">'quadbraces/parser.php'</span></span>; $parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QuadBracesParser(<span class="hljs-string"><span class="hljs-string">'D:/projects/foo/content/template'</span></span>); $parser-&gt;language = <span class="hljs-string"><span class="hljs-string">'ru'</span></span>; $parser-&gt;data = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'pagetitle'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'  '</span></span>, <span class="hljs-string"><span class="hljs-string">'date'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'20-09-17'</span></span>, <span class="hljs-string"><span class="hljs-string">'image'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'content/images/flies.jpg'</span></span> ); $parser-&gt;template = <span class="hljs-string"><span class="hljs-string">'news.single'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $parser-&gt;parse(); <span class="hljs-meta"><span class="hljs-meta">?&gt;</span></span></code> </pre> <br>  The template will be searched in the following files: <br><br> <code>D:/projects/foo/content/template/templates/news/single.html <br> D:/projects/foo/content/template/templates/news/ru/single.html</code> <br> <br><h2>  Outcome-disclaimer </h2><br>  Immediately I apologize for my inability to write tutorials and documentation!  If the community is really interesting, the most interesting moments will be revealed in subsequent publications.  Ask questions - I will answer with pleasure.  If you notice an error, write issues on the <a href="https://github.com/XanderBass/quadbraces">github here</a> . </div><p>Source: <a href="https://habr.com/ru/post/338018/">https://habr.com/ru/post/338018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338002/index.html">Go for big data</a></li>
<li><a href="../338008/index.html">Friday: ICO bubble</a></li>
<li><a href="../338010/index.html">Wi-Fi networks in retail: typical scenarios and equipment selection</a></li>
<li><a href="../338012/index.html">A little about the safety of terminals in the MFC</a></li>
<li><a href="../338016/index.html">Air flow isolation in the data center. Typical scenarios</a></li>
<li><a href="../338020/index.html">Volkov Design System</a></li>
<li><a href="../338024/index.html">Development for Sailfish OS: working with sound on the example of the DayTimer application</a></li>
<li><a href="../338026/index.html">The results of the summer internship 2017 in Digital Security. Security Analysis Division</a></li>
<li><a href="../338028/index.html">New series of webinars on the SAP Cloud Platform: development, integration, mobile applications and much more for the month</a></li>
<li><a href="../338032/index.html">Jenkins Pipeline Shared Libraries</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>