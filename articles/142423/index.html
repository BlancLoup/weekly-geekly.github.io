<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to SELinux: Modified Policies for Third-Party Web Applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello colleagues! 
 Many of us are involved in setting up working servers for web projects. I will not talk about how to configure Apache or Nginx: yo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to SELinux: Modified Policies for Third-Party Web Applications</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/c06/344/3b1/c063443b1d815c723ff8612bfa352b8f.jpg" align="left">  Hello colleagues! <br>  Many of us are involved in setting up working servers for web projects.  I will not talk about how to configure Apache or Nginx: you know more about it than me.  But one important aspect of creating frontend servers remains unlit: these are the settings of the security subsystems.  <a href="">‚ÄúDisable SELinux,‚Äù</a> is the standard recommendation of most amateur tutorials.  It seems to me that this is a hasty decision, because the process of setting up security subsystems in the ‚Äúsoft‚Äù policy mode is often very trivial. <br><br>  Today I will tell you about some of the methods for configuring the SELinux security subsystem used in the Red Hat family of operating systems (CentOS).  As an example, we will configure a bundle for the Apache + <a href="http://code.google.com/p/modwsgi/">mod_wsgi</a> + <a href="https://www.djangoproject.com/">Django</a> + <a href="http://www.zodb.org/documentation/guide/zeo.html">ZEO</a> web server on CentOS version 5.8. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When configuring Linux security systems, we are constrained by the Discretionary Access Control (DAC) framework.  We have standard rwx rights on three levels (owner, group-owner and others) and POSIX ACL.  Thus, an application with user rights theoretically has access to all resources available to the corresponding user.  If the application is compromised, this can lead to dire consequences. <br><br>  <a href="http://docs.fedoraproject.org/en-US/Fedora/13/html/SELinux_FAQ/">SELinux (Security-Enhanced Linux)</a> is a security subsystem that implements Mandatory Access Control (MAC), operating in parallel with the classic discretionary system.  Access rights are determined by the system using policies.  In the Red Hat (CentOS) family of operating systems, you get SELinux out of the box, as part of the kernel.  For the simplest solution of the tasks we need, we need the targeted policy (‚Äútarget‚Äù), within which the rules for the majority of typical applications are described.  We get the basic protection of basic services without any extra effort.  The policy rules are such that all applications not described in it will work without restrictions from SELinux within the DAC. <br><br>  ‚ÄúBut why, in fact, do we need this SELinux?‚Äù You ask.  The answer is quite simple: in some cases, the security subsystem will at least record the unauthorized access, and ideally prevent it.  In any case, the offender will have to act within the framework delineated for a particular process. <br><br><img src="https://habrastorage.org/storage2/84c/620/370/84c620370cd0190b562372da66a162d9.png"><br><br>  To add our own settings, we will operate with contexts, domains and access vectors.  Events that are important from a security point of view are intercepted by SELinux at the kernel level.  Security subsystem mechanisms take effect after DAC rules.  SELinux provides RBAC (Role-Based Access Control), TE (Type Enforcement) and, optionally, MLS (Multi-Level Security) capabilities.  Each system object has a specific context (type).  Based on the policy rules, the security subsystem either allows the operation to be performed or blocks it, and the process receives an error message.  All decisions taken by SELinux are cached in Access Vector Cache (AVC). <br><br>  The SELinux context contains user, role, type and level information.  We will operate on a type that is an attribute of Type Enforcement.  It is defined as a domain for processes and a type for files.  SELinux rules describe allowed interaction types.  Access is allowed only if there is a corresponding rule. <br><br>  Separately, I would like to mention the technology of domain transitions.  In SELinux, the transition of an application from one domain to another is possible if the process from the source domain runs an application that runs from a file with the entrypoint type of the new domain. <br><br>  The targeted policy created and described contexts, domains and access rules for more than 200 applications.  You have the opportunity to both expand the policy and act within the proposed contexts.  When developing basic policies, almost all main usage scenarios were taken into account.  To create standard solutions you practically will not have to change anything. <br><br>  So, when implementing template solutions, the refusal to use the SELinux protection mechanism is at least unjustified.  Some difficulties in its use arise when installing additional software.  In the context of the task, these are the mod_wsgi module and ZEO.  To keep SELinux running, we need to make changes to its settings. <br><br>  In my example, I use CentOS 5.8 (kernel 2.6.18-308.1.1.el5) with the Apache web server (httpd-2.2.3-63.el5.centos.1).  It is additionally installed from the source codes of Python (2.7.2), Django (1.4), mod_wsgi (3.3) and Zope (3.4.0).  (The simple installation process of this software does not deserve a separate description.) <br><br>  First we need to expand the SELinux policy for httpd.  The default settings are intended for reliable isolation of the process in case of its compromise.  However, for httpd access to your project you will need to make some changes.  The authors of the policy laid the complete logic of the application with restrictions on the context.  A simple command will help you get familiar with the markup of files on your system: <br><br><blockquote>  semanage fcontext <font color="#660033">-l</font> <font color="#000000">|</font>  <font color="#c20cb9">grep</font> httpd </blockquote><br><br>  The policy regulates access to each of the presented types.  You can <b>view the</b> full list of contexts on the corresponding man page ( <b>man httpd_selinux</b> ).  We are interested in the type httpd_sys_content_t, which allows the daemon and scripts to access files.  Thus, in addition to the standard DAC rights, you must set the context for the directory and files of your project.  This can be done at the <b>same</b> time using the <b>chcon command</b> . <br><br><blockquote>  chcon <font color="#660033">-R</font> <font color="#660033">-t</font> <font color="#ff0000">"httpd_sys_content_t"</font> <font color="#000000">/</font> your <font color="#000000">/</font> project </blockquote><br><br>  However, I recommend setting the type using a rule.  This will ensure the subsequent automatic type assignment when adding new files. <br><br><blockquote>  semanage fcontext <font color="#660033">-a</font> <font color="#660033">-t</font> httpd_sys_content_t <font color="#ff0000">"/your/</font> project <font color="#ff0000">(/.*)?"</font> <br>  restorecon <font color="#660033">-R</font> <font color="#000000">/</font> your <font color="#000000">/</font> project <br></blockquote><br><br>  My demo project uses Django with a ZoDB database.  ZEO is used as a means of communication with the database.  Since this is a standalone software, it is necessary to ensure its functioning within SELinux.  To ensure isolation, it is advisable, I believe, to launch ZEO with apache user rights in the <b>httpd_t</b> domain.  To do this, we define the startup init script in daemon mode.  I will not list here the entire script because of its large size.  The main thing will be enough for us: <br><br><blockquote>  <font color="#000000">/</font> usr <font color="#000000">/</font> local <font color="#000000">/</font> bin <font color="#000000">/</font> zeoctl <font color="#660033">-d</font> <font color="#660033">-s</font> <font color="#000000">/</font> var <font color="#000000">/</font> run <font color="#000000">/</font> zeo <font color="#000000">/</font> zsock <font color="#660033">-C</font> <font color="#000000">/</font> etc <font color="#000000">/</font> zeo <font color="#000000">/</font> zeoctl.conf start </blockquote><br><br>  Do not forget that your initialization script must be brought to the appropriate context in order to avoid problems during the subsequent type transition in SELinux. <br><br><blockquote>  chcon ‚Äìt <font color="#ff0000">"initrc_exec_t"</font> <font color="#000000">/</font> etc <font color="#000000">/</font> init.d <font color="#000000">/</font> your_init_script </blockquote><br><br>  In the configuration file, you must specify the desired user. <br><br><blockquote>  <font color="#000000">&lt;</font> runner <font color="#000000">&gt;</font> <br>  program <font color="#000000">/</font> usr <font color="#000000">/</font> local <font color="#000000">/</font> bin <font color="#000000">/</font> runzeo <font color="#660033">-a</font> <font color="#000000">/</font> var <font color="#000000">/</font> run <font color="#000000">/</font> zeo <font color="#000000">/</font> zeo.socket <font color="#660033">-f</font> <font color="#000000">/</font> var <font color="#000000">/</font> your_db_path <font color="#000000">/</font> db.fs <br>  daemon true <br>  user apache <br>  <font color="#000000">&lt;/</font> runner <font color="#000000">&gt;</font> <br></blockquote><br><br>  A socket is used as a link between ZEO and Django.  Since httpd works in the <b>httpd_t</b> domain, you need to reconcile the types and DAC rights so that the application can connect to it.  To do this, we will prepare the / var / run / zeo directory and set the necessary context for it.  We use the -f -s switch to limit the automatic assignment of context to sockets only, and also -f -d - so that the context is installed on the directory. <br><br><blockquote>  semanage fcontext <font color="#660033">-a</font> <font color="#660033">-f</font> <font color="#660033">-d</font> <font color="#660033">-t</font> <font color="#ff0000">'httpd_sys_script_rw_t'</font> <font color="#ff0000">'/var/run/zeo(/.*)?'</font> <br>  semanage fcontext <font color="#660033">-a</font> <font color="#660033">-f</font> <font color="#660033">-s</font> <font color="#660033">-t</font> <font color="#ff0000">'httpd_sys_script_rw_t'</font> <font color="#ff0000">'/var/run/zeo(/.*)?'</font> <br>  restorecon ‚ÄìR <font color="#000000">/</font> var <font color="#000000">/</font> run </blockquote><br><br>  In the ZEO configuration file, you must specify the forced location of the communication socket. <br><br><blockquote>  <font color="#000000">&lt;</font> zeo <font color="#000000">&gt;</font> <br>  address <font color="#000000">/</font> var <font color="#000000">/</font> run <font color="#000000">/</font> zeo <font color="#000000">/</font> zeo.socket <br>  <font color="#000000">&lt;/</font> zeo <font color="#000000">&gt;</font> </blockquote><br><br>  Since we are planning to launch the application on behalf of the apache user, it is necessary to take into account the type transitivity.  We need the running process to get the type <b>httpd_t</b> .  By default, the files / usr / local / bin / zeoctl and / usr / local / bin / runzeo will have the context <b>bin_t</b> .  Since they will be called from the <b>unconfined_t</b> domain, it is necessary to trace the chain of context transitions.  First of all, the script from /etc/init.d/ will be called, to which we assigned the type <b>initrc_exec_t</b> .  Find a chain of transitions for this situation. <br><br><blockquote>  sesearch <font color="#660033">-T</font> <font color="#660033">-s</font> unconfined_t <font color="#660033">-t</font> initrc_exec_t <font color="#000000">|</font>  <font color="#c20cb9">grep</font> <font color="#ff0000">"initrc_exec_t"</font> </blockquote><br><br>  The transition chain found looks like <b>unconfined_t initrc_exec_t: process initrc_t</b> .  We see that the process will receive the <b>initrc_t</b> context.  Accordingly, now we need to find a chain of transitions that will lead us to the required type of <b>httpd_t</b> . <br><br><blockquote>  sesearch <font color="#660033">-T</font> <font color="#660033">-s</font> initrc_t <font color="#000000">|</font>  <font color="#c20cb9">grep</font> <font color="#ff0000">"process httpd_t"</font> </blockquote><br><br>  The search will result in a link <b>initrc_t httpd_exec_t: process httpd_t</b> .  In order for this transition to occur, we need to set the <b>httpd_exec_t</b> context to executable files. <br><br><blockquote>  semanage fcontext <font color="#660033">-a</font> <font color="#660033">-t</font> httpd_exec_t <font color="#ff0000">"/ usr / local / bin / zeoctl"</font> <br>  semanage fcontext <font color="#660033">-a</font> <font color="#660033">-t</font> httpd_exec_t <font color="#ff0000">"/ usr / local / bin / runzeo"</font> <br>  restorecon <font color="#660033">-R</font> <font color="#000000">/</font> usr <font color="#000000">/</font> local <font color="#000000">/</font> bin </blockquote><br><br>  Now we need to add permissions to connect to the socket for httpd in the SELinux policy.  This can be done in several ways.  The simplest from the user's point of view is the audit2allow utility, which allows you to form modules for a policy based on AVC messages from system logs.  The utility should be used carefully, since it only creates permissions for certain actions - but no more than that (a <a href="http://docs.fedoraproject.org/ru-RU/Fedora/13/html/Security-Enhanced_Linux/sect-Security-Enhanced_Linux-Fixing_Problems-Allowing_Access_audit2allow.html">detailed guide is presented on the developers' website</a> ). <br><br>  The second way is to create the module manually, compile it and install it into the current policy.  Since this method gives the best visualization of the process, we will manufacture modules for ZEO just like that.  <b>Let's</b> grant <b>httpd_t the</b> rights to create and work with a socket of the <b>httpd_sys_script_rw_t</b> type.  To do this, create the file /tmp/httpdAllowDjangoZEO.te with the following content: <br><br><blockquote>  module httpdAllowDjangoZEO 1.0; <br><br>  require { <br>  type httpd_t; <br>  type httpd_sys_script_rw_t; <br>  class sock_file link; <br>  class sock_file setattr; <br>  class sock_file create; <br>  class sock_file unlink; <br>  class sock_file write; <br>  } <br>  # ============= httpd_t ============== <br>  allow httpd_t httpd_sys_script_rw_t: sock_file link; <br>  allow httpd_t httpd_sys_script_rw_t: sock_file setattr; <br>  allow httpd_t httpd_sys_script_rw_t: sock_file create; <br>  allow httpd_t httpd_sys_script_rw_t: sock_file unlink; <br>  allow httpd_t httpd_sys_script_rw_t: sock_file write; </blockquote><br><br>  Next we need to create and compile the module.  To do this, use the commands <b>checkmodule</b> and <b>semodule_package</b> .  To install the module in the current policy, we need the <b>semodule</b> utility. <br><br><blockquote>  checkmodule <font color="#660033">-M</font> <font color="#660033">-m</font> <font color="#660033">-o</font> <font color="#000000">/</font> tmp <font color="#000000">/</font> httpdAllowDjangoZEO.mod <font color="#000000">/</font> tmp <font color="#000000">/</font> httpdAllowDjangoZEO.te <br>  semodule_package - <font color="#660033">outfile</font> <font color="#000000">/</font> tmp <font color="#000000">/</font> httpdAllowDjangoZEO.pp <font color="#660033">--module</font> <font color="#000000">/</font> tmp <font color="#000000">/</font> httpdAllowDjangoZEO.mod <br>  semodule <font color="#660033">-i</font> httpdAllowDjangoZEO.pp <br></blockquote><br><br>  The final action will be setting the context of the storage location of the ZoDB database and the ZEO configuration file.  In the course of our work, we will need to create technical .lock files.  Therefore, the database storage location must be marked with the appropriate context, which will allow the creation of files.  ‚Äú <b>Httpd_sys_script_rw_t</b> ‚Äù is well suited for this. <br><br><blockquote>  semanage fcontext ‚Äìa ‚Äìt "httpd_sys_script_rw_t" ‚Äú <font color="#000000">/</font> var <font color="#000000">/</font> your_db_path <font color="#7a0874">(</font> <font color="#000000">/</font> . <font color="#000000">*</font> <font color="#7a0874">)</font> ?‚Äù </blockquote><br><br>  For configuration files there is a specialized type "httpd_config_t". <br><br><blockquote>  semanage fcontext ‚Äìa ‚Äìt "httpd_config_t" ‚Äú <font color="#000000">/</font> etc <font color="#000000">/</font> zeo <font color="#7a0874">(</font> <font color="#000000">/</font> . <font color="#000000">*</font> <font color="#7a0874">)</font> ?‚Äù </blockquote><br><br>  Now it is enough to restart the services to complete the configuration process. <br><br>  The rules we have written will allow the whole bundle to work without problems.  At the same time, we provide the server and its services with additional SELinux protection.  If any of the Django or ZEO components are compromised, the attacker will be restricted and will not be able to reach the system, since it will act within the <b>httpd_t</b> domain. <br><br>  So, we got a working custom httpd configuration without disabling SELinux.  Similarly, you can create regulatory policies for any of your applications.  It does not take much time and does not require serious theoretical preparation.  So maybe you should not turn off SELinux? <br><br>  For a more holistic understanding of the SELinux technology, I recommend that you familiarize yourself with the <a href="http://docs.fedoraproject.org/ru-RU/Fedora/13/html/Security-Enhanced_Linux/index.html">Russian-language SELinux description for Fedora 13</a> . </div><p>Source: <a href="https://habr.com/ru/post/142423/">https://habr.com/ru/post/142423/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../142417/index.html">JetBrains presented the Kotlin language at the JavaOne Russia 2012 conference.</a></li>
<li><a href="../142419/index.html">Draw an image map with the mouse</a></li>
<li><a href="../142420/index.html">33 million people were hurt by disabling Gmail</a></li>
<li><a href="../142421/index.html">Google +</a></li>
<li><a href="../142422/index.html">Do-It-Yourself: Automate Security Process Management</a></li>
<li><a href="../142424/index.html">Computational linguistics is powerless to help us in word processing.</a></li>
<li><a href="../142425/index.html">Linus Torvalds was awarded the Millennium Technology Prize 2012</a></li>
<li><a href="../142426/index.html">Two Chinese are accused of selling pirated software for $ 100 million</a></li>
<li><a href="../142428/index.html">The Tax Service of Ukraine searches the office of the company Imena.ua/Mirohost</a></li>
<li><a href="../142429/index.html">Testing, using SoapUI, a web service that returns a list of items</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>