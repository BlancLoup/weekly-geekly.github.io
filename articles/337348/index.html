<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RustGo: Rust call from Go with almost zero overhead</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Go has good support for calling assembler functions, and the large number of very fast cryptographic code in the standard library is, in fact, a well-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RustGo: Rust call from Go with almost zero overhead</h1><div class="post__text post__text-html js-mediator-article"><p>  Go has good support for calling assembler functions, and the large number of very fast cryptographic code in the standard library is, in fact, a well-optimized assembler, which gives more than 20-fold increase in speed. </p><br><p>  But it is still difficult to write code in assembler, it is even more difficult to analyze it, and cryptography <a href="https://groups.google.com/forum/">does not forgive errors</a> .  Wouldn't it be great to be able to write these functions in some higher level language? </p><br><p>  This post is about a slightly inadequate experiment on calling the Rust code from Go in an attempt to do this so quickly that it can be compared to a call to the assembler.  You do not need to know Rust or about the inside of the compiler, it‚Äôs enough to understand what a linker is. </p><a name="habracut"></a><br><h1 id="pochemu-rust">  Why Rust? </h1><br><p>  I admit right away - I do not know Rust and the idea of ‚Äã‚Äãwriting on it does not attract me very much.  But still, I know that Rust is very well customizable and optimizable language, more readable than assembler.  (In the end, more and more readable than assembler!) </p><br><p>  In Go, it is customary to choose default values ‚Äã‚Äãso that they fit the main tasks, and include by default only those features that are guaranteed fast - this helps in the constant and successful struggle with the need to have a bunch of parameters.  I love him for that.  But for what we are going to do today, we will need a language that will not blink if we ask it to generate stack-only functions with disabled security checks. </p><br><p>  And if there is such a language that we could limit enough so that it behaves like an assembler, and optimize it enough so that it is as effective as an assembler, it will most likely be Rust. </p><br><p>  In the end, Rust is safe, actively developing, and, importantly, it already has a good ecosystem of a fast cryptographic code that we can use. </p><br><h1 id="pochemu-ne-cgo">  Why not cgo? </h1><br><p>  In Go is from the box <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">Foreign Function Interface</a> , cgo.  <a href="https://golang.org/cmd/cgo/">cgo</a> allows Go programs to call C functions in the most natural way - which, unfortunately, is never natural at all.  (I know more about cgo <a href="https://speakerdeck.com/filosottile/from-cgo-back-to-go-gophercon-2016">than I would like</a> , and believe me, this <a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go">is not fun at all</a> ). </p><br><p>  Using C <a href="https://en.wikipedia.org/wiki/Application_binary_interface">ABI</a> as a <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D0%25BD%25D0%25B3%25D0%25B2%25D0%25B0_%25D1%2584%25D1%2580%25D0%25B0%25D0%25BD%25D0%25BA%25D0%25B0">lingua franca</a> for FFI, we can call anything from anywhere: Rust can be compiled into a library that is compatible with C ABI, and cgo can use this.  This is stupid, but it works. </p><br><p>  We can do it the other way around - compile Go into the C library and call it from different languages, as I, for example, <a href="https://blog.filippo.io/building-python-modules-with-go-1-5/">did with Python as a trick</a> .  (Folk, it was just a trick, don't take it seriously) </p><br><p>  But cgo does a lot of things under the hood to add some Go to naturalness: it organizes a stack for C code, it will set up defer calls to work correctly in case of a panic in a Go call ... you can write a separate post about it. </p><br><p>  But as a result, the cost of each cgo call is too high for the case we are talking about today - <em>small, nimble functions</em> . </p><br><h1 id="svyazyvaem-vsyo-vmeste">  We tie everything together </h1><br><p>  In general, such an idea: if we have isolated Rust code as an assembler, we should, in theory, be able to use it <strong>also as an assembler</strong> and call it directly.  Maybe with a thin layer. </p><br><p>  We do not want to work with it at the level of intermediate representation <a href="https://idea.popcount.org/2013-07-24-ir-is-better-than-assembly/">IR</a> : the Go compiler converts both Go code and assembler into machine code before rejoicing since <a href="https://talks.golang.org/2016/asm.slide">Go 1.3</a> . </p><br><p> This is confirmed by the presence of such a thing as <a href="https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/preview">"external linking"</a> , when the system linker is used to link the program to Go.  This is exactly how cgo works: first, C compiles with the compiler, Go - Go the compiler, and all this is linked together using <code>clang</code> or <code>gcc</code> .  We can even directly transfer flags to the battleship via <code>CGO_LDFLAGS</code> . </p><br><p>  Under the hood of all the security measures in the cgo, we, of course, will find the interlanguage challenge itself, after all. </p><br><p>  But it would be great to find a way to do this without changing the compiler, of course.  First, let's figure out how to link the Go program with the Rust archive. </p><br><p>  I could not find a normal way to link with an alien binary using <code>go build</code> (and why not?), Except for using <code>#cgo</code> directives.  But the cgo call <a href="https://github.com/golang/go/issues/19448">creates .s files that are then passed to the C compiler, not Go</a> , which means, friends, that we will need a Go assembler. </p><br><p>  Fortunately, <a href="https://golang.org/pkg/go/build/">go / build</a> is just a front-end!  Go offers a set of low-level utilities for <a href="https://golang.org/cmd/compile/">compiling</a> and <a href="https://golang.org/cmd/link/">linking</a> programs, and <code>go build</code> just assembles files into a heap and runs these utilities.  We can follow what happens with the <code>-x</code> flag. </p><br><p>  I wrote a small Makefile along the lines of the <code>-x -ldflags "-v -linkmode=external '-extldflags=-v'"</code> call when building cgo: </p><br><pre> <code class="hljs go">rustgo: rustgo.a <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool link -o rustgo -extld clang -buildmode exe -buildid b01dca11ab1e -linkmode external -v rustgo.a rustgo.a: hello.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> hello.o <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool compile -o rustgo.a -p main -buildid b01dca11ab1e -pack hello.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool pack r rustgo.a hello.o hello.o: hello.s <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> tool asm -I <span class="hljs-string"><span class="hljs-string">"$(shell go env GOROOT)/pkg/include"</span></span> -D GOOS_darwin -D GOARCH_amd64 -o hello.o hello.s</code> </pre> <br><p>  This will assemble a simple main package consisting of a single Go file ( <code>hello.go</code> ) and an assembler Go file ( <code>hello.s</code> ). </p><br><p>  Now, if we want to link an object to Rust, we first need to build it as a static library ... </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">libhello</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.a</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">hello</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rustc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-g</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-O</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">--crate-type</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">staticlib</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hello</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.rs</span></span></code> </pre> <br><p>  ... and then just tell the external linker to link them together: </p><br><pre> <code class="hljs pgsql">rustgo: rustgo.a libhello.a go tool link -o rustgo -extld clang -buildmode exe -buildid b01dca11ab1e -linkmode <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> -v -extldflags=<span class="hljs-string"><span class="hljs-string">'-lhello -L"$(CURDIR)"'</span></span> rustgo.a</code> </pre> <br><pre> <code class="hljs perl">$ make go tool asm -I <span class="hljs-string"><span class="hljs-string">"/usr/local/Cellar/go/1.8.1_1/libexec/pkg/include"</span></span> -D GOOS_darwin -D GOARCH_amd64 -o hello.o hello.s go tool compile -o rustgo.a -p main -buildid b01dca11ab1e -<span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> hello.go go tool <span class="hljs-keyword"><span class="hljs-keyword">pack</span></span> r rustgo.a hello.o rustc --crate-type staticlib hello.rs note: <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> against the following native artifacts <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> linking against this static library note: the order <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> any duplication can be significant on some platforms, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> so may need to be preserved note: library: System note: library: c note: library: <span class="hljs-keyword"><span class="hljs-keyword">m</span></span> go tool <span class="hljs-keyword"><span class="hljs-keyword">link</span></span> -o rustgo -extld clang -buildmode exe -buildid b01dca11ab1e -linkmode external -v -extldflags=<span class="hljs-string"><span class="hljs-string">"-lhello -L/Users/filippo/code/misc/rustgo"</span></span> rustgo.a HEADER = -H1 -T0x100100<span class="hljs-number"><span class="hljs-number">0</span></span> -D0x<span class="hljs-number"><span class="hljs-number">0</span></span> -R0x100<span class="hljs-number"><span class="hljs-number">0</span></span> searching <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> runtime.a in /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/Cellar/go/<span class="hljs-number"><span class="hljs-number">1.8</span></span>.<span class="hljs-number"><span class="hljs-number">1_1</span></span>/libexec/pkg/darwin_amd64/runtime.a searching <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> runtime/cgo.a in /usr/<span class="hljs-keyword"><span class="hljs-keyword">local</span></span>/Cellar/go/<span class="hljs-number"><span class="hljs-number">1.8</span></span>.<span class="hljs-number"><span class="hljs-number">1_1</span></span>/libexec/pkg/darwin_amd64/runtime/cgo.a <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span> deadcode <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">00</span></span> pclntab=<span class="hljs-number"><span class="hljs-number">166785</span></span> bytes, funcdata total <span class="hljs-number"><span class="hljs-number">17079</span></span> bytes <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span> dodata <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span> symsize = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span> symsize = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span> reloc <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span> dwarf <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">02</span></span> symsize = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">02</span></span> reloc <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">02</span></span> asmb <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">02</span></span> codeblk <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">03</span></span> datblk <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">03</span></span> sym <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">03</span></span> headr <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">06</span></span> host <span class="hljs-keyword"><span class="hljs-keyword">link</span></span>: <span class="hljs-string"><span class="hljs-string">"clang"</span></span> <span class="hljs-string"><span class="hljs-string">"-m64"</span></span> <span class="hljs-string"><span class="hljs-string">"-gdwarf-2"</span></span> <span class="hljs-string"><span class="hljs-string">"-Wl,-headerpad,1144"</span></span> <span class="hljs-string"><span class="hljs-string">"-Wl,-no_pie"</span></span> <span class="hljs-string"><span class="hljs-string">"-Wl,-pagezero_size,4000000"</span></span> <span class="hljs-string"><span class="hljs-string">"-o"</span></span> <span class="hljs-string"><span class="hljs-string">"rustgo"</span></span> <span class="hljs-string"><span class="hljs-string">"-Qunused-arguments"</span></span> <span class="hljs-string"><span class="hljs-string">"/var/folders/ry/v14gg02d0y9cb2w9809hf6ch0000gn/T/go-link-412633279/go.o"</span></span> <span class="hljs-string"><span class="hljs-string">"/var/folders/ry/v14gg02d0y9cb2w9809hf6ch0000gn/T/go-link-412633279/000000.o"</span></span> <span class="hljs-string"><span class="hljs-string">"-g"</span></span> <span class="hljs-string"><span class="hljs-string">"-O2"</span></span> <span class="hljs-string"><span class="hljs-string">"-lpthread"</span></span> <span class="hljs-string"><span class="hljs-string">"-lhello"</span></span> <span class="hljs-string"><span class="hljs-string">"-L/Users/filippo/code/misc/rustgo"</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">34</span></span> cpu <span class="hljs-keyword"><span class="hljs-keyword">time</span></span> <span class="hljs-number"><span class="hljs-number">12641</span></span> symbols <span class="hljs-number"><span class="hljs-number">5764</span></span> liveness data</code> </pre> <br><h1 id="perehodim-k-rust">  Go to Rust </h1><br><p>  Well, we are linked, but the characters themselves can do nothing, just sitting in a binary file next to each other.  We need to somehow call the Rust function from our Go code. </p><br><p>  We already know how to call the Go function from Go.  In assembler, this call will look like <code>CALL hello(SB)</code> , where SB is a virtual register accessible to all global characters. </p><br><p>  If we want to call a function in an assembler from Go, we need to let the compiler know about it - something like the C header, just writing <code>func hello()</code> without the function body. </p><br><p>  I tried all the above call combinations for the external Rust function, but they all complained that they either did not see the symbol or the function body. </p><br><p>  But cgo, which in the end is just a big code generator, somehow manages in the end to call this alien function!  But how? </p><br><p>  I came across <a href="">an answer a</a> few days later. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:cgo_import_static _cgoPREFIX_Cfunc__Cmalloc //go:linkname __cgofn__cgoPREFIX_Cfunc__Cmalloc _cgoPREFIX_Cfunc__Cmalloc var __cgofn__cgoPREFIX_Cfunc__Cmalloc byte var _cgoPREFIX_Cfunc__Cmalloc = unsafe.Pointer(&amp;__cgofn__cgoPREFIX_Cfunc__Cmalloc)</span></span></code> </pre> <br><p>  It looks like an interesting pragma!  <code>//go:linkname</code> just creates an alias for a symbol in the local scope (which <a href="https://sitano.github.io/2016/04/28/golang-private/">can be used to call private functions!</a> ), and I'm more than sure that the trick with <code>byte</code> is just for some sort of address manipulation, but <code>//go:cgo_import_static</code> ... it imports an external character! </p><br><p>  Armed with this new knowledge and the above Makefile, we have a chance to call the function from Rust (hello.rs) </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hello</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, Rust!"</span></span>); }</code> </pre> <br><p>  (Sorcery from no-mangle / pub / extern is taken from <a href="https://doc.rust-lang.org/1.5.0/book/rust-inside-other-languages.html">this tutorial</a> ) </p><br><p>  And, we call from this program on Go ( <code>hello.go</code> ): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">//go:cgo_import_static hello func trampoline() func main() { println("Hello, Go!") trampoline() }</span></span></code> </pre> <br><p>  Using this example in assembler ( <code>hello.s</code> ): </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> ¬∑trampoline(SB), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-meta"><span class="hljs-meta">$2048</span></span> JMP hello(SB) RET</code> </pre> <br><p>  <code>CALL</code> was too sophisticated to use, but using simple <code>JMP</code> ... </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Hello</span></span>, <span class="hljs-type"><span class="hljs-type">Go!</span></span> <span class="hljs-type"><span class="hljs-type">Hello</span></span>, <span class="hljs-type"><span class="hljs-type">Rust!</span></span> panic: runtime error: invalid memory address or <span class="hljs-literal"><span class="hljs-literal">nil</span></span> pointer dereference [signal <span class="hljs-type"><span class="hljs-type">SIGSEGV</span></span>: segmentation violation code=<span class="hljs-number"><span class="hljs-number">0x1</span></span> addr=<span class="hljs-number"><span class="hljs-number">0x0</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x0</span></span>]</code> </pre> <br><p>  Well, the program crashed while trying to exit.  And this <code>$2048</code> value is the whole stack that is given to Rust (if it puts the stack at all where it should be) and don‚Äôt ask me what happens if Rust tries to touch the heap ... but, damn, I'm surprised that it works! </p><br><h1 id="soglasheniya-o-vyzovah">  Calling conventions </h1><br><p>  Now, if we want to cleanly exit the program and pass on some arguments, we need to take a closer look at the call agreements in Go and Rust.  These <a href="https://en.wikipedia.org/wiki/Calling_convention">conventions</a> determine where the arguments and return values ‚Äã‚Äãare between function calls. </p><br><p>  Go call conventions are described <a href="https://github.com/golang/go/files/447163/GoFunctionsInAssembly.pdf">here</a> and <a href="https://golang.org/doc/asm">here</a> .  For Rust, we will have to look at the <a href="https://doc.rust-lang.org/beta/book/first-edition/ffi.html">standard for FFI</a> , which is just a standard agreement for C. </p><br><p>  To continue, we need a debugger.  (LLDB supports Go, but <a href="https://github.com/golang/go/issues/20568">the breakpoints are buggy on MacOS X</a> , so I had to do it inside the privileged Docker container) </p><br><p><img src="https://habrastorage.org/web/8d7/bce/245/8d7bce245c6741719a2334f2edee7782.png"></p><br><h1 id="soglashenie-o-vyzovah-go">  Go Call Agreement </h1><br><p><img src="https://habrastorage.org/web/4ee/d64/596/4eed64596b9b408ebe4e38165a1d6884.png"></p><br><p>  The call convention in Go is mostly <a href="https://github.com/golang/go/issues/16922">undocumented</a> , but we need to understand it in order to continue further, so that's what we can learn from this listing disassembler (amd64).  Let's look at a very simple function: </p><br><pre> <code class="hljs pgsql">// func foo(x, y uint64) uint64 <span class="hljs-type"><span class="hljs-type">TEXT</span></span> ¬∑foo(SB), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-meta"><span class="hljs-meta">$256</span></span><span class="hljs-number"><span class="hljs-number">-24</span></span> MOVQ x+<span class="hljs-number"><span class="hljs-number">0</span></span>(FP), DX MOVQ DX, ret+<span class="hljs-number"><span class="hljs-number">16</span></span>(FP) RET</code> </pre> <br><p>  <code>foo</code> has 256 (0x100) bytes of the local frame, 16 bytes of arguments, 8 bytes for the return value, and it simply returns its first argument: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { foo(<span class="hljs-number"><span class="hljs-number">0xf0f0f0f0f0f0f0f</span></span>0, <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>)</code> </pre> <br><pre> <code class="hljs mel">rustgo[<span class="hljs-number"><span class="hljs-number">0x49d785</span></span>]: movabsq $-<span class="hljs-number"><span class="hljs-number">0xf0f0f0f0f0f0f10</span></span>, %rax rustgo[<span class="hljs-number"><span class="hljs-number">0x49d78f</span></span>]: movq %rax, (%rsp) rustgo[<span class="hljs-number"><span class="hljs-number">0x49d793</span></span>]: movabsq $0x5555555555555555, %rax rustgo[<span class="hljs-number"><span class="hljs-number">0x49d79d</span></span>]: movq %rax, <span class="hljs-number"><span class="hljs-number">0x8</span></span>(%rsp) rustgo[<span class="hljs-number"><span class="hljs-number">0x49d7a2</span></span>]: callq <span class="hljs-number"><span class="hljs-number">0x49d8a0</span></span> ; main.foo at hello.s:<span class="hljs-number"><span class="hljs-number">14</span></span></code> </pre> <br><p>  The calling code above does very little: puts the arguments on the stack in reverse order, at the bottom of its frame (from <code>rsp</code> to <code>16(rsp)</code> , remember that the stack grows down) and calls <code>CALL</code> .  The <code>CALL</code> call starts the pointer to the return value on the stack and makes the transition.  There is no cleaning of the caller; there is a simple <code>RET</code> at the end. </p><br><p>  Note that <code>rsp</code> fixed, and here we have <code>movq</code> instead of <code>push</code> : </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">rustgo</span></span>`<span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hello</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:14</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">rustgo</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0x49d8a0]</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">movq</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">fs</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-0x8</span></span>, %<span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rustgo</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0x49d8a9]</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">leaq</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-0x88</span></span>(%<span class="hljs-selector-tag"><span class="hljs-selector-tag">rsp</span></span>), %<span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rustgo</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0x49d8b1]</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">cmpq</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x10</span></span>(%<span class="hljs-selector-tag"><span class="hljs-selector-tag">rcx</span></span>), %<span class="hljs-selector-tag"><span class="hljs-selector-tag">rax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rustgo</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0x49d8b5]</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">jbe</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x49d8ee</span></span> ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> + 78 <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hello</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:14</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[...]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rustgo</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0x49d8ee]</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">callq</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x495d10</span></span> ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">runtime</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.morestack_noctxt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">asm_amd64</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:405</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">rustgo</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0x49d8f3]</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">jmp</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x49d8a0</span></span> ; <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.foo</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">at</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">hello</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:14</span></span></code> </pre> <br><p>  The first 4 and last 2 instructions of the function check if there is enough space on the stack, and if not, then call <code>runtime.morestack</code> .  They are most likely skipped for functions labeled <code>NOSPLIT</code> : </p><br><pre> <code class="hljs perl">rustgo[<span class="hljs-number"><span class="hljs-number">0x49d8b7</span></span>]: subq $0x108, %rsp [...] rustgo[<span class="hljs-number"><span class="hljs-number">0x49d8e6</span></span>]: addq $0x108, %rsp rustgo[<span class="hljs-number"><span class="hljs-number">0x49d8ed</span></span>]: retq</code> </pre> <br><p>  Then we have control of <code>rsp</code> , in which 0x108 is subtracted, freeing up space for 0x100 bytes for the frame and 8 bytes for the pointer, at a time.  As a result, <code>rsp</code> points to the bottom (end) of the function frame and is controlled by the called function.  Before returning, <code>rsp</code> returns to the same place where it was (immediately after the return pointer). </p><br><pre> <code class="hljs perl">rustgo[<span class="hljs-number"><span class="hljs-number">0x49d8be</span></span>]: movq %rbp, <span class="hljs-number"><span class="hljs-number">0x100</span></span>(%rsp) rustgo[<span class="hljs-number"><span class="hljs-number">0x49d8c6</span></span>]: leaq <span class="hljs-number"><span class="hljs-number">0x100</span></span>(%rsp), %rbp [...] rustgo[<span class="hljs-number"><span class="hljs-number">0x49d8de</span></span>]: movq <span class="hljs-number"><span class="hljs-number">0x100</span></span>(%rsp), %rbp</code> </pre> <br><p>  Finally, a <a href="https://stackoverflow.com/questions/579262/what-is-the-purpose-of-the-ebp-frame-pointer-register">pointer to a frame</a> , which, in fact, is <code>rbp</code> stack immediately after the return pointer and updated in <code>rbp</code> .  It turns out that <code>rbp</code> also saved by the called function and must be updated where the called function has saved <code>rbp</code> in order to be able to spin the stack. </p><br><pre> <code class="hljs perl">rustgo[<span class="hljs-number"><span class="hljs-number">0x49d8ce</span></span>]: movq <span class="hljs-number"><span class="hljs-number">0x110</span></span>(%rsp), %rdx rustgo[<span class="hljs-number"><span class="hljs-number">0x49d8d6</span></span>]: movq %rdx, <span class="hljs-number"><span class="hljs-number">0x120</span></span>(%rsp)</code> </pre> <br><p>  As a result, from the body of the function, we saw that the returned values ‚Äã‚Äãare located immediately above the arguments. </p><br><h1 id="virtualnye-registry">  Virtual registers </h1><br><p>  The Go documentation says that <code>SP</code> and <code>FP</code> are virtual registers, not just aliases for <code>rsp</code> and <code>rbp</code> . </p><br><p>  It is clear, when we go to <code>SP</code> from Go assembler, all offsets are recalculated relative to the real <code>rsp</code> register so that <code>SP</code> points upward, not at the bottom of the frame.  This is convenient, because it means that we can not change all the offsets when the frame is resized, but this is, in fact, only syntactic sugar.  Bare case access (like <code>MOV SP, DX</code> ) accesses <code>rsp</code> directly. </p><br><p>  The virtual <code>FP</code> register is also simply recalculated relative to <code>rsp</code> .  It is pointed to the bottom of the frame of the calling function, where the arguments lie and there is no direct access. </p><br><p>  Note: Go stores <code>rbp</code> and frame pointers to help debug, but then uses a fixed <code>rsp</code> and <code>rsp</code> <code>omit-stack-pointer</code> style <code>omit-stack-pointer</code> for virtual <code>FP</code> .  You can read more about pointers to frames and how they should not be used <a href="https://www.imperialviolet.org/2017/01/18/cfi.html">in this post by Adam Langley</a> . </p><br><h1 id="soglasheniya-o-vyzovah-c">  Call Agreements C </h1><br><p>  With the standard x86-64 calling convention, <a href="https://en.wikipedia.org/wiki/X86_calling_conventions"><code>sysv64</code></a> is rather different: </p><br><ul><li>  arguments are passed through registers: RDI, RSI, RDX, RCX, R8 and R9 </li><li>  return value goes to RAX </li><li>  some registers are saved by the called function: RBP, RBX and R12-R15 <br><ul><li>  it interests us a little, because in Go all registers are saved by the called function </li></ul></li><li>  stack should be 16 bytes aligned <br><ul><li>  (I think this is why <code>JMP</code> worked, but <code>CALL</code> not - we did not align the stack!) </li></ul></li></ul><br><p>  Pointers to frames work in a similar way (and are generated using <code>rustc</code> with <code>-g</code> ). </p><br><h1 id="soedinyaem-vsyo-vmeste">  We put everything together </h1><br><p>  Creating a simple springboard between the two agreements should not be difficult.  We can look at <a href=""><code>asmcgocall</code></a> for inspiration, since it does just that, only for cgo. </p><br><p>  We need to remember that we want to give the Rust function to use the stack of our assembly function, since Go guarantees for us that it is present.  To do this, we need to return <code>rsp</code> to the end of the stack. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-comment"><span class="hljs-comment">//go:cgo_import_static increment func trampoline(arg uint64) uint64 func main() { println(trampoline(41)) }</span></span></code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> ¬∑trampoline(SB), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-meta"><span class="hljs-meta">$2048</span></span><span class="hljs-number"><span class="hljs-number">-16</span></span> MOVQ arg+<span class="hljs-number"><span class="hljs-number">0</span></span>(FP), DI // <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> the argument <span class="hljs-keyword"><span class="hljs-keyword">before</span></span> messing <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> SP MOVQ SP, BX // Save SP <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> a callee-saved registry ADDQ <span class="hljs-meta"><span class="hljs-meta">$2048</span></span>, SP // <span class="hljs-keyword"><span class="hljs-keyword">Rollback</span></span> SP <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> reuse this <span class="hljs-keyword"><span class="hljs-keyword">function</span></span><span class="hljs-string"><span class="hljs-string">'s frame ANDQ $~15, SP // Align the stack to 16-bytes CALL increment(SB) MOVQ BX, SP // Restore SP MOVQ AX, ret+8(FP) // Place the return value on the stack RET</span></span></code> </pre> <br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u64</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><h1 id="call-v-macos">  CALL in macOS </h1><br><p>  <code>CALL</code> , in fact, is not very good friends with macOS.  For some reason, the function call was replaced with the intermediate call <code>cgo_thread_start</code> , which is not so strange, considering that we use something called <code>cgo_import_static</code> and <code>CALL</code> also a virtuoso in Go assembly language. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">callq</span></span> 0x40a27cd ; <span class="hljs-attribute"><span class="hljs-attribute">x_cgo_thread_start</span></span> + <span class="hljs-number"><span class="hljs-number">29</span></span></code> </pre> <br><p>  We can get around this "help" using witchcraft <code>//go:linkname</code> , which we found in the standard library to take a pointer to a function and then call a function pointer, like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-string"><span class="hljs-string">"unsafe"</span></span> <span class="hljs-comment"><span class="hljs-comment">//go:cgo_import_static increment //go:linkname increment increment var increment uintptr var _increment = &amp;increment</span></span></code> </pre> <br><pre> <code class="hljs objectivec"> MOVQ ¬∑_increment(SB), AX <span class="hljs-built_in"><span class="hljs-built_in">CALL</span></span> AX</code> </pre> <br><h1 id="bystro-li-eto">  Is it fast? </h1><br><p>  The whole task of this experiment was to call Rust instead of an assembler for cryptographic operations (well, have fun).  Therefore, the rustgo call must be <a href="https://speakerdeck.com/gtank/i-wanna-go-fast">as fast</a> as the assembler call to be useful. </p><br><p>  Time benchmarks! </p><br><p>  We compare the increase in the uint64 variable in the inline version, with the <code>//go:noinline</code> directive, with our rustgo call, and with the cgo call of that same Rust function. </p><br><p>  Rust was compiled with the flags <code>-g -O</code> and benchmarks run on macOS on a 2.9GHz Intel Code i5 processor. </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op CallOverhead/<span class="hljs-keyword"><span class="hljs-keyword">Inline</span></span> <span class="hljs-number"><span class="hljs-number">1.72</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">3</span></span>% CallOverhead/Go <span class="hljs-number"><span class="hljs-number">4.60</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">2</span></span>% CallOverhead/rustgo <span class="hljs-number"><span class="hljs-number">5.11</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">4</span></span>% CallOverhead/cgo <span class="hljs-number"><span class="hljs-number">73.6</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>%</code> </pre> <br><p>  rustgo is 11% slower than calling the usual Go function and almost 15 times faster than cgo! </p><br><p>  The results are even better on Linux without a problem with the pointer, only 2% slower: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op CallOverhead/<span class="hljs-keyword"><span class="hljs-keyword">Inline</span></span> <span class="hljs-number"><span class="hljs-number">1.67</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">2</span></span>% CallOverhead/Go <span class="hljs-number"><span class="hljs-number">4.49</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">3</span></span>% CallOverhead/rustgo <span class="hljs-number"><span class="hljs-number">4.58</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">3</span></span>% CallOverhead/cgo <span class="hljs-number"><span class="hljs-number">69.4</span></span>ns ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>%</code> </pre> <br><h1 id="realnyy-primer">  Real example </h1><br><p>  For a real example, I chose the wonderful curve25519-dalek library and specifically the task of multiplying the starting point of a curve by a scalar and returning its Edwards view. </p><br><p>  Cargo benchmarks vary greatly between launches due to a <a href="https://wiki.debian.org/HowTo/CpuFrequencyScaling">dynamic change in the processor frequency</a> , but they roughly promise that the operation will take 22.9¬µs ¬± 17%. </p><br><pre> <code class="hljs php">test curve::bench::basepoint_mult ... bench: <span class="hljs-number"><span class="hljs-number">17</span></span>,<span class="hljs-number"><span class="hljs-number">276</span></span> ns/iter (+/- <span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">057</span></span>) test curve::bench::edwards_compress ... bench: <span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">633</span></span> ns/iter (+/- <span class="hljs-number"><span class="hljs-number">858</span></span>)</code> </pre> <br><p>  On the Go side, we add a simple API. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ScalarBaseMult</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dst, in *[32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <br><p>  On the Rust side, this is not much different from <a href="https://doc.rust-lang.org/beta/book/first-edition/ffi.html">building the interface for normal FFI</a> . </p><br><p>  I admit honestly, it took me forever to make it work in Rust: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> curve25519_dalek; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> curve25519_dalek::scalar::Scalar; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> curve25519_dalek::constants; <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scalar_base_mult</span></span></span></span>(dst: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>], k: &amp;[<span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>; <span class="hljs-number"><span class="hljs-number">32</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = &amp;constants::ED25519_BASEPOINT_TABLE * &amp;Scalar(*k); dst.clone_from(res.compress_edwards().as_bytes()); }</code> </pre> <br><p>  To create <code>.a</code> we run <code>cargo build --release</code> with <code>Cargo.toml</code> , which shows the dependencies, turns on pointers to frames, and configures curve25519-dalek to use its most advanced mathematics without a standard library. </p><br><pre> <code class="hljs pgsql">[package] <span class="hljs-type"><span class="hljs-type">name</span></span> = "ed25519-dalek-rustgo" version = "0.0.0" [lib] crate-<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = ["staticlib"] [dependencies.curve25519-dalek] version = "^0.9" <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>-features = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> features = ["nightly"] [profile.<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br><p>  Well and still, we should correct our springboard that it accepted 2 arguments, and returned nothing: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">TEXT</span></span> ¬∑ScalarBaseMult(SB), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-meta"><span class="hljs-meta">$16384</span></span><span class="hljs-number"><span class="hljs-number">-16</span></span> MOVQ dst+<span class="hljs-number"><span class="hljs-number">0</span></span>(FP), DI MOVQ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>+<span class="hljs-number"><span class="hljs-number">8</span></span>(FP), SI MOVQ SP, BX ADDQ <span class="hljs-meta"><span class="hljs-meta">$16384</span></span>, SP ANDQ $~<span class="hljs-number"><span class="hljs-number">15</span></span>, SP MOVQ ¬∑_scalar_base_mult(SB), AX <span class="hljs-keyword"><span class="hljs-keyword">CALL</span></span> AX MOVQ BX, SP RET</code> </pre> <br><p>  The result will be a transparent call from Go with a speed comparable to a benchmark on a pure Go, and almost 6% faster than cgo! </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta RustScalarBaseMult <span class="hljs-number"><span class="hljs-number">23.7</span></span>¬µs ¬± <span class="hljs-number"><span class="hljs-number">1</span></span>% <span class="hljs-number"><span class="hljs-number">22.3</span></span>¬µs ¬± <span class="hljs-number"><span class="hljs-number">4</span></span>% <span class="hljs-number"><span class="hljs-number">-5.88</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.003</span></span> n=<span class="hljs-number"><span class="hljs-number">5</span></span>+<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br><p>  For comparison, the similar functionality from Go package <code>github.com/agl/ed25519/edwards25519</code> - net Go implementation spends almost 3 times more time: </p><br><pre> <code class="go hljs">h := &amp;edwards25519.ExtendedGroupElement{} edwards25519.GeScalarMultBase(h, &amp;k) h.ToBytes(&amp;dst)</code> </pre> <br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op GoScalarBaseMult <span class="hljs-number"><span class="hljs-number">66.1</span></span>¬µs ¬± <span class="hljs-number"><span class="hljs-number">2</span></span>%</code> </pre> <br><h1 id="pakuem-vsyo-vmeste">  We pack everything together </h1><br><p>  Now we know that it really works, great!  But in order to be able to actually use it, the solution must be in the form of a package that can be imported, and not forcefully inserted into <code>package main</code> using the muddy build process. </p><br><p>  And this is where <code>//go:binary-only-package</code> comes into play.  This annotation allows us to say to ignore the source code and use only the previously collected <code>.a</code> library file from <code>$GOPATH/pkg</code> . </p><br><p>  If we can compile a <code>.a</code> file that works with the native Go linker ( <a href="https://godoc.org/cmd/link">cmd / link</a> , also called an <em>internal linker</em> ), <strong>we can distribute it and this will allow users to import our package as if it were native code</strong> , including cross-compiling (meaning that we collected <code>.a</code> for this platform)! </p><br><p>  Often Go is simple and we already have a pair with an assembler and Rust.  We can even add documentation so that it can be seen through the <code>go doc</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:binary-only-package // Package edwards25519 implements operations on an Edwards curve that is // isomorphic to curve25519. // // Crypto operations are implemented by calling directly into the Rust // library curve25519-dalek, without cgo. // // You should not actually be using this. package edwards25519 import _ "unsafe" //go:cgo_import_static scalar_base_mult //go:linkname scalar_base_mult scalar_base_mult var scalar_base_mult uintptr var _scalar_base_mult = &amp;scalar_base_mult // ScalarBaseMult multiplies the scalar in by the curve basepoint, and writes // the compressed Edwards representation of the resulting point to dst. func ScalarBaseMult(dst, in *[32]byte)</span></span></code> </pre> <br><p>  The makefile changes slightly, because we no longer build the library, we can stop using the <code>go tool link</code> . </p><br><p>  An <code>.a</code> archive <code>.a</code> is just a collection of object <code>.o</code> files in an <a href="https://en.wikipedia.org/wiki/Ar_">ancient format along with a symbol table</a> .  If we could take the symbols from <code>libed25519_dalek_rustgo.a</code> to the <code>libed25519_dalek_rustgo.a</code> archive so that <code>go tool compile</code> saw them, we would reach the goal. </p><br><p>  The <code>.a</code> archives <code>.a</code> operated using the UNIX utilities <code>ar</code> or the internal analog Go - <a href="https://godoc.org/cmd/pack">cmd / pack</a> (via the <code>go tool pack</code> ).  These two formats are very slightly different, of course.  We will have to use <code>ar</code> for <code>libed25519_dalek_rustgo.a</code> and <code>cmd/pack</code> for <code>edwards25519.a</code> . </p><br><p>  (For example, <code>ar</code> on my macOS uses the <a href="https://en.wikipedia.org/wiki/Ar_(Unix)">BSD conventions</a> for calling the <code>#1/LEN</code> files and then inserting the file name of the length LEN at the beginning of this file to bypass 16 bytes of the maximum file length. This is confusing.) </p><br><p>  To link these two libraries together, I tried to do the simplest (read: crutch) way: extract <code>libed25519_dalek_rustgo.a</code> into a separate folder and then pack its objects back into <code>edwards25519.a</code> . </p><br><pre> <code class="hljs pgsql">edwards25519/edwards25519.a: edwards25519/rustgo.go edwards25519/rustgo.o target/<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>/libed25519_dalek_rustgo.a go tool compile -N -l -o $@ -p main -pack edwards25519/rustgo.go go tool pack r $@ edwards25519/rustgo.o # <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> edwards25519/rustgo.s mkdir -p target/<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>/libed25519_dalek_rustgo &amp;&amp; cd target/<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>/libed25519_dalek_rustgo &amp;&amp; \ rm -f *.o &amp;&amp; ar xv "$(CURDIR)/target/release/libed25519_dalek_rustgo.a" go tool pack r $@ target/<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>/libed25519_dalek_rustgo<span class="hljs-comment"><span class="hljs-comment">/*.o .PHONY: install install: edwards25519/edwards25519.a mkdir -p "$(shell go env GOPATH)/pkg/darwin_amd64/$(IMPORT_PATH)/" cp edwards25519/edwards25519.a "$(shell go env GOPATH)/pkg/darwin_amd64/$(IMPORT_PATH)/"</span></span></code> </pre><br><p>  Imagine my surprise when it worked! </p><br><p>  Having the <code>.a</code> file in the right place, it remains to write a simple program using this package: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bytes"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/hex"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/FiloSottile/ed25519-dalek-rustgo/edwards25519"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { input, _ := hex.DecodeString(<span class="hljs-string"><span class="hljs-string">"39129b3f7bbd7e17a39679b940018a737fc3bf430fcbc827029e67360aab3707"</span></span>) expected, _ := hex.DecodeString(<span class="hljs-string"><span class="hljs-string">"1cc4789ed5ea69f84ad460941ba0491ff532c1af1fa126733d6c7b62f7ebcbcf"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dst, k [<span class="hljs-number"><span class="hljs-number">32</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(k[:], input) edwards25519.ScalarBaseMult(&amp;dst, &amp;k) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !bytes.Equal(dst[:], expected) { fmt.Println(<span class="hljs-string"><span class="hljs-string">"rustgo produces a wrong result!"</span></span>) } fmt.Printf(<span class="hljs-string"><span class="hljs-string">"BenchmarkScalarBaseMult\t%v\n"</span></span>, testing.Benchmark(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { edwards25519.ScalarBaseMult(&amp;dst, &amp;k) } })) }</code> </pre> <br><p>  And run <code>go build</code> ! </p><br><pre> <code class="hljs ruby">$ go build -ldflags <span class="hljs-string"><span class="hljs-string">'-linkmode external -extldflags -lresolv'</span></span> $ ./ed25519-dalek-rustgo BenchmarkScalarBaseMult <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">19914</span></span> ns/op</code> </pre> <br><p>  Well, it almost worked.  I had to pohimichit a little.  The binary file carried compiled until we linked to <code>libresolv</code> .  To be honest, the Rust compiler tried to say this.  (But who is it that everything the Rust compiler says?) </p><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">note</span></span>: link against the following native artifacts <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> linking against this static <span class="hljs-keyword"><span class="hljs-keyword">library</span></span> <span class="hljs-literal"><span class="hljs-literal">note</span></span>: the order <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> any duplication can be significant <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> some platforms, <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> so may need <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be preserved <span class="hljs-literal"><span class="hljs-literal">note</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">library</span></span>: System <span class="hljs-literal"><span class="hljs-literal">note</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">library</span></span>: resolv <span class="hljs-literal"><span class="hljs-literal">note</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">library</span></span>: c <span class="hljs-literal"><span class="hljs-literal">note</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">library</span></span>: m</code> </pre> <br><p>  Now, linking to system libraries will be a problem, because it will never happen to the internal linker and cross-compilation ... </p><br><p>  But wait, lib resolve?  Why is our <code>no_std</code> , "should be as an assembler", only the Rust stack library is trying to use the standard DNS name resolver library? </p><br><h1 id="ya-skazal-no_std">  I said no_std </h1><br><p>  The problem here is that the library is not really <code>no_std</code> .  Look at everything that is here!  We do not need any allocators: </p><br><pre> <code class="hljs sql">$ ar t target/<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>/libed25519_dalek_rustgo.a __.SYMDEF ed25519_dalek_rustgo<span class="hljs-number"><span class="hljs-number">-742</span></span>a1d9f1c101d86<span class="hljs-number"><span class="hljs-number">.0</span></span>.o ed25519_dalek_rustgo<span class="hljs-number"><span class="hljs-number">-742</span></span>a1d9f1c101d86.crate.allocator.o curve25519_dalek<span class="hljs-number"><span class="hljs-number">-03e3</span></span>ca0f6d904d88<span class="hljs-number"><span class="hljs-number">.0</span></span>.o subtle-cd04b61500f6e56a<span class="hljs-number"><span class="hljs-number">.0</span></span>.o <span class="hljs-keyword"><span class="hljs-keyword">std</span></span><span class="hljs-number"><span class="hljs-number">-72653</span></span>eb2361f5909<span class="hljs-number"><span class="hljs-number">.0</span></span>.o panic_unwind-d0b88496572d35a9<span class="hljs-number"><span class="hljs-number">.0</span></span>.o unwind-da13b913698118f9<span class="hljs-number"><span class="hljs-number">.0</span></span>.o arrayref<span class="hljs-number"><span class="hljs-number">-2</span></span>be0c0ff08ae2c7d<span class="hljs-number"><span class="hljs-number">.0</span></span>.o digest-f1373d68da35ca45<span class="hljs-number"><span class="hljs-number">.0</span></span>.o generic_array<span class="hljs-number"><span class="hljs-number">-95</span></span>ca86a62dc11ddc<span class="hljs-number"><span class="hljs-number">.0</span></span>.o nodrop<span class="hljs-number"><span class="hljs-number">-7</span></span>df18ca19bb4fc21<span class="hljs-number"><span class="hljs-number">.0</span></span>.o odds<span class="hljs-number"><span class="hljs-number">-3</span></span>bc0ea0bdf8209aa<span class="hljs-number"><span class="hljs-number">.0</span></span>.o typenum-a61a9024d805e64e<span class="hljs-number"><span class="hljs-number">.0</span></span>.o <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>-e0d585156faee9eb<span class="hljs-number"><span class="hljs-number">.0</span></span>.o alloc_system-c942637a1f049140<span class="hljs-number"><span class="hljs-number">.0</span></span>.o libc-e038d130d15e5dae<span class="hljs-number"><span class="hljs-number">.0</span></span>.o alloc<span class="hljs-number"><span class="hljs-number">-0e789</span></span>b712308019f<span class="hljs-number"><span class="hljs-number">.0</span></span>.o std_unicode<span class="hljs-number"><span class="hljs-number">-9735142</span></span>be30abc63<span class="hljs-number"><span class="hljs-number">.0</span></span>.o compiler_builtins<span class="hljs-number"><span class="hljs-number">-8</span></span>a5da980a34153c7<span class="hljs-number"><span class="hljs-number">.0</span></span>.o absvdi2.o absvsi2.o absvti2.o [... snip ...] truncsfhf2.o ucmpdi2.o ucmpti2.o core<span class="hljs-number"><span class="hljs-number">-9077840</span></span>c2cc91cbf<span class="hljs-number"><span class="hljs-number">.0</span></span>.o</code> </pre> <br><p>  So, how do we make it <code>no_std</code> ?  This turned out to be a <a href="https://twitter.com/FiloSottile/status/894663496410988544">separate adventure</a> , but I will write only conclusions: </p><br><ul><li>  if any dependency is not <code>no_std</code> , your <code>no_std</code> flag will be reset.  One of the dependencies of <code>curve25519-dalek</code> had this problem and <code>cargo update</code> fixed it. </li><li>  if you make <code>no_std</code> static library (that is, a library for external use, and not just inside Rust), then this is how to make the <code>`no_std</code> executable binary, which is much more complicated if it should be self-sufficient </li><li>  documentation on how to make a <code>no_std</code> binary is very <code>no_std</code> .  I mainly used the <a href="https://doc.rust-lang.org/1.5.0/book/no-stdlib.html">old version of the book on Rust</a> and, as a result, I found <a href="https://doc.rust-lang.org/beta/unstable-book/language-features/lang-items.html">this section on lang_items</a> .  <a href="https://os.phil-opp.com/set-up-rust/">This post</a> also helped. </li><li>  To begin with, you must define the "lang_items" functions to implement the functionality that is usually found in the standard library, like <code>panic_fmt</code> . </li><li>  then you are left without Rust <code>compiler-rt</code> equivalents, so you must import crate compiler_builtins ( <a href="https://github.com/rust-lang/rust/issues/43264">rust-lang / rust # 43264</a> ) </li><li>      <code>rust_begin_unwind</code> ,        <code>no_mangle</code>  <code>panic_fmt</code> ,     ( <a href="https://github.com/rust-lang/rust/issues/38281">rust-lang/rust#38281</a> ) </li><li>     <code>memcpy</code> , ,  ,     Rust  <a href="https://github.com/alexcrichton/rlibc"><code>rlibc</code></a> .    <a href="https://github.com/rust-lang-nursery/compiler-builtins/issues/182"></a> ,  <code>nm -u</code> ,      . </li></ul><br><p>           <code>lib.rs</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span> <span class="hljs-meta"><span class="hljs-meta">#![feature(lang_items, compiler_builtins_lib, core_intrinsics)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> core::intrinsics; <span class="hljs-meta"><span class="hljs-meta">#[allow(private_no_mangle_fns)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-comment"><span class="hljs-comment">// rust-lang/rust#38281 #[lang = "panic_fmt"] fn panic_fmt() -&gt; ! { unsafe { intrinsics::abort() } } #[lang = "eh_personality"] extern fn eh_personality() {} extern crate compiler_builtins; // rust-lang/rust#43264 extern crate rlibc;</span></span></code> </pre> <br><p>   , <code>go build</code>  (!!!)  macOS. </p><br><h1 id="linux">  Linux </h1><br><p>   Linux    . </p><br><p>     <code>fmax</code>    ,  , , : </p><br><pre> <code class="hljs ruby">$ ld -r -o linux.o target/release/libed25519_dalek_rustgo/*.o $ nm -u linux.o U _GLOBAL_OFFSET_TABLE<span class="hljs-number"><span class="hljs-number">_</span></span> U abort U fmax U fmaxf U fmaxl U logb U logbf U logbl U scalbn U scalbnf U scalbnl</code> </pre> <br><p>  ,   ,    <code>--gc-sections</code>    ,     ,    . ,  ,   (   ): </p><br><pre> <code class="hljs ruby">$ go build -ldflags <span class="hljs-string"><span class="hljs-string">'-extld clang -linkmode external -extldflags -Wl,--gc-sections'</span></span></code> </pre> <br><p> , ,   Makefile     ,    <code>--gc-sections</code> ?   ,    <code>.a</code>     <a href="https://linux.die.net/man/1/ld">man- </a> . </p><br><p>    <code>.o</code> ,      ,       <code>ld -r --gc-sections -u $SYMBOL</code> .  <code>-r</code>          <code>-u</code>    "",       . <code>$SYMBOL</code>  <code>scalar_base_mult</code>   . </p><br><p>       macOS?   ,     ,  ,    macOS     . </p><br><pre> <code class="hljs python">$ ld -e _scalar_base_mult target/release/libed25519_dalek_rustgo/*.o Undefined symbols <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> architecture x86_64: <span class="hljs-string"><span class="hljs-string">"___assert_rtn"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: _compilerrt_abort_impl <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> int_util.o <span class="hljs-string"><span class="hljs-string">"_copysign"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divdc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divdc3.o ___muldc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> muldc3.o <span class="hljs-string"><span class="hljs-string">"_copysignf"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divsc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divsc3.o ___mulsc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mulsc3.o <span class="hljs-string"><span class="hljs-string">"_copysignl"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divxc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divxc3.o ___mulxc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mulxc3.o <span class="hljs-string"><span class="hljs-string">"_fmax"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divdc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divdc3.o <span class="hljs-string"><span class="hljs-string">"_fmaxf"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divsc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divsc3.o <span class="hljs-string"><span class="hljs-string">"_fmaxl"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divxc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divxc3.o <span class="hljs-string"><span class="hljs-string">"_logb"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divdc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divdc3.o <span class="hljs-string"><span class="hljs-string">"_logbf"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divsc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divsc3.o <span class="hljs-string"><span class="hljs-string">"_logbl"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divxc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divxc3.o <span class="hljs-string"><span class="hljs-string">"_scalbn"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divdc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divdc3.o <span class="hljs-string"><span class="hljs-string">"_scalbnf"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divsc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divsc3.o <span class="hljs-string"><span class="hljs-string">"_scalbnl"</span></span>, referenced <span class="hljs-keyword"><span class="hljs-keyword">from</span></span>: ___divxc3 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> divxc3.o ld: symbol(s) <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> found <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inferred architecture x86_64 $ ld -e _scalar_base_mult -dead_strip target/release/libed25519_dalek_rustgo/*.o</code> </pre> <br><p>   ,  <a href="https://github.com/rust-lang/rust/issues/35052"><code>  ,  macOS  _</code>    </a> ,   . </p><br><p>  ,   Makefile,        :] </p><br><pre> <code class="hljs mel">edwards25519/edwards25519.a: edwards25519/rustgo.go edwards25519/rustgo.o edwards25519/libed25519_dalek_rustgo.o go tool compile -N -l -o $@ -p main -pack edwards25519/rustgo.go go tool pack r $@ edwards25519/rustgo.o edwards25519/libed25519_dalek_rustgo.o edwards25519/libed25519_dalek_rustgo.o: target/$(TARGET)/release/libed25519_dalek_rustgo.a ifeq ($(shell go <span class="hljs-keyword"><span class="hljs-keyword">env</span></span> GOOS),darwin) $(LD) -r -o $@ -arch x86_64 -u <span class="hljs-string"><span class="hljs-string">"_$(SYMBOL)"</span></span> $^ <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> $(LD) -r -o $@ --gc-sections -u <span class="hljs-string"><span class="hljs-string">"$(SYMBOL)"</span></span> $^ endif</code> </pre> <br><p>        Linux.  , <a href="https://gist.github.com/FiloSottile/0d938bc4e8a7f3eab1fa4f672c334842">  </a> ,     .      <code>CALL</code>    Rust     . </p><br><p>     ,   -   ,     rustgo,   ,   ,  .       <a href="https://gist.github.com/FiloSottile/0d938bc4e8a7f3eab1fa4f672c334842"> cmd/link</a> (  !),    ,    Go,     ,  <code>//cgo:cgo_import_static</code>    ,        <code>//cgo:cgo_import_dynamic</code> . </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//go:cgo_import_static scalar_base_mult //go:cgo_import_dynamic scalar_base_mult</span></span></code> </pre> <br><p>     ,      ,      -  rustgo        ,   macOS,    Linux,  . </p><br><h1 id="rasprostranenie-paketa">   </h1><br><p> ,     <code>.a</code> ,       <code>//go:binary-only-package</code>   tar-  <code>.a</code>   <code>linux_amd64/darwin_amd64</code>   ,        : </p><br><pre> <code class="hljs coffeescript">$ tar tf ed25519-dalek-rustgo_go1<span class="hljs-number"><span class="hljs-number">.8</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>.tar.gz src<span class="hljs-regexp"><span class="hljs-regexp">/github.com/FiloSottile/ed25519-dalek-rustgo/</span></span> src<span class="hljs-regexp"><span class="hljs-regexp">/github.com/FiloSottile/ed25519-dalek-rustgo/</span></span>.gitignore src<span class="hljs-regexp"><span class="hljs-regexp">/github.com/FiloSottile/ed25519-dalek-rustgo/Cargo.lock src/github.com/FiloSottile/ed25519-dalek-rustgo/Cargo.toml src/github.com/FiloSottile/ed25519-dalek-rustgo/edwards25519/</span></span> src<span class="hljs-regexp"><span class="hljs-regexp">/github.com/FiloSottile/ed25519-dalek-rustgo/main.go src/github.com/FiloSottile/ed25519-dalek-rustgo/Makefile src/github.com/FiloSottile/ed25519-dalek-rustgo/release.sh src/github.com/FiloSottile/ed25519-dalek-rustgo/src/</span></span> src/github.com/FiloSottile/ed25519-dalek-rustgo/target.go src/github.com/FiloSottile/ed25519-dalek-rustgo/src/lib.rs src/github.com/FiloSottile/ed25519-dalek-rustgo/edwards25519/rustgo.go src/github.com/FiloSottile/ed25519-dalek-rustgo/edwards25519/rustgo.s pkg/linux_amd64/github.com/FiloSottile/ed25519-dalek-rustgo/edwards25519.a pkg/darwin_amd64/github.com/FiloSottile/ed25519-dalek-rustgo/edwards25519.a</code> </pre> <br><p>    ,       ,     - (      <code>.a</code>  ). </p><br><p>  ,       ,  ,     Rust  <code>-Ctarget-cpu=native</code> ,       .   (  <a href="https://twitter.com/isislovecruft/status/887787163072507904">curve25519-dalek authors</a> )         -   Haswell ,         Haswell: </p><br><pre> <code class="hljs pgsql">$ benchstat bench-<span class="hljs-keyword"><span class="hljs-keyword">none</span></span>.txt bench-haswell.txt <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta ScalarBaseMult/rustgo <span class="hljs-number"><span class="hljs-number">22.0</span></span>¬µs ¬± <span class="hljs-number"><span class="hljs-number">3</span></span>% <span class="hljs-number"><span class="hljs-number">20.2</span></span>¬µs ¬± <span class="hljs-number"><span class="hljs-number">2</span></span>% <span class="hljs-number"><span class="hljs-number">-8.41</span></span>% (p=<span class="hljs-number"><span class="hljs-number">0.001</span></span> n=<span class="hljs-number"><span class="hljs-number">7</span></span>+<span class="hljs-number"><span class="hljs-number">6</span></span>) $ benchstat bench-haswell.txt bench-native.txt <span class="hljs-type"><span class="hljs-type">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">old</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">time</span></span>/op delta ScalarBaseMult/rustgo <span class="hljs-number"><span class="hljs-number">20.2</span></span>¬µs ¬± <span class="hljs-number"><span class="hljs-number">2</span></span>% <span class="hljs-number"><span class="hljs-number">20.1</span></span>¬µs ¬± <span class="hljs-number"><span class="hljs-number">2</span></span>% ~ (p=<span class="hljs-number"><span class="hljs-number">0.945</span></span> n=<span class="hljs-number"><span class="hljs-number">6</span></span>+<span class="hljs-number"><span class="hljs-number">7</span></span>)</code> </pre> <br><p>      ,  ,  Makefile  GOOS/GOARCH,       Rust,      Rust  -,    -  <code>.a</code> . </p><br><p>    : github.com/FiloSottile/ed25519-dalek-rustgo/edwards25519 <br>     <a href="https://godoc.org/github.com/FiloSottile/ed25519-dalek-rustgo/edwards25519">godoc</a> . </p><br><h1 id="prevraschaya-eto-v-nechto-realnoe">      </h1><br><p> ,   . </p><br><p> ,  , rustgo    ,      . ,  ,     <code>g</code>  ,      ,    ,  ,     .     Rust    . </p><br><p>        ,      <code>morestack</code>   <code>NOSPLIT</code>  ,  ,         (   <code>rsp</code> )  , ,     Rust  ( ). </p><br><p>    ,      - "rustgo" ,     Makefile  . Cgo     ,     .        <code>go:generate</code> ,    -,      cargo (-,  Go  Rust!).   FFI-   Rust,  <code>GoSlice</code>    . </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[repr(C)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GoSlice</span></span></span></span> { array: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, len: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, cap: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>   -   Go  Rust     ,    . </p><br><p>  Ps. ,  -     cgo (     )   Go, rustgo     ,  .  ,    ,  ,  -     ,   .   ,  ,   . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337348/">https://habr.com/ru/post/337348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337338/index.html">How to determine the mobile operator and home region by phone number</a></li>
<li><a href="../337340/index.html">The last countdown - Google has fun</a></li>
<li><a href="../337342/index.html">At the same place, at the same time: we are waiting for you at the new meeting of Android developers in the LC</a></li>
<li><a href="../337344/index.html">Critical analysis of old and synthesis of new knowledge will make Testing software science</a></li>
<li><a href="../337346/index.html">Waiting for 15 years. Nginx Application Server</a></li>
<li><a href="../337350/index.html">Use Stream API easier (or do not use at all)</a></li>
<li><a href="../337352/index.html">Time off the hook: turning emotions into allies</a></li>
<li><a href="../337354/index.html">5 myths about personal data</a></li>
<li><a href="../337356/index.html">Real Offline Perfect Forward Secrecy for your products</a></li>
<li><a href="../337358/index.html">Great collection of free fonts: the best of the best</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>