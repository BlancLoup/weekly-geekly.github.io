<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Vulkan API (glNext) from Khronos Group</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Relatively recently, the new Vulkan API was released - one can say the heir to OpenGL, although Vulkan is based on the AMD Mantle API. 
 Of course, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Vulkan API (glNext) from Khronos Group</h1><div class="post__text post__text-html js-mediator-article">  Relatively recently, the new Vulkan API was released - one can say the heir to OpenGL, although Vulkan is based on the AMD Mantle API. <br>  Of course, the development and support of OpenGL did not stop, and DirectX 12 was released as well. What about DirectX 12 and why it was installed only on Windows 10 - I, unfortunately (and maybe fortunately) do not know.  But the cross-platform Vulkan interested me.  What are the features of Vulkan and how to use it correctly, I will try to tell you in this article. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a9a/d28/398/a9ad28398c9b8c7bb8919cabab78e9fb.png" alt="Vulkan Logo"></div><br><br>  So what is Vulkan for and where can it be used?  In games and applications that work with graphics?  Of course!  Calculate how does CUDA or OpenCL do it?  No problem.  Do we need a window or display for this?  Of course not, you can specify for yourself where to broadcast your result or not to broadcast it at all.  But first things first. <br><a name="habracut"></a><br><h2>  API design and basics </h2><br>  Perhaps we should start with the simplest.  Since the <a href="https://www.khronos.org/">Khronous Group</a> worked on the Vulkan API, the syntax is very similar to OpenGL.  There is a vk prefix in the whole API.  For example, functions (sometimes even with very long names) look like this: vkDoSomething (...), the names of structures or handles: VkSomething, and all constant expressions (macros, macro calls and enumeration elements): VK_SOMETHING.  Also, there is a special kind of functions - commands that add the prefix Cmd: vkCmdJustDoIt (...). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can write on Vulkan both in C and in C ++.  But the second option will give, of course, more convenience.  There are (and will be created) ports to other languages.  Someone has already made a port on Delphi, someone wants (why?) A port in Python. <br><br>  So, how to create a render context?  No  Here it is not.  Instead, it came up with other things with different names that would even resemble DirectX. <br><br><h2>  Getting started and basic concepts </h2><br>  Vulkan separates two concepts - a <b>device</b> ( <i>device</i> ) and a <b>host</b> ( <i>host</i> ).  The device will execute all commands sent to it, and the host will send them.  In fact, our application is the host - Vulkan has this terminology. <br><br>  To work with Vulkan, we will need handles for its <i>instance</i> , and maybe not even one, but also the <b>device</b> , again, it may not always be enough for one. <br><br>  Vulkan can be easily loaded dynamically.  In the SDK (developed by <a href="http://lunarg.com/">LunarG</a> ), if the VK_NO_PROTOTYPES macro was declared and the Vulkan library was uploaded with their own hands (not by linker, but by certain means in the code), first of all, the vkGetInstanceProcAddr function would be needed, which can be used to find out the addresses of the main Vulkan functions - those that work without an instance, including the function of its creation, and functions that work with the instance, including the function of its destruction and the function of creating a device.  After creating a device, you can get the functions that work with it (as well as its child handles) via vkGetDeviceProcAddr. <br><br>  Interesting fact: in Vulkan, you always need to fill in a certain structure with data to create an object.  And everything in Vulkan works like this: prepared in advance - can be used often and with high performance.  In the information about the instance, you can also put information about your application, engine version, version of the API used and other information. <br><br><h2>  Layers and extensions </h2><br>  In pure Vulkan there are no strong checks on incoming data for correctness.  He was told to do something - he would do.  Even if this results in an application, driver, or video card error.  This is done for performance.  However, you can easily connect <i>test layers</i> , as well as <i>extensions</i> to the instance and / or device, if necessary. <br><br><h3>  Layers (layers) </h3><br>  Basically, the purpose of the layers is to check incoming data for errors and monitor the work of Vulkan.  They work very simply: let's say we call a function, and it gets into the topmost layer specified when creating the device or instance earlier.  He checks everything for correctness, then transfers the call to the next one.  And so it will be, until it comes to the core of Vulkan.  Of course, you can create your own layers.  For example, Steam released the SteamOverlay layer (although I don‚Äôt know what it does at all).  Nevertheless, the layers will be silent, but they will not bring the application to ruin.  How to find out if everything is done correctly?  For this there is a special extension! <br><br><h3>  Extensions (extensions) </h3><br>  As the name implies, they extend the work of Vulkan with additional functionality.  For example, one extension (debug report) will display errors (and not only) from all layers.  To do this, you will need to specify the necessary Callback function, and it is up to you to decide what to do with the information received by this function.  Please note that this is a Callback and a delay can cost you dearly, especially if you display all the information received directly to the console.  After processing the message, you can specify whether to transfer the function call further (to the next layer) or not - this way you can avoid critical errors, but try to work further with less dangerous errors. <br>  There are also other extensions, some of which I will discuss later in this article. <br><br><h2>  Device </h2><br>  Vulkan separates the concepts of physical device and logical.  <i>The physical device</i> can be your video card (and not one) or a processor that supports graphics.  <i>The logical device</i> is created on the basis of the physical: information is collected about the physical devices, the necessary is selected, other necessary information is prepared and the device is created.  There may be several logical devices based on one physical one, but it is not possible to combine physical devices (yet?) For a single operation. <br><br>  So, what kind of information we collect?  These are, of course, the supported formats, memory, features, and, of course, the queue families. <br><br><h2>  Queues and queue families </h2><br>  The device can (or cannot) do the following 4 things: draw graphics, perform various calculations, copy data, and also work with sparse memory management.  These features are represented as queue families: each family supports certain (maybe all at once) capabilities.  And if identical families were divided, Vulkan would still present them as one family, so that we would not suffer so much with the code and choose the right family. <br><br>  After you have selected the necessary (or necessary) families, you can get queues from them.  Queues - this is the place where the commands for the device will arrive (then the device will be taken from the queues and executed).  Queues and families, by the way, not much.  NVIDIA usually has one family with all the features for 16 queues.  Once you are done with the selection of families and the number of queues, you can create a device. <br><br><h2>  Commands, their execution and synchronization </h2><br>  All commands for the device are placed in a special container - the command buffer.  Those.  there is not a single function in Vulkan that would tell the device to do something right away and, at the end of the operation, return control to the application.  There are only functions for filling the command buffer with certain commands (for example, draw something or copy an image).  Only after recording the command buffer on the host can we send it to the queue, which, as we already know, is in the device. <br><br>  The command buffer is of two types: primary and secondary.  Primary goes straight to the queue.  The secondary can not be sent - it starts in the primary.  Commands are written in the same order in which the functions were called.  In turn, they come in the same manner.  But they can come true almost in a "chaotic" order.  To avoid complete chaos in the application, Vulkan developers have provided a means of synchronization. <br><br>  Now, the most important thing: the host <b>does not</b> wait for the completion of the execution of commands and command buffers.  At least until you specify it in an explicit way.  After sending the command buffers to the queue, control is immediately returned to the application. <br><br>  There are 4 synchronization primitives: fence (fence), semaphore (semaphore), event (event) and barrier (barrier). <br><br>  <b>The fence</b> is the easiest method of synchronization - it allows the host to expect to do certain things.  For example, the completion of the command buffer.  But the fence is rarely used. <br><br>  <b>Semaphore</b> - a way to synchronize inside the device.  You can‚Äôt see its status or wait for it on the host, you can‚Äôt also wait for it inside the command buffer, but we can specify which semaphore should give a signal when all the commands in the buffer have completed, and which semaphore to wait before starting the commands in the buffer.  Only not all the buffer will wait, but its certain stage. <br><br><div class="spoiler">  <b class="spoiler_title">Pipeline stages and performance dependencies</b> <div class="spoiler_text">  As already mentioned, not necessarily the teams in the queue will be executed in order.  To be more precise, subsequent teams will not wait for the completion of the previous ones.  They can be executed in parallel, or the execution of the previous command can be completed much later than the subsequent ones.  And this is quite normal.  But some teams <b>depend</b> on the performance of others.  You can divide them into two shores: ‚Äúbefore‚Äù and ‚Äúafter‚Äù, and also indicate which stages of ‚Äúbefore‚Äù shore must necessarily be executed (that is, commands may not complete completely or not all) before the indicated steps begin coast teams "after."  For example, drawing an image may pause to do certain things, and then continue to draw again.  There may also be a chain of dependencies, but we will not go deep into the <s>forests of Siberia</s> Vulkan. <br></div></div><br><br>  <b>Events</b> - element of "fine" settings.  You can signal both from the host and from the device; you can also wait on the device and on the host.  The event defines the dependency of two sets of commands (before and after) in the command buffer.  And for the event there is also a special pseudo-stage that allows the host to wait. <br><br>  <b>The barrier</b> can again be used only in the device, and more precisely in the command buffer, declaring the dependencies of the first and second set of commands.  You can also optionally specify memory barriers, which are of three types: <i>global</i> barrier, <i>buffer</i> barrier and <i>image</i> barrier.  They will not inadvertently read the data that is currently being written and / or vice versa, depending on the specified parameters. <br><br><h2>  Conveyors </h2><br>  Below are two Vulkan pipelines: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/edc/687/d3d/edc687d3d00a02a58c79407446e1b87a.png" alt="Vulkan Pipeline"><br><br>  Those.  Vulkan has two pipelines: <b>graphic</b> and <b>computing</b> .  With the help of graphic, we, of course, can draw, and computational ... calculate.  What else?  The results of the calculations can then go to the graphics pipeline.  So you can easily save time on a particle system, for example. <br><br>  You cannot change the order or change the pipeline stages themselves.  The exceptions are programmable stages (shaders).  You can also send various data to shaders (and not only) through descriptors. <br><br>  For a pipeline, you can create a cache that can be used (over and over) in other pipelines and even after restarting the application. <br><br>  The pipeline must be configured and associated with the command buffer before the latter will use pipeline commands. <br><br><div class="spoiler">  <b class="spoiler_title">Inheritance of conveyors</b> <div class="spoiler_text">  Since the pipeline is actually all the information about how to work with incoming data, changing the pipeline (and this is information about shaders, descriptors, rasterization, etc.) can be costly in time.  Therefore, the developers have provided the opportunity to inherit the pipeline.  If you change the pipeline to a child, the parent or between children, it will take less than the cost of performance.  But it is also a convenience for developers, such as OOP. <br></div></div><br><br><h3>  Render pass, graphics pipeline and framebuffer </h3><br>  So, we get the following matryoshka: <br><br>  In order to be able to use the drawing commands, you need a graphics pipeline.  In the graphics pipeline, you must specify the <i>Render Pass</i> , which contains information about <b>subpass</b> , their dependencies on each other, and <i>attachments</i> .  Attachment - information about the image that will be used in framebuffers.  Framebuffer is created specifically for a particular rendering pass.  To start the passage, you need to specify both the passage itself (as well as, if necessary, the subpass) and the framebuffer.  After the start of the passage you can draw.  You can also switch between subways.  After drawing is complete, you can complete the pass. <br><br><h2>  Memory Management and Resources </h2><br>  The memory in Vulkan is shared by the host and only by the host (with the exception of swapchain).  If the image (or other data) needs to be placed in the device, memory is allocated.  First, a resource of a certain size is created, then its memory requirements are requested, memory is allocated for it, then the resource is associated with a section of this memory and only then the necessary data can be copied to this resource.  Also, there is a memory that can be directly changed from the host (host visible), there is a local memory of the device (video card memory, for example) and other types of memory that affect the speed of access to them. <br><br>  In Vulkan, you can also write your own host memory allocation by configuring the Callback function.  But keep in mind that memory requirements are not only its size, but also <u>alignment</u> . <br><br>  The resources themselves are of two types: <b>buffers</b> ( <i>buffers</i> ) and <b>images</b> ( <i>images</i> ).  Both are divided by purpose, but if the buffer is just a collection of various data (vertex, index or constant buffer), then the image always has its own format. <br><br><div class="spoiler">  <b class="spoiler_title">Instruction to those who write on Vulkan</b> <div class="spoiler_text">  Allocate a section of memory in which you can put several resources at once.  The amount of discharge is limited and you may not have enough.  But the number of associations is not limited. <br></div></div><br><br><h2>  Shaders </h2><br>  Vulkan supports 6 types of shaders: <i>vertex</i> , <i>tessellation control, tessellation</i> <i>analysis</i> , <i>geometric</i> , <i>fragmentary</i> (aka <i>pixel</i> ) and <i>computational</i> .  You can write them on the readable SPIR-V, and then assemble the code in the byte, which we will print to the module in the application, i.e.  create a shader module from this code.  Of course, we can write it in the usual GLSL and then convert it to SPIR-V (there is already a translator).  And, of course, you can write your own translator and even an assembler - the source code and specifications are laid out in OpenSource, nothing prevents you from writing a collector for your High Level SPIR-V.  Or maybe someone has already written. <br>  The byte code is then translated into commands specific to each video card, but this is done much faster than from raw GLSL code.  This practice is also used in DirectX - HLSL is first converted into byte code, and this byte code can be saved and then used to not compile the shaders again and again. <br><br><h2>  Windows and displays </h2><br>  And this article will end the story of WSI (Window System Integration) and the switching chain (swapchain).  In order to display something in the window or on the screen - you need special extensions. <br><br>  For windows, this is the base plane extension and the plane extension specific to each of the systems (win32, xlib, xcb, android, mir, wayland).  For the display (i.e. FullScreen), the display extension is needed, but in general both of them use the swapchain extension. <br><br>  The switching chain is not connected to the graphics pipeline, so a simple Clear Screen comes out without setting all this up.  Everything is quite simple.  There is a certain presentation engine, in which there is a queue of images.  One image is displayed on the screen, others wait for their turn.  The number of images we can also specify.  There are also several modes that allow you to wait for the vertical sync signal. <br><br>  The method of operation is approximately as follows: we request a free image index, call the command buffer, which copies the result from the Framebuffer to this image, and send a command to send the image to the queue.  It sounds easy, but given the need for synchronization, everything is a little more complicated, since the only thing that the host expects is the image index, which will <u>soon</u> be available.  The command buffer waits for the semaphore signal, which will indicate the availability of the image, and then send a signal through the semaphore that the buffer execution, and therefore copying, is completed.  And the image will actually go to the queue at the signal of the last semaphore.  There are only two semaphores: the availability of the image for copying and the availability of the image for display (i.e., the completion of copying). <br><br>  By the way, I checked that the same command buffer actually went to the queue several times.  You can think for yourself what that means. <br><br>  In this article I tried to talk about the most important parts of the Vulkan API, but much is still not told and you can find out for yourself.  Stable FPS and pleasant coding. </div><p>Source: <a href="https://habr.com/ru/post/283490/">https://habr.com/ru/post/283490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../283478/index.html">Communication 2016: what's interesting?</a></li>
<li><a href="../283480/index.html">NFC - to the masses. New technologies at Eurovision, music and sports venues</a></li>
<li><a href="../283482/index.html">Once again about how not to make a ‚Äúsieve‚Äù from your network</a></li>
<li><a href="../283484/index.html">Errors when connecting payments on the Internet</a></li>
<li><a href="../283488/index.html">Removing the image from the OV7670 camera to a VGA monitor using FPGA</a></li>
<li><a href="../283492/index.html">Let's collect a moss-mite under a microscope or focus-stacking photos from the console</a></li>
<li><a href="../283494/index.html">Developing a simple pedometer application on ReactNative</a></li>
<li><a href="../283496/index.html">In the Opera browser appeared power saving mode</a></li>
<li><a href="../283498/index.html">Announcement of the track Windows conference DevCon 2016</a></li>
<li><a href="../283502/index.html">Chess Ice and Flame</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>