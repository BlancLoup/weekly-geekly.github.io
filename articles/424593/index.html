<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ 11 and event handling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think that event handling as a way of interacting objects in OOP is known to almost everyone who has ever touched OOP. At least, this approach is ve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ 11 and event handling</h1><div class="post__text post__text-html js-mediator-article">  I think that event handling as a way of interacting objects in OOP is known to almost everyone who has ever touched OOP.  At least, this approach is very convenient in a very wide, in my opinion, range of tasks.  In many programming languages, an event handling mechanism is built-in;  however, there is no such mechanism in C ++.  Let's see what can be done about it. <br><a name="habracut"></a><br><a name="Intro"></a><h1>  Brief introduction </h1><br>  <i>An event</i> is something that can happen to some object under certain conditions (for example, a button when you click on it with the mouse).  Other objects may need to be aware of this;  then they <i>subscribe to the event</i> .  In this case, when an event occurs, the <i>handler of a</i> third-party object subscribed to the event is called;  thus, it is possible for him to execute some code, i.e.  respond to the event.  Similarly, an object can <i>unsubscribe from an event</i> if it does not want to respond to it anymore.  As a result, we have a lot of objects that can be connected with each other through the events of one of them and the reaction to these events of others. <br><br>  Somehow, although everyone knows this. <br><br><a name="Trivial"></a><h1>  The simplest implementation </h1><br>  It would seem to implement such behavior is easy.  And it could look like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventHandler() {} };</code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers() { } ~TEvent() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> oneHandler; m_handlers.clear(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( TEventHandler* oneHandler : m_handlers ) oneHandler-&gt;call( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { m_handlers.push_back( &amp;eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TObject&amp; object, TMethod method ) : AbstractEventHandler&lt;TParams...&gt;(), m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ ( m_object.*m_method )( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createMethodEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">:</span></span>:*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;TObject, TParams...&gt;( object, method ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br>  The application of this case should be: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ ... } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  Naturally, a handler method (a member function of a class) will not be the only type of handler, but more on that later. <br><br>  It seems everything is convenient, compact and cool.  But while there are a number of flaws. <br><br><a name="HandlerCompare"></a><h1>  Handler comparison </h1><br>  To implement the unsubscribe from the event, you must add a comparison capability to the handler ( <i>==</i> and <i>! ==</i> ).  Equal will be considered such handlers that call the same method (-function-member of a class) of the same object (that is, the same instance of the same class). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; &amp;m_object == &amp;_other.m_object &amp;&amp; m_method == _other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TObject&amp; m_object; TMethod m_method; . . . };</code> </pre><br>  Then we will be able to remove handlers from the event subscription.  In this case, you must prevent the addition of the same (equal) handlers. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( &amp;eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> removedEventHandler; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TEventHandlerIt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findEventHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TEventHandler* oneHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( *oneHandler == eventHandler ); } ); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt; m_handlers; . . . };</code> </pre><br>  Here, the handler's add / remove functions return <i>true</i> if successful, and <i>false</i> if the corresponding action (add or delete) was not performed. <br><br>  Yes, the use case with comparison implies the creation of temporary, not added handlers, which are not deleted anywhere.  But more about that later. <br><br>  Can I use it?  Not yet fully. <br><br><a name="HandlerRemoving"></a><h1>  Delete handler inside handler </h1><br>  So, we immediately encounter a crash when executing the code, where the handler itself writes itself off from the event (I think it's not the rarest <i>use case</i> when the handler self-spits under any conditions): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TestWindow&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">instance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testWindowButtonClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ TestWindow::instance().onButtonClick -= MY_METHOD_HANDLER( ClickEventHandler::testWindowButtonClick ); } . . . }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . ClickEventHandler clickEventHandler; TestWindow::instance().onButtonClick += METHOD_HANDLER( clickEventHandler, ClickEventHandler::testWindowButtonClick ); . . . }</code> </pre><br>  The problem occurs for a very simple reason: <br><br><ul><li>  the event is triggered and starts iterating through (with the help of iterators) handlers, calling them; </li><li>  another handler inside causes itself to delete itself; </li><li>  event removes the given handler, making the corresponding iterator invalid; </li><li>  after this handler is completed, the event returns to the rest, but the current iterator (corresponding to the remote handler) is no longer valid; </li><li>  an event tries to access an invalid iterator, causing a crash. </li></ul><br>  Therefore, it is necessary to check the cases when the list of handlers can be changed, which would lead to the invalidity of the iterators;  and then implement read protection for such iterators. <br><br>  The advantage of <a href="https://en.cppreference.com/w/cpp/container/list">std :: list</a> 'and in this application is the fact that when deleting it makes invalid only one iterator - per deleted item (affecting, for example, the subsequent elements);  and the addition of an element does not lead to any iterators being invalid.  Thus, we need to check a single case: the removal of an element whose iterator is current in the current iteration of elements.  In this case, you can, for example, not delete the element, but simply mark that the current element is to be deleted, and let it be done inside the search of elements. <br><br>  It would be possible to immediately roll out the implementation of this, but I propose to solve this problem together with the following. <br><br><a name="ThreadSafety"></a><h1>  Thread safety </h1><br>  Potentially, calls to three possible functions ‚Äî add, delete, and iterate (when an event fires) handlers ‚Äî are possible from different threads at random points in time.  This creates a whole field of opportunities for their "intersection" in time, "overlaying" their performance on each other and the fall of the program in the end.  Let's try to avoid this;  <a href="https://en.cppreference.com/w/cpp/thread">mutexes are our everything</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandler*&gt;::const_iterator; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( <span class="hljs-literal"><span class="hljs-literal">false</span></span> ), m_handlerListMutex() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> </span></span>{ m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m_currentIt = m_handlers.begin(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_isCurrentItRemoved ) { m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( eventHandler ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::unique_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> it = findEventHandler( eventHandler ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it != m_handlers.end() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( it == m_currentIt ) m_isCurrentItRemoved = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> deleteHandler( it ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( TEventHandler&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandler* oneHandler ) { return ( *oneHandler == eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { TEventHandler* removedEventHandler = *it; m_handlers.erase( it ); delete removedEventHandler; } std::list&lt;TEventHandler*&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; };</span></span></code> </pre><br>  Do not forget to leave the ‚Äúwindow‚Äù nezalochennoti when calling each handler.  This is necessary so that inside the handler you can access the event and modify it (for example, add / remove handlers) without causing a <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B7%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B0">deadlock</a> .  For the validity of the data can not be afraid, because, as we found out, the only thing that leads to this is the removal of the current element, and this situation is handled. <br>  <b>UPD1.</b>  Thanks <a href="https://habr.com/users/cheater/" class="user_link">Cheater</a> , <a href="https://habr.com/post/424593/">suggested</a> that <i>std :: shared_mutex</i> appears only in <i>C ++ 17</i> (and <i>std :: shared_lock</i> only in <i>C ++ 14</i> ).  Those for whom it is critical, apparently, will have to do with <i>std :: mutex</i> . <br>  <b>UPD2.</b>  <a href="https://habr.com/ru/post/424593/">Further, about thread safety</a> (without preserving the sequence of narration). <br><br><a name="EventVisibility"></a><h1>  Event visibility problem </h1><br>  When using an event as a member of a class, it seems logical to make it appear <i>public</i> so that third-party objects can add / remove their handlers.  However, this will result in <i>operator ()</i> , i.e.  the event call will also be accessible from the outside, which in some cases may be unacceptable.  Let's solve this problem by extracting from the event class ( <i>TEvent &lt;...&gt;</i> ) an abstract interface intended only for operating handlers. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-=( TEventHandler&amp; eventHandler ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( eventHandler ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent() : IEvent&lt;TParams...&gt;() . . . { } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,     'TEvent::operator+=' } virtual bool removeHandler( TEventHandler&amp; eventHandler ) override { // ,     'TEvent::operator-=' } . . . };</span></span></code> </pre><br>  Now we can smash into different areas of visibility the part of the event responsible for working with handlers, and the part responsible for calling it. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestWindow() : onButtonClick( m_onButtonClick ), m_onButtonClick() { } IEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; onButtonClick; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; m_onButtonClick; . . . };</code> </pre><br>  Thus, now third-party objects can add / remove their handlers via <i>TestWindow :: onButtonClick</i> , however, they will not be able to trigger this event themselves.  The call can now be made only inside the class <i>TestWindow</i> (and its descendants, if the scope of the event, as an example, is <i>protected</i> ). <br><br>  The trivial code gradually begins to turn into something monstrous, but this is not the end. <br><br><a name="EventHandlerParams"></a><h1>  Matching the parameters of the event and its handlers </h1><br>  In the current implementation, the event and any handler must have a strictly corresponding list of parameters.  This leads to several disadvantages. <br><br>  <b>The first.</b>  Suppose we have a class template in which there is an event with a template parameter. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TSource&amp;&gt; onValueChanged; . . . };</code> </pre><br>  Due to the fact that the type that will be used here is unknown in advance, it makes sense to transfer it by a constant reference, and not by value.  However, now for any implementation, even with fundamental types, there must be appropriate handlers. <br><br><pre> <code class="cpp hljs">MyClass&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; myBoolClass; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSource</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHandlerClass</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; newValue )</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleValueChanged2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue )</span></span></span></span>; . . . }; . . . MyHandlerClass myHandlerClass; myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged1 ); <span class="hljs-comment"><span class="hljs-comment">// OK myBoolClass.onValueChanged += METHOD_HANDLER( myHandlerClass, MyHandlerClass::handleValueChanged2 ); // compile error</span></span></code> </pre><br>  I would like to be able to connect with a similar event and handlers of the form <i>MyHandlerClass :: handleValueChanged2</i> , but so far there is no such possibility. <br><br>  <b>The second.</b>  Let us try to implement a handler-functor in the same way as an existing handler-method (-functions-members of a class). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( TFunctor&amp; functor ) : AbstractEventHandler&lt;TParams...&gt;(), m_functor( functor ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override final </span></span>{ m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TParams...&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor )</span></span></code> </pre><br>  Now let's try to screw it to some event. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClickEventHandler</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ . . . } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; ClickEventHandler clickEventHandler; testWindow.onButtonClick += FUNCTOR_HANDLER( clickEventHandler ); . . . }</code> </pre><br>  The result will be a compilation error.  For the <i>createFunctorEventHandler</i> function <i>, the</i> compiler cannot infer the types of <i>TParams ...</i> from the only argument of this function - the functor itself.  The functor really does not contain any information about what type of handler to create on its basis.  The only thing that can be done in this situation is to write something like: <br><br><pre> <code class="cpp hljs">testWindow.onButtonClick += createFunctorEventHandler&lt;ClickEventHandler, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;( clickEventHandler );</code> </pre><br>  But you don‚Äôt want to do this at all. <br><br><a name="HandlerHolder"></a><h1>  Connection of event with handlers of different types </h1><br>  So, there is a Wishlist, it's up to the implementation.  We will consider the situation on the example of a handler-functor; a handler-method (-function-member of a class) will turn out in the same way. <br><br>  Since, based on the functor alone, it is impossible to say what the list of parameters of the corresponding handler will be, then we will not do that.  This issue becomes relevant not at the time of the creation of the handler, but at the time of the attempt to join it to a specific event.  And yes, these are two different points.  You can implement this idea as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorEventHandler( FunctorHolder&lt;TFunctor&gt;&amp; functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ m_functorHolder.m_functor( params... ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ) { } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;&amp;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">friend</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class">;</span></span> };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class">&lt;TFunctor&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createFunctorEventHandler</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">functor</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctorHolder&lt;TFunctor&gt;( functor ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTOR_HANDLER( Functor ) createFunctorEventHandler( Functor ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandler = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> addHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">-=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> removeHandler( <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TEventHandler&amp;&gt;( some ) ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: IEvent() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandler&amp; eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  In short, the separation of the moments of creating a handler and attaching it to an event here is more pronounced than before.  This allows you to bypass the problems described in the previous paragraph.  The type compatibility check will occur when trying to caste a particular <i>FunctorHolder</i> to a certain <i>FunctorEventHandler</i> , or rather, to create an instance of the class <i>FunctorEventHandler &lt;....&gt;</i> With a very specific type of functor;  and in this class there will be a line of code <i>m_functorHolder.m_functor (params ...);</i>  , which is simply not compiled for a set of types incompatible with a functor (or if it is not a functor at all, that is, an object that does not have a <i>operator ()</i> ). <br><br>  I repeat that the problem of deleting temporary objects will be discussed below.  In addition, it is worth noting that a bunch of macros for each case is made, firstly, in order to demonstrate the capabilities of this type of handler, and secondly, in case of possible modification by a file of any of them. <br><br>  Check the result. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestWindow</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onButtonClick; . . . }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor4</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor5</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor6</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor7</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *argv[] )</span></span></span><span class="hljs-function"> </span></span>{ . . . TestWindow testWindow; Functor functor; Functor2 functor2; Functor3 functor3; Functor4 functor4; Functor5 functor5; Functor6 functor6; Functor7 functor7; testWindow.onButtonClick += FUNCTOR_HANDLER( functor ); <span class="hljs-comment"><span class="hljs-comment">// ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor2 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor3 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor4 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor5 ); // compile error testWindow.onButtonClick += FUNCTOR_HANDLER( functor6 ); // ok testWindow.onButtonClick += FUNCTOR_HANDLER( functor7 ); // compile error . . . }</span></span></code> </pre><br>  A compilation error occurs when trying to convert one of the parameters from <i>const lvalue</i> to <i>lvalue</i> .  Converting from <i>rvalue</i> to <i>unconst lvalue</i> does not cause an error, although it is worth noting that it creates a potential threat to a self-shot in the leg: the handler will be able to change the variable copied to the stack, which will happily be deleted when it leaves this handler. <br><br>  In general, the error message should look something like this: <br><br><pre> <code class="hljs vhdl"><span class="hljs-literal"><span class="hljs-literal">Error</span></span> C2664 <span class="hljs-symbol"><span class="hljs-symbol">'void</span></span> Functor5::operator ()(std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;,<span class="hljs-built_in"><span class="hljs-built_in">unsigned</span></span> int &amp;)': cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-symbol"><span class="hljs-symbol">'const</span></span> std::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>' <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp;'</code> </pre><br>  For greater clarity, when using events and handlers in third-party code, you can add your own error message.  This will require writing a small supporting structure (I admit, I have peeped around this approach): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsFunctorParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedFunctor&gt;()( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;TFunctor, TParams...&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; }; } <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TParams... params )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, <span class="hljs-string"><span class="hljs-string">"Event and functor arguments are not compatible"</span></span> ); m_functorHolder-&gt;m_functor( params... ); } . . . };</code> </pre><br><a name="AboutSfinae"></a>  This work is based on the <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> mechanism.  In short, an attempt is made to compile the first <i>exists</i> function, however, if this fails due to the incompatibility of the arguments (or the lack of <i>operator ()</i> of what is passed as a functor), the compiler does not throw an error, but simply tries to compile the second function;  we do everything so that its compilation is always successful, and then, in fact, which of the functions was compiled, we conclude (writing the result in <i>value</i> ) about the compatibility of the arguments for the given types. <br><br>  Now the error message will look like this: <br><br><pre> <code class="cpp hljs">Error C2338 Event <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> functor arguments are <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> compatible Error C2664 <span class="hljs-string"><span class="hljs-string">'void Functor5::operator ()(std::string &amp;,unsigned int &amp;)'</span></span>: cannot convert argument <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-string"><span class="hljs-string">'const std::string'</span></span> to <span class="hljs-string"><span class="hljs-string">'std::string &amp;'</span></span></code> </pre><br>  In addition to an additional, more informative error message, this approach solves the problem of converting argument (s) from <i>rvalue</i> to <i>unconst lvalue</i> : now it causes an error of incompatible arguments, i.e.  an attempt to add the <i>functor6</i> handler from the example above results in a compile-time error. <br>  <b>UPD.</b>  <a href="https://habr.com/ru/post/424593/">Revision</a> (without preserving the sequence of the story). <br><br><a name="FunctorCompare"></a><h1>  Comparison of functors </h1><br>  Due to changes in the class handler, the implementation of comparing instances of this class will change a little.  Again, I will only give the implementation of a handler-functor, because a handler-method (-function-member of a class) will look similar. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = AbstractEventHandler&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isEquals( other ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MyType&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AbstractEventHandler&lt;TParams...&gt;&amp; other )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType* _other = <span class="hljs-keyword"><span class="hljs-keyword">dynamic_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType*&gt;( &amp;other ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( _other != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctorHolder&lt;TFunctor&gt;&amp; m_functorHolder; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TFunctor</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FunctorHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = FunctorHolder&lt;TFunctor&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_functor == other.m_functor ); } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == other ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TFunctor&amp; m_functor; . . . };</code> </pre><br>  At this similarity in the implementation of the comparison ends and begins part only for handlers-functors. <br><br>  As noted above, we have obtained several types of handler-functors: directly objects-functors, lambda expressions, instances of the class <i>std :: function</i> , separate functions.  Of these, functor objects, lambda expressions, and instances of the <i>std :: function</i> class cannot be compared using <i>operator ==</i> (they need to be compared by address), but individual functions can, because  already stored at.  In order not to rewrite the comparison function separately for each case, we write it in a general form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEqu</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEnabled</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( operand1 == operand2 ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TNonEquatable</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EqualityChecker</span></span></span><span class="hljs-class">&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEquals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TNonEquatable&amp; operand2 )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;operand1 == &amp;operand2 ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TFunctor&gt; class FunctorHolder { . . . using MyType = FunctorHolder&lt;TFunctor&gt;; public: bool operator==( const MyType&amp; other ) const { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } private: TFunctor&amp; m_functor; . . . };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is implied that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is_equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is an auxiliary template that determines whether two instances of a given type can be checked for equality. </font><font style="vertical-align: inherit;">With it, using </font></font><a href="https://en.cppreference.com/w/cpp/types/enable_if"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: enable_if</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we choose one of two partially specialized structures </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EqualityChecker</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which will make the comparison: by value or by address. </font><font style="vertical-align: inherit;">Implemented </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is_equatable</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it can be as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is_equatable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() == </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;U&gt;() )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">false_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ... )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( exists&lt;T&gt;( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) )::value; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This implementation is based on the </font></font><a href="https://en.cppreference.com/w/cpp/language/sfinae"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SFINAE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mechanism </font><font style="vertical-align: inherit;">that was </font></font><a href="https://habr.com/ru/post/424593/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previously</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Only here we check the availability of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operator ==</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for instances of a given class. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In such a simple way, the implementation of the comparison of handlers-functors is ready.</font></font><br><br><a name="GarbageCollection"></a><h1>  Garbage collection </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Be indulgent, I also wanted to insert a loud headline. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are approaching the final, and it‚Äôs time to get rid of the huge amount of objects that are being created that no one controls. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At each event of the event with the handler, two objects are created: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Holder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which stores the executable part of the handler, and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">associating it with an event. Do not forget that in the case of an attempt to re-add the handler, no addition will occur - two objects ‚Äúhung in the air‚Äù (unless, of course, separately check this case each time). Another situation: delete handler; two new objects are also created to search for the same (equal) in the list of event handlers; The handler found from the list is, of course, removed (if any), and this temporary, created for search and consisting of two objects, is again ‚Äúin the air‚Äù. In general, not cool. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turn to </font></font><a href="https://en.cppreference.com/w/cpp/memory"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smart pointers</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is necessary to determine what the semantics of ownership of each of the two handler objects will be: sole ownership ( </font></font><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) or shared ( </font></font><a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Holder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">besides using the event itself when adding / deleting should be stored in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , therefore we use for shared ownership, and for the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the sole </font><font style="vertical-align: inherit;">ownership </font><font style="vertical-align: inherit;">, because after creation, it will be stored only in the list of event handlers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We implement this idea:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventHandler</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventHandler() {} . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;THandlerPtr&lt;Types...&gt;&gt;( some ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TPtr</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerCast</span></span></span><span class="hljs-class">&lt;std::shared_ptr&lt;TPtr&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;Types...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cast</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TPtr&gt; some ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; bool operator+=( TSome&amp;&amp; some ) { return addHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool addHandler( TEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TEventHandlerPtr eventHandler ) = 0; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TEventHandlerPtr&gt;::const_iterator; public: TEvent() { . . . } ~TEvent() { // empty } protected: virtual bool addHandler( TEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TEventHandlerPtr eventHandler ) override { . . . } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TEventHandlerPtr&gt; m_handlers; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodEventHandler</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventHandler&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethodHolderPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;TMethodHolder&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: TMethodHolderPtr m_methodHolder; . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: MethodHolder( TObject&amp; object, TMethod method ) { . . . } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( <span class="hljs-comment"><span class="hljs-comment">/*   ? */</span></span> ) ); } . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodHolder&lt;TObject, TParams...&gt;( object, method ) ); } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> METHOD_HANDLER( Object, Method ) createMethodEventHandler( Object, &amp;Method ) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything in order. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To start the event and its interface for working with handlers. In the latter, converting types directly using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will no longer work, because the type to be transformed lies "inside" </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Now for such a transformation we will use the auxiliary structure </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which by its private specialization will provide access to the object inside </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and already working with it (in its non-specialized implementation), apply the good old </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static_cast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The event itself; There are some important changes here too. First, stop manually deleting instances of handlers in the destructor and during deletion; now it is enough to remove from the list a smart pointer with this handler. In addition, when adding a handler, it is important not to forget </font></font><a href="https://en.cppreference.com/w/cpp/utility/move"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: move</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , since </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not support copying (which is quite logical for such semantics). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's go to the handlers. According to the old tradition, only one of them is given, the second is similar. And here, at first glance, it all comes down to changing the types of stored / created objects from links / pointers to smart pointers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But there is one subtle point. The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">createMethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">will return </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the instance.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . A little later, an attempt will be made to convert it to a handler type ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), where it will have to create a new instance of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , passing it to the constructor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to itself. That was how it was intended that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instance </font><i><font style="vertical-align: inherit;">would</font></i><font style="vertical-align: inherit;"> later retire when the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instance was </font><i><font style="vertical-align: inherit;">deleted</font></i><font style="vertical-align: inherit;"> . But the problem is that </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not have access to the already created </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that stores it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve the problem, you will have to store a </font><font style="vertical-align: inherit;">smart pointer to yourself </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . However, so that he does not affect his removal, we use</font></font><a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: weak_ptr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCallParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class">&lt;TCallParams...&gt;() {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> THandlerPtr&lt;TCallParams...&gt;( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( object, method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } TObject&amp; m_object; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;TObject, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>( TObject::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;TObject, TParams...&gt;::create( object, method ); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For better clarity, I‚Äôll give an approximate order of events when removing a handler from an event (my apologies for the random pun): </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an event deletes an element from the list ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_handlers.erase (it);</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), which causes its destructor to be called;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destructor is </font><i><font style="vertical-align: inherit;">called</font></i><font style="vertical-align: inherit;"> , which causes the managed object's destructor to be </font><font style="vertical-align: inherit;">called </font><font style="vertical-align: inherit;">;</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destructor is </font><i><font style="vertical-align: inherit;">called</font></i><font style="vertical-align: inherit;"> , which removes all object fields, including the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_methodHolder</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> field </font><font style="vertical-align: inherit;">, which is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font></li><li>   <i>std::shared_ptr</i> ;  ,      (..         )      ( <i>MethodHolder</i> );      ,     <i>std::weak_ptr</i>    ; </li><li>   <i>MethodHolder</i> ,      ,   ,  <i>m_me</i> ,  <i>std::weak_ptr</i> ; </li><li>   <i>std::weak_ptr</i> ;     ;  because   <i>std::weak_ptr</i>   ,    ; </li><li>  profit </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to remember that the destructor of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class </font><font style="vertical-align: inherit;">must be virtual; </font><font style="vertical-align: inherit;">otherwise, after point </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in point </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventHandler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destructor will be called </font><font style="vertical-align: inherit;">and no further actions will be performed.</font></font><br><br><a name="Joins"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Connection of event and handler </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In some cases, when adding / removing a single handler from an event occurs quite often (according to some logic), I don‚Äôt want to mess around, taking an instance of the event and an instance of the handler each time to once again implement a subscription / unsubscribe from this event. </font><font style="vertical-align: inherit;">And you want to connect them once, and then, if necessary, work with this connection, adding / removing with it the predefined handler from a predetermined event. </font><font style="vertical-align: inherit;">You can implement this as follows:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Types</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">THandlerPtr</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventHandler&lt;Types...&gt;&gt;;</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = THandlerPtr&lt;TParams...&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class">&lt;TParams...&gt;;</span></span> . . . }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TEvent</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEvent&lt;TParams...&gt; { . . . <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isHandlerAdded</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TEventHandlerPtr&amp; eventHandler )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_lock&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( findEventHandler( eventHandler ) != m_handlers.end() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">removeHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( TEventHandlerPtr eventHandler )</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">//      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TEventHandlerPtr&amp; eventHandler ) const { . . . } std::list&lt;TEventHandlerPtr&gt; m_handlers; mutable std::shared_mutex m_handlerListMutex; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, THandlerPtr&lt;TParams...&gt; handler ) : m_event( _event ), m_handler( handler ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.isHandlerAdded( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.addHandler( m_handler ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_event.removeHandler( m_handler ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: IEvent&lt;TParams...&gt;&amp; m_event; THandlerPtr&lt;TParams...&gt; m_handler; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, now we have added another possible storage location for the handler instance, so we will use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for this </font><font style="vertical-align: inherit;">instead of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: unique_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this class, as for me, is slightly inconvenient to use. It would be desirable to store and create instances of connections without a list of parameters instantiating a class template. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We do this with the help of an abstract ancestor class and a wrapper:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractEventJoin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractEventJoin() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>: AbstractEventJoin() {} };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HandlerEventJoin</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractEventJoin { . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ . . . } . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inline</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class">&lt;TParams...&gt;&amp; _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">handler</span></span></span><span class="hljs-class"> ) :</span></span> m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_eventJoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ } ~EventJoinWrapper() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> m_eventJoin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isJoined(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAssigned</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isJoined</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> &amp;&amp; m_eventJoin-&gt;isJoined() ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">join</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;join() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unjoin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( m_eventJoin != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ? m_eventJoin-&gt;unjoin() : <span class="hljs-literal"><span class="hljs-literal">false</span></span> ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: AbstractEventJoin* m_eventJoin; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> EventJoin = EventJoinWrapper;</code> </pre><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerCast</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the same supporting structure that was used </font></font><a href="https://habr.com/ru/post/424593/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . By the way, it is important not to forget to make the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destructor </font><font style="vertical-align: inherit;">virtual so that when you delete its instance in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destructor, the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HandlerEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> destructor is </font><i><font style="vertical-align: inherit;">called</font></i><font style="vertical-align: inherit;"> , otherwise the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">THandlerPtr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> field </font><font style="vertical-align: inherit;">and, therefore, the handler itself </font><font style="vertical-align: inherit;">will not be destroyed </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This implementation seems to work, but only at first glance. Copying or moving an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EventJoinWrapper</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instance </font><font style="vertical-align: inherit;">will re-delete </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_eventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in its destructor. Therefore, we use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: shared_ptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to store the instance.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AbstractEventJoin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as well as implement slightly optimized motion semantics (and copying), since </font><font style="vertical-align: inherit;">this will be a potentially frequent operation.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoinWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) : m_eventJoin( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ) ) { } EventJoinWrapper( EventJoinWrapper&amp; other ) : m_eventJoin( other.m_eventJoin ) { } ~EventJoinWrapper() { <span class="hljs-comment"><span class="hljs-comment">/*empty*/</span></span> } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( EventJoinWrapper&amp;&amp; other ) { m_eventJoin = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( other.m_eventJoin ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } EventJoinWrapper&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventJoinWrapper&amp; other ) { m_eventJoin = other.m_eventJoin; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;AbstractEventJoin&gt; m_eventJoin; };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now, when connecting the handler to the event, you can immediately return an instance of the new connection: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IEvent</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventJoin</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">operator</span></span></span><span class="hljs-class">+=( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">some</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-function"><span class="hljs-function">EventJoin </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">result</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;TSome&gt;( some ) )</span></span></span></span>; result.join(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } . . . };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And after settling the triangular dependencies by </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">include </font></font></i> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(IEvent &lt;= EventJointWrapper.hpp; EventJointWrapper &lt;= HandlerEventJoin.hpp; HandlerEventJoin &lt;= IEvent.hpp)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can even work with </font><font style="vertical-align: inherit;">splitting some files into </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.h</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.hpp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creation of instances of connections occurs according to the same rules as when a handler is subscribed to an event:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; )</span></span></span><span class="hljs-function"> </span></span>{} }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder _methodsHolder; EventJoin join1 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method1 ) ); <span class="hljs-comment"><span class="hljs-comment">// ok EventJoin join2 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method2 ) ); // ok EventJoin join3 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method3 ) ); // error EventJoin join4 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method4 ) ); // error EventJoin join5 = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( _methodsHolder, MethodsHolder::method5 ) ); // error return 0; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plus, you can ‚Äúturn on‚Äù / ‚Äúturn off‚Äù event handling (for which, in principle, connections were created): </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventHolder</span></span></span><span class="hljs-class"> {</span></span> TEvent&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; onEvent; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodsHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; text, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Text '"</span></span> &lt;&lt; text &lt;&lt; <span class="hljs-string"><span class="hljs-string">"' handled "</span></span> &lt;&lt; count &lt;&lt; <span class="hljs-string"><span class="hljs-string">" times."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* argv[] )</span></span></span><span class="hljs-function"> </span></span>{ EventHolder _eventHolder; MethodsHolder methodsHolder; EventJoin eventJoin = EventJoin( _eventHolder.onEvent, METHOD_HANDLER( methodsHolder, MethodsHolder::handleEvent ) ); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> handlingText = <span class="hljs-string"><span class="hljs-string">"testing..."</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; ++i ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( eventJoin.isJoined() ) eventJoin.unjoin(); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> eventJoin.join(); _eventHolder.onEvent( handlingText, i ); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">0</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">2</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">4</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">6</span></span> times. <span class="hljs-type"><span class="hljs-type">Text</span></span> <span class="hljs-string"><span class="hljs-string">'testing...'</span></span> handled <span class="hljs-number"><span class="hljs-number">8</span></span> times.</code> </pre><br><a name="Totals"></a><h1>  Total </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, it is worth noting that the task to write an article as briefly and concisely as possible is completely failed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that the resulting implementation of event handling is quite efficient and will be at least useful to someone.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A rather cumbersome example demonstrating the main features.</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "events/event.hpp" #include "events/handler/methodeventhandler.hpp" #include "events/handler/functoreventhandler.hpp" #include "events/join/handlereventjoin.hpp" #include "events/join/eventjoinwrapper.hpp" class Foo { public: Foo() : onMake( m_onMake ), m_onMake(), m_onMakeInner(), m_makeCount( 0 ) { m_onMakeInner += FUNCTOR_HANDLER( m_onMake ); } IEvent&lt;unsigned int&gt;&amp; onMake; void make() { m_onMakeInner( m_makeCount++ ); } private: TEvent&lt;unsigned int&gt; m_onMake, m_onMakeInner; unsigned int m_makeCount; }; namespace instances { Foo&amp; getFoo() { static Foo _foo; return _foo; } } // instances struct FunctorHandler { void operator()( unsigned int makeCount ); }; void functionHandler( unsigned int makeCount ); class ClassHandler { public: void handle( unsigned int makeCount ); }; namespace instances { FunctorHandler&amp; getFunctorHandler() { static FunctorHandler _functorHandler; return _functorHandler; } std::function&lt;void( unsigned int )&gt;&amp; getStdFunctionHandler() { static std::function&lt;void( unsigned int )&gt; _stdFunctionHandler = []( unsigned int makeCount ) { std::cout &lt;&lt; "It's std::function handler" &lt;&lt; std::endl; if( makeCount &gt;= 2 ) instances::getFoo().onMake -= STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); }; return _stdFunctionHandler; } ClassHandler&amp; getClassHandler() { static ClassHandler _classHandler; return _classHandler; } } // instances void FunctorHandler::operator()( unsigned int makeCount ) { std::cout &lt;&lt; "It's functor handler" &lt;&lt; std::endl; if( makeCount &gt;= 0 ) instances::getFoo().onMake -= FUNCTOR_HANDLER( instances::getFunctorHandler() ); } void functionHandler( unsigned int makeCount ) { std::cout &lt;&lt; "It's function handler" &lt;&lt; std::endl; if( makeCount &gt;= 3 ) instances::getFoo().onMake -= FUNCTION_HANDLER( functionHandler ); } void ClassHandler::handle( unsigned int makeCount ) { std::cout &lt;&lt; "It's method handler" &lt;&lt; std::endl; if( makeCount &gt;= 4 ) instances::getFoo().onMake -= MY_METHOD_HANDLER( ClassHandler::handle ); } int main( int argc, char* argv[] ) { Foo&amp; foo = instances::getFoo(); auto lambdaHandler = []( unsigned int ) { std::cout &lt;&lt; "It's lambda handler" &lt;&lt; std::endl; }; foo.onMake += FUNCTOR_HANDLER( instances::getFunctorHandler() ); foo.onMake += LAMBDA_HANDLER( lambdaHandler ); EventJoin lambdaJoin = foo.onMake += LAMBDA_HANDLER( ( [ &amp;foo, &amp;lambdaHandler ]( unsigned int makeCount ) { if( makeCount &gt;= 1 ) foo.onMake -= LAMBDA_HANDLER( lambdaHandler ); } ) ); foo.onMake += STD_FUNCTION_HANDLER( instances::getStdFunctionHandler() ); foo.onMake += FUNCTION_HANDLER( functionHandler ); foo.onMake += METHOD_HANDLER( instances::getClassHandler(), ClassHandler::handle ); for( int i = 0; i &lt; 6; ++i ) { std::cout &lt;&lt; "Make " &lt;&lt; i &lt;&lt; " time:" &lt;&lt; std::endl; foo.make(); std::cout &lt;&lt; std::endl; } lambdaJoin.unjoin(); return 0; }</span></span></span></span></code> </pre><br>  Conclusion: <br><br><pre> <code class="hljs vhdl">Make <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>: It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> functor handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> lambda handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> std::<span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> method handler Make <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>: It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> lambda handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> std::<span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> method handler Make <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>: It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> std::<span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> method handler Make <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>: It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> handler It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> method handler Make <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>: It<span class="hljs-symbol"><span class="hljs-symbol">'s</span></span> method handler Make <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>:</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is worth noting a number of important points: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it was not specified separately, therefore, I will mention that the event itself in this implementation is a functor, and therefore, can act as a handler for another event; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">now you cannot use constant methods (class member functions) as handlers; </font><font style="vertical-align: inherit;">I think that if such an opportunity is needed, it is not difficult to write for this a new type of handler based on the existing ones.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In addition, in the final version there are some points omitted in the article for greater clarity and readability of the code: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the return type of the method (the class member function) for the corresponding handler can be any, not necessarily </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (for handlers-functors this was done and so);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the whole implementation is wrapped in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">namespaces</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for ease of use in projects (if this seems odd to someone, they can always be removed);</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here and there the </font></font><a href="https://en.cppreference.com/w/cpp/language/noexcept_spec"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noexcept</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> specifier is </font><a href="https://en.cppreference.com/w/cpp/language/noexcept_spec"><font style="vertical-align: inherit;">added</font></a><font style="vertical-align: inherit;"> .</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To all those who read to here at least diagonally, a low bow. </font><font style="vertical-align: inherit;">I enclose all the code; </font><font style="vertical-align: inherit;">You can also take it </font></font><a href="https://github.com/ZolotovPavel/EventHandling"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (with all the latest modifications).</font></font><br><br><div class="spoiler">  <b class="spoiler_title">All code</b> <div class="spoiler_text"><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/helpers/is_equatable.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; template&lt;class T&gt; class is_equatable { private: template&lt;class U&gt; static constexpr std::true_type exists( decltype( std::declval&lt;U&gt;() == std::declval&lt;U&gt;() )* = nullptr ) noexcept; template&lt;class U&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;T&gt;( nullptr ) )::value; };</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/abstracteventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { namespace handlers { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class AbstractEventHandler { using MyType = AbstractEventHandler&lt;TParams...&gt;; public: virtual ~AbstractEventHandler() {} virtual void call( TParams... params ) = 0; bool operator==( const MyType&amp; other ) const noexcept { return isEquals( other ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } protected: AbstractEventHandler() {} virtual bool isEquals( const MyType&amp; other ) const noexcept = 0; }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/eventhandlerptr.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace events { namespace handlers { template&lt;class ...TParams&gt; class AbstractEventHandler; template&lt;class ...Types&gt; using TEventHandlerPtr = std::shared_ptr&lt;AbstractEventHandler&lt;Types...&gt;&gt;; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/functoreventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" #include "../helpers/is_equatable.hpp" namespace events { namespace handlers { namespace { template&lt;class TFunctor, class ...TParams&gt; struct IsFunctorParamsCompatible { private: template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( std::declval&lt;TCheckedFunctor&gt;()( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedFunctor, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TFunctor, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TFunctor&gt; class FunctorHolder; template&lt;class TFunctor, class ...TParams&gt; class FunctorEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = FunctorEventHandler&lt;TFunctor, TParams...&gt;; using TFunctorHolderPtr = std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt;; public: FunctorEventHandler( TFunctorHolderPtr functorHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_functorHolder( functorHolder ) { assert( m_functorHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsFunctorParamsCompatible&lt;TFunctor, TParams...&gt;::value, "Event and functor arguments are not compatible" ); m_functorHolder-&gt;m_functor( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_functorHolder == *_other-&gt;m_functorHolder ); } private: TFunctorHolderPtr m_functorHolder; }; namespace { template&lt;class TEqu, class TEnabled = void&gt; struct EqualityChecker; template&lt;class TEquatable&gt; struct EqualityChecker&lt;TEquatable, typename std::enable_if&lt;is_equatable&lt;TEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TEquatable&amp; operand1, const TEquatable&amp; operand2 ) noexcept { return ( operand1 == operand2 ); } }; template&lt;class TNonEquatable&gt; struct EqualityChecker&lt;TNonEquatable, typename std::enable_if&lt;!is_equatable&lt;TNonEquatable&gt;::value&gt;::type&gt; { static constexpr bool isEquals( const TNonEquatable&amp; operand1, const TNonEquatable&amp; operand2 ) noexcept { return ( &amp;operand1 == &amp;operand2 ); } }; } // template&lt;class TFunctor&gt; class FunctorHolder { using MyType = FunctorHolder&lt;TFunctor&gt;; public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new FunctorEventHandler&lt;TFunctor, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return EqualityChecker&lt;TFunctor&gt;::isEquals( m_functor, other.m_functor ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TFunctor&gt; static std::shared_ptr&lt;MyType&gt; create( TFunctor&amp;&amp; functor ) { std::shared_ptr&lt;MyType&gt; result( new MyType( functor ) ); result-&gt;m_me = result; return result; } private: FunctorHolder( TFunctor&amp; functor ) : m_functor( functor ), m_me() { } TFunctor&amp; m_functor; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TFunctor, class ...TParams&gt; friend class FunctorEventHandler; }; template&lt;class TFunctor&gt; std::shared_ptr&lt;FunctorHolder&lt;TFunctor&gt;&gt; createFunctorEventHandler( TFunctor&amp;&amp; functor ) { return FunctorHolder&lt;TFunctor&gt;::create( functor ); } } // handlers } // events #define FUNCTOR_HANDLER( Functor ) ::events::handlers::createFunctorEventHandler( Functor ) #define LAMBDA_HANDLER( Lambda ) FUNCTOR_HANDLER( Lambda ) #define STD_FUNCTION_HANDLER( StdFunction ) FUNCTOR_HANDLER( StdFunction ) #define FUNCTION_HANDLER( Function ) FUNCTOR_HANDLER( &amp;Function )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/methodeventhandler.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;assert.h&gt; #include "abstracteventhandler.hpp" namespace events { namespace handlers { namespace { template&lt;class TMethodHolder, class ...TParams&gt; struct IsMethodParamsCompatible { private: template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::true_type exists( decltype( ( std::declval&lt;TCheckedMethodHolder&gt;().m_object.*std::declval&lt;TCheckedMethodHolder&gt;().m_method )( std::declval&lt;TCheckedParams&gt;()... ) )* = nullptr ) noexcept; template&lt;class TCheckedMethodHolder, class ...TCheckedParams&gt; static constexpr std::false_type exists( ... ) noexcept; public: static constexpr bool value = decltype( exists&lt;TMethodHolder, TParams...&gt;( nullptr ) )::value; }; } // template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { using MyType = MethodEventHandler&lt;TMethodHolder, TParams...&gt;; using TMethodHolderPtr = std::shared_ptr&lt;TMethodHolder&gt;; public: MethodEventHandler( TMethodHolderPtr methodHolder ) : AbstractEventHandler&lt;TParams...&gt;(), m_methodHolder( methodHolder ) { assert( m_methodHolder != nullptr ); } virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_object.*m_methodHolder-&gt;m_method )( params... ); } protected: virtual bool isEquals( const AbstractEventHandler&lt;TParams...&gt;&amp; other ) const noexcept override { const MyType* _other = dynamic_cast&lt;const MyType*&gt;( &amp;other ); return ( _other != nullptr &amp;&amp; *m_methodHolder == *_other-&gt;m_methodHolder ); } private: TMethodHolderPtr m_methodHolder; }; template&lt;class TObject, class TResult, class ...TParams&gt; class MethodHolder { using MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; using TMethod = TResult( TObject::* )( TParams... ); public: template&lt;class ...TCallParams&gt; operator TEventHandlerPtr&lt;TCallParams...&gt;() { return TEventHandlerPtr&lt;TCallParams...&gt;( new MethodEventHandler&lt;MyType, TCallParams...&gt;( m_me.lock() ) ); } bool operator==( const MyType&amp; other ) const noexcept { return ( &amp;m_object == &amp;other.m_object &amp;&amp; m_method == other.m_method ); } bool operator!=( const MyType&amp; other ) const noexcept { return !( *this == other ); } template&lt;class TObject, class ...TParams&gt; static std::shared_ptr&lt;MyType&gt; create( TObject&amp; object, TMethod method ) { std::shared_ptr&lt;MyType&gt; result( new MyType( object, method ) ); result-&gt;m_me = result; return result; } private: MethodHolder( TObject&amp; object, TMethod method ) : m_object( object ), m_method( method ) { assert( m_method != nullptr ); } TObject&amp; m_object; TMethod m_method; std::weak_ptr&lt;MyType&gt; m_me; template&lt;class TMethodHolder, class ...TParams&gt; friend class MethodEventHandler; template&lt;class TMethodHolder, class ...TParams&gt; friend struct IsMethodParamsCompatible; }; template&lt;class TObject, class TResult, class ...TParams&gt; std::shared_ptr&lt;MethodHolder&lt;TObject, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp; object, TResult( TObject::*method )( TParams... ) ) { return MethodHolder&lt;TObject, TResult, TParams...&gt;::create( object, method ); } } // handlers } // events #define METHOD_HANDLER( Object, Method ) ::events::handlers::createMethodEventHandler( Object, &amp;Method ) #define MY_METHOD_HANDLER( Method ) METHOD_HANDLER( *this, Method )</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/handlers/handlercast.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "eventhandlerptr.h" namespace events { namespace handlers { template&lt;class TSome&gt; struct HandlerCast { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( TSome&amp; some ) { return static_cast&lt;TEventHandlerPtr&lt;Types...&gt;&gt;( some ); } }; template&lt;class TPtr&gt; struct HandlerCast&lt;std::shared_ptr&lt;TPtr&gt;&gt; { template&lt;class ...Types&gt; static constexpr TEventHandlerPtr&lt;Types...&gt; cast( std::shared_ptr&lt;TPtr&gt; some ) { return HandlerCast&lt;TPtr&gt;::cast&lt;Types...&gt;( *some ); } }; } // handlers } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/event.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include &lt;list&gt; #include &lt;memory&gt; #include &lt;shared_mutex&gt; #include &lt;algorithm&gt; #include &lt;assert.h&gt; #include "handlers/abstracteventhandler.hpp" #include "handlers/eventhandlerptr.h" #include "handlers/handlercast.hpp" #include "joins/eventjoinwrapper.hpp" namespace events { namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin; } template&lt;class ...TParams&gt; class IEvent { public: template&lt;class TSome&gt; EventJoin operator+=( TSome&amp;&amp; some ) { EventJoin result( *this, std::forward&lt;TSome&gt;( some ) ); result.join(); return result; } template&lt;class TSome&gt; bool operator-=( TSome&amp;&amp; some ) { return removeHandler( handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( some ) ); } protected: using TMyEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; IEvent() {} virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const = 0; virtual bool addHandler( TMyEventHandlerPtr eventHandler ) = 0; virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) = 0; friend class joins::HandlerEventJoin&lt;TParams...&gt;; }; template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TEventHandlerIt = typename std::list&lt;TMyEventHandlerPtr&gt;::const_iterator; public: TEvent() : m_handlers(), m_currentIt(), m_isCurrentItRemoved( false ), m_handlerListMutex() { } void operator()( TParams... params ) { m_handlerListMutex.lock_shared(); m_isCurrentItRemoved = false; m_currentIt = m_handlers.begin(); while( m_currentIt != m_handlers.end() ) { m_handlerListMutex.unlock_shared(); ( *m_currentIt )-&gt;call( params... ); m_handlerListMutex.lock_shared(); if( m_isCurrentItRemoved ) { m_isCurrentItRemoved = false; TEventHandlerIt removedIt = m_currentIt; ++m_currentIt; deleteHandler( removedIt ); } else { ++m_currentIt; } } m_handlerListMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); return ( findEventHandler( eventHandler ) != m_handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); if( findEventHandler( eventHandler ) == m_handlers.end() ) { m_handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _handlerListMutexLock( m_handlerListMutex ); auto it = findEventHandler( eventHandler ); if( it != m_handlers.end() ) { if( it == m_currentIt ) m_isCurrentItRemoved = true; else deleteHandler( it ); return true; } return false; } private: //      'm_handlerListMutex' inline TEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const noexcept { return std::find_if( m_handlers.cbegin(), m_handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } //      'm_handlerListMutex' inline void deleteHandler( TEventHandlerIt it ) { m_handlers.erase( it ); } std::list&lt;TMyEventHandlerPtr&gt; m_handlers; //    'm_handlerListMutex' mutable TEventHandlerIt m_currentIt; mutable bool m_isCurrentItRemoved; mutable std::shared_mutex m_handlerListMutex; }; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/joins/abstracteventjoin.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once namespace events { namespace joins { class AbstractEventJoin { public: virtual ~AbstractEventJoin(); virtual bool isJoined() const = 0; virtual bool join() = 0; virtual bool unjoin() = 0; protected: AbstractEventJoin(); }; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/joins/abstracteventjoin.cpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { AbstractEventJoin::AbstractEventJoin() { } AbstractEventJoin::~AbstractEventJoin() { } } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/joins/handlereventjoin.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"abstracteventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/eventhandlerptr.h"</span></span></span><span class="hljs-meta"> namespace events { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; class IEvent; namespace joins { template&lt;class ...TParams&gt; class HandlerEventJoin : public AbstractEventJoin { public: HandlerEventJoin( IEvent&lt;TParams...&gt;&amp; _event, ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; handler ) : AbstractEventJoin(), m_event( _event ), m_handler( handler ) { } virtual inline bool isJoined() const override; virtual inline bool join() override; virtual inline bool unjoin() override; private: IEvent&lt;TParams...&gt;&amp; m_event; ::events::handlers::TEventHandlerPtr&lt;TParams...&gt; m_handler; }; } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/joins/handlereventjoin.hpp</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::isJoined() const { return m_event.isHandlerAdded( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::join() { return m_event.addHandler( m_handler ); } template&lt;class ...TParams&gt; bool HandlerEventJoin&lt;TParams...&gt;::unjoin() { return m_event.removeHandler( m_handler ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">./events/joins/eventjoinwrapper.h</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include "../handlers/eventhandlerptr.h" namespace events { template&lt;class ...TParams&gt; class IEvent; namespace joins { class AbstractEventJoin; class EventJoinWrapper { public: template&lt;class TSome, class ...TParams&gt; inline EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ); constexpr EventJoinWrapper() noexcept; EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept; EventJoinWrapper&amp; operator=( EventJoinWrapper&amp;&amp; other ) noexcept; EventJoinWrapper&amp; operator=( const EventJoinWrapper&amp; other ) noexcept; operator bool() const; bool isAssigned() const; bool isJoined() const; bool join(); bool unjoin(); private: std::shared_ptr&lt;AbstractEventJoin&gt; m_eventJoin; }; } // joins using EventJoin = joins::EventJoinWrapper; } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"handlereventjoin.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../handlers/handlercast.hpp"</span></span></span><span class="hljs-meta"> namespace events { namespace joins { template</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;class TSome, class ...TParams&gt; EventJoinWrapper::EventJoinWrapper( IEvent&lt;TParams...&gt;&amp; _event, TSome&amp;&amp; handler ) : m_eventJoin( std::make_shared&lt;HandlerEventJoin&lt;TParams...&gt;&gt;( _event, ::events::handlers::HandlerCast&lt;TSome&gt;::cast&lt;TParams...&gt;( handler ) ) ) { } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">./events/joins/eventjoinwrapper.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"eventjoinwrapper.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;type_traits&gt; #include "abstracteventjoin.h" namespace events { namespace joins { constexpr EventJoinWrapper::EventJoinWrapper() noexcept : m_eventJoin( nullptr ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp;&amp; other ) noexcept : m_eventJoin( std::move( other.m_eventJoin ) ) { } EventJoinWrapper::EventJoinWrapper( EventJoinWrapper&amp; other ) noexcept : m_eventJoin( other.m_eventJoin ) { } EventJoinWrapper&amp; EventJoinWrapper::operator=( EventJoinWrapper&amp;&amp; other ) noexcept { m_eventJoin = std::move( other.m_eventJoin ); return *this; } EventJoinWrapper&amp; EventJoinWrapper::operator=( const EventJoinWrapper&amp; other ) noexcept { m_eventJoin = other.m_eventJoin; return *this; } EventJoinWrapper::operator bool() const { return isJoined(); } bool EventJoinWrapper::isAssigned() const { return ( m_eventJoin != nullptr ); } bool EventJoinWrapper::isJoined() const { return ( m_eventJoin != nullptr &amp;&amp; m_eventJoin-&gt;isJoined() ); } bool EventJoinWrapper::join() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;join() : false ); } bool EventJoinWrapper::unjoin() { return ( m_eventJoin != nullptr ? m_eventJoin-&gt;unjoin() : false ); } } // joins } // events</span></span></span></span></code> </pre><br></div></div><br></div></div><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD1. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here and earlier on the article is the code written under </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VC ++ 14</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">For compatibility with other compilers, it is better to take the code by reference. </font><font style="vertical-align: inherit;">Special thanks to </font></font><a href="https://habr.com/users/cheater/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cheater</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for ensuring compatibility with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCC</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><a name="ThreadRev"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD2. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you </font></font><a href="https://habr.com/users/lexxmark/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lexxmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for </font></font><a href="https://habr.com/post/424593/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noticing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a thread-safety hole in terms of several simultaneous event calls.</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minor improvements</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeHelper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerPtr = handlers::TEventHandlerPtr&lt;TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TEventHandlerIt = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;TEventHandlerPtr&gt;::const_iterator; }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class ...TParams&gt; class IEvent { . . . protected: using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; . . . }; namespace { template&lt;class ...TParams&gt; struct EventCore { using TMyHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; std::list&lt;TMyHandlerPtr&gt; handlers; mutable std::shared_mutex coreMutex; }; template&lt;class ...TParams&gt; class HandlerRunner { using TMyEventCore = EventCore&lt;TParams...&gt;; using TMyHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; public: HandlerRunner( TMyEventCore&amp; eventCore ) : m_eventCore( eventCore ), currentIt(), wasRemoving( false ) { } void run( TParams... params ) { m_eventCore.coreMutex.lock_shared(); currentIt = m_eventCore.handlers.begin(); wasRemoving = false; while( currentIt != m_eventCore.handlers.end() ) { m_eventCore.coreMutex.unlock_shared(); ( *currentIt )-&gt;call( params... ); m_eventCore.coreMutex.lock_shared(); if( wasRemoving ) wasRemoving = false; else ++currentIt; } m_eventCore.coreMutex.unlock_shared(); } TMyHandlerIt currentIt; mutable bool wasRemoving; private: TMyEventCore&amp; m_eventCore; }; } // template&lt;class ...TParams&gt; class TEvent : public IEvent&lt;TParams...&gt; { using TMyEventHandlerPtr = typename TypeHelper&lt;TParams...&gt;::TEventHandlerPtr; using TMyEventHandlerIt = typename TypeHelper&lt;TParams...&gt;::TEventHandlerIt; using TMyHandlerRunner = HandlerRunner&lt;TParams...&gt;; public: TEvent() : m_core() { } void operator()( TParams... params ) { TMyHandlerRunner newHandlerRunner( m_core ); m_core.coreMutex.lock_shared(); auto it = m_handlerRunners.insert( m_handlerRunners.end(), &amp;newHandlerRunner ); m_core.coreMutex.unlock_shared(); newHandlerRunner.run( params... ); m_core.coreMutex.lock_shared(); m_handlerRunners.erase( it ); m_core.coreMutex.unlock_shared(); } protected: virtual bool isHandlerAdded( const TMyEventHandlerPtr&amp; eventHandler ) const override { std::shared_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); return ( findEventHandler( eventHandler ) != m_core.handlers.end() ); } virtual bool addHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); if( findEventHandler( eventHandler ) == m_core.handlers.end() ) { m_core.handlers.push_back( std::move( eventHandler ) ); return true; } return false; } virtual bool removeHandler( TMyEventHandlerPtr eventHandler ) override { std::unique_lock&lt;std::shared_mutex&gt; _coreMutexLock( m_core.coreMutex ); auto it = findEventHandler( eventHandler ); if( it != m_core.handlers.end() ) { for( TMyHandlerRunner* oneHandlerRunner : m_handlerRunners ) { if( it == oneHandlerRunner-&gt;currentIt ) { ++oneHandlerRunner-&gt;currentIt; oneHandlerRunner-&gt;wasRemoving = true; } } m_core.handlers.erase( it ); return true; } return false; } private: //      'm_core.coreMutex' inline TMyEventHandlerIt findEventHandler( const TMyEventHandlerPtr&amp; eventHandler ) const { return std::find_if( m_core.handlers.cbegin(), m_core.handlers.cend(), [ &amp;eventHandler ]( const TMyEventHandlerPtr&amp; oneHandler ) { return ( *oneHandler == *eventHandler ); } ); } EventCore&lt;TParams...&gt; m_core; std::list&lt;TMyHandlerRunner*&gt; m_handlerRunners; };</span></span></code> </pre><br>        (,  ,     )    <i>HandlerRunner</i> ,       . ,     : <i>currentIt</i> (    )  <i>wasRemoving</i> (,        ).   <i>HandlerRunner'</i>          <i>operator()</i> ;        (,  )  ,    <i>EventCore</i> .  So      ,   ,        ,     ,         ,       . <br></div></div><a name="HolderImprovement"></a> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD3. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks </font></font><a href="https://habr.com/users/isnullxbh/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isnullxbh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> found another error. </font><font style="vertical-align: inherit;">It is associated with incorrect saving and subsequent reference to objects passed by </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rvalue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mainly lambda expressions).</font></font><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correction</font></font></b> <div class="spoiler_text">     ,   <i>lvalue</i> ,  <i>lvalue</i> -,  ,   <i>rvalue</i> ,   (,  ).      : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TSome</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;LValue&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = LValue&amp;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RValue</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ObjectSaver</span></span></span><span class="hljs-class">&lt;RValue&amp;&amp;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TObject = RValue; };</code> </pre><br>  <i>Holder</i>           ( <i>lvalue</i>  <i>rvalue</i> ),        ,  ¬´¬ª     .     <i>type erasing</i> (   <a href="https://habr.com/post/207294/%2522"> </a> ).   ,   <i>Holder'</i>   . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~AbstractInnerHolder() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const_cast</span></span>&lt;AbstractInnerHolder&lt;TBase&gt;&amp;&gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> ).get(); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TInnerHolder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> AbstractInnerHolder&lt;TBase&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TInnerObject = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ObjectSaver&lt;TInner&gt;::TObject; TInnerHolder( TInner _inner ) : AbstractInnerHolder&lt;TBase&gt;(), inner( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TInner&gt;( _inner ) ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> TBase&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;TBase&amp;&gt;( inner ); } TInnerObject inner; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TAssignBase</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractInnerHolder</span></span></span><span class="hljs-class">&lt;TAssignBase&gt;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">createInnerHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgInner</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inner</span></span></span><span class="hljs-class"> ) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TAssignInner = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>( inner ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TInnerHolder&lt;TAssignBase, TAssignInner&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgInner&gt;( inner ) ); }</code> </pre><br>      <i>Holder'</i> .    <i>MethodHolder'</i> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyType = MethodHolder&lt;TObject, TResult, TParams...&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> TMethod = TResult( TObject::* )( TParams... ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ~MethodHolder() { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> &amp;m_innerHolder; } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>==( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MyType&amp; other ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &amp;m_innerHolder.get() == &amp;other.m_innerHolder.get() &amp;&amp; m_method == other.m_method ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; create( TArgObject&amp;&amp; object, TMethod method ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MyType&gt; result( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyType( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ), method ) ); result-&gt;m_me = result; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MethodHolder</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TArgObject</span></span></span><span class="hljs-class">&amp;&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethod</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">method</span></span></span><span class="hljs-class"> ) :</span></span> m_innerHolder( createInnerHolder&lt;TObject&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TArgObject&gt;( object ) ) ), m_method( method ) { assert( m_method != <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); } AbstractInnerHolder&lt;TObject&gt;&amp; m_innerHolder; TMethod m_method; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::weak_ptr&lt;MyType&gt; m_me; . . . };</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsMethodParamsCompatible</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedMethodHolder</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TCheckedParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">constexpr</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-function"><span class="hljs-function">true_type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( ( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_innerHolder.get().*</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedMethodHolder&gt;().m_method )( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;TCheckedParams&gt;()... ) )* = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; . . . }; } <span class="hljs-comment"><span class="hljs-comment">// template&lt;class TMethodHolder, class ...TParams&gt; class MethodEventHandler : public AbstractEventHandler&lt;TParams...&gt; { public: virtual void call( TParams... params ) override { static_assert( IsMethodParamsCompatible&lt;TMethodHolder, TParams...&gt;::value, "Event and method arguments are not compatible" ); ( m_methodHolder-&gt;m_innerHolder.get().*m_methodHolder-&gt;m_method )( params... ); } private: TMethodHolderPtr m_methodHolder; . . . };</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObject</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TResult</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> ...</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TParams</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;MethodHolder&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;&gt; createMethodEventHandler( TObject&amp;&amp; object, TResult( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type::*method )( TParams... ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MethodHolder&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::decay&lt;TObject&gt;::type, TResult, TParams...&gt;::create( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TObject&gt;( object ), method ); }</code> </pre><br>  Is done. <i>FunctorHolder</i>   .        .    -    . <br></div></div><br><a name="Qt"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PS Comparison with Qt Signal / Slots Mechanism </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I think I‚Äôm not mistaken if I say that </font></font><a href="https://www.qt.io/what-is-qt/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a very common framework for developing in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Among other things, it also has </font></font><a href="http://wiki.qt.io/New_Signal_Slot_Syntax"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">its own event-handling mechanism</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , in which there are signals as event analogs and slots as handler analogs. </font><font style="vertical-align: inherit;">It is implemented using the </font></font><a href="http://doc.qt.io/qt-5/moc.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-Object Compiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is part of a more global </font></font><a href="http://doc.qt.io/qt-5/metaobjects.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meta-Object System</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which, in turn, is implemented using the </font><font style="vertical-align: inherit;">add-in over </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q </font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">++</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> used in </font><i><font style="vertical-align: inherit;">Qt</font></i><font style="vertical-align: inherit;"> .</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Features of both implementations: </font></font></h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the ability to connect signals (events) to methods (member functions), functors and functions; </font></font></li><li>     ()  (),        ( <i>lvalue</i> , <i>rvalue</i> ); </li><li>      (  ); </li><li>    ()      (   ). </li></ul><br><h4>  <i>Qt</i> : </h4><br><ul><li> <i>   ;</i> <br>  <i>Qt</i>          ;     ¬´¬ª,  ,     ¬´ ¬ª  ;   ,        ; ,       ; <br></li><li> <i>    ;</i> <br>   <i>Qt</i>          (    )      (    );        ,  <a href="http://doc.qt.io/qt-5/qt.html">Qt::UniqueConnection</a> ;      ,        ,  ,  <i>Qt</i>        ; <br></li><li> <i>     ,   ;</i> <br>     <a href="http://doc.qt.io/qt-5/qt.html">Qt::QueuedConnection</a>  <a href="http://doc.qt.io/qt-5/qt.html">Qt::BlockingQueuedConnection</a>     ;      ()       ;          ();    ,         ,         ;  those.   ,           ; ,       . <br></li></ul><br><h4>  <i>Qt</i> : </h4><br><ul><li> <i>   <a href="http://doc.qt.io/qt-5/qobject.html">QObject</a> ;</i> <br>    , ,   <i>QObject</i> ,     ,  ,    ( <a href="https://doc.qt.io/qt-5/moc.html"></a> : <i>Virtual inheritance with QObject is not supported.</i> );    ,   ,  ; <br></li><li> <i>   template';</i> <br>        ,     <i>public</i> - <i>QObject</i> ;     <i>moc'</i> ; ,    <br><div class="spoiler"> <b class="spoiler_title">,</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; class AbstractProperty : public QObject { Q_OBJECT protected: AbstractProperty(); signals: void valueChanged(); }; template&lt;class TSource&gt; class TProperty : public AbstractProperty { public: TProperty( const TSource&amp; value = TSource() ) : AbstractProperty(), m_value( value ) { } const TSource&amp; value() const { return m_value; } void setValue( const TSource&amp; newValue ) { if( newValue != m_value ) { m_value = newValue; emit valueChanged(); } } private: TSource m_value; };</span></span></span></span></code> </pre><br>  ,  <i>valueChanged</i>    (  ,  )  ,        . <br></div></div> ,   ,     ; <br></li><li> <strike><i>     .cpp-;</i></strike> <br> <a href="https://habr.com/post/424593/"></a> ; <br></li><li> <i>     <a href="http://doc.qt.io/qt-5/qmetaobject-connection.html">QMetaObject::Connection</a> ;</i> <br>    ,  <i>Qt</i>   (   )    ,    ;      ()   ,    ,           ;            ,          ;  <i>Qt</i>     ; <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use of additional </font><font style="vertical-align: inherit;">code </font><font style="vertical-align: inherit;">generated by </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">moc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font></i> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is completely subjective, but the solution, where for each class that uses signals and slots (slots are not always) there are several (in the file for each configuration) generated files, it brings some inconvenience; </font><font style="vertical-align: inherit;">but let's be honest, this is the smallest drawback.</font></font><br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to note that this comparison with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is still very subjective and is not aimed at exalting or condemning this framework. </font><font style="vertical-align: inherit;">It must be remembered that in addition to the signal / slot mechanism, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> provides a great deal of functionality, both using this mechanism and not depending on it. </font><font style="vertical-align: inherit;">In any case, it's always up to you to decide what to use and what not.</font></font></div><p>Source: <a href="https://habr.com/ru/post/424593/">https://habr.com/ru/post/424593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424583/index.html">You will not be a hero if you are a developer</a></li>
<li><a href="../424585/index.html">The release of CryEngine 5.5 from Crytek</a></li>
<li><a href="../424587/index.html">Summary of the book "Sales to large companies"</a></li>
<li><a href="../424589/index.html">How to enroll in a PhD machine learning program</a></li>
<li><a href="../424591/index.html">There is no ideal: as I was looking for a programming language for myself</a></li>
<li><a href="../424595/index.html">MVC + Scenario vs. Fat Controllers</a></li>
<li><a href="../424597/index.html">Interview with Markus Schirp, RubyRussia Conference Speaker</a></li>
<li><a href="../424599/index.html">You have to choose which software you need: written on time or in quality</a></li>
<li><a href="../424601/index.html">Information architecture on the Internet, part 1</a></li>
<li><a href="../424603/index.html">The book "Why we are wrong. Traps thinking in action. " Excerpts part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>