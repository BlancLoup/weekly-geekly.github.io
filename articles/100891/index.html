<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Eventually Consistent</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, at Habr√©, discussions of scalable systems and NoSQL solutions have become more frequent. This article, written by Amazon‚Äôs CTO, is one of th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Eventually Consistent</h1><div class="post__text post__text-html js-mediator-article">  Recently, at Habr√©, discussions of scalable systems and NoSQL solutions have become more frequent.  This article, written by Amazon‚Äôs CTO, is one of the best introductory, in my opinion, showing what problems arise when building scalable systems, what to consider when choosing a toolkit, what Cassandra authors mean when it comes to providing AP in Cassandra and CP in HBase and much more. <br><a name="habracut"></a><br><h4>  Introduction </h4><br>  Amazon‚Äôs cloud computing is based on infrastructure services.  Such as Amazon S3, SimpleDB and EC2.  They allow you to build scalable computing platforms and applications.  The requirements for these services are very strict.  They must provide excellent security, scalability, availability, performance, and efficient use of resources.  And all this - while serving millions of customers from around the world. <br>  Inside these services are huge distributed systems operating globally.  This creates additional difficulties, since, when processing trillions and trillions of requests, events that usually happen with a very low probability now happen to happen.  And this must be considered when designing and developing the system.  Globally, we use replication everywhere to ensure the required performance and high availability.  Although replication brings us closer to our goals, it still does not allow us to achieve them transparently.  There are a number of nuances that users of replication services will encounter. <br>  One such nuance is the type of data consistency provided by the system.  In particular, many common distributed systems use the eventual consistency model in the context of data replication.  When developing large scalable systems in Amazon, we used a set of rules and abstractions related to data replication in large scalable systems.  We focused on finding a compromise between high availability and data consistency.  In this article, I will look at some of the information that has shaped our approach to building reliable, distributed systems operating on a global scale. <br><br><h4>  Historical perspective </h4><br>  In an ideal world, there would be only one consistency model: once the data has been updated, all observers will see updates.  The first difficulties in achieving this arose in the DBMS in the late 70s.  The best work on this topic is Bruce Lindsay's Notes on Distributed Databases.  He outlines the basic principles of database replication and discusses a number of techniques related to achieving consistency.  Many of these techniques are trying to achieve transparency of distribution - so that from the user's point of view, it looks like a single system, and not as many related systems.  Many systems of that time followed the approach that a failure of the entire system is better than a violation of transparency. <br>  In the mid-90s, with the growth of systems on the Internet, this practice was revised.  At this time, people began to incline to the view that accessibility is the most important feature, but they could not decide what to sacrifice as a compromise.  Eric Brewer, a professor at Berkeley who was the head of Inktomi at that time <i>(the company that launched the successful search engine that was later absorbed by Yahoo -</i> brought together all the compromises together in a report at the 2000 PODC conference.  He presented the CAP theorem, which states that of the three properties of systems with distributed data - data consistency (consistency), system availability when one of the nodes (system availability) fails, and resistance to loss of communication between network segments (partition tolerance) <i>(hereinafter Segmentation of a network means loss of communication between parts of a distributed system, when each part is separately operable, but they do not ‚Äúsee‚Äù each other (note of the lane)</i> - only two can be achieved simultaneously.  A more formalized confirmation was published in an article by Seth Gilbert and Nancy Lynch in 2002. <br>  A system that does not provide resilience to the loss of communication between network segments can achieve data consistency and availability, which is often achieved using a transaction protocol.  In this case, certain situations are treated as a system failure.  For example, if the client does not see part of the nodes.  It should be noted that in large scalable systems segmentation is often present, because data consistency and accessibility are not achievable at the same time.  This means that we have two choices: to weaken the consistency, which will create a system with high availability in terms of network segmentation, or focus on consistency, which will lead to inaccessibility of the system in certain situations. <br>  Both options require the attention of the client developer to the capabilities of the system.  If the system focuses on integrity, then the developer should keep in mind that the system may be inaccessible, for example, for recording and accordingly handle this situation in order not to lose data.  If the system focuses on accessibility, then it can always provide a record, but reading the data in some cases will not reflect the result of the recently implemented record.  The developer has to decide whether the client really needs the most recent changes.  In many cases, it is permissible to use slightly outdated data. <br>  In principle, consistency in ACID-compliant transaction systems is a slightly different kind of consistency assurance.  In ACID, consistency implies a guarantee that upon completion of a transaction, the database is in a consistent state.  For example, when transferring money between accounts, the amount of money in the accounts should not change.  In ACID-compliant systems, this kind of consistency is usually provided by the use of transactions and the data integrity database. <br><br><h4>  Consistency - Client and Server </h4><br>  There are two views on consistency.  One from the point of view of a developer / client: how they see data updates.  The second is from the server side: how are the updates in the system and what the system can guarantee regarding updates. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Client Consistency </h5><br>  From the client‚Äôs point of view, we have the following components: <br>  <b>Storage system</b>  At the moment we consider it as a black box.  But consider that inside something highly scalable and distributed, built to ensure sustainability and accessibility. <br>  <b>Process A</b>  A process that writes to the storage system and reads from it. <br>  <b>Processes B and C.</b>  Two processes, independent of Process A, that also write and read the storage system.  It does not matter whether they are processes or threads of a single process.  What matters is that they are independent and must interact to exchange information. <br>  Client-side consistency determines how and when observers (in our case processes A, B, and C) see changes in the object's data in the storage system.  In the following examples, illustrating the different types of consistency, process A has updated the data. <br>  <b>Strong consistency</b> .  After the update is complete, any subsequent access to the data (Process A, B, or C) will return the updated value. <br>  <b>Weak consistency</b> .  The system does not guarantee that subsequent accesses to the data will return the updated value.  Before the updated value is returned, a number of conditions must be met.  The period between the update and the moment when each observer is always guaranteed to see the updated value is called the <i>inconsistency window</i> . <br>  <b>Eventually consistency</b> .  A special case of poor consistency.  The system ensures that, in the absence of new data updates, ultimately, all queries will return the latest updated value.  In the absence of failures, the maximum inconsistency window size can be determined based on factors such as communication latency, system load, and number of replicas according to the replication scheme.  The most popular system implementing ‚Äúconsistency in the long run‚Äù is DNS.  The updated entry is distributed in accordance with the configuration settings and the settings of the caching intervals.  Ultimately, all customers will see an update. <br>  Eventually consistency (Eventual consistency) has many variations that are important to consider: <br>  <b>Causal consistency</b> .  If process A has informed process B that it has updated the data, then subsequent accesses of process B to this data will return the updated values ‚Äã‚Äãand the record is guaranteed to replace the earlier one.  The access of process C, which is not in causal connection with process A, follows the usual rules of eventual consistency. <br>  <b>Consistency model ‚ÄúRead what you wrote down‚Äù (Read-your-writes consistency)</b> .  This is an important model in which Process A, after updating data, always receives the updated value when it is accessed and never sees the older one.  This is a special case of causal consistency. <br>  <b>Session consistency (Session consistency)</b> .  This is a practical version of the previous model, when the process accesses the repository in the context of the session.  As long as the session exists, the system guarantees read-your-writes consistency.  If the session ends due to some kind of failure, then a new session should be created that is guaranteed not to overlap with others. <br>  <b>The ‚Äúuniform reading‚Äù consistency model (Monotonic read consistency)</b> .  If a process sees a certain value, then, on subsequent accesses to this data, it will never receive an older value. <br>  <b>The monotonic write consistency model (Monotonic write consistency)</b> .  In this variant, the system guarantees the orderliness of the recording of one process.  Systems that do not provide this level of consistency are difficult to use. <br>  Some of these variations can be combined.  For example, you can combine monotonic reads and session consistency.  From a practical point of view, monotonic reads and read-your-writes are most desirable in systems that implement ‚Äúconsistency in the long run‚Äù, but are not always necessary.  This combination facilitates application development while allowing the storage system to reduce consistency and ensure high availability. <br>  ‚ÄúConsistency in the long run‚Äù (Eventual consistency) is not some kind of esoteric poetry of extreme distributed systems.  Many modern relational DBMSs that provide reliability with duplication to a backup server (primary-backup reliability) implement the operation of the replication mechanism in two modes: synchronous and asynchronous.  In synchronous mode, updating a replica is part of a transaction.  In asynchronous mode, the update is delivered as a backup, with some delay, often through the delivery of logs.  In the latter case, if the primary server refuses before the log is delivered, reading from the backup server, raised instead of the main server, will return the outdated data to us.  Also, to ensure better read scalability, relational DBMSs began to provide read access from a backup server, which is a classic case of guarantees of ‚Äúconsistency in the end‚Äù, in which the size of the inconsistency window depends on the frequency of sending the log. <br><br><h5>  Server side consistency </h5><br>  On the server side, we need to further understand how updates are distributed in the system in order to understand what this or that method gives the developer.  Let's first agree on several definitions: <br>  <b>N =</b> number of nodes storing copies (replicas) of data; <br>  <b>W = the</b> number of replicas that must confirm the receipt of the update before the update is considered complete; <br>  <b>R =</b> number of replicas with which a connection is established when processing a request to read data. <br>  If W + R&gt; N, then the sets of replicas involved in writing and participating in reading always intersect, which can guarantee strong consistency.  In the mechanism of synchronous replication to a backup server, relational DBMS is N = 2, W = 2 and R = 1.  No matter which replica reads from, actual data will always be read.  With asynchronous replication and read on from the backup server, N = 2, W = 1 and R = 1.  In this case, R + W = N and data consistency cannot be guaranteed. <br>  The problem with such configurations is that when it is impossible to write to W nodes due to a failure, the write operation should return an error, noting that the system is unavailable.  For example, when N = 3, W = 3, and two available nodes, the system should generate an error when writing. <br>  In distributed repositories, which should provide high performance and availability, the number of replicas is generally more than two.  A system that focuses only on fault tolerance often uses N = 3 (with W = 2 and R = 2).  Systems that must maintain a very high reading load often use more replicas than is necessary to ensure fault tolerance.  The value of N can be several tens, or even hundreds of nodes, with R = 1, so that a query on one node returns a result.  Systems focused on data consistency set W = N for updates, which can reduce the likelihood of successful completion of a record.  Frequent configuration for systems that require fault tolerance, but do not require strong consistency - work with W = 1 to get the minimum update duration and then update the rest of the replicas using a lazy (lazy, epidemic) technique. <br>  How to configure N, W and R depends on use cases and on performance requirements for different loads.  With R = 1, N = W, we optimize the read speed, and with W = 1, R = N, we optimize the system for a very fast write.  Of course, in the latter case, the survival of the system in case of failures is not guaranteed, and with W &lt;(N + 1) / 2 there is the possibility of the occurrence of conflicting records when the sets of nodes do not overlap in various write operations. <br>  Weak (weak / eventual) consistency occurs when W + R &lt;= N.  Those.  there is a possibility that the sets of nodes will not intersect when writing and reading.  If this is a deliberate step and not because of the requirements for fault tolerance, then installing R into something other than 1 makes almost no sense.  Weak consistency occurs in two main cases: the first is replication to multiple nodes to ensure read scaling, as noted above, and the second option, with more complex data access.  In simple systems, the key value is fairly simple to compare versions to determine which value was last written.  But in systems that return sets of objects, it is more difficult to determine which of the sets to be considered the last relevant.  Most systems in which W &lt;N contain a mechanism that updates data on the right nodes (not included in the W set) in the background.  The period before the update of all nodes is the inconsistency window, which was discussed earlier.  If W + R &lt;= N, then the system can read data from nodes that have not yet received the update. <br>  The ability to implement read-your-writes, session, monotonic consistency models generally depends on the client's binding to a specific server, which provides work with the entire distributed system.  When a client accesses the same server each time, the implementation of read-your-writes and monotonic reads is quite simple.  It is somewhat more difficult to implement load balancing and fault tolerance, but this is a simple solution.  It makes it possible to use these sessions, which are sticky. <br>  Sometimes read-your-writes and monotonic reads are implemented by means of the client.  Adding versions to the records, the client discards the value with versions less than the last one encountered. <br>  Segmentation occurs when some nodes of the system cannot connect to other nodes, but both sets of nodes are available to clients.  When using the classic quorum mechanism, a segment with W nodes can continue to function and receive updates, while another segment becomes unavailable.  Similar reasoning applies to reading.  Since the sets of nodes when reading and writing intersect by definition, the smaller set of nodes becomes inaccessible.  Segmentation happens infrequently, but can occur both between data centers and inside data centers. <br>  In some applications, the inaccessibility of part of the nodes is unacceptable, and it is important that the client, which interacts with any segment, can work normally.  In this case, both segments define a new set of nodes for storing data, and a merge operation is performed when the connection between segments is restored. <br><br><h4>  Amazon's dynamo </h4><br>  Amazon's dynamo is a system that allows you to customize all the parameters discussed above in accordance with the architecture of the application.  This key-value storage system is used in many e-commerce platform services and Amazon web services.  One of the goals of Dynamo development is to allow owners of services that use Dynamo storage system instances, often distributed across multiple data centers, to define a compromise between consistency, stability, availability, and system performance. <br><h4>  Summarizing the above </h4><br>  Inconsistency of data in highly scalable reliable distributed systems should be acceptable for two reasons: improved read and write performance, if there are many competitive requests;  segmentation processing, when otherwise it is necessary to declare a part of the system inaccessible, even if all nodes are working. <br>  Whether inconsistency is acceptable depends on the client application.  In any case, the developer should not forget what kind of consistency is provided by the storage system and take this into account when developing applications.  There are a number of practical improvements to the ‚Äúeventual consistency‚Äù model, such as ‚Äúsession consistency‚Äù and ‚Äúmonotonous reading‚Äù, which make life easier for developers.  Often, an application can use eventual consistency without any problems.  A particular case of concern is a web site where we have the concept of consistency from a user's point of view.  In this case, the inconsistency window should be less than the expected time for the user to move to the next page.  This allows you to distribute the update in the system until the next read request. <br>  The purpose of this article is to raise awareness of the complexity of systems that need to operate globally and require careful tuning to ensure that they can provide the performance, availability, and sustainability required by the application.  One of the things that designers of distributed systems have to work with is the size of the inconsistency window, during which system clients can experience the realities of developing highly scalable systems. <br><br>  <i>Comments and suggestions for improving the translation are welcome.</i> </div><p>Source: <a href="https://habr.com/ru/post/100891/">https://habr.com/ru/post/100891/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../100881/index.html">Hi, Habr!</a></li>
<li><a href="../100884/index.html">Cry of the soul: let's write correctly!</a></li>
<li><a href="../100887/index.html">Licensing policy change for WEBO Site SpeedUp</a></li>
<li><a href="../100888/index.html">Home Furniture for Geek</a></li>
<li><a href="../100890/index.html">Running multiple accounts</a></li>
<li><a href="../100892/index.html">Reducing the cost of IT services. Mobile and fixed</a></li>
<li><a href="../100893/index.html">Good luck and failure in the AppStore</a></li>
<li><a href="../100895/index.html">The Chinese have created a project of the future bus</a></li>
<li><a href="../100897/index.html">Review of the communicator Garmin-Asus nuvifone M10!</a></li>
<li><a href="../100898/index.html">MeeGo "on wheels"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>