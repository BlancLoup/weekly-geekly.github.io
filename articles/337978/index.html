<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Telegram bot for Mikrotik with Webhook and JSON parser</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What do you think, is it possible, using only the Mikrotik script, to write an interactive Telegram bot, which will work entirely in the environment o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Telegram bot for Mikrotik with Webhook and JSON parser</h1><div class="post__text post__text-html js-mediator-article">  What do you think, is it possible, using only the Mikrotik script, to write an interactive Telegram bot, which will work entirely in the environment of the router with support for Webhook, incoming events from the Telegram API? <a name="habracut"></a><br><br>  <i>Preface:</i> <i><br></i>  <i>I have been putting off writing this article for a long time, but recent events around the Telegram messenger spurred me with a new energy to take up what was planned.</i>  <i>I believe that Telegram, among other things, is a convenient niche platform for informational dialogue services, and it should exist and be cool to compete with other systems without artificial restrictions.</i>  <i>May this article be a modest contribution to Telegram support.</i> <br><br>  Before answering a question, you need to understand what is minimally required from the bot platform for Webhook to work.  Here's what: the presence of a WEB server with SSL, a valid SSL certificate or a self-signed certificate that is loaded into the Telegram API, the URL address of the WEB server for processing Webhook.  And if access from the Internet (real IP, domain name) to the router can be secured, then with the WEB server (even SSL is not here), Mikrotik has a problem, there is simply no user server.  But this problem can be circumvented; a solution will be proposed below. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Telegram bot for Mikrotik - this is only the "tip of the iceberg."  It is based on the full-featured (as far as possible) JSON parser in the Mikrotik script language.  In general, it is not necessary to do a full analysis of JSON to write an average bot, you can easily do by searching and copying in lines, but I chose a different path.  Next, I will tell you about the parser and some programming techniques of the Mikrotik script that you learned while working on it. <br><br><h2>  JSON parser strings in Mikrotik language </h2><br>  I admit that creating JSON parser in the Mikrotik script language was a sport for me.  It was interesting if this could be done at all, given the limitations of the Mikrotik scripting language.  But the further he plunged into the code, the more clearly the paths to the final goal were seen.  Earlier, I brought to mind a similar VBScript parser found on the network for the needs of a single SCADA system, so I took the logic of the VBScript implementation as a basis, reworked it taking into account the constructions of the Mikrotik language and designed the code as a library of functions.  Along the way, I found several interesting features of the scripting language, which I‚Äôll share with pleasure below.  A few words about the limitations.  First: the length of the string in Mikrotik variables is 4096 bytes, there's nothing you can do about it, all that is simply not assigned to a variable anymore.  Second: Mikrotik does not know anything about real numbers, so the float parser saves as a string variable, the types bool, int, string normally parse into the internal representation. <br><br><h3>  Using JSON parser </h3><br><img src="https://habrastorage.org/webt/vk/ba/iu/vkbaiulgpsz3oyh5y1ii9ocmr54.png"><br><br>  Functions are represented by the JParseFunctions library file, which "expands" the code of functions into global variables.  This library can be called in scripts as many times as necessary, without much loss of performance. For each function, a check is made for its ‚Äúdeployment‚Äù in global variables in order to avoid duplication of actions.  When editing a library file, you need to delete global variables - the function code so that they are ‚Äúre-created‚Äù with the updates. <br><br>  JParseFunctions library code: <br><br><div class="spoiler">  <b class="spoiler_title">JParseFunctions</b> <div class="spoiler_text"><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># -------------------------------- JParseFunctions --------------------------------------------------- # ------------------------------- fJParsePrint ---------------------------------------------------------------- :global fJParsePrint :if (!any $fJParsePrint) do={ :global fJParsePrint do={ :global JParseOut :local TempPath :global fJParsePrint :if ([:len $1] = 0) do={ :set $1 "\$JParseOut" :set $2 $JParseOut } :foreach k,v in=$2 do={ :if ([:typeof $k] = "str") do={ :set k "\"$k\"" } :set TempPath ($1. "-&gt;" . $k) :if ([:typeof $v] = "array") do={ :if ([:len $v] &gt; 0) do={ $fJParsePrint $TempPath $v } else={ :put "$TempPath = [] ($[:typeof $v])" } } else={ :put "$TempPath = $v ($[:typeof $v])" } } }} # ------------------------------- fJParsePrintVar ---------------------------------------------------------------- :global fJParsePrintVar :if (!any $fJParsePrintVar) do={ :global fJParsePrintVar do={ :global JParseOut :local TempPath :global fJParsePrintVar :local fJParsePrintRet "" :if ([:len $1] = 0) do={ :set $1 "\$JParseOut" :set $2 $JParseOut } :foreach k,v in=$2 do={ :if ([:typeof $k] = "str") do={ :set k "\"$k\"" } :set TempPath ($1. "-&gt;" . $k) :if ($fJParsePrintRet != "") do={ :set fJParsePrintRet ($fJParsePrintRet . "\r\n") } :if ([:typeof $v] = "array") do={ :if ([:len $v] &gt; 0) do={ :set fJParsePrintRet ($fJParsePrintRet . [$fJParsePrintVar $TempPath $v]) } else={ :set fJParsePrintRet ($fJParsePrintRet . "$TempPath = [] ($[:typeof $v])") } } else={ :set fJParsePrintRet ($fJParsePrintRet . "$TempPath = $v ($[:typeof $v])") } } :return $fJParsePrintRet }} # ------------------------------- fJSkipWhitespace ---------------------------------------------------------------- :global fJSkipWhitespace :if (!any $fJSkipWhitespace) do={ :global fJSkipWhitespace do={ :global Jpos :global JSONIn :global Jdebug :while ($Jpos &lt; [:len $JSONIn] and ([:pick $JSONIn $Jpos] ~ "[ \r\n\t]")) do={ :set Jpos ($Jpos + 1) } :if ($Jdebug) do={:put "fJSkipWhitespace: Jpos=$Jpos Char=$[:pick $JSONIn $Jpos]"} }} # -------------------------------- fJParse --------------------------------------------------------------- :global fJParse :if (!any $fJParse) do={ :global fJParse do={ :global Jpos :global JSONIn :global Jdebug :global fJSkipWhitespace :local Char :if (!$1) do={ :set Jpos 0 } $fJSkipWhitespace :set Char [:pick $JSONIn $Jpos] :if ($Jdebug) do={:put "fJParse: Jpos=$Jpos Char=$Char"} :if ($Char="{") do={ :set Jpos ($Jpos + 1) :global fJParseObject :return [$fJParseObject] } else={ :if ($Char="[") do={ :set Jpos ($Jpos + 1) :global fJParseArray :return [$fJParseArray] } else={ :if ($Char="\"") do={ :set Jpos ($Jpos + 1) :global fJParseString :return [$fJParseString] } else={ # :if ([:pick $JSONIn $Jpos ($Jpos+2)]~"^-\?[0-9]") do={ :if ($Char~"[eE0-9.+-]") do={ :global fJParseNumber :return [$fJParseNumber] } else={ :if ($Char="n" and [:pick $JSONIn $Jpos ($Jpos+4)]="null") do={ :set Jpos ($Jpos + 4) :return [] } else={ :if ($Char="t" and [:pick $JSONIn $Jpos ($Jpos+4)]="true") do={ :set Jpos ($Jpos + 4) :return true } else={ :if ($Char="f" and [:pick $JSONIn $Jpos ($Jpos+5)]="false") do={ :set Jpos ($Jpos + 5) :return false } else={ :put "Err.Raise 8732. No JSON object could be fJParseed" :set Jpos ($Jpos + 1) :return [] } } } } } } } }} #-------------------------------- fJParseString --------------------------------------------------------------- :global fJParseString :if (!any $fJParseString) do={ :global fJParseString do={ :global Jpos :global JSONIn :global Jdebug :global fUnicodeToUTF8 :local Char :local StartIdx :local Char2 :local TempString "" :local UTFCode :local Unicode :set StartIdx $Jpos :set Char [:pick $JSONIn $Jpos] :if ($Jdebug) do={:put "fJParseString: Jpos=$Jpos Char=$Char"} :while ($Jpos &lt; [:len $JSONIn] and $Char != "\"") do={ :if ($Char="\\") do={ :set Char2 [:pick $JSONIn ($Jpos + 1)] :if ($Char2 = "u") do={ :set UTFCode [:tonum "0x$[:pick $JSONIn ($Jpos+2) ($Jpos+6)]"] :if ($UTFCode&gt;=0xD800 and $UTFCode&lt;=0xDFFF) do={ # Surrogate pair :set Unicode (($UTFCode &amp; 0x3FF) &lt;&lt; 10) :set UTFCode [:tonum "0x$[:pick $JSONIn ($Jpos+8) ($Jpos+12)]"] :set Unicode ($Unicode | ($UTFCode &amp; 0x3FF) | 0x10000) :set TempString ($TempString . [:pick $JSONIn $StartIdx $Jpos] . [$fUnicodeToUTF8 $Unicode]) :set Jpos ($Jpos + 12) } else= { # Basic Multilingual Plane (BMP) :set Unicode $UTFCode :set TempString ($TempString . [:pick $JSONIn $StartIdx $Jpos] . [$fUnicodeToUTF8 $Unicode]) :set Jpos ($Jpos + 6) } :set StartIdx $Jpos :if ($Jdebug) do={:put "fJParseString Unicode: $Unicode"} } else={ :if ($Char2 ~ "[\\bfnrt\"]") do={ :if ($Jdebug) do={:put "fJParseString escape: Char+Char2 $Char$Char2"} :set TempString ($TempString . [:pick $JSONIn $StartIdx $Jpos] . [[:parse "(\"\\$Char2\")"]]) :set Jpos ($Jpos + 2) :set StartIdx $Jpos } else={ :if ($Char2 = "/") do={ :if ($Jdebug) do={:put "fJParseString /: Char+Char2 $Char$Char2"} :set TempString ($TempString . [:pick $JSONIn $StartIdx $Jpos] . "/") :set Jpos ($Jpos + 2) :set StartIdx $Jpos } else={ :put "Err.Raise 8732. Invalid escape" :set Jpos ($Jpos + 2) } } } } else={ :set Jpos ($Jpos + 1) } :set Char [:pick $JSONIn $Jpos] } :set TempString ($TempString . [:pick $JSONIn $StartIdx $Jpos]) :set Jpos ($Jpos + 1) :if ($Jdebug) do={:put "fJParseString: $TempString"} :return $TempString }} #-------------------------------- fJParseNumber --------------------------------------------------------------- :global fJParseNumber :if (!any $fJParseNumber) do={ :global fJParseNumber do={ :global Jpos :local StartIdx :global JSONIn :global Jdebug :local NumberString :local Number :set StartIdx $Jpos :set Jpos ($Jpos + 1) :while ($Jpos &lt; [:len $JSONIn] and [:pick $JSONIn $Jpos]~"[eE0-9.+-]") do={ :set Jpos ($Jpos + 1) } :set NumberString [:pick $JSONIn $StartIdx $Jpos] :set Number [:tonum $NumberString] :if ([:typeof $Number] = "num") do={ :if ($Jdebug) do={:put "fJParseNumber: StartIdx=$StartIdx Jpos=$Jpos $Number ($[:typeof $Number])"} :return $Number } else={ :if ($Jdebug) do={:put "fJParseNumber: StartIdx=$StartIdx Jpos=$Jpos $NumberString ($[:typeof $NumberString])"} :return $NumberString } }} #-------------------------------- fJParseArray --------------------------------------------------------------- :global fJParseArray :if (!any $fJParseArray) do={ :global fJParseArray do={ :global Jpos :global JSONIn :global Jdebug :global fJParse :global fJSkipWhitespace :local Value :local ParseArrayRet [:toarray ""] $fJSkipWhitespace :while ($Jpos &lt; [:len $JSONIn] and [:pick $JSONIn $Jpos]!= "]") do={ :set Value [$fJParse true] :set ($ParseArrayRet-&gt;([:len $ParseArrayRet])) $Value :if ($Jdebug) do={:put "fJParseArray: Value="; :put $Value} $fJSkipWhitespace :if ([:pick $JSONIn $Jpos] = ",") do={ :set Jpos ($Jpos + 1) $fJSkipWhitespace } } :set Jpos ($Jpos + 1) # :if ($Jdebug) do={:put "ParseArrayRet: "; :put $ParseArrayRet} :return $ParseArrayRet }} # -------------------------------- fJParseObject --------------------------------------------------------------- :global fJParseObject :if (!any $fJParseObject) do={ :global fJParseObject do={ :global Jpos :global JSONIn :global Jdebug :global fJSkipWhitespace :global fJParseString :global fJParse # Syntax :local ParseObjectRet ({}) don't work in recursive call, use [:toarray ""] for empty array!!! :local ParseObjectRet [:toarray ""] :local Key :local Value :local ExitDo false $fJSkipWhitespace :while ($Jpos &lt; [:len $JSONIn] and [:pick $JSONIn $Jpos]!="}" and !$ExitDo) do={ :if ([:pick $JSONIn $Jpos]!="\"") do={ :put "Err.Raise 8732. Expecting property name" :set ExitDo true } else={ :set Jpos ($Jpos + 1) :set Key [$fJParseString] $fJSkipWhitespace :if ([:pick $JSONIn $Jpos] != ":") do={ :put "Err.Raise 8732. Expecting : delimiter" :set ExitDo true } else={ :set Jpos ($Jpos + 1) :set Value [$fJParse true] :set ($ParseObjectRet-&gt;$Key) $Value :if ($Jdebug) do={:put "fJParseObject: Key=$Key Value="; :put $Value} $fJSkipWhitespace :if ([:pick $JSONIn $Jpos]=",") do={ :set Jpos ($Jpos + 1) $fJSkipWhitespace } } } } :set Jpos ($Jpos + 1) # :if ($Jdebug) do={:put "ParseObjectRet: "; :put $ParseObjectRet} :return $ParseObjectRet }} # ------------------- fByteToEscapeChar ---------------------- :global fByteToEscapeChar :if (!any $fByteToEscapeChar) do={ :global fByteToEscapeChar do={ # :set $1 [:tonum $1] :return [[:parse "(\"\\$[:pick "0123456789ABCDEF" (($1 &gt;&gt; 4) &amp; 0xF)]$[:pick "0123456789ABCDEF" ($1 &amp; 0xF)]\")"]] }} # ------------------- fUnicodeToUTF8---------------------- :global fUnicodeToUTF8 :if (!any $fUnicodeToUTF8) do={ :global fUnicodeToUTF8 do={ :global fByteToEscapeChar # :local Ubytes [:tonum $1] :local Nbyte :local EscapeStr "" :if ($1 &lt; 0x80) do={ :set EscapeStr [$fByteToEscapeChar $1] } else={ :if ($1 &lt; 0x800) do={ :set Nbyte 2 } else={ :if ($1 &lt; 0x10000) do={ :set Nbyte 3 } else={ :if ($1 &lt; 0x20000) do={ :set Nbyte 4 } else={ :if ($1 &lt; 0x4000000) do={ :set Nbyte 5 } else={ :if ($1 &lt; 0x80000000) do={ :set Nbyte 6 } } } } } :for i from=2 to=$Nbyte do={ :set EscapeStr ([$fByteToEscapeChar ($1 &amp; 0x3F | 0x80)] . $EscapeStr) :set $1 ($1 &gt;&gt; 6) } :set EscapeStr ([$fByteToEscapeChar (((0xFF00 &gt;&gt; $Nbyte) &amp; 0xFF) | $1)] . $EscapeStr) } :return $EscapeStr }} # ------------------- End JParseFunctions----------------------</span></span></code> </pre> </div></div><br>  Consider the work of the parser for example a piece of code Telegram bot.  Perform the following commands step by step. <br><br>  Request the state of the getWebhookInfo API function of the Telegram API, which returns a JSON string to the j.txt file: <br><br><pre> <code class="bash hljs">:<span class="hljs-keyword"><span class="hljs-keyword">do</span></span> {/tool fetch url=<span class="hljs-string"><span class="hljs-string">"https://api.telegram.org/bot</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TToken</span></span></span><span class="hljs-string">/getWebhookInfo"</span></span> dst-path=j.txt} on-error={:put <span class="hljs-string"><span class="hljs-string">"getWebhookInfo error"</span></span>};</code> </pre> <br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put [/file get j.txt contents]; {<span class="hljs-string"><span class="hljs-string">"ok"</span></span>:<span class="hljs-literal"><span class="hljs-literal">true</span></span>,<span class="hljs-string"><span class="hljs-string">"result"</span></span>:{<span class="hljs-string"><span class="hljs-string">"url"</span></span>:<span class="hljs-string"><span class="hljs-string">"https://*****:8443"</span></span>,<span class="hljs-string"><span class="hljs-string">"has_custom_certificate"</span></span>:<span class="hljs-literal"><span class="hljs-literal">false</span></span>,<span class="hljs-string"><span class="hljs-string">"pending_update_count"</span></span>:0,<span class="hljs-string"><span class="hljs-string">"last_error_date"</span></span>:1524565055,<span class="hljs-string"><span class="hljs-string">"last_error_message"</span></span>:<span class="hljs-string"><span class="hljs-string">"Connection timed out"</span></span>,<span class="hljs-string"><span class="hljs-string">"max_connections"</span></span>:4 0}}</code> </pre> <br>  Loading JSON string in input variable: <br><br><pre> <code class="bash hljs">:<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> JSONIn [/file get j.txt contents]</code> </pre> <br>  Execution of the $ fJParse parser function and uploading the result to the $ JParseOut variable <br><br><pre> <code class="bash hljs">:<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> JParseOut [<span class="hljs-variable"><span class="hljs-variable">$fJParse</span></span>];</code> </pre> <br>  In $ JParseOut, you can find an associative array, which is a mapping of the original JSON string to arrays and Mikrotik data types.  The content here does not cite, it is given below. <br><br>  You can set the global variable $ Jdebug (true), then in manual mode, when you call the function in the console of the router, you can get additional output for debugging needs. <br><br><h3>  Multidimensional associative arrays </h3><br>  In the Mikrotik language, nested (multidimensional) associative arrays are supported. <br>  Here is an example of the output of the global variable $ JParseOut, in which the result of the parser is written: <br><br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span> ok=<span class="hljs-literal"><span class="hljs-literal">true</span></span>;result=has_custom_certificate=<span class="hljs-literal"><span class="hljs-literal">false</span></span>;max_connections=40;pending_update_count=0;url=https://*****.ru:8443</code> </pre> <br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put (<span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>) has_custom_certificate=<span class="hljs-literal"><span class="hljs-literal">false</span></span>;max_connections=40;pending_update_count=0;url=https://*****:8443</code> </pre> <br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put (<span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"max_connections"</span></span>) 40</code> </pre> <br>  It can be seen that the key ‚Äúresult‚Äù contains also an associative array as a value, the elements of which can be accessed using the "-&gt;" chain.  And it is important that all elements have their own data type (number, string, boolean, array): <br><br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put [:typeof (<span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>)] array</code> </pre> <br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put [:typeof (<span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"max_connections"</span></span>)] num</code> </pre> <br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put [:typeof (<span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"url"</span></span>)] str</code> </pre> <br>  It was experiments with this multi-level construction that gave rise to the idea of ‚Äã‚Äãcreating a JSON parser.  The JSON format is nicely shifted to such an internal representation of the Mikrotik script language. <br><br><h3>  Functions, recursive call </h3><br>  For many, it is no secret that you can define your functions, on the forum site <a href="http://www.mikrotik.com/">www.mikrotik.com</a> you can find many examples of such structures.  My parser is also built on functions, nested and recursive calls.  Yes, recursive function calls are supported! <br><br>  As an example, I will cite the $ fJParsePrint function from the parser set, printing in readable form the contents of the associative array $ JParseOut (or rather, in the form of paths that can be copied and used in their scripts to access the elements of the array) and the result of its work: <br><br><pre> <code class="bash hljs">:global fJParsePrint :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!any <span class="hljs-variable"><span class="hljs-variable">$fJParsePrint</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :global fJParsePrint <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :global JParseOut :<span class="hljs-built_in"><span class="hljs-built_in">local</span></span> TempPath :global fJParsePrint :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:len <span class="hljs-variable"><span class="hljs-variable">$1</span></span>] = 0) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$1</span></span> <span class="hljs-string"><span class="hljs-string">"\$JParseOut"</span></span> :<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> <span class="hljs-variable"><span class="hljs-variable">$2</span></span> <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span> } :foreach k,v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>=<span class="hljs-variable"><span class="hljs-variable">$2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:typeof <span class="hljs-variable"><span class="hljs-variable">$k</span></span>] = <span class="hljs-string"><span class="hljs-string">"str"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> k <span class="hljs-string"><span class="hljs-string">"\"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$k</span></span></span><span class="hljs-string">\""</span></span> } :<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> TempPath (<span class="hljs-variable"><span class="hljs-variable">$1</span></span>. <span class="hljs-string"><span class="hljs-string">"-&gt;"</span></span> . <span class="hljs-variable"><span class="hljs-variable">$k</span></span>) :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:typeof <span class="hljs-variable"><span class="hljs-variable">$v</span></span>] = <span class="hljs-string"><span class="hljs-string">"array"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:len <span class="hljs-variable"><span class="hljs-variable">$v</span></span>] &gt; 0) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ <span class="hljs-variable"><span class="hljs-variable">$fJParsePrint</span></span> <span class="hljs-variable"><span class="hljs-variable">$TempPath</span></span> <span class="hljs-variable"><span class="hljs-variable">$v</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>={ :put <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TempPath</span></span></span><span class="hljs-string"> = [] ($[:typeof </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$v</span></span></span><span class="hljs-string">])"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>={ :put <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TempPath</span></span></span><span class="hljs-string"> = </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$v</span></span></span><span class="hljs-string"> ($[:typeof </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$v</span></span></span><span class="hljs-string">])"</span></span> } } }}</code> </pre> <br><pre> <code class="bash hljs">[admin@MikroTik] &gt; <span class="hljs-variable"><span class="hljs-variable">$fJParsePrint</span></span> <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"ok"</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span> (bool) <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"has_custom_certificate"</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> (bool) <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"last_error_date"</span></span> = 1524483204 (num) <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"last_error_message"</span></span> = Connection timed out (str) <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"max_connections"</span></span> = 40 (num) <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"pending_update_count"</span></span> = 0 (num) <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"url"</span></span> = https://*****.ru:8443 (str)</code> </pre> <br>  You can see in the function code a recursive call that passes the current level of the attachment and the subarray element into the function, thus traversing the entire array tree in the $ JParseOut variable. <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$fJParsePrint</span></span> <span class="hljs-variable"><span class="hljs-variable">$TempPath</span></span> <span class="hljs-variable"><span class="hljs-variable">$v</span></span></code> </pre> <br>  For interest, you can call this function with parameters from the console, specify the initial output path, for example, ‚Äúhome‚Äù, and an array variable manually: <br><br><pre> <code class="bash hljs">[admin@MikroTik] &gt; <span class="hljs-variable"><span class="hljs-variable">$fJParsePrint</span></span> <span class="hljs-string"><span class="hljs-string">"home"</span></span> <span class="hljs-variable"><span class="hljs-variable">$JParseOut</span></span> home-&gt;<span class="hljs-string"><span class="hljs-string">"ok"</span></span> = <span class="hljs-literal"><span class="hljs-literal">true</span></span> (bool) home-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"has_custom_certificate"</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span> (bool) home-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"last_error_date"</span></span> = 1524483204 (num) home-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"last_error_message"</span></span> = Connection timed out (str) home-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"max_connections"</span></span> = 40 (num) home-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"pending_update_count"</span></span> = 0 (num) home-&gt;<span class="hljs-string"><span class="hljs-string">"result"</span></span>-&gt;<span class="hljs-string"><span class="hljs-string">"url"</span></span> = https://*****.ru:8443 (str)</code> </pre> <br>  The function is written to handle the call with and without parameters, i.e.  A variable number of parameters are used.  Traditionally, before a call, it is necessary to declare (more precisely, declare) global variables and functions inside the block, in this case in the function body.  Notice that the declaration ": global fJParsePrint" is present, i.e.  the function itself is declared, nothing surprising, it is necessary for a recursive call. <br><br><h3>  Parsing a string with on-the-fly code and its execution </h3><br>  Let's look at the $ fByteToEscapeChar function: <br><br><pre> <code class="bash hljs">:global fByteToEscapeChar :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!any <span class="hljs-variable"><span class="hljs-variable">$fByteToEscapeChar</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ :global fByteToEscapeChar <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ <span class="hljs-comment"><span class="hljs-comment"># :set $1 [:tonum $1] :return [[:parse "(\"\\$[:pick "0123456789ABCDEF" (($1 &gt;&gt; 4) &amp; 0xF)]$[:pick "0123456789ABCDEF" ($1 &amp; 0xF)]\")"]] }}</span></span></code> </pre> <br>  This function converts the parameter $ 1 (byte number) to a string character, i.e.  converts an ASCII code to a character.  Here, for example, is the code 0x2B, which corresponds to the symbol "+".  You can set the character by using the escaping "\ NN", where NN is the ASCII code, but only on the line: <br><br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put <span class="hljs-string"><span class="hljs-string">"\2B"</span></span> +</code> </pre> <br>  But if the source code is represented by a number (byte), then obtaining a symbol is not an easy task, since there is no ready built-in function for this.  Here comes another built-in parse function that allows you to assemble a string ‚Äî an expression, a control sequence based on the source number, for example, "(\ 2B)". <br><br>  Expression of the form: <br><br><pre> <code class="bash hljs">:put [:parse <span class="hljs-string"><span class="hljs-string">"(\"\\$[:pick "</span></span>0123456789ABCDEF<span class="hljs-string"><span class="hljs-string">" ((0x2B &gt;&gt; 4) &amp; 0xF)]$[:pick "</span></span>0123456789ABCDEF<span class="hljs-string"><span class="hljs-string">" (0x2B &amp; 0xF)]\")"</span></span>] (&lt;%% + )</code> </pre> <br>  - collects a line of code that must be executed to get a string character on the output.  The second execution of the code obtained after the parse is done using the same square brackets [...], so the final expression takes on a rather intricate look, framing with double square brackets [[...]], after which we get the expected symbol: <br><br><pre> <code class="bash hljs">[admin@MikroTik] &gt; :put [[:parse <span class="hljs-string"><span class="hljs-string">"(\"\\$[:pick "</span></span>0123456789ABCDEF<span class="hljs-string"><span class="hljs-string">" ((0x2B &gt;&gt; 4) &amp; 0xF)]$[:pick "</span></span>0123456789ABCDEF<span class="hljs-string"><span class="hljs-string">" (0x2B &amp; 0xF)]\")"</span></span>]] +</code> </pre> <br><h2>  Telegram bot based on JSON parser </h2><br><h3>  Polling bot </h3><br>  Now that we can easily access the contents of the JSON responses from the Telegram API, we‚Äôll write the first version of the bot operating in polling mode, i.e.  periodic API request Telegram.  It will respond to some commands, for example, uptime - request the router operation time, ip - request all DHCP Client IP addresses, parse - output the contents of the $ JParseOut variable, i.e.  parse JSON response to the last request.  If you enter any other commands or characters, the bot will simply echo out. <br><br>  This bot is a single script that is called periodically from the scheduler, for example, once a minute and reads the getUpdates API telegram function, after parsing the answer, makes the if-else action on the $ v -&gt; ‚Äúmessage‚Äù -&gt; ‚Äútext‚Äù variable.  I also want to draw attention to the function call ‚Äútext = $ [$ fJParsePrintVar]‚Äù from the set of parser functions, which returns the contents of $ JParseOut in a readable form.  The full bot code is shown below. <br><br>  From the pros: since the script initiates the exchange, it will work through NAT without settings. <br>  The disadvantages of this implementation are: the speed of Mikrotik‚Äôs response to a request is determined by the frequency of the script call, each call is made with a getUpdates request, the parsing, in general, the complete request-analysis cycle, which loads the processor;  Each call leads to a j.txt file; for a partition on a flash disk, this is bad; for a RAM disk it is not a problem. <br><br>  Bot Polling script code: <br><br><div class="spoiler">  <b class="spoiler_title">TelegramPollingBot</b> <div class="spoiler_text"><pre> <code class="bash hljs">/system script run JParseFunctions :global TToken <span class="hljs-string"><span class="hljs-string">"12312312:32131231231"</span></span> :global TChatId <span class="hljs-string"><span class="hljs-string">"43242342423"</span></span> :global Toffset :<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:typeof <span class="hljs-variable"><span class="hljs-variable">$Toffset</span></span>] != <span class="hljs-string"><span class="hljs-string">"num"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={:<span class="hljs-built_in"><span class="hljs-built_in">set</span></span> Toffset 0} /tool fetch url=<span class="hljs-string"><span class="hljs-string">"https://api.telegram.org/bot</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TToken</span></span></span><span class="hljs-string">/getUpdates\?chat_id=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$TChatId</span></span></span><span class="hljs-string">&amp;offset=</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$Toffset</span></span></span><span class="hljs-string">"</span></span> dst-path=j.txt <span class="hljs-comment"><span class="hljs-comment">#:delay 2 :global JSONIn [/file get j.txt contents] :global fJParse :global fJParsePrintVar :global Jdebug false :global JParseOut [$fJParse] :local Results ($JParseOut-&gt;"result") :if ([:len $Results]&gt;0) do={ :foreach k,v in=$Results do={ :if (any ($v-&gt;"message"-&gt;"text")) do={ :if ($v-&gt;"message"-&gt;"text" ~ "uptime") do={ /tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$[/system resource get uptime]" keep-result=no } else={ :if ($v-&gt;"message"-&gt;"text" ~ "ip") do={ /tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$[/ip dhcp-client print as-value]" keep-result=no } else={ :if ($v-&gt;"message"-&gt;"text" ~ "parse") do={ /tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$[$fJParsePrintVar]" keep-result=no } else={ /tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$($v-&gt;"message"-&gt;"text")" keep-result=no } } } } :set $Toffset ($v-&gt;"update_id" + 1) } } else={ :set $Toffset 0 }</span></span></code> </pre><br></div></div><br><h3>  Webhook bot </h3><br>  To get rid of these drawbacks, let's create the second version of the script that will process Webhook, i.e.  when the Telegram API itself is ‚Äúhammered‚Äù at a given address into the router in order to send new messages. <br><br>  Mikrotik, of course, does not know how to make a custom Web server inside itself, which is required for the full-fledged operation of Webhook notifications from the Telegram API.  But you can slyly get around this problem.  To do this, you need to monitor some non-existent TCP socket, which Webhook will ‚Äúdig‚Äù into; this is done using the Mangle (or Firewall) rules.  The Telegram API turns on working with Webhook (the setWebhook API function), specifies the domain name of the router and the TCP port, the SSL certificate does not play any role here, i.e.  not needed!  By changing the value of the packet counter of the Mangle rule, it can be understood that the Webhook (or something else;) gets into the non-existent TCP port (or you can cut off the excess with the src-address filter = 149.154.167.192 / 26).  Unfortunately, the Mangle rule cannot directly invoke a custom script (there is no such action), but you can interrogate the packet counter from the script.  The script also runs on a schedule, but with a minimum interval of 1 second.  In the standby state, only the check of changes in the value of the packet counter is performed.  After detecting a new incoming packet, a request is sent to the Telegram API to disable Webhook, and reading and processing of messages is done as in the first variant of the script (polling), then Webhook is turned on again and returned to the standby state.  The main steps are illustrated in the diagram of the script. <br><br><img src="https://habrastorage.org/webt/nm/wx/jq/nmwxjqdz6ncqdejqinehqqcbino.png"><br><br>  As already mentioned, the script is run frequently, and to avoid duplication of instances of the called script, protection against duplication is made at the beginning of the script, the name of this script must be indicated there. <br><br><pre> <code class="bash hljs">:<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:len [/system script job find script=TelegramWebhookBot]] &lt;= 1) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={...}</code> </pre> <br>  Script code Webhook bot: <br><br><div class="spoiler">  <b class="spoiler_title">TelegramWebhookBot</b> <div class="spoiler_text"><pre> <code class="bash hljs">:<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([:len [/system script job find script=TelegramWebhookBot]] &lt;= 1) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>={ <span class="hljs-comment"><span class="hljs-comment">#:while (true) do={ :global TelegramWebhookPackets :local TWebhookURL "https://www.yourdomain" :local TWebhookPort "8443" # Create Telegram webhook mangle action :if ([:len [/ip firewall mangle find dst-port=$TWebhookPort]] = 0) do={ /ip firewall mangle add action=accept chain=prerouting connection-state=new dst-port=$TWebhookPort protocol=tcp src-address=149.154.167.192/26 comment="Telegram" } :if ([/ip firewall mangle get [find dst-port=$TWebhookPort] packets] != $TelegramWebhookPackets) do={ /system script run JParseFunctions :local TToken "123123123:123123123123123" :local TChatId "3213123123123" :global TelegramOffset :global fJParse :global fJParsePrintVar :global Jdebug false :global JSONIn :global JParseOut :if ([:typeof $TelegramOffset] != "num") do={:set TelegramOffset 0} :put "getWebhookInfo" :do {/tool fetch url="https://api.telegram.org/bot$TToken/getWebhookInfo" dst-path=j.txt} on-error={:put "getWebhookInfo error"} :set JSONIn [/file get j.txt contents] :set JParseOut [$fJParse] :put $JParseOut :if ($JParseOut-&gt;"result"-&gt;"pending_update_count" &gt; 0) do={ :put "pending_update_count &gt; 0" :do {/tool fetch url="https://api.telegram.org/bot$TToken/deleteWebhook" http-method=get keep-result=no} on-error={:put "deleteWebhook error"} :put "getUpdates" :do {/tool fetch url="https://api.telegram.org/bot$TToken/getUpdates\?chat_id=$TChatId&amp;offset=$TelegramOffset" dst-path=j.txt} on-error={:put "getUpdates error"} :set JSONIn [/file get j.txt contents] :set JParseOut [$fJParse] :put $JParseOut :if ([:len ($JParseOut-&gt;"result")] &gt; 0) do={ :foreach k,v in=($JParseOut-&gt;"result") do={ :if (any ($v-&gt;"message"-&gt;"text")) do={ :if ($v-&gt;"message"-&gt;"text" ~ "uptime") do={ :do {/tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$[/system resource get uptime]" keep-result=no} on-error={:put "sendmessage error"} } else={ :if ($v-&gt;"message"-&gt;"text" ~ "ip") do={ :do {/tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$[/ip dhcp-client print as-value]" keep-result=no} on-error={:put "sendmessage error"} } else={ :if ($v-&gt;"message"-&gt;"text" ~ "parse") do={ :do {/tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$[$fJParsePrintVar]" keep-result=no} on-error={:put "sendmessage error"} } else={ :if ($v-&gt;"message"-&gt;"text" ~ "add") do={ :local addIP [:toip [:pick ($v-&gt;"message"-&gt;"text") 4 [:len ($v-&gt;"message"-&gt;"text")]]] :if ([:typeof $addIP] = "ip") do={ :do {/ip firewall address-list add address=$addIP list=ExtAccessIPList timeout=10m comment="temp"} on-error={:put "ip in list error"} } :local Str1 "" :foreach item in=[/ip firewall address-list print as-value where list=ExtAccessIPList and dynamic] do={:set Str1 ($Str1 . "$($item-&gt;"address") $($item-&gt;"timeout") $($item-&gt;"comment")\r\n")} :do {/tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$Str1" keep-result=no} on-error={:put "sendmessage error"} } else={ :put ($v-&gt;"message"-&gt;"text") :do {/tool fetch url="https://api.telegram.org/bot$TToken/sendmessage\?chat_id=$TChatId" http-method=post http-data="text=$($v-&gt;"message"-&gt;"text")" keep-result=no} on-error={:put "sendmessage error"} } } } } } :set $TelegramOffset ($v-&gt;"update_id" + 1) } } else={ # :set $TelegramOffset 0 } :put "getUpdates" :do {/tool fetch url="https://api.telegram.org/bot$TToken/getUpdates\?chat_id=$TChatId&amp;offset=$TelegramOffset" keep-result=no} on-error={:put "getUpdates error"} :put "setWebhook" :do {/tool fetch url="https://api.telegram.org/bot$TToken/setWebhook\?url=$TWebhookURL:$TWebhookPort" keep-result=no} on-error={:put "setWebhook error"} } else={ :if ($JParseOut-&gt;"result"-&gt;"url"="") do={ :put "setWebhook" :do {/tool fetch url="https://api.telegram.org/bot$TToken/setWebhook\?url=$TWebhookURL:$TWebhookPort" keep-result=no} on-error={:put "setWebhook error"} } } :set TelegramWebhookPackets [/ip firewall mangle get [find dst-port=$TWebhookPort] packets] :put "--------------------------------------------------" } }</span></span></code> </pre><br></div></div><br>  The ‚Äúadd‚Äù command was added to this bot script, which adds the IP address to the ExtAccessIPList allowing address list for 10 minutes. <br><br>  Sample request and response in Telegram.  The last line is the temporary address already added to the IP list: <br><br> <code>&gt;add 1.1.1.1 <br> &gt;&gt; 90.0.0.97 h******* <br> 100.0.0.157 6******* <br> 90.0.0.2 i*******.ru <br> 100.00.66 b*******.ru <br> 1.1.1.1 00:10:00 temp</code> <br> <br>  It remains to point out the disadvantages and advantages of this approach.  Cons: for Webhook, you need access to the IP and the specified TCP port of the router from the Internet, in fact, the real IP address, preferably associated with the domain.  Regarding the availability of the domain name, I‚Äôm not sure if the Telegram API needs to be ‚Äúsmoked‚Äù, perhaps it doesn‚Äôt allow Webhook to be made on the server‚Äôs IP.  It works with a dynamic real IP address and a dynamic DNS service. <br><br>  Pros: the main part of the script actually sleeps all the time, waiting for incoming packets on the surrogate socket.  If the script is called frequently (once per second), then Webhook-and are processed very quickly, as in normal Telegram bots. <br><br>  Also source code can be found <a href="http://www.embest.ru/mikrotik/json-parser-script">here</a> . <br><br>  And a little video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/hIN8FpmJHlw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QJGC3qemLlk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/337978/">https://habr.com/ru/post/337978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337968/index.html">What do large successful open source projects have in common?</a></li>
<li><a href="../337970/index.html">People's Privacy Policy</a></li>
<li><a href="../337972/index.html">On the factor of the case when playing "Monopoly"</a></li>
<li><a href="../337974/index.html">Overview of one Russian RTOS, part 5. First application</a></li>
<li><a href="../337976/index.html">RTP Bleed: Dangerous vulnerability to intercept VoIP traffic</a></li>
<li><a href="../337982/index.html">Methods for developing motion software flow sensors that work with Arduino</a></li>
<li><a href="../337984/index.html">About smart contracts in simple words</a></li>
<li><a href="../337986/index.html">Prototyping in the Python-Arduino environment</a></li>
<li><a href="../337990/index.html">Android web applications without Cordova, Phonegap and SMS</a></li>
<li><a href="../337992/index.html">Journey from Node to Crystal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>