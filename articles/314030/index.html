<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to stop being afraid and fall in love with syntactic analysis?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As often when programming another business feature, you caught yourself thinking: there are people on Earth who write databases, recognize faces in ph...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to stop being afraid and fall in love with syntactic analysis?</h1><div class="post__text post__text-html js-mediator-article">  As often when programming another business feature, you caught yourself thinking: there are people on Earth who write databases, recognize faces in photos, make frameworks and implement interesting algorithms.  Why in my work it all comes down to shifting from one database table to another, calling http-services, html-form layout and other ‚Äúbusiness noodles‚Äù?  Maybe I'm doing something wrong or working in the wrong company? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9e9/639/ec5/9e9639ec5f9543e48ab8c2aa02ce5854.jpg" width="600"></div><br>  The good news is that interesting challenges surround us everywhere.  Strong desire and courage work wonders on the way to the goal - a task of any scale will be up to you, if you just start doing it. <br><br>  Recently we have written the 1C query language parser and its translator into plain SQL.  This allowed us to fulfill requests to 1C without the participation of 1C :) The minimum working version on regexp-ah turned out for two weeks.  Another month went to a full-fledged parser through grammars, digging out the nuances of the database structure of different 1C objects and implementing specific operators and functions.  As a result, the solution supports almost all language constructs, the source code is uploaded to <a href="https://github.com/gusev-p/simple-1c">GitHub</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Under the cut, we will tell you why we needed it, how we did it, and also touch on some interesting technical details. <br><a name="habracut"></a><br><h1>  How did it all start? </h1><br>  We work in a <a href="http://knopka.com/">large accounting company Button</a> .  We have 1005 clients serviced, 75 accountants and 11 developers work.  Our accountants keep records of thousands of client bases in <nobr>1C: Accounting</nobr> .  To manage databases, we use the cloud technology 1cFresh, the data for it is stored in PostgreSQL. <br><br><img src="https://habrastorage.org/files/bcc/2a4/3be/bcc2a43be9084ea38bad6daf81730686.jpg" width="300" align="right">  The most difficult stage in the work of an accountant is reporting.  It would seem that 1C can prepare any reporting, but for this it needs the current state of the database.  Someone must enter all primary documents into the system, import a bank statement, create and carry out the necessary accounting documents.  At the same time, the deadlines for submitting reports in our beloved state are strictly limited, so accountants usually live from one sleepless time trouble to another. <br><br>  <b>We thought: how can accountants make their lives easier?</b> <br><br>  It turned out that a lot of problems with reporting arise due to minor errors in the accounting database: <br><br><ul><li>  duplicate counterparty or contract; </li><li>  duplicates of primary documents; </li><li>  counterparty without TIN; </li><li>  A document with a date from a distant past or future. </li></ul><br><img src="https://habrastorage.org/files/271/5af/dc5/2715afdc5dd94deea018a2ae52ce03e5.jpg" width="300" align="right">  These problems are easy to find using the 1C query language, so there was an idea to do an automated audit of client databases.  We wrote several requests and began to execute them every night on all 1C bases.  We showed the problems we found to the accountants in a convenient google-tablet, and in every possible way called for the tablet to remain empty. <br><br>  Performing these queries through standard COM api 1C is not the best idea.  First, it takes a long time - to go around a thousand bases and run all requests on each of them takes 10 hours.  Secondly, it significantly loads the server 1C, which usually and so hard lives.  It is unpleasant for the sake of auditing to slow down people's daily work. <br><br>  Meanwhile, a typical 1C query looks like this: <br><br><pre><code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc. <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>, doc. <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>, doc.. <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Inn, doc.. <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CounterpartyInn, (doc..) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> CounterpartyType, doc. <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Description, doc. <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Sum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> . doc <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> doc.. <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> doc. <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> doc. = (..) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (doc.) = (&amp;<span class="hljs-keyword"><span class="hljs-keyword">Now</span></span>)</code> </pre> <br>  Despite the fact that it is very similar to SQL, such a thing will not work just like that and run directly through the database. <br><br><img src="https://habrastorage.org/files/05f/717/7f6/05f7177f623943d09db812d5024926aa.jpg" width="200" align="right">  There are three real reasons for this: <br><br><ol><li>  <b>Magic names of tables and columns in the database.</b>  This is easily solved, since <a href="http://v8.1c.ru/metod/faq2/answer.jsp%3Fid%3D493%26printversion%3D1">1C documents</a> their correspondence to the names from the request. </li><li>  <b>Nested properties.</b>  For example, <code>doc..</code> in SQL corresponds to the <code>left join</code> two plates <code>.</code> <code>doc..</code> to the <code>doc..</code> and <code>.</code> . </li><li>  <b>Specific for 1C operators and functions</b> , such as <code>,   </code> .  They also need to be further translated into the appropriate database design. </li></ol><br>  Realizing all this, we wrote a <a href="https://github.com/gusev-p/simple-1c">utility</a> that converts a query from 1C dialect into ordinary SQL, runs it in parallel on all PostgreSQL physical servers, the result combines and adds to a separate table in MS SQL.  As a result, the data collection time was reduced from 10 hours to 3 minutes. <br><br><h1>  Regular expressions </h1><br>  In the first version, we implemented the query conversion logic entirely through regexps.  In COM api 1C, there is a function GetStructure Database Storage.  It returns information about which tables and fields correspond to objects and properties in 1C request.  Using several regexp templates, we simply replaced some names with others.  This was achieved quite easily, provided that all references to objects and properties had pseudonyms. <br><br>  Most of the trouble delivered nested properties.  1C stores them in related tables, so we had to replace the original name of the object in the <code>from</code> construction with a subquery, which contained all the necessary <code>left join-</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Request example</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> doc.. <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> . doc <span class="hljs-comment"><span class="hljs-comment">--   select doc.gen0 from (select tContractor.inn gen0 from tDoc left join tContractor on tDoc.contractorId = tContractor.id) doc</span></span></code> </pre><br></div></div><br>  In addition to renaming the properties and generating the left <code>join</code> , the translator also applied a number of transformations.  So, for example, all the joines in the original query had to be supplied with an additional condition for the equality of the field <code> (area)</code> .  The fact is that in one PostgreSQL database, we have several 1C client bases, and the data of one client differs from the data of another with a special identifier, which 1C calls a <i>domain</i> .  In base 1C creates a number of indexes by default.  All of them have the first component of the key area, since all requests are executed within a single client.  In order for our queries to use standard indexes, and in order not to think about it when writing them, we began to add this condition automatically when translating the query. <br><br>  <strong>Using regexps turned out to be the right decision</strong> , as it allowed us to quickly get the final result and to understand that something useful is obtained from this whole undertaking.  We all recommend the proof of concepts and experiments to do just that - as simple as possible means at hand.  And what could be simpler and more effective when working with texts than regexp? <br><br>  Of course, there are drawbacks.  The first and obvious is the cut corners and syntax restrictions.  Regexps for properties and tables required the arrangement of pseudonyms in the query and, in general, could accidentally get stuck with some other construct, for example, a constant string. <br><br>  Another problem is mixing the logic of parsing text and converting it according to the necessary rules.  Each time, implementing a new feature, it was necessary to invent a new hellish mixture of regexp-s with <code>IndexOf</code> calls on the rows, which would subtract the corresponding elements in the original query. <br><br>  So, for example, looked like a code that added a condition on the equality of domains to all joines: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PatchJoin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> joinText, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> joinPosition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">alias</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromPosition = queryText.LastIndexOf(<span class="hljs-string"><span class="hljs-string">"from"</span></span>, joinPosition, StringComparison.OrdinalIgnoreCase); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fromPosition &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"assertion failure"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tableMatch = tableNameRegex.Match(queryText, fromPosition); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tableMatch.Success) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"assertion failure"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mainTableAlias = tableMatch.Groups[<span class="hljs-number"><span class="hljs-number">3</span></span>].Value; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> mainTableEntity = GetQueryEntity(mainTableAlias); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> joinTableEntity = GetQueryEntity(<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> condition = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"{0}.{1} = {2}.{3} and "</span></span>, mainTableAlias, mainTableEntity.GetAreaColumnName(), <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span>, joinTableEntity.GetAreaColumnName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> joinText + condition; }</code> </pre><br>  In the code, I wanted to deal with the object model of the original request, with the <code>ColumnReference</code> and <code>JoinClause</code> , and instead there were only the substrings found and the <code>JoinClause</code> in the query text. <br><br>  Agree that this option looks much simpler and clearer than the previous one: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PatchJoin</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SelectClause selectClause, JoinClause joinClause</span></span></span><span class="hljs-function">)</span></span> { joinClause.Condition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AndExpression { Left = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EqualityExpression { Left = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColumnReferenceExpression { Name = PropertyNames.area, Table = selectClause.Source }, Right = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColumnReferenceExpression { Name = PropertyNames.area, Table = joinClause.Source } }, Right = joinClause.Condition }; }</code> </pre><br>  Such an object model is called <strong>Abstract syntax tree</strong> ( <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a> ). <br><br><h1>  AST </h1><br>  Interestingly, for the first time, AST did not appear when parsing the original request, but, on the contrary, when formatting the result in SQL.  The fact is that the logic of constructing a subquery for nested properties became quite florid, and to simplify it (and in accordance with <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a> ) we broke the whole process into two steps: first create a tree of objects describing the subquery, then separately serialize it into SQL.  At some point, we realized that this is AST, and to solve problems with regexp, you just need to learn how to create it for the original request. <br><br>  The term <abbr title="Abstract syntax tree">AST is</abbr> widely used when discussing the nuances of parsing.  It is called a <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">tree</a> because this data structure describes well the typical for programming languages ‚Äã‚Äãconstructs, usually with the property of recursiveness and absence of cycles (although this is <a href="http://cs.stackexchange.com/questions/13126/does-an-abstract-syntax-tree-have-to-be-a-tree">not always true</a> ). <br><br>  For example, consider the following query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p.surname <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-string"><span class="hljs-string">'person surname'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> persons p <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.name = <span class="hljs-string"><span class="hljs-string">''</span></span></code> </pre><br>  In the form of AST, it looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e7a/be5/220/e7abe52202c94b23bd9ff36c6e2414ba.jpg" width="600"></div><br>  <i>In the figure, nodes ‚Äî instances of classes, arrows, and captions ‚Äî are properties of these classes.</i> <br><br>  Such an object model can be assembled through code as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TableDeclarationClause { Name = <span class="hljs-string"><span class="hljs-string">"PersonsTable"</span></span>, Alias = <span class="hljs-string"><span class="hljs-string">"t"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> selectClause = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectClause { FromExpression = table, WhereExpression = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EqualityExpression { Left = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColumnReferenceExpression { Table = table, Name = <span class="hljs-string"><span class="hljs-string">"name"</span></span> }, Right = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LiteralExpression { Value = <span class="hljs-string"><span class="hljs-string">""</span></span> } } }; selectClause.Fields.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SelectFieldExpression { Expression = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ColumnReferenceExpression { Table = table, Name = <span class="hljs-string"><span class="hljs-string">"surname"</span></span> } });</code> </pre><br>  It is worth noting that the above example AST is not the only correct one.  The specific structure of classes and the connections between them are determined by the specifics of the task.  <b>The main goal of any AST</b> is to facilitate the solution of the problem, to make performing typical operations as convenient as possible.  Therefore, the easier and more natural it is to describe the constructions of the desired language, the better. <br><br>  The transition from regexp to AST allowed us to get rid of many hacks, to make the code cleaner and clearer.  At the same time, our utility now had to be aware of all the constructs of the source language in order to create for them the corresponding node in the tree.  For this, I had to write the grammar of the query language 1C and a parser for it. <br><br><h1>  Grammar </h1><br>  So, at some point it became clear that we need the AST of the original request.  There are many libraries on the Internet that can parse SQL and create an AST for it, but if you take a closer look, they either turn out to be <a href="http://www.sqlparser.com/">paid</a> , or they only support a subset of SQL.  Besides, it is not clear how to adapt them for recognizing the 1C-dialect of SQL, because it contains a number of specific extensions. <br><br>  Therefore, we decided to write our own parser.  Syntax analyzers usually begin to do with the description of the grammar of the language that you want to recognize.  <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">Formal grammar</a> is a classic tool for describing the structure of programming languages.  Its basis is formed by the rules of inference, that is, the recursive definitions of each language construct. <br><br>  For example, such rules can describe the language of arithmetic expressions: <br><br><pre> <b><code class="cs hljs">E ‚Üí number | (E) | E + E | E - E | E * E | E / E</code></b> </pre> <br>  This record can be read as follows: <br><br><ul><li>  any number <code>(number)</code> is an expression <code>(E)</code> ; </li><li>  if the expression is enclosed in brackets, then all this, together with the brackets, is also an expression; </li><li>  two expressions joined by an arithmetic operation also constitute an expression. </li></ul><br>  The characters for which output rules are defined are called <i>non terminals</i> .  Symbols for which rules are not defined and which are language elements - <i>terminals</i> .  Applying the rules, you can get strings from non-terminals, consisting of other non-terminals and terminals, until only the terminals remain.  In the example above, <code>E</code> is a non-terminal, and the symbols <code>+, -, *, /</code> and <code>number</code> are the terminals that make up the language of arithmetic expressions. <br><br>  There are special tools - syntax analyzer generators, which, according to the description of a language specified in the form of a grammar, are able to generate code recognizing this language.  The most famous of them are <a href="https://ru.wikipedia.org/wiki/Yacc">yacc</a> , <a href="https://ru.wikipedia.org/wiki/GNU_Bison">bison</a> and <a href="http://www.antlr.org/">antlr</a> .  For C #, there is a less common <a href="http://irony.codeplex.com/">Irony</a> library.  About her there was already a small <a href="https://habrahabr.ru/sandbox/19813/">article on Habr√©</a> , but <a href="http://www.hanselman.com/blog/TheWeeklySourceCode59AnOpenSourceTreasureIronyNETLanguageImplementationKit.aspx">Scott Hanselman</a> ‚Äôs <a href="http://www.hanselman.com/blog/TheWeeklySourceCode59AnOpenSourceTreasureIronyNETLanguageImplementationKit.aspx">post</a> about her. <br><br>  The main feature of the <b>Irony</b> library is that grammar rules can be described directly in <code>C#</code> using operator overloading.  The result is quite a nice <a href="http://martinfowler.com/bliki/InternalDslStyle.html">DSL</a> , the form is very similar to the classical form of writing rules: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NonTerminal(<span class="hljs-string"><span class="hljs-string">"expression"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> number = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NumberLiteral(<span class="hljs-string"><span class="hljs-string">"number"</span></span>); e.Rule = e + <span class="hljs-string"><span class="hljs-string">"+"</span></span> + e | e + <span class="hljs-string"><span class="hljs-string">"-"</span></span> + e | e + <span class="hljs-string"><span class="hljs-string">"*"</span></span> + e | e + <span class="hljs-string"><span class="hljs-string">"/"</span></span> + e | <span class="hljs-string"><span class="hljs-string">"("</span></span> + e + <span class="hljs-string"><span class="hljs-string">")"</span></span> | number;</code> </pre><br>  Symbol <b>|</b>  means that any of the variants of the rule can be applied (logical or). The symbol <b>+</b> is a concatenation, the characters must follow each other. <br><br>  Irony separates <i>Parse Tree</i> and <i>Abstract Syntax Tree</i> .  <b>Parse Tree</b> is an artifact of the text recognition process, the result of consistent application of grammar rules.  In its internal nodes are non terminals, and descendants get characters from the right parts of the relevant rules. <br><br>  For example, the expression <code>1+(2+3)</code> when applying the rules: <br><blockquote>  <b>e <sub>1</sub> :</b> E ‚Üí E + E <br>  <b>e <sub>2</sub> :</b> E ‚Üí (E) <br>  <b>e <sub>3</sub> :</b> E ‚Üí number </blockquote><br>  corresponds to the Parse Tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d5c/bbb/3e4/d5cbbb3e4723432c979330bdf4d95628.jpg" width="600"></div><br><br>  Parse Tree does not depend on a specific language and in Irony is described by a single <code>ParseTreeNode</code> class. <br><br>  <b>Abstract Syntax Tree, on the</b> contrary, is entirely determined by a specific task, and consists of classes specific to this task and the connections between them. <br><br>  For example, the AST for grammar above can consist of just one <code>BinaryOperator</code> class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OperatorType { Plus, Minus, Mul, Div } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BinaryOperator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Left { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> Right { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OperatorType Type { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  <code>Left</code> and <code>Right</code> properties are of type <code>object</code> , since  they can refer either to a number or to another <code>BinaryOperator</code> : <br><div style="text-align:center;"><img src="https://habrastorage.org/files/86e/7a3/434/86e7a34347fa423783ff0c898940eece.jpg" width="600"></div><br><br>  Irony allows you to create an AST sequentially, rising from the leaves to the root, while applying the rules of grammar.  To do this, you can <code>AstNodeCreator</code> delegate to each non- <code>AstNodeCreator</code> , which Irony will call at the time of applying any of the rules associated with this non-terminal.  This delegate should, on the basis of the passed <code>ParseTreeNode</code> create the corresponding AST node and put the link to it back in <code>ParseTreeNode</code> .  By the time the delegate was called, all the Parse Tree child nodes were already processed and <code>AstNodeCreator</code> for them was already called, so we can use the already filled property <code>AstNode</code> child nodes in the delegate body. <br><br>  When we thus reach the root nonterminal, the AST root node is formed in its <code>AstNode</code> , in our case the <code>SqlQuery</code> . <br><br>  For the grammar of arithmetic expressions above, AstNodeCreator might look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NonTerminal(<span class="hljs-string"><span class="hljs-string">"expression"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span>(AstContext context, ParseTreeNode node) { <span class="hljs-comment"><span class="hljs-comment">//  E ‚Üí number, if (node.ChildNodes.Count == 1) { node.AstNode = node.ChildNodes[0].Token.Value; return; } //  E ‚Üí E op E if (node.ChildNodes[0].AstNode != null &amp;&amp; node.ChildNodes[2].AstNode != null) { node.AstNode = new BinaryOperator { Left = node.ChildNodes[0].AstNode, Operator = node.ChildNodes[1].FindTokenAndGetText(), Right = node.ChildNodes[2].AstNode }; return; } //   node.AstNode = node.ChildNodes[1].AstNode; });</span></span></code> </pre><br>  So, with the help of Irony, we learned how to construct an AST on an initial request.  Only one big question remains - how to effectively structure the code for AST conversion, because ultimately we need to get an AST of the resulting SQL query from the source AST.  The Visitor pattern will help us in this. <br><br><h1>  Visitor </h1><br>  The <strong><a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2581%25D0%25B5%25D1%2582%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Visitor</a></strong> (or <a href="https://en.wikipedia.org/wiki/Double_dispatch">double dispatch</a> ) pattern is one of the most complex in <a href="https://ru.wikipedia.org/wiki/Design_Patterns">GoF</a> and, therefore, one of the most rarely used.  For our experience, we have seen only one active application of it - to convert various AST.  A specific example is the <a href="https://msdn.microsoft.com/ru-ru/library/system.linq.expressions.expressionvisitor(v%3Dvs.110).aspx">ExpressionVisitor</a> class in .NET, which <a href="">inevitably occurs</a> when you make a <a href="https://msdn.microsoft.com/en-us/library/bb546158.aspx">linq provider</a> or just want to tweak a little with the compiler-generated <a href="https://msdn.microsoft.com/ru-ru/library/mt654263.aspx">expression tree</a> . <br><br>  <strong>What problem is solved by visitor?</strong> <br>  The most natural and necessary thing that you often have to do when working with AST is to turn it into a string.  Take for example our AST: after replacing Russian table names with English ones, generating <code>left join-</code> and converting 1C-operators into database operators, we need to get a string at the output, which we can send for execution in PostgreSQL. <br><br>  A possible solution to this problem is as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SelectClause</span></span> : <span class="hljs-title"><span class="hljs-title">ISqlElement</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... public void BuildSql(StringBuilder target) { target.Append("select "); for (var i = 0; i &lt; Fields.Count; i++) { if (i != 0) target.Append(","); Fields[i].BuildSql(target); } target.Append("\r\nfrom "); From.BuildSql(target); foreach (var c in JoinClauses) { target.Append("\r\n"); c.BuildSql(target); } } }</span></span></code> </pre><br>  About this code, you can make two important observations: <br><br><ul><li>  all tree nodes must have a <code>BuildSql</code> method for recursion to work; </li><li>  The <code>BuildSql</code> method on <code>SelectClause</code> calls <code>BuildSql</code> on all child nodes. </li></ul><br>  Now consider another task.  Suppose we need to add a condition for the equality of the <code>area</code> field between the main table and all the others to get into the PostgreSQL indexes.  To do this, we need to run through all the <code>JoinClause</code> in the query, but, given the possible subqueries, we need to remember to look at all the other nodes. <br><br>  This means that if you follow the same code structure as above, we will need to: <br><br><ul><li>  add the <code>AddAreaToJoinClause</code> method to all tree nodes; </li><li>  its implementations on all nodes except <code>JoinClause</code> will have to forward a call to their descendants. </li></ul><br>  The problem with this approach is clear - the more we have different logical operations on the tree, the more there will be methods in the nodes, and the more copy-paste between these methods. <br><br>  <b>Visitors solve this problem</b> by: <br><br><ul><li>  Logical operations cease to be methods on nodes, and become separate objects ‚Äî heirs of the abstract class <code>SqlVisitor</code> (see figure below). </li><li>  Each node type has a separate <code>Visit</code> method in the base <code>SqlVisitor-</code> , for example, <code>VisitSelectClause(SelectClause clause)</code> or <code>VisitJoinClause(JoinClause clause)</code> . </li><li>  The <code>BuildSql</code> and <code>AddAreaToJoinClause</code> are replaced with one common <code>Accept</code> method. </li><li>  Each node implements it by forwarding to the corresponding method on <code>SqlVisitor-</code> , which comes as a parameter. </li><li>  Specific operations are inherited from <code>SqlVisitor</code> and override only those methods that interest them. </li><li>  Implementations of the <code>Visit</code> methods in the base <code>SqlVisitor-</code> simply call the <code>Visit</code> for all child nodes, thereby eliminating duplication of code. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/files/47a/ef1/2ce/47aef12cebc3466a8b70b1658808d5ce.jpg" width="600"></div><br>  An example with serialization in SQL is adapted as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISqlElement</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Accept</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SqlVisitor visitor</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SqlVisitor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Visit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISqlElement sqlElement</span></span></span><span class="hljs-function">)</span></span> { sqlElement.Accept(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VisitSelectClause</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SelectClause selectClause</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-comment"><span class="hljs-comment">//... } internal class SqlFormatter : SqlVisitor { private readonly StringBuilder target = new StringBuilder(); public override void VisitSelectClause(SelectClause selectClause) { target.Append("select "); for (var i = 0; i &lt; selectClause.Fields.Count; i++) { if (i != 0) target.Append(","); Visit(selectClause.Fields[i]); } target.Append("\r\nfrom "); Visit(selectClause.Source); foreach (var c in selectClause.JoinClauses) { target.Append("\r\n"); Visit(c); } } } internal class SelectClause : ISqlElement { //... public void Accept(SqlVisitor visitor) { visitor.VisitSelectClause(this); } }</span></span></code> </pre><br>  The name <b>double dispatch</b> quite accurately describes this scheme: <br><br><ul><li>  The first dispatch occurs in the <code>SqlVisitor</code> class when moving from <code>Visit</code> to <code>Accept</code> on a specific node, at which point the type of the node becomes known. </li><li>  The second dispatch follows the first one when moving from <code>Accept</code> on a node to a specific method on <code>SqlVisitor</code> , here the operation that needs to be applied to the selected node becomes known. </li></ul><br><h1>  Total </h1><br>  The article describes in detail the recipe for making the translator of the 1C query language into SQL queries.  We went through experiments with regular expressions, having received a working prototype and confirmation that the piece is useful and should move on.  And when it became impossible to look at the code without shame and pain, and juggling with regexp did not lead to the desired result, we took a serious step - we switched to AST and grammars.  Then, using visitor, we learned how to transform AST, thereby realizing the logic of translation from one language to another. <br><br>  It is worth noting that this path we did not go alone, and did not even have to open the <a href="https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811">Dragon Book</a> .  For parsing and building AST, we used the ready-made library of Irony, which made it possible not to reinvent the wheel, but to go straight to solving an applied problem. <br><br>  The bottom line for the company is to reduce the speed of receiving data from 10 hours to 3 minutes.  This allowed our analysts to quickly set up experiments and test hypotheses about the clients' business and the work of accountants.  This is especially convenient, since we have a lot of clients, and their bases are distributed among the five physical PostgreSQL servers. <br><br>  <b>Summarizing all the above:</b> <br><br><ol><li>  Set experiments and get proof of concept as quickly and cheaply as possible. </li><li>  Set ambitious goals, and move towards them in small steps, gradually honing the instrument to the desired state. </li><li>  For most tasks, there is already a ready-made solution, or at least a foundation. </li><li>  Parsing and grammar are applicable in normal business applications. </li><li>  Solve a specific problem, and the general solution will come by itself. </li></ol><br>  Library code and usage examples <a href="https://github.com/gusev-p/simple-1c">are waiting for you on GitHub</a> . <br><br>  At leisure, we advise you to read: <br><br><ul><li>  <a href="https://medium.com/krol-institute/99-99-%25D0%25B7%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587-%25D0%25BD%25D0%25B5-%25D0%25B8%25D0%25BC%25D0%25B5%25D1%258E%25D1%2582-%25D1%2580%25D0%25B5%25D1%2588%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F-%25D0%25BF%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BC%25D1%2583-%25D1%2587%25D1%2582%25D0%25BE-%25D0%25BB%25D1%258E%25D0%25B4%25D0%25B8-%25D0%25BD%25D0%25B5-%25D0%25B2%25D0%25B5%25D1%2580%25D1%258F%25D1%2582-%25D0%25B2-%25D1%258D%25D1%2582%25D0%25BE-4d27266d896c">99.99% of problems have no solution because people do not believe in it.</a> </li><li>  <a href="http://www.joelonsoftware.com/items/2006/09/01b.html">Why did the Joel Spolsky team write their own compiler?</a> </li><li>  <a href="http://www.hanselman.com/blog/TheWeeklySourceCode59AnOpenSourceTreasureIronyNETLanguageImplementationKit.aspx">Scott Hanselman's Post on the Irony Library</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/314030/">https://habr.com/ru/post/314030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314020/index.html">We work with a budget institution. Part 4</a></li>
<li><a href="../314022/index.html">How to make virtual infrastructure more accessible</a></li>
<li><a href="../314024/index.html">Huawei Hosting Platform</a></li>
<li><a href="../314026/index.html">Print support promised a year ago appeared in ReactOS</a></li>
<li><a href="../314028/index.html">Studying Retrofit 2</a></li>
<li><a href="../314032/index.html">Setting up the environment for PHP developers</a></li>
<li><a href="../314034/index.html">We are creating a news site using Flexbox</a></li>
<li><a href="../314038/index.html">How to turn a smartphone into a microphone (ideas and questions)</a></li>
<li><a href="../314040/index.html">How to find a vector of software development? Planning as a science</a></li>
<li><a href="../314042/index.html">Time is money, or arguments for and against hourly pay.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>