<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>12 Fractured Apps and Docker</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Over the years I have witnessed how more and more people are supporting the manifesto of the 12 Factor App and are starting to implement the provision...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>12 Fractured Apps and Docker</h1><div class="post__text post__text-html js-mediator-article"> Over the years I have witnessed how more and more people are supporting the manifesto of the <a href="http://12factor.net/">12 Factor App</a> and are starting to implement the provisions described there.  This has led to the emergence of applications that have been greatly simplified in deployment and management.  However, examples of practical application of these 12 factors were quite rare in the vast Internet. <br><img src="https://habrastorage.org/files/2ef/54b/465/2ef54b46579d4ab48e75df59e1456889.png"><br><br>  While working with Docker, the benefits of the 12 Factor App (12FA) have become more tangible for me.  For example, 12FA recommends that logging be configured for standard output and processed as a general event flow.  Have you ever used the <code>docker logs</code> ?  This is the 12FA in action! <a name="habracut"></a><br><br>  12FA also recommends using environment variables to configure the application.  Docker does this trivially, providing the ability to set environment variables programmatically when creating containers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <blockquote>  The Docker and 12 Factor App is a killer combination that provides a quick overview of the design and deployment of future applications. </blockquote><br>  Docker also partly simplifies the movement of legacy applications into a container.  I say ‚Äúpartly‚Äù, because ultimately you have to slightly edit Docker containers, with the result that 2 GB images of containers are created on top of a full-fledged Linux distribution. <br><br>  Unfortunately, legacy applications that you may be working with right now have many flaws, especially around the startup process.  Applications, even modern ones, have too many dependencies and because of this they cannot provide a clean launch.  Applications that require access to an external database usually initiate a connection to the database during startup.  However, if this database was unavailable, or temporarily unavailable, then many of the applications simply will not start.  If you are lucky, you can get an error message with details that will help you in troubleshooting. <br><br><blockquote>  Many applications that are packaged in Docker have some minor flaws.  This is more like microcracks - applications continue to work, but can cause hellish torment when working with them. </blockquote><br>  This behavior of applications forces to resort to complex deployment processes and contributes to the development of tools such as Puppet or Ansible.  Configuration management tools help solve various problems, for example, the inaccessibility of the database.  They run the database on which this application depends before starting the application itself.  Most likely it looks like sticking adhesive tape on a lacerated wound.  The application should simply repeat the connection to the database, using a sort of classification for the returned errors and of course error logging.  In this case, there will be two options: either you can return the database online, or your company will simply go bankrupt. <br><br>  Another problem for applications moved to Docker is in the configuration files.  Many applications, even modern ones, still rely on configuration files located locally on disks.  The most commonly used solution is to deploy additional new containers that link configuration files to a container image. <br><br><h4>  Do not do this. </h4><br>  If you choose this solution, you will end up with an infinite number of container images, named something like this: <br><br><ul><li>  application-v2 ‚Äì prod-01022015 </li><li>  application-v2-dev-02272015 </li></ul><br>  Soon you will need to look for tools to manage so many images. <br><br>  Moving to Docker gave people the mistaken belief that they no longer need configuration management in any way.  I tend to agree with this, there is no need to use Puppet, Chef or Ansible when creating images, but there is still a need to manage configuration settings during operation. <br><br>  Similar logic is used to end the frequent use of configuration management systems in order to avoid <abbr title="Initialization system in UNIX and Unix-like systems">init</abbr> systems in favor of the <code>docker run</code> . <br><br>  To compensate for the lack of configuration management tools and robust init systems, Docker users are turning to shell scripts to disguise the flaws of the application around the bootstrap and the startup process. <br><br><blockquote>  As soon as you transfer everything to Docker and refuse to use tools that do not have the Docker logo, you will put yourself in an impossible position. </blockquote><br><h4>  application </h4><br>  We now turn to the sample application to demonstrate some common tasks when starting a typical application.  The example performs the following tasks during startup: <br><br><ul><li>  Loads configuration parameters from JSON encoded config.  file </li><li>  Gives access to the working directory </li><li>  Connects to an external MySQL database. </li></ul><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/go-sql-driver/mysql"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( config Config db *sql.DB ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DataDir <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`json:"datadir"`</span></span> <span class="hljs-comment"><span class="hljs-comment">// Database settings. Host string `json:"host"` Port string `json:"port"` Username string `json:"username"` Password string `json:"password"` Database string `json:"database"` } func main() { log.Println("Starting application...") // Load configuration settings. data, err := ioutil.ReadFile("/etc/config.json") if err != nil { log.Fatal(err) } if err := json.Unmarshal(data, &amp;config); err != nil { log.Fatal(err) } // Use working directory. _, err = os.Stat(config.DataDir) if err != nil { log.Fatal(err) } // Connect to database. hostPort := net.JoinHostPort(config.Host, config.Port) dsn := fmt.Sprintf("%s:%s@tcp(%s)/%s?timeout=30s", config.Username, config.Password, hostPort, config.Database) db, err = sql.Open("mysql", dsn) if err != nil { log.Fatal(err) } if err := db.Ping(); err != nil { log.Fatal(err) } }</span></span></code> </pre><br><h6>  The full source code is available on <a href="https://github.com/kelseyhightower/12-fractured-apps">GitHub</a> . </h6><br>  As you can see, there is nothing special here, but if you look closely, you can see that this application will automatically load only under certain conditions.  If the configuration file or working directory is missing, or the database is not available during startup, the above application will not start. <br><br>  Let's deploy the sample application through Docker and explore it. <br><br>  Create an application using the <code>docker build</code> : <br><br><pre> <code class="go hljs">$ GOOS=linux <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build -o app</code> </pre><br>  Now, create a container from the app: v1 Docker image using the <code>docker run</code> : <br><br><pre> <code class="go hljs">FROM scratch MAINTAINER Kelsey Hightower &lt;kelsey.hightower@gmail.com&gt; COPY app /app ENTRYPOINT [<span class="hljs-string"><span class="hljs-string">"/app"</span></span>]</code> </pre><br>  All I'm doing here is copying the binary of the application to the right place.  This container image will use the base image script, resulting in a minimal container Docker image suitable for deploying our application. <br><br>  Create an image using the <code>docker build</code> : <br><br><pre> <code class="go hljs">$ docker build -t app:v1 .</code> </pre><br>  Finally, create a container from the app: v1 image using the <code>docker run</code> : <br><br><pre> <code class="go hljs">$ docker run --rm app:v1 <span class="hljs-number"><span class="hljs-number">2015</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>/<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">34</span></span> Starting application... <span class="hljs-number"><span class="hljs-number">2015</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>/<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">34</span></span> open /etc/config.json: no such file or directory</code> </pre><br>  Let the pain begin!  Right, almost at the start, I ran into the first startup problem.  Please note that the application does not start due to the missing <code>/etc/config.json</code> configuration file.  I can fix this by mounting the configuration file at runtime: <br><br><pre> <code class="go hljs">$ docker run --rm \ -v /etc/config.json:/etc/config.json \ app:v1 <span class="hljs-number"><span class="hljs-number">2015</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>/<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span>:<span class="hljs-number"><span class="hljs-number">36</span></span>:<span class="hljs-number"><span class="hljs-number">27</span></span> Starting application... <span class="hljs-number"><span class="hljs-number">2015</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>/<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span>:<span class="hljs-number"><span class="hljs-number">36</span></span>:<span class="hljs-number"><span class="hljs-number">27</span></span> stat /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/data: no such file or directory</code> </pre><br>  Another mistake!  This time, the application fails to start because the <code>/var/lib/data</code> directory does not exist.  I can easily bypass the missing directory by mounting another host directory in the container: <br><br><pre> <code class="go hljs">$ docker run --rm \ -v /etc/config.json:/etc/config.json \ -v /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/data:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/data \ app:v1 <span class="hljs-number"><span class="hljs-number">2015</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>/<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span>:<span class="hljs-number"><span class="hljs-number">44</span></span>:<span class="hljs-number"><span class="hljs-number">18</span></span> Starting application... <span class="hljs-number"><span class="hljs-number">2015</span></span>/<span class="hljs-number"><span class="hljs-number">12</span></span>/<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span>:<span class="hljs-number"><span class="hljs-number">44</span></span>:<span class="hljs-number"><span class="hljs-number">48</span></span> dial tcp <span class="hljs-number"><span class="hljs-number">203.0</span></span><span class="hljs-number"><span class="hljs-number">.113</span></span><span class="hljs-number"><span class="hljs-number">.10</span></span>:<span class="hljs-number"><span class="hljs-number">3306</span></span>: i/o timeout</code> </pre><br>  We are making progress, but I forgot to set up database access for this instance. <br><br>  This is the point where some people start using configuration management tools to ensure that all these dependencies are started before the application starts.  Although this works, it is still to some extent overkill and often the wrong approach to solving application-level problems. <br><br><blockquote>  I hear silent screams from hipsters ‚Äúsys-admins‚Äù, impatiently waiting to suggest using the Docker user entry point to solve our bootstrap problems. </blockquote><br><br><h4>  User entry point to the rescue. </h4><br>  One way to solve our startup problems is to create a shell script and use it as a Docker entry point, instead of the actual application.  Here is a short list of things we can do using a shell script as an entry point: <br><br><ul><li>  Generate the required / etc / config.json configuration file </li><li>  create the required / var / lib / data directory </li><li>  test the database connection while it is available </li></ul><br><br>  The following shell script deals with the first two elements, adding the ability to use environment variables along with the <code>/etc/config.json</code> configuration file and creating the missing <code>/var/lib/data</code> directory during the startup process.  The script executes the sample application as the final stage, retaining the original behavior when the application is started by default. <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/sh set -e datadir=${APP_DATADIR:="/var/lib/data"} host=${APP_HOST:="127.0.0.1"} port=${APP_PORT:="3306"} username=${APP_USERNAME:=""} password=${APP_PASSWORD:=""} database=${APP_DATABASE:=""} cat &lt;&lt;EOF &gt; /etc/config.json { "datadir": "${datadir}", "host": "${host}", "port": "${port}", "username": "${username}", "password": "${password}", "database": "${database}" } EOF mkdir -p ${APP_DATADIR} exec "/app"</span></span></code> </pre><br>  Now the image can be restored using the following Docker file: <br><br><pre> <code class="sql hljs">FROM alpine:3.1 MAINTAINER Kelsey Hightower &lt;kelsey.hightower@gmail.com&gt; COPY app /app COPY docker-entrypoint.sh /entrypoint.sh ENTRYPOINT ["/entrypoint.sh"]</code> </pre><br><blockquote>  Notice that the custom shell script is copied to the Docker image and used as an entry point instead of the application's binary file. </blockquote><br>  Create an app: v2 image using the docker build command: <br><br><pre> <code class="sql hljs">$ docker build -t app:v2 .</code> </pre><br>  Now perform the next step: <br><br><pre> <code class="sql hljs">$ docker run <span class="hljs-comment"><span class="hljs-comment">--rm \ -e "APP_DATADIR=/var/lib/data" \ -e "APP_HOST=203.0.113.10" \ -e "APP_PORT=3306" \ -e "APP_USERNAME=user" \ -e "APP_PASSWORD=password" \ -e "APP_DATABASE=test" \ app:v2 2015/12/13 04:44:29 Starting application...</span></span></code> </pre><br>  User entry point is working.  Using only environment variables, we are able to configure and run our application. <br><br><h5>  But why do we do it? </h5><br>  Why do we have to use such a complex wrapper script?  Some will say that it is much easier to write this functionality in a shell than to implement it in an application.  But it's not just about managing shell scripts.  Notice another difference between v1 and v2 files? <br><br><pre> <code class="sql hljs">FROM alpine:3.1</code> </pre><br>  The v2 file uses alpine - the base image to provide a scripting environment, but it doubles the size of our Docker image: <br><br><pre> <code class="sql hljs">$ docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE app v2 1b47f1fbc7dd 2 hours ago 10.99 MB app v1 42273e8664d5 2 hours ago 5.952 MB</code> </pre><br>  Another disadvantage of this approach is the inability to use the configuration file with the image.  We can continue to write the script and add support for the configuration file and the environment variable, but all this will simply lose its functionality when the wrapper script is out of sync with the application.  But there is another way to solve this problem. <br><br><h4>  Programming will save all. </h4><br>  Yes, good old programming.  Each of the shell script tasks of the Docker entry point can be processed directly by the application. <br><br>  Don't get me wrong, using the entry point script is good for applications that you do not control.  But, when you rely on entry point scripts for applications, you add another level of complexity to the application deployment process without any reason. <br><br><h4>  Configuration files must be optional </h4><br>  I think that there is absolutely no reason to use configuration files from the end of the 90s.  I suggest loading the configuration file if it exists and rolls back to the default settings.  The following code fragment does just that. <br><br><pre> <code class="sql hljs">// <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> configuration settings. <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, err := ioutil.ReadFile(<span class="hljs-string"><span class="hljs-string">"/etc/config.json"</span></span>) // Fallback <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> values. <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> os.IsNotExist(err): log.Println(<span class="hljs-string"><span class="hljs-string">"Config file missing using defaults"</span></span>) config = Config{ DataDir: <span class="hljs-string"><span class="hljs-string">"/var/lib/data"</span></span>, Host: <span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>, Port: <span class="hljs-string"><span class="hljs-string">"3306"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Database</span></span>: <span class="hljs-string"><span class="hljs-string">"test"</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> err == nil: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := json.Unmarshal(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>, &amp;config); err != nil { log.Fatal(err) } default: log.Println(err) }</code> </pre><br><h5>  Use environment variable for configuration. </h5><br>  This is one of the simplest things you can do directly in your application.  The following code snippet uses environment variables to override configuration settings. <br><br><pre> <code class="sql hljs">log.Println("Overriding configuration from env vars.") if os.Getenv("APP_DATADIR") != "" { config.DataDir = os.Getenv("APP_DATADIR") } if os.Getenv("APP_HOST") != "" { config.Host = os.Getenv("APP_HOST") } if os.Getenv("APP_PORT") != "" { config.Port = os.Getenv("APP_PORT") } if os.Getenv("APP_USERNAME") != "" { config.Username = os.Getenv("APP_USERNAME") } if os.Getenv("APP_PASSWORD") != "" { config.Password = os.Getenv("APP_PASSWORD") } if os.Getenv("APP_DATABASE") != "" { config.Database = os.Getenv("APP_DATABASE") }</code> </pre><br><h5>  Manage the working directory of the application. </h5><br>  Instead of shifting responsibility for work and connectivity with directories to external tools or to script entry points, your application should manage them directly.  If for some reason something does not work, do not forget to set up error logging with details: <br><br><pre> <code class="sql hljs">// <span class="hljs-keyword"><span class="hljs-keyword">Use</span></span> working directory. _, err = os.Stat(config.DataDir) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.IsNotExist(err) { log.Println(<span class="hljs-string"><span class="hljs-string">"Creating missing data directory"</span></span>, config.DataDir) err = os.MkdirAll(config.DataDir, <span class="hljs-number"><span class="hljs-number">0755</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { log.Fatal(err) }</code> </pre><br><h5>  Eliminate the need to start services in a specific order. </h5><br>  Remove the deployment requirement for your application in a specific order.  I have seen that in many deployment guides for various applications there is an instruction to launch the application after the database is started, otherwise it will result in a zero result. <br><br>  You can get rid of this requirement like this: <br><br><pre> <code class="sql hljs">$ docker run <span class="hljs-comment"><span class="hljs-comment">--rm \ -e "APP_DATADIR=/var/lib/data" \ -e "APP_HOST=203.0.113.10" \ -e "APP_PORT=3306" \ -e "APP_USERNAME=user" \ -e "APP_PASSWORD=password" \ -e "APP_DATABASE=test" \ app:v3 2015/12/13 05:36:10 Starting application... 2015/12/13 05:36:10 Config file missing using defaults 2015/12/13 05:36:10 Overriding configuration from env vars. 2015/12/13 05:36:10 Creating missing data directory /var/lib/data 2015/12/13 05:36:10 Connecting to database at 203.0.113.10:3306 2015/12/13 05:36:40 dial tcp 203.0.113.10:3306: i/o timeout 2015/12/13 05:37:11 dial tcp 203.0.113.10:3306: i/o timeout</span></span></code> </pre><br><blockquote>  Notice in the above output I am not able to connect to a working target database located at 203.0.113.10 .. </blockquote><br>  Run the following command to grant access to the MySQL database: <br><br><pre> <code class="sql hljs">$ gcloud sql instances patch mysql \ <span class="hljs-comment"><span class="hljs-comment">--authorized-networks "203.0.113.20/32"</span></span></code> </pre><br>  The application is able to connect to the database and complete the startup process. <br><br><pre> <code class="sql hljs">2015/12/13 05:37:43 dial tcp 203.0.113.10:3306: i/o timeout 2015/12/13 05:37:46 Application started successfully.</code> </pre><br>  The code to execute looks like this: <br><br><pre> <code class="sql hljs">// Connect to database. hostPort := net.JoinHostPort(config.Host, config.Port) log.Println("Connecting to database at", hostPort) dsn := fmt.Sprintf("%s:%s@tcp(%s)/%s?timeout=30s", config.Username, config.Password, hostPort, config.Database) db, err = sql.Open("mysql", dsn) if err != nil { log.Println(err) } var dbError error maxAttempts := 20 for attempts := 1; attempts &lt;= maxAttempts; attempts++ { dbError = db.Ping() if dbError == nil { break } log.Println(dbError) time.Sleep(time.Duration(attempts) * time.Second) } if dbError != nil { log.Fatal(dbError) }</code> </pre><br>  There is nothing special here.  I simply repeat the connection to the database and increase the time between each attempt. <br><br>  Great, we got a startup process with a friendly message in the log that the application started correctly. <br><br><pre> <code class="sql hljs">log.Println("Application started successfully.")</code> </pre><br>  Believe me, your system administrator will thank you. <br><br>  You can <a href="https://medium.com/%40kelseyhightower/12-fractured-apps-1080c73d481c">find the</a> link to the original source <a href="https://medium.com/%40kelseyhightower/12-fractured-apps-1080c73d481c">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/273983/">https://habr.com/ru/post/273983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273971/index.html">Configuring Grandstream UCM 61xx series and its integration with 1C</a></li>
<li><a href="../273973/index.html">Overview of the office DECT-phone Unify OpenStage wl3 plus</a></li>
<li><a href="../273977/index.html">Lost art proof security. Part 2 of 2</a></li>
<li><a href="../273979/index.html">Erlang for web development (1) -> Introduction;</a></li>
<li><a href="../273981/index.html">9 Tips for Localizing Audio</a></li>
<li><a href="../273985/index.html">As we did on Unity, a game for adults and got an audience of "up to 10 years"</a></li>
<li><a href="../273987/index.html">Content Delivery Network: can not wait to download</a></li>
<li><a href="../273991/index.html">Open a new version of IDE CodinGame</a></li>
<li><a href="../273995/index.html">Subtle places in React.js</a></li>
<li><a href="../273997/index.html">Cloud call center in a cloudless edge. Extraordinary New Year Adventures of ITooLabs in the Balkans</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>