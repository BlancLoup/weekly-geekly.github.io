<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parse and calculate MS Excel formulas</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most interesting tasks that we had to face in the process of working on the Spreadsheet component was the mechanism for calculating formula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parse and calculate MS Excel formulas</h1><div class="post__text post__text-html js-mediator-article">  One of the most interesting tasks that we had to face in the process of working on the <a href="https://www.devexpress.com/products/net/controls/winforms/spreadsheet/">Spreadsheet</a> component was the mechanism for calculating formulas.  Working on it, we thoroughly delved into the mechanics of the functioning of a similar mechanism in MS Excel. <br><br>  And today I want to tell you about the principles of its work, tricks and pitfalls.  And in order not to be reduced to dry retellings of documentation diluted with add-ons ‚Äúfrom life‚Äù - at the same time I will briefly describe how we implemented such a mechanism. <br><br>  So, in this article we will talk about the three main parts of the classical calculator of formulas - expression analysis, storage and calculation. <br><img src="https://habrastorage.org/getpro/habr/post_images/f94/93e/e10/f9493ee10cb62802566b41db5d3a559b.png"><br><a name="habracut"></a><br><h4>  Internal expression </h4><br>  The expression in Excel is stored in <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">reverse polish notation</a> , <abbr title="Reverse polish notation">RPN</abbr> .  An expression in RPN form is a simple array whose elements are called ParsedThing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The complete set of ParsedThing consists of the following elements: <br><br><div class="spoiler">  <b class="spoiler_title">Operands - constants, arrays, references;</b> <div class="spoiler_text">  Constants: <br><ul><li>  ParsedThingNumeric </li><li>  ParsedThingInt </li><li>  ParsedThingString </li><li>  ParsedThingBool </li><li>  ParsedThingMissingArg </li><li>  ParsedThingError </li></ul>  Arrays: <br><ul><li>  ParsedThingArray </li></ul>  References: <br><ul><li>  ParsedThingName, ParsedThingNameX </li><li>  ParsedThingArea, ParsedThingAreaErr, ParsedThingArea3d, ParsedThingAreaErr3d, ParsedThingAreaN, ParsedThingArea3dRel </li><li>  ParsedThingRef, ParsedThingRefErr, ParsedThingRef3d, ParsedThingErr3d, ParsedThingRefRel, ParsedThingRef3dRel </li><li>  ParsedThingTable, ParsedThingTableExt </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Operators - mathematical, logical, reference, as well as function calls;</b> <div class="spoiler_text">  Function calls: <br><ul><li>  ParsedThingFunc </li><li>  ParsedThingFuncVar </li></ul>  Binary operators: <br><ul><li>  ParsedThingAdd </li><li>  ParsedThingSubtract </li><li>  ParsedThingMultiply </li><li>  ParsedThingDivide </li><li>  ParsedThingPower </li><li>  ParsedThingConcat </li><li>  ParsedThingLess </li><li>  ParsedThingLessEqual </li><li>  ParsedThingEqual </li><li>  ParsedThingGreaterEqual </li><li>  ParsedThingGreater </li><li>  ParsedThingNotEqual </li><li>  ParsedThingIntersect </li><li>  ParsedThingUnion </li><li>  ParsedThingRange </li></ul>  Unary operators: <br><ul><li>  ParsedThingUnaryPlus </li><li>  ParsedThingUnaryMinus </li><li>  ParsedThingPercent </li></ul></div></div><br><div class="spoiler">  <b class="spoiler_title">Auxiliary elements and attributes (to optimize the speed of calculations, save spaces and line breaks in the expression, ie, do not affect the result of the calculation of the expression).</b> <div class="spoiler_text">  Auxiliary: <br><ul><li>  ParsedThingMemArea </li><li>  ParsedThingMemNoMem </li><li>  ParsedThingMemErr </li><li>  ParsedThingMemFunc </li><li>  ParsedThingParentheses </li></ul>  Attributes: <br><ul><li>  ParsedThingAttrSemi </li><li>  ParsedThingAttrIf </li><li>  ParsedThingAttrChoose </li><li>  ParsedThingAttrGoto </li><li>  ParsedThingAttrSum </li><li>  ParsedThingAttrSpace </li></ul></div></div><br>  I will give a couple of examples. <br><ol><li>  "= A1 * (1 + true)".  In the internal view it will look like this: {ParsedThingRef (A1), ParsedThingInt (1), ParsedThingBool (true), ParsedThingAdd, ParsedThingMultiply} </li><li>  "= SUM (A1,1," 2 ",)".  In the internal view it will look like this: {ParsedThingRef (A1), ParsedThingInt (1), ParsedThingString (‚Äú2‚Äù), ParsedThingMissing, ParsedThingFuncVar (‚ÄúSUM‚Äù, 4 arguments)} </li></ol><br><h4>  Calculations </h4><br>  Calculation of the expression written in reverse Polish notation is performed using the stack machine.  A good example is given in Wikipedia. <br><br>  But in the calculation of expressions from Excel was not without tricks.  The developers endowed all the operands with the "value type" property.  This property indicates how the operand must be converted before evaluating an operator or function.  For example, ordinary mathematical operators cannot be performed on links, but can only on simple values ‚Äã‚Äã(numeric, logical, etc.).  In order for the expression ‚ÄúA1 + B1: C1‚Äù to work correctly, Excel indicates for references A1 and B1: C1 that they must be converted to a simple value before putting the result of the calculation on the stack. <br><br>  There are three types of operands: <br><ul><li>  Reference; </li><li>  Value; </li><li>  Array. </li></ul><br>  Each operand is of type ‚Äúdefault‚Äù: <br><table><tbody><tr><td>  All kinds of links </td><td>  Reference </td></tr><tr><td>  Constants except arrays </td><td>  Value </td></tr><tr><td>  Arrays </td><td>  Array </td></tr><tr><td>  Function calls </td><td>  Value, Reference, Array </td></tr></tbody></table>  The result of the function calculation can be of any type.  Most functions return a Value, some (for example, INDIRECT) are a Reference, the rest are Array (MMULT). <br><br>  End users do not need to fill their heads with data types: Excel itself selects the desired type of operand already at the stage of expression analysis.  And at the computation stage, one cannot do without ‚Äúimplicit type conversion‚Äù.  It occurs according to the following scheme: <br><img src="https://habrastorage.org/getpro/habr/post_images/5ef/0f8/810/5ef0f8810ffe00bfc24268e05c21ba0d.png"><br>  The value of the <b>Value</b> type <b>can be converted to Array</b> , in this case an array of one value will be created.  In the opposite direction ( <b>Array-&gt; Value</b> ) the transformation is also quite simple - the first element is taken from the array. <br><br>  As can be seen from the diagram, a value of type <b>Reference cannot be obtained from Value or Array</b> .  It is quite logical, from number, line, etc.  get the link does not work. <br><br>  When converting <b>Reference to Array,</b> all values ‚Äã‚Äãfrom cells in the range are overwritten into an array.  In the case when the range is complex (consisting of two or more other ranges) - the result of the conversion is equal to the error #VALUE! <br><br>  The conversion of <b>Reference to Value</b> occurs in an interesting way.  Between ourselves, this rule we called "Crossing."  The easiest way to explain its essence is an example: <br><img src="https://habrastorage.org/getpro/habr/post_images/93b/0d2/b4f/93b0d2b4f9086e7994a0a7bf9f52a744.png"><br><br>  Suppose we want to bring to Value the values ‚Äã‚Äãof the cells from A1 to A4, which contain the same formula ‚Äú= B2: B3‚Äù, having the type Reference.  The range of B2: B3 consists of one column.  If this were not the case and there would be more columns, converting the Reference to Value for all cells A1 to A4 would return #VALUE!  and that would be the end.  Cells A2 and A3 are located in rows intersecting the range B2: B3.  Conversion Reference-&gt; Value for these cells will return the corresponding value from the range B2: B3, i.e.  the conversion for A2 returns 1, and for A3 returns 2. For the remaining cells, such as A1 and A4, the conversion returns #VALUE! <br><br>  The same behavior will be for the range of B7: C7, consisting of one line.  For cells B6 and C6, the conversion returns the values ‚Äã‚Äã3 and 4, respectively, and for A6 and - D6 #VALUE!  Similarly, if there were more lines in the range, the conversion would return #VALUE!  for all cells from A6 to D6 <br><br>  There are several types conversion rules. <br><br>  <b><i>The values ‚Äã‚Äãof all formulas inside cells are always reduced to the type Value.</i></b> <br><br>  For example: <br><ul><li>  <b>"= 123"</b> In this formula, a constant is specified, it is already of type Value.  Nothing to convert. </li><li>  <b>"= {1,2,3}" An</b> array is given here.  Conversion to Value by the rule gives us the first element of the array - 1. It will be the result of evaluating the expression. </li><li>  The formula <b>"= A1: B1"</b> located in cell B2.  The operand link to the default range is of type Reference.  In the calculation, it will be reduced to Value by the "crossing" rule.  The result in this case is the value from cell B1. </li></ul><br>  <b><i>Mathematical, logical and text operators can not work with links</i></b> .  Therefore, the arguments for them are prepared and cast to either Value or Array.  The second option is only possible inside Array formulas.  For example, when calculating the expression "= B1: B2 + A3: B3" written in cell A1, both arguments of the mathematical addition operator will first be converted to the Value type according to the "Crossing" rule, and then the results will be added.  Those.  the value will be equal to the sum of the values ‚Äã‚Äãof the cells B1 and A3. <br><br>  <b><i>Reference operators cannot work with any other type than Reference</i></b> .  For example, the formula "= A1:" test "" will be incorrect, entering such a formula will lead to an error - Excel simply will not allow such a formula to be written into a cell. <br><br>  <b><i>Expressions inside ‚Äúnames‚Äù and some other constructions are converted to the ‚Äúdefault‚Äù type</i></b> .  Unlike formulas inside cells, expressions in which are reduced to the type Value.  The expression inside some ‚Äúname‚Äù name "= A1: B1" as a result of the calculation will be equal to the range A1: B1.  The same expression in the cell will be calculated and as a result there will be either one value or the error #VALUE!  But the expression in the cell "= name" will already have the type Value and will be calculated depending on the current cell. <br><br><h4>  Parser </h4><br>  Having written the first version of the parser on the knee, we realized that the monster is too large and poorly amenable to modernization.  And in our case, it was inevitable, since we learned a large number of subtleties already when the parser worked at the very least.  For the sake of interest I decided to try other methods and armed myself for this with the <a href="http://www.ssw.uni-linz.ac.at/Coco/">Coco / R</a> translator generator.  The choice for him at that moment fell mainly due to the fact that I was already well acquainted with him.  Coco / R met my expectations.  The parser generated by him showed quite good results in terms of speed of work, so we decided to stop at this option. <br><br>  Of course, in this article I will not dwell on the description of the features and the retelling of the Coco / R documentation.  Fortunately, the <a href="http://www.ssw.uni-linz.ac.at/Coco/Doc/UserManual.pdf">documentation is</a> written in my opinion very understandable.  In addition, I recommend to read the <a href="http://habrahabr.ru/post/139972/">article on the site</a> . <br><br><h5>  We collected Coco / R from source codes </h5><br>  In some places, Coco / R does not generate a CLS-compliant code. <br><br>  <a href="http://msdn.microsoft.com/en-us/library/x8ak87y5%2528v%3Dvs.90%2529.aspx">The problem is</a> in public constants whose name begins with an underscore.  The only way out of the situation is to correct Coco / R, since the full <a href="">source code</a> is available on the developers website. <br><br>  Having rummaged in source codes found three places where public constants are created.  All of them in the ParserGen.cs file.  For example: <br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenTokens</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Symbol sym <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tab.terminals) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Char.IsLetter(sym.name[<span class="hljs-number"><span class="hljs-number">0</span></span>])) gen.WriteLine(<span class="hljs-string"><span class="hljs-string">"\tpublic const int _{0} = {1};"</span></span>, sym.name, sym.n); } }</code> </pre> <br><br>  Further, the resulting code continues to be invalid, now according to <a href="http://msdn.microsoft.com/en-us/library/bb429476%2528v%3Dvs.80%2529.aspx">FxCop</a> .  In our company, assemblies are constantly being tested for compliance with a large number of rules.  Of course, since the code was generated, it would be possible to make an exception for it and suppress the verification of the generated classes.  But this is not the best way.  Fortunately, there is only one problem - the public fields do not comply with the <a href="http://msdn.microsoft.com/en-us/library/ms182141.aspx">Microsoft.Design</a> rule <a href="http://msdn.microsoft.com/en-us/library/ms182141.aspx">: CA1051</a> .  To fix everything, it is enough to make the necessary changes to the Parser.frame and Scanner.frame files, which are located next to the grammar file.  That is, Coco / R itself is not necessary to rebuild.  Here are some examples: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Scanner scanner; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Errors errors; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Token t; <span class="hljs-comment"><span class="hljs-comment">// last recognized token public Token la; // lookahead token</span></span></code> </pre><br>  Some of these fields are not used at all outside the class ‚Äî we simply make them private, the rest ‚Äî we create public properties. <br><br>  When developing grammar for Coco / R, I used a <a href="http://www.ssw.uni-linz.ac.at/Coco/Tools/VSPlugin/">studio plugin</a> . <br><div class="spoiler">  <b class="spoiler_title">His buns</b> <div class="spoiler_text"><ul><li>  Syntax highlighting for a grammar file; </li><li>  Automatic generator start when saving a file with grammar; </li><li>  Intellisense for keywords; </li><li>  Shows compilation errors that occur in the parser file in the appropriate place in the grammar file </li></ul><br><br>  The last feature would be very convenient, but, unfortunately, it worked for me incorrectly - it showed errors not where necessary. <br></div></div><br><br>  The plugin also had to be taught to generate CLS compliant code.  Download the <a href="">source code of the plugin</a> , and repeat the same operations as with Coco / R itself. <br><br><h5>  We modernize the scanner and parser </h5><br>  I recall that to parse the expression Coco / R creates a pair of classes - Parser and Scanner.  Both are re-created for each new expression.  Since in our case there are many expressions, the re-creation of the scanner may take additional time on a large number of calls.  In general, one parser scanner is enough for us.  The first upgrade affected exactly this. <br><br>  The second upgrade touched the auxiliary class Buffer, which is created by the scanner to read the incoming character stream.  Out of the box, Coco / R contains a pair of Buffer and UTF8Buffer implementations.  Both of them work with the stream.  We do not need a thread: enough work with the string.  To do this, create a third implementation of the StringBuffer, highlighting the IBuffer interface along the way: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBuffer</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Peek</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Pos { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre><br>  The implementation of StringBuffer itself is simple: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StringBuffer</span></span> : <span class="hljs-title"><span class="hljs-title">IBuffer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stringLen; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bufPos; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> str; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StringBuffer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str</span></span></span><span class="hljs-function">)</span></span> { stringLen = str.Length; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.str = str; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (stringLen &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) Pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> bufPos = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bufPos &lt; stringLen) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str[bufPos++]; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> StreamBuffer.EOF; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Peek</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curPos = Pos; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ch = Read(); Pos = curPos; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ch; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetString</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> beg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> end</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str.Substring(beg, end - beg); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Pos { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bufPos; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt; stringLen) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FatalError(<span class="hljs-string"><span class="hljs-string">"buffer out of bounds access, position: "</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); bufPos = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">We are testing</b> <div class="spoiler_text">  Just in case, we check that we created an additional class for a reason.  We start testing three scenarios for a string of length N: <br><ol><li>  initialization from string; </li><li>  reading a character (calling the IBuffer.Read () method N times); </li><li>  get 10 characters from a string (call IBuffer.GetString (i-10, i) (N-10) times). </li></ol><br><br>  When N = 100: <br>  <b>Init x 100000:</b> <br>  Buffer: 171 ms <br>  StringBuffer: 2ms <br>  <b>Read xNx10000:</b> <br>  Buffer: 14 ms <br>  StringBuffer: 8ms <br>  <b>GetString x (N-10) x 10000:</b> <br>  Buffer: 250 ms <br>  StringBuffer: 20 ms <br></div></div><br><br><h5>  Grammar Development </h5><br>  The grammar for Coco / R is described in the <abbr title="Extended Backus ‚Äì Naur Form">EBNF</abbr> <b>.</b>  The development of grammar for Coco / R is reduced to the construction of the RBNF and its design in accordance with the grammar of Coco / R in a file with the extension atg. <br><br>  The parser is based on a recursive descent, the grammar must satisfy LL (k).  The scanner is based on a <a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton">deterministic finite state machine</a> . <br><br>  So let's get started.  The first in the grammar file is the name of the future compiler: <br><br><pre> <code class="cs hljs">COMPILER FormulaParserGrammar</code> </pre><br>  Next, the scanner specification must follow.  The scanner will be case-insensitive, we indicate this with the help of the keyword IGNORECASE.  Now you need to decide on the characters.  We need to separate the numbers, letters, control characters.  It turned out the following: <br><br><pre> <code class="cs hljs">CHARACTERS digit = <span class="hljs-string"><span class="hljs-string">"0123456789"</span></span>. chars = <span class="hljs-string"><span class="hljs-string">"~!@#$%^&amp;*()_-+={[]}|\\:;\"',./?&lt;&gt; "</span></span>. eol = <span class="hljs-string"><span class="hljs-string">'\r'</span></span>. blank = <span class="hljs-string"><span class="hljs-string">' '</span></span>. letter = ANY - digit - chars - eol - blank + <span class="hljs-string"><span class="hljs-string">'_'</span></span>.</code> </pre><br>  Coco / R allows you to not only add sets of characters, but also to subtract.  So, in the letter description, the keyword ANY is used, which substitutes the entire set of characters from which the other sets defined above are subtracted. <br><br>  An important task of the scanner is to identify the tokens in the input sequence.  While working on the parser, the set of tokens was constantly changing and as a result it looks like this: <br><br><pre> <code class="cs hljs">TOKENS ident = letter {letter | digit | <span class="hljs-string"><span class="hljs-string">'.'</span></span>}. wideident = letter {letter | digit} (<span class="hljs-string"><span class="hljs-string">'?'</span></span>|<span class="hljs-string"><span class="hljs-string">'\\'</span></span>) {letter | digit | <span class="hljs-string"><span class="hljs-string">'?'</span></span>|<span class="hljs-string"><span class="hljs-string">'\\'</span></span>}. positiveinumber = digit {digit}. fnumber = <span class="hljs-string"><span class="hljs-string">"."</span></span> digit {digit} [(<span class="hljs-string"><span class="hljs-string">"e"</span></span> | <span class="hljs-string"><span class="hljs-string">"E"</span></span>) [<span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>] digit {digit}] | digit {digit} ( <span class="hljs-string"><span class="hljs-string">"."</span></span> digit {digit} [(<span class="hljs-string"><span class="hljs-string">"e"</span></span> | <span class="hljs-string"><span class="hljs-string">"E"</span></span> ) [<span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>] digit {digit} ] | (<span class="hljs-string"><span class="hljs-string">"e"</span></span> | <span class="hljs-string"><span class="hljs-string">"E"</span></span>) [<span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span>] digit {digit} ). space = blank. quotedOpenBracket = <span class="hljs-string"><span class="hljs-string">"'["</span></span>. quotedSymbol = <span class="hljs-string"><span class="hljs-string">"''"</span></span> | <span class="hljs-string"><span class="hljs-string">"']"</span></span> | <span class="hljs-string"><span class="hljs-string">"'@"</span></span> | <span class="hljs-string"><span class="hljs-string">"'#"</span></span>. pathPart = <span class="hljs-string"><span class="hljs-string">":\\"</span></span>. trueConstant = <span class="hljs-string"><span class="hljs-string">"TRUE"</span></span>. falseConstant = <span class="hljs-string"><span class="hljs-string">"FALSE"</span></span>.</code> </pre><br><br>  Please note that an identifier may contain one or several dot characters.  Such, for example, may be the name of the sheet in the link to the range.  An additional, extended identifier is also required.  It differs from the usual presence of a question mark or bekslesha.  I note that in Excel the concept of an identifier is quite complex and difficult to describe in grammar.  Instead, I check all lines identified by the scanner as ident and wideident already in the code for compliance with the following rules: <br><ul><li>  It can contain only letters, numbers, and symbols: _,., \,?; </li><li>  Cannot be TRUE or FALSE; </li><li>  The first character can only be a letter, underscore, or beksleshem; </li><li>  If the first character of the string is Bexlesh, then the second character may not be, or it must be one of: _,., \,?; </li><li>  Must not be similar to the name of the range (for example, A10); </li><li>  Should not begin on a line that can be interpreted as a reference in the format R1C1.  The nature of this condition is difficult to explain; I will give only a few examples of identifiers that do not satisfy him: ‚ÄúR1_test‚Äù, ‚ÄúR1test‚Äù, ‚ÄúRC1test‚Äù, ‚ÄúR‚Äù, ‚ÄúC‚Äù.  At the same time, ‚ÄúRCtest‚Äù is quite suitable. </li></ul><br><br>  Selection quotedOpenBracket, quotedSymbol and pathPart to a separate token is nothing more than a trick.  It allowed to skip characters in the column names in the table link, before which the apostrophe should follow.  For example, in the expression ‚Äú= Table1 [Column '[1']]‚Äù, the column name starts after the '[' character and continues to the ']' character.  At the same time, the first such symbol, together with the apostrophe preceding it, will be read by the scanner as a quotedSymbol (']) terminal and, thus, reading the column name will not stop there. <br><br>  Finally, let the scanner skip line feeds and tabs. <br>  IGNORE eol + '\ n' + '\ t'.  Expressions themselves can be written in several lines, but this does not affect the grammar. <br><br>  We have come to the main section of PRODUCTIONS.  It is necessary to describe all non-terminals.  In the examples below, I will provide a simplified code, I cut out most semantic inserts, since  they will make it difficult to understand grammar.  I will leave only the places of construction of the expression itself, without optimizations. <br><br>  For all non-terminals (of which Coco / R will make methods), a reference to the expression in the RPN form will be transmitted, as well as the data type to which it should be converted.  When calling a parser for a formula inside a cell, the initial data type is Value.  Further, during parsing, it will change, and the prepared type will be transferred to the branches of the parse tree.  For example, when parsing the expression ‚Äú= OFFSET (A1: B1, A1, A2)‚Äù, the element of the Polish notation ‚Äî the OFFSET function ‚Äî will receive the Value type, while parsing the first argument, it will be cast to Reference, the other two to Value.  For all functions, we store information, which arguments and which types should be passed to it. <br><br>  The task of the parser is also to check the formula for correctness.  The formula will be considered incorrect if Excel does not allow to write it in a cell.  In addition to syntax errors, an incorrect number of arguments passed to a function or a data type mismatch to the requested one can make the formula incorrect.  For example, the ROW function either needs no parameters at all or only one, and it should be exclusively Reference.  We have already said that it is impossible to bring any other type to the Reference, which means that the expressions ‚Äú= ROW (1)‚Äù, ‚Äú= ROW (‚Äú A1 ‚Äù)‚Äù will be invalid. <br><br>  Since  our grammar is a sophisticated grammar for ordinary mathematical expressions, it is also constructed depending on the precedence of operations.  The first are the logical expressions, the last are the operators for working with ranges.  Those.  in order of increasing priority. <br><br>  To visualize RBNF I use a small program <a href="http://dotnet.jku.at/applications/visualizer/">EBNF Visualizer</a> .  This is how the first non-terminal in our grammar will look like - a logical expression: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/103/dc4/afe/103dc4afe4d5dccdac69c256f99860e5.gif"><br><br>  Further grammar for Coco / R.  In the semantic inserts between ‚Äú(..‚Äù And ‚Äú.)‚Äù I add the desired ParsedThing to the expression. <br><br><pre> <code class="cs hljs">LogicalClause&lt;OperandDataType dataType, ParsedExpression expression&gt; (. IParsedThing thing = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; .) = ConcatenateClause&lt;dataType, expression&gt; { ( <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span> (.thing = ParsedThingLess.Instance; .) | <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span> (.thing = ParsedThingGreater.Instance; .) | <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span> (.thing = ParsedThingLessEqual.Instance; .) | <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span> (.thing = ParsedThingGreaterEqual.Instance; .) | <span class="hljs-string"><span class="hljs-string">"&lt;&gt;"</span></span> (.thing = ParsedThingNotEqual.Instance; .) | <span class="hljs-string"><span class="hljs-string">'='</span></span> (.thing = ParsedThingEqual.Instance; .) ) ConcatenateClause&lt;dataType, expression&gt; (. expression.Add(thing); .) } .</code> </pre><br><br>  According to this principle will be built: ConcatenateClause, AddClause, MultipyClause, PowerClause, UnaryClause, PercentClause, RangeUnionClause, RangeIntersectionClause, CellRangeClause.  On the CellRangeClause, the nonterminals describing the operators end.  It is followed by the first operand - OperandCommonClause.  It will look something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22d/5bc/dde/22d5bcdde2d72e6b7001f15bccdc74e5.gif"><br><br>  However, there is ambiguity in the above grammar.  It lies in the fact that SheetName and OperandClause can begin with the same terminal - with an identifier.  For example, the expression ‚Äú= Sheet! A1‚Äù may follow, or it may be ‚Äú= name‚Äù.  Here ‚ÄúSheet‚Äù and ‚Äúname‚Äù are identifiers.  Fortunately, Coco / R allows you to resolve conflicts by viewing the incoming stream with a scanner several terminals ahead.  Those.  we can look for the character '!', if one is found, then we parse the SheetName, otherwise OperandClause.  This is how the grammar will look like: <br><br><pre> <code class="cs hljs">OperandCommonClause&lt;OperandDataType dataType, ParsedExpression expression&gt; = ( IF(IsSheetDefinition()) ( ( SheetNameQuoted&lt;sheetDefinitionContext&gt; | [ <span class="hljs-string"><span class="hljs-string">'['</span></span> FileDefinitionSimple ] [ SheetName&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> sheetName&gt; [ <span class="hljs-string"><span class="hljs-string">':'</span></span> SheetName&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> sheetName&gt; | <span class="hljs-string"><span class="hljs-string">'|'</span></span> SingleQuotedIdent&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> ddeTopic&gt; ] ] ) <span class="hljs-string"><span class="hljs-string">'!'</span></span> CellReferenceClause&lt;dataType, expression&gt; ) | OperandClause&lt;dataType, expression&gt; ) .</code> </pre><br><br>  The IsSheetDefinition () method defined in the Parser class is used to resolve the conflict.  Such methods are conveniently written in a separate file, marking the class as partial. <br><br>  The SheetName terminal can start with a digit or consist of numbers only.  In this case, the name of the sheet must be enclosed in apostrophes.  Otherwise, Excel adds the missing extras. <br><br><pre> <code class="cs hljs">SheetName&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sheetName&gt; (. <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sheetNameStart = la.pos;.) = ( [positiveinumber | fnumber] [ident] ) (. sheetName = scanner.Buffer.GetString(sheetNameStart, la.pos); .) .</code> </pre><br><br>  There are a couple of mistakes in this grammar.  First, all terminals inside the non-terminal are optional.  And secondly, it allows you to insert a space or any character described in the IGNORE section between the number and the identifier.  The problem can be solved with the help of the conflict resolution mechanism, but without additional functions.  Directly in the grammar we check for the presence of a gap between the number and the identifier following it: <br><br><pre> <code class="cs hljs">SheetName&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> sheetName&gt; (. <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sheetNameStart = la.pos;.) = ( positiveinumber | fnumber [ IF(la.pos - t.pos == t.val.Length) ident ] | ident ) (. sheetName = scanner.Buffer.GetString(sheetNameStart, la.pos); .) .</code> </pre><br><br>  In OperandClause we will get from OperandCommonClause if there is no link to a worksheet, external book or DDE source.  From this non-terminal, we can get into ArrayClause, StringConstant (both cannot have a link to the list in front of them), CellReferenceClause, or we can see a bracket and go to the beginning of the entire parse tree - to LogicalClause. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/52c/e3b/345/52ce3b3453a54f1bbc4712212e18912c.gif"><br><br><pre> <code class="cs hljs">OperandClause&lt;OperandDataType dataType, ParsedExpression expression&gt; = ( CellReferenceClause&lt;dataType, expression&gt; | ArrayClause&lt;dataType, expression&gt; | StringConstant&lt;expression, dataType&gt; ) | <span class="hljs-string"><span class="hljs-string">'('</span></span> CommonCellReference&lt;dataType, expression&gt; <span class="hljs-string"><span class="hljs-string">')'</span></span> (. expression.Add(ParsedThingParentheses.Instance);.) .</code> </pre><br><br>  CellReferenceClause is probably the largest non-terminal, it contains almost all types of operands: <br><br><pre> <code class="cs hljs">CellReferenceClause&lt;OperandDataType dataType, ParsedExpression expression&gt; = ( IF (IsTableDefinition()) TableReferenceExpressionClause&lt;dataType, expression&gt; | IF (IsFunctionDefinition()) FunctionClause&lt;dataType, expression&gt; | IF (IsDefinedNameDefinition()) DefinedNameClause&lt;dataType, expression&gt; | IF(IsRCCellPosition()) CellPositionRCClause&lt;dataType, expression&gt; | IF(IsA1CellPosition()) CellPositionA1Clause&lt;dataType, expression&gt; | CellError&lt;dataType, expression&gt; | TermNumber&lt;expression&gt; | BoolConstant&lt;expression, dataType&gt; | wideident (. expression.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParsedThingName(t.val);.) ) .</code> </pre><br><br>  For most non-terminals, you need to create conflict resolution methods.  Then we describe the grammar for all the remaining non-terminals. <br><br><h5>  Parsing incomplete expressions and "predictions" </h5><br>  Consider the task of highlighting the ranges involved in the formula. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/736/518/71c/73651871cd38b6058c5477a5dcb1e758.png"><br><br>  The problem here is that the expression may be invalid, and you must still highlight the ranges.  At that time, the parser, without mastering the expression, always returned null.  Of course, it would be possible to try to figure out a partially read expression and gather links from it, but how do you know where in the expression is a specific link?  Therefore, we decided to teach the parser to immediately put everything interesting in places as it reads.  So, all links by type were in specially designed collections.  The parser when detecting, for example, a reference to a range, calls the appropriate method <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterCellRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CellRange range, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sheetDefinitionIndex, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> position, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> length</span></span></span><span class="hljs-function">)</span></span></code> </pre><br><br>  After reading, regardless of whether it was successfully completed or not, we have a set of links. <br><br>  Another mechanism began to be based on this - predictions.  In the expression ‚Äú= 1 * (1 + 2‚Äù the balance of brackets is broken, but, with high probability, the user forgot to put the bracket exactly at the end of the expression. That is, you can try to correct this formula by adding the missing bracket to it. Of course, the parser will do this it will not, he will only say where and what he thinks is missing. For example, the following lines appeared in OperandClause already familiar to us: <br><pre> <code class="cs hljs"><span class="hljs-string"><span class="hljs-string">'('</span></span> CommonCellReference&lt;dataType, expression&gt; (. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(la.val != <span class="hljs-string"><span class="hljs-string">")"</span></span>) parserContext.RegisterSuggestion(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FunctionCloseBracketSuggestion(la.pos)); .) <span class="hljs-string"><span class="hljs-string">')'</span></span></code> </pre><br><br>  Of course, all these actions are done only when the expression is entered manually and there is a need to draw the involved ranges or to try to correct the unfinished formula. <br><br><h4>  Computation Performance Optimization </h4><br>  Excel, still at the stage of parsing the expression, tries to make life easier for itself.  To this end, he, if possible, fills the expression with all sorts of auxiliary elements.  Let's look at them. <br><br>  <b>AttrSemi attribute.</b>  This attribute is added to the first element in those expressions that contain volatile functions. <br><br>  <b>Attribute class Mem.</b>  This includes several attributes at once.  They are united by the fact that they are designed to optimize the calculation of links.  In essence, they are a wrapper over some expression.  During the evaluation, the inner expression may not be calculated, the result will be Mem for it.  A distinctive feature of these elements is that they are inserted in the reverse Polish record before the expression that is optimized. <br><br><ul><li>  ParsedThingMemFunc - indicates that the expression inside must be evaluated every time and no result can be cached.  For example, the whole expression = INDIRECT ("A1"): B1 will be wrapped in MemFunc, since  The INDIRECT function is a volatile function and, at the next calculation, may return a different value. </li><li>  ParsedThingMemArea.  It contains an expression whose value has already been calculated and will not change.  This value will remain inside the attribute and at the next calculation it will be added to the stack, and the internal expression will not be calculated at all. </li><li>  ParsedThingMemErr.  It contains an expression whose value is calculated, will not change and is equal to an error. </li><li>  ParsedThingMemNoMem.  When calculating an expression inside Excel, there is a shortage of memory.  In practice, I have never met this. </li></ul><br><br>  <b>The AttrSum attribute is</b> used as a simplified form of writing the SUM function in the case when only one argument is passed to the function. <br><br>  <b>The AttrIf attribute is</b> used in conjunction with one or two Goto operators to optimize the calculation of the IF function.  Let me remind the syntax of the IF function: IF (condition, true_value, [false_value]).  Of the two values, you can calculate only one and save time on the calculation of the other, if you immediately go to the desired value after the condition is calculated.  Thus, the simple expression = IF (condition, ‚Äùv_true‚Äù, ‚Äùv_false‚Äù) Excel dilutes with dense attributes.  It turns out about the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/957/657/6de/9576576de8cbdbd60706cec064f42fa2.png"><br><br>  The calculation goes like this.  The condition value is pushed onto the stack.  The next in line is the IF attribute.  He looks at the value at the top of the stack.  If it is true, it does nothing.  If false, adds the current item counter in the expression to the offset written inside, thereby starting the counter to point to ‚Äúv_false‚Äù.  Next, either ‚Äúv_true‚Äù or ‚Äúv_false‚Äù is calculated and the result is pushed onto the stack.  Next is Goto, first or second.  But both of them refer to the end of the expression (or the following operators in the expression, if any). <br><br>  <b>AttrChoose</b> works very similarly.  Let me remind you that the CHOOSE function selects one of the arguments, the sequence number of which is specified in the first argument. <br>  Thus, only one argument affects the further result of the calculation, all the others can be skipped.  AttrChoose stores a set of blends, each of which points to the beginning of each next argument.  The argument is followed by the familiar AttrGoto, which points to the end of the expression or the element following the CHOOSE function. <br><br>  <b>The Space attribute is</b> used to preserve the format of a user-entered expression, namely, string and space transfers.  Each such attribute except quantity has type.  There are only six types: <br><ul><li>  SpaceBeforeBaseExpression, </li><li>  CarriageReturnBeforeBaseExpression, </li><li>  SpaceBeforeOpenParentheses, </li><li>  CarriageReturnBeforeOpenParentheses, </li><li>  SpaceBeforeCloseParentheses, </li><li>  CarriageReturnBeforeCloseParentheses, </li><li>  SpaceBeforeExpression; </li></ul><br><br>  Looking at these types, you can guess that Excel cannot save spaces at the end of the line and before the ‚Äú=‚Äù sign.  In addition, spaces within structured references and arrays will not be saved either. <br><br><h4>  Testing </h4><br>  When our control just learned to read and write files in the OpenXML format, we were quick to check it out.  And the best way to do this is to find many, many files and try to drive reading and writing these files.  So we pumped about 10k random OpenXML files and wrote a simple program.  We created a task for her on the test farm.  Every night, the task automatically starts and reads and writes files.  If any errors occur, all the necessary information is recorded in the log.  So we were able to debug a huge number of errors. <br><br>  With the development of controls, both supported formats and features were added.  So now 20k xls files and 15k csv files are constantly being tested.      -,     ,     . <br><br>        Excel  ,           10 OpenXML  20 xls .  ,    .           ,        ,     .       ‚Äì           ,     Excel. <br><br> ,      ,    ‚Äì    .        ,     .       , ,        . <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/222523/">https://habr.com/ru/post/222523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222513/index.html">How not to turn off pictures and scripts in letters, and at the same time be safe. History from Yandex. Mail</a></li>
<li><a href="../222515/index.html">Google Chrome extension to improve search quality</a></li>
<li><a href="../222517/index.html">Postgraduate study in France, personal experience</a></li>
<li><a href="../222519/index.html">Pool of constants</a></li>
<li><a href="../222521/index.html">Axure tutorial videos</a></li>
<li><a href="../222525/index.html">Half-Life 2 and Portal became available on NVIDIA SHIELD</a></li>
<li><a href="../222527/index.html">The magazine "TsODy.RF" and the Association of Industry Data Centers will show all the paths that lead to the data center</a></li>
<li><a href="../222529/index.html">Python Meetup: March Meeting</a></li>
<li><a href="../222533/index.html">In honor of TechEd 2014, telerik offers free licenses</a></li>
<li><a href="../222535/index.html">DEKA ARM</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>