<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Esoteric language translated into C ++ templates</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ Templates is a Turing-complete language in which you can write compile-time programs. Only here the syntax is designed for the description of par...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Esoteric language translated into C ++ templates</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/14f/b2b/c94/14fb2bc947ec47788192892c9553a44e.png" align="right" alt="KDV with code examples" title="Factorial, written mathematically (above), on C ++ templates (in the middle) and described in the article (below)">  C ++ Templates is a Turing-complete language in which you can write compile-time programs.  Only here the syntax is designed for the description of parameterized types and is poorly adapted to clearly express something more complex.  In this article, we will look at how types and patterns become values ‚Äã‚Äãand functions, and also find out what the author‚Äôs attempt to create a functional language that translates into C ++ patterns led to.  Knowledge of functional programming is almost not required to read text. <br><a name="habracut"></a><br><h2>  How it works? </h2><br>  Here we will lay the basic building blocks for building a compilation phase from the program templates.  For those who are not familiar with functional programming, we will describe some necessary concepts in simple language.  Having examined the basic things, we will be ready to switch to a new language, its syntax, capabilities and problems.  Those who wish to go straight to the main point immediately can skip to the green image next to the repeated appearance of the article title. <br><br>  Honestly, a couple of years ago I was trying to write here a post about explaining the principles of the work of compile-time programs using the example of the algorithm for changing the priorities of operators in expressions (i.e., I implemented options for the compile-time and run-time algorithm, which allowed <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mn" id="MJXp-Span-2"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+ </font></font></span><span class="MJXp-mn" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mo" id="MJXp-Span-5" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚àó </font></font></span><span class="MJXp-mn" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.522ex" height="2.057ex" viewBox="0 -728.2 3669.4 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-32" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-2B" x="722" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-32" x="1723" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-2217" x="2446" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-32" x="3168" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> 2 + 2 * 2 </script>  ‚ÄúReassemble‚Äù with alternative priorities and calculate how <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mn" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eight</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-38" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> 8 </script>  , but not <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mn" id="MJXp-Span-10"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-36" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> 6 </script> ). <br><br>  I‚Äôve almost finished a long article with pictures and UML diagrams, but suddenly I realized that Habr√© was so often told about metaprograms that it‚Äôs simply not interesting to anyone.  Especially because <code>constexpr</code> added for practical use, but I wanted to stay in the area of ‚Äã‚Äãperverted entertainment and use the minimum of language features.  Wonderful articles <a href="https://habrahabr.ru/post/218229/">Life during compilation</a> from <a href="https://habrahabr.ru/users/hurrthedurr/" class="user_link">HurrTheDurr</a> and <a href="https://habrahabr.ru/post/218341/">Interpretation at compile time, or Alternative understanding of lambda in C ++ 11</a> by <a href="https://habrahabr.ru/users/ilammy/" class="user_link">ilammy</a> (the second is more hardcore and without <code>using template</code> with <code>constexpr</code> ) described almost everything that the perverted mind needed to know.  In the end, I left the article in the drafts, but did not leave the desire to metaprogram.  And today I come back with newly written text and new ideas. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If, despite all my efforts, it will still be difficult for the reader to perceive the material, I recommend reading these articles, and after - a gentle introduction to Haskell ( <a href="">part 1</a> , <a href="">part 2</a> ) from Paul Hyudak and others, translated by Denis Moskvin and <a href="https://habrahabr.ru/post/322052/">Lambda calculus on Javascript</a> from <a href="https://habrahabr.ru/users/ibessonov/" class="user_link">ibessonov</a> .  All this to some extent influenced the author, maybe it will affect the reader ?! <br><br><h3>  Meta values ‚Äã‚Äãand meta functions </h3><br>  Class templates are, in a sense, functions of types that accept and return types.  Accordingly, patterns become meta-functions, and types and integers become meta-values.  For example, the <code>std::vector</code> metafunction takes the meta value <code>T</code> and returns the meta value <code>std::vector&lt;T&gt;</code> .  It is important that metadata has a set of metafields (from the point of view of C ++, nested classes, type aliases, static constant fields) with which you can make the most interesting. <br><br>  We can single out one meta-field, for example <code>value</code> , and understand it as the value that the metafunction returns.  Metafunctions over integers are fairly simple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">square</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value = x * x; };</code> </pre><br>  <s>Called</s> is applied, as they say in the FP, meta-function as follows: <code>square&lt;5&gt;::value</code> . <br><br>  But integers are the usual meanings, to work with which simple C ++ is enough, and therefore it would be somewhat unsportsmanlike to use them in meta-expressions.  A real honest meta value is a type.  The easiest way to create it is to declare a structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">One</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Zero</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  From the point of view of C ++, <code>one</code> and <code>zero</code> only <i>declared</i> and practically useless.  is that enough?  Yes.  What, then, are they equal and how to use them?  Equal to them, which is important, only to themselves.  These are a kind of abstract symbols that can be used in symbolic calculations (almost as in Mathematica, etc.).  The metaprogram will calculate the values ‚Äã‚Äãof meta expressions of varying complexity.  We first consider these expressions, and a little later we will deal with the interpretation of symbols and the display of results on the screen. <br><br>  For zero and one as Boolean values, it is natural to write NOT, AND, and OR functions.  Consider the negation metafunction: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Not</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Zero value; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Not</span></span></span><span class="hljs-class"> &lt;Zero&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> One value; };</code> </pre><br>  <code>Not</code> takes some value and returns one if this value is zero.  In all other cases, it will return zero.  Thus, due to the specialization of templates, we have pattern matching (comparison with a sample) in the embryonic stage: we can describe separately the behavior of a function for one or several arguments that have specific values, and the C ++ compiler, noting that the template parameters match one of the samples, will substitute necessary specialization.  Using this, we could already write something recursive (for example, factorial, dividing the description into <code>fac&lt;0&gt;</code> and <code>fac&lt; &gt;</code> ). <br><br><h3>  List </h3><br>  If you do not limit yourself to the default <code>value</code> , you can imagine how many-valued functions look.  We write the constructor of the <code>Cons</code> list and the empty <code>Nil</code> list, familiar to connoisseurs of functional programming: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> h, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> t&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cons</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> h head; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> t tail; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nil</span></span></span><span class="hljs-class">;</span></span></code> </pre><br>  <code>Cons</code> in the OP is a function that constructs a list of the first element (head) and the list of other elements (tail).  Normal list <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="noError" id="MJXp-Span-12" style="display: inline-block;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ {one, two, three \}</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><span class="noError" style="display: inline-block;">\&nbsp;{one,&nbsp;two,&nbsp;three&nbsp;\}</span></span><script type="math/tex" id="MathJax-Element-4"> \ {one, two, three \} </script>  will correspond to <code>Cons&lt;one, Cons&lt;two, Cons&lt;three, Nil&gt;&gt;&gt;</code> .  Since to work with a list you need to be able to get its components, we will make <code>Cons</code> multivalued function that returns the head ( <code>Cons&lt;...,...&gt;::head</code> ) and tail ( <code>Cons&lt;...,...&gt;::tail</code> ).  OOP lovers can imagine that <code>Cons</code> is a constructor, and <code>head</code> and <code>tail</code> are getters.  In the FP, all assignments are replaced by a <s>call</s> using a function with modified arguments, so there will not be setters and their analogues here. <br><br>  Such a list is usually recursive, since there are no cycles in functional languages: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    template &lt;typename list&gt; struct negate { private: //    typedef typename list::head h; //  typedef typename Not&lt;h&gt;::value not_head; //   typedef typename list::tail t; //  typedef typename negate&lt;t&gt;::value not_tail; //   public: //     -   , //     typedef Cons&lt;not_head, not_tail&gt; value; }; //    template &lt;&gt; struct negate &lt;Nil&gt; { //   -    typedef Nil value; };</span></span></code> </pre><br>  It turns out that Haskell is not as scary as it is painted.  All the same looks so simple that it is not a sin to add examples in this language for clarity.  For the untrained reader, we note the main difference from C ++ and school math: in Haskell, arguments are separated by spaces and are not grouped in brackets.  Those. <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">f</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">x</span><span class="MJXp-mo" id="MJXp-Span-17" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">y</span><span class="MJXp-mo" id="MJXp-Span-19" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">g</span><span class="MJXp-mo" id="MJXp-Span-21" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22">y</span><span class="MJXp-mo" id="MJXp-Span-23" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-24" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">z</span><span class="MJXp-mo" id="MJXp-Span-26" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.65ex" height="2.66ex" viewBox="0 -832 6738.3 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMATHI-66" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-28" x="550" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMATHI-78" x="940" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-2B" x="1734" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMATHI-79" x="2735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-2C" x="3232" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMATHI-67" x="3678" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-28" x="4158" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMATHI-79" x="4548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-29" x="5045" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-2C" x="5435" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMATHI-7A" x="5880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/337590/&amp;xid=17259,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhh-oHBBxV2or2i5p-GqNDo9XjleXA#MJMAIN-29" x="6348" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> f (x + y, g (y), z) </script>  will be written to Haskell as <code>f (x+y) (gy) z</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--  -      (  -  ), --   data List a = Cons a List | Nil --       head (Cons x _) = x --   tail (Cons _ xs) = xs --   --   negate (Cons x xs) = Cons (Not x) (negate xs) negate Nil = Nil</span></span></code> </pre><br>  Unlike the strongly typed Haskell and C ++, duck-typing works in the template language.  <code>negate&lt;One&gt;::value</code> , of course, will not work, but if <code>One</code> has the metafield and <code>head</code> and <code>tail</code> , it will be fine.  However, while the <code>negate&lt;One&gt;</code> not ‚Äúdereferenced‚Äù with <code>::value</code> , the program continues <s>to work to</s> compile. <br><br><h3>  Higher order functions </h3><br>  In functional languages, functions are the same values.  So, you can write a higher order function ‚Äî that takes a function as an argument or returns a function.  For example, element-by-element list conversion is performed using the FVP map: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">--       map f (Cons x xs) = Cons (fx) (map f xs) --      map f Nil = Nil</span></span></code> </pre><br>  STL contains such a transformation under the name <code>std::transform</code> .  In our language, the <code>map</code> metafunction is declared using template template parameterization: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    // f -     -   template &lt;template &lt;typename&gt; class f, typename list&gt; struct map { private: typedef typename list::head h; //  typedef typename f&lt;h&gt;::value new_head; //   typedef typename list::tail t; //  typedef typename map&lt;f, t&gt;::value new_tail; //   public: //       typedef Cons&lt;new_head, new_tail&gt; value; }; //    template &lt;template &lt;typename&gt; class f&gt; struct map&lt;f, Nil&gt; { //      typedef Nil value; };</span></span></code> </pre><br>  As <code>f</code> here, we can substitute the function <code>Not</code> described earlier and calculate the list of negatives: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Not, Cons&lt;One, Cons&lt;One, Cons&lt;Zero, Nil&gt;&gt;&gt;&gt;::value <span class="hljs-built_in"><span class="hljs-built_in">list</span></span>; <span class="hljs-comment"><span class="hljs-comment">// list  Cons&lt;Zero, Cons&lt;Zero, Cons&lt;One, Nil&gt;&gt;&gt;</span></span></code> </pre><br><h3>  Expression Naming Operations </h3><br>  It can be seen that <code>typedef</code> is some equivalent of an assignment operator.  Or, which sounds more correct for functional languages, is the operation of specifying the name and expression. <br><br>  Starting with C ++ 11, you can use type and pattern aliases to set values ‚Äã‚Äãand functions through known expressions: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> x = Not&lt;One&gt;::value; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> xs&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> g = Cons&lt;x, xs&gt;;</code> </pre><br>  Template aliases allow you to get rid of the <code>value</code> metafield when the metafunction returns a single meta value.  This can be more convenient if the programmer is too lazy to explicitly specify <code>::value</code> , and also impose a computability requirement. <br><br><div class="spoiler">  <b class="spoiler_title">The program can just go into endless recursion.</b> <div class="spoiler_text">  Remember that <code>negate&lt;Zero&gt;</code> compiled, but <code>negate&lt;Zero&gt;::value</code> is not.  Using the cumbersome metafields, you can write a branch metafunction that calculates <code>::value</code> for only one branch depending on the condition and returns this value.  It turns out that one of the expressions will never be calculated: all operations are performed only when receiving <code>::value</code> , and nobody touched it: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      template &lt;typename expr1, typename expr2&gt; struct If &lt;True, expr1, expr2&gt; { // expr1, expr2 ,  expr1::value  expr2::value -  typedef typename expr1::value value; } // If&lt;One, id&lt;One&gt;, destroy&lt;the_world&gt;&gt;::value   </span></span></code> </pre><br>  At the same time, the template alias version provides that some <code>g&lt;x&gt;</code> makes sense of the already calculated <code>f&lt;x&gt;::value</code> .  And if you branch between two recursive variants, the calculations will be infinite - an analog of stack overflow at the compilation stage. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> expr1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> expr2&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">If</span></span></span><span class="hljs-class"> &lt;True, expr1, expr2&gt; {</span></span> <span class="hljs-comment"><span class="hljs-comment">// expr1, expr2  typedef expr1 value; }; // If&lt;One, One, destroy&lt;the_world&gt;::value&gt;::value  </span></span></code> </pre><br></div></div><br>  Basically, pseudonyms of patterns are simply syntactic sugar, equivalent to patterns, without which it is quite possible to do. <br><br><h3>  Closures </h3><br>  If in ordinary C / C ++ the arguments and local variables die after the function ends, in functional languages ‚Äã‚Äãfunctions can return functions that depend on the arguments and local variables of the parent function.  Accordingly, the parent function has already completed, but its local variables remain alive, ‚Äútied‚Äù to the child function.  In practice, this is useful when the interface requires, for example, a unary function, and in its implementation there is some context on which it also depends. <br><br>  For example, <code>fx</code> returns a unary function <code>g</code> , implicitly using the <code>x</code> argument of <code>f</code> . <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fx</span></span> = g <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> g xs = <span class="hljs-type"><span class="hljs-type">Cons</span></span> x xs <span class="hljs-comment"><span class="hljs-comment">-- : (fx) xs ,  , map (fx) list</span></span></code> </pre><br>  It would be possible to leave <code>Cons</code> , but <code>g</code> can be passed as a unary function into an already written <code>map</code> function, and as a binary one, <code>Cons</code> not! <br><br><div class="spoiler">  <b class="spoiler_title">However, normal C ++ does not suffer from the absence of closures.</b> <div class="spoiler_text">  To do this, use a functional object or lambda function.  That is, if the transfer of additional parameters to the function via global variables violates the flexibility of the program, instead of a function, use an object, <code>this</code> contains the entire context of interest, and <code>operator ()</code> takes the arguments required by the interface.  The beautiful concept of the OP is replaced by the equivalent power concept of the PLO.  Even the standard <code>std::function</code> template is provided! <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  C++11:  ,   struct f { f(something&amp; x) : x(x) {} something_else operator () (something_else&amp; xs) { // xs -   return Cons(x, xs); } private: something x; //   }; // C++11  : -,   something x; auto f = [x](something_else&amp; xs) { return Cons(x, xs); };</span></span></code> </pre><br></div></div><br>  When replacing functions (for example, <code>int(int)</code> ) with functional objects (for example, <code>std::function&lt;int(int)&gt;</code> ), the C ++ programmer gets a full-fledged closure. <br><br>  At the template level, there is no need for the substitution of ‚Äúfunction ‚Üí object‚Äù, as it turns out.  Closures are supported by the language itself: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> x&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">g</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> Cons&lt;x, xs&gt; value; }; }; <span class="hljs-comment"><span class="hljs-comment">// : f&lt;x&gt;::g&lt;list&gt;::value  map&lt;f&lt;x&gt;::g, list&gt;</span></span></code> </pre><br>  Unlike C ++ and Haskell, the <code>g</code> character comes out of <code>f</code> here, but the rest is fair closure.  The expression <code>f&lt;x&gt;::g</code> can be used instead of the usual unary function (for example, <code>Not</code> ). <br><br><h3>  Unlimited number of arguments or syntactic sugar for lists </h3><br>  Variation patterns allow you to record functions from lists.  Again, in some cases it is more convenient, but without them you can also live in peace with <code>Cons</code> and <code>Nil</code> .  In addition, it may be even more simple move.  To transfer two lists to a metafunction, it‚Äôs enough ... to transfer two lists: <code>f&lt;xs, ys&gt;</code> , for variadic templates, you need to set a wrapper that captures all lists except the last one: <code>f&lt;list_wrapper&lt;x1,x2,x3&gt;, y1, y2, y3&gt;</code> , since the list of arguments of arbitrary length must be one, and several lists written in a row simply ‚Äústick together‚Äù.  Upon completion of the calculations, you have to return the wrapper, since  in C ++ you cannot add a list of several types.  And in order to ‚Äúpick out‚Äù the list from the wrapper and transfer it to the metafunction (say, <code>f</code> ), you will have to use metacallbacks: implement the metamethod that accepts this metafunction <code>f</code> and transfers the contents of the list to the wrapper: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list_wrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   list_wrapper&lt;...&gt;::call , //     xs struct call&lt;template &lt;typename...&gt; class f&gt; { typedef typename f&lt;xs...&gt;::value value; }; };</span></span></code> </pre><br>  Iterative / recursive processing of the list even with the help of this is not so easy to implement.  For example, to implement <code>negate</code> you need to construct an auxiliary unary metafunction <code>f</code> , which takes the result of the recursive use of <code>negate</code> to the tail of the list, calculates the negation of the head, and returns the wrapper for the list assembled together: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">negate</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... ys&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> list_wrapper&lt;Not&lt;x&gt;::value, ys&gt; value; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> negate&lt;xs&gt;::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> call&lt;f&gt;::value; }; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">negate</span></span></span><span class="hljs-class">&lt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> list_wrapper&lt;&gt; value; };</code> </pre><br>  It turned out that for a beautiful view of the record <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="noError" id="MJXp-Span-28" style="display: inline-block;">\&nbsp;{x1,&nbsp;x2,&nbsp;x3&nbsp;\}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><span class="noError" style="display: inline-block;">\&nbsp;{x1,&nbsp;x2,&nbsp;x3&nbsp;\}</span></span><script type="math/tex" id="MathJax-Element-6"> \ {x1, x2, x3 \} </script>  when declared, I had to suffer, packing, transferring and unpacking these sequences.  <code>negate</code> looks more cumbersome even compared to the version for <code>Cons</code> / <code>Nil</code> .  It also requires more serious fabrications, when, as writing a ‚Äúnormal‚Äù version, the basics of the OP and mechanical replacement of Haskell ‚Üí C ++ are sufficient.  Therefore, using variadic templates, it is better to write a wrapper for converting the sequence of parameters into the <code>Cons</code> / <code>Nil</code> list, and then using the program to use it already.  So we will be able to set the lists by a pleasant comma-separated listing, and to think in more simple categories. <br><br><h3>  Exit to the outside world </h3><br>  So far, we have considered only values ‚Äã‚Äãand pure functions (the result of which depends entirely on their arguments, and for the same arguments, the function will produce the same value).  To print the result of the program, you need to go beyond the use of both pure functions and calculations at the compilation stage. <br><br>  Upon completion of the calculations in the metaprogram, the resulting expression is interpreted as an entity from the real world and is either saved to a variable or displayed on the screen.  You can use template classes for output.  In the constructor or other methods imperative code is located.  It can be either inside the meta-values ‚Äã‚Äãthemselves (for example, <code>void One::print();</code> ), or inside the meta-function, if the possibilities of the pattern-match are enough to consider all the options.  For example, a <code>print</code> metafunction that prints its argument (one, zero, or a list) at the stage of constructing an instance of <code>print&lt;...&gt;</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class"> {</span></span> print () { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"unknown number"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class"> &lt;One&gt; {</span></span> print () { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"1"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class"> &lt;Zero&gt; {</span></span> print () { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"0"</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-comment"><span class="hljs-comment">// print&lt;Not&lt;Zero&gt;::value&gt;()  "1"</span></span></code> </pre><br>  Similarly, you can display a list and anything.  For example, we could implement AND, NOT, XOR, the binary adder, represent numbers as lists from <code>One</code> and <code>Zero</code> and build addition, multiplication, ... <br><br>  Prior to C ++ 11 and the emergence of <code>decltype</code> it was impossible to carry out purely functional calculations on types, create variables and C ++ objects of the appropriate types, perform calculations on them, and then return to calculations on types. <br><br><pre> <code class="cpp hljs">sum&lt;sum&lt;One, two&gt;, three&gt; <span class="hljs-comment"><span class="hljs-comment">//  -  sum&lt;sum&lt;One, two&gt;, three&gt;() //  -  do_something(sum&lt;One, two&gt;(), three()) //  -  sum&lt;sum&lt;One, two&gt;(), three()&gt; //  , // ..       sum&lt;decltype(sum&lt;One, two&gt;()), decltype(three())&gt; // C++11; </span></span></code> </pre><br>  Of course, this feature allowed us to write ideologically more correct code in C ++ at a lower cost, but it slightly shaken the ideology of the metalanguage of templates.  In Haskell, for example, the function that consumed the poisonous cup of the imperative world remains poisoned by them forever and does not have the right to return ordinary values ‚Äã‚Äãbelonging to the pure world.  That is, the transition from functional purity to imperativeness can be made only in one direction. <br><br>  Before <code>decltype</code> types were an analogy of purity, and values ‚Äã‚Äãwere entities of the imperative world: only a type could be a template parameter, and a type could only be obtained by type conversions;  once creating a value, it was impossible to go back to types. <br><br>  In C ++ 11, you can calculate a certain type, create a value of this type, convert it in some way, and transfer the result type to an expression over types using <code>decltype</code> .  However, <code>decltype</code> does not <code>decltype</code> its argument, but only answers the question "what would be the type of expression if we began to consider it," which does not violate functional purity.  Therefore, as long as the expression above the variables <u>does not leave the <code>decltype</code> bracket</u> , purity is preserved.  From the point of view of the template language, <code>decltype</code> beneficial to use along with operator overloading.  In the following example, the expressions are equivalent, but the bottom one looks less cumbersome: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> sum&lt;sum&lt;one, two&gt;, three&gt; x; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(one() + two() + three())</span></span></span><span class="hljs-function"> x</span></span>;</code> </pre><br>  Going beyond the brackets breaks the purity: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> v = one() + two() + three(); <span class="hljs-comment"><span class="hljs-comment">// v     typedef decltype(v) x;</span></span></code> </pre><br><h2>  Esoteric language translated into C ++ templates </h2><br>  The main problem of C ++ templates as compile-time FIAs is excessive verbosity.  All these <code>::value</code> , parentheses and <code>typename</code> exhaust the programmer and stretch the program code.  Of course, the logic says that one who decides to program in such a style should suffer, but ... this is one of those perverted entertainments to which the IT specialist's brain often leans.  I want to try to do so that the perversion is preserved, but to the extent that suffering can still be endured. <br><br><img src="https://habrastorage.org/web/a39/200/9a4/a392009a4fb14780acb59cc0bc71b170.JPG"><br><br>  In general, I decided to create my own language, which will be translated into C ++ templates.  This can be done in different ways.  You can use even the most ingenious transformations like those made by the JSFuck translator.  But such an approach (a) will generate another unnecessary language, (b) divorced from C ++, (c) that still needs to be invented, and (d) spend energy on implementation.  And to develop and implement a powerful enough and unnecessary FJ is troublesome and useless.  Especially when in C ++ templates there are already constructions equivalent to functions, closures, pattern matching ... And it‚Äôs not sporty either. <br><br>  I chose the path of the most appropriate.  The code in my language should look simple, but remain ideologically similar to C ++.  That is, the transformation should have been the most literal to translate my language into C ++.  He was supposed to be a kilogram of syntactic sugar over the templates. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's rewrite the above pieces of code in the created language, thus having considered its features and their application in practice. </font><font style="vertical-align: inherit;">We will move in the same order from the definition of the values ‚Äã‚Äã"zero" and "one", the function of negating the number, the constructors of the list to the definition of the function of negating the list, FVP map, etc.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Values ‚Äã‚Äãand Functions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To declare a value, the struct keyword is not required: </font></font><br><br><pre> <code class="hljs">One; Zero;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function declaration encloses the arguments and their types in curly brackets, leaving the body behind the "=" sign. </font><font style="vertical-align: inherit;">The descriptions of specific cases are given after the description of the general case and differ in that the specific values ‚Äã‚Äãof the arguments do not indicate the type:</font></font><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> (val x) = Zero; //   <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span> (Zero) = One; //   <span class="hljs-keyword"><span class="hljs-keyword">And</span></span>(val x, val y); //  x,y != One,Zero <span class="hljs-keyword"><span class="hljs-keyword">And</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">And</span></span>(val x, One) = x; // One - , val x -  <span class="hljs-keyword"><span class="hljs-keyword">And</span></span>(val x, Zero) = Zero; // : <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span>(One)  <span class="hljs-keyword"><span class="hljs-keyword">And</span></span>(One, Zero)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++, a template parameter can be a type ( </font></font><code>typename</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), another template ( </font></font><code>template &lt;typename&gt; class</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), etc., and this should be indicated. </font><font style="vertical-align: inherit;">So, creating meta-phwp, one </font></font><code>typename</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can not do, and the requirement to specify the type also goes into my language. </font><font style="vertical-align: inherit;">By default, the type is set </font></font><code>val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to correspond to the usual meta value (structure or normal type in C ++). </font><font style="vertical-align: inherit;">To describe the functions, you can combine types with the arrow ( </font></font><code>-&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">For example, </font></font><code>val -&gt; val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- a unary function (a template that takes one parameter), </font></font><code>(val, val) -&gt; val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- a binary function (a template that takes two parameters), and so on. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I have a little retreated from the literal translation and introduced pseudonyms of types, which have no analogue (pseudonyms of types) in C ++. </font><font style="vertical-align: inherit;">Via</font></font><code>#type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can specify synonyms to shorten the record a little more and clarify the meaning through appropriate naming: </font></font><br><br><pre> <code class="hljs scala">#<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">number</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; #<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>; #<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unary</span></span></span><span class="hljs-class"> </span></span>= number -&gt; number; #<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map_t</span></span></span><span class="hljs-class"> </span></span>= (unary, list) -&gt; list; <span class="hljs-comment"><span class="hljs-comment">// map_t   template &lt;template &lt;typename&gt; class, typename&gt; class</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It can be considered </font></font><code>#type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as an analogue </font></font><code>#define</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in C, which sets textual transformations, which can also be carried out manually in a simple way.</font></font><br><br><h3>  List </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have not canceled a multiple return as a useful feature. </font><font style="vertical-align: inherit;">This comes in handy when implementing the list:</font></font><br><br><pre> <code class="hljs scala"><span class="hljs-type"><span class="hljs-type">Nil</span></span>; <span class="hljs-type"><span class="hljs-type">Cons</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y) { head = x; tail = y; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application of the function to the arguments, being translated into C ++, automatically opens </font></font><code>::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is </font></font><code>f(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equivalent </font></font><code>f&lt;x&gt;::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But </font></font><code>Cons</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it is generated only two Metafields </font></font><code>head</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>tail</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. To prevent the disclosure </font></font><code>::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is required explicitly by using the apostrophe: </font></font><code>Cons(x, xs)'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have been thinking about this problem for a long time. On the one hand, </font></font><code>::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as one of the frequent constructs, it had to open automatically, but there had to be an opportunity to (a) convey an undisclosed value (see the problem of the branch function and infinite recursion above the spoiler) and (b) use other metafields except </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As a result, I settled on ‚Äúshielding‚Äù, recording metafields through a dot, and introduced the reverse ‚Äú!‚Äù Operator for shielding, revealing </font></font><code>::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs pgsql">Cons(x, xs)<span class="hljs-string"><span class="hljs-string">'.head; // x Cons(x, xs)'</span></span>.tail; // xs <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span>(Zero); // One <span class="hljs-keyword"><span class="hljs-keyword">Not</span></span>(Zero)<span class="hljs-string"><span class="hljs-string">'!; // One</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, the meta-field </font></font><code>::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may well coexist with multiple returns. </font><font style="vertical-align: inherit;">Implementing the negation of the list </font></font><code>negate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in C ++, we created local metavariables that could be returned. </font><font style="vertical-align: inherit;">Here is the same, only all values ‚Äã‚Äãare public:</font></font><br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/   : /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -   , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     negate (list list) = Cons(not_head, not_tail)' { h = list.head; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  not_head = Not(h); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   t = list.tail; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  not_tail = negate(t); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ! /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -    negate (Nil) = Nil;</span></span></code> </pre><br><h3>  Higher order functions </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Recall that we declared the types of a unary function and a list and write a map: </font></font><br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/    map (unary f, list list) = Cons(new_head, new_tail)' { h = list.head; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  new_head = f(h); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   t = list.tail; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  new_tail = map(f, t); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    map (unary f, Nil) = Nil;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, instead of </font></font><code>unary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>list</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it was possible to immediately indicate </font></font><code>val -&gt; val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">respectively, but the record would have been longer and less visual.</font></font><br><br><h3>  Closures </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since closures are supported by the C ++ templates themselves, there is nothing unusual here: </font></font><br><br><pre> <code class="hljs scala">f(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x) = { g(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> xs) = <span class="hljs-type"><span class="hljs-type">Cons</span></span>(x, xs)'; } <span class="hljs-comment"><span class="hljs-comment">// : f(x)'.g(list)  map(f(x)'.g, list)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But it is required to give the name (for example, g) of the returned function. </font><font style="vertical-align: inherit;">The nameless function </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returned </font><font style="vertical-align: inherit;">would have to have a name </font><font style="vertical-align: inherit;">and return </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">A member of the same name with a class in C ++ is already given to the constructor, which is why assigning a new meaning to it through </font></font><code>typedef</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leads to a compilation error:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> x&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> xs&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">value</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// value! typedef Cons&lt;x, xs&gt; value; // value! }; };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In C ++, you cannot specialize a nested template, so instead of pattern-matching, you need to use some other mechanisms in the child meta-functions. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ also does not allow reuse of template parameter names within a template. </font><font style="vertical-align: inherit;">Since these names in my language refer to local metavariables and do not go beyond the template, I automated their renaming:</font></font><br><br><pre> <code class="cpp hljs">f (val x) = g(Not(x)) { g (val x) = x; <span class="hljs-comment"><span class="hljs-comment">//    g (x1) = x1 // .. x   template f    x   template g }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This transformation, it seems to me, did not add ‚Äúunsportsmanship‚Äù (due to the possibility of a trivial manual replacement), but life was somewhat simplified. </font></font><br><br><h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At a certain stage, it turned out that the purely functional part is more or less successfully translated into C ++, and we must somehow be able to at least print the result. This part went beyond the framework of the interesting world of templates that I was interested in (because of which I thought less well in the end) and, more importantly, it was described quite well with ordinary C ++. In programs with compile-time computing on templates, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regular C ++</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> without templates </font><font style="vertical-align: inherit;">is responsible for entering the outside world </font><font style="vertical-align: inherit;">. That is, I had to either make my language a superset of C ++, or create my own analogue of C ++. Of course, I chose the first option. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It only remained to enter the tags to insert the code in C ++ and rub their hands with satisfaction. But a logical problem arose: in the source code it is not mentioned anywhere that it is used for the application of meta-functions </font></font><code>::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it is not said anywhere that</font></font><code>f(x)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- it is </font></font><code>f&lt;x&gt;::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but not </font></font><code>call&lt;f, x&gt;::result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This knowledge was stored </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside the translator</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and its use in the program would break through the abstraction:</font></font><br><br><pre> <code class="hljs ruby">f(val x) = One; f(Zero) = Zero; main { print&lt;f&lt;One&gt;<span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-symbol"><span class="hljs-symbol">:value&gt;</span></span>(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ? }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There were few ideas about the uninteresting imperative part, and after scoring a few options, I decided to introduce (a) imperative blocks with the possibility of using the usual C ++ in them and (b) exporting values ‚Äã‚Äãfrom the pure functional world to them. A block </font></font><code>impure {  }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">may appear instead of a value / function declaration, as well as to the right after the "=" sign when a function is declared. In these cases, C ++ code is inserted into the appropriate place in the program. To export an expression, a keyword is placed before it </font></font><code>impure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. From the point of view of C ++, this is equivalent to constructing an object of the type described by the expression. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a demonstration of the work, we will </font></font><code>impure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prepare a list ‚Äúprinter‚Äù:</font></font><br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(val list) { head = list.head; tail = list.tail; impure { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  typedef- head, tail    : <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>() { impure <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(head); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-string"><span class="hljs-string">"print&lt;head&gt;();"</span></span> std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span>; impure <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(tail); } } } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(Zero) = impure { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(Zero) { impure { ...,   <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"0"</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(One) = impure { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"1"</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>(Nil) = impure { <span class="hljs-keyword"><span class="hljs-keyword">print</span></span>() { std::cout &lt;&lt; std::endl; } }</code> </pre><br><h3>  Namespaces </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since in my language in theory it would be possible to create libraries that would be used in ordinary C ++, I ‚Äúthrew‚Äù into it </font></font><code>namespace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>using namespace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ns1</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ns2</span></span> { f(val x) = x; } } <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ns3</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ns1.ns2</span></span>; g(val x) = f(x); }</code> </pre><br> <code>using namespace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is also a necessary measure. </font><font style="vertical-align: inherit;">In C ++, in some cases, not enough of the record type </font></font><code>f&lt;x&gt;::y&lt;z&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>x</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are not specific types / templates, but template parameters, it </font></font><code>::y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">becomes the output of the black box. </font><font style="vertical-align: inherit;">It is necessary to specify what we get in the calculation </font></font><code>::y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- type or pattern (for example, </font></font><code>typename f&lt;x&gt;::y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>f&lt;x&gt;::template y&lt;z&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">I did not automate these instructions and did not implement syntactic sugar for a simpler manual description, therefore each use of a dot causes the appearance of a ‚Äútypename‚Äù.</font></font> Those. <code>f&lt;x&gt;::y&lt;z&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is translated into something incorrect form </font></font><code>typename typename f&lt;x&gt;::value::typename y&lt;z&gt;::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the case of a namespace, this unnecessarily </font></font><code>using namespace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allows you to do without the insertion of "typename".</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lambda </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did not want to leave a functional language without lambda functions. </font><font style="vertical-align: inherit;">Full support could not be implemented, but instead at least you can transfer its function to the other side of the = sign when the function is declared.</font></font><br><br><pre> <code class="hljs scala">f (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x) = y(x) { y(x) = g(x); } <span class="hljs-comment"><span class="hljs-comment">//  f = lambda (val x) -&gt; y(x) { y(x) = g(x); } // </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Full support for lambdas is made difficult by the fact that in C ++ (a) you cannot create an anonymous class and (b) you cannot declare something equivalent to a template without unwinding the description until the type is equivalent to the type. </font><font style="vertical-align: inherit;">Ie, to put it in mathematical terms,</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-29"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30">x</span><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32">y</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7">x = y</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can write, but instead </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">g</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">f</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8">g = f</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will have to use </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-37"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">g</span><span class="MJXp-mo" id="MJXp-Span-39" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">x</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-42" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">f</span><span class="MJXp-mo" id="MJXp-Span-44" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">x</span><span class="MJXp-mo" id="MJXp-Span-46" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9">g(x) = f(x)</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Users of imperative programming have become accustomed to this state of affairs, but by the standards of functional programming it is rather cumbersome. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> x&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    f using g = f; //      //    ,   template &lt;typename x&gt; using g = f&lt;x&gt;; // g&lt;x&gt; - , f&lt;x&gt; - </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To implement the view records, you </font></font><code>map(lambda(val x) -&gt; y, xs)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will have to modify the language and generate templates with temporary names. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As discussed above, </font></font><code>value::value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is a constructor, so it is not possible to directly implement a lambda, which returns a lambda. </font><font style="vertical-align: inherit;">To return functions from lambdas and resolve view records, </font></font><code>g = f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you need to use other concepts and almost completely rewrite the translator.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Disadvantages and possible solutions </font></font></h3><br><ol><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No hiding of local variables. </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is naively solved by inserting </font></font><code>impure { private: }</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">into the code or by elementary modification of the language.</font></font></li><li> <b>     ¬´typename¬ª.</b> <br>  ,      .          (, <code>fMap(fCurry(fCons).fApply(vXs), vObj.vYs)</code> ‚Äî      <code>template</code> , <code>typename</code>  ,      ¬´f¬ª, ¬´v¬ª  ¬´n¬ª ). <br><br>   ‚Äî ¬´ ¬ª.        -     : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   x struct x { typedef internal::value type; //   x }; //   f(x) = x struct f { typedef internal::function type; //   f template &lt;typename x&gt; struct value { typedef typename x::type type; //    f struct result { //   ,   value::value typedef x value; }; }; };</span></span></code> </pre><br>      <code>internal</code>         ;     <code>struct result</code>     <code>value::value</code>      .  - ,           (   ,     ),      (  <code>typedef</code> ),      ,         . </li><li> <b>   :        .</b> <br>     . <br><br>    <code>value</code>    ,        . ,   <code>value::value</code>  <code>value1::value2</code>       : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> x&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> internal::True uses_value1; <span class="hljs-comment"><span class="hljs-comment">//  value1 template &lt;typename y&gt; struct value1 { typedef internal::False uses_value1; //  value2 typedef Cons&lt;x, y&gt; value2; }; };</span></span></code> </pre><br>         ,       <code>uses_value1</code>  ,   <code>value1</code>   <code>value2</code> . </li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Variadic patterns and integers are not taken into account as template parameters. </font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To implement the required support in addition to </font></font><code>val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">other types of numbers ( </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>uint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ...) and arrays ( </font></font><code>[val]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>[int]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>[uint]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...). </font><font style="vertical-align: inherit;">When using metafields, you will have to solve the problem described above with an indication </font></font><code>template</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>typename</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, since </font><font style="vertical-align: inherit;">for numbers, nothing is required, but for types and patterns - required.</font></font></li></ol><br><h3>  Sample program </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As an example, build a list </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-47"><span class="MJXp-mo" id="MJXp-Span-48" style="margin-left: 0em; margin-right: 0em;">{</span><span class="MJXp-mn" id="MJXp-Span-49">1</span><span class="MJXp-mo" id="MJXp-Span-50" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-51">1</span><span class="MJXp-mo" id="MJXp-Span-52" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mn" id="MJXp-Span-53">0</span><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0em; margin-right: 0em;">}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10">\{1, 1, 0\}</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, take its negation in two ways and print all these values ‚Äã‚Äãin </font></font><code>main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="hljs dos">//  : my_list = Cons(One, Cons(One, Cons(Zero, Nil)')')'; negated_list = negate(my_list); negated_list2 = map(<span class="hljs-keyword"><span class="hljs-keyword">Not</span></span>, my_list); impure { int main() { //  : std::cout &lt;&lt; "my list is "; impure <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(my_list); std::cout &lt;&lt; "negated list is "; impure <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(negated_list); std::cout &lt;&lt; "negated list is also "; impure <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(negated_list2); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The program will display the following: </font></font><br><br><pre> <code class="hljs pgsql">my list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, negated list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, negated list <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">also</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>,</code> </pre><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source code of the entire program</font></font></b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">impure</span></span> { #include &lt;iostream&gt; } <span class="hljs-type"><span class="hljs-type">One</span></span>; <span class="hljs-type"><span class="hljs-type">Zero</span></span>; <span class="hljs-type"><span class="hljs-type">Not</span></span> (val x) = <span class="hljs-type"><span class="hljs-type">Zero</span></span>; //   <span class="hljs-type"><span class="hljs-type">Not</span></span> (<span class="hljs-type"><span class="hljs-type">Zero</span></span>) = <span class="hljs-type"><span class="hljs-type">One</span></span>; //   <span class="hljs-type"><span class="hljs-type">And</span></span>(val x, val y); //  x,y != <span class="hljs-type"><span class="hljs-type">One</span></span>,<span class="hljs-type"><span class="hljs-type">Zero</span></span> <span class="hljs-type"><span class="hljs-type">And</span></span>   <span class="hljs-type"><span class="hljs-type">And</span></span>(val x, <span class="hljs-type"><span class="hljs-type">One</span></span>) = x; // <span class="hljs-type"><span class="hljs-type">One</span></span> - , val x -  <span class="hljs-type"><span class="hljs-type">And</span></span>(val x, <span class="hljs-type"><span class="hljs-type">Zero</span></span>) = <span class="hljs-type"><span class="hljs-type">Zero</span></span>; #<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> number = val; #</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> list = val; #</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> unary = number -&gt; number; #</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> map_t = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unary</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">) -&gt; list; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class">; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">x</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">y</span></span></span><span class="hljs-class">; } //   : negate (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">not_head</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">not_tail</span></span></span><span class="hljs-class">)' { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">h</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">not_head</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Not(h)</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">not_tail</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">negate</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">); } //   -    negate (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class">; //    map (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unary</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_head</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_tail</span></span></span><span class="hljs-class">)' { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">h</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_head</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">h</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">new_tail</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">map</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">); } //    map (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unary</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class">; print(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impure</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impure</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">head</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cout</span></span></span><span class="hljs-class"> &lt;&lt; ", "; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impure</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tail</span></span></span><span class="hljs-class">); } } } print(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Zero</span></span></span><span class="hljs-class">) = impure { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cout</span></span></span><span class="hljs-class"> &lt;&lt; "0"; } } print(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">One</span></span></span><span class="hljs-class">) = impure { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cout</span></span></span><span class="hljs-class"> &lt;&lt; "1"; } } print(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class">) = impure { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cout</span></span></span><span class="hljs-class"> &lt;&lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">endl</span></span></span><span class="hljs-class">; } } my_list = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">One</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">One</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class">(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Zero</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class">)')')'; negated_list = negate(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_list</span></span></span><span class="hljs-class">); negated_list2 = map(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Not</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_list</span></span></span><span class="hljs-class">); impure { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">main</span></span></span><span class="hljs-class">() { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cout</span></span></span><span class="hljs-class"> &lt;&lt; "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> "; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impure</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_list</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cout</span></span></span><span class="hljs-class"> &lt;&lt; "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">negated</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> "; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impure</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">negated_list</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cout</span></span></span><span class="hljs-class"> &lt;&lt; "</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">negated</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">list</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">is</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">also</span></span></span><span class="hljs-class"> "; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impure</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">print</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">negated_list2</span></span></span><span class="hljs-class">); } }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code after translation in C ++</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; struct One; struct Zero; template &lt;typename x&gt; struct Not { typedef Zero _value; }; template &lt;&gt; struct Not&lt;Zero&gt; { typedef One _value; }; template &lt;typename x, typename y&gt; struct And; template &lt;typename x&gt; struct And&lt;x, One&gt; { typedef x _value; }; template &lt;typename x&gt; struct And&lt;x, Zero&gt; { typedef Zero _value; }; struct Nil; template &lt;typename x, typename y&gt; struct Cons { typedef x head; typedef y tail; }; template &lt;typename list&gt; struct negate { typedef typename list::head h; typedef typename Not &lt;h&gt; ::_value not_head; typedef typename list::tail t; typedef typename negate &lt;t&gt; ::_value not_tail; typedef Cons &lt;not_head, not_tail&gt; _value; }; template &lt;&gt; struct negate&lt;Nil&gt; { typedef Nil _value; }; template &lt;template &lt;typename&gt; class f, typename list&gt; struct map { typedef typename list::head h; typedef typename f &lt;h&gt; ::_value new_head; typedef typename list::tail t; typedef typename map &lt;f, t&gt; ::_value new_tail; typedef Cons &lt;new_head, new_tail&gt; _value; }; template &lt;template &lt;typename&gt; class f&gt; struct map&lt;f, Nil&gt; { typedef Nil _value; }; template &lt;typename list&gt; struct print { typedef typename list::head head; typedef typename list::tail tail; print() { print &lt;head&gt; (); std::cout &lt;&lt; ", "; print &lt;tail&gt; (); } }; template &lt;&gt; struct print&lt;Zero&gt; { print() { std::cout &lt;&lt; "0"; } }; template &lt;&gt; struct print&lt;One&gt; { print() { std::cout &lt;&lt; "1"; } }; template &lt;&gt; struct print&lt;Nil&gt; { print() { std::cout &lt;&lt; std::endl; } }; typedef Cons &lt;One, Cons &lt;One, Cons &lt;Zero, Nil&gt; &gt; &gt; my_list; typedef typename negate &lt;my_list&gt; ::_value negated_list; typedef typename map &lt;Not, my_list&gt; ::_value negated_list2; int main() { std::cout &lt;&lt; "my list is "; print &lt;my_list&gt; (); std::cout &lt;&lt; "negated list is "; print &lt;negated_list&gt; (); std::cout &lt;&lt; "negated list is also "; print &lt;negated_list2&gt; (); }</span></span></span></span></code> </pre><br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Translator </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I wrote my translator in JavaScript (I love this language, I think it is easier for me to think). I used PEG.js as a parser generator. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When running, the translator (see the </font></font><a href="https://github.com/sekrasoft/cpp-tpllang"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">language page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on GitHub) reads the file whose name is specified as a command line parameter, and outputs the resulting C ++ program text to stdout.</font></font><br><br><pre> <code class="bash hljs">node src/compile &lt;&gt; <span class="hljs-comment"><span class="hljs-comment"># </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as the translator more or less earned and working programs were written, I posted all this stuff on GitHub and, like the mathematician from the anecdote, exclaiming ‚ÄúThere is a solution!‚Äù, Almost lost interest in the development of the project. </font><font style="vertical-align: inherit;">I tried to solve the above problems by alternating / indicating the type / Hungarian notation, but this required serious changes and repeated mental exertion. </font><font style="vertical-align: inherit;">To think, having something ready and working, was laziness. </font><font style="vertical-align: inherit;">Moreover, the principle of maximum compliance could be violated. </font><font style="vertical-align: inherit;">Unnecessary wrappers and code to work with them would have killed the beauty of the straightness of the broadcast and would bring the program closer to exceeding the limit on nesting patterns. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, I stopped at what has been accomplished and will be glad if someone is interested and, perhaps, makes his contribution to the development of the language.</font></font></div><p>Source: <a href="https://habr.com/ru/post/337590/">https://habr.com/ru/post/337590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337578/index.html">How I stopped loving Angular</a></li>
<li><a href="../337580/index.html">The task of rewarding: feel like a manager</a></li>
<li><a href="../337582/index.html">Validating React Components with Livr.js</a></li>
<li><a href="../337584/index.html">India adopted a law on "turning off" the Internet</a></li>
<li><a href="../337586/index.html">The digest of interesting materials for the mobile developer # 220 (September 4 - September 10)</a></li>
<li><a href="../337594/index.html">Balanced B-tree Search Tree (t = 2)</a></li>
<li><a href="../337596/index.html">Jack and Android or the Tale of Earth and Sky</a></li>
<li><a href="../337598/index.html">ggplot2: how to easily combine multiple graphs in one, part 2</a></li>
<li><a href="../337602/index.html">Work and life in Bulgaria. Part two</a></li>
<li><a href="../337604/index.html">Spring: Your Next Java Microfilm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>