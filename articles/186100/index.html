<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple and fast application stress testing framework</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[   ] 

 Web applications under high loads have recently been created more and more, but with frameworks that allow them to test their stress flexibly...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple and fast application stress testing framework</h1><div class="post__text post__text-html js-mediator-article">  [ <a href="http://www.yetanothercoder.ru/2013/07/ultimate-stress-simple-and-fast-stress.html"> </a> ] <br><br>  Web applications under high loads have recently been created more and more, but with frameworks that allow them to test their stress flexibly and add their own logic - not a lot. <br>  There are of course many different ones (see voting at the end of the post), but someone does not support cookies, someone gives a weak load, someone is very heavy, and they are suitable mainly for very single-type requests, i.e.  dynamically generate each request using its own logic and at the same time still as quickly as possible (and ideally on java to finish if anything) - did not find such. <br><br>  Therefore, it was decided to sketch his own, because it is only 3-5 classics in this case.  Basic requirements: speed and dynamic query generation.  At the same time, speed is not just thousands of RPS, but ideally, when stress rests only on network bandwidth and works from any free machine. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Engine </h5><br><br>  The requirements are clear, now you need to decide on what it will all work, i.e.  what http / tcp client to use.  Of course, we don‚Äôt want to use the outdated thread-per-connection model (thread per connection), because we immediately push into several thousand rps depending on the power of the machine and the speed of context switching in jvm.  So  <a href="httpclient-3.x/">apache-http-client</a> and the like are swept away.  Here we must look at the so-called.  non-blocking network clients built on <a href="http://en.wikipedia.org/wiki/New_I/O">NIO</a> . <br><br>  Fortunately, in the java world in this niche there has long been a standard de facto open source <a href="http://netty.io/">Netty</a> , which is also very versatile and low-level, allows you to work with tcp and udp. <br><br><h5>  Architecture </h5><br><br>  In order to create our sender, we need the <a href="http://netty.io/3.6/api/org/jboss/netty/channel/ChannelUpstreamHandler.html">ChannelUpstreamHandler</a> handler in terms of Netty, from which it will send our requests. <br><br>  Next, you need to select a high-performance timer to send the maximum possible number of requests per second (rps).  Here you can take the standard <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ScheduledExecutorService.html">ScheduledExecutorService</a> , it basically copes with this, but on weaker machines it is better to use <a href="http://netty.io/3.6/api/org/jboss/netty/util/HashedWheelTimer.html">HashedWheelTimer</a> (included in Netty) because of the lower overhead when adding tasks, it only requires some tuning.  On powerful machines there is almost no difference between them. <br><br>  Lastly, in order to squeeze the maximum rps from any machine, when any limits on the connections in this OS or the total current load are unknown, it‚Äôs safest to use the trial and error method: first set some outrageous value, for example, a million requests per second how many connections will start mistakes when creating new ones.  Experiments have shown that the maximum number of rps is usually slightly smaller than this figure. <br>  Those.  We take this figure as the initial value of rps and then, if errors repeat, we reduce it by 10-20%. <br><br><h5>  Implementation </h5><br><h6>  Request generation </h6><br><br>  To support dynamic query generation, we create an interface with the only method that our stress will call to receive the contents of the next query: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RequestSource</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> request contents */</span></span> <span class="hljs-function"><span class="hljs-function">ChannelBuffer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><br>  <a href="http://netty.io/3.6/api/org/jboss/netty/buffer/ChannelBuffer.html">ChannelBuffer</a> is an abstraction of the byte stream in Netty, i.e.  here the entire contents of the request should be returned as a stream of bytes.  In the case of http and other text protocols, this is simply a byte representation of the request string (text). <br>  Also in the case of http, <b>it is necessary to put 2 new line characters at the end of the</b> request (\ n \ n), this is also a sign of the end of the request for Netty (it will not send the request otherwise) <br><br><h6>  Sending </h6><br>  To send requests to Netty, you first need to explicitly connect to a remote server, so at the start of the client we start periodic connections with a frequency in accordance with the current rps: <br><pre> <code class="java hljs">scheduler.startAtFixedRate(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Overrid</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { ChannelFuture future = bootstrap.connect(addr); connected.incrementAndGet(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ChannelException e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e.getCause() <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> SocketException) { processLimitErrors(); } ... }, rpsRate);</code> </pre><br><br>  After successful connection, we immediately send the request itself, so our Netty handler will conveniently inherit from SimpleChannelUpstreamHandler where there is a special method for this.  But there is one nuance: a new connection is processed by a so-called.  the main thread (‚Äúboss‚Äù), where long operations should not be present, which may be the generation of a new request, so you have to transfer it to another stream, as a result, sending the request itself will look something like this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StressClientHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannelUpstreamHandler</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ChannelStateEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ... requestExecutor.execute(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ e.getChannel().write(requestSource.next()); } }); .... } }</code> </pre><br><h6>  Error processing </h6><br>  Next is the error handling of creating new connections when the current request rate is too large.  And this is the most non-trivial part, or rather it is difficult to make it platform-independent, since  different operating systems behave differently in this situation.  For example, linux throws BindException, windows - ConnectException, and MacOS X - either one of these, or in general InternalError (Too many open files).  So  on the max-axis, stress behaves most unpredictably. <br><br>  In this regard, in addition to error handling when connecting, in our handler, it is also necessary to do this (simultaneously counting the number of errors for statistics): <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StressClientHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannelUpstreamHandler</span></span></span><span class="hljs-class"> </span></span>{ .... <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exceptionCaught</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, ExceptionEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ e.getChannel().close(); Throwable exc = e.getCause(); ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exc <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> BindException) { be.incrementAndGet(); processLimitErrors(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exc <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> ConnectException) { ce.incrementAndGet(); processLimitErrors(); } ... } .... }</code> </pre><br><h6>  Server responses </h6><br>  Finally, we must decide what we will do with the answers from the server.  Since this is a stress test and only throughput is important for us, it remains only to read the statistics: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StressClientHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannelUpstreamHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">messageReceived</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, MessageEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ... ChannelBuffer resp = (ChannelBuffer) e.getMessage(); received.incrementAndGet(); ... } }</code> </pre><br><br>  There may also be a count of types of http responses (4xx, 2xx) <br><h6>  All code </h6><br>  All code with additional buns like reading http templates from files, templating, timeouts and so on.  lies in the form of a finished maven project on <a href="https://github.com/yetanothercoder/ultimate-stress">github (ultimate-stress)</a> .  There you can also download the <a href="https://github.com/yetanothercoder/ultimate-stress/releases">finished distribution</a> (jar file). <br><br><h5>  findings </h5><br><br>  All of course rests on the limit of open connections.  For example, on linux, with an increase in some OS settings (ulimit, etc.), on a local machine, it was possible to achieve about 30K rps, on modern hardware.  Theoretically, in addition to the limit of connections and the network, there should be no more restrictions; in practice, the jvm overhead costs are still felt and the actual rps is 20-30% lower than the specified one. </div><p>Source: <a href="https://habr.com/ru/post/186100/">https://habr.com/ru/post/186100/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186086/index.html">Google has released a patch for the vulnerability in Android</a></li>
<li><a href="../186088/index.html">A little bit about managing HTPC</a></li>
<li><a href="../186092/index.html">Tablet for the elderly. Part two</a></li>
<li><a href="../186096/index.html">PC makers will get Windows 8.1 at the end of August</a></li>
<li><a href="../186098/index.html">Should I put Gentoo for the sake of acceleration?</a></li>
<li><a href="../186102/index.html">Published draft HTTP 2.0 specification</a></li>
<li><a href="../186104/index.html">New technology Ford allows you to "print" car body in a matter of hours</a></li>
<li><a href="../186112/index.html">Grand Theft Auto V - familiarity with the world of the game</a></li>
<li><a href="../186114/index.html">Android phones on Jelly Bean are already more than on Gingerbread</a></li>
<li><a href="../186116/index.html">Already a very small survey clarifying the relationship of habrasoobschestva to GMOs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>