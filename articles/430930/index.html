<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About 3D graphics in simple words</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1. Introduction 
 Hi my name is baldurk. I‚Äôve been working as a graphics programmer for several years now, so although I‚Äôm by no means an expert,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About 3D graphics in simple words</h1><div class="post__text post__text-html js-mediator-article"><h2>  Part 1. Introduction </h2><br>  Hi my name is baldurk.  I‚Äôve been working as a graphics programmer for several years now, so although I‚Äôm by no means an expert, it seems I already understand a lot about everything related to working with graphics. <br><br>  The idea of ‚Äã‚Äãthis series of posts has long been hovering somewhere on the periphery of my mind, and re-emerged after reading an <a href="http://www.adriancourreges.com/blog/2015/03/10/deus-ex-human-revolution-graphics-study/">interesting article with an analysis of the latest Deus Ex</a> . <br><br>  It seems to me that the graphics, and especially the complexity that it reaches in modern games - this is an interesting topic.  Very few people are curious to immerse themselves deeply in all its details, but I believe that there are topics that are interesting to everyone.  I think that most of the people who played the games were curious about how certain effects are obtained, or with what technology they managed to create such amazing graphics in some new game. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c8/3b9/2ad/4c83b92ad325af58966fc3742aa85a10.jpg"></div><br>  <em>There are many components needed to create even a simple 3D game, not to mention a project like Watch Dogs.</em> <br><br>  I only have a general idea of ‚Äã‚Äãwhat needs to be covered in this article, but it will depend on which topics are of interest.  However, the basic idea is to create a general description of what is going on inside a modern game, without scaring any readers away - I will assume that you do not have knowledge of mathematics and programming.  If you know the difference between the CPU and the graphics card, and distinguish the RAM from the hard disk, then this will be quite enough, and I will explain the rest. <br><a name="habracut"></a><br>  This article will be developed in accordance with its video <a href="http://chipandironicus.com/videos/dog/">passage Chip &amp; Ironicus' to play a</a> little bit of structure.  The game is well known for its graphics (and opinions about it can be completely opposed), and there are many aspects to it that can be considered with some examples.  Perhaps I will talk about other games. <br><br>  I will begin by explaining the basics, which are almost the same for each game, but I will also consider some of the techniques and visual effects of Watch Dogs. <br><br>  I will use a tool called <a href="https://github.com/baldurk/renderdoc">RenderDoc</a> , which I wrote in my spare time.  It is used to debug problems with graphics - the tool allows you to decompose a frame of graphics into parts, and thanks to this we will see how it comes together. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//OBaA9JD/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>This animation shows a part of a gradually created frame in the process of drawing it with a graphic card.</em> <br><br>  Most people know that computer graphics (and any other video graphics) consist of a series of still frames, each of which is displayed for a certain fraction of a second.  In the cinema, traditionally used 24 frames per second (frames per second, FPS), in television the frequency is about the same, about 24-30 frames.  In games, FPS can be changeable, because a lot of work is done in every frame.  Falling below 30 is undesirable, although it happens quite often.  Usually the upper limit for console games is 60 FPS.  Developers tend to realize the frequency of 30 or 60, which depends on the goals of the game.  On a PC, with a high frame rate display, you can achieve 90, 120, or even higher.  The reason for these particular numbers is vertical synchronization (vsync), which we describe below. <br><br>  Mentally, we can look at this task from the opposite side - instead of looking at how <em>high the</em> FPS frequency is, we look at how <em>short the</em> time allocated for each frame is.  If we want the game to work at 30 FPS, then we have only 33 milliseconds to do all the work necessary for the frame.  At 60 FPS, the time is two times less ‚Äî about 17 milliseconds.  Even for a computer, such a period of time is not very large, given the amount of work that needs to be done.  To give you an idea of ‚Äã‚Äãthe values, the bullet is estimated to move about 1 meter per millisecond. <br><br>  Basically, we will talk about the PC, because this platform is open, and I can‚Äôt talk about consoles without fear of violating non-disclosure agreements (NDA).  Anyway, basically, I will talk about what is not very different on consoles, and if something is different, I‚Äôll emphasize it.  As for mobile platforms, most of the differences between PC equipment / consoles and mobile equipment are not related to the topic of my article. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8a/414/db8/d8a414db8e56c45fae566b8da11316e2.jpg"></div><br>  <em>Honestly, I put this picture here so that you understand that the article will not only have text.</em> <br><br>  This is the task that interests us - we will not worry about how all the AI ‚Äã‚Äãcalculations are performed, or how a physical simulation is performed to move objects.  The boundaries of the discipline called ‚Äúgraphics programming‚Äù are rather blurred, but I will say that graphics programming begins when we have all the information necessary for building a frame: we know what happens, all the textures and models are in memory (not on disk ), the animations are already animated, the physics is counted, and it remains for us to render the finished frame for display on the screen. <br><br>  I‚Äôll add that I‚Äôll look at a 3D game with fairly traditional rendering, like Watch Dogs - many of the basic principles apply to 2D games, but it‚Äôs a little harder to demonstrate concepts on them.  I will also explain (especially to programmers of graphics) that I primarily strive for understanding, therefore, I will probably use rather dubious explanations if they allow me to achieve my goal. <br><br><h2>  Part 2. What is the frame </h2><br>  Most of the time, we will consider only one frame and talk about the building blocks that the game uses to create the finished frame.  Also in this part there will be some new beautiful pictures. <br><br>  There are several ways in which a frame is assembled from building blocks.  The finished image that the player sees is not instantly drawn.  It was immediately drawn many years ago, but in modern graphics engines almost always some kind of preliminary processing is used.  Before displaying the finished frame on the screen, the graphics engine renders many intermediate images of various types that help in the calculation of the final image. <br><br>  These images are highly dependent on the type of engine and on the techniques that the graphics programmer needs to apply.  For example, if he wants the sunlight to create the correct shadows, then one type of image is required for the shadows.  Also, he may need the right reflections on the controlled player car, and for this, too, need another image with reflections. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/874/47d/95e/87447d95ee62161dc63df6e3dd2406f5.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3b/9ec/b69/a3b9ecb6984a5aae18fd57d8c2f4a9f2.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e6/bd2/ff7/1e6bd2ff7c49373dc337d20c0fe2a66a.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/5cb/65d/fa45cb65dfcb2042ecfd06ef6c463022.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d9/4ed/937/3d94ed937c68dd821ab21c4a1a1cf4fb.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a57/360/2e8/a573602e8f7b69fa3868df93eebc776f.jpg"></div><br>  <em>Various examples of intermediate images used in the construction of the frame Watch Dogs.</em> <br><br>  In this article I will not consider each of the images used in the frame of Watch Dogs, but I will only tell you about the main ones so that you can learn something.  This is an area in which graphics are constantly being researched and new techniques are emerging.  Innovations also arise at smaller levels, but when marketing tells you about some kind of new graphical function, it is usually these improvements that are meant. <br><br><hr><br>  Each of these intermediate images is also built from even smaller fragments.  Each object in the scene or a group of related objects is created separately as a <em>textured model</em> .  When designing a game, artists build these models in a 3D editor and create all the necessary resources for them.  Then these models are placed in the world with the help of a level editor and a virtual city is gradually built from them. <br><br>  Probably, this is known to almost everyone, and if during the last 20 years you have watched the development of real-time 3D graphics, you know how much more complex the models have become today.  At the very first stages of the formation of graphics, the imposition of textures was a costly process, and, if possible, they got rid of it, painting objects with the same color.  Textures were left only for elements such as eyes or faces that really needed detailing. <br><br>  The 3D model consists entirely of interrelated triangles that form the shape of an object.  Each triangle has three points, called vertices, and since the triangles are connected to each other, the vertices can be common to several triangles.  We'll come back to this later, because vertices and triangles are important enough.  It is also worth remembering that some objects, such as characters or trees, must be animated before rendering.  The model is created in the standard static form, and the animations are applied in each frame.  We will return to this too. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/357/03d/382/35703d382d727d1e395283a4fb3aae33.jpg"></div><br>  <em>This is a 3D model of Aiden Pierce's head after animating.</em>  <em>Triangles are visible because they are drawn flat, and not smoothed, as is usually the case.</em> <br><br>  To add more details to a 3D model, textures are superimposed.  Textures are ordinary flat image files, usually square or with simple dimensions, for example, rectangles with a 2: 1 ratio.  Textures are superimposed on a 3D model using a more complex process, which I will discuss in more detail below, but conceptually it is similar to the process of wrapping a gift.  Instead of a simple repeating pattern of a paper wrapper, the image exactly matches the size of the wrapper.  If you have seen paper models for assembly with glue, the principle here is the same. <br><br>  This analogy is more appropriate than one might think, because these textures are usually created by ‚Äúunfolding‚Äù a 3D model into a flat blank, as is done with a paper model, after which a texture is drawn on top of it.  This deployment is often done automatically, but in the case of particularly complex objects it can be done manually. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/1f7/cf0/b9f1f7cf0d34680c8f313ad11691656f.jpg"></div><br>  <em>This is the texture corresponding to the Aiden Pierce head model shown above.</em>  <em>There are parts for the teeth and tongue.</em>  <em>Note that the area above his forehead is not textured because it is permanently closed by Aiden Pierce Legendary Baseball Cap ‚Ñ¢.</em> <br><br><blockquote><h4>  Note </h4><br>  When deployed, some parts of the object that require more detail increase, while others decrease. </blockquote><br>  Very often people talk about different ‚Äúskins‚Äù of models, especially in the case of custom characters.  Today, what is called a ‚Äúskin‚Äù usually refers to small changes in the model ‚Äî a new belt or other hat ‚Äî but this term originally arose because the same model was used, but the texture (or ‚Äúskin‚Äù changed) literally means "Skin") to create a character that looks different.  Even today, with the help of such textures, you can create a large variety of NPC or objects, which saves time and money - you do not need to create a lot of unique 3D models.  Different clothes that Aiden can wear are most often just different textures of the same model. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//8ItIFRj/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Here is a brief fragment of the head rotation of the 3D model.</em>  <em>Imposed only texture, and nothing more.</em> <br><br>  In the frame we are examining there are approximately 1700 objects drawn in the part of the main rendering.  Some of them will be the same models - objects such as flowers in pots and garbage cans are never actually created individually; they are one model or several models placed in different places.  However, the approximate number of objects drawn to complete the frame is close to <strong>4700</strong> - this gives us an idea of ‚Äã‚Äãhow much additional work needs to be done in addition to drawing all these models. <br><br>  Let's look at another example of an object - a baseball cap that Aiden wears. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa2/1ce/636/aa21ce63666b4636b76ebe062f7536ca.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f7/4d3/b93/0f74d3b9305c6ed4572a5bc55d178a11.jpg"></div><br>  <em>This is a texture and textured model of a baseball cap.</em>  <em>It can be seen that the texture is built from separate parts that are combined on the model.</em> <br><br><blockquote><h4>  Note </h4><br>  The visor and the main part of the baseball cap on the texture does not touch, because the scan can be quite complicated and, if necessary, can be performed in several different parts.  Sometimes, texturing a complex shape without visible problems and seams requires considerable skill. </blockquote><br>  The same principles that we saw in the case of Aiden‚Äôs head also apply to the cap.  In fact, if we abstract away from the concrete texture and the numbers needed to perform the unfolding, then the principle is always the same. <br><br>  To show what can go wrong during development, and demonstrate how to have fun while programming graphics, we can do a little experiment.  Since most textures have a standard square size, and the method of wrapping and unfolding textures on the model is also the same, then why not play with them a little?  What happens if we apply Aiden's head texture to a baseball cap model? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/212/1b1/5c7/2121b15c7f8355575864f9333c9eeab0.jpg"></div><br>  <em>Already not very much like Aiden Pierce Legendary Baseball Cap.</em> <br><br>  Where there was a logo on the baseball cap texture, ear and teeth are located on the head texture.  Where there was a visor, only hair is on the texture of the head.  The overlay is made exactly the same, but a different texture is used.  Of course, this example will be a mistake in the game, but think about what you can do if you animate a texture or make it flicker - in games such things are used for various effects that you can now notice.  In particular, the game Saint's Row 4 uses a similar for the special effects of "simulation". <br><br>  It will also be useful to think about the consequences of this - the games very carefully combine pairs of models and textures, that is, the most unique models should match their own unique textures. <br><br>  Of course, this rule is not absolute - in some cases, to save space, texture is a standard repeating pattern that can be used for many objects.  Associated sets of objects ‚Äî for example, newsstands ‚Äî can use the same texture for different newspapers, with each newspaper occupying a small portion of the texture. <br><br>  However, this means that to build the final image, you must have all the building blocks, that is, as a result, you can get a lot of mandatory models and textures.  In the next part we will talk about why some aspects, such as reflections, are very difficult to implement correctly.  I will also talk about how games use small tricks to save time and resources. <br><br><h2>  Part 3. What you do not need to draw </h2><br>  Often, graphics programming is the task of balancing a dozen different constraints to achieve the perfect compromise.  In the last part, we saw that each time a scene was drawn, it was assembled from many small building blocks - people, cars, road signs, buildings.  Everything on the screen is made up of individual components that need to be drawn.  There are several subtle balancing operations that we will look at here. <br><br>  Above the drawing of the frame are working together the CPU and graphics card.  The rest of the game is executed in the CPU, so it decides which objects should be drawn in the current frame, where the camera is looking, and which animations are played.  A graphics card is a ‚Äúworkhorse‚Äù that does all the hard work involved in drawing pixels, which is why it is a separate, specialized device. <br><br>  It turns out that both the CPU and the graphics card have restrictions on the speed or amount of computation, but these are different types of restrictions. <br><br>  In general, the CPU is more interested in its own part of the work: how many objects do we need to draw everything?  How <i>different are</i> these objects - are they 100 identical lamps, or 100 bushes / plants / trees?  Are these objects animated, moving dynamically, and which of them are static or fixed? <br><br>  The first thing we do is to reduce the load as much as possible - we draw only what is visible on the screen.  This seems obvious, but implementation requires careful work.  Do not forget that we are building each frame from scratch, so <i>in each frame</i> we need to look at each object and determine whether we see it or not.  This means that in each game there is a black void, following the player everywhere, and when he does not look at objects and people, they cease to exist. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//bmSqTLe/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>In this animation, we turn the camera on, showing the emptiness behind the player.</em>  <em>Attentive viewers will notice that it is not completely empty ...</em> <br><br>  In this case, it is difficult to work out some practical rules, but in general, about 1000 objects can be drawn in the scene without worrying about the lack of space.  However, if you need to render 5,000 objects, then you should think about applying tricks.  Do not forget that in most games where the player can control the camera, we cannot know at what angle he looks, so you need to save room for maneuver. <br><br>  It turns out that there are quite a few tricks that make it possible to use the permitted resource almost completely, and they are especially important in games like Watch Dogs.  The closer you get to the borders and the more visual quality you can get from the same number of objects, the better the game will look. <br><br>  Even if you look at what is in front of you in the scene, this does not mean that it is necessary to draw the entire city completely.  If there is a huge building on the left or on the right, everything becomes invisible behind it, so you can not draw it.  Similarly, some objects in the distance become very small, so we do not need to worry about drawing tiny plants and shrubs in the distance. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//auvvQ67/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>This animation shows that if you walk down the street beyond what we see, then there is nothing in the side streets, but at a great distance there is less detail.</em> <br><br>  In fact, there are still many objects in this scene that will end up invisible.  There is still much to explore in this area and it is necessary to apply various complex techniques.  You always have to make compromises, but if you can spend a little time, or come up with a very smart way to avoid drawing 100 objects with almost no extra effort, then we can make the scene even more complex or denser than the full. <br><br>  There is also another minor issue.  In some cases, we have to draw a building that is barely visible on the screen and goes far beyond its limits.  It wastes resources in vain.  We can always break these objects into several parts, then each part can be drawn or skipped, that is, there will be less waste.  However, now we have increased the total number of objects drawn when they <i>are</i> on the screen, and created the opposite problem! <br><br>  This example is one of hundreds, but it is easy to explain what decisions you have to make and which experiments to make in order to find an ideal equilibrium point for each game. <br><br>  Since the action of our frame from Watch Dogs takes place in the city, we can look at it from above to understand approximately what exactly is drawn.  In this static picture, it is especially noticeable that Watch Dogs performs work quarterly. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//My8bi1m/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>Now we move away to show the visible area in front of the camera (sorry for mounting to save time).</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/719/960/135/7199601359a0d421147d9f632061bfaf.jpg"></div><br>  <em>An approximate camera view area is superimposed on the image.</em>  <em>The width of this triangle depends on the field of view (Field of View) - sometimes this is an adjustable option in games, sometimes a constant value.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ccf/5ff/d45/ccf5ffd455dccf7098393602c9944139.jpg"></div><br>  <em>Here is a wireframe scene display, the camera's scope is limited to white.</em> <br><br><hr><br>  Some of you have already thought of a little trick that would allow you to bypass the limit on drawing a certain number of objects - why not make objects a very complex combination in just a small area, down to individual leaves?  Then drawing 1000 objects will be more than enough. <br><br>  But here we are faced with a completely different set of constraints - graphics cards have limited performance, and the more complex the object, the longer it will take to render it.  That is, even one object, if it is rather complicated, can reduce the frame rate of the game to 20 FPS.  Including why I said that the limit on the number of objects is quite fuzzy. <br><br>  The amount of time spent on an object depends on the complexity and detail of the models and textures, as well as on the sophistication of lighting and shadows.  That is why games that try to implement more complex or sophisticated graphics tend to use less complex and detailed scenes - balancing the scales in one direction or the other, so you can secure more room for maneuver by sacrificing what is not so important for the game. . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45f/2d5/233/45f2d5233fe8bd806ab2fbf18baa038d.jpg"></div><br>  <em>This is a kind of heat map showing which parts of the scene are particularly complex models.</em>  <em>Notice how many problems trees and vegetation can cause.</em> <br><br>  There is another set of techniques called "levels of detail" (level of detail, LOD), which is specifically designed to solve such problems.  Similar to the fact that we can optimize the number of objects, cutting off all unnecessary, we can increase the supply of "complexity" by eliminating unnecessary. <br><br>  One of the techniques is actually well known - this is a change in the resolution of textures.  This topic is usually intersected with many others, so I will try to explain it is available. <br><br>  Textures in games are usually rectangles with sizes equal to the power of two - 512, 1024, 2048, 4096. There are many reasons for this, but one of the advantages of this is that you can take a texture of 1024x1024 and easily create its reduced version of 512x512 . <br><br>  For the reasons I will discuss below, it is always necessary that the texture has all sorts of smaller versions.  That is, a 1024x1024 texture will have smaller versions of 512x512, 256x256, 128x128, 64x64, 32x32, 16x16, 8x8, 4x4, 2x2 and 1x1.  However, one of the advantages of this is that if distant objects have a small size on the screen, then applying a texture of 1024x1024 on them means wasting resources.  We can save by using smaller versions of the same texture. <br><br>  Similarly, even close objects can be considered not very significant and use smaller textures for them. <br><br><blockquote><h4>  Note </h4><br>  Usually, when a player approaches an object, the greatest texture is used, but as most people saw in one game or another, this does not always happen and the textures look too blurry before loading.  This usually happens because textures cannot be loaded from a DVD or hard drive immediately into the memory of a graphics card for rendering.  Most often this happens when a player dramatically changes his position, for example, during respawn, loading a new level or very fast movement.  In all other cases, textures are usually loaded gradually, in the process of moving a player around the world. </blockquote><br>  You can also apply this simplification process to the models used in the game, although it is much more difficult to do this.  Creating simplified versions of complex objects, one can make it so that at a great distance they do not eat off a part of a limited margin of complexity. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to simplified objects and cropped models, you can save a lot and this approach has to be used in any game like Watch Dogs. </font><font style="vertical-align: inherit;">But at the same time, it can be a huge waste of resources. </font><font style="vertical-align: inherit;">It is necessary to make a very thoughtful and balanced decision on how much simplified versions of models will be required. </font><font style="vertical-align: inherit;">If there are too few of them, then either you will not be able to save too much, or there will be noticeable quality jumps when changing them. </font><font style="vertical-align: inherit;">If there are too many of them, then you will take up the memory in vain and spend the man-hours needed to create the objects.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/801/f01/9ed/801f019ed8c365cfebbbeea2320bf3d7.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is how complex objects and characters look at a distance when they are indistinguishable from their highly detailed versions.</font></font></em> <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope you now have some insight into the problems that graphics programmers, artists and level designers encounter in trying to combine maximum graphics quality with high speed. On consoles, this equation is slightly easier to solve than on a PC, because the equipment is unchanged.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the previous part, I said that I will talk about why it is very difficult to properly implement reflections and other similar things. The reason is quite simple - the performance reserves and resources that I constantly talk about do not change depending on whether you have reflections or not. If you want to create a reflection that can display the whole scene again, then you have to re-do all the work that I was talking about. In addition, reflections are very dependent on the angle at which we look at them, so they must be their own to get accurate reflections from each reflecting object!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This can get out of control very quickly, and usually games with reflections allow themselves certain liberties or assumptions. Games very rarely create reflections in complex environments, the maximum that it can be is a mirror in the bathroom, where there are not so many objects, the complexity of the scene is small, and therefore you can afford extra expenses. Perhaps the true reflections in the game will only be on uneven or wavy water surfaces, so that even a very rough and low-detailed scene is quite enough to create convincing reflections.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is usually difficult to completely avoid reflective surfaces, so the games use pre-rendered images of the nearest environment, which gives a ‚Äúgood enough‚Äù result. But they do not withstand close study, and if you look closely at the reflections, you will see that it is an imitation. There are modern techniques that help create reflections in certain conditions, and maybe later I will tell about them, but such pre-rendered (‚Äúpre-rendered‚Äù) images are still needed.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06c/9bd/b94/06c9bdb94b41c1a83b7d574cdf90f449.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This pre-rendered image is called a ‚Äúcube map‚Äù. It‚Äôs not quite accurate as to where Aiden stands, but close enough to him.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Watch Dogs renders reflections in real time. I have not investigated this question in detail, but I believe that they are always rendered when a character is on the street, and are mainly used to get his exact reflections on the car in which he sits to improve the image and give it a slight sense of reality. . Since the player is always focused on his car and the immediate environment, the fact of incorrectness of reflections on other cars is barely noticeable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are many approximations to speed up the rendering of these reflections. For example, in reflection, a lot less objects are rendered than there are in the real scene ‚Äî about 350 in total ‚Äî and many of them are very simplified compared to the full versions. I suspect that complex objects, such as people, are completely discarded, regardless of distance, but I have not tested this theory. In addition, there are no shadows on these objects, and the lighting is very simple - just what comes from the sun and sky. Reflections are rendered from the ground as in a fisheye lens, that is, reflections of the earth itself are impossible, and what is next to it has very low details.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But even with all these simplifications, reflections only deal with what was intended. </font><font style="vertical-align: inherit;">If you drive under the rails, you can get the right reflection with a view over the car, which in practice could not have been achieved. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This decision was intentional and not easy. </font><font style="vertical-align: inherit;">The stock is a constant value, so if you leave room for these reflections, then you need to sacrifice something else.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ab1/cda/fcd/ab1cdafcde2ca5c15111ca30f5b6bb5f.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a very "fake" image of the scene around Aiden with a bottom view made for reflections. </font><font style="vertical-align: inherit;">You can navigate through the two lanterns and train rails.</font></font></em> <br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is another part of the work that I want to mention here - the shadows. Later, I plan to talk about how the shadows work, because this is an interesting topic, but now the most important thing is to remember that the shadows are very similar to reflections. Each light source casting a shadow must render an image of the scene from its point of view. This time there are not so many ways to simplify the work - each source of lighting </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> have this image </font><font style="vertical-align: inherit;">to correctly calculate shadows </font><font style="vertical-align: inherit;">.</font></font><br><br><blockquote><h4>  Note </h4><br>      ,    .           ,      ¬´¬ª  ,             .         ,  ,        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The most obvious and most significant source of shadow-giving illumination is the sun (or the moon, if it happens at night). </font><font style="vertical-align: inherit;">Since the sun is huge, 3-5 images are usually rendered for it, and not one, as in the case of headlights or a flashlight. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, this is one of the cases when Watch Dogs cannot be a good example. </font><font style="vertical-align: inherit;">The calculation of shadows in the game is rather complicated and, it seems to me, specially optimized for the case of shadow casting in the city. </font><font style="vertical-align: inherit;">Therefore, I would rather switch to Far Cry 4 and consider the calculation of shadows using the example of a frame from this game.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21c/4a4/ae6/21c4a4ae665924ba44245b8e18249f8b.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is a scene from Far Cry 4 that I use just for example.</font></font></em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ae/502/26c/7ae50226c3cc0c40c916c58f26ba27f3.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is an image with information about the shadows of this scene - each of them requires a completely new rendering of the scene.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> So when we need to add shadow casting to the light source, we have to render the scene one more time. Here you can also use some of the approximations used in the case of reflections, only they are much smaller. You can skip small or distant objects, but you need to consider that these objects will seem not to cast shadows. You can render the image very small, but then the shadows will be grainy and low detail. Usually it is impossible to use a very simplified version of the object, because then it will seem that the object casts a shadow on itself, or gaps appear between the object and its shadow.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another consequence that is very easy to miss is the need to create a shading image for each light source. In many cases, it is possible to simplify the sources of lighting by combining them - in Watch Dogs this happens with car headlights. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When both lights are turned on, only one light source is drawn, but with a special shape, because of which it looks like two beams. If the headlights have shadows, then this is not so easy to do, and it will be much more noticeable - when the player passes in front of the car, the light will come from somewhere between the two headlights. Perhaps, then you have to split the headlights, but not only will there be additional costs for calculating the shadows, but also have to draw new lighting.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The main thing that I wanted to emphasize to all this is compromises. </font><font style="vertical-align: inherit;">We can definitely get rid of all these approximations, but we have to spend our resources on it, that is, to sacrifice something else. </font><font style="vertical-align: inherit;">Each game developer must decide what it is important for him to focus on in the game, and what will be the most impressive or most annoying to the player.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Part 4. Move the vertices. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this part, I will discuss in more detail the technical details of animating objects in the scene. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphic programmers often talk about the "graphics pipeline". 3D graphics are a bit like an assembly line with a clearly defined movement from one stage to another, but it does not work simultaneously with only one object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All modern graphics cards have approximately the same conveyor, they have special equipment and software, stitched directly "in silicon", for maximum acceleration of the conveyor. Of course, there are many variations between different manufacturers and graphics card families, but usually we don‚Äôt need to worry about </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> they work at this level.</font></font><br><br><blockquote><h4>  Note </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are interested in how everything works on an abstract hardware level, then I recommend </font></font><a href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fabian Gisin's series of articles on the graphics pipeline</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This series of articles is </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">much</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> more detailed and requires much more understanding than my post.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will skip many details to explain interesting and important principles. </font><font style="vertical-align: inherit;">In this part we will look at the first part of the pipeline, which is called the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúvertex shader‚Äù (Vertex Shader)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shaders became widespread about 16 years ago, after the release of DirectX 9, in which vertex and pixel shaders appeared. </font><font style="vertical-align: inherit;">To explain what shaders are and compare them with what was previously, I will talk about the work they are doing.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/357/03d/382/35703d382d727d1e395283a4fb3aae33.jpg"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aiden‚Äôs framed head is back with us.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let me remind you that in part 2, we considered the models from which the game world is created. These models consist of individual points, called vertices, which are connected in triangles. I said that I will tell you more about them later, and now I keep my promise. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since everything in the game world consists of vertices, then everything that needs to be done with these models must be performed with vertices. When it comes to a graphics card, all it sees is a long list of vertices. For her, there are no such things as running animation, or swaying leaves of trees, or any other abstract concepts. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's look at a simple example of what we have to do - the movement and location of objects in the world. First, take a simple case, not a character.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When creating objects in 3D editors like Maya and 3D Studio Max, artists always build from in their own separate world. These objects are not created immediately in the Chicago entourage; rather, their surroundings look like an ‚Äúempty white room‚Äù from the Matrix. Each object is located in the center of absolute emptiness.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd0/a55/a3c/bd0a55a3c96f5fefc237bdf22194e009.png"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is some kind of traffic light in the game somewhere under the rails, and it is located in its own world.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When saving to disk, the model has no idea where it will be in the world and when it will be downloaded and transferred to the graphics card. This means that when it is time to draw objects, we need to move it from our own world to the scene that we draw. This happens with each object being drawn, and even such fixed objects as buildings and bridges also move from their own world to the scene in each frame.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d65/21d/673/d6521d67344753566d0d2b4ff3b4fbf9.png"></div><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we see several traffic lights already placed in a partially constructed final scene.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As I mentioned above, the only thing we can work with is vertices. We can't just say to the graphics card: ‚ÄúCan you put this traffic light under the bridge? And then put another one a little further? Great! ‚Äù </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, instead of telling the graphic map what it needs to do with the object itself, we need to say what to do with all its vertices. It turns out that in this case, everything becomes very simple. If we change all the vertices in exactly the same way and they remain stationary relative to each other, then this is similar to moving the object as a whole. All we need is to figure out what ‚Äúchange‚Äù is, which is called transformation.</font></font><br><br><blockquote><h4>  Note </h4><br>       ,     .      , , ,    ‚Äî        . </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before the appearance of vertex shaders, the possible options for converting vertices in a graphics card were very limited. Moving and turning objects were available, as well as some other operations, but nothing particularly unnecessary or difficult. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vertex shaders are small computer programs running on a graphics card. They take one vertex, perform </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any necessary actions</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with it </font><em><font style="vertical-align: inherit;">,</font></em><font style="vertical-align: inherit;"> and output the output vertex. They can not only move it, but also make it jump down and up, move away from the nearest peak, swing depending on the wind, animate and much more.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I took one of the vertex shaders that are used in Watch Dogs, and experimented a bit with it to show what it does. This is quite a painstaking job, but I managed to find the vertex shader used for the characters and change it. There is another vertex shader used for skin, for example, for faces and hands, but you will quickly understand the principle.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//Wqyv7B8/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I made a very simple change that adds a bend to the character models, but everything else is used as usual. </font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the animation shown above, you can see that the characters are somehow strangely distorted. </font><font style="vertical-align: inherit;">This brings us back to the principle of ‚Äúif you move each vertex, then this is similar to moving the entire object‚Äù. </font><font style="vertical-align: inherit;">The change made to the vertex shader only works for one vertex at a time, but since they all work with the same distortion, the effect is applied to the entire object as a result.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also make changes to the part of the transformation that is responsible for ‚Äújust moving into place‚Äù so that instead of placing the character in the right place, she raises him above the ground. </font><font style="vertical-align: inherit;">This is not simulated with the help of physics, so it has nothing to do with gravity or collisions with other objects - if you wish, we can make everyone float in the air.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//tktCaw4/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this animation, we forced the vertex shader to gradually raise and lower the object.</font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Obviously, all this is not very constructive, but it gives us a general idea of ‚Äã‚Äãhow vertex shaders work - if now we wanted to animate the leaves on the trees so that they sway, they would do about the same. Only instead of raising and lowering they would swing in the direction of the wind. Then we can change the strength of the wind so that the trees swing more or less.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//5Sl1uhw/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we see what happens when everything increases about seven times. </font></font></em> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I simplify a little, but the main task of most vertex shaders is ‚Äúmoving objects into place‚Äù. </font><font style="vertical-align: inherit;">The exception is all animated objects - people, animals, as well as items such as rocking ropes, flowing clothes, etc.</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animation of people associated with the idea of ‚Äã‚Äãusing the skeleton and the "skin." </font><font style="vertical-align: inherit;">The skeleton is a simple description of a moving character. </font><font style="vertical-align: inherit;">At this stage, we are worried about not animated buckles, hats or jeans - only important movements that are most relevant to the human skeleton are important to us.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f0f/bf2/ce7/f0fbf2ce7c1a0d3d287f8cc4b04b41f2.png"></div><br>  <em>Shown here is a simple skeleton of a human figure.</em>  <em>It is not taken from Watch Dogs, because the skeleton is difficult to visualize outside of the 3D editor.</em> <br><br>  <em>Image licensed by <a href="https://creativecommons.org/licenses/by-sa/3.0/">Attribution-ShareAlike CC BY-SA</a> ¬© <a href="http://www.makehuman.org/doc/node/alpha_7_creating_a_custom_rig_with_makerig.html">MakeHuman team</a> 2001-2014</em> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//nXYWZOr/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>This is a posture of binding or T-posture, demonstrating how a character looks like without the use of animations.</em> <br><br>  Animations - running, walking, jumping - apply only to this skeleton.  This makes the whole process very simple, because we only need to consider about a hundred bones instead of thousands and thousands of vertices. <br><br>  After creating the skeleton, each vertex binds to one or more bones in this static pose, and this connection is called skinning.  At the time of Half-Life 1, when this technology began to be used, each vertex was associated with only one bone.  Nowadays, even four bones can join, and each bone is given a weight, on which the degree of influence of the bone on the top depends.  Thanks to this, you can get a smoother animation, allowing the bones to intersect in different areas without creating sharp corners when moving arms or legs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/af5/e31/7e5af5e314bf44d7f9098941be6eacbc.png"></div><br>  <em>This is the skeleton shown above with the hip bone turned.</em>  <em>The colors show the weight of the hip bone relative to the model's tops.</em> <br><br>  <em>Image licensed by <a href="https://creativecommons.org/licenses/by-sa/3.0/">Attribution-ShareAlike CC BY-SA</a> ¬© <a href="http://www.makehuman.org/doc/node/alpha_7_creating_a_custom_rig_with_makerig.html">MakeHuman team</a> 2001-2014</em> <br><br>  This technology has its limitations, especially in those places where clothing and skin are compressed or stretched in the hinges, for example, on the elbows and shoulders.  This is a non-ideal, but very effective way to animate.  The most serious limitation is that it is very difficult to create convincing facial animations.  You can create a lot of "fake" bones on your face, for example, for eyebrows and around your mouth, but this will only be a rough approximation of muscles and skin. <br><br>  Another important feature of this technique is that the mapping of tops and bones is very specific and is related to how this mapping is performed.  It is possible to use animations for several different models, but each individual model in which to use a skeleton must be associated with bones.  The reason is that the animations move vertices from their original position relative to their skeletons.  If the vertices are not in the expected positions, then problems will arise. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//JdJEwEW/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>If the model does not match the skeleton it uses, then the animations will be <u>completely</u> wrong.</em> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed//Wt5PSQY/embed?ref=https" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <em>If we make the character two times wider, we will get an effect similar to <a href="http://uncharted.wikia.com/wiki/Doughnut_Drake">‚ÄúDrake's donated donuts,‚Äù</a> but it is noticeable that the animations become irregular closer to the brushes, because it is here that they are farthest from their original positions.</em> <br><br>  The first animation may seem strangely familiar to you - similar animation glitches occur in games very often.  Usually they are caused by the fact that the wrong animations are applied to the skeleton, or the wrong skeleton is used in the model.  As in the case of textures and models, the skeleton, skinning and model need to be very carefully compared, otherwise the results will quickly turn out to be sad. <br><br>  I hope you got some idea of ‚Äã‚Äãthe purpose of the vertex shaders and understood how animations are used to turn a static model into a living character. </div><p>Source: <a href="https://habr.com/ru/post/430930/">https://habr.com/ru/post/430930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430918/index.html">About Flutter, briefly: Basics</a></li>
<li><a href="../430922/index.html">Calculation example for a switchboard</a></li>
<li><a href="../430924/index.html">Hell language programming</a></li>
<li><a href="../430926/index.html">Time is fragmentary; a bit about the similarity of distributed systems and weak memory models</a></li>
<li><a href="../430928/index.html">Just about ‚Äúsmart home‚Äù: how to make ‚Äúsmart‚Äù lighting</a></li>
<li><a href="../430932/index.html">Hackers stole more than 21 million rubles from a Russian bank</a></li>
<li><a href="../430934/index.html">Asterisk Dialplan Extension Mask Generator</a></li>
<li><a href="../430936/index.html">Conference DEFCON 21. DNS can be dangerous for your health. Part 2</a></li>
<li><a href="../430938/index.html">How to get the first orders in design, when there is no portfolio and experience</a></li>
<li><a href="../430940/index.html">SDK to you, SDK to me, SDK to everyone! How to do the SDK and why it is needed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>