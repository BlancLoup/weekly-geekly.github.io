<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scaling Windows Azure Queues</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article provides guidelines for creating scalable, high-performance, and cost-effective messaging solutions based on Windows Azure queues. The do...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scaling Windows Azure Queues</h1><div class="post__text post__text-html js-mediator-article">  This article provides guidelines for creating scalable, high-performance, and cost-effective messaging solutions based on Windows Azure queues.  The document is intended for architects and developers of cloud solutions that use Windows Azure queues. <br><br><img src="https://habrastorage.org/storage2/085/636/b15/085636b15c8797f2eba424662342bbf6.png"><br><br><h4>  Introduction </h4><br>  Traditional queuing-based messaging solutions use a repository called <i>message queue</i> .  This is a repository of data received or transmitted by participants using the asynchronous exchange mechanism. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Queue-based data exchange is a solid foundation for creating a fault-tolerant scalable messaging architecture with support for a wide range of universal scenarios in a distributed computing environment.  Regardless of the task (dispatching large volumes of work or reliable messaging), the technology of message queues provides first-class information exchange capabilities in accordance with the requirements of asynchronous data transfer. <br><br>  This document describes the functionality of the Windows Azure platform, as well as how to use design patterns to create optimized and inexpensive queue-based messaging systems.  The document contains a detailed overview of the basic methods of software implementation of the queue-based interaction in modern solutions for the Windows Azure platform, as well as recommendations for improving performance, increasing scalability and reducing operating costs. <br><a name="habracut"></a><br><h4>  Scenario </h4><br>  For greater clarity, we summarize the real scenario as follows.  The supplier of SaaS solutions is commissioning a new billing system implemented as a Windows Azure application and serving the needs of the enterprise in processing a large number of customer transactions.  The solution is based on moving workloads to the cloud and using the elasticity of the Windows Azure infrastructure to perform complex calculations. <br><br>  The local element of the integrated infrastructure provides regular daily consolidation and scheduling of large transaction volumes for subsequent processing by a service hosted in the Windows Azure cloud environment.  The volume of transactions transferred varies from several thousand to hundreds of thousands within one package, and the cumulative daily volume can reach several million transactions.  This solution must meet the requirements of the service level agreement (SLA) in terms of ensuring the guaranteed maximum delay in data processing. <br><br>  The solution architecture is based on a distributed system pattern called map-reduce and consists of many instances of cloud-based work roles that use Windows Azure queue storage to dispatch work.  Transaction bursts are accepted by the <i>Process Initiator Worker</i> role.  They are then broken down into smaller work tasks that are transferred to Windows Azure queues for workload distribution. <br><br>  The workload is processed by a large number of instances of the <i>Processing Worker</i> role, which extract work operations from the queues, and perform computational procedures.  In these instances of handlers, multi-threaded queue listeners are used for parallel data processing, ensuring maximum performance. <br><br>  Processed work items are redirected to a dedicated queue, from which they are extracted by an instance of the <i>Process Controller</i> role for aggregation and long-term storage in the warehouse for data mining and reporting. <br><br>  The solution architecture is as follows: <br><img src="https://habrastorage.org/storage2/eb2/c41/3fe/eb2c413fe91cd138fbcba818ffaa01b5.png"><br><br>  The above diagram illustrates an example of a typical architecture used to scale large or complex computational loads.  The queue-based messaging pattern implemented in this architecture is typical of many Windows Azure applications and services that need to exchange data with each other using queues.  This allows a canonical approach to the study of the main components used for queuing-based messaging. <br><br><h4>  Queuing Basics </h4><br>  A standard messaging solution that supports the exchange of data between distributed components includes <i>publishers</i> who place messages in a queue, as well as one or more <i>subscribers</i> who receive these messages.  In most cases, subscribers, sometimes referred to <i>as queue listeners</i> , are implemented as single or multi-threaded applications that run continuously or run on demand, according to the user's schedule. <br><br>  At a higher level, there are two main dispatch mechanisms that allow the listener of the queue to receive messages stored in it: <br><ul><li>  <b>Polling (polling-based query model)</b> : A listener keeps track of a queue, checking for new messages in it at regular intervals.  If the queue is empty, the listener continues to poll the queue, periodically turning into a sleep state. </li><li>  <b>Switching (push-based model)</b> : A listener subscribes to an event that the trigger is associated with (by the publisher or the queue service manager) that is triggered when a message is sent to the queue.  The listener can initiate message processing, so he will not have to re-poll the queue to determine if new data is available. </li></ul><br>  It must be emphasized that the practical implementation of each of the mechanisms has its own characteristics.  For example, a poll can be either blocking or nonblocking.  The lock puts a hold request until a new message appears in the queue (or the waiting time expires), while non-blocking requests are executed immediately if the queue is empty.  Using the switch model allows you to force notifications to listeners on the queue whenever the very first message arrives in an empty queue or when the queue depth reaches a certain value. <br><br>  <b>Note</b>  The queuing operation supported by the Windows Azure Queue Service API is non-blocking.  This means that the <i>GetMessage</i> or <i>GetMessages</i> API methods will immediately exit if the message queue is empty.  In contrast, the <i>Durable Message Buffers</i> (DMB) buffers provided by the Windows Azure integration bus use blocking message retrieval operations, in which the calling thread is blocked until a message arrives in the DMB queue or a specified waiting period expires. <br><br>  The following are the most common approaches to software implementation of Windows Azure queue listeners: <br><ol><li>  The listener is implemented as an application component, an instance of which is created and executed as part of an instance of a working role. </li><li>  The life cycle of a role listener component is often tied to the execution time of an instance of a hosted role. </li><li>  The main processing logic is a loop through which messages are removed from the queues and sent for processing. </li><li>  If the queue of received messages is empty, the listener enters sleep mode, the duration of which is determined by the system shutdown algorithms and depends on the application. </li><li>  A program cycle for receiving messages is being performed;  the queue is polled until the listener is notified to exit the loop and complete their work. </li></ol><br>  The following block diagram illustrates the standard implementation logic for a queue listener with a built-in polling mechanism in Windows Azure. <br><img src="https://habrastorage.org/storage2/09d/234/46e/09d23446e3b65ff55b5a99a7e39fc685.png"><br>  <b>Note</b>  Discussion of more complex decision patterns, such as those requiring the use of a central queue manager (broker), is beyond the scope of this document. <br><br>  Using a classic queue listener in conjunction with a polling mechanism is not the most optimal choice.  The Windows Azure pricing model is based on counting the number of transactions within the repository based on the number of application requests to the queue, regardless of whether the queue is full.  The following sections are devoted to discussing methods to maximize performance and minimize the cost of implementing messaging systems based on Windows Azure queues. <br><br><h4>  Recommendations for cost reduction, performance and scalability </h4><br>  This section describes design methods that allow for improved performance and improved scalability, as well as reducing the cost of a turnkey solution. <br><br>  The system implementation pattern can be called a more effective solution only if it ensures the achievement of the following goals: <br><ul><li>  <b>Reducing operating costs</b> by eliminating data exchange transactions with the repository that do not perform useful work. </li><li>  <b>Eliminate unnecessary delays</b> associated with the use of the polling interval when checking for new messages in the queue. </li><li>  <b>Dynamic scaling</b> (expansion and reduction) due to the adaptation of computing power to changing volumes of work. </li></ul><br>  The implementation template must perform these tasks without complicating the system, otherwise the benefits of its implementation will be negated. <br><br><h5>  Recommendations for optimizing transaction costs when communicating with the repository </h5><br>  In assessing the total cost of ownership (TCO) and return on investment (ROI) of a solution deployed on the Windows Azure platform, one of the most important variables of a TCO formula is the volume of transactions in data exchange with the storage.  Reducing the number of data exchange transactions with Windows Azure queues allows you to reduce the operational costs associated with using Windows Azure solutions. <br><br>  When implementing a queue-based messaging solution, developers can reduce the number of data exchange transactions with the repository. <br><ol><li>  When sending messages to a queue, you can <b>group related messages</b> into one, larger package, compress and store the compressed image in the blob storage, and then use the queue to store a link to the blob with this data. </li><li> When retrieving messages from a queue, you can <b>combine several messages into one batch</b> to conduct data exchange transactions with the repository.  The <i>GetMessages</i> method, implemented in the Queue Service API, ensures that a specified number of messages are removed from a queue within a single transaction (see note below). </li><li>  When checking for the presence of work items in the queue, <b>avoid using aggressive polling intervals</b> and <b>set a time delay</b> that increases the polling interval of the queue if requests to it do not return data. </li><li>  <b>Reduce the number of queue listeners</b> ‚Äî when using a query-based model, use only one listener for each of the role instances when the queue is empty.  To nullify the number of listeners for each instance of a role, use a notification mechanism to create instances of listeners when queued work items are received. </li><li>  If the work queues remain empty most of the time, <b>create a mechanism for automatically reducing the number of role instances</b> that tracks system metrics to determine when the application needs to increase the number of role instances to handle the increased workload. </li></ol><br>  The above recommendations can be implemented as a general mechanism for processing message packets and encapsulating most of the basic operations for interacting with queues, blob storage and flow control.  Next will be discussed how to implement such a mechanism. <br><br>  <b>Important information</b> .  When receiving messages using the <i>GetMessages</i> method, the maximum size of the Queue Service API package for a remove from a queue operation is 32. Exceeding this value will result in a runtime exception. <br><br>  Transaction costs in Windows Azure queues increase linearly as the number of queue service clients increases, for example, when scaling the number of role instances or as the number of queuing threads increases.  To demonstrate the possible increase in costs during the implementation of the solution without taking into account the above recommendations, we will give an example with specific figures. <br><br><h5>  Impact of inefficient architecture on costs </h5><br>  Creation of the architecture of the above-described billing system, which does not contain optimization mechanisms, will lead to increased operational costs after the solution is deployed on the Windows Azure platform.  This section describes the reasons for possible additional costs. <br><br>  In accordance with the scenario definition, a software solution receives business transaction data at regular intervals.  Suppose that this solution is occupied by processing the workload only 25% of the time of the standard eight-hour workday.  As a result, 6 hours (8 hours * 0.75) fall on the ‚Äúinactivity time‚Äù when the system is not processing transactions.  Moreover, the solution does not receive data at all for 16 hours every day during non-working hours. <br><br>  During the period of inactivity, which together totals 22 hours, the decision tries to remove work information from the queue without receiving notifications about the addition of new data to it.  During this time, each individual deletion stream performs up to 79,200 transactions (22 hours * 60 minutes * 60 transactions per minute) related to the input queue with a default polling interval of one second. <br><br>  As mentioned above, the pricing model of the Windows Azure platform services uses separate ‚Äústorage transactions‚Äù as the base unit.  A store transaction is a request from a user application to add, read, update, or delete store data.  At the time of writing this technical document, the cost of storage transactions was $ 0.01 per 10,000 transactions.  <b>UPDATE</b> : at the time of publication of the transfer: $ 0.01 per <b>100,000</b> transactions. <br><br>  <b>Important information</b> .  When calculating the number of transactions associated with the queues, it must be remembered that placing one message in a queue is a single transaction, while receiving a message is often a two-step process that includes receiving a message and requesting that the message be removed from the queue.  As a result, a successful operation to remove a message from the queue will require two repository transactions.  Please note that even if the request to delete a message from the queue is not associated with receiving data, it is still considered a paid transaction. <br><br>  Storage transactions created by a single data deletion stream in the queue described above will add approximately $ 2.38 to the monthly invoice for services ($ 79,200/10,000 * $ 0.01 * 30 days).  200 threads deleting messages from the queue (or one thread in 200 copies of the working role) will increase your monthly expenses by $ 457.2 ( <b>UPDATE</b> : if you make calculations at the time of publication of the translation of the article, then it is $ 45.7).  These costs occur when the system does not perform any calculations, but only checks for the presence of work items in the queue.  The above example is abstract because no one will implement the service in this way.  You must use the following optimization techniques. <br><br><h5>  Recommendations for eliminating unnecessary delays </h5><br>  To optimize the performance of messaging systems based on Windows Azure queues, you can use the message processing level of the publishers and subscribers provided by the Windows Azure integration bus, as described below. <br>  In this case, developers need to combine the mechanisms for polling and forcing real-time notifications to allow listeners to subscribe to a notification event (trigger) that occurs under certain conditions and indicates that a new workload has been placed in the queue.  This approach allows you to create a standard queuing cycle at the level of publishers and subscribers to dispatch notifications. <br><br>  In complex distributed systems, this approach requires the use of a ‚Äúmessage bus‚Äù or ‚Äúmessage processing middleware‚Äù to reliably send notifications to one or more subscribers.  The Windows Azure integration bus is the best solution for messaging between loosely coupled distributed application services that are deployed not only in Windows Azure, but also locally.  It is ideally suited for the implementation of the message bus architecture, which provides for the exchange of notifications between data transmission processes using queues. <br><br>  The procedures for creating a messaging system using queues can use the following pattern: <br><img src="https://habrastorage.org/storage2/a34/596/646/a3459664668e82fccb83438fb8fc2189.png"><br>  The principles used to communicate between instances of Windows Azure roles when interacting between publishers and queue service subscribers meet most of the requirements for exchanging notifications based on forced data.  The basic concepts of this process are discussed in one of our previous publications. <br><br>  <b>Important information</b> .  Using the Windows Azure integration bus is governed by a pricing scheme that takes into account two important components of this process.  First, a fee is charged for receiving and sending data when exchanging with the data center.  Secondly, a fee is charged for the number of connections established between the application and the integration bus infrastructure. <br>  In this regard, it is important to analyze the costs and benefits to evaluate all the positive and negative aspects of using the integration bus for implementing a specific architecture.  It should be evaluated whether the implementation of the dispatch level of notifications based on the integration bus will result in an actual cost reduction that can justify the investment in this project and the additional developer labor costs. <br><br>  The negative impact of delays can be quite easily minimized by creating an additional level of messaging between publishers and subscribers.  Additional cost reductions are achieved through dynamic (elastic) scaling, the implementation of which is described in the next section. <br><br><h5>  Dynamic scaling guidelines </h5><br>  The Windows Azure platform supports the ability to easily and quickly scale solutions of customers both upwards and downwards.  The ability to adapt to workload and traffic fluctuations is one of the main advantages of this cloud computing platform.  This means that the notion of ‚Äúscalability‚Äù has ceased to be a term in the dictionary of IT professionals, and the support of scalability no longer requires excessive costs.  Software implementation of this feature is available in any cloud solution with a well-designed architecture. <br><br>  <i>Dynamic scaling</i> is a technical feature of a particular solution that allows you to adapt to a variable workload by increasing and decreasing the storage space and computing power available to the runtime environment.  The Windows Azure platform contains built-in support for dynamic scaling using a distributed computing infrastructure that allows users to allocate the necessary power for an installed fee. <br><br>  It is important to distinguish between two types of dynamic scaling supported by the Windows Azure platform: <br><ul><li>  <b>Scaling</b> role <b>instances</b> is adding and removing additional instances of working roles or web roles to handle the current workload.  This often requires changing the number of instances in the service configuration.  The Windows Azure runtime responds to an increase in the number of instances by creating new instances, and a decrease in the number of instances results in the termination of some of the existing instances. </li><li>  <b>Scaling processes</b> (threads) is maintaining a sufficient level of capacity (the number of processing threads) for a specific role instance at the expense of increasing or decreasing the number of threads depending on the current workload. </li></ul><br>  Implementing dynamic scaling in a role-based messaging solution requires consideration of the following recommendations: <br><ol><li>  <b>Keep track of key performance indicators</b> , including CPU usage, queue depth, response time, and latency in processing messages. </li><li>  <b>Dynamically increase or decrease the number of worker role instances</b> to handle peak workload, both expected and unpredictable. </li><li>  <b>Programmatically increase and decrease the number of processing flows</b> to adapt the system to various workload indicators. </li><li>  <b>Perform a workload partitioning and parallel processing of small fragments</b> using the .NET Framework 4 Task Parallel Library. </li><li>  <b>Ensure the availability of computing power</b> when managing solutions with a non-constant level of workload;  this will allow to cope with a sudden increase in load, without making additional efforts to create additional copies. </li></ol><br>  Service Management APIs allow services hosted on the Windows Azure platform to increase or decrease the number of running role instances by changing the deployment configuration in the runtime environment. <br><br>  <b>Note</b>  By default, no more than 20 instances of Windows Azure computing operations are available for a standard subscription.  This allows you to protect users of the Windows Azure platform from increasing the cost of maintenance if they accidentally try to create a very large number of role instances.  This is the so-called ‚Äúsoft‚Äù restriction.  Any application to increase this quota must be submitted to the Windows Azure Support Technical Team. <br><br>  Dynamically scaling the number of role instances is not always the best way to handle dramatically increased workload.  For example, a new instance of a virtual machine takes a few seconds to prepare for work, and currently, service level agreements do not include indicators related to the duration of this process.  Instead, you can take a simpler path ‚Äî increase the number of worker threads to cope with a temporary increase in workload.  When processing a workload, it monitors its performance to identify situations that require a dynamic increase or decrease in the number of work processes. <br><br>  <b>Important information</b> .  Currently, the target value of the scalability metric for a single Windows Azure queue is limited to 500 transactions per second.  If an application tries to exceed this threshold, for example, performing operations on a queue with several instances of the role, each of which has hundreds of object removal threads running, the storage service may return an HTTP error 503, "Server is busy."  In the event that this error occurs in the application, a mechanism for the repetition of transactions should be implemented using an algorithm with an exponentially increasing delay time.  However, if HTTP 503 errors occur regularly, it is recommended to use multiple queues and apply a segmentation strategy that will allow these queues to be used to scale the workload. <br><br>  In most cases, automated scaling of workflows is performed by a separate instance of the role.  Scaling role instances often requires developing a central element of the solution architecture that tracks performance indicators and takes measures to scale the system.  The diagram below contains a description of a service component called the <i>Dynamic Scaling Agent</i> ( <i>Dynamic Scaling Agent</i> ), which collects and analyzes data related to workload indicators to determine whether new instances are to be created or decommissioned inactive. <br><img src="https://habrastorage.org/storage2/ec2/1ee/67c/ec21ee67c7d47433c23b94c8163b0b52.png"><br>  The scaling agent service can be deployed as a worker role on the Windows Azure platform or as a local service.  Regardless of the deployment topology used, this service will have access to Windows Azure queues. <br><br>  Having discussed the impact of delay time on scaling, transaction costs when exchanging data with the repository, and dynamic scaling requirements, we now turn to the practical implementation of these recommendations. <br><br><h4>  Technical implementation </h4><br>  The previous sections described the main features of a well-designed messaging architecture implemented using Windows Azure queue storage services.  We looked at three key aspects of scaling: reducing data processing latency, optimizing data storage transaction costs, and improving response to workload instability. <br><br>  This section is intended for developers of Windows Azure applications and contains a description of the software implementation of patterns. <br><br>  Note.  This section contains information about creating a queue listener with support for automatic scaling, as well as models based on queries and forcing data to be sent.  For information on modern methods of dynamic scaling at the role instance level, refer to the projects implemented by the user community and published on the <a href="http://code.msdn.microsoft.com/azurescale">MSDN Code Gallery</a> website. <br><br><h5>  Creating a standard queue listener </h5><br>  First, create a contract that is implemented by the queue listener component, which is hosted in the worker role and is waiting for data transfer for the Windows Azure queue. <br><br><pre><code class="hljs pgsql">///    ,     Windows Azure. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface ICloudQueueServiceWorkerRoleExtension { ///    ,         . <span class="hljs-type"><span class="hljs-type">void</span></span> StartListener(<span class="hljs-type"><span class="hljs-type">int</span></span> threadCount); ///            . CloudQueueListenerInfo QueryState(); ///             Windows Azure. <span class="hljs-type"><span class="hljs-type">int</span></span> DequeueBatchSize { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ///      ,           . TimeSpan DequeueInterval { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ///    , ,   . event WorkCompletedDelegate QueueEmpty; }</code> </pre> <br>  The <i>QueueEmpty</i> event <i>is</i> intended to be used by the node.  It contains a mechanism that allows the node to control the queue listener when the queue is empty.  The event delegate is defined as follows: <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;summary&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,        /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       . /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"sender"</span></span>&gt; .&lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"idleCount"</span></span>&gt; ,    .&lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"delay"</span></span>&gt;,             .&lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;returns&gt;,              .&lt;<span class="hljs-regexp"><span class="hljs-regexp">/returns&gt; public delegate bool WorkCompletedDelegate(object sender, int idleCount, out TimeSpan delay);</span></span></code> </pre><br>  The processing of queue elements can be simplified by creating listeners with support for universal templates instead of using the built-in SDK classes, such as <i>CloudQueueMessage</i> .  Create a new queue listener interface with support for universal queue access patterns: <br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     ,       . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;typeparam name="T"&gt;</span></span></span><span class="hljs-comment">   ,     .</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/typeparam&gt;</span></span></span><span class="hljs-comment"> public interface ICloudQueueListenerExtension</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> : ICloudQueueServiceWorkerRoleExtension, IObservable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> { }</span></span></code> </pre><br>  Note: we also allowed the listener with universal template support to transfer queue elements to one or more subscribers by implementing the Observer design pattern using the IObservable interface, available in the .NET Framework 4. <br>  We intend to save a single instance of the component that implements the ICloudQueueListenerExtension interface.  However, we need the ability to simultaneously run multiple threads (tasks) to remove messages from the queue.  Therefore, we add support for a multi-threaded logic to remove messages from the queue to the listener component.  To solve this problem, the Task Parallel Library (TPL) library of parallel data processing functions is used.  The <i>StartListener</i> method will allow us to create the required number of threads to remove messages from the queue: <br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">/// &lt;summary&gt; ///</span></span>        . <span class="hljs-regexp"><span class="hljs-regexp">/// &lt;/summary&gt; ///</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"threadCount"</span></span>&gt;     .&lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; public void StartListener(int threadCount) { Guard.ArgumentNotZeroOrNegativeValue(threadCount, "threadCount"); /</span></span>/             . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dequeueTasks.IsAddingCompleted) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dequeueTasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlockingCollection&lt;Task&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dequeueTaskList); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; threadCount; i++) { CancellationToken cancellationToken = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cancellationSignal.Token; CloudQueueListenerDequeueTaskState&lt;T&gt; workerState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CloudQueueListenerDequeueTaskState&lt;T&gt;(Subscriptions, cancellationToken, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.queueLocation, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.queueStorage); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>             ,      . <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dequeueTasks.Add(Task.Factory.StartNew(DequeueTaskMain, workerState, cancellationToken, TaskCreationOptions.LongRunning, TaskScheduler.Default)); } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ,    . <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.dequeueTasks.CompleteAdding(); }</code> </pre><br>  The <i>DequeueTaskMain</i> method implements stream functions that remove messages from the queue.  It supports the following basic operations: <br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///        Windows Azure. /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="state"&gt;,    .&lt;/param&gt; private <span class="hljs-type"><span class="hljs-type">void</span></span> DequeueTaskMain(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> state) { CloudQueueListenerDequeueTaskState&lt;T&gt; workerState = (CloudQueueListenerDequeueTaskState&lt;T&gt;)state; <span class="hljs-type"><span class="hljs-type">int</span></span> idleStateCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; TimeSpan sleepInterval = DequeueInterval; try { //          ,             . <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (workerState.CanRun) { try { var queueMessages = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> msg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> workerState.QueueStorage.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>&lt;T&gt;(workerState.QueueLocation.QueueName, DequeueBatchSize, workerState.QueueLocation.VisibilityTimeout).AsParallel() <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> msg != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> msg; <span class="hljs-type"><span class="hljs-type">int</span></span> messageCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; //            PLINQ. queueMessages.ForAll((message) =&gt; { //     . idleStateCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; //       ,   . workerState.OnNext(message); //    ,     . workerState.QueueStorage.<span class="hljs-keyword"><span class="hljs-keyword">Delete</span></span>&lt;T&gt;(message); //       . messageCount++; }); // ,       . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == messageCount) { //     ,        (,     ). idleStateCount++; //    ,      . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QueueEmpty != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { // ,          . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QueueEmpty(this, idleStateCount, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> sleepInterval)) { //      ,      . break; } } //        . Thread.Sleep(sleepInterval); } } catch (<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> ex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> OperationCanceledException) { throw; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //           . workerState.OnError(ex); //        ,         . Thread.Sleep(sleepInterval); } } } } finally { workerState.OnCompleted(); } }</code> </pre><br>  It is necessary to make a few explanations related to the implementation features of the <i>DequeueTaskMain</i> method. <br>  First, the Parallel LINQ (PLINQ) method is used to dispatch messages for further processing. <br><br>  The main advantage of using PLINQ to solve this problem is to speed up the processing of messages due to the parallel use of the delegate in separate workflows on different processors whenever possible. <br><br>  <b>Note</b>  Internal query concurrency control is provided by PLINQ.  There is no guarantee that the PLINQ system will use more than one kernel to support parallelization.  If the PLINQ system detects the likelihood of a slow query execution due to the additional computational power required for parallelization, the query can be executed sequentially.  To realize all the benefits of PLINQ, the cumulative workload for executing a query must be large enough to justify the use of additional computational power to manage the thread pool. <br><br>  Secondly, we do not create separate requests to receive each specific message.  Instead, the Queue Service APIs are used to retrieve a specified number of messages from the queue.  The number of received messages is determined by the <i>DequeueBatchSize</i> parameter, which is passed to the Get method.  When accessing the data warehouse abstraction layer, this parameter is passed to the queue service API.  In addition, a security check is carried out to ensure that the packet size does not exceed the maximum allowed for the API.  Below is the software implementation of this approach: <br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">          Windows Azure    . public sealed class ReliableCloudQueueStorage : ICloudQueueStorage { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   ,   API  Queue Service     Get. private const int MaxDequeueMessageCount = 32; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">             . public IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment"> Get</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(string queueName, int count, TimeSpan visibilityTimeout) { Guard.ArgumentNotNullOrEmptyString(queueName, "queueName"); Guard.ArgumentNotZeroOrNegativeValue(count, "count"); try { var queue = this.queueStorage.GetQueueReference(CloudUtility.GetSafeContainerName(queueName)); IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;CloudQueueMessage&gt;</span></span></span><span class="hljs-comment"> queueMessages = this.retryPolicy.ExecuteAction</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;IEnumerable&lt;CloudQueueMessage&gt;</span></span></span><span class="hljs-comment">&gt;(() =&gt; { return queue.GetMessages(Math.Min(count, MaxDequeueMessageCount), visibilityTimeout); }); // ...     ...</span></span></code> </pre><br>   ,            .      ,     <i>QueueEmpty</i> ,    ,    .       <i>QueueEmpty</i> ,  ,          .     <i>QueueEmpty</i>   ¬´ ¬ª,     . <br><br><h4>          </h4><br>   <i>QueueEmpty</i>     . -,           ,           (    <i>delay</i>  ). -,                 . <br><br>     <i>QueueEmpty</i>    ,  .                      .  :           ;     ,        .  ,                .     ,                     .            ,       ,       .   <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">helps reduce the number of storage transactions and reduce transaction costs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , as discussed above.</font></font><br><br><pre> <code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">bool</span></span> HandleQueueEmptyEvent(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> sender, <span class="hljs-type"><span class="hljs-type">int</span></span> idleCount, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> TimeSpan delay) { //     ICloudQueueServiceWorkerRoleExtension,     . ICloudQueueServiceWorkerRoleExtension queueService = sender <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ICloudQueueServiceWorkerRoleExtension; //    ,         . IWorkItemProcessorConfigurationExtension config = Extensions.Find&lt;IWorkItemProcessorConfigurationExtension&gt;(); //              . CloudQueueListenerInfo queueServiceState = queueService.QueryState(); //   ,   . <span class="hljs-type"><span class="hljs-type">int</span></span> deltaBackoffMs = <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-type"><span class="hljs-type">int</span></span> minimumIdleIntervalMs = Convert.ToInt32(config.Settings.MinimumIdleInterval.TotalMilliseconds); <span class="hljs-type"><span class="hljs-type">int</span></span> maximumIdleIntervalMs = Convert.ToInt32(config.Settings.MaximumIdleInterval.TotalMilliseconds); //               . <span class="hljs-type"><span class="hljs-type">int</span></span> delta = (<span class="hljs-type"><span class="hljs-type">int</span></span>)((Math.Pow(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, (<span class="hljs-type"><span class="hljs-type">double</span></span>)idleCount) - <span class="hljs-number"><span class="hljs-number">1.0</span></span>) * (<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Random()).Next((<span class="hljs-type"><span class="hljs-type">int</span></span>)(deltaBackoffMs * <span class="hljs-number"><span class="hljs-number">0.8</span></span>), (<span class="hljs-type"><span class="hljs-type">int</span></span>)(deltaBackoffMs * <span class="hljs-number"><span class="hljs-number">1.2</span></span>))); <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-type"><span class="hljs-type">interval</span></span> = Math.Min(minimumIdleIntervalMs + delta, maximumIdleIntervalMs); //                 . delay = TimeSpan.FromMilliseconds((<span class="hljs-type"><span class="hljs-type">double</span></span>)<span class="hljs-type"><span class="hljs-type">interval</span></span>); //               , //          .    ,        . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> delay.TotalMilliseconds &gt;= maximumIdleIntervalMs &amp;&amp; queueServiceState.ActiveDequeueTasks &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The automated scaling mechanism can be described as follows: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As soon as a message appears in the queue, the task of deleting messages from the queue immediately processes the workload. </font><font style="vertical-align: inherit;">Requests to remove packet messages from the queue are transmitted without delay.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> After the initial queue is empty, each of the tasks to remove messages from the queue raises a QueueEmpty event. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The QueueEmpty event handler calculates a random exponential delay between sending requests and sends the task of removing messages from the queue to suspend operations for a specified interval. </font></font></li><li>                ,        . </li><li>      ,      ,         .    ,           . </li><li>  ,          .     ,     ,  ,     . </li></ul><br>                  . -,     ,        .              . <br><pre> <code class="hljs pgsql">///  ,        . <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> struct CloudQueueListenerInfo { ///       Windows Azure. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> CurrentQueueDepth { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-type"><span class="hljs-type">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ///       ,       . <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> ActiveDequeueTasks { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-type"><span class="hljs-type">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ///         ,  . <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> TotalDequeueTasks { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-type"><span class="hljs-type">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br> -,    ,     (.  ). <br><pre> <code class="hljs pgsql">///            . <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> CloudQueueListenerInfo QueryState() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> CloudQueueListenerInfo() { CurrentQueueDepth = this.queueStorage.GetCount(this.queueLocation.QueueName), ActiveDequeueTasks = (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this.dequeueTasks <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> task.Status != TaskStatus.Canceled &amp;&amp; task.Status != TaskStatus.Faulted &amp;&amp; task.Status != TaskStatus.RanToCompletion <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> task).Count(), TotalDequeueTasks = this.dequeueTasks.Count }; }</code> </pre><br><h4>       </h4><br>                           ,       .             . <br><br>               ,   : <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;summary&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,        ,    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/summary&gt; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> &lt;param name=<span class="hljs-string"><span class="hljs-string">"sender"</span></span>&gt; .&lt;<span class="hljs-regexp"><span class="hljs-regexp">/param&gt; public delegate void WorkDetectedDelegate(object sender);     ICloudQueueServiceWorkerRoleExtension,      ,   ,        (       ): public interface ICloudQueueServiceWorkerRoleExtension { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ...    ,   . .        ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,        ,    . event WorkDetectedDelegate QueueWorkDetected; }</code> </pre><br> ,          .     <i>QueueWorkDetected</i>       ,     <i>DequeueTaskMain</i> ,      : <br><pre> <code class="hljs ruby">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloudQueueListenerExtension</span></span></span><span class="hljs-class">&lt;T&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ICloudQueueListenerExtension</span></span></span><span class="hljs-class">&lt;T&gt; { //  ,        ,    . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">event</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkDetectedDelegate</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueWorkDetected</span></span></span><span class="hljs-class">;</span></span> private void DequeueTaskMain(object state) { CloudQueueListenerDequeueTaskState&lt;T&gt; workerState = (CloudQueueListenerDequeueTaskState&lt;T&gt;)state; int idleStateCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; TimeSpan sleepInterval = DequeueInterval; try { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>          ,             . <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (workerState.CanRun) { try { var queueMessages = from msg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> workerState.QueueStorage.Get&lt;T&gt;(workerState.QueueLocation.QueueName, DequeueBatchSize, workerState.QueueLocation.VisibilityTimeout).AsParallel() where msg != null select msg; int messageCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,   . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (idleStateCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; queueMessages.Count() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (QueueWorkDetected != null) { QueueWorkDetected(this); } } /<span class="hljs-regexp"><span class="hljs-regexp">/ ...    ,   . .        ...</span></span></code> </pre><br>       <i>QueueWorkDetected</i> .        ,    .        .  ,         ,    : <br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WorkItemProcessorWorkerRole</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RoleEntryPoint { //  Windows Azure    . public override sealed bool OnStart</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// ...      ... //       . var inputQueueListener = new CloudQueueListenerExtension&lt;XDocument&gt;(inputQueueLocation); //    . inputQueueListener.QueueEmpty += HandleQueueEmptyEvent; inputQueueListener.QueueWorkDetected += HandleQueueWorkDetectedEvent; inputQueueListener.DequeueBatchSize = configSettingsExtension.Settings.DequeueBatchSize; inputQueueListener.DequeueInterval = configSettingsExtension.Settings.MinimumIdleInterval; // ...     ... } ///  ,        ,    . private void HandleQueueWorkDetectedEvent(object sender) { //     ICloudQueueServiceWorkerRoleExtension,     . ICloudQueueServiceWorkerRoleExtension queueService = sender as ICloudQueueServiceWorkerRoleExtension; //              . CloudQueueListenerInfo queueServiceState = queueService.QueryState(); //         ,     . int dequeueTaskCount = GetOptimalDequeueTaskCount(queueServiceState.CurrentQueueDepth); //             ,         . if (queueServiceState.ActiveDequeueTasks &lt; dequeueTaskCount) { //       . queueService.StartListener(dequeueTaskCount - queueServiceState.ActiveDequeueTasks); } } // ...     ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the light of the above example, it is necessary to clarify the use of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetOptimalDequeueTaskCount</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. This method is responsible for calculating the number of queuing tasks for processing the workload. When calling, it is necessary to determine (using any suitable decision-making mechanisms) how much computing power is required for the queue listener to handle the expected workload. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, a developer can follow the most simple path and implement a set of static rules directly in the </font><i><font style="vertical-align: inherit;">GetOptimalDequeueTaskCount</font></i><font style="vertical-align: inherit;"> method </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></i> .           ,   ,      ,                   . <br><br>             : <br><pre> <code class="hljs pgsql">/// &lt;<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; ///         ,     . /// &lt;/<span class="hljs-keyword"><span class="hljs-keyword">summary</span></span>&gt; /// &lt;param <span class="hljs-type"><span class="hljs-type">name</span></span>="currentDepth"&gt;    .&lt;/param&gt; /// &lt;<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt;     .&lt;/<span class="hljs-keyword"><span class="hljs-keyword">returns</span></span>&gt; private <span class="hljs-type"><span class="hljs-type">int</span></span> GetOptimalDequeueTaskCount(<span class="hljs-type"><span class="hljs-type">int</span></span> currentDepth) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentDepth &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentDepth &gt;= <span class="hljs-number"><span class="hljs-number">100</span></span> &amp;&amp; currentDepth &lt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentDepth &gt;= <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; //    . <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>          .      ‚Äî  ,           . <br><br>        ,          (  ). ,              .    ,    ,       <i>QueueWorkDetected</i> . <br><br>                . <br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement publisher and subscriber level to remove from the queue with zero delay </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this section, we will supplement the above implementation of the queue listener with a push notification mechanism created on the basis of a </font></font><a href="http://msdn.microsoft.com/en-us/wazplatformtrainingcourse_introductiontotheappfabricservicebus2010part1_topic5.aspx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unidirectional multicast stream</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the integration bus. </font><font style="vertical-align: inherit;">This notification mechanism handles a trigger event, which is a signal for the queue listener to start working on removing items from the queue. </font><font style="vertical-align: inherit;">This approach </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eliminates the need to poll the queue when checking for new messages and eliminates the effect of the delay factor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a trigger event received by the listener of the queue when a new workload appears in it:</font></font><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  -,         . [DataContract(Namespace = WellKnownNamespace.DataContracts.Infrastructure)] public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CloudQueueWorkDetectedTriggerEvent</span></span></span><span class="hljs-class"> { ///     ,    . [</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataMember</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">string</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StorageAccount</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get</span></span></span><span class="hljs-class">;</span></span> private set; } /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,     . [DataMember] public string QueueName { get; private set; } /<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      (,       ). [DataMember] public long PayloadSize { get; private set; } /<span class="hljs-regexp"><span class="hljs-regexp">/ ...      ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let the queue listener implementations act as subscribers receiving a trigger event. </font><font style="vertical-align: inherit;">The first step is to assign the queue listener as an observer of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CloudQueueWorkDetectedTriggerEvent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event </font><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    ,     Windows Azure. public interface ICloudQueueServiceWorkerRoleExtension : IObserver</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;CloudQueueWorkDetectedTriggerEvent&gt;</span></span></span><span class="hljs-comment"> { // ...  , . .      ... }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second step will be the implementation of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">defined in the IObserver interface. </font><font style="vertical-align: inherit;">This method is called by the supplier to notify the observer about the new event:</font></font><br><pre> <code class="hljs xml">public class CloudQueueListenerExtension<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> : ICloudQueueListenerExtension<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">T</span></span></span><span class="hljs-tag">&gt;</span></span> { // ...      ... /// <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">summary</span></span></span><span class="hljs-tag">&gt;</span></span> ///          /// <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">summary</span></span></span><span class="hljs-tag">&gt;</span></span> /// <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"e"</span></span></span><span class="hljs-tag">&gt;</span></span>-,        .<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">param</span></span></span><span class="hljs-tag">&gt;</span></span> public void OnNext(CloudQueueWorkDetectedTriggerEvent e) { Guard.ArgumentNotNull(e, "e"); // ,  -   ,  ;  ,    . if (this.queueLocation.StorageAccount == e.StorageAccount &amp;&amp; this.queueLocation.QueueName == e.QueueName) { if (QueueWorkDetected != null) { QueueWorkDetected(this); } } } // ...     ... }</code> </pre><br>     ,        ,    .   <i>QueueWorkDetected</i>            .            <i>CloudQueueWorkDetectedTriggerEvent</i> . <br><br>     ,             .          ,       ,            ,     .         ,        <i>QueueEmpty</i> : <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleQueueEmptyEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idleCount, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TimeSpan delay</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ...      ... //               . return delay.TotalMilliseconds &gt;= maximumIdleIntervalMs; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, we no longer determine whether there is one active removal task from the queue. The modified </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueEmpty</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event </font><i><font style="vertical-align: inherit;">handler</font></i><font style="vertical-align: inherit;"> takes into account only the fact that the maximum inactivity interval has been exceeded, after which all active removal tasks from the queue will be completed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To receive notifications from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CloudQueueWorkDetectedTriggerEvent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a publisher and subscriber model is used, which is implemented as a </font></font><a href="http://windowsazurecat.com/2010/09/implementing-reliable-inter-role-communication-using-windows-azure-service-bus-observer-pattern-parallel-linq/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loosely coupled messaging model between instances of Windows Azure roles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In essence, we enable the level of data exchange between roles and handle incoming events as follows:</font></font><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterRoleEventSubscriberExtension</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IInterRoleEventSubscriberExtension { // ...      .     . </span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">    Windows Azure Customer Advisory Team ... public void OnNext</span></span></span></span>(InterRoleCommunicationEvent e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.owner != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; e.Payload != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ...      ... if (e.Payload is CloudQueueWorkDetectedTriggerEvent) { HandleQueueWorkDetectedTriggerEvent(e.Payload as CloudQueueWorkDetectedTriggerEvent); return; } // ...     ... } } private void HandleQueueWorkDetectedTriggerEvent(CloudQueueWorkDetectedTriggerEvent e) { Guard.ArgumentNotNull(e, "e"); //        -. foreach (var queueService in this.owner.Extensions.FindAll&lt;ICloudQueueServiceWorkerRoleExtension&gt;()) { //  -  . queueService.OnNext(e); } } }</span></span></code> </pre><br>   -,    <i>CloudQueueWorkDetectedTriggerEvent</i> ,   ,   ,      .                    .      -  ,         : <br><pre> <code class="hljs ruby">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProcessInitiatorWorkerRole</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RoleEntryPoint</span></span></span><span class="hljs-class"> { //   ,       . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">private</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">volatile</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IInterRoleCommunicationExtension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interRoleCommunicator</span></span></span><span class="hljs-class">;</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/ ...      .     . ,     Windows Azure Customer Advisory Team ... private void HandleWorkload() { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  1.   ,     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... (    ) ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  2.      . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ... (    ) ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  3.       . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  -,   ,        . var trigger = new CloudQueueWorkDetectedTriggerEvent("MyStorageAccount", "InputQueue"); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . var interRoleEvent = new InterRoleCommunicationEvent(CloudEnvironment.CurrentRoleInstanceId, trigger); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/             . interRoleCommunicator.Publish(interRoleEvent); } }</span></span></code> </pre><br> ,    ,    ,      .     ,             Windows Azure. <br><br><h4>  Conclusion </h4><br>       ¬´ ‚Äî ¬ª        Windows Azure,        . <br><br>     : <br><ul><li>           <b>   Windows Azure      </b>         . </li><li>   <b>   ,       500</b>   . </li><li>        Windows Azure   <b>       </b> ;        . </li><li>       ,       <b>    </b> . </li><li>           <b>     </b>     . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the integration bus to prepare for sending real-time notifications</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you need to evaluate the benefits and costs.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Developers should consider the following: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Designing a messaging solution </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requires batch processing when writing procedures for storing and retrieving data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from Windows Azure queues.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementing an effective queue-listening service requires the creation of a mechanism that polls empty queues using a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">single thread to remove items from the queues</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use dynamic scaling to reduce the number of worker role instances</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if the queues remain empty for a long time.</font></font></li><li> <b>       </b> ,          . </li><li>  ,  <b>     </b>      ,       . </li><li>      Windows Azure       <b>     </b> ,     . </li><li>        Windows Azure <b>    ,    </b>          . </li><li>     .NET Framework 4,   <b>TPL, PLINQ    ¬´¬ª,     </b> ,         . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/155961/">https://habr.com/ru/post/155961/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../155951/index.html">HighLoad 2012</a></li>
<li><a href="../155953/index.html">If programming languages ‚Äã‚Äãwere girls ...</a></li>
<li><a href="../155955/index.html">Game console based on Android. Detailed manual</a></li>
<li><a href="../155957/index.html">Mobile applications for iOS and Android on php</a></li>
<li><a href="../155959/index.html">Development through suffering</a></li>
<li><a href="../155963/index.html">Each data center has its own constructor</a></li>
<li><a href="../155967/index.html">Acer Iconia Tab A701 - Return of the Jedi</a></li>
<li><a href="../155969/index.html">Understanding autorotation in iOS 6</a></li>
<li><a href="../155971/index.html">Soviet radio "Micro" 1965</a></li>
<li><a href="../155973/index.html">RFID tag on simple logic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>