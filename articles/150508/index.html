<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to frameworks (Part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Automated testing (AT) is most effective when implemented using the framework. Despite the fact that in AT, the term framework is often used to descri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to frameworks (Part 1)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/9ad/3be/b19/9ad3beb19854c67745e5cddf8844a0c2.jpg" align="left" alt="Automated Testing"><br>  Automated testing (AT) is most effective when implemented using the framework.  Despite the fact that in AT, the term <i>framework is</i> often used to describe the set of objects that forms the unit testing tool, this article will be mainly focused on other types of frameworks.  We will discuss the types of frameworks that can be defined as a set of abstract concepts, processes, procedures, and environments through which automated tests are designed, created, and implemented.  In addition, this definition of the framework includes physical objects used to create tests and their implementation, as well as to organize the logical interaction between components. <br>  Automated testing (and, therefore, frameworks) has evolved over the years, evolving and becoming more complex with each new phase of evolution.  These phases can be described in terms of three generations, each of which has a set of disadvantages and advantages, due to which each of them remains relevant, despite new developments.  The concepts below are commonly used to automate functional testing, but in some cases they can be used to solve unit testing problems. <a name="habracut"></a><br><br><h4>  First generation frameworks </h4>  The first generation of frameworks in test automation is initially based on a linear approach to the development of automated tests.  A linear approach usually results in a one-dimensional set of automated tests, in which each autotest is considered simply as the implementation of its ‚Äúmanual‚Äù equivalent.  All components that are used by the autotest are generated for the most part using the ‚Äúrecord-play‚Äù technique and are mainly located inside this autotest.  At the same time, there is practically no modularity, code reuse, and other elements that determine software quality in scripts.  The scope in which such tests can be useful is quite small. <br><br><h5>  Linear frameworks </h5>  An example of a small linear script is presented below.  Please note that there are no calls to external modules and access to external data. <br><blockquote><ol><li>  <font color="#FF8000">Input</font> ‚ÄúJohn‚Äù into Username textbox </li><li>  <font color="#FF8000">Input</font> ‚ÄúJPass‚Äù into Password textbox </li><li>  Click Login button </li><li>  <font color="#0600FF">If</font> ‚ÄúWelcome Screen‚Äù exists <font color="#FF8000">then</font> </li><li>  Pass the test </li><li>  <font color="#FF8000">Else</font> </li><li>  Fail the test </li><li>  <font color="#0600FF">End</font> <font color="#0600FF">if</font> </li></ol></blockquote>  In most cases, the use of the ‚Äúrecord-play‚Äù technique cannot be considered as a framework or a serious approach to automation.  Nevertheless, many would agree that this technique may in some cases be useful. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  Advantages of linear frameworks </h6><ul><li>  <b>The speed of creating scripts</b> - not much planning is required, little attention is paid to the quality aspects of autotests as software.  Considering this, as well as the fact that the development of linear scripts is often based on the use of the ‚Äúrecord-play‚Äù technique, it is easy to understand that the cost of such development in terms of time, resources and money can be relatively small. </li><li>  <b>Short learning curve <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B8%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BE%25D0%25B1%25D1%2583%25D1%2587%25D0%25B0%25D0%25B5%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">w</a></b> - test automation usually requires knowledge of the automation tool, the programming language, and how the tool interacts with the application under test.  Using the ‚Äúrecord-play‚Äù technique when creating linear scripts automatically generates code that corresponds to the actions that must be performed in the application under test.  This code can then be studied by the automation to get answers to questions about the syntax of the automation tool language, as well as how the tool interacts with the application. </li><li>  <b>Quickly obtaining information about changes in the application under test</b> is an advantage closely related to the previous one.  Using the record-play technique provides information about changes in the application under test.  For example, how properties of objects change after actions to change an application. </li><li>  <b>Script independence</b> - given the fact that all the components used by the script are inside the script itself, there is no danger of changing the script in such a way that it accidentally affects the work of any other scripts. </li><li>  <b>Simplicity of error detection</b> - the more advanced the framework is, the more complicated it is.  Together with the complexity come the problems associated with finding the source of the error, especially for those who are not familiar with the structure of the framework.  Given the fact that all the components of a linear script are in it, finding out where the error occurred is not a problem. </li></ul><br><h6>  Disadvantages of linear frameworks </h6><ul><li>  <b>Incorrect reproduction</b> - in the case when they mainly rely on the ‚Äúrecord- <b>play</b> ‚Äù approach, the recorded scripts are often not reproduced correctly.  This is due to the fact that this approach is not analytical.  At its application, the application‚Äôs objects and its behavior are not investigated, the decision is not made on how best to interact with these objects and behavior.  When trying to fix playback errors, a series of temporary solutions is often used, which then fail the test of time. </li><li>  <b>Redundancy</b> - linear scripts do not have the advantage of reuse, so if several scripts perform similar or similar actions, then the functionality will be duplicated in each of the scripts.  In case of a change in the tested application in subsequent releases, we will receive as a result an increase in script maintenance costs. </li><li>  <b>One-dimensionality</b> - low flexibility is attached to the load to linearity.  Scripts can be easily run on one level only, in one place and in one way.  If the test manager wants the automator to perform part of the tests based on certain priorities or risks, or in a different environment, or in a different sequence, then the automator will have to spend a lot of time analyzing the scripts to perform the required.  Consequently, the time available for running scripts or analyzing results is reduced. </li><li>  <b>Scripts are difficult to read</b> - due to the lack of reusable components, linear scripts are overloaded with code.  This makes scripts difficult to read and, therefore, difficult to analyze and difficult to maintain.  In addition, when changes need to be made to the script, it becomes more difficult to determine in which part of the code this should be done. </li><li>  <b>Requires a higher level of knowledge to support</b> - this is directly related to the lack of division into modules.  Modularity helps to deal with the question for which each of the code blocks is responsible.  Free declarations in linear scripts make this process not so easy.  So, when it comes to analyzing or debugging a linear script, the automator must first spend a significant amount of time understanding the code in order to effectively support the script. </li></ul><br>  <a href="http://habrahabr.ru/post/150603/">Part 2.</a> </div><p>Source: <a href="https://habr.com/ru/post/150508/">https://habr.com/ru/post/150508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150500/index.html">Legal withdrawal of money from oDesk to p / c IP</a></li>
<li><a href="../150501/index.html">Google Maps for Android. Now for cyclists</a></li>
<li><a href="../150502/index.html">The laws of drama in the IMO: when will they earn?</a></li>
<li><a href="../150504/index.html">Samsung Galaxy Camera at IFA 2012</a></li>
<li><a href="../150505/index.html">Housing for home server / NAS</a></li>
<li><a href="../150509/index.html">Video review of HP Pavilion G6 and Pavilion M6 laptops</a></li>
<li><a href="../150510/index.html">Android users are finally starting to buy apps.</a></li>
<li><a href="../150512/index.html">How to become a freelancer</a></li>
<li><a href="../150513/index.html">The correct calculation for VDI (part 1)</a></li>
<li><a href="../150514/index.html">Tracks Flow + Open Source = Simple File Storage</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>