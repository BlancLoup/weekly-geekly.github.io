<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How JS: WebSocket and HTTP / 2 + SSE work. What to choose?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[We advise you to read] Other 19 parts of the cycle  Part 1: Overview of the engine, execution time mechanisms, call stack 
 Part 2: About the V8 inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How JS: WebSocket and HTTP / 2 + SSE work. What to choose?</h1><div class="post__text post__text-html js-mediator-article"><div class="spoiler">  <b class="spoiler_title">[We advise you to read] Other 19 parts of the cycle</b> <div class="spoiler_text">  Part 1: <a href="https://habrahabr.ru/company/ruvds/blog/337042/">Overview of the engine, execution time mechanisms, call stack</a> <br>  Part 2: <a href="https://habrahabr.ru/company/ruvds/blog/337460/">About the V8 internals and code optimization</a> <br>  Part 3: <a href="https://habrahabr.ru/company/ruvds/blog/338150/">Memory management, four types of memory leaks and dealing with them</a> <br>  Part 4: <a href="https://habrahabr.ru/company/ruvds/blog/340508/">Event loop, asynchrony, and five ways to improve code with async / await</a> <br>  Part 5: <a href="https://habrahabr.ru/company/ruvds/blog/342346/">WebSocket and HTTP / 2 + SSE.</a>  <a href="https://habrahabr.ru/company/ruvds/blog/342346/">What to choose?</a> <br>  Part 6: <a href="https://habrahabr.ru/company/ruvds/blog/343568/">Features and Scope of WebAssembly</a> <br>  Part 7: <a href="https://habrahabr.ru/company/ruvds/blog/348424/">Web Workers and Five Use Cases</a> <br>  Part 8: <a href="https://habrahabr.ru/company/ruvds/blog/349858/">Service Workers</a> <br>  Part 9: <a href="https://habrahabr.ru/company/ruvds/blog/350486/">Web push notifications</a> <br>  Part 10: <a href="https://habrahabr.ru/company/ruvds/blog/351256/">Tracking DOM Changes with MutationObserver</a> <br>  Part 11: <a href="https://habrahabr.ru/company/ruvds/blog/351802/">The engines of rendering web pages and tips to optimize their performance</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 12: <a href="https://habr.com/company/ruvds/blog/354070/">Browser networking subsystem, optimizing its performance and security</a> <br>  Part 13: <a href="https://habr.com/company/ruvds/blog/354438/">Animation with CSS and JavaScript</a> <br>  Part 14: <a href="https://habr.com/company/ruvds/blog/415269/">How JS works: abstract syntax trees, parsing and its optimization</a> <br>  Part 15: <a href="https://habr.com/company/ruvds/blog/415377/">How JS Works: Classes and Inheritance, Babil and TypeScript Transformation</a> <br>  Part 16: <a href="https://habr.com/company/ruvds/blog/415505/">How JS Works: Storage Systems</a> <br>  Part 17: <a href="https://habr.com/company/ruvds/blog/415881/">How JS Works: Shadow DOM Technology and Web Components</a> <br>  Part 18: <a href="https://habr.com/company/ruvds/blog/416821/">How JS: WebRTC and P2P Communication Mechanisms Work</a> <br>  Part 19: <a href="https://habr.com/company/ruvds/blog/419831/">How JS Works: Custom Elements</a> </div></div><br>  Before you - the translation of the fifth material from the series, devoted to the features of JS-development.  In previous articles, we looked at the main elements of the JavaScript ecosystem, the capabilities of which are used by developers of server and client code.  In these materials, after setting out the basics of certain aspects of JS, recommendations are given on their use.  The author of the article says that these principles are applied during the development of the <a href="https://www.sessionstack.com/">SessionStack</a> application.  A modern user of libraries and frameworks can choose from a variety of possibilities, so any project, in order to adequately look at the competition, has to be squeezed out of the technologies on which it is built, everything that is possible. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6p/xj/ml/6pxjmllzgz5vbdnbz1y9g1ihbdm.jpeg"></div><a name="habracut"></a>  This time we will talk about communication protocols, compare and discuss their features and components.  Here we will deal with WebSocket and HTTP / 2 technologies, in particular, let's talk about security and share tips on choosing the appropriate protocols in various situations. <br><br><h2>  <font color="#3AC1EF">Introduction</font> </h2><br>  Nowadays, complex web applications with rich dynamic user interfaces are taken for granted.  But the Internet had to go a long way in order to achieve its current state. <br><br>  At the very beginning, the Internet was not designed to support such applications.  It was conceived as a collection of HTML pages, as a ‚Äúweb‚Äù of related documents.  Everything was basically built around the HTTP request / response paradigm.  Client applications loaded pages and after that nothing happened until the user clicked on the link to go to the next page. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Approximately in 2005, AJAX technology appeared and a lot of programmers began to explore the possibilities of bidirectional communication between the client and the server.  However, all HTTP communication sessions were still initiated by the client, which required either user participation or periodic server access to download new data. <br><br><h2>  <font color="#3AC1EF">"Bidirectional" HTTP communication</font> </h2><br>  Technologies that allow "proactively" send data from the server to the client have been around for quite some time.  Among them - <a href="https://en.wikipedia.org/wiki/Push_technology">Push</a> and <a href="http://en.wikipedia.org/wiki/Comet_%2528programming%2529">Comet</a> . <br><br>  One of the most commonly used techniques for creating the illusion that the server sends data to the client itself is called ‚Äúlong polling‚Äù (long polling).  Using this technology, the client opens an HTTP connection to the server, which keeps it open until a response is sent.  As a result, when the server has data for the client, it sends it to him. <br><br>  Here is an example of a very simple code snippet that implements the long poll technology: <br><br><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poll</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{   setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{      $.ajax({        <span class="hljs-attr"><span class="hljs-attr">url</span></span>: <span class="hljs-string"><span class="hljs-string">'https://api.example.com/endpoint'</span></span>,        <span class="hljs-attr"><span class="hljs-attr">success</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">) </span></span>{          <span class="hljs-comment"><span class="hljs-comment">//  -  `data`          // ...          //              poll();        },        dataType: 'json'      });  }, 10000); })();</span></span></code> </pre> <br>  This design is a function that calls itself after, for the first time, it is launched automatically.  It sets a 10-second interval for each asynchronous Ajax call to the server, and after processing the server‚Äôs response, the function call is scheduled again. <br><br>  Another technique used in a similar situation is <a href="http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/Socket.html">Flash</a> or a composite HXR query, and so-called <a href="http://cometdaily.com/2007/12/27/a-standards-based-approach-to-comet-communication-with-rest/">htmlfiles</a> . <br><br>  All these technologies have the same problem: the additional load on the system, which creates the use of HTTP, which makes all this unsuitable for the organization of applications that require high speed response.  For example, this is something like a multiplayer browser-based "shooter" or any other online game in which actions are performed in real time. <br><br><h2>  <font color="#3AC1EF">Introduction to WebSocket Technology</font> </h2><br>  The <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocket</a> specification defines an API for establishing a connection between a web browser and a server based on a "socket".  Simply put, it is a permanent connection between the client and the server, using which the client and server can send data to each other at any time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b9/26c/e9b/3b926ce9b0eb9023d85ad53c8772a78e.png"><br><br>  The client establishes a connection by performing the process of the so-called WebSocket handshake.  This process begins with the client sending a regular HTTP request to the server.  This request includes the <code>Upgrade</code> header, which informs the server that the client wants to establish a WebSocket connection. <br><br>  Let's see how the installation of such a connection looks like from the client: <br><br><pre> <code class="hljs pgsql">//   WebSocket-. var socket = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> WebSocket(<span class="hljs-string"><span class="hljs-string">'ws://websocket.example.com'</span></span>);</code> </pre> <br>  The URL used for the WebSocket connection uses the <code>ws</code> scheme.  In addition, there is a <code>wss</code> scheme for organizing secure WebSocket connections, which is equivalent to HTTPS. <br><br>  In this case, the beginning of the process of opening a WebSocket connection to the <code>websocket.example.com</code> server is <code>websocket.example.com</code> . <br><br>  Here is a simplified example of the original request headers. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">GET</span></span> ws://websocket.example.com/ HTTP/<span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span> Origin: http://example.com Connection: Upgrade Host: websocket.example.com Upgrade: websocket</code> </pre> <br>  If the server supports the WebSocket protocol, it will agree to switch to it and report this in the <code>Upgrade</code> response header.  Let's look at the implementation of this mechanism using Node.js: <br><br><pre> <code class="hljs pgsql">//    WebSocket  //https://github.com/theturtle32/WebSocket-Node var WebSocketServer = require(<span class="hljs-string"><span class="hljs-string">'websocket'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>; var http = require(<span class="hljs-string"><span class="hljs-string">'http'</span></span>); var <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> = http.createServer(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(request, response) { //  HTTP-. }); <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">listen</span></span>(<span class="hljs-number"><span class="hljs-number">1337</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { }); //   wsServer = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> WebSocketServer({ httpServer: <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> }); // WebSocket- wsServer.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'request'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(request) { var <span class="hljs-keyword"><span class="hljs-keyword">connection</span></span> = request.accept(<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>, request.origin); //  -     ,   //   . <span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'message'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(message) {     //   WebSocket }); <span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">connection</span></span>) {   //   }); });</code> </pre> <br>  After the connection is established, the server‚Äôs response will include information on switching to the WebSocket protocol: <br><br><pre> <code class="hljs pgsql">HTTP/<span class="hljs-number"><span class="hljs-number">1.1</span></span> <span class="hljs-number"><span class="hljs-number">101</span></span> Switching Protocols <span class="hljs-type"><span class="hljs-type">Date</span></span>: Wed, <span class="hljs-number"><span class="hljs-number">25</span></span> Oct <span class="hljs-number"><span class="hljs-number">2017</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">07</span></span>:<span class="hljs-number"><span class="hljs-number">34</span></span> GMT <span class="hljs-keyword"><span class="hljs-keyword">Connection</span></span>: Upgrade Upgrade: WebSocket</code> </pre> <br>  After that, the <code>open</code> event is triggered in the WebSocket instance on the client: <br><br><pre> <code class="hljs lua">var socket = new WebSocket(<span class="hljs-string"><span class="hljs-string">'ws://websocket.example.com'</span></span>); //     WebSocket-. socket.onopen = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'WebSocket is connected.'</span></span>); };</code> </pre> <br>  Now that the handshake phase is complete, the original HTTP connection is replaced with a WebSocket connection that uses the same basic TCP / IP connection.  At this point, both the client and the server may begin sending data. <br><br>  Through the use of WebSocket, you can send any amount of data without exposing the system to unnecessary load caused by the use of traditional HTTP requests.  Data is transmitted over a WebSocket connection as messages, each of which consists of one or more frames containing the data to be sent (payload).  In order to ensure the correct assembly of the original message when it reaches the client, each frame has a prefix containing 4-12 bytes of payload data.  The use of a frame-based messaging system helps to reduce the number of service data transmitted over the communication channel, which significantly reduces delays in the transmission of information. <br><br>  It should be noted that the client will be informed of the arrival of a new message only after all the frames have been received and the original message payload has been reconstructed. <br><br><h2>  <font color="#3AC1EF">Different WebSocket protocol URLs</font> </h2><br>  Above, we mentioned that WebSocket uses a new URL scheme.  In fact, there are two of them: <code>ws://</code> and <code>wss://</code> . <br><br>  When building URLs, certain rules are used.  A feature of the WebSocket URL is that they do not support anchors ( <code>#sample_anchor</code> ). <br><br>  Otherwise, the same rules apply to WebSocket URLs as to HTTP URLs.  When using ws addresses, the connection is unencrypted, the default port is 80. When using wss, TLS encryption is required and port 443 is used. <br><br><h2>  <font color="#3AC1EF">The protocol of working with frames</font> </h2><br>  Let's take a closer look at the protocol for working with WebSocket frames.  Here's what you can learn about the frame structure from the relevant <a href="https://tools.ietf.org/html/rfc6455">RFC</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c2/431/c0f/4c2431c0f62d4e764babe19b6e8026c8.png"></div><br>  If we talk about the standardized version of WebSocket RFC, then we can say that at the beginning of each package there is a small header.  However, it is quite difficult.  Here is a description of its components: <br><br><ul><li>  <code>fin</code> (1 bit): indicates whether this frame is the last frame completing the transmission of the message.  Most often, a single frame is enough to send a message, and this bit is always set.  Experiments have shown that Firefox creates a second frame after the message size exceeds 32 KB. <br></li><li>  <code>rsv1</code> , <code>rsv2</code> , <code>rsv3</code> (each for the 1st bit): these fields should be set to 0 only if no agreement was reached on extensions, which will determine the meaning of their nonzero values.  If a non-zero value is set in one of these fields and no agreement was reached on the meaning of this value, the recipient must declare the connection invalid. <br></li><li>  <code>opcode</code> (4 bits): The frame contents are encoded here.  The following values ‚Äã‚Äãare currently used: <br><br><ul><li>  <code>0x00</code> : in this frame is the next part of the transmitted message. <br></li><li>  <code>0x01</code> : This frame contains text data. <br></li><li>  <code>0x02</code> : there are binary data in this frame. <br></li><li>  <code>0x08</code> : this frame terminates the connection. <br></li><li>  <code>0x09</code> : this is a ping frame. <br></li><li>  <code>0x0a</code> : This is a pong frame. <br></li></ul></li></ul><br>  As you can see, there are enough unused values.  They are reserved for the future. <br><br><ul><li>  <code>mask</code> (1 bit): indicates that the frame is masked.  Now it is the case that each message from the client to the server must be masked, otherwise the specifications prescribe to break the connection. <br></li><li>  <code>payload_len</code> (7 bits): payload length.  WebSocket frames support the following methods for specifying payload sizes.  A value of 0-125 indicates the length of the payload.  126 means the next two bytes mean size.  127 means that the next 8 bytes contain the size information.  As a result, the length of the payload can be written in approximately 7 bits, or 16, or 64 bits. <br></li><li>  <code>masking-key</code> (32 bits): all frames sent from the client to the server are masked using the 32-bit value that is contained in the frame. <br></li><li>  <code>payload</code> : framed data that is masked for sure.  Their length corresponds to what is specified in <code>payload_len</code> . <br></li></ul><br>  Why is the WebSocket protocol based on frames, not threads?  If you know the answer to this question - you can share it in the comments.  In addition, <a href="https://news.ycombinator.com/item%3Fid%3D3377406">here is an interesting discussion</a> on this topic at HackerNews. <br><br><h2>  <font color="#3AC1EF">Data in frames</font> </h2><br>  As already mentioned, the data can be divided into multiple frames.  In the first frame, from which data transfer begins, in the <code>opcode</code> field, the type of data to be transferred is specified.  This is necessary, since in JavaScript, it can be said, there was no support for binary data when starting work on the WebSockets specification.  Code <code>0x01</code> indicates UTF-8 encoded data, code <code>0x02</code> used for binary data.  Often JSON data is sent in WebSocket packages, for which the <code>opcode</code> field is usually set as for text.  When transferring binary data, they will be presented in the form of Web-specific <a href="https://developer.mozilla.org/en-US/docs/Web/API/Blob">Blob</a> entities. <br><br>  The API for transferring data using the WebSocket protocol is very simple: <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(<span class="hljs-string"><span class="hljs-string">'ws://websocket.example.com'</span></span>); socket.onopen = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span><span class="hljs-function"> </span></span>{ socket.send(<span class="hljs-string"><span class="hljs-string">'Some message'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . };</span></span></code> </pre> <br>  When, on the client side, WebSocket receives data, a <code>message</code> event is raised.  This event has a <code>data</code> property that can be used to work with message content. <br><br><pre> <code class="hljs lua">//  ,  . socket.onmessage = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> { var message = event.data; console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(message); };</code> </pre> <br>  To find out what's inside the frames of a WebSocket connection, you can use the Network tab of the Chrome developer tools: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a59/259/81d/a5925981d4578138e58b8c68d362fafc.png"><br><br><h2>  <font color="#3AC1EF">Data fragmentation</font> </h2><br>  The payload may be split into several separate frames.  It is assumed that the receiving side will buffer the frames until a frame with the <code>fin</code> header field is set.  As a result, for example, the ‚ÄúHello World‚Äù message can be transmitted in 11 frames, each of which carries 1 byte of the payload and 6 bytes of header data.  Control packet fragmentation is prohibited.  However, the specification makes it possible to handle <a href="https://en.wikipedia.org/wiki/Interleaving_%2528data%2529">alternating</a> control frames.  This is necessary if TCP packets arrive in a random order. <br><br>  The logic of combining frames, in general, is as follows: <br><br><ul><li>  Take the first frame. <br></li><li>  Remember the value of the <code>opcode</code> field. <br></li><li>  Accept other frames and combine the frame payload until a frame is received with the <code>fin</code> bit set. <br></li><li>  Check that the <code>opcode</code> field for all frames except the first one is set to zero. <br></li></ul><br>  The main purpose of fragmentation is to allow the sending of messages, the size of which is unknown at the time the data is sent. <br><br>  Due to fragmentation, the server can pick up a buffer of a reasonable size, and when the buffer is full, send data to the network.  The second use of fragmentation is multiplexing, when it is undesirable for a message to occupy the entire logical communication channel.  As a result, for multiplexing purposes, you need to be able to break up messages into smaller fragments in order to better organize channel sharing. <br><br><h2>  <font color="#3AC1EF">About heartbeat messages</font> </h2><br>  At any time after the handshake procedure, either the client or the server may decide to send a ping message to the other party.  When receiving such a message, the recipient should send, as soon as possible, a pong-message.  This is the heartbeat message.  They can be used to check if the client is still connected to the server. <br><br>  The ping and pong messages are just control frames.  For ping messages, the <code>opcode</code> field is set to <code>0x9</code> , for pong messages, to <code>0xA</code> .  When receiving a ping message, in response, you must send a pong message containing the same payload as the ping message (for such messages, the maximum payload length is 125).  In addition, you can receive a pong message without sending a ping message before.  Such messages can simply be ignored. <br><br>  This messaging scheme can be very useful.  There are services (like load balancers) that stop idle connections. <br><br>  In addition, one of the parties cannot, without additional efforts, find out that the other party has completed the work.  Only the next time you send the data you can find out that something went wrong. <br><br><h2>  <font color="#3AC1EF">Error processing</font> </h2><br>  You can handle errors while working with WebSocket connections by subscribing to the <code>error</code> event.  It looks like this: <br><br><pre> <code class="hljs lua">var socket = new WebSocket(<span class="hljs-string"><span class="hljs-string">'ws://websocket.example.com'</span></span>); //  . socket.onerror = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'WebSocket Error: '</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>); };</code> </pre> <br><h2>  <font color="#3AC1EF">Connection closure</font> </h2><br>  In order to close the connection, either the client or the server must send a control frame with the <code>opcode</code> field set to <code>0x8</code> .  Upon receipt of a similar frame, the other party, in response, sends a frame to close the connection.  The first side then closes the connection.  Thus, data obtained after closing the connection is discarded. <br><br>  Here's how to initiate a WebSocket close operation on the client: <br><br><pre> <code class="hljs pgsql">//  ,   . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (socket.readyState === WebSocket.<span class="hljs-keyword"><span class="hljs-keyword">OPEN</span></span>) {   socket.<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>(); }</code> </pre> <br>  In addition, in order to perform a cleanup after completing the closure of a connection, you can subscribe to the <code>close</code> event: <br><br><pre> <code class="hljs lua">//  . socket.onclose = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event)</span></span></span></span> { console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">'Disconnected from WebSocket.'</span></span>); };</code> </pre> <br>  The server needs to listen for the <code>close</code> event in order to process it, if necessary: <br><br><pre> <code class="hljs actionscript">connection.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reasonCode, description)</span></span></span><span class="hljs-function"> </span></span>{   <span class="hljs-comment"><span class="hljs-comment">//  . });</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Comparison of WebSocket and HTTP / 2 technologies</font> </h2><br>  Although HTTP / 2 offers many features, this technology cannot completely replace existing push technologies and streaming data transfer methods. <br><br>  The first thing that is important to know about HTTP / 2, is that it is not a replacement for everything that is in HTTP.  The types of requests, status codes and most of the headers remain the same as when using HTTP.  HTTP / 2 innovations consist in increasing the efficiency of data transmission over the network. <br><br>  If we compare HTTP / 2 and WebSocket, we will see many similarities. <br><table><tbody><tr><td>  Indicator <br></td><td>  HTTP / 2 <br></td><td>  Websocket <br></td></tr><tr><td>  Header compression <br></td><td>  Yes (HPACK) <br></td><td>  Not <br></td></tr><tr><td>  Transfer of binary data <br></td><td>  Yes <br></td><td>  Yes (binary or text) <br></td></tr><tr><td>  Multiplexing <br></td><td>  Yes <br></td><td>  Yes <br></td></tr><tr><td>  Prioritization <br></td><td>  Yes <br></td><td>  Not <br></td></tr><tr><td>  Compression <br></td><td>  Yes <br></td><td>  Yes <br></td></tr><tr><td>  Direction <br></td><td>  Client / Server and Server Push <br></td><td>  Bidirectional data transfer <br></td></tr><tr><td>  Full duplex mode <br></td><td>  Yes <br></td><td>  Yes <br></td></tr></tbody></table><br>  As already mentioned, HTTP / 2 introduces Server Push technology, which allows the server to send data to the client cache on its own initiative.  However, when using this technology, data cannot be sent directly to the application.  The data sent by the server on its own initiative processes the browser, while there are no APIs that allow, for example, notifying the application of the receipt of data from the server and responding to this event. <br><br>  It is in this situation that Server-Sent Events (SSE) technology turns out to be very useful.  SSE is a mechanism that allows a server to asynchronously send data to a client after establishing a client-server connection. <br><br>  After connection, the server can send data at its discretion, for example, when the next data fragment is ready for transmission.  This mechanism can be thought of as a one-way <a href="https://en.wikipedia.org/wiki/Publish%25E2%2580%2593subscribe_pattern">publisher-subscriber</a> model.  In addition, as part of this technology, there is a standard JavaScript client API, called <code>EventSource</code> , implemented in most modern browsers as part of the HTML5 <a href="https://www.w3.org/TR/eventsource/">W3C standard</a> .  Note that for browsers that do not support the <a href="http://caniuse.com/">EventSource</a> API, there are polyfills. <br><br>  Since SSE is based on HTTP, it goes well with HTTP / 2.  It can be combined with some HTTP / 2 capabilities, which opens up additional perspectives.  Namely, HTTP / 2 provides an efficient transport layer based on multiplexed channels, and SSE provides applications with an API for transferring data from the server. <br><br>  To fully understand the capabilities of multiplexing and streaming, take a look at the IETF definition: <i>‚Äústream‚Äù is an independent, bidirectional sequence of frames transmitted between the client and the server as part of the HTTP / 2 connection.</i>  <i>One of its main characteristics is that one HTTP / 2 connection can contain several simultaneously open streams, and any endpoint can handle alternating frames from several streams</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/49c/c4e/dc7/49cc4edc739dc8af7261077c321048c6.png"><br><br>  SSE technology is based on HTTP.  This means that using HTTP / 2, not only several SSE streams can transmit data in one TCP connection, but the same can be done with a combination of several sets of SSE streams (sending data to the client at the initiative of the server) and several client requests (leaving the server). <br><br>  Thanks to HTTP / 2 and SSE, there is now the possibility of organizing bidirectional connections based solely on the capabilities of HTTP, and there is a simple API that allows data from servers to be processed in client applications.  Insufficient bi-directional data transfer capabilities were often considered a major disadvantage when comparing SSE and WebSocket.  Thanks to HTTP / 2, this flaw no longer exists.  This opens up possibilities for building data exchange systems between server and client parts of applications using only HTTP capabilities, without using WebSocket technology. <br><br><h2>  <font color="#3AC1EF">WebSocket and HTTP / 2.</font>  <font color="#3AC1EF">What to choose?</font> </h2><br>  Despite the extremely widespread use of the HTTP / 2 + SSE bundle, the WebSocket technology will most certainly not disappear, mainly due to the fact that it is well mastered and due to the fact that in very specific cases it has advantages over HTTP / 2, since it was created to provide two-way data exchange with less additional load on the system (for example, this concerns headers). <br><br>  Suppose you want to create an online game that needs to transfer a huge number of messages between clients and the server.  In this case, WebSocket is much better suited than the combination of HTTP / 2 and SSE. <br><br>  In general, we can recommend using WebSocket for cases when you need a really low level of delays, approaching, when organizing communication between the client and the server, to real-time data exchange.  Remember that such an approach may require rethinking how the server part of the application is built, as well as the fact that you may need to pay attention to other technologies, such as event queues. <br><br>  If you need, for example, to show users real-time news or market data, or you are creating a chat application, using the HTTP / 2 + SSE connection will give you an effective bidirectional communication channel, and, at the same time, the benefits of working with technologies from the world. HTTP  ,  WebSocket    ,          -,       HTTP-    ,    HTTP  .  ,       .  - (,   ,  ) ,       HTTP.  ,    ,   ,          HTTP-. <br><br>  ,        . ,       WebSocket: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59c/7c7/aec/59c7c7aeca1e2827b6e5668e5d4b4d58.png"><br><br>      . ,    HTTP/2    : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/408/8fd/67a/4088fd67aabf54b9ce4fc1d49e13e20c.png"><br><br>       HTTP/2   : <br><br><ul><li>  HTTP/2    TLS (,   ,     ). <br></li><li>    IE 11,    Windows 10. <br></li><li>    OSX 10.11+  Safari. <br></li><li>  HTTP/2    ,     ALPN (     ). <br></li></ul><br>  SSE, ,  : <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cdc/667/f27/cdc667f2774fa8edaf3118185fed1fd9.png"><br><br>      IE/Edge. (, Opera Mini    SSE,  WebSocket,       ,   ,   .) ,  IE/Edge   . <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  ,   WebSockets  HTTP/2+SSE ,     ,  ,  .   - ? ,                . ,       ,        . ,    ,  ,  SessionStack, ,    ,  WebSockets,  HTTP. <br><br>   SessionStack   -,        DOM, ,     , JS-,   ,   ,  ,        ,       .              -.             .     SessionStack   HTTP,         (     ).     WebSocket   ,        . ,  SessionStack,   -,  WebSocket, ,       WebSocket ,   HTTP. <br><br>          SessionStack.           ,   , ,   ,    ,    ,       WebSocket. <br><br>  Dear readers!     WebSocket  HTTP/2+SSE?   ‚Äî    ,       ,   ,    ,  . </div><p>Source: <a href="https://habr.com/ru/post/342346/">https://habr.com/ru/post/342346/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342334/index.html">Introduction to Neural Networks</a></li>
<li><a href="../342336/index.html">Migrating a database from InnoDB to MyRocks</a></li>
<li><a href="../342338/index.html">Where large companies are looking for innovation. Interview with Dmitry Izmestyev about the development of startups</a></li>
<li><a href="../342340/index.html">Buy ready MDM or develop your own?</a></li>
<li><a href="../342344/index.html">You are working in the wrong place (if you have an open office)</a></li>
<li><a href="../342348/index.html">Growth Formula for Mobile Products</a></li>
<li><a href="../342350/index.html">Now Wall Street: How Amazon, Alibaba, and Rakuten Will Change Finance (McKinsey Report)</a></li>
<li><a href="../342352/index.html">Compare Bitcoin with iPhone X, Dollar and Gold</a></li>
<li><a href="../342354/index.html">Another small step to C ++ 20. Meeting in Albuquerque</a></li>
<li><a href="../342356/index.html">Not every article needs an illustration.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>