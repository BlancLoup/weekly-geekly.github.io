<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Delegates and events in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator. Judging from my own experience, as well as from the experience of familiar fellow programmers, I can say that for a novice develo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Delegates and events in .NET</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator.</i>  <i>Judging from my own experience, as well as from the experience of familiar fellow programmers, I can say that for a novice developer, among all the basic functions of the C</i> # <i>language</i> <i>and the .NET platform, delegates and events are among the most complex.</i>  <i>Perhaps this is due to the fact that the need for delegates and events at first glance seems not obvious, or because of some confusion in terms.</i>  <i>Therefore, I decided to translate the article by John Skit, telling about delegates and events at the most basic level, ‚Äúon fingers‚Äù.</i>  <i>It is ideal for those familiar with C</i> # / <i>.NET, but has difficulty understanding delegates and events.</i> <i><br><br></i>  <i>The translation presented here is free.</i>  <i>However, if the term ‚Äúfree‚Äù, as a rule, is understood to be abbreviated translation, with omissions, simplifications and retellings, here it is the opposite.</i>  <i>This translation is a slightly expanded, refined and updated version of the original.</i>  <i>I express my <a href="https://habrahabr.ru/users/sergeyt/" class="user_link">deep</a> gratitude to Sergey Teplyakov, aka <a href="https://habrahabr.ru/users/sergeyt/" class="user_link">SergeyT</a> , who made an invaluable contribution to the translation and design of this article.</i> <br><br>  People often have difficulty understanding the differences between events and delegates.  And C # confuses the situation even more, as it allows you to declare field-like events that are automatically converted into a delegate variable with the same name.  This article is intended to clarify this issue.  Another point is the confusion with the term "delegate", which has several meanings.  Sometimes it is used to designate the <i>type of</i> delegate (delegate type), and sometimes to designate an <i>instance of the</i> delegate (delegate instance).  To avoid confusion, I will explicitly use these terms - the type of delegate and the delegate instance, and when I use the word "delegate" - that means I‚Äôm talking about them in the broadest sense. <br><a name="habracut"></a><br><h3>  Types of delegates </h3><br>  In a sense, you can think of a delegate type as some kind of interface, in which only one method is defined with a clearly defined signature (in this article, under the signature of the method, I will understand all its input and output parameters (ref and out) parameters, and return value).  Then the delegate instance is an object that implements this interface.  In this understanding, having a delegate instance, you can call any existing method, the signature of which will match the signature of the method defined in the ‚Äúinterface‚Äù.  Delegates have other functionality, but the ability to make method calls with predefined signatures is the very essence of delegates.  The delegate instance stores a reference (pointer, label) to the target method and, if this method is an instance method, then a reference to the object instance (class or structure) in which the target method is located. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The delegate type is declared using the <code>delegate</code> keyword.  The types of delegates can exist as independent entities, or be declared within classes or structures.  For example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">DelegateArticle</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FirstDelegate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sample</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SecondDelegate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b</span></span></span><span class="hljs-function">)</span></span>; } }</code> </pre><br>  In this example, two types of delegate are declared.  The first is <code>DelegateArticle.FirstDelegate</code> , which is declared at the namespace level.  It is ‚Äúcompatible‚Äù with any method that has one parameter of type <code>int</code> and returns a value of type <code>string</code> .  The second is <code>DelegateArticle.Sample.SecondDelegate</code> , which is already declared inside the class and is a member of it.  It is ‚Äúcompatible‚Äù with any method that has two parameters of type <code>char</code> and returns nothing, since the return type is marked as <code>void</code> . <br><br>  Note that both delegate types have a <code>public</code> access <code>public</code> .  In general, with respect to access modifiers, delegate types behave in the same way as classes and structures.  If the access modifier is not explicitly specified for the delegate type and this type is declared within the namespace, then it will be available for all objects that are also within this namespace.  If the delegate type without a modifier is declared inside a class or structure, it will be closed, similar to the action of the <code>private</code> modifier. <br><br>  When declaring a delegate type, you cannot use the <code>static</code> modifier. <br><br>  But remember that the <code>delegate</code> keyword does not always mean a delegate type declaration.  The same keyword is used when instantiating delegates when using anonymous methods. <br><br>  Both delegate types declared in this example are inherited from <a href="http://msdn.microsoft.com/en-us/library/system.multicastdelegate.aspx"><code>System.MulticastDelegate</code></a> , which, in turn, is inherited from <a href="http://msdn.microsoft.com/en-us/library/system.delegate.aspx"><code>System.Delegate</code></a> .  In practice, consider inheritance only from <code>MulticastDelegate</code> - the difference between <code>Delegate</code> and <code>MulticastDelegate</code> lies primarily in the historical aspect.  These differences were significant in beta versions of .NET 1.0, but this was inconvenient, and Microsoft decided to merge the two types into one.  Unfortunately, the decision was made too late, and when it was made, they did not dare to make such a serious change affecting the basis of .NET.  Therefore, assume that <code>Delegate</code> and <code>MulticastDelegate</code> are one and the same. <br><br>  Each delegate type you create inherits members from <code>MulticastDelegate</code> , namely: one constructor with the <code>Object</code> and <a href="http://msdn.microsoft.com/en-us/library/system.intptr.aspx"><code>IntPtr</code></a> parameters, as well as three methods: <code>Invoke</code> , <code>BeginInvoke</code> and <code>EndInvoke</code> .  We will return to the constructor a bit later.  Actually, these three methods are not inherited in the literal sense, since their signature for each type of delegate is different - it ‚Äúadjusts‚Äù to the signature of the method in the declared type of delegate.  Looking at the code sample above, we derive the ‚Äúinherited‚Äù methods for the first type of delegate <code>FirstDelegate</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> System.<span class="hljs-function"><span class="hljs-function">IAsyncResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginInvoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, System.AsyncCallback callback, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndInvoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncResult result</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  As you can see, the return type of the <code>Invoke</code> and <code>EndInvoke</code> matches the one specified in the delegate signature, as well as the parameter of the <code>Invoke</code> method and the first parameter of <code>BeginInvoke</code> .  We will look at the purpose of the <code>Invoke</code> method later in the article, while <code>BeginInvoke</code> and <code>EndInvoke</code> will look at the section on <a href="https://habr.com/ru/post/198694/">advanced use of delegates</a> .  It is still too early to talk about this, since we still don‚Äôt even know how to create instances of delegates.  We will talk about this in the next section. <br><br><h3>  Delegate Copies: Basics </h3><br>  We now know how the delegate type is declared and what it contains, so let's take a look at how to create an instance of the delegate and what can be done with it. <br><br><h5>  Creating delegate instances </h5><br>  First of all, I‚Äôll note that this article does not cover the new functionality of C # 2.0 and 3.0 related to instantiating delegates, nor does it cover the generic delegates that appeared in C # 4.0.  My separate article about the closures of ‚Äú <a href="http://csharpindepth.com/Articles/Chapter5/Closures.aspx">The Beauty of Closures</a> ‚Äù tells about the new features of delegates that appeared in C # 2.0 and 3.0;  In addition, a lot of information on this topic is contained in Chapters 5, 9, and 13 of my book, <a href="http://csharpindepth.com/">C # in Depth</a> .  I will adhere to the explicit style of instantiating delegates that appeared in C # 1.0 / 1.1, as I believe that such a style is easier for understanding what is going on under the hood.  That's when you comprehend the basics, you can begin to learn new features from C # 2.0, 3.0 and 4.0;  and vice versa, without a firm understanding of the fundamentals outlined in this article, the ‚Äúnew‚Äù delegates' functional can be overwhelming for you. <br><br>  As mentioned earlier, each delegate instance necessarily contains a reference to the target method that can be invoked through this delegate instance, and a reference to the object instance (class or structure) in which the target method is declared.  If the target method is static, then naturally there is no reference to the instance.  The CLR also supports other, slightly different forms of delegates, where the first argument passed to the static method is stored in the delegate instance, or the reference to the target instance method is passed as an argument when the method is called.  More information about this can be found in the documentation for <a href="http://msdn.microsoft.com/en-us/library/system.delegate.aspx"><code>System.Delegate</code></a> on MSDN, but now, at this stage, this additional information is not significant. <br><br>  So, we know that to create an instance we need two ‚Äúunits‚Äù of data (well, and the type of delegate itself, of course), but how to let the compiler know about it?  We use what is referred to in the C # specification as ‚Äú <i>delegate-creation-expression</i> ‚Äù, which is one of the <i>new delegate-type (expression)</i> forms.  An expression must either be a different delegate with the same type (or a compatible delegate type in C # 2.0), or the ‚Äúmethod group‚Äù, which consists of the name of the method and an optional reference to the object instance.  The group of methods is specified in the same way as the usual method call, but without any arguments and parentheses.  The need to create delegate copies is quite rare, so we will focus on more general forms.  Examples below. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">/*      d1  d2 .  InstanceMethod   ,    ,       ( ). ,     ‚Äî this,      . */</span></span> FirstDelegate d1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstDelegate(InstanceMethod); FirstDelegate d2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstDelegate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.InstanceMethod); <span class="hljs-comment"><span class="hljs-comment">/*  (d3)    ,     ,      ,        . */</span></span> FirstDelegate d3 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstDelegate(anotherInstance.InstanceMethod); <span class="hljs-comment"><span class="hljs-comment">/*   (d4)      ,  ,     ;        . */</span></span> FirstDelegate d4 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstDelegate(instanceOfOtherClass.OtherInstanceMethod); <span class="hljs-comment"><span class="hljs-comment">/*    (d5)     ,      ,     ( ). */</span></span> FirstDelegate d5 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstDelegate(StaticMethod); <span class="hljs-comment"><span class="hljs-comment">/*  (d6)      ,       . */</span></span> FirstDelegate d6 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstDelegate(OtherClass.OtherStaticMethod);</code> </pre><br>  The delegate constructor, which we talked about earlier, has two parameters - a reference to a method called of type <code>System.IntPtr</code> (in MSDN documentation this parameter is called method) and a reference to an instance of an object of type <code>System.Object</code> (in MSDN documentation this parameter is called target), which is null if the method specified in the method parameter is static. <br><br>  An important note needs to be made: delegate instances can refer to methods and instances of objects that will be invisible (out of scope) in relation to the place in the code where the delegate instance will be <i>called</i> .  For example, when creating a delegate instance, a private method can be used, and then this delegate instance can be returned from another public (public) method or property.  On the other hand, an instance of an object specified when creating an instance of a delegate may be an object that, when called, will be unknown with respect to the object in which the call was made.  The important thing is that both the method and the object instance must be accessible (be in scope) at the time the delegate is instantiated.  In other words, if (and only if) in the code you can create an instance of a specific object and call a specific method from that instance, then you can use this method and an object instance to create an instance of the delegate.  But when calling a previously created delegate instance, the access rights and scope are ignored.  Speaking of challenges ... <br><br><h5>  Call delegate instances </h5><br>  Instances of delegates are called in the same way as regular methods are called.  For example, invoking an instance of delegate d1, whose type is defined at the very top as <code>delegate string FirstDelegate (int x)</code> , would be as follows: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> result = d1(<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><br>  The method referenced by the delegate instance is called ‚Äúwithin‚Äù (or ‚Äúin context‚Äù, if in other words) of the object instance, if any, after which the result is returned.  Writing a full-fledged program that demonstrates the work of the delegates, and at the same time compact, not containing ‚Äúextra‚Äù code, is not an easy task.  However, below is a similar program containing one static and one instance method.  Calling <code>DelegateTest.StaticMethod</code> equivalent to calling <code>StaticMethod</code> ‚Äî I included the class name to make the example more understandable. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FirstDelegate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DelegateTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { FirstDelegate d1 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstDelegate(DelegateTest.StaticMethod); DelegateTest instance = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DelegateTest(); instance.name = <span class="hljs-string"><span class="hljs-string">"My instance"</span></span>; FirstDelegate d2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstDelegate(instance.InstanceMethod); Console.WriteLine (d1(<span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//    "Static method: 10" Console.WriteLine (d2(5)); //    "My instance: 5" } static string StaticMethod (int i) { return string.Format ("Static method: {0}", i); } string InstanceMethod (int i) { return string.Format ("{0}: {1}", name, i); } }</span></span></code> </pre><br>  The C # syntax on invoking delegate instances is syntactic sugar that masks the invocation of the <code>Invoke</code> method that each delegate type has.  Delegates can run asynchronously if they provide <code>BeginInvoke/EndInvoke</code> , but more on that <a href="https://habr.com/ru/post/198694/">later</a> . <br><br><h5>  Combining Delegates </h5><br>  Delegates can be combined (combined and subtracted) in such a way that when you call a single delegate instance, a whole set of methods are called, and these methods can be from different instances of different classes.  When I said earlier that a delegate instance stores references to a method and an object instance, I simplified it a little.  This is true for instances of delegates that represent one method.  For clarity, hereinafter I will call such <i>instances of delegates</i> "simple delegates" (simple delegate).  In contrast, there are instances of delegates that are actually lists of simple delegates, all of which are based on the same type of delegate (i.e., have the same signature of the methods referenced).  I will call such <i>instances of delegates</i> ‚Äúcombined delegates‚Äù.  Several combined delegates can be combined with each other, actually becoming one big list of simple delegates.  The list of simple delegates in a combined delegate is called the ‚Äúcall list‚Äù or ‚Äúaction list‚Äù (invocation list).  Thus, a call list is a list of pairs of references to methods and instances of objects that (pairs) are arranged in the order of the call. <br><br>  It is important to know that delegate instances are always immutable.  Each time when instances of delegates are merged (and also when subtracting ‚Äî we will look at this below), a new combined delegate is created.  <code>String.PadLeft</code> as with strings: if you apply <code>String.PadLeft</code> to an instance of a string, the method does not change this instance, but returns a new instance with the changes made. <br><br>  The union (also known as the term ‚Äúaddition‚Äù) of two instances of delegates is usually done using the addition operator, as if the instances of delegates were numbers or strings.  Similarly, subtraction (the term ‚Äúdeletion‚Äù also occurs) of one delegate instance from another is performed using the subtraction operator.  Note that when subtracting one combined delegate from another, subtraction is done as part of the call list.  If the original (reduced) call list does not contain one of those simple delegates that are in the subtracted call list, then the result of the operation (difference) will be the original list.  Otherwise, if there are simple delegates in the original list, which are also present in the subtracted, then only the <i>latest</i> entries of simple delegates will be missing from the resulting list.  However, it is easier to show with examples than to describe in words.  But instead of the next source code, I will demonstrate the work of combining and subtracting using the example of the following table.  In it, the literals d1, d2, d3 denote simple delegates.  Further, the designation [d1, d2, d3] implies a combined delegate, which consists of three simple in exactly this order, i.e.  when called, d1 will be called first, then d2, and then d3.  An empty call list is represented by null. <br><table><tbody><tr><th>  Expression </th><th>  Result </th></tr><tr><td>  null + d1 </td><td>  d1 </td></tr><tr><td>  d1 + null </td><td>  d1 </td></tr><tr><td>  d1 + d2 </td><td>  [d1, d2] </td></tr><tr><td>  d1 + [d2, d3] </td><td>  [d1, d2, d3] </td></tr><tr><td>  [d1, d2] + [d2, d3] </td><td>  [d1, d2, d2, d3] </td></tr><tr><td>  [d1, d2] - d1 </td><td>  d2 </td></tr><tr><td>  [d1, d2] - d2 </td><td>  d1 </td></tr><tr><td>  [d1, d2, d1] - d1 </td><td>  [d1, d2] </td></tr><tr><td>  [d1, d2, d3] - [d1, d2] </td><td>  d3 </td></tr><tr><td>  [d1, d2, d3] - [d2, d1] </td><td>  [d1, d2, d3] </td></tr><tr><td>  [d1, d2, d3, d1, d2] - [d1, d2] </td><td>  [d1, d2, d3] </td></tr><tr><td>  [d1, d2] - [d1, d2] </td><td>  null </td></tr></tbody></table><br>  In addition to the addition operator, delegate instances can be combined using the static <a href="http://msdn.microsoft.com/en-us/library/system.delegate.combine.aspx"><code>Delegate.Combine</code></a> method;  similarly to it, the subtraction operation has an alternative in the form of the static method <a href="http://msdn.microsoft.com/en-us/library/system.delegate.remove.aspx"><code>Delegate.Remove</code></a> .  Generally speaking, addition and subtraction operators are a kind of syntactic sugar, and the C # compiler, meeting them in code, replaces calls to the Combine and Remove methods.  And precisely because these methods are static, they easily handle null instances of delegates. <br><br>  The addition and subtraction operators always work as part of the assignment operation <code>d1 += d2</code> , which is completely equivalent to the expression <code>d1 = d1+d2</code> ;  the same for subtraction.  Again, recall that the instances of delegates involved in addition and subtraction do not change during the operation;  in this example, the variable d1 simply replaces the reference to the newly created combined delegate consisting of the ‚Äúold‚Äù d1 and d2. <br><br>  Note that adding and deleting delegates occurs at the end of the list, so the sequence of calls is x + = y;  x - = y;  equivalent to an empty operation (the variable x will contain an unchanged list of subscribers, <i>approx. transl.</i> ). <br><br>  If the delegate type signature is declared such that it returns a value (that is, the return value is not void) and a combined delegate instance is created ‚Äúbased on‚Äù this type, then when it is called, the return value ‚Äúprovided‚Äù by the last simple delegate will be written to the variable. in the call list of the combined delegate. <br><br>  If there is a combined delegate (containing a list of calls consisting of a set of simple delegates), and when it is called in some simple delegate, an exception occurs, then the call of the combined delegate will stop, the exception will be forwarded, and all other simple delegates from the call list never be called. <br><br><h3>  Developments </h3><br>  First of all: events (event) are not instances of delegates.  And now again: <br>  <b>Events are NOT delegate instances.</b> <br><br>  In a sense, it is a pity that the C # language allows you to use events and delegate instances in certain situations in the same way, but it is very important to understand the difference. <br><br>  I came to the conclusion that the best way to understand events is to think of them as ‚Äúas if‚Äù properties.  Properties, although they look like ‚Äútype as‚Äù fields (fields), in fact, they are definitely not - you can create properties that do not use fields at all.  Events behave in a similar way - although they look like instances of delegates in terms of addition and subtraction operations, but in fact they are not. <br><br>  Events are pairs of methods that are appropriately ‚Äústyled‚Äù in IL (CIL, MSIL) and related to each other so that the language environment clearly knows that it ‚Äúdeals‚Äù not with ‚Äúsimple‚Äù methods, but with methods that represent events.  The methods correspond to the <i>add</i> (add) and <i>remove</i> (remove) operations, each of which takes one parameter with an instance of a delegate that has a type that is the same as the event type.  What you will do with these operations is largely up to you, but usually add and delete operations are used to add and remove delegate instances to / from the list of event handlers.  When an event is triggered (and no matter what caused the trigger ‚Äî click on a button, a timer, or an unhandled exception), the call to the handlers occurs (one by one).  Be aware that in C #, calling event handlers is <i>not</i> part of the event itself. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The add and remove methods are called in C # </font></font><code>eventName += delegateInstance;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and so </font></font><code>eventName -= delegateInstance;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, where it </font></font><code>eventName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be specified by reference to an object instance (for example </font></font><code>myForm.Click</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) or by type name (for example </font></font><code>MyClass.SomeEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). However, static events are quite rare. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Events themselves can be announced in two ways. The first method is with an explicit implementation of the add and remove methods; This method is very similar to properties with explicitly declared getters (get) and setters (set), but with the keyword event. The following is an example of a property for a delegate type.</font></font><code>System.EventHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Note that in the add and remove methods, there are no operations with delegate instances that are passed there - the methods simply output to the console that they were called. If you execute this code, you will see that the remove method will be invoked, despite the fact that we passed it a null value for deletion.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Test</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent <span class="hljs-comment"><span class="hljs-comment">//  MyEvent   EventHandler { add { Console.WriteLine ("add operation"); } remove { Console.WriteLine ("remove operation"); } } static void Main() { Test t = new Test(); t.MyEvent += new EventHandler (t.DoNothing); t.MyEvent -= null; } //-,        EventHandler void DoNothing (object sender, EventArgs e) { } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The moments when it is necessary to ignore the obtained value </font></font><code>value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">appear quite rarely. </font><font style="vertical-align: inherit;">And although there are very few cases where we can ignore the value passed in this way, there are times when we cannot use the simple delegate variable to keep subscribers. </font><font style="vertical-align: inherit;">For example, if a class contains many events, but subscribers will use only some of them, we can create an associative array, the key of which will be the description of the event, and the value - the delegate with its subscribers. </font><font style="vertical-align: inherit;">This technique is used in Windows Forms - i.e. </font><font style="vertical-align: inherit;">A class can contain a huge number of events without unnecessary use of memory for variables, which in most cases will be equal to null.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Field-like events </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C # provides an easy way to declare a delegate variable and an event at the same time. </font><font style="vertical-align: inherit;">This method is called a "field-like event" (field-like event) and is declared very simply - just like the "long" form of event declaration (given above), but without the "body" with the add and remove methods.</font></font><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This form creates a delegate variable and an event with the same type. </font><font style="vertical-align: inherit;">Access to an event is defined in an event declaration using an access modifier (thus, in the example above, a public event is created), but the delegate variable is always private. </font><font style="vertical-align: inherit;">The implicit body of the event is deployed by the compiler into quite obvious operations of adding and deleting delegate instances to / from the delegate variable, and these actions are performed under lock. </font><font style="vertical-align: inherit;">For C # 1.1, the event </font></font><code>MyEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the example above is equivalent to the following code:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventHandler _myEvent; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler MyEvent { <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { _myEvent += <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">remove</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { _myEvent -= <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is for the instance members. As for static events, the variable is also static and the lock is captured on the type of the view.</font></font><code>typeof(XXX)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where XXX is the name of the class in which the static event is declared. C # 2.0 makes no guarantees about what is used to capture locks. It says only that the only object associated with the current instance is used to block instance events, and the only object associated with the current class to block static events. (Note that this is true only for events declared in classes, but not in structures. There are problems with blocking events in structures; and in practice I don‚Äôt remember a single example of a structure in which an event was announced.) But none of this not as useful as you might think, for details see the </font></font><a href="https://habr.com/ru/post/198694/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">section on multithreading</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, what happens when you refer to</font></font><code>MyEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Inside the body of the type itself (including nested types), the compiler generates code that refers to the delegate variable ( </font></font><code>_myEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the example above). </font><font style="vertical-align: inherit;">In all other contexts, the compiler generates code that refers to an event.</font></font><br><br><h3>  What's the point of this? </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we know both about delegates and about events, a completely natural question arises: why do we need both in the language? </font><font style="vertical-align: inherit;">The answer is due to encapsulation. </font><font style="vertical-align: inherit;">Suppose that in some fictional C # /. NET event does not exist. </font><font style="vertical-align: inherit;">How then can a third-party class subscribe to an event? </font><font style="vertical-align: inherit;">Three options:</font></font><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Public variable (field) with delegate type. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Private variable (field) with a delegate type with a wrapper in the form of a public property. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Private variable (field) with delegate type with public methods AddXXXHandler and RemoveXXXHandler. </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option number 1 is terrible - we usually hate public fields. Option # 2 is slightly better, but allows subscribers to effectively override (override) one single thing - it will be too easy to write an expression </font></font><code>someInstance.MyEvent = eventHandler;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, as a result of which all existing handlers will be </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">replaced</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with </font></font><code>eventHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, instead of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adding</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to existing ones </font></font><code>eventHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Plus, you still need to explicitly set the property code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option number 3 is, in fact, what the events provide to you, but with a guaranteed agreement (generated by the compiler and reserved by special flags in IL) and with a ‚Äúfree‚Äù implementation, if only you are happy with the semantics of field-like events. </font><font style="vertical-align: inherit;">Subscribing and unsubscribing to / from events is encapsulated without providing random access to the list of event handlers, which makes it possible to simplify the code for subscription and unsubscribe operations.</font></font><br><a name="threadsafe"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thread safe events </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Note: with the release of C # 4, this section is somewhat outdated. From the translator: see details in the section ‚Äú </font></font><a href="https://habr.com/ru/post/198694/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the translator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Earlier, we touched upon the blocking (locking) that occurs in field-like events during add and remove operations that are automatically implemented by the compiler . This is done in order to provide some kind of thread safety guarantee. Unfortunately, it is not so useful. First of all, even in the C # 2.0 specifications, you can set a lock on a link to this object or to the type itself in static events. This is contrary to the principles of blocking on private links, which is necessary to prevent deadlocks.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ironically, the second problem is the exact opposite of the first - due to the fact that in C # 2.0 you cannot guarantee which lock will be used, you also cannot use it when you trigger an event to make sure that you see the newest ( actual) value in this stream. You can use a lock on something else or use special methods that work with memory barriers, but all this leaves an unpleasant aftertaste </font></font><sup><a href="https://habr.com/ru/post/198694/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 ‚Üì</font></font></a></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want your code to be truly thread-safe, such that when you raise an event, you always use the most current value of the delegate variable, and also so that you can make sure that add / remove operations do not interfere with one another, then to achieve You need to write the body of the add / remove operations yourself for such a ‚Äúreinforced concrete‚Äù thread safety. Example below:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    SomeEventHandler,  ¬´¬ª . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> SomeEventHandler someEvent; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">       SomeEvent. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> readonly object someEventLock = new object(); </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public event SomeEventHandler SomeEvent { add { lock (someEventLock) { someEvent += value; } } remove { lock (someEventLock) { someEvent -= value; } } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   SomeEvent </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected virtual void OnSomeEvent(EventArgs e) { SomeEventHandler handler; lock (someEventLock) { handler = someEvent; } if (handler != null) { handler (this, e); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can use a single lock for all of your events, and even use this lock for something else ‚Äî this already depends on the specific situation. Note that you need to ‚Äúwrite‚Äù the current value to a local variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock (in order to get the most current value), then check this value to null and execute </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outside the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lock: holding the lock during the event call is a very bad idea. easily leading to a deadlock. To explain this, imagine that an event handler must wait for another thread to do some of its work, and if during that time another thread causes an add / remove operation for your event, then you will get a deadlock.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The above code works correctly because once the local variable </font></font><code>handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is assigned the value someEvent, the value of the handler will not change even if it changes itself </font></font><code>someEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If all event handlers unsubscribe from the event, then the call list will be empty, </font></font><code>someEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will become null, but </font></font><code>handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will store its value, which will be what it was at the time of the assignment. In fact, delegate instances are immutable, so any subscribers who subscribe between assignment ( </font></font><code>handler = someEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and event ( </font></font><code>handler (this, e);</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">call </font><font style="vertical-align: inherit;">will be ignored.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, you need to determine whether you need thread safety at all. Are you going to add and remove event handlers from other threads? Are you going to trigger events from different threads? If you are in complete control of your application, then the very no and very easy-to-implement answer will be. If you are writing a class library, then most likely providing thread safety will come in handy. If you definitely do not need thread safety, then it is a good idea to self-implement the body of add / remove operations so that they do not explicitly use locks; after all, as we remember, C # when autogenerating these operations uses its ‚Äúown‚Äù ‚Äúwrong‚Äù locking mechanism. In this case, your task is very simple. Below is an example of the above code, but without thread safety.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    SomeEventHandler,  ¬´¬ª . </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> SomeEventHandler someEvent; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public event SomeEventHandler SomeEvent { add { someEvent += value; } remove { someEvent -= value; } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   SomeEvent </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> protected virtual void OnSomeEvent(EventArgs e) { if (someEvent != null) { someEvent (this, e); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If at the time of the method call the </font></font><code>OnSomeEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delegate variable </font></font><code>someEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not contain a list of delegate instances (due to the fact that they were not added via the add method or deleted via the remove method), then the value of this variable will be null and to avoid calling it with this value, and A check for null has been added. </font><font style="vertical-align: inherit;">This situation can be solved in a different way. </font><font style="vertical-align: inherit;">You can create an instance of the delegate stub (no-op) that will be bound to the ‚Äúdefault‚Äù variable and will not be deleted. </font><font style="vertical-align: inherit;">In this case, in the method </font></font><code>OnSomeEvent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you just need to get and call the value of the delegate variable. </font><font style="vertical-align: inherit;">If the ‚Äúreal‚Äù instances of the delegates have not been added, then the stub will simply be called.</font></font><br><a name="other"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Delegate Instances: Other Methods </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Earlier in the article, I showed that a call </font></font><code>someDelegate(10)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is just an abbreviation for a call </font></font><code>someDelegate.Invoke(10)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In addition </font></font><code>Invoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, delegate types have asynchronous behavior through a pair of methods </font></font><code>BeginInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the CLI, they are optional, but in C # they are always there. They follow the same asynchronous execution model as the rest of .NET, allowing you to specify a callback handler along with an object storing state information. As a result of an asynchronous call, the code is executed in threads created by the system and located in the thread pool (thread-pool) .NET. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the first example, shown below </font></font><sup><a href="https://habr.com/ru/post/198694/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 ‚Üì</font></font></a></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , there are no callbacks, they are simply used here </font></font><code>BeginInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and</font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in one thread. Such a code pattern is sometimes useful when one thread is used for operations that are generally synchronous, but at the same time contains elements that can be executed in parallel. For the sake of simplicity of the code, all the methods in the example are static, but you can, of course, use "asynchronous" delegates along with instance methods, and in practice this will happen even more often. The method </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">returns the value that is returned as a result of invoking the delegate instance. If an exception is raised during the invocation of the delegate instance, this exception will be thrown and </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleDelegate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AsyncDelegateExample1</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SampleDelegate counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleDelegate(CountCharacters); SampleDelegate parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleDelegate(Parse); IAsyncResult counterResult = counter.BeginInvoke(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); IAsyncResult parserResult = parser.BeginInvoke(<span class="hljs-string"><span class="hljs-string">"10"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"   ID = {0}  "</span></span>, Thread.CurrentThread.ManagedThreadId); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  '{0}'"</span></span>, counter.EndInvoke(counterResult)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  '{0}'"</span></span>, parser.EndInvoke(parserResult)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"   ID = {0} "</span></span>, Thread.CurrentThread.ManagedThreadId); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountCharacters</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">2000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"    '{0}'    ID = {1}"</span></span>, text, Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.Length; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  '{0}'    ID = {1}"</span></span>, text, Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(text); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Method calls </font></font><code>Thread.Sleep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are inserted only in order to demonstrate that the methods </font></font><code>CountCharacters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>Parse</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actually carried out in parallel with the main flow. </font><font style="vertical-align: inherit;">A sleep of </font></font><code>CountCharacters</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 seconds is large enough to force the thread pool to perform tasks in other threads ‚Äî the thread pool serializes queries that do not take much time to execute, so as to avoid excessive creation of new threads (creating new threads is a relatively resource-intensive operation) . </font><font style="vertical-align: inherit;">By putting the stream to sleep for a long time, we thus imitate a ‚Äúheavy‚Äù, time-consuming task. </font><font style="vertical-align: inherit;">And here is the output of our program:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	Main thread with ID = 9 continues</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	Parsing the string '10' in the stream with ID = 10</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	Counting characters in the string 'hello' in the stream with ID = 6</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	Counter returned '5'</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	Parser returned '10'</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	Main thread with id = 9 terminated</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the process of executing a delegate in a third-party thread has not yet completed, then the method call </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the main thread will have a similar effect to the call </font></font><code>Thread.Join</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for manually created threads - the main thread will wait until the task is completed in the third-party thread. </font><font style="vertical-align: inherit;">The value </font></font><code>IAsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is returned by the method </font></font><code>BeginInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and passed to the input </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used to transfer the state from </font></font><code>BeginInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(through the last parameter - </font></font><code>Object state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), however, the need for such a transfer when using delegates does not often occur.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code above is fairly simple, but not efficient enough compared to the callback model that is called after the delegate has completed its execution. As a rule, it is in the callback method </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that the </font><font style="vertical-align: inherit;">method </font><font style="vertical-align: inherit;">that returns the result of delegate execution is called. Although theoretically, this call still blocks the main thread (as in the above example), but in practice the thread will not be blocked, since the callback method is executed only when the delegate has completed its task. The callback method can use a state with some additional data that will be passed to it from the method</font></font><code>BeginInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The example below uses the same delegates to parse and count the number of characters per line as in the example above, but this time with a callback method in which the result is output to the console. The </font></font><code>state</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type </font><font style="vertical-align: inherit;">parameter </font><font style="vertical-align: inherit;">is </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to send information about the format in which to output the result to the console, and because of this we can use the same callback method </font></font><code>DisplayResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to handle both asynchronous delegate calls. Note the cast </font></font><code>IAsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to type </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: value received by the callback is always the instance </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and through it we can get the original copy of the delegate, the result of which is obtained using </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Here, a little weird is that the type is </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">declared in the namespace</font></font><code>System.Runtime.Remoting.Messaging</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(which you need to connect), while all other types are declared in </font></font><code>System</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>System.Threading</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Runtime.Remoting.Messaging; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleDelegate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> data</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AsyncDelegateExample2</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { SampleDelegate counter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleDelegate(CountCharacters); SampleDelegate parser = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SampleDelegate(Parse); AsyncCallback callback = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncCallback(DisplayResult); counter.BeginInvoke(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>, callback, <span class="hljs-string"><span class="hljs-string">"  '{0}'    ID = {1}"</span></span>); parser.BeginInvoke(<span class="hljs-string"><span class="hljs-string">"10"</span></span>, callback, <span class="hljs-string"><span class="hljs-string">"  '{0}'    ID = {1}"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"   ID = {0}  "</span></span>, Thread.CurrentThread.ManagedThreadId); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">3000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"   ID = {0} "</span></span>, Thread.CurrentThread.ManagedThreadId); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DisplayResult</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAsyncResult result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> format = (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>)result.AsyncState; AsyncResult delegateResult = (AsyncResult)result; SampleDelegate delegateInstance = (SampleDelegate)delegateResult.AsyncDelegate; Int32 methodResult = delegateInstance.EndInvoke(result); Console.WriteLine(format, methodResult, Thread.CurrentThread.ManagedThreadId); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountCharacters</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">2000</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"    '{0}'    ID = {1}"</span></span>, text, Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> text.Length; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { Thread.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"  '{0}'    ID = {1}"</span></span>, text, Thread.CurrentThread.ManagedThreadId); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>.Parse(text); } }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This time almost all work is done in threads from the thread pool. </font><font style="vertical-align: inherit;">The main thread simply initiates asynchronous tasks and ‚Äúfalls asleep‚Äù until all these tasks are completed. </font><font style="vertical-align: inherit;">All threads from the thread pool are background (background) threads that cannot ‚Äúhold‚Äù the application (i.e., they cannot prevent it from closing), and so that the application does not terminate before the delegates work in the background threads, we and applied the call </font></font><code>Thread.Sleep(3000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the main thread - you can hope that 3 seconds will be enough to complete and complete the delegates. </font><font style="vertical-align: inherit;">You can check this by commenting out the line </font></font><code>Thread.Sleep(3000)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- the program will end almost instantly after launch.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of our program is presented below. </font><font style="vertical-align: inherit;">Pay attention to the order of results output to the console - the result of the parser appeared before the result of the counter, as the environment does not guarantee the preservation of order when called </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the previous example, the parsing was completed much faster (100 ms) than the counter (2 seconds), but the main thread waited for both of them to display, first of all, the result of the counter, and only then the parser.</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">	Main thread with ID = 9 continues</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	Parsing the string '10' in the stream with ID = 11</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	The parser returned '10' in the stream with ID = 11</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	Counting characters in the 'hello' string in the stream with ID = 10</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	The counter returned '5' in the stream with ID = 10</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
	Main thread with id = 9 terminated</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember that when using this asynchronous model you must call </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">this is necessary in order to guarantee the absence of memory leaks and handlers. </font><font style="vertical-align: inherit;">In some cases, in the absence of </font></font><code>EndInvoke</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">leaks may not be, but do not hope so. </font><font style="vertical-align: inherit;">For more information, you can refer to my article ‚Äú </font></font><a href="http://yoda.arachsys.com/csharp/threads/index.shtml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Multi-threading in .NET: Introduction and Suggestions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù on multi-threading, in particular, to the ‚Äú </font></font><a href="http://yoda.arachsys.com/csharp/threads/threadpool.shtml"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Thread Pool and Asynchronous Methods</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù section.</font></font><br><br><h3>  Conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delegates provide an easy way to call methods based on instances of objects and with the ability to transfer some data. </font><font style="vertical-align: inherit;">They are the basis for events, which themselves are an effective mechanism for adding and removing handlers to be called at an appropriate time.</font></font><br><br><h3>  Notes </h3><br><a name="ref1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approx.</font></font></i>  <i>trans.</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I admit, John Skyte's explanation is rather vague and crumpled. </font><font style="vertical-align: inherit;">To understand in detail why locking on the current instance and type is bad, and why you should enter a separate read-only private field, I highly recommend using the book "CLR via C #" written by Jeffrey Richter, which has already gone through 4 editions. </font><font style="vertical-align: inherit;">If we talk about the second edition of 2006, translated into 2007 into Russian, then the information on this problem is located in ‚ÄúPart 5. CLR Tools‚Äù - ‚ÄúChapter 24. Flow Synchronization‚Äù - the section ‚ÄúWhy the‚Äú great ‚Äùidea was so unsuccessful ".</font></font><br><br><a name="ref2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approx.</font></font></i>  <i>trans.</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This and the following code samples, as well as their output to the console, were slightly modified compared to the original examples from J. Skit. </font><font style="vertical-align: inherit;">In addition to the translation, I added the output of thread identifiers so that you can clearly see which code is running in which thread.</font></font><br><br><a name="fromtranslator"></a><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> From translator </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Despite the rather large size of the article, one cannot but agree that the topic of delegates and events is much more extensive, complex and multifaceted. </font><font style="vertical-align: inherit;">However, a hypothetical article that fully describes delegates and events would have a size similar to the size of an average book. </font><font style="vertical-align: inherit;">Therefore, I provide links to the most useful articles on the topic, and those that complement this article as harmoniously as possible. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alexey Dubovtsev. </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delegates and Events</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (RSDN).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although the article is not new (dated 2006) and considers only the basics of delegates and events, the level of ‚Äúreviewing the basics‚Äù is much deeper: here you can look more closely at the type of MulticastDelegate, especially in terms of combined delegates, and describe the principle of working at the MSIL level, and the description of EventHandlerList, and more. In general, if you want to consider the basics of delegates and events at a deeper level, then this article is definitely for you. </font></font><br><br> <a href="https://habrahabr.ru/users/coffeecupwinner/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coffeecupwinner</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="http://habrahabr.ru/post/148562/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET events in detail</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope you paid attention to the article about outdated material at the beginning of the section " </font></font><a href="https://habr.com/ru/post/198694/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-safe events</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"? In C # 4, the internal implementation of field-like events, which Skyt and Richter criticize, has been completely reworked: now thread safety is implemented through Interlocked.CompareExchange, without any blocking. About this, among other things, and tells this article. In general, the article meticulously examines only events, but at a much deeper level than that of John Skeet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daniel Grunwald. </font></font><a href="https://habrahabr.ru/users/andreycha/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andreycha</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="http://habrahabr.ru/post/89529/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weak events in C #</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When talking about the benefits between C # /. NET on the one hand and C ++ on the other, the advantage of the first among other things, is recording automatic garbage collection, which eliminates memory leaks as a class of errors. </font><font style="vertical-align: inherit;">However, not everything is so rosy: events can lead to memory leaks, and this very detailed article is devoted to the solution of these problems. </font></font><br><br> <a href="https://habrahabr.ru/users/rroyter/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rroyter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="http://habrahabr.ru/post/143925/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why do we need delegates in C #? </font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As I mentioned in the introduction, novice developers have misunderstandings with delegates due to the lack of visible reasons requiring their use. </font><font style="vertical-align: inherit;">This article very lucidly demonstrates some situations where delegates will be extremely relevant. </font><font style="vertical-align: inherit;">In addition, the delegates introduced new features introduced in C # 2 and 3 versions.</font></font></div><p>Source: <a href="https://habr.com/ru/post/198694/">https://habr.com/ru/post/198694/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198682/index.html">Aho-Korasik Algorithm</a></li>
<li><a href="../198684/index.html">Step-by-step guide on binding SIP-numbers to Elastix (FreePBX, Asterisk) on the example of the provider Megaline iDPhone</a></li>
<li><a href="../198688/index.html">New concept of using VoIP on the example of Wi-Fi IP-phone Escene WS220-N</a></li>
<li><a href="../198690/index.html">Dropbox-light or my desktop on the Internet</a></li>
<li><a href="../198692/index.html">FAVORaim: we are starting to build a neural network and analyze the interests of users</a></li>
<li><a href="../198696/index.html">How to test only what you need</a></li>
<li><a href="../198700/index.html">Linux Installation, configuration, administration. Now Available!</a></li>
<li><a href="../198702/index.html">Problem solving: 10 manager rules</a></li>
<li><a href="../198704/index.html">Cloud content management system database</a></li>
<li><a href="../198706/index.html">Customs wants a percentage of cross-border purchases</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>