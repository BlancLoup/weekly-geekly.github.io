<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We control the quality of the code using the SonarQube platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will look at the main features of SonarQube, a platform for continuous analysis and measurement of code quality, and also discuss ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We control the quality of the code using the SonarQube platform</h1><div class="post__text post__text-html js-mediator-article"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/688/dd3/790/688dd3790b6d716e43bd04da96b1a579.png" height="300" alt="Picture 50"></div><p></p><br>  In this article, we will look at the main features of SonarQube, a platform for continuous analysis and measurement of code quality, and also discuss the merits of a code quality assessment methodology based on SonarQube metrics. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  Our company is developing a PVS-Studio static code analyzer.  We are convinced that choosing the appropriate development methodology and following it, applying proven techniques and tools significantly increases the likelihood that the code will be written correctly and the final product will meet the required quality standards.  One of these methodologies is the use of static source code analysis.  Static analysis, used in conjunction with other code metrics, makes it possible to assess the current state of the code base, the dynamics of this state, and possible risks during project implementation. <br><br>  To begin, I will briefly tell you about the presentation of the analysis results of PVS-Studio.  The results of the work of our static analyzer PVS-Studio are saved in the xml format.  The list of error messages can be opened directly in the Microsoft Visual Studio window or in a separate Standalone utility, and you can work with these errors using the code navigation, sorting, filtering, suppressing false positives, etc. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/58f/5e6/5ec/58f5e65ec727a5a7e429278b49e50d60.png" alt="Picture 5"></p><br>  The list of errors found in the xml format can be converted to one of the readable formats, for example, html.  Such reports with the results of the analysis can be sent to all interested project participants by mail.  Another way of notifying project participants is sending error lists to developers who have made them.  For this, users can use special utilities supplied in the PVS-Studio distribution kit. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Speaking about the capabilities of PVS-Studio, we should mention the functionality for the <a href="http://www.viva64.com/ru/m/0032/">mass suppression of diagnostic messages</a> .  If static analysis was implemented in the later stages of the application's life cycle, when the size of the code base has reached a large size, code inspection can lead to the detection of a large number of errors.  Perhaps at this point in time, the team lacks the resources necessary to correct all errors.  In this case, developers can hide all messages issued on the current revision of the code, and concentrate on errors found in newly written or modified code. <br><br>  The dynamics of the number of errors found by PVS-Studio can be obtained using the <a href="http://www.viva64.com/ru/m/0034/">Analysis Statistics</a> functionality of the PVS-Studio plugin for Microsoft Visual Studio or the Standalone utility: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6cf/332/a05/6cf332a059785abb94e51736b8a2be99.png" alt="Picture 4"></p><br>  The listed methods of presenting the results of our static analyzer, however, exist by themselves and are not related to other code metrics, such as the number of lines of code, cyclomatic complexity, the number of errors per 1000 lines of code, the level of code coverage by unit tests, duplication, and so on.  The report on the errors found after the next analysis and the number of these errors does not answer the questions: do we have a lot of errors or few?  How is the dynamics of the number of errors associated with the growth of the code base?  Is code quality improving or deteriorating?  And, probably, the most important question of managers: when will everything work (how long will it take to eliminate errors)?  These questions made us think about how to make PVS-Studio reports more valuable and informative. <br><br>  Why is it useful to collect and monitor code metrics?  It is impossible to improve what you do not measure.  Suppose some team does not collect code metrics.  With the development of the project, the code base may become worse and worse, and for a long time no one will even notice this until at some point the amount of technical debt reaches such a size that support and the addition of new functionality will cost more and more.  If the team constantly monitored the code metrics, it would see the dynamics of the state of its project and, upon reaching certain threshold values, would start to sound the alarm. <br><br>  Next, let's say the team realized the problem and convinced its manager that it was necessary to spend resources on improving the quality of the code.  The manager, in turn, will ask the team a few simple questions: how long will it take for the team?  What parts of the project need to be improved?  How many bugs are you going to fix?  By what criteria do you estimate that the quality of the code has reached the required level, and you can again return to the development of new functionality?  Using metrics will answer all these questions.  If before starting work on improving the quality of the code, the team will record the current state of the code for each component of the product and determine the threshold values ‚Äã‚Äãfor each metric, the achievement of which will allow you to state with a certain degree of confidence that the product code has become high-quality, you can predict the end date and stop when certain thresholds will be reached.  For example, the team will be able to show the manager that after completing work on improving the quality of the code, the level of coverage with modular tests reached 90%, adherence to the coding standards adopted by the company reached 95%, and duplication of the code was reduced to 5%, etc. <br><br><h2>  Why SonarQube? </h2><br>  SonarQube is an open source platform designed for continuous analysis and measurement of code quality.  SonarQube provides the following features: <br><br><ul><li>  Support for Java, C, C ++, C #, Objective-C, Swift, PHP, JavaScript, Python, etc. </li><li>  Provides reports on code duplication, compliance with coding standards, code coverage with unit tests, possible code errors, code comment density, technical debt, and more. </li><li>  Saves the history of metrics and builds graphs of changes of these metrics over time. </li><li>  Provides fully automated analysis: integrates with Maven, Ant, Gradle and common continuous integration systems. </li><li>  Allows you to integrate with IDEs such as Visual Studio, IntelliJ IDEA and Eclipse using the SonarLint plugin. </li><li>  Provides integration with external tools: JIRA, Mantis, LDAP, Fortify, etc. </li><li>  You can extend existing functionality with third-party plug-ins. </li><li>  Implements the SQALE methodology for assessing technical debt. </li></ul><br>  An impressive list, right?  You yourself can get acquainted with the capabilities of SonarQube and try it in action by clicking on the link <a href="https://sonarqube.com/">https://sonarqube.com/</a> .  SonarSource provides this service for analyzing open source projects, and if you have an open source project on GitHub, you can upload it to <a href="https://sonarqube.com/">https://sonarqube.com/</a> and use SonarQube reports to control the quality of your project code. <br><br>  We have carefully studied the capabilities of the SonarQube platform and decided that these capabilities may be of interest to our customers.  Therefore, we have decided to develop a plugin for importing the results of the analysis of PVS-Studio. <br><br>  At about the same time, one of our customers expressed interest in implementing a centralized repository of various code metrics.  The client is developing a very large (more than 10 million lines of code) and long-term (more than 15 years of active development) project.  Naturally, in such a project there is a lot of inherited code and associated skeletons in the closet, and in this case, in my opinion, it is absolutely necessary to develop and implement a set of metrics to evaluate the status of the project code and the dynamics of changes in this state over time.  Naturally, our client made a decision on collecting and analyzing metrics long ago, and implemented various utilities for monitoring code quality indicators, such as: code coverage with modular tests, test run results, duplication of code blocks, adherence to accepted coding standards, code comment density, and so on .d  In parallel with the collection of these metrics, static code analysis was performed daily.  The use of a large number of utilities led to the complication of the configuration of the continuous integration server, writing additional scripts to convert the results of each utility into a convenient form for presenting and combining all the indicators into a single report.  This approach required significant resources to create and support this reporting system. <br><br>  Based on the needs of the client and our study of the capabilities of the SonarQube platform, we proposed to implement this platform.  What was done.  As part of the implementation task, a plug-in for SonarQube was implemented, which allows you to import the results of the PVS-Studio analysis into SonarQube.  The process of SonarQube deployment and its integration with the existing environment (assembly system, continuous integration server, version control system) did not cause difficulties due to logical configuration mechanisms and a large number of detailed documentation.  Widgets were set up to evaluate both the state of the client‚Äôs project portfolio as a whole and the state of each project individually; Quality Profiles and Quality Gates were set up (I‚Äôll discuss SonarQube mechanisms below) according to the client‚Äôs needs, automatic assignment of tasks to performers, distribution of notifications to all interested parties. <br><br>  As a result of the implementation of the SonarQube, the client received a centralized system for storing and displaying code metrics, which makes it possible to evaluate and predict project risks.  The transition from individual tools to a centralized code quality control system not only simplifies the deployment and support of this system, but also allows you to make a qualitative leap in project management, providing all interested participants with tools for monitoring project status and making weighted decisions.  After the test operation, the client decided to include SonarQube in the existing ALM (Application Lifecycle Management) toolkit. <br><br>  It should be noted that SonarQube, thanks to its extensive integration with other tools, can easily become an integral part of your ALM framework.  Using plug-ins in SonarQube, you can add support for Git, SVN, Mercurial, Team Foundation Version Control, ClearCase, configure authorization via LDAP, GitHub, Bitbucket, Azure Active Directory, import the results of third-party analyzers.  SonarLint plug-ins for IntelliJ IDEA, Eclipse, and Visual Studio allow you to analyze the code in real time in your favorite IDE using the rules defined in the SonarQube profile.  Integration with Team Foundation Server and Visual Studio Team Services is also available.  You can run code analysis and data import into SonarQube directly from the build process on these systems, or, for example, manage build status in Team Foundation Server and Visual Studio Team Services using Quality Gates (build quality indicators), available in SonarQube: if the code does not meet the requirements of the Quality Gate, the build will be considered failed.  Thus, SonarQube developers seek to make their product as open as possible and allow development teams to integrate SonarQube into their environment. <br><br>  For which projects and teams is it advisable to implement SonarQube?  I believe that for relatively short-term projects (no more than 2‚Äì3 months) in which small teams are engaged (no more than 5 people), investments in the implementation of SonarQube in the development process may not be justified.  As a rule, such projects do not require large expenditures for product support.  For such projects, I would recommend limiting it to separate tools for monitoring the status of a project code: a static analyzer, monitoring code coverage by tests, compliance with coding standards, etc., which the team is used to using. <br><br>  On large projects that require significant resources, with a long life cycle, the introduction of the SonarQube platform into the development process is justified.  Moreover, the introduction of SonarQube can benefit at any stage of the project development.  The optimal strategy, in my opinion, is the implementation of the SonarQube in the early stages of the development cycle, which will allow the team to analyze the quality control reports from the very beginning and to be sure that the specified quality standards of the code are observed.  Implementing the SonarQube at a later stage of development may potentially require a lot of money to improve the quality of the code.  For example, it may turn out that static analysis revealed a large number of potential errors, there is a large amount of technical debt, the code is not covered by tests, public APIs are not documented, etc.  Nevertheless, identifying product risks at any stage of the life cycle allows us to correctly respond to these risks and plan actions to minimize them. <br><br>  For example, a team can agree that if a piece of code is changed as part of the development of new functionality, all technical debt in this code will be eliminated.  Investing in eliminating the deficiencies found will further reduce the cost of product support and the development of new functionality.  Also, if the product has been on the market for a long time, and, despite the fact that the code quality inspection revealed a large number of problems, the behavior in the production environment is quite stable and there are not enough resources at the current time to improve the quality of the code base, you can postpone this investment.  SonarQube provides an opportunity to focus on problems that have appeared in the new code.  This functionality is similar to the mass message suppression functionality in PVS-Studio. <br><br><h2>  How SonarQube helps evaluate code quality </h2><br>  The SonarQube quality model is based on the implementation of the SQALE (Software Quality Assessment based on Lifecycle Expectations) methodology with certain additions.  As is known, the SQALE methodology focuses mainly on the complexity of code maintenance (maintainability) and does not take into account the risks of a project.  For example, if today a critical safety problem was discovered in a project, strict adherence to the SQALE methodology obliges you to eliminate all existing problems with reliability (reliability), possibility of changes (changeability), testability, etc., and only then return to the new critical issue.  In fact, if potential problems have existed in the code for a long time and do not manifest themselves in the form of user bug reports, it is much more important to focus on fixing new bugs. <br><br>  With this in mind, the SonarQube developers modified the quality model based on SQALE to highlight the following important points: <br><br><ul><li>  The quality model should be as easy to use as possible. </li><li>  Bugs and vulnerabilities should not be lost among maintainability issues </li><li>  The presence of serious bugs and vulnerabilities in the project should lead to the fact that the Quality Gate requirements are not met </li><li>  Code maintainability issues are important too and cannot be ignored. </li><li>  Calculating the cost of troubleshooting (using the SQALE analysis model) is important and should be performed. </li></ul><br>  The Standard Quality Gate SonarQube uses the following metric values ‚Äã‚Äãto determine that the code passed the validation successfully: <br><br><ul><li>  0 new bugs </li><li>  0 new vulnerabilities </li><li>  technical debt ratio on the new code &lt;= 5% </li><li>  new code coverage not lower than 80% </li></ul><br>  The Sonar team identified the seven deadly sins of developers who increase technical debt: <br><br><ul><li>  Bugs and potential bugs </li><li>  Breaking Coding Standards </li><li>  Code duplication </li><li>  Insufficient coverage with unit tests. </li><li>  Poor distribution of complexity </li><li>  Spaghetti design </li><li>  Not enough or too many comments. </li></ul><br>  The SonarQube platform is designed to help fight these seven sins. <br><br>  Let us consider in more detail the main features of the SonarQube. <br><br><h3>  Home page </h3><br>  On the SonarQube main page, you can see a list of projects added to the system, with brief statistics on each project: build version, number of lines of code, number of bugs, vulnerabilities and signs of ‚Äútidy code‚Äù, last analysis date: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4ea/763/25a/4ea76325ae0accbd481b632e5bdb8c26.png" alt="Picture 7"></p><br>  You can customize the contents of the main page to suit your goals with a large set of built-in widgets that allow you to visualize the status of the project code in SonarQube. <br><br><h3>  Project Metrics </h3><br>  For more detailed information on the project status, go to the project metrics page: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/221/0a2/150/2210a215052586f9864017951fa29fdd.png" alt="Picture 9"></p><br>  Information on the following code metrics is presented here: Reliability, Security, Maintainability, Coverage, Duplications, Size (code base size), Complexity, Documentation. code) and Issues. <br><br>  Turning to Reliability metric, we get information on the total number of detected bugs and new bugs found during the last analysis, the code reliability rating on a scale from A to E, where E is the worst rating, indicating that at least one was found Blocker bug, as well as the time required to eliminate all errors found: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/999/190/03d/99919003d36420fd51b4be20e675d7ed.png" alt="Picture 11"></p><br>  The SonarQube platform allows analyzing code metrics from top to bottom, from the project level as a whole to individual modules and files.  So, for example, if you click on a reliability rating (Reliability Rating), you will see a list of project files, sorted by increase in reliability rating.  This will allow focusing on the most problematic areas of the code: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/af2/a66/870/af2a6687078538df2d49d4f9b14ff651.png" alt="Picture 13"></p><br>  Then you can go to the file with the source code and to specific parts of the code in which errors are found: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/955/f98/85c/955f9885c53a7a3135d06acca526fe60.png" alt="Picture 15"></p><br>  This top-down navigation is also available for other metrics. <br><br>  The Security metrics page provides information on the total number of vulnerabilities, new vulnerabilities, security rating (also on a scale from A to E), and the time it takes to fix vulnerabilities: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/33f/af1/d18/33faf1d18f6e3ff1e040cf71dd6a1fcb.png" alt="Picture 17"></p><br>  The Maintainability page contains information about the technical duty in the project: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3a/561/ea0/f3a561ea09511bf7c9543174b5b6d8b8.png" alt="Picture 19"></p><br>  Thanks to the top-down navigation, you can go to the list of files sorted by the number of detections of a code with a nice one: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/45a/b7e/d42/45ab7ed423fa156c69cc0b9b023e4c96.png" alt="Picture 21"></p><br>  and then directly to the code that requires attention: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a24/4c0/ddf/a244c0ddf4fbe22b96c9096473c24b65.png" alt="Picture 23"></p><br>  The Coverage page provides information on code coverage with tests: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac6/2aa/5d8/ac62aa5d8e2191f8e9fe4b01c812cba4.png" alt="Picture 25"></p><br>  The Duplications page contains information about duplicating code in a project: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bb4/abc/ef1/bb4abcef1e5844d67fa513b95212a4cd.png" alt="Picture 27"></p><br>  With this metric, you can easily find duplicate lines, blocks of code, and even entire files: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e0f/a8c/546/e0fa8c546aed3e9913d2d8346cc0b553.png" alt="Picture 29"></p><br>  The Size page contains information about the size of the project: the number of lines of code, expressions, functions, classes, files and directories: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e28/d36/be5/e28d36be58f974c18226708590cd43fa.png" alt="Picture 31"></p><br>  The Complexity page provides information on the total cyclomatic complexity of the project, as well as on the average complexity of functions and files: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/16f/e20/fde/16fe20fdefa2852ba021726a4afc85b8.png" alt="Picture 33"></p><br>  The Documentation page provides information about comments in the code: the ratio of lines with comments to the total number of lines in a project, the number of lines with comments, the number of public APIs and the level of documentation of public APIs: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/01e/fb1/af4/01efb1af4b30f2335b9c2319023acb5d.png" alt="Picture 35"></p><br>  The last tab in the project metrics section - Issues - contains the total number of problems found in the code (the sum of the number of bugs, vulnerabilities and code smells), as well as the distribution of problems according to the state: open, reopened, confirmed, false positives and won't fix: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/94d/19a/dca/94d19adcadafeb9dc54ecd545c76823b.png" alt="Picture 37"></p><br><h3>  Error and Code Navigation </h3><br>  After analyzing the code metrics, let's see how SonarQube allows you to work with the problems found in the code.  To do this, go to the Issues section: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/cb0/706/105/cb0706105b01f713d65010355ed0bb19.png" alt="Picture 39"></p><br>  Here are all the problems found in the code with extensive filtering capabilities, which allows you to focus on the most important problems.  It should be noted that SonarQube allows you to save filter settings to reuse them. <br><br>  By double clicking on the error message, you can go to the code where the problem was found.  Also available is a detailed description of the error and recommendations how to fix it: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9f0/bfa/3ec/9f0bfa3ec3566cbd851836d344f1b0ea.png" alt="Picture 41"></p><br>  Please also note that, thanks to the integration with version control systems, you can see who and when made changes to the code that triggered the analyzer: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4ff/4c6/afc/4ff4c6afc6ca55b12b42fc287491b814.png" alt="Picture 43"></p><br>  Integration with version control systems also allows you to automatically assign bugs in SonarQube to those developers who have allowed them.  You can also assign bugs to developers manually, change their type (bug, vulnerability or code smell), importance, tags, add comments.  For more convenience, the function of mass change of bugs is available: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a4f/15c/040/a4f15c0404fa3e9c72379ceed767f06a.png" alt="Picture 44"></p><br><h3>  Rules, Quality Profiles and Quality Gates </h3><br>  Diagnostic Rules (Rules), Quality Profiles (Quality Profiles) and Quality Limits (Quality Gates) are key understandings of the SonarQube platform.  Each plug-in for SonarQube, which performs static code analysis, contains a repository with a description of the diagnostic rules that this plug-in executes.  Violations of these rules are used to determine the technical duty in the code and calculate the time to troubleshoot problems.  For ease of use, the rules are combined into quality profiles (Quality Profiles).  By default, SonarQube creates a default quality profile for each supported language, but you can create your own quality profiles with a set of diagnostic rules that you may find useful.  For example, to analyze critical projects whose code quality requirements are the most stringent, you can define a quality profile containing all available diagnostics, and for less critical projects you can define a less strict quality profile containing only serious errors, which will allow you not to be distracted by minor code. smells. <br><br>  Quality Gate is an indicator of compliance (or inconsistency) of the project code with the specified threshold metrics.  By default, all projects added to SonarQube use the standard quality gate, which defines the following metrics and their thresholds: <br><ul><li>  New bugs = 0 </li><li>  New vulnerabilities = 0 </li><li>  Ratio of technical debt on the new code &lt;= 5% </li><li>  Coverage of the new code&gt; = 80% </li></ul><br>  Based on your own requirements for the quality of the source code, you can change the standard quality gate or create a new one by adding or removing those metrics and their threshold values ‚Äã‚Äãthat are of interest to you. <br><br><h2>  PVS-Studio and SonarQube </h2><br>  To import the analysis results to SonarQube, we have developed a sonar-pvs-studio-plugin plugin.  Using the plug-in allows you to add messages found by the PVS-Studio analyzer to the message base of the SonarQube server.  The plugin contains a repository with a description of the diagnostics that our static analyzer performs.  After you add our plug-in to SonarQube, you will see a repository called PVS-Studio for C, C ++ and C # languages: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d44/03d/949/d4403d9496710c4fb29e34ca671b8898.png" alt="Picture 45"></p><br>  Diagnostic messages of PVS-Studio in the plugin repository are accompanied by detailed error descriptions with code examples and recommendations for resolving the problem: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8a7/b2a/272/8a7b2a2727f26698c7508f36c0abbf48.png" alt="Picture 47"></p><br>  After static analysis of the project code and importing the results into SonarQube, using filters you can, for example, select all the unresolved problems found by PVS-Studio: <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0bf/0e9/bc6/0bf0e9bc6b790dbfbaf22beb9d8d9bee.png" alt="Picture 49"></p><br>  To add the PVS-Studio analysis results to SonarQube, just install the sonar-pvs-studio-plugin plugin, add the PVS-Studio diagnostics from the plugin's repository to the Quality Profile and pass the path to the PVS-Studio report file in the sonar.pvs-studio.reportPath property when you start the scanner SonarQube. <br><br>  SonarQube developers recommend using <a href="http://docs.sonarqube.org/display/SCAN/Analyzing%2Bwith%2BSonarQube%2BScanner%2Bfor%2BMSBuild">SonarQube Scanner for MSBuild</a> to analyze MSBuild projects.  This scanner is a wrapper over the standard SonarQube scanner and facilitates the process of creating the configuration file of the sonar-project.properties scanner, automatically adding modules (projects in the solution) to it and recording the paths to the source files that need to be analyzed. <br><br>  However, we are faced with important, from our point of view, limitations of the SonarQube Scanner for MSBuild. <br><br>  First, when analyzing C / C ++ projects, this scanner will add to the list of files for analysis only those files that have been added to the ClCompile and ClInclude properties of the project file .vcxproj.  If, for example, the header file is not explicitly included in the project and is included in the code of one of the source files, this file will be ignored, and the results of the analysis of this file will be missing in the SonarQube. <br><br>  Secondly, SonarQube Scanner for MSBuild does not add for analysis the source files located higher in the directory tree than the directory in which the project file is located.  Messages for such files will also be missing in SonarQube. <br><br>    ,     PVS-Studio      SonarQube.        sonar-project.properties .        <a href="http://docs.sonarqube.org/display/SCAN/Analyzing%2Bwith%2BSonarQube%2BScanner%2Bfor%2BMSBuild">Analyzing with SonarQube Scanner</a> . <br><br>  ,  SonarQube     ,     ,    (.sln)   (.vcxproj/.csproj).      ,         ,     ,   sonar.projectBaseDir          (  ,     ),    sonar.sources   ,         (     ). <br><br>         sonar.sources       ,        ‚Äî  .    ,       ,        SonarQube. <br><br>            ,        code smells,       SonarQube  Security  Maintainability   .   ,          Duplications, Complexity  Documentation. <br><br><h2>  Conclusion </h2><br>      ,  SonarQube           .     (, ,    ): if you can't measure it, you can't improve it.    ,        ,    ,   ,           ,      .     ¬´-.     ¬ª     : <br><br> " <i>  ¬´ ¬ª ( ,      )  .    ,  .      ,   .            ¬´  ¬ª,    .      ,    ,  ,    .</i> <br><br> <i> ,  ,    ,     .    ,       ,       ,     ,    .</i> <br><br> <i>  ,         ¬´ ¬ª    .      ,             .     .</i>  ". <br><br>  SonarQube    ¬´ ¬ª.  SonarQube,          , ,       ,       ¬´ ¬ª,                  . SonarQube    ,      .  ,         ,    ,       . <br><br>      SonarQube           ,      ALM-,         .           .      PVS-Studio,         SonarQube,          . <br><br>    SonarQube  , <a href="http://www.sonarqube.org/downloads/"> </a>   .  SonarQube                   . <br><br>      ,    C/C++  C#,     <a href="http://www.viva64.com/ru/pvs-studio-download/">PVS-Studio</a> . <br><br><h2>  useful links </h2><br><ul><li> <a href="http://www.sonarqube.org/"> SonarQube</a> </li><li> <a href="http://docs.sonarqube.org/display/SONAR/Documentation"> SonarQube</a> </li><li> <a href="https://sonarqube.com/">  SonarQube</a> </li><li> <a href="http://docs.sonarqube.org/display/PLUG/Plugin%2BLibrary">  SonarQube</a> </li><li> <a href="http://www.viva64.com/ru/m/0037/">   PVS-Studio  SonarQube</a> </li></ul><br><br><div style="text-align:center;"> <a href="http://www.viva64.com/en/b/0452/"><img src="https://habrastorage.org/getpro/habr/post_images/35e/064/ddf/35e064ddf91f5d99b620384893909ff7.png"></a> </div><br>        ,      : Pavel Kusnetsov. <a href="http://www.viva64.com/en/b/0452/">Control source code quality using the SonarQube platform</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Read the article and have a question?</b> <div class="spoiler_text">  Often our articles are asked the same questions.  We collected answers to them here: <a href="http://www.viva64.com/ru/a/0085/">Answers to questions from readers of articles about PVS-Studio, version 2015</a> .  Please review the list. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/315422/">https://habr.com/ru/post/315422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../315410/index.html">Bilateral data binding with ECMAScript-2015 without proxy</a></li>
<li><a href="../315414/index.html">Pro web client 1C</a></li>
<li><a href="../315416/index.html">Personal experience of receiving the Blue Card in Germany 2015-2016. Part 3: Arriving in Germany</a></li>
<li><a href="../315418/index.html">Polish clouds. Price notes (not only for Ukrainians)</a></li>
<li><a href="../315420/index.html">How to create elusive goals in the game 2016 Hitman</a></li>
<li><a href="../315424/index.html">Creation of the world Experience of creating intelligent life with their own hands</a></li>
<li><a href="../315428/index.html">The first private city in Russia, to be or not to be? Part 1</a></li>
<li><a href="../315430/index.html">We write the protocols of counters Mercury 230 and Mercury 200 for OpenSCADA</a></li>
<li><a href="../315432/index.html">Veeam Availability Suite 9.5 released - what's new?</a></li>
<li><a href="../315434/index.html">Connect (); // 2016: Text Translation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>