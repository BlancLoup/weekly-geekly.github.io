<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About the design. Part 2. Practical examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As we discussed last time , the design is not simple; constantly have to keep in mind a bunch of different options and try to find a compromise among ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About the design. Part 2. Practical examples</h1><div class="post__text post__text-html js-mediator-article">  As we discussed <a href="http://habrahabr.ru/post/148050/">last time</a> , the design is not simple;  constantly have to keep in mind a bunch of different options and try to find a compromise among the many different requirements, tearing your elegant solution to pieces.  On the one hand, I want the solution to be simple to maintain, well expandable, with high performance, and it should be understandable not only to its author, but to at least one other person;  I want the solution to eat little memory and not violate any of the 100,500 principles of the PLO, and, most importantly, we want to finish it at least this year, although the manager constantly insists that it should have been ready a month ago. <br><br>  Many of these criteria are not very compatible with each other, so sooner or later we come to the conclusion that good design is like <i>that</i> , trying to squeeze through dozens of conflicting requirements and find a reasonable compromise that maximally satisfies the most weighty requirements without forgetting that the weight of these requirements may also change over time. <br><a name="habracut"></a><br><br>  Due to its ambiguity, you can find many examples where two different teams prefer different criteria;  one group may consider the security of a solution a more important criterion, while the other group may prefer efficiency.  This ambiguity leads to the fact that a whole zoo of technologies is used on different projects, and all of them can differ greatly from each other in implementation issues (yes, to go far, even within the .Net Framework, it is quite easy to find different solutions to the same tasks). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But stop philosophizing, let's look at some more or less specific examples. <br><br><h5>  <b>Efficiency and maintainability</b> </h5><br>  I think that one of the most common compromises that most developers face is a compromise between the efficiency (productivity) of a solution and its maintainability. <br><br>  Let's look at this example. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeType</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _i = <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _s = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> _d; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d</span></span></span><span class="hljs-function">)</span></span> { _d = d; } }</code> </pre> <br><br>  This is quite a typical example when a certain class contains default values, initialized when a field is declared.  However, this example leads to some swelling of the code, since the C # compiler converts it into something like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeType</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _i = <span class="hljs-number"><span class="hljs-number">42</span></span>; _s = <span class="hljs-string"><span class="hljs-string">"42"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// System.Object::ctor(); } public SomeType(double d) { _i = 42; _s = "42"; // System.Object::ctor(); _d = d; }</span></span></code> </pre><br><br>  Thus, all fields initialized during the declaration get their values ‚Äã‚Äãeven <b>before calling the base class constructor</b> , thanks to this we can access them even from virtual methods called from the base class constructor, and also that all readonly fields will be guaranteed initialized ( but in any case, do not use this trick!).  But we get this behavior due to the "swelling" of the code, which is duplicated in each constructor. <br><br>  Jeffrey Richter in his excellent book ‚ÄúCLR via C #‚Äù gives the following advice: since the use of field initialization during declarations can lead to swelling of the code, you should consider selecting a separate constructor that does all the basic initialization and explicitly call it from other designers. <br><br>  Obviously, here we are confronted with the classic compromise of readability and maintainability versus efficiency.  In general, Richter's advice is quite reasonable, just do not follow him blindly.  When solving such a dilemma, we must clearly understand whether it is worth reducing the <b>readability</b> (after all, you have to look for the right constructor every time to look at the default values) and <b>maintainability</b> (what if someone adds a new constructor and forgets to call the default constructor) the performance gains we get?  In most cases, the answer will be: ‚ÄúNo, not worth it!‚Äù, But if this class is a library class or simply instantiated a million times, then my answer will not be so unequivocal. <br><br>  <b>NOTE</b> <br>  You should not think that I dispute Jeffrey Richter's opinion, you just need to clearly understand that Richter is ‚Äúmade of a different test‚Äù than most of us;  he is used to solving lower-level tasks, where every millisecond counts, but this is not so important to most application developers. <br><br><h5>  <b>Safety and efficacy</b> </h5><br>  Another very common compromise in the design of some solutions is the choice between structure and class (between a significant type and a reference type).  On the one hand, structures up to a certain size (on the order of 24 bytes on the x86 platform) can significantly improve performance due to the lack of memory allocation in the managed heap.  But on the other hand, in the case of changeable significant types, we can get a number of very nontrivial problems, since the behavior may be far from what many developers assume. <br><br>  <b>NOTE</b> <b><br></b>  Many people consider changeable significant types as the greatest evil of modern times.  If you do not understand what they are talking about or simply do not agree with this opinion, then it is worth looking at an article entitled <a href="http://sergeyteplyakov.blogspot.com/2011/07/blog-post.html">‚ÄúOn the harm of changeable significant types‚Äù</a> , perhaps after that, your opinion will change;) <br><br>  Let's look at a more specific example.  When implementing the collection enumerator, the author must decide how to implement this enumerator: as a class or as a structure.  In the first case, we get a much safer solution (after all, the enumerator is a ‚Äúmutable‚Äù type), and in the second case, a more effective one. <br><br>  So, for example, the enumerator of the <b>List</b> <b>&lt;</b> <b>T</b> <b>&gt;</b> class is a structure, which means that in the following code snippet you will get behavior that will be unexpected for most of your colleagues: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Items = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }.GetEnumerator() }; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x.Items.MoveNext()) { Console.WriteLine(x.Items.Current); }</code> </pre><br><br>  Most of the developers who see such behavior, quite reasonably outraged by the stupidity of comrades from Redmond, who clearly decided to make fun of the poor brother programmer.  However, things are not so simple. <br><br>  In the life of any collection, sooner or later there is a moment when someone wants to look at its internal contents.  In some cases (for example, in the case of arrays and lists) an indexer can be used for these purposes, but in most cases the collection is <b>iterated</b> using a <b>foreach loop</b> (directly or indirectly).  For most of us, one additional allocation of memory in the heap for each cycle seems trivial, but the .NET environment is quite universal, and cycles are one of the most common constructions of modern programming languages.  And if all this happens not on a four-core processor, but on a mobile device, then such a decision by the BCL developers will no longer seem so delusional. <br><br>  The choice between a class and a structure (especially if the structure is changeable) is a very serious decision, which the designer must have an exact understanding of what he will receive in one case and what he will lose in the other. <br><br><h5>  <b>Simplicity</b> <b>vs</b> <b>versatility</b> </h5><br>  When it comes to higher-level design, it is often a problem of choice: how much should our solution be universal, or is it enough to restrict ourselves to solving a specific task, and only then proceed to a generalized solution? <br><br>  Many programmers and architects intuitively believe that the best way to deal with changing requirements is versatility.  <b>If today the customer needs only a toothpick, then let's immediately make a Swiss knife with the function of a toothpick, just in case, and suddenly the requirements will change!</b> <br><br>  In fact, neither we nor our customers need a universal solution in and of itself;  all we need is to <b>provide our solution with a certain flexibility, which will allow it to be adapted after changing the existing requirements</b> .  At the same time, by and large, nobody is interested in how this flexibility will be ensured: at the expense of simplicity or universality;  whether a change in the configuration file will be required, or it will be necessary to add or change a couple of classes ‚Äî this is not so important.  It is only important how much effort the team will have to spend on a new opportunity and what the consequences will be for this decision (if the entire system collapses after such a change). <br><br>  When it comes to making this choice, and we decide whether to make a ‚ÄúSwiss knife‚Äù from the very beginning or not, I tend to take a compromise solution.  As I wrote in <a href="http://sergeyteplyakov.blogspot.com/2012/04/blog-post_19.html">the reuse</a> note, the most effective solution to this problem is a simple solution from the very beginning, which is summarized in one of the subsequent iterations, when this is necessary. <br><br>  The use of ingenious architectural constructions is still the same premature optimization as the unreasonable use of ingenious language constructs.  Versatility for the most part implies additional complexity, and if your expansion points are not directed where the wind of change blows, then you will get just an overly complex and unnecessary solution. <br><br>  When designing classes and methods, I use the following rule: any module, class, or method must ‚Äúexpose‚Äù a minimum amount of information.  This means that all classes and methods by default should be with the smallest possible scope of visibility: classes - internal (internal), methods - private.  It sounds like the statement of the famous captain, but very often we put out "well, here's another method, it won't get any worse."  The initial solution should be as simple as possible;  the less our clients have dependencies on our implementation, the easier it is for these clients to live and the easier it is for us to change our classes.  Remember that <b>encapsulation is not only hiding a class or module implementation details, it also protects customers from unnecessary details.</b> <br><br><h5>  <b>Libraries and usability</b> </h5><br>  There is a certain type of tasks, the solution of which I would not entrust to any person.  No, the point is not, I would not have entrusted this task to someone other than myself, there are simply certain tasks that are badly solved by one person, regardless of his level.  Many tasks are much better solved jointly, but there is one type of tasks for which ‚Äúanother opinion‚Äù is simply necessary - we are talking about the development of libraries and frameworks. <br><br>  If you look through the wonderful book <a href="http://sergeyteplyakov.blogspot.com/2009/06/framework-design-guidelines-2nd-edition.html">‚ÄúFramework Design Guidelines‚Äù</a> , then from the very first pages it will become clear that the priorities of the library developer are greatly shifted compared to the application developer.  If the application developer's main criterion is simplicity, ease of maintaining the code and reducing the time-to-market, then the library developer has to think not so much about himself as about his main client: the library user. <br><br>  <b>The developer of the library can score on all the principles of OOP, if they contradict the main principle of the library - simplicity and intuitive use.</b>  A library can be quite complex to maintain, since every solution added to it can never (or almost never) be changed. <br><br>  If during the design of the application we can afford to make a mistake and change a dozen of even open interfaces, then everything becomes much more complicated when your class has a couple dozen external users.  Martin Fowler has a wonderful article called <a href="http://martinfowler.com/ieeeSoftware/published.pdf">Published vs Public Interfaces</a> , in which he makes a clear distinction between these two concepts.  The cost of changes to any ‚Äúpublished‚Äù interface increases dramatically, which means that the mistake made when developing the first versions of the library can and will haunt its developer for many years (here is a great example described recently by Eric Lippert <a href="http://blogs.msdn.com/b/ericlippert/archive/2012/06/25/foolish-consistency-is-foolish.aspx">‚ÄúFoolish Consistency is Foolish‚Äù</a> ).  It is for this reason that Microsoft is in no hurry to make hundreds, if not thousands of very useful classes from the .NET Framework public, because each new public class significantly increases the cost of maintenance. <br><br>  The solutions to all the compromises described above are sharply different when we move from applications to libraries.  Micro-optimizations, extensibility, dirty hacks, the problem of ‚Äúbreaking changes‚Äù, consistency (even to the detriment of many other important factors), all this is found in libraries all the time.  That is why, when it comes to most of the tips related to software development, you need to clearly understand that this is most likely related to the development of application applications, rather than specialized libraries. <br><br><h5>  <b>Conclusion</b> </h5><br>  Most of the compromises that we face can be divided into several categories.  First, you need to clearly understand whether it is a framework (or a widely used reuse library) or an application.  Here you need to understand that these two worlds are quite different and very well shifting priorities when choosing between two compromise solutions. <br><br>  Another very important criterion when choosing one or another solution is the understanding of long term and short term benefits (long term vs short term benefits).  One solution may be good for solving today's problem, but it will certainly add a number of problems in the future.  Do not forget the <a href="http://sergeyteplyakov.blogspot.com/2011/05/blog-post.html">"technical duty"</a> , and that such metaphors will be able to convince not only colleagues, but also the customer of the importance of "long-term prospects" when making this or that decision. <br><br>  And finally, do not forget that programming is an applied discipline, not an end in itself, so experience, pragmatism and common sense, here are three very useful tools for solving most problems. </div><p>Source: <a href="https://habr.com/ru/post/148640/">https://habr.com/ru/post/148640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148634/index.html">If TrueCrypt stopped working after upgrading to Mountain Lion (10.8)</a></li>
<li><a href="../148636/index.html">Why large customers do not work with small but proud contractors</a></li>
<li><a href="../148637/index.html">DataSets in Web services are a product of the devil and all the world's evil</a></li>
<li><a href="../148638/index.html">Protection against universal in-app shopping hacks</a></li>
<li><a href="../148639/index.html">Pure CSS principle of cicada</a></li>
<li><a href="../148643/index.html">User-Experience: Submission of e-reporting in the State Tax Service of Ukraine</a></li>
<li><a href="../148648/index.html">JavaScript framework Meteor received $ 11 million investment</a></li>
<li><a href="../148649/index.html">Software engineering at HSE, for applicants</a></li>
<li><a href="../148650/index.html">A way to get a coupon on OS X Mountain Lion</a></li>
<li><a href="../148651/index.html">Allegro Cadence 16.5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>