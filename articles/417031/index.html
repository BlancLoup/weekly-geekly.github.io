<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mobile OAuth 2.0 Security</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! I am Nikita Stupin, information security specialist at Mail.Ru Mail. Not so long ago, I conducted a study on mobile OAuth 2.0 vulnerabilities. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mobile OAuth 2.0 Security</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/205/605/cd5/205605cd5b166f65aa8085fe1606779f.jpg"><br><br>  Hello!  I am Nikita Stupin, information security specialist at Mail.Ru Mail.  Not so long ago, I conducted a study on mobile OAuth 2.0 vulnerabilities.  To create a secure mobile OAuth 2.0 scheme, it‚Äôs not enough to implement the standard in its pure form and check redirect_uri.  It is necessary to take into account the specifics of mobile applications and apply additional security mechanisms. <br><br>  In this article I want to share with you the knowledge of attacks on mobile OAuth 2.0, methods of protection and secure implementation of this protocol.  All the necessary protection components, which I will discuss below, are implemented in the latest SDK for Mail.Ru mobile clients. <br><a name="habracut"></a><br><h1>  The nature and function of OAuth 2.0 </h1><br>  OAuth 2.0 is an authorization protocol that describes how a client service can securely access user resources on a service provider.  At the same time, OAuth 2.0 saves the user from having to enter a password outside the service provider: the whole process comes down to clicking the "I agree to provide access to ..." button. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A provider in terms of OAuth 2.0 is a service that owns user data and, with the user's permission, provides third-party services (clients) with secure access to this data.  The client is an application that wants to receive user data from the provider. <br><br>  Some time after the release of the OAuth 2.0 protocol, regular developers adapted it for authentication, although initially it was not intended for this.  Authentication shifts the attack vector from user data stored by the service provider to user accounts of the service client. <br><br>  Only one authentication is not limited to.  In the era of mobile applications and exalting the conversion, entering the application with one button became very attractive.  The developers have put OAuth 2.0 on mobile rails.  Naturally, few people thought about the security and specifics of mobile applications: once and again, and in production.  However, OAuth 2.0 generally does not work well outside of web applications: the same problems are observed in mobile and desktop applications. <br><br>  Let's see how to make a secure mobile OAuth 2.0. <br><br><h1>  How does it work? </h1><br>  Remember that on mobile devices, the client may not be a browser, but a mobile application without a backend.  Therefore, we face two major security issues of mobile OAuth 2.0: <br><br><ol><li>  The client is not trusted. </li><li>  The behavior of the redirect from the browser to the mobile application depends on the settings and applications that the user has installed. </li></ol><br><h4>  Mobile application is a public client </h4><br>  To understand the roots of the first problem, let's take a look at how OAuth 2.0 works when a server-to-server interaction occurs, and then compare it with OAuth 2.0 if a client-to-server interface works. <br><br>  In both cases, everything starts with the fact that the service client is registered with the service provider and receives the <code>client_id</code> and, in some cases, the <code>client_secret</code> .  The value of <code>client_id</code> is public and necessary to identify the client service, unlike <code>client_secret</code> , whose value is private.  The registration process is described in more detail in <a href="https://tools.ietf.org/html/rfc7591">RFC 7591</a> . <br><br>  The diagram below shows how OAuth 2.0 works when server-to-server interacts. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f06/279/e8a/f06279e8ac68f2fe664362caec6fa063.png"><br>  <i>Picture taken from <a href="https://tools.ietf.org/html/rfc6749">https://tools.ietf.org/html/rfc6749#section-1.2</a></i> <br><br>  There are 3 main stages of the OAuth 2.0 protocol: <br><br><ol><li>  [AC steps] Get the Authorization Code (hereinafter simply <code>code</code> ). </li><li>  [DE steps] Exchange <code>code</code> for <code>access_token</code> . </li><li>  Access the resource using <code>access_token</code> . </li></ol><br>  We will analyze the receipt of the code in more detail: <br><br><ol><li>  [Step A] The service client redirects the user to the service provider. </li><li>  [Step B] The service provider asks the user for permission to provide data to the service client (arrow B up).  The user provides access to the data (arrow B to the right). </li><li>  [Step C] The service provider returns the <code>code</code> to the user's browser, and the user redirects the <code>code</code> service client. </li></ol><br>  Let's <code>access_token</code> getting <code>access_token</code> more detail: <br><br><ol><li>  [Step D] The client server sends a request for <code>access_token</code> .  The request includes: <code>code</code> , <code>client_secret</code> and <code>redirect_uri</code> . </li><li>  [Step E] In the case of valid <code>code</code> , <code>client_secret</code> and <code>redirect_uri</code> , <code>client_secret</code> provided. </li></ol><br>  The request for <code>access_token</code> is performed according to the server-to-server scheme, therefore, in general, to kidnap <code>client_secret</code> an attacker must hack into the server of the client or server of the service provider. <br><br>  Now let's see how the OAuth 2.0 scheme looks on a mobile device without a backend (client-to-server interaction). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Picture taken from <a href="https://tools.ietf.org/html/rfc8252">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  The general scheme is divided into the same 3 basic steps: <br><br><ol><li>  [steps 1-4 in the picture] Get the <code>code</code> . </li><li>  [steps 5-6 in the picture] Exchange the <code>code</code> for <code>access_token</code> . </li><li>  Access the resource using <code>access_token</code> . </li></ol><br>  However, in this case, the mobile application also performs server functions, which means that the <code>client_secret</code> will be sewn inside the application.  This leads to the fact that on mobile devices it is impossible to keep <code>lient_secret</code> secret secret from an attacker.  <code>client_secret</code> are two ways to get the <code>client_secret</code> , which is sewn into the application: to sniff the traffic from the application to the server or to reverse engineer the application.  Both methods are easy to implement, so <code>client_secret</code> useless on mobile devices. <br><br>  Regarding the client-to-server scheme, you might have a question: ‚Äúwhy not immediately get an <code>access_token</code> ?‚Äù.  It would seem, why do we need an extra step?  Moreover, there is an <a href="https://tools.ietf.org/html/rfc6749">Implicit Grant</a> scheme, in which the client immediately gets <code>access_token</code> .  And although in some cases it can be used, we will see below that the <a href="https://tools.ietf.org/html/rfc6749">Implicit Grant</a> scheme is not suitable for secure mobile OAuth 2.0. <br><br><h4>  Redirect on mobile devices </h4><br>  In general, <a href="https://developer.apple.com/documentation/uikit/core_app/allowing_apps_and_websites_to_link_to_your_content/communicating_with_other_apps_using_custom_urls">Custom URI Scheme</a> and <a href="https://developer.android.com/training/app-links/verify-site-associations">AppLink</a> mechanisms are used to redirect from browser to application on mobile devices.  None of these mechanisms in its pure form is as reliable as a browser redirect. <br><br>  Custom URI Scheme (or deep link) is used as follows: the developer determines the application's scheme before building.  The scheme can be arbitrary, and several applications with the same scheme can be installed on one device.  It's pretty simple, when on the device each scheme corresponds to one application.  And what if two applications registered the same scheme on the same device?  How can the operating system determine which of the two applications to open when accessing the Custom URI Scheme?  Android will show a window with the choice of the application in which you want to open the link.  In iOS, the <a href="https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html">behavior is undefined</a> , which means that any of the two applications can be opened.  In both cases, the attacker has the <a href="https://habr.com/company/mailru/blog/417031">opportunity to intercept the code or access_token</a> . <br><br>  AppLink, in contrast to the Custom URI Scheme, allows you to open the desired application, but this mechanism has several disadvantages: <br><br><ol><li>  Each service client must independently pass <a href="https://developer.android.com/training/app-links/verify-site-associations">the verification procedure</a> . </li><li>  Android users can turn off AppLink for a specific application in the settings. </li><li>  Android below 6.0 and iOS below 9.0 do not support AppLink. </li></ol><br>  The above disadvantages of AppLink, firstly, raise the entry threshold for potential client services, and secondly, can lead to the fact that, under certain circumstances, the user will not have OAuth 2.0 working.  This makes the AppLink mechanism unsuitable for replacing browser redirects in the OAuth 2.0 protocol. <br><br><h1>  Okay, what to attack? </h1><br>  Mobile OAuth 2.0 issues have generated specific attacks.  Let's see what they are and how they work. <br><br><a name="1"></a><h4>  Authorization Code Interception Attack </h4><br>  Initial data: a legitimate application (OAuth 2.0 client) and a malicious application that registered the same scheme as the legitimate one are installed on the user's device.  The figure below shows the attack pattern. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a87/336/d4c/a87336d4c0d73c89a62bb448cb12d49b.png"><br>  <i>Picture taken from <a href="https://tools.ietf.org/html/rfc7636">https://tools.ietf.org/html/rfc7636#section-1</a></i> <br><br>  The problem here is this: in step 4, the browser returns the <code>code</code> to the application via the Custom URI Scheme, so the <code>code</code> can be intercepted by the malware (because it registered the same scheme as the legitimate application).  After that, the malware changes the <code>code</code> to <code>access_token</code> and gets access to user data. <br><br>  How to protect yourself?  In some cases, you can use interprocess communication mechanisms, we will talk about them below.  In the general case, it is necessary to apply a scheme called <a href="https://tools.ietf.org/html/rfc7636">Proof Key for Code Exchange</a> .  Its essence is reflected in the diagram below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/123/67e/349/12367e3497cbbd54d007a18a678bfc0d.png"><br>  <i>Picture taken from <a href="https://tools.ietf.org/html/rfc7636">https://tools.ietf.org/html/rfc7636#section-1.1</a></i> <br><br>  In requests from the client there are several additional parameters: <code>code_verifier</code> , <code>code_challenge</code> (in the <code>t(code_verifier)</code> scheme) and <code>code_challenge_method</code> (in the <code>t_m</code> scheme). <br><br>  <code>Code_verifier</code> is a random number <a href="https://tools.ietf.org/html/rfc7636">at least 256 bits long</a> that is <a href="https://ru.wikipedia.org/wiki/Nonce">used only once</a> .  That is, for <b>each</b> request for receiving a <code>code</code> client must generate a new <code>code_verifier</code> . <br><br>  <code>Code_challenge_method</code> is the name of the conversion function, most often SHA-256. <br><br>  <code>Code_challenge</code> is the <code>code_verifier</code> to which the <code>code_challenge_method</code> transform was <code>code_challenge_method</code> and encoded into the Safe Base64 URL. <br><br>  The conversion of <code>code_verifier</code> to <code>code_challenge</code> necessary to protect against attack vectors based on <code>code_verifier</code> interception (for example, from the system logs of the device) when requesting <code>code</code> . <br><br>  In the event that the user's device <b>does not support</b> SHA-256, then we <a href="https://tools.ietf.org/html/rfc7636">assume a downgrade to the absence of the code_verifier conversion</a> .  In all other cases, you must use SHA-256. <br><br>  The scheme works as follows: <br><br><ol><li>  The client generates <code>code_verifier</code> and remembers it. </li><li>  The client selects the <code>code_challenge_method</code> and receives the <code>code_challenge</code> from the <code>code_verifier</code> . </li><li>  [Step A] The client requests the <code>code</code> , and the <code>code_challenge</code> and <code>code_challenge_method</code> added to the request. </li><li>  [Step B] The provider remembers the <code>code_challenge</code> and <code>code_challenge_method</code> on the server and returns the <code>code</code> client. </li><li>  [Step C] The client requests an <code>access_token</code> , and the <code>code_verifier</code> added to the <code>code_verifier</code> . </li><li>  The provider receives the <code>code_challenge</code> from the incoming <code>code_verifier</code> , and then compares it with the <code>code_challenge</code> that he remembers. </li><li>  [Step D] If the values ‚Äã‚Äãmatch, the provider issues an <code>access_token</code> client. </li></ol><br>  Let's <code>code_challenge</code> why <code>code_challenge</code> protects against code <code>code_challenge</code> attacks.  To do this, go through the stages of obtaining <code>access_token</code> . <br><br><ol><li>  First, a legitimate application requests a <code>code</code> (along with the <b>request, the</b> <code>code_challenge</code> and <code>code_challenge_method</code> ). </li><li>  The malware intercepts the <code>code</code> (but not the <code>code_challenge</code> , because there <b>is</b> no <code>code_challenge</code> <b>in the answer</b> ). </li><li>  The malware asks for <code>access_token</code> (with a valid <code>code</code> , but <b>without a</b> valid <code>code_verifier</code> ). </li><li>  The server notices the <code>code_challenge</code> mismatch and gives an error. </li></ol><br>  Note that the attacker does not have the ability to guess the <code>code_verifier</code> (random 256 bits!) Or find it somewhere in the logs (the <code>code_verifier</code> is transmitted once). <br><br>  If you <code>code_challenge</code> all this in one phrase, then <code>code_challenge</code> allows the service provider to answer the question: ‚Äúis <code>access_token</code> requested by the same client application that requested the <code>code</code> , or another?‚Äù. <br><br><h4>  OAuth 2.0 CSRF </h4><br>  On mobile devices, OAuth 2.0 is often used as an authentication mechanism.  As we remember, authentication through OAuth 2.0 differs from authorization in that OAuth 2.0 vulnerabilities affect user data on the client side of the service, and not the service provider.  As a result, a CSRF attack on OAuth 2.0 allows you to steal someone else's account. <br><br>  Consider a CSRF attack applied to OAuth 2.0 using the example of taxi client application and provider.com provider.  First, the attacker on his device enters the account <code>attacker@provider.com</code> and gets the <code>code</code> for the taxi.  After that, the attacker interrupts the OAuth 2.0 process and generates a link: <br><br> <code>com.taxi.app://oauth? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4 <br></code> <br>  Then the attacker sends the link to the victim, for example, under the guise of a letter or SMS from the administration of the taxi.  The victim <code>access_token</code> link, the taxi application on her phone opens, which receives <code>access_token</code> , and as a result, the victim enters the <b>attacker's</b> taxi account.  Unaware of a dirty trick, the victim uses this account: makes trips, enters his data, etc. <br><br>  Now, an attacker can enter the victim‚Äôs taxi account at any time because he is tied to <code>attacker@provider.com</code> .  CSRF-attack on the login allowed to steal the account. <br><br>  CSRF attacks are usually protected using a CSRF token (also called a <code>state</code> ), and OAuth 2.0 is no exception.  How to use CSRF token: <br><br><ol><li>  The client application generates and stores a CSRF token on the user's mobile device. </li><li>  The client application includes a CSRF token in the request for a <code>code</code> . </li><li>  The server returns the same CSRF token in the response along with the code. </li><li>  The client application compares the incoming and saved CSRF token.  If the values ‚Äã‚Äãmatch, the process continues. </li></ol><br>  Requirements for CSRF token: <a href="https://ru.wikipedia.org/wiki/Nonce">nonce</a> minimum length of 256 bits, obtained from a good source of pseudo-random sequences. <br><br>  In short, the CSRF token allows the client application to answer the question: ‚Äúdid I start getting <code>access_token</code> , or is someone trying to deceive me?‚Äù. <br><br><h4>  Malware pretending to be a legitimate client </h4><br>  Some malware can mimic legitimate applications and raise the consent screen on their behalf (the consent screen is the screen on which the user sees: ‚ÄúI agree to give access to ...‚Äù).  An inattentive user can click ‚Äúallow‚Äù, and as a result, the malware gets access to user data. <br><br>  Android and iOS provide mechanisms for mutual verification of applications.  The application provider can verify the legitimacy of the application client, and vice versa. <br><br>  Unfortunately, if OAuth 2.0 uses a stream through a browser, then you cannot defend against this attack. <br><br><h4>  Other attacks </h4><br>  We looked at attacks that are unique to mobile OAuth 2.0.  However, do not forget about the attacks on the usual OAuth 2.0: <code>redirect_uri</code> substitution, interception of traffic over an unprotected connection, etc.  You can read more about them <a href="https://sakurity.com/oauth">here</a> . <br><br><h1>  What to do? </h1><br>  We learned how the OAuth 2.0 protocol works, and figured out what vulnerabilities exist in the implementations of this protocol on mobile devices.  Let's now assemble the secure OAuth 2.0 mobile schema out of individual pieces. <br><br><h4>  Good, bad OAuth 2.0 </h4><br>  To begin with, how to raise the consent screen.  On mobile devices, there are two ways to open a web page from a native application (examples of native applications: Mail.Ru Mail, VK, Facebook). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ee/bd1/d02/7eebd1d02b5fa11a820fe37abbd1c552.png"><br><br>  The first method is called Browser Custom Tab (in the picture on the left).  <b>Note</b> : Browser Custom Tab on Android is called Chrome Custom Tab, and on iOS SafariViewController.  In fact, this is the usual browser tab, which is displayed directly in the application, i.e.  There is no visual switching between applications. <br><br>  The second method is called ‚Äúraise WebView‚Äù (in the picture on the right), as applied to mobile OAuth 2.0, I consider it bad. <br><br>  WebView is a standalone browser for the native application. <br><br>  ‚ÄúStand-alone <i>browser</i> ‚Äù means that WebView denies access to cookies, storage, caches, history, and other data from Safari and Chrome browsers.  The converse is also true: Safari and Chrome cannot access WebView data. <br><br>  ‚Äú <i>Browser for a native application</i> ‚Äù means that the native application that brought up WebView has <b>full</b> access to cookies, storage, cache, history and other WebView data. <br><br>  Now imagine: the user presses the "log in using ..." button and the malicious application WebView requests his login and password from the service provider. <br><br>  Failure immediately on all fronts: <br><br><ol><li>  The user enters the username and password of the service provider account in the application, which can easily steal this data. </li><li>  OAuth 2.0 was originally designed in order <i>not to enter the login and password</i> from the service provider. </li><li>  The user gets used to enter the username and password anywhere, increases the likelihood of <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B3">phishing</a> . <br></li></ol><br>  Given that all the arguments against WebView, the conclusion suggests itself: raise the Browser Custom Tab for the consent screen. <br><br>  If any of you have arguments in favor of WebView instead of Browser Custom Tab, write about it in the comments, I will be very grateful. <br><br><h4>  Secure Mobile OAuth 2.0 Schema </h4><br>  We will use the Authorization Code Grant scheme, because it allows you to add <code>code_challenge</code> and protect against code interception attacks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7cb/9fb/b7d/7cb9fbb7dcc35c74e921f18d22584254.png"><br>  <i>Picture taken from <a href="https://tools.ietf.org/html/rfc8252">https://tools.ietf.org/html/rfc8252#section-4.1</a></i> <br><br>  A request for a code (steps 1-2) will look like this: <br><br> <code>https://o2.mail.ru/code? <br> redirect_uri=com.mail.cloud.app%3A%2F%2Foauth&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24&amp; code_challenge=ZjYxNzQ4ZjI4YjdkNWRmZjg4MWQ1N2FkZjQzNGVkODE1YTRhNjViNjJjMGY5MGJjNzdiOGEzMDU2ZjE3NGFiYw%3D%3D&amp; <br> code_challenge_method=S256&amp; <br> scope=email%2Cid&amp; <br> response_type=code&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  In step 3, the browser receives a response with a redirect: <br><br> <code>com.mail.cloud.app://outh? <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> anti_csrf=927489cb2fcdb32e302713f6a720397868b71dd2128c734181983f367d622c24</code> <br> <br>  In step 4, the browser opens the Custom URI Scheme and sends the <code>code</code> and the CSRF token to the client application. <br><br>  Request for <code>access_token</code> (step 5): <br><br> <code>https://o2.mail.ru/token? <br> code_verifier=e61748f28b7d5daf881d571df434ed815a4a65b62c0f90bc77b8a3056f174abc&amp; <br> code=b57b236c9bcd2a61fcd627b69ae2d7a6eb5bc13f2dc25311348ee08df43bc0c4&amp; <br> client_id=984a644ec3b56d32b0404777e1eb73390c <br></code> <br>  In the last step, the response is returned with the <code>access_token</code> . <br><br>  In general, the above scheme is safe, but there are also special cases in which OAuth 2.0 can be made simpler and a bit safer. <br><br><h4>  Android IPC </h4><br>  In Android, there is a mechanism for two-way communication between processes: IPC (inter-process communication).  IPC is preferable to Custom URI Scheme for two reasons: <br><br><ol><li>  An application that opens an IPC channel can verify the authenticity of the application being opened by its certificate.  The reverse is also true: an open application can verify the authenticity of the application that opened it. </li><li>  By sending a request via the IPC channel, the sender can receive a response through the same channel.  Coupled with mutual verification (p.1), this means that no third-party process will be able to intercept the <code>access_token</code> . </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/693/84d/6f6/69384d6f63788694137f8d559d6469fa.png"><br><br>  Thus, we can use <a href="https://tools.ietf.org/html/rfc6749">Implicit Grant</a> and significantly simplify the mobile OAuth 2.0 scheme.  No <code>code_challenge</code> and CSRF tokens.  Moreover, we can protect against malicious programs that mimic under valid clients in order to steal user accounts. <br><br><h4>  Customer SDK </h4><br>  In addition to implementing the secure mobile OAuth 2.0 scheme outlined above, the provider should develop an SDK for its clients.  This will facilitate client-side OAuth 2.0 implementation and at the same time reduce the number of errors and vulnerabilities. <br><br><h1>  Draw conclusions </h1><br>  For OAuth 2.0 providers, I compiled the Checklist for secure mobile OAuth 2.0: <br><br><ol><li>  A solid foundation is vital.  In the case of mobile OAuth 2.0, the foundation is the scheme or protocol we choose to implement.  When <a href="https://hackerone.com/reports/314814">implementing your own OAuth 2.0 scheme,</a> it's easy to make a mistake.  Others have already filled the bumps and made conclusions; there is nothing wrong with learning from their mistakes and immediately making a safe implementation.  In general, the most secure mobile OAuth 2.0 scheme is the one in the ‚ÄúWhat should I do?‚Äù Section. </li><li>  <code>Access_token</code> and other sensitive data are stored: under iOS - in Keychain, under Android - in Internal Storage.  These stores are specifically designed for such purposes.  If necessary, you can use the Android Content Provider, but you need to configure it safely. </li><li>  <code>Code</code> should be one-time, with a short lifetime. </li><li>  To protect against interception code use <code>code_challenge</code> . </li><li>  To protect against a CSRF attack on a login, use CSRF tokens. </li><li>  Do not use the WebView for the consent screen, use the Browser Custom Tab. </li><li>  <code>Client_secret</code> <b>useless</b> if it is not stored on the backend.  Do not give it to public customers. </li><li>  Use HTTPS <b>everywhere</b> , with the prohibition of downgrade to HTTP. </li><li>  Follow the cryptographic guidelines (cipher selection, token length, etc.) <b>from the standards</b> .  You can copy the data and find out why it was done this way, but <a href="https://2017.zeronights.org/wp-content/uploads/materials/ZN17_Karim_Valiev_StopCrypto.pdf">you cannot do your own cryptography</a> . </li><li>  From the client side, check who you are opening for OAuth 2.0, and from the provider side, check who opens you to OAuth 2.0. </li><li>  Remember the <a href="https://sakurity.com/oauth">usual OAuth 2.0 vulnerabilities</a> .  Mobile OAuth 2.0 expands and complements the usual, so no one has canceled the <code>redirect_uri</code> check for exact match and other recommendations for the usual OAuth 2.0. </li><li>  Be sure to provide SDK clients.  The client will have fewer errors and vulnerabilities in the code, and it will be easier for him to implement your OAuth 2.0. </li></ol><br><h1>  What to read </h1><br><ol><li>  [RFC] OAuth 2.0 for Native Apps <a href="https://tools.ietf.org/html/rfc8252">https://tools.ietf.org/html/rfc8252</a> </li><li>  Google OAuth 2.0 for Mobile &amp; Desktop Apps <a href="https://developers.google.com/identity/protocols/OAuth2InstalledApp">https://developers.google.com/identity/protocols/OAuth2InstalledApp</a> </li><li>  [RFC] Proof Key for Code Exchange by OAuth Public Clients <a href="https://tools.ietf.org/html/rfc7636">https://tools.ietf.org/html/rfc7636</a> </li><li>  OAuth 2.0 Race Condition <a href="https://hackerone.com/reports/55140">https://hackerone.com/reports/55140</a> </li><li>  [RFC] OAuth 2.0 Threat Model and Security Considerations <a href="https://tools.ietf.org/html/rfc6819">https://tools.ietf.org/html/rfc6819</a> </li><li>  Attacks on regular OAuth 2.0 <a href="https://sakurity.com/oauth">https://sakurity.com/oauth</a> </li><li>  [RFC] OAuth 2.0 Dynamic Client Registration Protocol <a href="https://tools.ietf.org/html/rfc7591">https://tools.ietf.org/html/rfc7591</a> </li></ol><br><h1>  Thanks </h1><br>  Thanks to everyone who helped write this article, especially Sergey Belov, Andrey Sumin, Andrey Labunts ( <a href="https://twitter.com/isciurus">@isciurus</a> ) and Darya Yakovleva. </div><p>Source: <a href="https://habr.com/ru/post/417031/">https://habr.com/ru/post/417031/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417015/index.html">Understand what is written and what is not recorded application Burger King</a></li>
<li><a href="../417017/index.html">How a failed nuclear experiment spawned neutrino astronomy</a></li>
<li><a href="../417023/index.html">Rambler Group experience: how we started to fully control the formation and behavior of front-end React components</a></li>
<li><a href="../417027/index.html">As I wrote the standard C ++ 11 library or why the boost is so scary. Introduction</a></li>
<li><a href="../417029/index.html">Code profiling with LLVM</a></li>
<li><a href="../417033/index.html">QIWI Kitchen from June 7th - videos of our speakers</a></li>
<li><a href="../417035/index.html">UnnyWorld: postmortem</a></li>
<li><a href="../417037/index.html">BEERBRAZZERS. Control the light. Vixen Lights 3. Quick Start (1/4)</a></li>
<li><a href="../417039/index.html">We learn wordpress (and not only) to draw quickly Youtube players</a></li>
<li><a href="../417041/index.html">eslint-scope v3.7.2 steals NPM tokens</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>