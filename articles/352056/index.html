<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why does the Heap32Next () function work so slowly on Windows 7?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are doing system programming under Windows, you might notice that the very useful functions of Heap32First / Heap32Next and others from the sam...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why does the Heap32Next () function work so slowly on Windows 7?</h1><div class="post__text post__text-html js-mediator-article">  If you are doing system programming under Windows, you might notice that the very useful functions of <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms683245(v%3Dvs.85).aspx">Heap32First</a> / <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/ms683440(v%3Dvs.85).aspx">Heap32Next</a> and others from the same family began to work much slower since Windows 7. What happened to them? <br><br>  Let's go back to far 1992.  Developed by Windows 3.1.  One of the new components in it was ToolHelp.  He allowed a little digging in the guts of the OS kernel.  For us, the most interesting features are those that allow you to view data in a heap.  Since Windows 3.1 used <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative multitasking</a> , calling such functions one could be sure that the contents of the heap would not change between the HeapFirst and HeapNext calls, because the OS did not have the right to interrupt the process and switch the context to the other.  Here were the times! <br><a name="habracut"></a><br>  Separately, it should be noted that ToolHelp was not a component of the OS kernel.  He screwed the side.  The reason was that the development of ToolHelp ended already closer to the release of Windows 3.1 and the kernel development team did not want to destabilize it at such a late stage.  So everything that ToolHelp does, it does "outside", and this imposes some restrictions. <br><br>  Widows 95 added 32-bit versions of the same functions to ToolHelp. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So what am I talking about ... oh yeah, Heap32Next. <br><br>  In the 32-bit version of ToolHelp, you can view data on the heap using Heap32First and Heap32Next function calls.  The implementation of these functions in Windows 95 worked as follows: a call to Heap32First allocated a certain amount of memory and saved its size in the HEAPENTRY32.dwResvd field.  Each subsequent call to Heap32Next used this value to read the next block of memory.  The last call to Heap32Next (the one that returned FALSE) freed the allocated memory.  You have already seen the problem here, right?  If for some reason we want to finish viewing the memory before reaching the end of the heap (the user canceled the action, the timeout expired, we found what we were looking for), then we immediately get a memory leak.  Unlike other similar sets of WinAPI functions (like FindFirstFile / FindNextFile / FindClose), here we have no function like Heap32Close.  The only way to free up memory is to get to the end with Heap32Next.  Also, Windows 95 has changed the multitasking model.  It became possible that between two consecutive calls to Heap32Next, the data in the heap was changed by another process.  However, this situation was not handled by the functions of the ToolHelp component. <br><br>  Both of the above problems look very serious, but, according to the creators of these functions, they were intended only for diagnostic purposes.  The very name of the ToolHelp component should have prompted the developer to think that it can be used in development and debugging, but not in the end product for users. <br><br>  Everything changed when the Windows transition to the NT kernel.  The developers of Windows NT paid significant attention to the stability of the system and did not want to have a memory leak in the design, even if auxiliary functions.  Since there was no guarantee that the programmer would always reach the end of the heap using Heap32Next, as well as there was no way to allow him to complete the pass earlier, it was decided to free all allocated memory before returning from Heap32First and Heap32Next.  When the application called Heap32First, this function took a heap snapshot, returned its first block, and released the snapshot.  When the application called Heap32Next, a heap snapshot was taken again, the second block was returned and the snapshot was released again.  And so on, you get the idea. <br><br>  As a result of the implementation of this algorithm, O (n¬≤) operations were required to view n memory blocks. <br><br>  So why did it become slower in Windows 7? <br><br>  Prior to Windows 7, the above snapshot of the memory area was taken into a fixed-size buffer.  It contained information about a quarter of a million blocks of memory on the heap.  With such an implementation, a hard limit was obtained by itself for the worst case of calling the Heap32First / Heap32Next functions.  In Windows 7, this buffer was increased, because there were complaints from developers of some diagnostic utilities that they rest on its size.  The developers of the Windows kernel decided that it was better to let the functions run slowly and correctly than quickly and erroneously.  Thus, O (n¬≤) was added to the not very beautiful complexity of O (n¬≤) and a large constant due to the increased buffer size. <br><br>  This sad story about functionality, which was designed as an auxiliary in times of cooperative multitasking, and then failed to upgrade sufficiently well in future versions of the OS.  At the moment, the Heap32First / Heap32Next functions live in the Windows kernel under the slogan ‚Äúa family has a black sheep.‚Äù  No one likes them, but you just can't take something from the kernel and throw it away: good backward compatibility is what Windows is on. <br><br>  But, fortunately, you can always add something new that works more correctly.  In this case, the <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/aa366710(v%3Dvs.85).aspx">HeapWalk</a> function has become such a ‚Äúnew‚Äù <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/aa366710(v%3Dvs.85).aspx">one</a> .  It has O (n) complexity, but is limited by the ability to read only the memory of the current process.  If you want to read the memory of other processes - you have no alternatives other than Heap32First / Heap32Next.  You can be comforted by the fact that doing something like this is still most often needed for diagnostic purposes, on the developers' machines.  And here correctness is more important than performance. </div><p>Source: <a href="https://habr.com/ru/post/352056/">https://habr.com/ru/post/352056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352044/index.html">We found a large company that has not been engaged in information security for 5 years and is still alive</a></li>
<li><a href="../352048/index.html">Hackathon Design</a></li>
<li><a href="../352050/index.html">Reverse "Neuromant". Part 1: Sprites</a></li>
<li><a href="../352052/index.html">Linux containers: isolation as a technological breakthrough</a></li>
<li><a href="../352054/index.html">How do we predict the end date and project evaluation using a neural network?</a></li>
<li><a href="../352060/index.html">Accelerating the enumeration of processes and threads in Windows</a></li>
<li><a href="../352062/index.html">How to explain to relatives who you are in the IT world on the example of buns</a></li>
<li><a href="../352064/index.html">Bluebird: belt with tools for the asynchronist</a></li>
<li><a href="../352066/index.html">New solution for maintaining the availability of IT infrastructure: Veeam Availability Orchestrator</a></li>
<li><a href="../352068/index.html">Installing Facebook image recognition package. All rake in one place</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>