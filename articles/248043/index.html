<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An approximate comparison of numbers in Haskell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Probably everyone knows that when calculating with limited accuracy, two mathematically equivalent expressions may not be equal to each other. For exa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An approximate comparison of numbers in Haskell</h1><div class="post__text post__text-html js-mediator-article">  Probably everyone knows that when calculating with limited accuracy, two mathematically equivalent expressions may not be equal to each other.  For example, the following obvious mathematical equality is unexpectedly false when calculated in Haskell: <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">24</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) == sqrt(<span class="hljs-number"><span class="hljs-number">72</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-type"><span class="hljs-type">False</span></span></code> </pre> <br><br>  The reason for such a violation is that the expressions in this equality are calculated only approximately: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">24</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">86.53323061113574</span></span> ghci&gt; sqrt(<span class="hljs-number"><span class="hljs-number">72</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">86.53323061113575</span></span> ghci&gt; sqrt(<span class="hljs-number"><span class="hljs-number">72</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">3</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">24</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">1.4210854715202004e-14</span></span></code> </pre><br><br>  The difference here is only in the last (fourteenth!) Decimal place, but this is enough for the comparison to be false. <br><br>  Although this problem is well known, programmers pay little attention to it.  First, it is believed that comparisons of this kind occur only in a narrow field of numerical methods, and second, that violation of equality occurs extremely rarely.  As it turned out, both are not entirely true.  The given case arose when I needed to implement the function of calculating the length of a vector with integer coordinates.  At the same time, for the unit testing, the <a href="http://hackage.haskell.org/package/QuickCheck">QuickCheck</a> package tools are used, which rather quickly found a case of violation of the scaling invariant for the vector length.  I note that this is not the only invariant whose violation was discovered during testing. <br><br>  The question arises: what is the easiest way to describe the verification of the approximate equality of two numbers obtained as a result of calculations with limited accuracy?  To solve this problem in Haskell, it suffices to define another comparison operator (say, ~ =), which is used in the same way as the ordinary equality operator.  I propose to consider the implementation of such an operator, which can be arranged in the form of a fairly simple <a href="http://snipplr.com/view/88264/circa-comparison-of-fractional-numbers/">Circa</a> module. <br><br><a name="habracut"></a><br><br>  The first thing that comes to mind for an approximate comparison of two numbers is to calculate the absolute value of the difference between the numbers being compared, and to check whether it exceeds some threshold: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; abs(sqrt(<span class="hljs-number"><span class="hljs-number">72</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">3</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">24</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>)) &lt; <span class="hljs-number"><span class="hljs-number">1e-12</span></span> <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre><br><br>  Such a solution, of course, is quite workable.  But he has two serious drawbacks.  First of all, when reading this record, it is not at all obvious that we check the equality (even if it is approximate) of two numbers.  In addition, we had to use the ‚Äúmagic‚Äù number 1e-12 to indicate the expected inaccuracy of the comparison.  Of course, with a small number of such comparisons with these inconveniences could be put up.  But when the number of invariants is measured in dozens, I would like to get a simpler and more obvious way to write them.  Much better is the code in which a two-place approximate comparison operator is used in the same way as a regular equal sign, for example, like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sqrt</span></span>(<span class="hljs-number"><span class="hljs-number">72</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) ~= <span class="hljs-number"><span class="hljs-number">3</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">24</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre><br><br>  Unfortunately, standard Haskell syntax does not provide such an operator.  However, the language itself provides a wonderful opportunity to introduce a new operator on your own, as if it were part of the standard syntax. <br><br>  First, we define the function circaEq, which will reduce the approximate comparison record <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">circaEq</span></span> :: (<span class="hljs-type"><span class="hljs-type">Fractional</span></span> t, <span class="hljs-type"><span class="hljs-type">Ord</span></span> t) =&gt; t -&gt; t -&gt; t -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> circaEq txy = abs (x - y) &lt; t</code> </pre><br><br>  Now our example is getting a bit shorter, but not much clearer: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; circaEq <span class="hljs-number"><span class="hljs-number">1e-12</span></span> (sqrt(<span class="hljs-number"><span class="hljs-number">72</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>)) (<span class="hljs-number"><span class="hljs-number">3</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">24</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>)) <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre><br><br>  There is still a lot of unnecessary information: to separate the arguments, we had to enclose them in brackets, and most importantly, it is still necessary to specify the accuracy of the comparison.  To get rid of the extra parameter, <a href="http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Fixed.html">let's</a> use the trick that was used in the <a href="http://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Fixed.html">Data.Fixed</a> module to represent numbers with fixed precision.  We define a series of two-place functions, each of which will compare numbers with a predetermined error.  It turns out that in practice it is enough to define only seven such functions for the most typical values ‚Äã‚Äãof the error: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">picoEq</span></span> :: (<span class="hljs-type"><span class="hljs-type">Fractional</span></span> t, <span class="hljs-type"><span class="hljs-type">Ord</span></span> t) =&gt; t -&gt; t -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> picoEq = circaEq <span class="hljs-number"><span class="hljs-number">1e-12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> `picoEq` nanoEq :: (Fractional t, Ord t) =&gt; t -&gt; t -&gt; Bool nanoEq = circaEq <span class="hljs-number"><span class="hljs-number">1e-9</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> `nanoEq` microEq :: (Fractional t, Ord t) =&gt; t -&gt; t -&gt; Bool microEq = circaEq <span class="hljs-number"><span class="hljs-number">1e-6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> `microEq` milliEq :: (Fractional t, Ord t) =&gt; t -&gt; t -&gt; Bool milliEq = circaEq <span class="hljs-number"><span class="hljs-number">1e-3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> `milliEq` centiEq :: (Fractional t, Ord t) =&gt; t -&gt; t -&gt; Bool centiEq = circaEq <span class="hljs-number"><span class="hljs-number">1e-2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> `centiEq` deciEq :: (Fractional t, Ord t) =&gt; t -&gt; t -&gt; Bool deciEq = circaEq <span class="hljs-number"><span class="hljs-number">1e-1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> `deciEq` uniEq :: (Fractional t, Ord t) =&gt; t -&gt; t -&gt; Bool uniEq = circaEq <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> `uniEq`</code> </pre><br><br>  Any of these functions can be used as a two-place comparison operator, for example: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; sqrt(<span class="hljs-number"><span class="hljs-number">72</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) `picoEq` <span class="hljs-number"><span class="hljs-number">3</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">24</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre><br><br>  It only remains to add a little sugar: <br><br><pre> <code class="haskell hljs">(~=) :: (<span class="hljs-type"><span class="hljs-type">Fractional</span></span> t, <span class="hljs-type"><span class="hljs-type">Ord</span></span> t) =&gt; t -&gt; t -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> (~=) = picoEq <span class="hljs-keyword"><span class="hljs-keyword">infix</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> ~=</code> </pre><br><br>  and we get what we wanted: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; sqrt(<span class="hljs-number"><span class="hljs-number">72</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">48</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) ~= <span class="hljs-number"><span class="hljs-number">3</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">24</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre><br><br>  Let us answer one more important question: why did we need several different functions for an approximate comparison?  Is comparison with pico-accuracy insufficient?  It turns out really not enough.  A suitable counterexample is found using the same QuickCheck package: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; sqrt(<span class="hljs-number"><span class="hljs-number">5588</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">8184</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) ~= <span class="hljs-number"><span class="hljs-number">44</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">127</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">186</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-type"><span class="hljs-type">False</span></span> ghci&gt; sqrt(<span class="hljs-number"><span class="hljs-number">5588</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">8184</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) `nanoEq` <span class="hljs-number"><span class="hljs-number">44</span></span> * sqrt(<span class="hljs-number"><span class="hljs-number">127</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">186</span></span> ^ <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-type"><span class="hljs-type">True</span></span></code> </pre><br><br>  It is obvious that the required level of accuracy strongly depends on the scale of the numbers with which it is necessary to work.  That is why Circa module exports not only an approximate comparison operator, but also a set of functions for which it can become a synonym.  If pico-precision is unacceptable for an application, it can import the necessary function and define an approximate comparison operator accordingly.  You can do the same if someone likes a different designation for an approximate comparison operator. </div><p>Source: <a href="https://habr.com/ru/post/248043/">https://habr.com/ru/post/248043/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248027/index.html">MindStream. How do we write software under FireMonkey. Part 5. Testing</a></li>
<li><a href="../248033/index.html">Permanent intruder ban with Fail2Ban + MikroTik</a></li>
<li><a href="../248037/index.html">Herringbone, light up! Part 3: Web Interface and Android Application</a></li>
<li><a href="../248039/index.html">Lua API for D language</a></li>
<li><a href="../248041/index.html">Once again (I hope the last one) about double-checked locking</a></li>
<li><a href="../248047/index.html">HP ProLiant ML350 Gen9 - server with insane extensibility</a></li>
<li><a href="../248051/index.html">Doomsday QA</a></li>
<li><a href="../248053/index.html">3CXPhone for Android and iOS in Unified Communications style</a></li>
<li><a href="../248055/index.html">Creating your own vendor bundle in symfony2</a></li>
<li><a href="../248057/index.html">Without cuts. The first month of kubish.ru cashback service in Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>