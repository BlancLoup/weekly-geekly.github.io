<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Russian Code Cup 2012: detailed analysis of tasks from the qualifying round (semi-final)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last Saturday, June 16, the qualifying round of the Russian Code Cup 2012 was completed. The tasks of the qualifying round are more complicated than t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Russian Code Cup 2012: detailed analysis of tasks from the qualifying round (semi-final)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/b95/d6d/aa8/b95d6daa8c3658c018b2823e4efcb5fa.png"><br><br>  Last Saturday, June 16, the qualifying round of the Russian Code Cup 2012 was completed. The tasks of the qualifying round are more complicated than they were in qualifying - well, that’s the semi-final.  I have already talked about what was offered to the participants on previous online tours, analyzed in detail solutions ( <a href="http://habrahabr.ru/company/mailru/blog/144793/">Q1</a> , <a href="http://habrahabr.ru/company/mailru/blog/145262/">Q2</a> , <a href="http://habrahabr.ru/company/mailru/blog/145735/">Q3</a> ). <br><br>  600 people were invited to the qualifying round.  434 people were able to solve at least one problem.  All tasks were solved only by two.  Top 50 went to the final.  In just 3 hours of the tour, 3190 solutions were sent to the verification system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>So, let's go to the tasks themselves.</b>  <b>I tried to explain them in such a way that the solutions were understandable even taking the first steps in sports programming (and in programming in general).</b> <a name="habracut"></a><br><br><h1>  Transposition </h1>  The essence of the task was to determine whether, by applying two types of permutations in arbitrary order, to move an element from the specified position to the one indicated in the list of values.  By the condition of the problem, it was possible to apply the so-called interposition, changing the first two elements in places, and a complex permutation defined by the rule-set of values ​​(a1, a2, ..., aN), where each of the values ​​determines the ordinal position to which you can move number from this position.  For example, the last two in the permutation rule (1,4,3,2) means that it is possible to rearrange from the last position to the second one, and from it to the last one.  Actually, as a result, it is required to give a response of the form “Yes / No” to the input data containing this list (from N values) and a query in the form (position1, position2) - “can the element be moved from position 1 to position 2”. <br><br>  This task was the simplest at the contest, 411 people coped with it, the first test that passed the tests was proposed by Dmitry Zhukov at 3 minutes 31 seconds after the start of the round. <br><br>  It is obvious that all permutations ultimately boil down to a set of cycles.  In the example above, cycle three is 4-&gt; 2-&gt; 4-&gt; 2 ... 1-&gt; 1-&gt; 1 ... 3-&gt; 3-&gt; 3 ... That is, if we only had the operation “apply permutation p”, then for two elements ai and bi the answer would be “Yes” if and only if these elements lay on the same cycle in the permutation p. <br><br>  Let us think about what happens when applying the “transposition” z.  If initially the first and second elements lay in different cycles, then the use of the “transposition” gives us the opportunity to rearrange some element from one of these two cycles to the other. <br><br>  Now we can formulate a general solution. <br><ul><li>  Divide the whole permutation p into cycles. </li><li>  For each query ai and bi, the answer is “Yes” if ai and bi lie in one cycle, or if the first element is present in the cycle of one of them, and the second element is in the cycle of the other. </li></ul><br><br>  The division into cycles is as follows: <br><br><pre><code class="hljs pgsql">//    col,   −<span class="hljs-number"><span class="hljs-number">1.</span></span> vector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; col(n, −<span class="hljs-number"><span class="hljs-number">1</span></span>); //    ,    ,       <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (col[i] != −<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; //     <span class="hljs-type"><span class="hljs-type">int</span></span> x = i; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { col[x] = i; //    x = a[x]; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (col[x] == −<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br><br>  We combine the first two cycles into one: <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; n; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (col[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] == <span class="hljs-number"><span class="hljs-number">0</span></span>) col[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>] = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><br>  As a result, we have an array of col, the <nobr>i-th</nobr> element of which denotes the cycle, which includes the <nobr>i-th</nobr> position. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, b; <span class="hljs-built_in"><span class="hljs-built_in">cin</span></span> &gt;&gt; a &gt;&gt; b; <span class="hljs-comment"><span class="hljs-comment">//  ,          . cout &lt;&lt; ((col[a — 1] == col[b — 1])? «Yes» : «No») &lt;&lt; «\n»; }</span></span></code> </pre><br><br><h1>  Coronation </h1>  Under the terms of the problem, there are two capitals and a certain multitude of cities connected by roads in such a way that from any to any one can be reached in the only way.  But they are of such quality that after the passage of a certain number of cars specified for each road, they become unsuitable for passage.  It was decided to add another (possibly duplicating) road with unlimited bandwidth between any two cities, none of which is the capital.  It is necessary to find the maximum number of cars that can travel between the two capitals, taking into account this new road. <br><br>  A detailed statement of the problem can be found <a href="http://russiancodecup.ru/round/9/">on the round page</a> on the official site of the Russian Code Cup. <br><br>  This task turned out to be the second in complexity “from the end” - 313 people solved it.  The first correct decision was sent by Dmitry Zhukov at 12:50. <br><br>  In the problem we have a weighted undirected tree.  That is, a graph that does not have loops and multiple edges, the edges of which (“roads”) are assigned “weights” - the capacity of the roads. <br><br>  It has two peaks - the "capital" - s and t.  It is necessary to add an edge that does not affect either s or t, such that the flow from s to t is maximal. <br><br>  Let us add an edge from vertex a to vertex b.  Let us prove that between s and t there will be at most two simple paths (a path is called simple if the edges in it do not repeat).  Prove by contradiction.  Suppose we managed to find three paths. <br><br>  Consider two cases: <br><br><ul><li>  At least in two of them there is an edge ab.  Here are also two cases: <br><ul><li>  Edge both times in the same direction.  Take one of the directions a-&gt; b, then both paths in question contain the subpath &lt;s;  a;  b;  t&gt;.  Since these paths are not equal, either the sub paths &lt;s; are not equal;  a&gt; or &lt;b; t&gt;.  In both cases, this means that there are two different paths between the vertices of the tree, which contradicts its properties and the condition of the problem. </li><li>  Rib cost in opposite directions.  If so, then there is a cycle in the tree &lt;s;  a;  t;  b;  s&gt;, which also contradicts the condition of the problem and the properties of our tree. </li></ul></li><li>  The edge ab is not more than in one of them.  Then the remaining two paths form a cycle, and, consequently, a simple cycle in the tree, which is impossible according to the condition of the problem. </li></ul><br><br>  As a result, we found out that adding an edge ab leads to the appearance of no more than two simple paths and only one of them has an edge ab, and the other, obviously, runs along the edges of the tree and is the only one between the vertices-cities. <br><br>  Consider the second path passing through the edge ab.  One end of this edge is connected to the path to the vertex s, and the other to the path to the vertex t.  Now, if we move the junction ab with &lt;s; a&gt; to the node closer to s, then the bandwidth will not degrade.  Similarly, arguing with the road to t, and, remembering the constraint in the problem, we arrive at the fact that the new path passing through the capital nodes s, t and edge ab in its most efficient form consists of three edges - edges from s, edge ab and edges from t. <br><br>  As a result, we obtain that our answer consists of two paths, one of which existed before adding the edge ab, and the second — an edge from s, an edge ab, and an edge in t. <br><br>  We get the solution: <br><ol><li>  Find a path from s to t along the edges of the tree, </li><li>  Skip it to the maximum number of machines and, accordingly, reduce the throughput of all edges along the way.  In this case, the path will definitely collapse - after all, the maximum number of machines corresponds to the lowest throughput capacity of the edges in the path. </li><li>  Probably, there will still be roads (or one road) from s and from t.  Choose those with maximum throughput. </li><li>  Combining them with the edge ab, we calculate the number of cars - the minimum value of the carrying capacity of the two edges leaving the capitals. </li></ol><br><br><h1>  Social phobia </h1>  The condition of the problem is worth it to bring it here with minimal abbreviations. <br><br><blockquote>  “Not all people are pleased to be constantly in the crowd.  Many love privacy and are even willing to pay for it.  That is why Joyful Railways OJSC has introduced a new service on its ticket sale site, called Sociophobe.  The service is necessary in order to enable each passenger to ride in a compartment with the smallest possible number of neighbors.  Its essence is as follows. <br><br>  Let the tickets be sold to a car in which part of the compartment is already full.  If at some point another passenger buys a ticket for this car, he sells a seat in the empty compartment, that is, in a compartment in which the number of people is no more than in all others.  If there are several such compartments, then the compartment with the lowest number is selected.  If a passenger from some compartment gives up his ticket, after which the difference between the number of people in this compartment and in the most filled compartment becomes equal to at least two, then from the most filled compartment the passenger who earlier bought the ticket before the others changes, there is a passenger with the lowest number.  If there are several most filled coupes, then the coupe closest to the one in which the ticket was handed over is selected.  And if there are several such, then the coupe with the smallest number is selected. <br><br>  According to the data on how passengers bought and handed over the tickets, it is required to derive the final distribution of passengers in the compartment.  It is guaranteed that every time a passenger buys a ticket, there is at least one free seat in the car. ” </blockquote><br><br>  It seems that the train in question is truly a huge one, since the number of sales and return tickets is up to 200,000, the number of compartments is up to 50,000. <br><br>  In total, this task was solved by 167 people, of whom the first was Kunyavsky Pavel (23:19). <br><br>  One solution to this problem is as follows.  Prepare the following data structures: <br><br><pre> <code class="hljs pgsql">// ,     . Pas[i] = , <span class="hljs-number"><span class="hljs-number">-1</span></span>  «  ». vector&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; pas(<span class="hljs-number"><span class="hljs-number">200000</span></span>+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>); //   –    . Cars[i]     vector&lt; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; &gt; cars(<span class="hljs-number"><span class="hljs-number">50000</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br><br>  We will also support two sets (in C ++, for example, you can use set for this, in Java - the TreeSet): zero and one.  At zero, we will store the compartment numbers in which we have the smallest number of passengers, and in one - where the most. <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; zero; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt; one;</code> </pre><br><br>  Initially, all coupes are empty, so put them in the list of candidates for filling - zero. <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt;= n; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) zero.insert(<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>);</code> </pre><br><br>  We do not need others, since the difference between the number of passengers in different compartments will never exceed one. <br><br>  <b>Ticket sale operation ("+").</b>  According to the condition of the problem, we must choose the car with the lowest number, in which the least number of people.  To do this, take the smallest element of the set zero.  Update the information in pas and cars.  Then we will delete the found element from zero and add it to one, since now there are as many people in this car as in all cars lying in one.  If zero becomes empty, then it is necessary to swap one and zero, since the same number of people became in all compartments. <br><br><pre> <code class="hljs ruby">int car = *zero.upper_bound(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    pas[++id] = car; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      cars[car].insert(id); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       zero.erase(car); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        one.insert(car); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> …     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (zero.empty()) /<span class="hljs-regexp"><span class="hljs-regexp">/   ,      … { zero = one; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        zero.erase(-n); zero.erase(2 * n); one.clear(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     one.insert(-n); one.insert(2 * n); }</span></span></code> </pre><br><br>  <b>Ticket operation ("-").</b>  With the help of the array pas we find out in which compartment the passenger was sitting.  Remove the passenger from the corresponding compartment. <br><br><pre> <code class="hljs vbscript"><span class="hljs-built_in"><span class="hljs-built_in">int</span></span> car = pas[x]; cars[car].<span class="hljs-keyword"><span class="hljs-keyword">erase</span></span>(x); pas[x] = −<span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><br>  Find out which set belonged to the coupe car.  Here are the following options: <br><ul><li>  belonged to the set of one - "filled coupe."  Then simply remove X from one and add it to zero, that is, we transfer the coupe to the unfilled ones; </li><li>  belonged to the zero set and the one set is empty.  Then we transfer all zero (applicants for filling) into one (filled), leaving only the coupe from which the passenger left. </li><li>  belonged to the zero set and the one set is not empty.  This is the only case in which a situation arises in which the difference between the number of passengers in a compartment could become equal to two.  To do this, in the set of one we find the first coupe, which is larger by number than our coupe, and the last coupe, which is smaller by number than our coupe.  Then from these two found coupes choose the closest one.  We transfer it from the set of one (filled) to the set of zero ("applicants").  We also make adjustments in the cars coupe array and in the passenger pas array. </li></ul><br><br><br><pre> <code class="hljs perl">set&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::iterator ll = (one.upper_bound(car)); ll--; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,    set&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;::iterator rr = (one.upper_bound(car)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(*ll - car) &gt; <span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>(*rr - car)) //        ll = rr; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> l = *ll; one.erase(l); zero.insert(l); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   one  zero <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = *cars[l].upper_bound(<span class="hljs-number"><span class="hljs-number">0</span></span>); cars[l].erase(p); cars[car].insert(p); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      pas[p] = car;</code> </pre><br><br>  To output the answer to the task, we will use the cars array.  To display information about passengers in the <nobr>i-th</nobr> compartment, it is enough to display the size of the set of cars [i], <br><br><pre> <code class="hljs matlab">cout &lt;&lt; cars[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>() &lt;&lt; ((cars[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>].<span class="hljs-built_in"><span class="hljs-built_in">size</span></span>() == <span class="hljs-number"><span class="hljs-number">0</span></span>) ? <span class="hljs-string"><span class="hljs-string">"\n"</span></span> : <span class="hljs-string"><span class="hljs-string">" "</span></span>);</code> </pre><br><br>  and then all passengers belonging to multiple cars [i]. <br><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt;::iterator en = cars[i].<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); en--; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">int</span></span>&gt;::iterator it = cars[i].begin(); it != cars[i].<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>(); it++) cout &lt;&lt; *it &lt;&lt; ((it == en) ? <span class="hljs-string"><span class="hljs-string">"\n"</span></span> : <span class="hljs-string"><span class="hljs-string">" "</span></span>);</code> </pre><br><br><h1>  Coins </h1>  According to the condition of the problem, a certain wizard Rinsvid confuses the coins, and instead of paying for, say, doubloons, he counts sterling (and he does not pay by real sterling).  It is necessary to calculate how many pairs of coins exist, such that by accepting the first coin for the second, he could pay exactly T dollars instead of S, as he considered. <br><br>  An example is provided for illustration.  If there are coins in denominations of 1, 2 or 3 dollars, and Risvind paid 10 dollars instead of 9, then he could do this by accepting 2 coins with a nominal value of 1, and paid, for example, four coins with a nominal 2 and one coin with a nominal 2 which he took as nominal "1". <br><br>  He could also accept coins of face value 3 for coins of face value 2 and pay seven coins of face value 1 and one face value of 3, which he accepted as a coin of face value 2. <br><br><table><tbody><tr><td>  <b>How much is actually paid in nominal 1</b> </td><td>  <b>How much is actually paid in nominal 2</b> </td><td>  <b>How much is actually paid in nominal 3</b> </td><td>  <b>Total paid</b> </td></tr><tr><td>  - </td><td>  <b>really</b> <br>  4 coins <br>  (8 dollars, 4 × 2) <br><br>  1 coin <br>  (2 dollars, 2 × 1) <br>  <b>in the view of Risvind -</b> <br><br>  1 dollar (1 × 1) <br></td><td>  - </td><td>  <b>really</b> <br>  5 coins <br><br>  (10 dollars, 4 × 2 + 2 × 1) <br><br>  <b>in the view of Risvind -</b> <br><br>  9 dollars (4 × 2 + 1 × 1) </td></tr><tr><td>  <b>really</b> <br>  7 coins <br>  (7 dollars, 7 × 1) </td><td>  - </td><td>  <b>really</b> <br>  1 coin <br>  (3 dollars, 3 × 1) <br>  <b>in the view of Risvind -</b> <br>  2 dollars (2 × 1) </td><td>  <b>really</b> <br>  8 coins <br>  (10 dollars, 4 × 2 + 1 × 1) <br>  <b>in the view of Risvind -</b> <br>  9 dollars (4 × 2 + 2 × 1) </td></tr></tbody></table><br><br>  Suppose that Rincewind took the coin t for s.  In the last example, the coin 3 (t) for 2 (s).  This means that he dialed a certain amount of V (in the example - $ 10), without using the coin s (in the example - $ 7), then put another k coin number t, thinking that this is the coin number s (in the example - 1 coin 3, thinking it is 2). <br><br>  In other words, the whole variety of options fits into two groups of cases: <br><ul><li>  There are integers V ≥ 0 and k&gt; 0, such that S = V + k · as and T = V + k · at, where T is the actual amount paid, and S is the sum in the Risvinda view. </li><li>  the sum V can be dialed without using the coin s. </li></ul><br><br>  The first condition can be checked for O (1).  notice, that <br><br>  k = (s - t) / (as - at); <br>  V = S - k · as <br><br>  It remains to verify that the numbers obtained are integers, V ≥ 0, and k&gt; 0. <br><br>  In order to check the second condition, we use the dynamic programming method.  Let D [i] [j] - is it possible to get the sum j using the first i coins?  Base: D [0] [0] = true.  Transition: D [i] [j] = D [i - 1] [j] or D [i] [j - ai].  For implementation, a single array of size S is sufficient. The running time of this algorithm is O (S · n).  For details on the approach using dynamic programming, see <a href="http://habrahabr.ru/company/mailru/blog/144793/">Parsing tasks from the last tour</a> , as well as <a href="http://habrahabr.ru/post/113108/">good material with examples and illustrations</a> . <br><br>  Using the described method, we calculate for each sum V from 1 to S, whether Rincewind could collect this sum without using the coin s.  After that, let's sort out the coin, which Rincewind took for s.  Now the check of both conditions is carried out for O (1).  The final asymptotic solution is O (S · n2). <br><br>  The task of "Coins" was solved first by Peter Mitrichev at 17:06.  In total, we received the correct decisions of 234, which puts this task in third place from the end in terms of complexity. <br><br><h1>  Parse string </h1>  The task describes the algorithm for finding dictionary words from a given text — the so-called greedy algorithm, when every time a found word is removed from this text.  An example is given that in some cases such an approach leads to incorrect results.  For example, for workingrass, working can be removed and some rass would remain, while the correct solution would be to break up the work / in / grass into three words, each of which would be in the dictionary.  It is necessary to check whether the greedy algorithm will work correctly with the specified dictionary, and, if it does not, give an example of a string for which the word break from the dictionary exists, but cannot be found by the described algorithm.  If there are several such examples, it is necessary to find the shortest one, that is, one whose length is no more than the rest.  If there are several, you need to withdraw any. <br><br>  We first consider the key idea leading us to the solution of the problem.  Let there be a string t - the required counter-example of the shortest length, and some of its splitting into words from the dictionary w <sub>1</sub> , w <sub>2</sub> , ..., w <sub>k</sub> .  Let the greedy parser that we are trying to break, when exploring this line, first bite off the string w from it. <br><br>  Let us prove the following statement: if the length of the string w is not greater than the sum of the lengths of the rows w <sub>1</sub> , w <sub>2</sub> , ..., w <sub>k-1</sub> , then there is a counterexample shorter than the string t. <br><br>  Let, to begin with, the length of the string t is equal to this sum.  Then it is obvious that the greedy parser will correctly work on string t, since the string w will be “bitten off” first, and then the string w <sub>k</sub> , since it will be the longest string prefix contained in the dictionary. <br><br>  In this case, let the length of the string w be less than the sum of the lengths of the rows w <sub>1</sub> , w <sub>2</sub> , ..., w <sub>k-1</sub> .  Then there is a number j such that w <sub>j is</sub> divided into the prefix w <sub>j1</sub> and the suffix w <sub>j2</sub> , and w <sub>j1</sub> is the suffix of the string w (possibly, of zero length).  Consider the string w <sub>j2</sub> .  If for it there is a correct splitting into words from the dictionary, then it suffices to leave as a counterexample the concatenation of the strings w <sub>j2</sub> , w <sub>j + 1</sub> , w <sub>j + 2</sub> , ..., w <sub>k</sub> , which will be a shorter counter example.  If for the string w <sub>j2 the</sub> division into words from the dictionary does not exist in principle, then a shorter counterexample is the concatenation of the strings w <sub>1</sub> , w <sub>2</sub> , ..., w <sub>j</sub> . <br><br><img src="http://russiancodecup.ru/images/analisys/round_9/parse-2.png"><br><br>  So now we can imagine what the desired counterexample looks like. <br><br><img src="http://russiancodecup.ru/images/analisys/round_9/parse-1.png"><br><br>  We develop an effective algorithm for its construction.  Suppose that for each line from the dictionary we know which of its suffixes and prefixes there is a division into words from the dictionary (later we will explain how to calculate this data).  Let's look through all the lines from the dictionary to find out if they are the same string w that will be “bitten off” first.  It is clear that the penultimate line from the correct partition can end only in the same place where some prefix of the string w ends, for which there is a partition.  Let's sort through all such prefixes.  Now it only remains to understand which lines may be the last in the correct partitioning of the counterexample.  First, it must be strings whose length is longer than the length of the uncovered suffix of the string w being checked.  Secondly, the uncovered suffix of the string w must exactly match the prefix of the candidate string to the last place in the partition of the appropriate length.  And finally, the candidate string suffix, uncovered by the string w, should not have a correct vocabulary splitting. <br><br>  Here it is appropriate to make one important remark.  Even if the uncovered candidate string suffix has a word splitting from the dictionary, what we are checking at the moment may still be a counterexample.  However, then the counterexample will be the suffix in itself, and then what we are testing is not the shortest counter-example of interest, and we are not interested. <br><br><img src="http://russiancodecup.ru/images/analisys/round_9/parse-3.png"><br><br>  With this approach to solving the problem, you need to ask another question.  And what will happen if, instead of the string w, which we check, another string will be “bitten off”, with w being the prefix?  In this case, the greedy parser will behave unpredictably, and may find some kind of partition.  However, in order to avoid this fate, you simply need to check the strings for whether they are not the string w in the order of non-increasing their lengths, and remember the strings that we have already checked.  Then every line with which such a problem is possible at all will be checked at the time of the problem, and we can just ignore this line. <br><br>  Now, when there is a general algorithm for solving the problem, it remains to solve the problem of checking prefixes and breakable suffixes, and also learn how to quickly compare the necessary substrings of the necessary strings for equality.  The second problem is solved quite simply with the help of hashing algorithms, which themselves are the subject of a separate article or lecture.  The first problem is solved using dynamic programming.  Let for all prefixes of the string t, the length of which is strictly less than l, we know whether there is their division into lines from the dictionary.  To check whether there is a partition of the prefix of length l, it is enough to go through all the lines from the dictionary and check for the existence of such that two statements are true: <br><br><ul><li>  the suffix of the studied prefix of the corresponding length is exactly equal to the string from the dictionary </li><li>  the prefix of the studied prefix of the corresponding length is divided into words from the dictionary </li></ul><br><br>                     ,   O(sumL × n),  sumL —    ,  n —  ,  ,       .  ,           . <br><br>  « »  (  )  « »,     ,     –    115:47. <br><br><h1>  </h1>       ,         ,      .  ,    / ,     .   ,        ,   ,     . ,  ,   ,       —      Impossible. <br><br>       ,     ,    x    ,   x — .        :     (0, 0)   (x, y)   y,       (  ),        (  )       ().     . <br><br><img src="http://russiancodecup.ru/images/analisys/round_9/prince-1.png"><br><br>           ,             ,     ,          .  ,                ,    . <br><br>        ,    .       ,  ,      «» ,   .     ,    .     .       ,  -       .        .     ,      . <br><br>        ,          .   ,         .    ,   .   , ,  ,   ,      - .   ,         .   ,         ,    .      x,     .            ,        ,    . <br><br>             ,        ,    .    O(n2 log n) ,       O(n)     O(n)     O(n) .       O(n log n)    ,         O(n) . <br><br>       ,     . <br><br><img src="http://russiancodecup.ru/images/analisys/round_9/prince-3.png"><br><br>  and <br><br><img src="http://russiancodecup.ru/images/analisys/round_9/prince-4.png"><br><br>            . <br><br><img src="http://russiancodecup.ru/images/analisys/round_9/prince-2.png"><br><br>       –    23 ,  –    100:18.     ,    ,   – ,  2    .       ,     . <br><br><hr><br><br> 50       .   10   Swissotel,  .  , , ,        . <br><br> <i>  <br>      <br> Mail.Ru Group <br></i> </div><p>Source: <a href="https://habr.com/ru/post/146458/">https://habr.com/ru/post/146458/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146453/index.html">Develop sms blacklist for Android</a></li>
<li><a href="../146454/index.html">Management of a network of online stores in 1C 8.2 through PHPShop "1C-Monitor"</a></li>
<li><a href="../146455/index.html">Mass add / remove hosts in Zabbix using API</a></li>
<li><a href="../146456/index.html">IT Compote # 11 Programming and Technology Podcast</a></li>
<li><a href="../146457/index.html">Microsoft has blocked the donation site FSF as "gambling"</a></li>
<li><a href="../146459/index.html">Creative D100 - Mobile Speaker System</a></li>
<li><a href="../146460/index.html">Meet WebMatrix 2 RC: support for Node.js, Jade, EJS, LESS, CoffeeScript, and more</a></li>
<li><a href="../146462/index.html">Copiratic chaos in Japan: two years in prison for the downloaded file</a></li>
<li><a href="../146464/index.html">Installing the OS using SmartStart</a></li>
<li><a href="../146465/index.html">Technological startups in Russia. Interview with Renat Garipov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>