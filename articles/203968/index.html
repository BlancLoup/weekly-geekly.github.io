<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Grid control</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table controls (usually the words Table or Grid are in their names) are widely used in GUI development. It so happened that at work we use C ++ and MF...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Grid control</h1><div class="post__text post__text-html js-mediator-article">  Table controls (usually the words Table or Grid are in their names) are widely used in GUI development.  It so happened that at work we use C ++ and MFC to develop the user interface.  In the beginning, we used <b>CGridCtrl</b> , an open- <b>source</b> and fairly well-known grid implementation.  But for some time he stopped arranging us and his own development came into being.  The ideas underlying our implementation, I want to share with you here.  There is an idea to make an open source project (most likely under Qt).  Therefore, this note can be considered as ‚ÄúProof Of Concept‚Äù.  Constructive criticism and comments are welcome. <br><img src="https://habrastorage.org/getpro/habr/post_images/09c/f5b/910/09cf5b910a8047ae0ebb70686f959b52.png"><br><a name="habracut"></a><br>  The reasons for which I am not satisfied with the existing implementation, I omit (this is a topic for a separate note). <br>  Our projects are engineering-scientific, with rich graphics, and lists and tables are used everywhere.  Therefore, the new grid had to provide flexible customization, good speed and minimal memory consumption when displaying large amounts of information.  When developing, I tried to adhere to the following rule: implement the functionality as generalized and abstract as possible, but not to the detriment of ease of use and optimal performance.  Of course, this rule is contradictory, but as far as I managed to keep the balance - to judge you. <br><br>  To start somewhere, let's try to define the grid control.  To preserve the commonality, we can say that the grid is a visual element that breaks space into rows and columns.  The result is a grid of cells (the intersection of rows and columns) within which some information is displayed.  Thus, two components can be distinguished in the grid: structure and data.  The grid structure determines how we will break the space into rows and columns, and the data describes, in fact, what we want to see in the resulting cells. <br><br>  As we defined above, the grid structure (topology can be said) is described by rows and columns.  Rows and columns are very similar objects.  You can say indistinguishable, only some break the plane horizontally, and others vertically.  But they do it the same way.  Here we are approaching a rather small and self-sufficient entity, which can be arranged in the C ++ class.  I called this class Lines (in Russian it can be defined as Lines or Stripes).  This class will define a set of lines (rows or columns).  Deepen and define a class for a separate line is not necessary.  The class will be small and non-functional.  Thus, Lines will define the properties of a rowset or column set and operations that can be performed on them: <br><ul><li>  The main property of Count is the number of lines that make up Lines. </li><li>  Each line can change its size (row height, and column - width) </li><li>  Lines can be reordered (sort rows, reorder columns) </li><li>  Lines can be hidden (made invisible to the user) </li></ul>  I couldn‚Äôt think of any more or less useful operations on a set of rows or columns.  It turned out a small but useful class: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lines</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Lines(UINT_t count = <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-function">UINT_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT_t count)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">UINT_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetLineSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT_t line)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLineSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT_t line, UINT_t size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsLineVisible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT_t line)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetLineVisible</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT_t line, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> visible)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Pred&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sort</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Pred&amp; pred)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;UINT_t&gt;&amp; GetPermutation() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetPermutation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;UINT_t&gt;&amp; permutation)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">UINT_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAbsoluteLineID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT_t visibleLine)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">UINT_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetVisibleLineID</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UINT_t absoluteLine)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; Event_t&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lines&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)&gt; changed; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: UINT_t m_count; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;UINT_t&gt; m_linesSize; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; m_linesVisible; };</code> </pre> <br>  Comments and some utility functions and fields omitted for clarity. <br>  You can see that the class has the functions <code>GetAbsoluteLineID</code> and <code>GetVisibleLineID</code> .  Since we allow the lines to be shuffled and hidden, the absolute and visible index of the line are different.  I hope the picture clearly shows this situation. <br><img src="https://habrastorage.org/getpro/habr/post_images/72d/c22/46a/72dc2246a9815af03d054437d2735433.png"><br>  You also need to make an explanation about the line <br><pre> <code class="cpp hljs">Event_t&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lines&amp;, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span>)&gt; changed;</code> </pre>  Here a signal is defined (as it is called in Qt or boost).  With the advent of C ++ 11 and std :: function, you can easily write a simple implementation of signals / slots so as not to depend on external libraries.  In this case, we defined an event in the Lines class, and any function or functor can be connected to it.  For example, the grid connects to this event and receives an alert when the Lines instance changes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, the grid structure is represented by two copies of Lines: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Lines m_rows; Lines m_columns;</code> </pre><br>  Go to the data.  How to give the grid information about what data it will display and how to display it?  Here everything is already invented before us - I used the MVC (Model-View-Controller) triad.  Let's start with the View element.  Just as the Lines class defines not one line, but a whole set, we define the View class as something that displays some kind of homogeneous data in some subset of grid cells.  For example, we will display text in the first column.  This means that we have to create an object that can display text data and who can say that this data should be displayed in the first column.  Since the data we can display is different and in different places, it is better to implement these functions in different classes.  Let's call a class that can display data, actually View, and a class that can say where the data should display Range (a set of cells).  Passing two instances of these classes to the grid, we just indicate what and where to display. <br><br>  Let's take a closer look at the Range class.  This is an amazingly small and powerful class.  Its main task is to quickly answer the question of whether a particular cell is in it or not.  In essence, this is an interface with one function: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Range</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  In this way, any set of cells can be defined.  The most useful of course will be the following two: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RangeAll</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RangeColumn</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: RangeColumn(UINT_t column): m_column(column) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasCell</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell.column == m_column; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: UINT_t m_column; };</code> </pre>  The first class defines a set of all cells, and the second defines a set of one specific column. <br><br>  For the View class, there is only one function left - draw the data in the cell.  In fact, for full-fledged work, View should be able to answer a couple more questions: <br><ul><li>  How much space is needed to display the data (for example, to set columns sufficient for displaying text - Fit mode) </li><li>  Give a textual representation of the data (to copy to the clipboard as text or display in a tooltip) </li></ul><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">View</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc, Rect rect, CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Size </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc, CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell, INTENT intent, String&amp; text)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  But what if we want to draw different data types in the same cell?  For example, draw an icon and next to text or draw a checkbox and next to text.  It would not be desirable for these combinations to implement a separate type of View.  Let's allow in a single cell to show several View, only need a class that tells how to place a specific View in a cell. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Layout</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LayoutView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> View* view, Rect&amp; cellRect, Rect&amp; viewRect)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  For clarity, we consider an example in which the checkboxes and text are displayed in the first column.  The second column presents the radio buttons, the squares with color and the textual representation of the color.  And in one cell there is an asterisk. <br><img src="https://habrastorage.org/getpro/habr/post_images/df3/a5f/f2e/df3a5ff2e721e90f82ed5c22d2243809.png"><br>  For example, for the checkbox, we will use LayoutLeft, which will ask View its size and bite the rectangle of the desired size from the rectangle of the cell.  For the text, we will use LayoutAll, to which, in the cellRect parameter, the already truncated cell rectangle will go.  LayoutAll will not ask for the size of its View, but simply ‚Äútake away‚Äù all the available cell space.  You can come up with many different useful layouts that will be combined with any View. <br><br>  Let's return to the Grid class for which we wanted to set the data.  It turns out that we can store triples &lt;Range, View, Layout&gt;, which determine in which cells, how to display data, plus how this data should be located inside the cell.  So our Grid class looks like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Grid</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Lines m_rows; Lines m_columns; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;tuple&lt;Range, View, Layout&gt;&gt; m_data; };</code> </pre><br>  Here is what m_data looks like for our example. <br><img src="https://habrastorage.org/getpro/habr/post_images/ac9/069/fa1/ac9069fa168190cf2ea53ba31364e11e.png"><br>  In essence, this is enough to render the grid.  But the information is not organized in an optimal way - just a list of records that determine the display of data. <br>  Let's think about how we can draw some kind of cell using our Grid class. <br><ol><li>  We need to filter m_data and leave only those triples for which our cell falls into the Range. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> d: grid.m_data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (d.range-&gt;HasCell(cell)) cell_data.push_back(d);</code> </pre> </li><li>  Define a rectangle for a cell <br><pre> <code class="cpp hljs">Rect cellRect = CalculateCellRect(grid.m_rows, grid.m_columns, cell);</code> </pre> </li><li>  Define rectangles for all views. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Rect&gt; view_rects(cell_data.size()); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> view_rect_it = view_rects.begin(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> d: cell_data) d.layout-&gt;LayoutView(grid.GetDC(), d.view, cellRect, *view_rect_it++);</code> </pre> </li><li>  Draw all View into rectangles calculated for them <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> view_rect_it = view_rects.begin(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> d: cell_data) d.view-&gt;Draw(grid.GetDC(), *view_rect_it++, cell);</code> </pre> </li></ol><br>  As you can see, the drawing takes place at the last step and all you need is a list of filtered View and a list of rectangles where this View will draw data.  You can come up with a small class that caches this data and its drawing function would consist of a single item 4. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CellCache</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CellCache(Grid grid, CellID cell); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: CellID m_cell; Rect m_cellRect; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;pair&lt;View, Rect&gt;&gt; m_cache; };</code> </pre><br>  This class in the constructor executes the first three items and stores the result in m_cache.  At the same time, the Draw function turned out to be quite lightweight.  We had to pay for this lightness in the form of m_cache.  Therefore, it will be costly to create an instance of such a class for each cell (after all, we agreed not to have data depending on the total number of cells).  But we don‚Äôt need to have CellCache instances for all cells, only visible enough.  As a rule, a small part of all cells is visible in the grid and their number does not depend on the total number of cells. <br><br>  Thus, we have another class that manages the visible area of ‚Äã‚Äãthe grid, stores CellCache for each visible cell and is able to quickly draw them. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GridCache</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: GridCache(Grid grid); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetVisibleRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Rect visibleRect)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: Grid m_grid; Rect m_visibleRect; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;CellCache&gt; m_cells; };</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/9bb/530/7e8/9bb5307e8cd497affbd554dd84165400.png"><br>  When the user resizes the grid or scrolls the content, we simply set a new visibleRect in this object.  In this case, m_cells will be reformed to contain only visible cells.  GridCache functionality is enough to implement a read-only grid. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GridWindow</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">Grid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetGrid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_gridCache.GetGrid(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPaint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_gridCache.Draw(GetDrawContext()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnScroll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_gridCache.SetVisibleRect(GetVisibleRect()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_gridCache.SetVisibleRect(GetVisibleRect()); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: GridCache m_gridCache; };</code> </pre><br>  Separating the Grid and GridCache classes is very useful.  It allows, for example, to create multiple GridCache for a single Grid instance.  This can be used to implement page printing of the contents of a grid or export the grid to a file as an image.  At the same time, the GridWindow object is not modified in any way - just a GridCache is created aside, referring to the same Grid instance, in a new GridCache loop, the visibleRect is set for the current page and printed. <br><br>  How to add interactivity?  This is where Controller comes to the fore.  Unlike other classes, this class defines an interface with many functions.  But only because there are a lot of mouse events themselves. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Controller</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLBttnDown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell, Point p)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLBttnUp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell, Point p)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; ... };</code> </pre><br>  Just like for drawing, we only need visible cells to work with the mouse.  Add a mouse handling function to the GridCache class.  According to the position of the mouse cursor, we will determine which cell (CacheCell) is under it.  Then in the cell for all the View whose mouse got into the rectangle, pick up the Controller and call the corresponding method from it.  If the method returns true, stop the Views traversal.  This scheme works fairly quickly.  At the same time, we had to add a link to the Controller to the View class. <br><br>  It remains to deal with the class Model.  It is needed as a template adapter.  Its main goal is to provide data for the View in a ‚Äúconvenient‚Äù form.  Let's take an example.  We have a ViewText that can draw text.  To draw it in a specific cell, this text should be requested for the cell from the ModelText object, which, in turn, is only an interface, and its concrete implementation knows how to get the text.  Here is an example implementation of the ViewText class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ViewText</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> View { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ViewText(ModelText model): m_model(model) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DrawContext&amp; dc, Rect rect, CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> String&amp; text = model-&gt;GetText(cell); dc.DrawText(text, rect); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ModelText m_model; };</code> </pre><br>  Thus, it is easy to guess which interface ModelText should have: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelText</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Model { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> String&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String&amp; text)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  Please note that we have added a setter for using the controller.  In practice, the most commonly used implementation is ModelTextCallback. <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModelTextCallback</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ModelText { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: function&lt;<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> String&amp;(CellID)&gt; getCallback; function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(CellID, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> String&amp;)&gt; setCallback; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> String&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getCallback(cell); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CellID cell, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> String&amp; text)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (setCallback) setCallback(cell, text); } };</code> </pre><br>  This model allows for the initialization of the grid to assign lambda functions to access this data. <br>  Well, what is common between models for different data: ModelText, ModelInt, ModelBool ...?  In general, nothing, the only thing that can be said about all of them is that they should inform all those interested in the facility that the data has changed.  Thus, the base class Model with us will take the following form: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~Model() {} Event_t&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Model)&gt; changed; };</code> </pre><br><br>  As a result, our grid has broken down into many small classes, each of which performs a well-defined small task.  On the one hand, it may seem that there are too many classes to implement the grid.  But, on the other hand, the classes turned out to be small and simple, with clear interconnections, which simplifies the understanding of the code and reduces its complexity.  At the same time, various combinations of the heirs of the Range, Layout, View, Controller and Model classes give a very large variation.  Using lambda functions for ModelCallback allows you to easily and quickly associate a grid with data. <br><br>  In the next article I will describe how to implement the standard grid functionality: selection, sorting, column / row resize, printing, how to add a header (fixed upper rows and left columns). <br>  I will reveal a small secret - all that is described in this article is already enough to implement the above.  If I missed some functionality, please write in the comments and I will describe their implementation in the next article. </div><p>Source: <a href="https://habr.com/ru/post/203968/">https://habr.com/ru/post/203968/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../203956/index.html">What is ITAM technology, why and with what it is eaten</a></li>
<li><a href="../203958/index.html">Sites for kids - is it easy to make a serious product ‚Äútoy‚Äù</a></li>
<li><a href="../203960/index.html">JavaFX and Spring. It's more fun together</a></li>
<li><a href="../203964/index.html">Snake on PLC? Easy!</a></li>
<li><a href="../203966/index.html">UEFI - Aah, I heard ... but still, what is it?</a></li>
<li><a href="../203970/index.html">LINQ for SQL emulation on Delphi</a></li>
<li><a href="../203972/index.html">Universal way to quickly take a screenshot in linux</a></li>
<li><a href="../203974/index.html">Why do many banks and payment systems worry little about the safety of their customers?</a></li>
<li><a href="../203980/index.html">XCP for those who want but are afraid</a></li>
<li><a href="../203984/index.html">It is a little about neutrino, cosmology and domestic projects</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>