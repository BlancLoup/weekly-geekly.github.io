<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How did the intro on 64k</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Intro intro 
 The demoscene is about creating cool pieces that work in real time (as if ‚Äúspinning in your computer‚Äù). They are called demos . Some of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How did the intro on 64k</h1><div class="post__text post__text-html js-mediator-article"><h1>  Intro intro </h1><br>  The demoscene is about creating cool pieces that work in real time (as if ‚Äúspinning in your computer‚Äù).  They are called <i>demos</i> .  Some of them are really small, say, 64k or less - such are called <i>intro</i> .  The name comes from the advertising or presentation of hacked programs (crack intro).  So, intro is just a little demo. <br><br>  I noticed that many people are interested in the works of the demoscene, but they have no idea how demos are made in reality.  This article is a brain dump and postmortem autopsy of our fresh <i>Guberniya</i> intro.  I hope it will be interesting for both novice and experienced veterans.  The article affects almost all the techniques that are used in the demos, and should give a good idea of ‚Äã‚Äãhow to do them.  In this article I will call people by nicknames, because this is the custom on the <i>stage</i> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yei3mJm33SQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>  <i>Binary under Windows: <a href="">guberniya_final.zip (61.8 kB)</a> (breaks a bit on AMD cards)</i> <br><a name="habracut"></a><br><h1>  Guberniya in a nutshell </h1><br>  This is a 64k intro released on <a href="https://2017.revision-party.net/">demopati Revision 2017</a> .  Some numbers: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  C ++ and OpenGL, <a href="https://github.com/ocornut/imgui">dear imgui</a> for GUI </li><li>  62976 bytes binary under Windows, packed <a href="http://www.farbrausch.de/~fg/kkrunchy/">kkrunchy</a> </li><li>  mostly raymarching ( <i><a href="http://blog.ruofeidu.com/tutorial-of-ray-casting-ray-tracing-and-ray-marching/">rakecasting option</a> - approx. lane.</i> ) </li><li>  group of 6 people <br><ul><li>  one artist :) </li></ul></li><li>  done in four months </li><li>  ~ 8300 C ++ lines, not counting library code and spaces </li><li>  4840 lines of GLSL shaders </li><li>  ~ 350 git commits </li></ul><br><h1>  Development </h1><br>  Demos are usually released on demopati, where viewers watch them and vote for the winner.  Release for demopati gives a good motivation, because you have a deadline and a passionate audience.  In our case, it was <a href="https://2017.revision-party.net/">Revision 2017</a> , a big demopati, which traditionally takes place on Easter weekends.  You can look at <a href="http://tf.weimarnetz.de/revision2017/">some photos</a> to get an idea of ‚Äã‚Äãthe event. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b8/749/fda/8b8749fda557875641c5d349447bf323.png"><br>  <font color="gray"><i>The number of commits per week.</i></font>  <font color="gray"><i>The biggest surge is that we urgently hack right before deadline.</i></font>  <font color="gray"><i>The last two columns are the changes for the final version, after demopati.</i></font> <br><br>  We started working on the demo in early January and released it on Easter in April during the event.  You can watch <a href="https://www.youtube.com/watch%3Fv%3D1jv0woZONvc">the entire competition</a> if you wish :) <br><br>  Our team consisted of six people: cce (this is me), <a href="https://twitter.com/martin_b_radev">varko</a> , <a href="https://twitter.com/nnnnoby">noby</a> , <a href="https://twitter.com/nicebranch">branch</a> , msqrt and goatman. <br><br><h1>  Design and influence </h1><br>  The song was ready at a fairly early stage, so I tried to draw something based on its motives.  It was clear that we needed something big and cinematic with memorable parts. <br><br>  The first visual ideas revolved around wires and their use.  I really like the work of Viktor Antonov, so the first sketches are largely copied from Half-Life 2: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/642/109/d70/642109d7035980d5026212db2f3e3796.jpg"><br>  <font color="gray"><i>The first outline of the citadel towers and ambitious human characters.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/990/073/555/9900735558280ffc5769e4b97844ccf3.jpg"><br>  <font color="gray"><i>Conceptual work of Victor Antonov for Half-Life 2: <i>Raising the Bar</i></i></font> <br><br>  The similarities are quite obvious.  In the landscape scenes, I also tried to convey the mood of <a href="http://anthonyscime.deviantart.com/art/Eldion-Passageway-304528786">Eldion Passageway</a> Anthony Shimez. <br><br>  The landscape was created under the inspiration of <a href="https://vimeo.com/189904045">this glorious video about Iceland</a> , as well as ‚ÄúKoyaaniskatsi‚Äù, probably.  I had big plans for the story shown on the storyboard: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a0/498/001/0a049800142cb4d7e067187bb2b113ca.jpg"><br>  <font color="gray"><i>This storyboard is different from the final intro version.</i></font>  <font color="gray"><i>For example, brutal architecture cut out.</i></font>  <font color="gray"><i><a href="">Full storyboard</a> .</i></font> <br><br>  If I would do it again, I would limit myself to just a couple of photos that set the mood.  So less work and more space for imagination.  But at least drawing helped me organize my thoughts. <br><br><h3>  Ship </h3><br>  The spacecraft designed by <a href="https://twitter.com/nnnnoby">noby</a> .  This is a combination of numerous Mandelbrot fractals intersecting with geometric primitives.  The design of the ship remained a little unfinished, but it seemed to us that it was better not to touch it in the final version. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe5/a76/b0b/fe5a76b0b5d5fb418513a7d8e9e554e4.jpg"><br>  <font color="gray"><i>The spacecraft is a raymarching field of distances, like everything else.</i></font> <br><br>  We had another ship shader that didn‚Äôt enter the intro.  Now I look at the design, it is very cool, and it is a pity that there was no place for it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6fc/8f3/7a3/6fc8f37a3d30a1562861100990ed149d.jpg"><br>  <font color="gray"><i>Spacecraft design from branch.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br><h1>  Implementation </h1><br>  We started with the code base of our old intro <a href="http://www.pouet.net/prod.php%3Fwhich%3D67435">Pheromone</a> ( <a href="https://www.youtube.com/watch%3Fv%3DBTZs8ppUtSQ">YouTube</a> ).  There was basic framing functionality and a library of standard OpenGL functions along with a file system utility that packs files from a data directory into an executable file using <code>bin2h</code> . <br><br><h3>  The working process </h3><br>  To compile the project, we used Visual Studio 2013 because it was not compiled in VS2015.  Our replacement of the standard library did not work very well with the updated compiler and produced funny errors like these: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b61/237/e9f/b61237e9f527608559d3287eaa4d2d6b.png"><br>  <font color="gray"><i>Visual Studio 2015 did not get along with our code base</i></font> <br><br>  For some reason, we are still stuck on VS2015 as an editor and just compiled the project using the v120 platform toolkit. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f3/5ed/7eb/8f35ed7eb191c177fcd463b672b3f112.jpg"><br>  <font color="gray"><i>Most of my work with the demo looked like this: the shaders are open in one window, and the final result with console output is in the others.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br>  We made a simple global interception of keystrokes that would reload all shaders if it detected the CTRL + S combination: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Listen to CTRL+S. if (GetAsyncKeyState(VK_CONTROL) &amp;&amp; GetAsyncKeyState('S')) { // Wait for a while to let the file system finish the file write. if (system_get_millis() - last_load &gt; 200) { Sleep(100); reloadShaders(); } last_load = system_get_millis(); }</span></span></code> </pre> <br>  It worked really well, and editing shaders in real time became much more interesting.  No need to intercept file system events and the like. <br><br><h3>  GNU Rocket </h3><br>  For animation and production we used <a href="https://github.com/edoreshef/ground-control">Ground Control</a> , fork <a href="https://github.com/rocket/rocket">GNU Rocket</a> .  Rocket is a program for editing animated curves, it connects to the demo via a TCP socket.  The reference frames are sent on request demo.  This is very convenient, because you can edit and recompile the demo without closing the editor and without risking losing the synchronization position.  For the final version, reference frames are exported to binary format.  However, there are some <a href="https://github.com/rocket/rocket/issues/63">annoying restrictions</a> . <br><br><h3>  Tool </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/UwVqr2iI9tU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <font color="gray"><i>Changing the point of view with the mouse and keyboard is very convenient to select camera angles.</i></font>  <font color="gray"><i>Even a simple GUI helps a lot when little things matter.</i></font> <br><br>  Unlike <a href="http://peisik.untergrund.net/engines/">some</a> , we did not have a tool for demos, so we had to create it as we worked.  The magnificent <a href="https://github.com/ocornut/imgui">dear imgui</a> library <a href="https://github.com/ocornut/imgui">makes</a> it easy to add features as needed. <br><br>  For example, you need to add several sliders to control the color parameters ‚Äî all you need is to add these lines to the rendering cycle ( <i>not</i> to a separate GUI code). <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">imgui</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::Begin("Postprocessing")</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">imgui</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::SliderFloat("Bloom</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">blur</span></span>", &amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">postproc_bloom_blur_steps</span></span>, 1, 5); <span class="hljs-selector-tag"><span class="hljs-selector-tag">imgui</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::SliderFloat("Luminance"</span></span>, &amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">postproc_luminance</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, "%<span class="hljs-selector-class"><span class="hljs-selector-class">.3f</span></span>", 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">imgui</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::SliderFloat("Threshold"</span></span>, &amp;<span class="hljs-selector-tag"><span class="hljs-selector-tag">postproc_threshold</span></span>, 0<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, 1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>, "%<span class="hljs-selector-class"><span class="hljs-selector-class">.3f</span></span>", 3<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">imgui</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::End()</span></span>;</code> </pre> <br>  Final result: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/61d/1df/cfc/61d1dfcfcbcb72bddc5709587b7f482b.png"><br>  <font color="gray"><i>These sliders were easy to add.</i></font> <br><br>  The camera position can be saved to a <code>.cpp</code> file by pressing <code>F6</code> , so after the next compilation it will be in the demo.  This eliminates the need for a separate data format and the corresponding serialization code, but such a solution can also be rather sloppy. <br><br><h3>  Making small binaries </h3><br>  The main thing to minimize the binary is to throw away the standard library and compress the compiled binary.  As a base for our own library implementation, we used the <a href="https://www.codeproject.com/Articles/15156/Tiny-C-Runtime-Library">Tiny C Runtime Library</a> from Mike_V. <br><br>  Binary compression is <a href="http://www.farbrausch.de/~fg/kkrunchy/">done by kkrunchy</a> , a tool made for this very purpose.  It works with individual executables, so you can write your demo in C ++, Rust, Object Pascal or anything else.  To be honest, the size for us was not a particular problem.  We did not store a lot of binary data like images, so there was room for maneuver.  I didn't even have to delete comments from the shaders! <br><br><h3>  Floating commas </h3><br>  The floating-point code delivered some headaches by making calls to the functions of a non-existent standard library.  Most of them were eliminated by disabling SSE compiler <code>/arch:IA32</code> key and removing calls to <code>ftol</code> using the <code>/QIfst</code> flag, which generates code that does not save the FPU flags for truncation mode.  This is not a problem, because you can set the floating-point truncation mode at the beginning of your program using this code from <a href="http://www.musicdsp.org/showone.php%3Fid%3D246">Peter Schoffhauser</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// set rounding mode to truncate // from http://www.musicdsp.org/showone.php?id=246 static short control_word; static short control_word2; inline void SetFloatingPointRoundingToTruncate() { __asm { fstcw control_word // store fpu control word mov dx, word ptr [control_word] or dx, 0x0C00 // rounding: truncate mov control_word2, dx fldcw control_word2 // load modfied control word } }</span></span></code> </pre> <br>  You can read more about these things at <a href="http://www.benshoof.org/blog/minicrt/">benshoof.org</a> . <br><br><h5>  POW </h5><br>  The call to <code>pow</code> still generates a call to the internal <code>__CIpow</code> function that does not exist.  I could not find out its signature by myself, but I found the implementation in <a href="">ntdll.dll from Wine</a> - it became clear that it expects two double precision numbers in the registers.  After this, it became possible to make a wrapper that calls our own implementation of <code>pow</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> __cdecl _CIpow(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Load the values from registers to local variables. double b, p; __asm { fstp qword ptr p fstp qword ptr b } // Implementation: http://www.mindspring.com/~pfilandr/C/fs_math/fs_math.c return fs_pow(b, p); }</span></span></code> </pre> <br>  If you know the best way to deal with this, please report. <br><br><h3>  WinAPI </h3><br>  If you can not count on the SDL or something similar, then you have to use pure WinAPI for the necessary operations to display the window on the screen.  If you have problems, this is what can help: <br><br><ul><li>  <a href="https://gist.github.com/seece/1f67da14d69b9c8a75a7e6839abf8e72">Example of creating a WinAPI window</a> </li><li>  <a href="https://gist.github.com/seece/9f5f3069130c4fe642f4fd5e7375816a">OpenGL initialization example</a> , <a href="">glext.h</a> and <a href="">wglext.h</a> are required </li></ul><br>  Please note that in the last example we load function pointers only for those OpenGL functions that are actually used in the business.  It might be a good idea to automate this.  Functions need to be accessed along with string identifiers that are stored in an executable file, so the less functions are loaded, the more space is saved.  The <a href="https://msdn.microsoft.com/en-us/library/0zza0de8.aspx">Whole Program Optimization</a> option may remove all unused string literals, but we will not use it because of a <a href="http://stackoverflow.com/a/2945619">problem with memcpy</a> . <br><br><h3>  Rendering techniques </h3><br>  The rendering is performed mainly by the raymarching method, and for convenience we used the <a href="http://mercury.sexy/hg_sdf/">hg_sdf</a> library.  <a href="http://iquilezles.org/www/">I√±igo Quiles</a> (from now on, simply called iq) wrote a lot about this and many other techniques.  If you have ever visited <a href="https://www.shadertoy.com/">ShaderToy</a> , then you should be familiar with this. <br><br>  In addition, we had a racaster output - the depth buffer value, so that we could combine the SDF (signed distance fields) with the geometry in the raster, as well as apply post-processing effects. <br><br><h3>  Shading </h3><br>  We applied the standard Unreal Engine 4 shading ( <a href="http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">here is a large pdf with a description</a> ) with a drop of GGX.  This is not very noticeable, but it does matter in the main points.  From the very beginning, we planned to make the same illumination for both raymarching and rasterized forms.  The idea was to use deferred rendering and shadow maps, but it completely failed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4c/01e/7fa/b4c01e7faf1a0f261938f58fbc048e4f.jpg"><br>  <font color="gray"><i>One of the first experiments with the imposition of shadow maps.</i></font>  <font color="gray"><i>Notice that both towers and wires cast a shadow on the raymarching-ground and also correctly intersect.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br>  It is incredibly difficult to correctly render large areas with shadow maps due to the wildly jumping screen-to-shadow map-texel and other problems with accuracy.  I also had no desire to start experiments with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416307(v%3Dvs.85).aspx">cascading shadow cards</a> .  In addition, raymarching of the same scene from different angles of view is really <i>slow</i> .  So we just decided to scrape the whole system of the same lighting.  This turned out to be a huge problem later when we tried to correlate the lighting of rasterized wires and raymarching scene geometry. <br><br><h1>  Terrain </h1><br>  Raymarching terrain was produced by <a href="http://www.iquilezles.org/www/articles/morenoise/morenoise.htm">numerical noise</a> with analytical derivatives.  <a href="https://habr.com/ru/post/330090/"><sup>one</sup></a> <a name="1_1"></a>  Of course, the generated derivatives were used to impose shadows, but also to control the beam pitch to accelerate the traversal of rays by smooth contours, as in examples iq.  If you want to learn more, read the <a href="http://iquilezles.org/www/articles/terrainmarching/terrainmarching.htm">old article about this technique</a> or play with the <a href="https://www.shadertoy.com/view/4ttSWf">cool rainforest scene on ShaderToy</a> .  The landscape elevation map became more realistic when msqrt implemented an <a href="http://jcgt.org/published/0004/02/01/">exponentially distributed noise</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b4/8c6/cbd/2b48c6cbdbc09e0c5e3c3c23d0175d78.png"><br>  <font color="gray"><i>The first tests are my own implementation of numerical noise.</i></font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/07e/95b/288/07e95b2885e8eed6cd5b3fc2d53a27f5.jpg"><br>  <font color="gray"><i>The implementation of the area from the branch, which they decided not to use.</i></font>  <font color="gray"><i>I do not remember why.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br>  The effect of the landscape is calculated very slowly, because we brute force the shadows and reflections.  The use of shadows is a <a href="http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm">small hack with shadows</a> , in which the size of the penumbra is determined by the shortest distance that was encountered when walking around the shadow beam.  They look <a href="">pretty good in action</a> .  We also tried using bisection tracing to speed up the effect, but it produced too many artifacts.  On the other hand, the <a href="http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf">mercury raymarching tricks</a> (another demo group) helped us to improve the quality a bit without losing speed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/870/864/e3b/870864e3b10482a8cf6e6d8bd8570ccf.png"><br>  <font color="gray"><i>Landscape rendering with better fixed-point iterations (left) compared to conventional raymarching (right).</i></font>  <font color="gray"><i>Pay attention to the unpleasant artifacts of ripples in the picture to the right.</i></font> <br><br>  The sky is generated by almost the same techniques as described in <a href="http://www.iquilezles.org/www/material/function2009/function2009.pdf">behind elevated</a> from iq, slide 43. Some simple functions of the direction vector of the beam.  The sun produces rather large values ‚Äã‚Äãin the frame buffer (above 100), so this also adds some color naturalness. <br><br><h1>  Lane scene </h1><br>  This is a view created under the influence of photos of <a href="http://www.fanhophotography.com/hong-kong-yesterday.html">Fan Ho</a> .  Our post-processing effects really allowed us to create a solid scene, although the original geometry is fairly simple. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c4/49d/535/7c449d5350d063bed312b6d7733320fe.jpg"><br>  <font color="gray"><i>An ugly distance field with some repeating fragments.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/891/e5a/20e/891e5a20e4a5984fab22874af123f441.jpg"><br>  <font color="gray"><i>Added a bit of fog with an exponential change in distance.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ed/a51/0ac/1eda510aca2c3ce3cd00b496adce9054.jpg"><br>  <font color="gray"><i>Wires make the scene more interesting and realistic.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/465/6cd/a9d/4656cda9d538c9a78999c56173964747.jpg"><br>  <font color="gray"><i>In the final version, a bit of noise is added to the distance field to create the impression of brick walls.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/51b/c6c/079/51bc6c079059bd16b6d94f1af8898e5d.jpg"><br>  <font color="gray"><i>With post-processing added color gradient, color, chromatic aberration and glare.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br><h1>  Modeling with distance fields </h1><br>  B-52 bombers are a good example of SDF simulation.  They were much simpler at the development stage, but we brought them to the final release.  From a distance they look pretty convincing: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5d/6bb/877/e5d6bb8779d69f611c7366d1d4e90091.jpg"><br>  <font color="gray"><i>Bombers look good from a distance.</i></font>  <font color="gray"><i><a href="">Full version</a> .</i></font> <br><br>  However, this is just a bunch of capsules.  Admittedly, it would be easier to simply model them in some 3D package, but we didn‚Äôt have any suitable tools at hand, so we chose a faster way.  Just for reference, here‚Äôs what the distance field shader looks like: <a href="https://gist.github.com/seece/dcc4e1a6a68f0a911ad05e3be755588b">bomber_sdf.glsl</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/957/2d8/115/9572d8115a9623ae69f6acefb2c0bb4d.jpg"><br>  <font color="gray"><i>However, they are actually very simple.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br><h1>  Characters </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/1d0/63c/15d/1d063c15df659880013db9599ce97805.png"><br>  <font color="gray"><i>The first four frames of the goat animation.</i></font> <br><br>  Animated characters are simply packaged 1-bit bitmaps.  During playback, the frames smoothly move from one to another.  Material provided by the mysterious goatman. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/424/18d/8ed/42418d8ed35c205569fb2c12933d9133.jpg"><br>  <font color="gray"><i>Kozopas with your friends.</i></font> <br><br><h1>  Post processing </h1><br>  The effects of post-processing wrote varko.  The system is as follows: <br><br><ol><li>  Add shadows from the G-buffer. </li><li>  Calculate the depth of field. </li><li>  Extract light parts for chroma. </li><li>  Perform <i>N</i> separate Gaussian blur operations. </li><li>  Calculate fake lens flare and spotlight glare. </li><li>  Put it all together. </li><li>  Make smooth contours using FXAA ( <a href="">thanks, mudlord</a> ). </li><li>  Color correction. </li><li>  Gamma Correction and Light Grit. </li></ol><br>  The lens <a href="http://john-chapman-graphics.blogspot.fi/2013/02/pseudo-lens-flare.html">flare</a> largely follow the technique <a href="http://john-chapman-graphics.blogspot.fi/2013/02/pseudo-lens-flare.html">described by John Chapman</a> .  Sometimes it was hard to work with them, but the end result delivers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/573/e46/778/573e46778df8033ecc1424bb5cf93bdc.jpg"><br>  <font color="gray"><i>We tried to aesthetically use the effect of depth of field.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br>  The effect of depth of field (based on <a href="https://www.slideshare.net/DICEStudio/five-rendering-ideas-from-battlefield-3-need-for-speed-the-run">the DICE technique</a> ) is done in three passes.  The first one calculates the size of the circle of unsharpness for each pixel, and the other two passes impose on them two spots from rotating areas.  We also make improvements in several iterations (in particular, we impose numerous Gaussian smears) if necessary.  This implementation worked well for us and it was fun to play with. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/a6GM3gqGGjQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <font color="gray"><i>The effect of depth of field in action.</i></font>  <font color="gray"><i>The red picture shows a calculated circle of sharpness for the DOF spot.</i></font> <br><br><h3>  Color correction </h3><br>  Rocket has an animated parameter <code>pp_index</code> , which is used to switch between color correction profiles.  Each profile is simply a different branch of a large branch operator in the final post-processing shader: <br><br><pre> <code class="cpp hljs">vec3 cl = getFinalColor(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (u_GradeId == <span class="hljs-number"><span class="hljs-number">1</span></span>) { cl.gb *= UV.y * <span class="hljs-number"><span class="hljs-number">0.7</span></span>; cl = <span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(cl, vec3(<span class="hljs-number"><span class="hljs-number">1.1</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (u_GradeId == <span class="hljs-number"><span class="hljs-number">2</span></span>) { cl.gb *= UV.y * <span class="hljs-number"><span class="hljs-number">0.6</span></span>; cl.g = <span class="hljs-number"><span class="hljs-number">0.0</span></span>+<span class="hljs-number"><span class="hljs-number">0.6</span></span>*smoothstep(<span class="hljs-number"><span class="hljs-number">-0.05</span></span>,<span class="hljs-number"><span class="hljs-number">0.9</span></span>,cl.g*<span class="hljs-number"><span class="hljs-number">2.0</span></span>); cl = <span class="hljs-number"><span class="hljs-number">0.005</span></span>+<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(cl, vec3(<span class="hljs-number"><span class="hljs-number">1.2</span></span>))*<span class="hljs-number"><span class="hljs-number">1.5</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/* etc.. */</span></span></code> </pre> <br>  It is very simple, but it works quite well. <br><br><h1>  Physical modeling </h1><br>  There are two simulated systems in the demo: wires and a flock of birds.  They also wrote varko. <br><br><h3>  Wires </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/ec6/a37/56b/ec6a3756b159e76d4f75d6fd71d52d8e.jpg"><br>  <font color="gray"><i>Wires add realism to the scene.</i></font>  <font color="gray"><i><a href="">Full size</a> .</i></font> <br><br>  Wires are considered as a series of springs.  They are modeled on a GPU using computational shaders.  We make this simulation in many small steps due to the instability of the Verlet numerical integration method that we use here.  The computational shader also outputs the wire geometry (a series of triangular prisms) to the vertex buffer.  Unfortunately, for some reason, the simulation does not work on AMD cards. <br><br><h3>  A flock of birds </h3><br><iframe width="560" height="315" src="https://www.youtube.com/embed/nsxDR4qTNdo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <font color="gray"><i>Birds give a sense of scale.</i></font> <br><br>  The flock model consists of 512 birds, where the first 128 are considered leaders.  Leaders move in a <a href="http://prideout.net/blog/%3Fp%3D63">whirling</a> pattern, and the rest follow them.  I think that in real life the birds follow the movements of the nearest neighbors, but this simplification looks quite good.  The flock was rendered as <code>GL_POINTs</code> , whose size was modulated to create the impression of flapping wings.  I think this rendering technique was also used in Half-Life 2. <br><br><h1>  Music </h1><br>  Usually, music for 64k intro is made using a <a href="https://en.wikipedia.org/wiki/Virtual_Studio_Technology">VST plugin</a> : so musicians can use their usual instruments to compose music.  A classic example of this approach is farbrausch <a href="http://www.pouet.net/prod.php%3Fwhich%3D15073">V2 Synthesizer</a> . <br><br>  This was a problem.  I did not want to use any ready-made synthesizer, but from previous failed experiments I knew that making my own virtual instrument would require a lot of work.  I remember how I really liked the mood of the <a href="https://www.youtube.com/watch%3Fv%3DSr5Jh5hqfAA">element / gesture demo of 61%</a> , which the branch did with a musical ambient theme, prepared in <a href="http://hypermammut.sourceforge.net/paulstretch/">paulstretched</a> .  This gave me the idea to implement such in the amount of 4k or 64k. <br><br><h3>  Paulstretch </h3><br>  Paulstretch is a great tool for really crazy stretching music.  If you haven't heard about him, then you should definitely listen to <a href="https://www.youtube.com/watch%3Fv%3DFai5s3Zn7b4">what he can make from the sound of the Windows 98 greeting</a> .  His internal algorithms are described <a href="http://www.microscopics.co.uk/blog/2010/paulstretch-an-interview-with-paul-nasca/">in this interview with the author</a> , and he is also open source. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c49/b01/0bf/c49b010bf6d6ee42df481fff9568e20a.png"><br>  <font color="gray"><i>The original sound (top) and the stretched sound (bottom) created using the Paulstretch effect for Audacity.</i></font>  <font color="gray"><i>Notice also how the frequencies are spread across the spectrum (vertical axis).</i></font> <br><br>  Essentially, along with stretching the original signal, it also shakes its phases in the frequency space, so instead of metal artifacts you get an unearthly echo.  This requires many Fourier transforms, and the original application uses the Kiss FFT library for this.  I did not want to depend on an external library, so I finally implemented a simple discrete Fourier transform <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>O</mi><mo stretchy=&quot;false&quot;>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.76ex" height="2.901ex" viewBox="0 -935.7 2910.5 1249" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/330090/&amp;xid=25657,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhguTS4g7V5gb3WolMKCSL-JhSIMAw#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/330090/&amp;xid=25657,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhguTS4g7V5gb3WolMKCSL-JhSIMAw#MJMAIN-28" x="763" y="0"></use><g transform="translate(1153,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/330090/&amp;xid=25657,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhguTS4g7V5gb3WolMKCSL-JhSIMAw#MJMATHI-4E" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/330090/&amp;xid=25657,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhguTS4g7V5gb3WolMKCSL-JhSIMAw#MJMAIN-32" x="1292" y="513"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/330090/&amp;xid=25657,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhguTS4g7V5gb3WolMKCSL-JhSIMAw#MJMAIN-29" x="2520" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></mi><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(</font></font></mo><msup><mi><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></mi><mn><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></mn></msup><mo stretchy="false"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> O (N ^ 2) </script>  on the GPU.  It took a long time to implement it correctly, but in the end it was worth it.  The implementation of the GLSL shader is very compact and works fairly quickly, despite its bruteforce nature. <br><br><h3>  Tracker module </h3><br>  Now it has become possible to wind the coils of ambient buzz, if there is some sensible sound as input data.  So I decided to use proven and tested technology: tracker music.  It is much like MIDI <a href="https://habr.com/ru/post/330090/"><sup>2.</sup></a> <a name="2_2"></a>  , but packed in a file with samples.  For example, in the <a href="http://www.pouet.net/prod.php%3Fwhich%3D374">kasparov</a> demo from elitegroup ( <a href="https://www.youtube.com/watch%3Fv%3DsvkjjNt7J5Q">YouTube</a> ), a module with additional reverberation is used.  If it worked 17 years ago, why not now? <br><br>  I used <code>gm.dls</code> - a sound bank built into Windows MIDI (again an old trick) and made a song using MilkyTracker in the XM module format.  This format was used for many more demos under MS-DOS in the 90s. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a7/95d/503/7a795d503e9254649768dca74ea6bf77.png"><br>  <font color="gray"><i>I used MilkyTracker to compose the original song.</i></font>  <font color="gray"><i>The final module file has been cleared from the instruments samples, and instead the offset and length parameters from <code>gm.dls</code></i></font> <br><br>  The catch with <code>gm.dls</code> is that Roland instruments from 1996 sound very archaic and of poor quality.  But it turned out that there is no problem in this if you immerse them in a ton of reverberations!  Here is an example in which a short test song first plays, and then a stretched version: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://w.soundcloud.com/player/" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Surprisingly atmospheric, agree?  So yes, I made a song that mimics Hollywood music, and it turned out great.  In general, this is all about the musical side. <br><br><h1>  Thanks </h1><br>  Thanks to varko for help with some of the technical details of this article. <br><br><h1>  Additional materials </h1><br><ul><li>  <a href="https://www.youtube.com/watch%3Fv%3DwoqksTHNbvk">Ferris from the Logicoma group shows his toolkit for creating demos 64k</a> <br><ul><li>  Don't forget to see <a href="https://www.youtube.com/watch%3Fv%3DGjuridCR2Fo">Engage</a> first, their work in the same competition in which we participated. </li></ul></li><li>  <a href="https://github.com/laurentlb/Ctrl-Alt-Test/tree/master/">Sources of some demos Ctrl-Alt-Test</a> <br><ul><li>  There are code 4k and 64k. </li><li>  They also have an intro: <a href="https://www.youtube.com/watch%3Fv%3DHpAMtE4i8zg">H-Immersion</a> </li></ul></li></ul><br><hr><br><a name="1"></a>  1. You can calculate analytic derivatives for gradient noise: <a href="https://mobile.twitter.com/iquilezles/status/863692824100782080">https://mobile.twitter.com/iquilezles/status/863692824100782080</a> <br><br><a name="2"></a>  2. The first thought was to simply use MIDI instead of the tracker module, but it does not seem to be a way to simply render a song to a Windows audio buffer.  Apparently, somehow this is possible using the DirectMusic API, but I could not find how.  <a href="https://habr.com/ru/post/330090/">‚Üë</a> </div><p>Source: <a href="https://habr.com/ru/post/330090/">https://habr.com/ru/post/330090/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330080/index.html">Win the Android Camera2 API with RxJava2 (Part 1)</a></li>
<li><a href="../330082/index.html">Rethinking JavaScript: break and functional approach</a></li>
<li><a href="../330084/index.html">How old are you? I'm 11</a></li>
<li><a href="../330086/index.html">Preview RamblerFront & # 1</a></li>
<li><a href="../330088/index.html">All Flash Isilon NAS: Scalable Storage for Unstructured Data</a></li>
<li><a href="../330092/index.html">Monte Carlo and tic-tac-toe tree search</a></li>
<li><a href="../330094/index.html">On the issue of numbers</a></li>
<li><a href="../330096/index.html">How to make money on the Yandex.Money API</a></li>
<li><a href="../330098/index.html">Text online from the festival RIT ++ 2017. Day One</a></li>
<li><a href="../330100/index.html">Text online from the festival RIT ++ 2017. Day two</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>