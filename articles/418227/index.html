<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MIT course "Computer Systems Security". Lecture 7: "Sandbox Native Client", part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Lecture course # 6.858. "Security of computer systems". Nikolai Zeldovich, James Mykens. year 2014 
 Computer S...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MIT course "Computer Systems Security". Lecture 7: "Sandbox Native Client", part 3</h1><div class="post__text post__text-html js-mediator-article"><h3>  Massachusetts Institute of Technology.  Lecture course # 6.858.  "Security of computer systems".  Nikolai Zeldovich, James Mykens.  year 2014 </h3><br>  Computer Systems Security is a course on the development and implementation of secure computer systems.  Lectures cover threat models, attacks that compromise security, and security methods based on the latest scientific work.  Topics include operating system (OS) security, capabilities, information flow control, language security, network protocols, hardware protection and security in web applications. <br><br>  Lecture 1: "Introduction: threat models" <a href="https://habr.com/company/ua-hosting/blog/354874/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/354894/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/354896/">Part 3</a> <br>  Lecture 2: "Control of hacker attacks" <a href="https://habr.com/company/ua-hosting/blog/414505/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/416047/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/416727/">Part 3</a> <br>  Lecture 3: "Buffer overflow: exploits and protection" <a href="https://habr.com/company/ua-hosting/blog/416839/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418093/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418099/">Part 3</a> <br>  Lecture 4: "Separation of privileges" <a href="https://habr.com/company/ua-hosting/blog/418195/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418197/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418211/">Part 3</a> <br>  Lecture 5: "Where Security Errors Come From" <a href="https://habr.com/company/ua-hosting/blog/418213/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418215/">Part 2</a> <br>  Lecture 6: "Opportunities" <a href="https://habr.com/company/ua-hosting/blog/418217/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418219/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418221/">Part 3</a> <br>  Lecture 7: "Sandbox Native Client" <a href="https://habr.com/company/ua-hosting/blog/418223/">Part 1</a> / <a href="https://habr.com/company/ua-hosting/blog/418225/">Part 2</a> / <a href="https://habr.com/company/ua-hosting/blog/418227/">Part 3</a> <a name="habracut"></a><br><br>  In rule <b>C4</b> there is one nuance.  You cannot ‚Äújump over‚Äù the end of the program.  The last thing you can jump to is the last instruction.  So this rule ensures that when the program is executed in the ‚Äúengine‚Äù of the process, there will be no inconsistency. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Rule <b>C5</b> says that there can be no instructions larger than 32 bytes.  We considered a certain variant of this rule when we talked about the multiplicity of the size of the instruction to 32 bytes, otherwise you can jump into the middle of the instruction and create a problem with a system call that can ‚Äúhide‚Äù there. <br><br>  Rule <b>C6</b> states that all available instructions can be disassembled from the very beginning.  Thus, it ensures that we see every instruction and can check all the instructions that are launched during the execution of the program. <br><br>  Rule <b>C7</b> states that all straight jumps are correct.  For example, you jump right into that part of the instruction where the target is indicated, and although it is not a multiple of 32, it is still the correct instruction to which the disassembly is applied from left to right. <br><br><img src="https://habrastorage.org/webt/1-/3i/vl/1-3ivlo26n7llpnkbkvzgzm-tci.jpeg"><br><br>  <b>Audience:</b> what is the difference between <b>C5</b> and <b>C3</b> ? <br><br>  <b>Professor:</b> I think that <b>C5</b> says that if I have a multi-byte instruction, it cannot cross the boundaries of adjacent addresses.  Suppose that I have a stream of instructions, and there is an address 32 and an address 64. So, the instruction cannot cross a border multiple of 32 bytes, that is, it must not begin with an address smaller than 64 and end with an address greater than 64. <br><br><img src="https://habrastorage.org/webt/di/oc/l5/diocl5ztxk3kmc1ol0mmm_badik.jpeg"><br><br>  That is what the <b>C5</b> rule says.  Because otherwise, having made a jump of multiplicity 32, you can get into the middle of another instruction, where it is not known what is happening. <br><br>  And rule <b>C3</b> is an analogue of this prohibition on the side of the jump.  It states that whenever you jump, your jump should be a multiple of 32. <br><br>  <b>C5</b> also claims that anything in the multiple of 32 is a safe instruction. <br><br>  After reading the list of these rules, I had a mixed feeling, since I could not assess whether these rules are sufficient, that is, the minimum is a list or a complete one. <br>  So let's think about the homework you need to do.  I think that in fact in the work of the <b>Native Client</b> there is an error when executing some complicated instruction in the sandbox.  I believe that they did not have the correct length coding, which could lead to something bad, but I can‚Äôt remember exactly what that error was. <br><br>  Suppose that the sandbox validator incorrectly gets the length of some instruction.  What bad can happen in this case?  How would you use this slip? <br><br>  <b>Audience:</b> for example, you can hide a system call or the return statement <b>ret</b> . <br><br>  <b>Professor:</b> yes.  Suppose there is some kind of fancy version of <b>AND</b> instruction that you wrote down.  It is possible that the validator made a mistake and considered that its length is 6 bytes with an actual length of 5 bytes. <br><br><img src="https://habrastorage.org/webt/2z/ak/mg/2zakmgsficxcsi5tqkqnb-r_tj4.jpeg"><br><br>  What happens?  The validator considers the length of this instruction to be 6 bytes and places another valid instruction behind it.  But the processor, running the code, uses the actual length of the instruction, that is, 5 bytes.  As a result, we have a free byte at the end of the <b>AND</b> instruction, where we could insert the system call and use it to our advantage.  And if we insert a byte <b>CD</b> here, it will be like the beginning of another instruction.  Next we will place something in the next interval of 6 bytes, and this will be similar to the instruction that begins with the <b>CD</b> byte, although in fact it is part of the <b>AND</b> instruction.  After that, we can make a system call and "escape" from the sandbox. <br><br>  Thus, the validator of the <b>Native Client</b> must synchronize its actions with the actions of the <b>CPU</b> , that is, ‚Äúguess‚Äù how the processor will interpret each instruction.  And this should be at every level of the sandbox, which is quite difficult to implement. <br><br>  There are actually other interesting bugs in the <b>Native Client</b> .  One of these is incorrect cleaning of the processor environment during a jump into the trusted services environment of the <b>Trusted Service Runtime</b> .  I think we'll talk about it in a second.  But the <b>Trusted Service Runtime</b> is mainly going to work with the same set of <b>CPU</b> registers that are designed to run unreliable modules.  So if the processor forgets to clear or reload something, the runtime environment may be deceived, considering the unreliable module as a trusted application and doing what it shouldn‚Äôt do or what was not part of the developers' intentions. <br><br>  So where are we now?  At the moment, we understand how to disassemble all instructions and how to prevent the execution of prohibited instructions.  Now let's see how we store memory and links for both the code and data within the boundaries of the <b>Native Client</b> module. <br><br>  For performance reasons, the guys from the <b>Native Client</b> are starting to use hardware support to make sure that storing the memory and references doesn't really cause a lot of overhead.  But before I consider the hardware support they use, I want to hear suggestions, how could I do the same without hardware support?  Can we just provide access to all memory processes within the limits set by the machine earlier? <br><br>  <b>Audience:</b> You can instrument the instructions to clear all the higher bits. <br><br><img src="https://habrastorage.org/webt/h1/b7/yg/h1b7ygdlwrvvs7y7ywxitmabec8.jpeg"><br><br>  <b>Professor:</b> yes, that's right.  In fact, we see that we have this <b>AND</b> instruction here, and every time we, for example, jump somewhere, it clears the low bits.  But if we want to save all possible code that runs within the low 256 MB, you can simply replace the first attribute <b>f</b> with <b>0</b> and instead of <b>$ 0xffffffe0</b> get <b>$ 0x0fffffe0</b> .  This clears the low bits and sets the upper limit to 256 MB. <br><br>  So it does exactly what you are offering, allowing you to make sure that whenever you jump, you are within 256 MB.  And the fact that we are disassembling also makes it possible to verify that all direct jumps are within reach. <br><br>  The reason they do not do this for their code is that on the <b>x86</b> platform you can encode <b>AND</b> very efficiently, where all the upper bits are 1. This results in the existence of a 3-byte instruction for <b>AND</b> and a 2-byte instruction for a jump.  Thus, we have an additional expense of 3 bytes.  But if you need not a single high bit, like this <b>0</b> instead of <b>f</b> , then you suddenly have a 5-byte instruction.  Therefore, I think that in this case they are worried about overhead costs. <br><br>  <b>Audience:</b> Is there a problem with the existence of some instructions that give increments to the version you are trying to get?  So you can say that your instruction can have a constant offset or something like that? <br><br>  <b>Professor:</b> I think so.  You will probably prohibit instructions that jump to some complicated address formula and will only support instructions that jump directly to this value, and this value always gets <b>AND</b> . <br><br>  <b>Audience:</b> this is more needed for memory access than ... <br><br>  <b>Professor:</b> yes, because it is just a code.  And for accessing memory on the <b>x86</b> platform, there are many strange ways of accessing a particular memory location.  Usually you must first calculate the location of the memory, then add an additional <b>AND,</b> and only then make access.  I think this is the real reason for their worries about performance degradation due to the use of this tool. <br><br>  On the <b>x86</b> platform, or at least on the 32-bit platform, which is described in the article, they use hardware support instead of restricting the code and address data referring to unreliable modules. <br><br>  Let's see how this looks before we figure out how to use the <b>NaCl</b> module in the sandbox.  This hardware is called segmentation.  It arose before the <b>x86</b> platform acquired the swap file.  On an <b>x86</b> platform, while the process is running, there is a table of supported hardware.  Let's call it the segment descriptor table.  It represents a bunch of segments, numbered from 0 to the end of the table of any size.  This is something like a file descriptor in <b>Unix</b> , except that each entry consists of 2 values: the base of the <b>base</b> and the length of the <b>lenght</b> . <br><br>  This table tells us that we have a couple of segments, and whenever we refer to a particular segment, this in a sense means that we are talking about a chunk of memory that begins with the <b>base</b> address and extends over the length <b>length</b> . <br><br><img src="https://habrastorage.org/webt/bc/5z/ly/bc5zlyp2hzg0aa6nn9nfsbbzwoe.jpeg"><br><br>  This helps us to observe the memory boundaries on the <b>x86</b> platform, because each instruction, referring to the memory, refers to a specific segment in this table. <br><br>  For example, when we execute <b>mov (% eax), (% ebx)</b> , that is, we move the memory value from the pointer stored in the <b>EAX</b> register to another pointer stored in the <b>EBX</b> register, the program knows what the initial one is and what the final address is in view of, and store the value in the second address. <br><br>  But in fact, on the <b>x86</b> platform, when we talk about memory, there is an implicit thing called a segment descriptor, similar to a file descriptor in <b>Unix</b> .  This is simply an index in the descriptor table, and unless otherwise indicated, then each opcode contains a default segment. <br><br>  Therefore, when you execute <b>mov (% eax)</b> , it refers to <b>% ds</b> , or the data segment register, which is a special register in your processor.  If I remember correctly, it is a 16-bit integer that points to this table of descriptors. <br><br>  And the same goes for <b>(% ebx)</b> - it belongs to the same <b>% ds</b> segment selector.  In fact, in <b>x86</b> we have a group of 6 code selectors: <b>CS, DS, ES, FS, GS</b> and <b>SS</b> .  <b>CS</b> call segment selector <b>(call selector) is</b> implicitly used for instructions.  So if your instruction pointer points to something, then it refers to having selected the <b>CS</b> segment selector. <br><br><img src="https://habrastorage.org/webt/li/vq/nz/livqnzyn6jk6muyb93siboedkik.jpeg"><br><br>  Most data references implicitly use <b>DS</b> or <b>ES</b> , <b>FS</b> and <b>GS</b> denote some special things, and <b>SS is</b> always used for stack operations.  And if you execute <b>push &amp; pop</b> , then they implicitly come from this segment selector.  This is quite archaic mechanics, but it turns out to be extremely useful in this particular case. <br><br>  If you get access to some address, for example, in the <b>% ds: addr</b> selector, the hardware translates it to the operation with the <b>adrr + T [% ds] .base table</b> .  This means that he will take the address of the length of the module from the same table.  So whenever you access memory, it has a database of segment selectors in the form of descriptor table entries, and it takes the address you specified and matches it with the length of the corresponding segment. <br><br>  <b>Audience:</b> so why not use it, for example, to protect the buffer? <br><br>  <b>Professor:</b> yes, that's a good question!  Could we use this to protect against buffer overflow?  For example, for each buffer that we have, you can put here the base of the buffer, and there the size of the buffer. <br><br>  <b>Audience:</b> what if you don‚Äôt need to put it in a table before you want to write to it?  You do not need it to be there all the time. <br><br>  <b>Professor:</b> yes.  Therefore, I think that the reason that this approach is not often used to protect against buffer overflows is that the number of entries in this table cannot exceed 2 to the 16th power, because the descriptors are 16 bits long, but in fact A few more bits are used for other things.  So in fact you can place only 2 to the 13th power in this table.  Therefore, if you have an array of data larger than 2 <sup>13</sup> in your code, this table may overflow. <br><br>  In addition, it would be strange for the compiler to directly manage this table, because it is usually manipulated with the help of system calls.  You cannot write directly to this table; you must first make a system call to the operating system, after which the operating system places an entry in this table.  Therefore, I think that most compilers simply do not want to deal with such a complex system of managing memory buffers. <br><br><img src="https://habrastorage.org/webt/rp/sa/hb/rpsahbydh4eumva5z7st5cfuc2a.jpeg"><br><br>  By the way, <b>Multex</b> uses this approach: it has 2 <sup>18</sup> entries for different segments and 2 <sup>18</sup> entries for possible offsets.  And each shared library fragment or memory fragment are separate segments.  They are all checked for a range and therefore cannot be used at a variable level. <br><br>  <b>Audience:</b> presumably, the constant need to use the kernel will slow down the process. <br><br>  <b>Professor:</b> yes, that's right.  So we have an overhead due to the sudden creation of a new buffer in the stack, you need to make a system call to add it. <br><br>  So, how many of these elements actually use a segmentation mechanism?  You can guess how this works.  I think, by default, all these segments in <b>x86</b> have a base of 0 and a length of 2 to 32. Thus, you can access the entire range of memory that you want.  Therefore, for <b>NaCl,</b> they encode base 0 and set the length to 256 megabytes.  They then point to all the registers of the 6 segment selectors in this entry for the 256 MB area.  Thus, whenever a hardware accesses a memory, it modifies it with an offset of 256 MB.  So the ability to change the module will be limited to a range of 256 MB. <br><br>  I think you now understand how this hardware is supported and how it works, so you could end up using these segment selectors. <br>  So what can go wrong if we just implement this plan?  Can we jump out of the segment selector in an unreliable module?  I think that one thing to be careful about is that these registers are similar to regular registers, and you can move values ‚Äã‚Äãinto and out of them.  Therefore, you must ensure that the unreliable module does not distort these segment selector registers.  Because somewhere in the descriptor table there may well be a record, which is also the original segment descriptor for a process with a base of 0 and a length of up to 2 <sup>32</sup> . <br><br><img src="https://habrastorage.org/webt/vg/k-/sv/vgk-svh5b3xlsnke_meuehgaira.jpeg"><br><br>  So if an unreliable module was able to change <b>CS</b> , or <b>DS</b> , or <b>ES</b> , or any of these selectors so that they start pointing to this original operating system that covers your entire address space, then you can link memory to this segment and ‚Äú jump out of the sandbox. <br><br>  Thus, the <b>Native Client</b> should have added a few more instructions to this prohibited list.  I think they prohibit all instructions of type <b>mov% ds, es,</b> and so on.  Therefore, once in the sandbox, you cannot change the segment to which some of the things related to it refer.  On the <b>x86</b> platform <b>, the</b> instructions for changing the segment descriptor table are privileged, but changing the <b>ds, es,</b> and so on themselves.  the table is completely unprivileged. <br><br>  <b>Audience:</b> can you initialize the table so that all unused slots fit zero length? <br><br>  <b>Professor:</b> yes.  You can set the length of the table for something where there are no unused slots.  It turns out that you really need this extra slot containing 0 and 2 <sup>32</sup> , because the <b>trusted runtime</b> should start in this segment and gain access to the whole range of memory.  So this entry is required for running the trusted <b>runtime</b> environment. <br><br>  Audience: what is needed to change the length of the output table? <br>  Professor: you need to have root-rights.  <b>Linux</b> actually has a system called <b>modify_ldt ()</b> for a table of local descriptors that allows any process to change its own table, that is, there is actually one table for each process.  But on the <b>x86</b> platform <b>,</b> this is more complicated, there is both a global table and a local table.  You can change the local table for a specific process. <br><br>  And now we will try to figure out how we jump and jump out of the process of executing the <b>Native Client</b> or jump out of the sandbox.  What does "jump" mean us? <br><br><img src="https://habrastorage.org/webt/8t/lb/yj/8tlbyjy5erf0s-x7stz29ca1qae.jpeg"><br><br>  So, we need to run this trusted code, and this trusted code "lives" somewhere above the 256 MB limit.  In order to jump there, we will have to cancel all these protections that the <b>Native Client has</b> installed.  Basically, they boil down to changing these six selectors.  I think our validator is not going to apply the same rules for things located above the 256 MB limit, so this is quite simple. <br><br>  But then we need to somehow jump into the <b>trusted runtime trusted runtime</b> and reset the segment selectors to the correct values ‚Äã‚Äãfor this giant segment that covers the address space of the entire process ‚Äî this range is from 0 to 2 <sup>32</sup> .  Such mechanisms that exist in the <b>Native Client</b> , they called the trampoline <b>trampoline</b> and springboards springboards.  They live in a low 64k module.  The cool thing is that these ‚Äútrampolines‚Äù and ‚Äúspringboards‚Äù are pieces of code that lie in the bottom 64k of the process space.  This means that this unreliable module can jump there, because it is a valid code address that is within the limits of 32 bits and within 256 MB.  So you can jump on this ‚Äútrampoline‚Äù. <br><br>    <b>Native Client</b>    ¬´¬ª - .  ,  <b>Native Client</b>       ¬´¬ª,   trampoline      <b>trusted runtime</b> .         ,    <b>DS, CS</b>   ,       . <br><br>  ,        ,   -  <b>malo</b>   ,    ¬´¬ª,  ¬´¬ª  32-  . <br><br> ,     4096 + 32        ,     .   , ,   <b>mov %ds, 7</b> ,       <b>ds</b> ,   7         0  2 <sup>32</sup> .    <b>CS</b>       <b>trusted service runtime</b> ,     256 . <br><br><img src="https://habrastorage.org/webt/cr/fx/xj/crfxxjwdpg1tcflmflesmj_8obq.jpeg"><br><br>  ,     ,     ,         <b>trusted service runtime</b> ,    .            ,   .      DS ,   ,      ,     ,    -       . <br><br> ,        ? ,          ¬´¬ª? ,    ? <br><br> <b>:</b>    64. <br><br> <b>:</b> , ,          .         malo,       64,     32 .        ,       ,  ,     . <br><br>   ,        32-  ,       .  , ,        32 ,     32-    ,    .       ¬´¬ª    <b>trusted runtime</b>   32  . <br><br><img src="https://habrastorage.org/webt/hq/zy/tj/hqzytj99szvgxayslg6aqmwlmrk.jpeg"><br><br>      .     ,     ,     <b>DS, CS</b>   .    ,       256-  ,    <b>trusted runtime</b> ,      .                 . <br><br>         ¬´¬ª,      <b>trusted runtime</b>   256     <b>Native Client</b> . ¬´¬ª   <b>DS</b> , ,  <b>mov %ds, 7</b> ,        ,  <b>trusted runtime</b>    .     .     ,        ¬´¬ª,       - . <br><br>      <b>halt</b>    32-   ¬´¬ª.        ¬´¬ª,   .      <b>trusted service runtime</b>      ,   1    . <br><br><img src="https://habrastorage.org/webt/50/am/cy/50amcyeulmago9zmrdvmjrsipvg.jpeg"><br><br>       <b>trusted service runtime</b> ,     ,        . <br><br> <b>:</b>   ¬´¬ª    ? <br><br> <b>:</b> ¬´¬ª     0  256   .        64-     ,    ,       ¬´¬ª,    - -.     <b>Native Client</b>       . <br><br> <b>:</b>          ? <br><br> <b>:</b> ,         ?  ,      ¬´¬ª?  What is bad? <br><br> <b>:</b>    ,   ? <br><br> <b>:</b>  ,            -  <b>%eax</b> ,  <b>trusted runtime</b> : ¬´,      ¬ª!      <b>EAX</b> ,    <b>mov</b> ,  ¬´¬ª      <b>EAX</b> ,        <b>trusted runtime</b> .   ,       ¬´¬ª? <br><br> <b>:</b> ,        ,         .   ‚Ä¶ <br><br> <b>:</b> ,   ,       ‚Äî  ,       ,            0  2 <sup>32</sup> .  This is really important.         ¬´¬ª,                256 . <br><br>  ,      ¬´¬ª,          .  , ¬´¬ª    ,    .    ,   ¬´¬ª   . <br><br> <b>:</b>    ¬´¬ª   256 ? <br><br> <b>:</b>  ,      .    ,       <b>CS</b>         -  .     ¬´¬ª,       <b>halt</b> ,   mov,    <b>CS</b> ,        ,       256 . <br><br>  ,         ,    ¬´¬ª.  ,       <b>DS</b> ,  ,  <b>CS</b>   - . <br><br> ,    ,        <b>x86</b> ,           <b>Native Client</b> . <br><br> ,        -. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/I0Psvvky-44" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Full version of the course is available <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-858-computer-systems-security-fall-2014/">here</a> . <br><br>  Thank you for staying with us.  Do you like our articles?  Want to see more interesting materials?  Support us by placing an order or recommending to friends, <b>30% discount for Habr users on a unique analogue of the entry-level servers that we invented for you:</b> <a href="https://habr.com/company/ua-hosting/blog/347386/">The whole truth about VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps from $ 20 or how to share the server?</a>  (Options are available with RAID1 and RAID10, up to 24 cores and up to 40GB DDR4). <br><br>  <b>VPS (KVM) E5-2650 v4 (6 Cores) 10GB DDR4 240GB SSD 1Gbps until December for free</b> if you pay for a period of six months, you can order <a href="https://ua-hosting.company/vpsnl">here</a> . <br><br>  <b>Dell R730xd 2 times cheaper?</b>  Only we have <b><a href="https://ua-hosting.company/serversnl">2 x Intel Dodeca-Core Xeon E5-2650v4 128GB DDR4 6x480GB SSD 1Gbps 100 TV from $ 249</a> in the Netherlands and the USA!</b>  Read about <a href="https://habr.com/company/ua-hosting/blog/329618/">How to build an infrastructure building.</a>  <a href="https://habr.com/company/ua-hosting/blog/329618/">class c using servers Dell R730xd E5-2650 v4 worth 9000 euros for a penny?</a> </div><p>Source: <a href="https://habr.com/ru/post/418227/">https://habr.com/ru/post/418227/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418217/index.html">MIT course "Computer Systems Security". Lecture 6: "Opportunities", part 1</a></li>
<li><a href="../418219/index.html">MIT course "Computer Systems Security". Lecture 6: "Opportunities", part 2</a></li>
<li><a href="../418221/index.html">MIT course "Computer Systems Security". Lecture 6: "Opportunities", part 3</a></li>
<li><a href="../418223/index.html">MIT course "Computer Systems Security". Lecture 7: "Sandbox Native Client", part 1</a></li>
<li><a href="../418225/index.html">MIT course "Computer Systems Security". Lecture 7: "Sandbox Native Client", part 2</a></li>
<li><a href="../418229/index.html">MIT course "Computer Systems Security". Lecture 8: "Model of network security", part 1</a></li>
<li><a href="../418233/index.html">BMW Mnemonic for finding boundary values</a></li>
<li><a href="../418235/index.html">Orchestrated saga or how to build business transactions in services with the pattern database per service</a></li>
<li><a href="../418237/index.html">Development of multi-tenant applications on the SAP Cloud Platform in the Neo environment, part 2: authorization and authentication</a></li>
<li><a href="../418239/index.html">48 megapixel for smartphone</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>