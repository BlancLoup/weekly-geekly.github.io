<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Such an exceptional go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, drafts of the design of a new error handling in Go 2 were published. It is very pleasing that the language does not stand in one place - it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Such an exceptional go</h1><div class="post__text post__text-html js-mediator-article"><p>  Recently, drafts of the design of a new error handling in Go 2 were published. It is very pleasing that the language does not stand in one place - it develops and becomes more lethal with each year. </p><br><p>  Only now, while Go 2 can only be seen on the horizon, and it‚Äôs very painful and sad to wait.  Therefore, we take matters into our own hands.  A little bit of code generation, a bit of work with ast, and a slight movement of the arm of a panic turn, turn panic ... into elegant exceptions! </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0u/sd/fx/0usdfxkuqp9qtfe9biignfxdzxo.jpeg"></div><a name="habracut"></a><br><blockquote>  And at once I want to make a very important and absolutely serious statement. <br>  This decision is <em>purely</em> entertaining and pedagogical. <br>  I mean just 4 fun.  This is generally a proof-of-concept, in truth.  I warned :) </blockquote><br><h2 id="tak-chto-zhe-vyshlo">  So what happened </h2><br><p>  It turned out a small such <a href="https://github.com/anjensan/jex">library-kodogenerator</a> .  And kodogenerators, as everyone knows, carry goodness and grace.  Not really, but they are quite popular in the Go world. </p><br><p> We set such kodogenerator on go-raw.  He parses it for using the standard <code>go/ast</code> module, does some <del>  not </del>  tricky transformations, the result is written next to the file, adding the suffix <code>_jex.go</code> .  The resulting files for work want a tiny runtime. </p><br><p>  This is exactly the way we add exceptions to Go. </p><br><h2 id="polzuem">  We use </h2><br><p>  We connect the generator to the file, in the header (before the <code>package</code> ) we write </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//+build jex //go:generate jex</span></span></code> </pre> <br><p>  If you now run the command <code>go generate -tags jex</code> , then the <code>jex</code> utility will be executed.  She takes the file name from <code>os.Getenv("GOFILE")</code> , eats it, digests it and writes <code>{file}_jex.go</code> .  The newborn file in the header already has <code>//+build !jex</code> (the tag is inverted), so the <code>go build</code> , and along with it the rest of the commands, like <code>go test</code> or <code>go install</code> , take into account only the <em>new</em> , correct files.  Lepote ... </p><br><p>  Now dot-import <code>github.com/anjensan/jex</code> . <br>  Yes, yes, while import through a point is required.  In the future it is planned to leave exactly the same. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/anjensan/jex"</span></span></code> </pre> <br><p>  Great, now you can insert <code>TRY</code> , <code>THROW</code> , <code>EX</code> stub function calls into the code.  The code for all this remains syntactically valid, and even compiles in its raw form (it just does not work), so the auto-completions are available and the linters <em>do not</em> swear <em>much</em> .  The editors would also show documentation for these functions, if only they had it. </p><br><p>  Throw an exception </p><br><pre> <code class="go hljs">THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"error name"</span></span>))</code> </pre> <br><p>  Catch exception </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { <span class="hljs-comment"><span class="hljs-comment">//   } else { fmt.Println(EX()) }</span></span></code> </pre> <br><p>  An anonymous function is generated under the hood.  And in her <code>defer</code> .  And in it one more function.  And in her <code>recover</code> ... Well, there is still some more ast-magic to handle <code>return</code> and <code>defer</code> . </p><br><p>  And yes, by the way, they are supported! </p><br><p>  In addition, there is a special macro variable <code>ERR</code> .  If you assign an error to it, an exception is thrown out.  This makes it easier to call functions that still return <code>error</code> in the old fashioned way. </p><br><pre> <code class="go hljs">file, ERR := os.Open(filename)</code> </pre> <br><p>  Additionally, there are a couple of small utility bags <code>ex</code> and <code>must</code> , but there is nothing to tell about. </p><br><h2 id="primery">  Examples </h2><br><p>  Here is an example of a correct, idiomatic Go code. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { r, err := os.Open(src) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w, err := os.Create(dst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, err := io.Copy(w, r); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { w.Close() os.Remove(dst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := w.Close(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { os.Remove(dst) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"copy %s %s: %v"</span></span>, src, dst, err) } }</code> </pre> <br><p>  This code is not so pleasant and elegant.  By the way, this is not just my opinion! <br>  But <code>jex</code> will help us improve it. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CopyFile_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(src, dst </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ex.Logf(<span class="hljs-string"><span class="hljs-string">"copy %s %s"</span></span>, src, dst) r, ERR := os.Open(src) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> r.Close() w, ERR := os.Create(dst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { ERR := io.Copy(w, r) ERR := w.Close() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { w.Close() os.Remove(dst) THROW() } }</code> </pre> <br><p>  But for example the following program </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { hex, err := ioutil.ReadAll(os.Stdin) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } data, err := parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } os.Stdout.Write(data) }</code> </pre> <br><p>  can be rewritten as </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { hex, ERR := ioutil.ReadAll(os.Stdin) data, ERR := parseHexdump(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(hex)) os.Stdout.Write(data) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { log.Fatal(EX()) } }</code> </pre> <br><p>  Here is another example in order to feel the proposed idea better.  Original code </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { x, err := strconv.Atoi(a) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } y, err := strconv.Atoi(b) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  can be rewritten as </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { x, ERR := strconv.Atoi(a) y, ERR := strconv.Atoi(b) fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, x + y) }</code> </pre> <br><p>  or so even </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printSum_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"result:"</span></span>, must.Int_(strconv.Atoi(a)) + must.Int_(strconv.Atoi(b))) }</code> </pre> <br><h2 id="isklyuchenie">  An exception </h2><br><p>  The essence is a simple structure-wrapper over the <code>error</code> instance. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> exception <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ,   err error //  ^W , ,    log []interface{} //      ,    suppress []*exception }</span></span></code> </pre> <br><p>  An important point - the usual panic is not perceived as exceptions.  So, all standard errors are not exceptions, like <code>runtime.TypeAssertionError</code> .  This corresponds to the accepted best practices in Go - if we have, say, a nil-dereference, then we cheerfully and cheerfully drop the whole process.  Reliable and predictable.  Although not sure, perhaps it is worth reviewing this moment and still catching such errors.  Maybe optional? </p><br><p>  Here is an example of a chain of exceptions. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">one_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"one"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">two_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"two"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">three</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { one_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { two_() } }</code> </pre> <br><p>  Here we calmly handle the exception <code>one</code> , as suddenly bang ... and the exception <code>two</code> thrown.  So, the original <code>one</code> <code>suppress</code> attach to the <code>suppress</code> field.  Nothing is lost, everything goes to the logs.  And therefore, there is no particular need to push the entire chain of errors directly into the message text using the very popular <code>fmt.Errorf("blabla: %v", err)</code> pattern <code>fmt.Errorf("blabla: %v", err)</code> .  Although no one, of course, prohibits its use here, if you really want to. </p><br><h2 id="kogda-zabyli-otlovit">  When they forgot to catch </h2><br><p>  Ah, another very important moment.  In order to improve readability, there is an additional check: if a function can throw an exception, then its name must end with <code>_</code> .  Consciously crooked name that prompts the programmer "dear sir, here in your program something can go wrong, if you please be attentive and diligent!" </p><br><p>  The check is started automatically for transformable files, plus it can still be started manually in the project using the <code>jex-check</code> command.  Perhaps it makes sense to run it as part of the build process along with other linters. </p><br><p>  Comment checking is <code>//jex:nocheck</code> .  This, by the way, is still the only way to throw exceptions from an anonymous function. </p><br><p>  Of course this is not a panacea for all problems.  Checker will miss this </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bad_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"ups"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { f := bad_ f() }</code> </pre> <br><p>  On the other hand, it is not much worse than the standard check on <code>err declared and not used</code> , which is very easy to get around </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a, err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } b, err := bar() <span class="hljs-comment"><span class="hljs-comment">//  ,    ok... go vet, ? }</span></span></code> </pre> <br><p>  In general, this question is rather philosophical, what is better to do when you forgot to handle the error - quietly ignore it, or throw out panic ... By the way, better verification results could be achieved by introducing support for exceptions to the compiler, but this is much beyond the scope of this article . </p><br><p>  Some may say that, although this is a wonderful solution, it is no exception, since exceptions now mean a very concrete implementation.  Well, it‚Äôs because the exceptions are not attached to the exceptions, or there is a separate linter for checking the function names, or that the function may end in <code>_</code> but it does not throw exceptions, or there is no direct support in the syntax, or that it is in fact panic, but panic is not an exception at all, because gladiolus ... Disputes can be as hot as they are useless and pointless.  Therefore, I will leave them behind the board of the article, and the described solution will continue to unshakably call "exceptions." </p><br><h2 id="po-povodu-stektreysov">  Regarding the structures </h2><br><p>  Often, developers, in order to simplify debugging, rivet the constructs to custom implementation <code>error</code> .  There are even some popular libraries for this.  But, fortunately, with exceptions, no additional actions are needed due to one interesting feature of Go ‚Äî during a panic, the <code>defer</code> blocks <code>defer</code> executed in the stack context of the code that the panic threw.  Therefore here </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"ups"</span></span>)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { foo_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { debug.PrintStack() } }</code> </pre> <br><p>  a full-fledged spectra will be printed, even a little verbose (cut out file names) </p><br><pre> <code class="go hljs"> runtime/debug.Stack runtime/debug.PrintStack main.bar.func2 github.com/anjensan/jex/runtime.TryCatch.func1 <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span> main.foo_ main.bar.func1 github.com/anjensan/jex/runtime.TryCatch main.bar main.main</code> </pre> <br><p>  It doesn‚Äôt hurt to make your own helper for formatting / printing of the glassboard taking into account surrogate functions, hiding them for readability.  I think a good idea, recorded in. </p><br><p>  And you can grab the stack and attach it to the exception with <code>ex.Log()</code> .  Then such an exception is allowed to transfer to another city center - the strays are not lost. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foobar_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { e := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> error, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(e) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { checkZero_() } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { EX().Log(debug.Stack()) <span class="hljs-comment"><span class="hljs-comment">//   e &lt;- EX().Wrap() //     } }() ex.Must_(&lt;-e) //  ,  ,  }</span></span></code> </pre> <br><h2 id="k-sozhaleniyu">  Unfortunately </h2><br><p>  Eh ... of course, something better would look better </p><br><pre> <code class="go hljs"> try { throw io.EOF, <span class="hljs-string"><span class="hljs-string">"some comment"</span></span> } catch e { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"exception: %v"</span></span>, e) }</code> </pre> <br><p>  But alas, the Go syntax is not extensible. <br>  [thoughtfully] Although, probably, this is still for the better ... </p><br><p>  In any case, it is necessary to pervert.  One of the alternative ideas was to make </p><br><pre> <code class="go hljs"> TRY; { THROW(io.EOF, <span class="hljs-string"><span class="hljs-string">"some comment"</span></span>) }; CATCH; { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"exception: %v"</span></span>, EX) }</code> </pre> <br><p>  But such code looks awkward after <code>go fmt</code> .  And the compiler curses when it sees <code>return</code> in both branches.  There is no such problem with <code>if-TRY</code> . </p><br><p>  It would be cool to replace the macro <code>ERR</code> with the <code>MUST</code> function (better simply <code>must</code> ).  To write </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> MUST(strconv.Atoi(a)) + MUST(strconv.Atoi(b))</code> </pre> <br><p>  In principle, this is still realizable; it is possible to derive the type of expressions when analyzing ast, generate a simple wrapper function for all variants of types, such as those declared in the <code>must</code> package, and then replace <code>MUST</code> with the name of the corresponding surrogate function.  This is not entirely trivial, but it is completely possible ... Only now editors / ides will not be able to understand such code.  After all, the signature of the <code>MUST</code> stub function is not expressed in the framework of the Go type system.  And therefore no autocomplete. </p><br><h2 id="pod-kapotom">  Under the hood </h2><br><p>  A new import is added to all processed files. </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _jex <span class="hljs-string"><span class="hljs-string">"github.com/anjensan/jex/runtime"</span></span></code> </pre> <br><p>  The call to <code>THROW</code> is replaced by <code>panic(_jex.NewException(...))</code> .  Also, <code>EX()</code> is replaced with the name of a local variable in which the caught exception lies. </p><br><p>  But <code>if TRY() {..} else {..}</code> processed a bit more complicated.  First, special processing occurs for all <code>return</code> and <code>defer</code> .  Then the processed if-a branches are placed in anonymous functions.  And then these functions are passed to <code>_jex.TryCatch(..)</code> .  Here it is </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span> { THROW(errors.New(<span class="hljs-string"><span class="hljs-string">"a == 0"</span></span>)) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> fmt.Printf(<span class="hljs-string"><span class="hljs-string">"a = %d\n"</span></span>, a) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"hmm"</span></span> }</code> </pre> <br><p>  turns into something like this (I removed comments <code>//line</code> ): </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_jex_r0 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, _jex_r1 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _jex_ret <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> fmt.Println(<span class="hljs-string"><span class="hljs-string">"before"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _jex_md2502 _jex.MultiDefer <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> _jex_md2502.Run() _jex.TryCatch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(_jex.NewException(errors.New(<span class="hljs-string"><span class="hljs-string">"a == 0"</span></span>))) } { _f, _p0, _p1 := fmt.Printf, <span class="hljs-string"><span class="hljs-string">"a = %d\n"</span></span>, a _jex_md2502.Defer(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _f(_p0, _p1) }) } _jex_ret, _jex_r0, _jex_r1 = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, a+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"ok"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_jex_ex _jex.Exception)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> _jex.Suppress(_jex_ex) fmt.Println(<span class="hljs-string"><span class="hljs-string">"fail"</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _jex_ret { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"hmm"</span></span> }</code> </pre><br><p>  A lot, not beautiful, but it works.  Well, not all and not always.  For example, you cannot <code>defer-recover</code> inside TRY, since the function call turns into an additional lambda. </p><br><p>  Also, when displaying the ast tree, the option "save comments" is specified.  So, in theory, <code>go/printer</code> should print them ... What he honestly does, though very, very crooked =) I will not give examples, just crooked.  In principle, such a problem is quite solvable if you carefully specify the positions for all ast-nodes (they are now empty), but this is definitely not included in the list of necessary things for the prototype. </p><br><h2 id="probuem">  We try </h2><br><p>  Out of curiosity, wrote a small <a href="">benchmark</a> . </p><br><p>  We have a wooden implementation of qsort, which checks for the presence of duplicates.  Found - an error.  One version simply forgets through <code>return err</code> , the other clarifies the error by calling <code>fmt.Errorf</code> .  And one more uses exceptions.  We sort the slices of different sizes, either without any duplicates (there is no error, the slice is sorted completely), or with one repetition (the sorting is interrupted about halfway through the timing). </p><br><div class="spoiler">  <b class="spoiler_title">results</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">~ &gt; cat /proc/cpuinfo | grep <span class="hljs-string"><span class="hljs-string">'model name'</span></span> | head <span class="hljs-number"><span class="hljs-number">-1</span></span> model <span class="hljs-type"><span class="hljs-type">name</span></span> : Intel(R) Core(TM) i7<span class="hljs-number"><span class="hljs-number">-6700</span></span>K CPU @ <span class="hljs-number"><span class="hljs-number">4.00</span></span>GHz ~ &gt; go <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> go <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> go1<span class="hljs-number"><span class="hljs-number">.11</span></span> linux/amd64 ~ &gt; go test -bench=. github.com/anjensan/jex/demo goos: linux goarch: amd64 pkg: github.com/anjensan/jex/demo BenchmarkNoErrors/_____10/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000000</span></span> <span class="hljs-number"><span class="hljs-number">236</span></span> ns/op BenchmarkNoErrors/_____10/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">255</span></span> ns/op BenchmarkNoErrors/_____10/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">287</span></span> ns/op BenchmarkNoErrors/____100/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3119</span></span> ns/op BenchmarkNoErrors/____100/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3194</span></span> ns/op BenchmarkNoErrors/____100/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3533</span></span> ns/op BenchmarkNoErrors/___1000/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">42356</span></span> ns/op BenchmarkNoErrors/___1000/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">42204</span></span> ns/op BenchmarkNoErrors/___1000/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">30000</span></span> <span class="hljs-number"><span class="hljs-number">44465</span></span> ns/op BenchmarkNoErrors/__10000/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">525864</span></span> ns/op BenchmarkNoErrors/__10000/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">524781</span></span> ns/op BenchmarkNoErrors/__10000/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">3000</span></span> <span class="hljs-number"><span class="hljs-number">561256</span></span> ns/op BenchmarkNoErrors/_100000/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6309181</span></span> ns/op BenchmarkNoErrors/_100000/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6335135</span></span> ns/op BenchmarkNoErrors/_100000/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> <span class="hljs-number"><span class="hljs-number">6687197</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">76274341</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">77806506</span></span> ns/op BenchmarkNoErrors/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">78019041</span></span> ns/op BenchmarkOneError/_____10/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-number"><span class="hljs-number">712</span></span> ns/op BenchmarkOneError/_____10/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000000</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> ns/op BenchmarkOneError/_____10/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">2000000</span></span> <span class="hljs-number"><span class="hljs-number">799</span></span> ns/op BenchmarkOneError/____100/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">2296</span></span> ns/op BenchmarkOneError/____100/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">1000000</span></span> <span class="hljs-number"><span class="hljs-number">1809</span></span> ns/op BenchmarkOneError/____100/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500000</span></span> <span class="hljs-number"><span class="hljs-number">3529</span></span> ns/op BenchmarkOneError/___1000/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">21168</span></span> ns/op BenchmarkOneError/___1000/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-number"><span class="hljs-number">20747</span></span> ns/op BenchmarkOneError/___1000/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">50000</span></span> <span class="hljs-number"><span class="hljs-number">24560</span></span> ns/op BenchmarkOneError/__10000/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-number"><span class="hljs-number">242077</span></span> ns/op BenchmarkOneError/__10000/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-number"><span class="hljs-number">242376</span></span> ns/op BenchmarkOneError/__10000/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span> <span class="hljs-number"><span class="hljs-number">251043</span></span> ns/op BenchmarkOneError/_100000/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2753692</span></span> ns/op BenchmarkOneError/_100000/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2824116</span></span> ns/op BenchmarkOneError/_100000/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-number"><span class="hljs-number">2845701</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span><span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33452819</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/return_err<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33374000</span></span> ns/op BenchmarkOneError/<span class="hljs-number"><span class="hljs-number">1000000</span></span>/fmt.errorf<span class="hljs-number"><span class="hljs-number">-8</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> <span class="hljs-number"><span class="hljs-number">33705994</span></span> ns/op PASS ok github.com/anjensan/jex/demo <span class="hljs-number"><span class="hljs-number">64.008</span></span>s</code> </pre> </div></div><br><p>  If the error is not thrown (the code is stable and reinforced concrete), then the varant with the exception forwarding is approximately comparable to <code>return err</code> and <code>fmt.Errorf</code> .  Sometimes a little faster.  But if they threw a mistake, the exceptions go to second place.  But it all depends on the ratio of "useful work / errors" and the depth of the stack.  For small slices, <code>return err</code> goes to the gap, for medium and large exceptions are already equal to manual forwarding. </p><br><p>  In short, if errors occur very rarely - exceptions may even speed up the code a bit.  If like everyone else, it will be something like this.  But if very often ... then slow exceptions are far from the most important problem that is worth worrying about. </p><br><p>  As a test, I tried to <a href="https://github.com/divan/gorilla-xmlrpc/pull/25">migrate the</a> real gosh <a href="https://github.com/divan/gorilla-xmlrpc">library</a> for exceptions. </p><br><div class="spoiler">  <b class="spoiler_title">To my deep regret, it did not work out to rewrite 1-in-1</b> <div class="spoiler_text"><p>  More precisely, it would have happened, but it must be bother. </p><br><p>  So, for example, the <a href=""><code>rpc2XML</code></a> function seems to be returning an <code>error</code> ... but it just never returns it.  If you try to serialize an unsupported data type - no error, just empty output.  Maybe it is conceived? .. No, conscience does not allow to leave like that.  Added by </p><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: THROW(fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"unsupported type %T"</span></span>, value))</code> </pre> <br><p>  But it turned out that this function is used in a special way. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpcParams2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rpc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error buffer := <span class="hljs-string"><span class="hljs-string">"&lt;params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reflect.ValueOf(rpc).Elem().NumField(); i++ { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xml <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> buffer += <span class="hljs-string"><span class="hljs-string">"&lt;param&gt;"</span></span> xml, err = rpc2XML(reflect.ValueOf(rpc).Elem().Field(i).Interface()) buffer += xml buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/param&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer, err }</code> </pre> <br><p>  Here we run through the list of parameters, serialize them all, but return an error <em>only</em> for the latter.  The remaining errors are ignored.  Strange behavior made easier </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rpcParams2XML_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rpc </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; reflect.ValueOf(rpc).Elem().NumField(); i++ { buffer += <span class="hljs-string"><span class="hljs-string">"&lt;param&gt;"</span></span> buffer += rpc2XML_(reflect.ValueOf(rpc).Elem().Field(i).Interface()) buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/param&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/params&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> <br><p>  If at least one field failed to serialize - an error.  Well, that's better.  But it turned out that this function is also used in a <a href="">special</a> way. </p><br><pre> <code class="go hljs">xmlstr, _ = rpcResponse2XML(response)</code> </pre> <br><p>  again, for the source code it is not so important, because there errors are already ignored.  I am starting to guess why some programmers are <em>so</em> fond of explicit error handling via <code>if err != nil</code> ... But with exceptions, it‚Äôs still easier to forward or process than to ignore </p><br><pre> <code class="go hljs">xmlstr = rpcResponse2XML_(response)</code> </pre> <br><p>  And I did not remove the "chain of errors."  Here is the original code </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeClientResponse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader, reply </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { rawxml, err := ioutil.ReadAll(r) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FaultSystemError } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> xml2RPC(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(rawxml), reply) }</code> </pre> <br><p>  that's rewritten </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DecodeClientResponse_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r io.Reader, reply </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rawxml []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { rawxml, ERR = ioutil.ReadAll(r) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { THROW(FaultSystemError) } xml2RPC_(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(rawxml), reply) }</code> </pre> <br><p>  Here the original error (which <code>ioutil.ReadAll</code> returned) will not be lost, will be attached to the exception in the <code>suppress</code> field.  Again, it can be done the same as in the original, but this should be specially confused ... </p><br><p>  Rewrote the tests, replacing <code>if err != nil { log.Error(..) }</code> with a simple forwarding exception.  There is a negative point - the tests fall on the first error, not continuing to work "well, at least somehow."  According to the mind, we should divide them into sub-tests ... What, in general, is worth doing anyway.  But it‚Äôs very easy to get the right frame </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">errorReporter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t testing.TB)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e error)</span></span></span></span> { t.Log(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(debug.Stack())) t.Fatal(e) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestRPC2XMLConverter_</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> ex.Catch(errorReporter(t)) <span class="hljs-comment"><span class="hljs-comment">// ... xml := rpcRequest2XML_("Some.Method", req) }</span></span></code> </pre> <br><p>  In general, errors are very easy to ignore.  In the original code </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fault Fault)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;methodResponse&gt;&lt;fault&gt;"</span></span> xml, _ := rpc2XML(fault) buffer += xml buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/fault&gt;&lt;/methodResponse&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> <br><p>  here the error from <code>rpc2XML</code> again <code>rpc2XML</code> ignored.  It became like this </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fault2XML</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fault Fault)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { buffer := <span class="hljs-string"><span class="hljs-string">"&lt;methodResponse&gt;&lt;fault&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> TRY() { buffer += rpc2XML_(fault) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"ERR: %v"</span></span>, EX()) buffer += <span class="hljs-string"><span class="hljs-string">"&lt;nil/&gt;"</span></span> } buffer += <span class="hljs-string"><span class="hljs-string">"&lt;/fault&gt;&lt;/methodResponse&gt;"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buffer }</code> </pre> </div></div><br><p>  According to my personal feelings, with errors it is easier to return the "half-ready" result. <br>  For example, a half-designed response.  With exceptions it is more difficult, since the function either returns a successful result or returns nothing at all.  Such atomicity.  On the other hand, exceptions are more difficult to ignore or lose the root cause in the exception chain.  After all, you need to specifically try to do it.  With errors, this happens easily and naturally. </p><br><h2 id="vmesto-zaklyucheniya">  Instead of conclusion </h2><br><p>  When <em>writing</em> this article, no gopher was hurt. </p><br><p>  Thanks for the photo of the gopher-alcoholic <a href="http://migranov.ru/">http://migranov.ru</a> </p><br><p>  Could not choose between the hubs "Programming" and "Abnormal Programming". <br>  A very difficult choice, added to both. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/425145/">https://habr.com/ru/post/425145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425135/index.html">Why VoIP was recognized as an information service in the USA, and what it means for the telecom industry and users</a></li>
<li><a href="../425137/index.html">We work in the console quickly and efficiently</a></li>
<li><a href="../425139/index.html">Pop stars under the lens of artificial intelligence</a></li>
<li><a href="../425141/index.html">‚ÄúFacing Guido what you tell him‚Äù or Python dialogs with Bobuk</a></li>
<li><a href="../425143/index.html">Higher School of Economics refuses to lecture in favor of online courses</a></li>
<li><a href="../425149/index.html">Between heaven and earth</a></li>
<li><a href="../425151/index.html">We are listening to the telegraph chat with the help of our client</a></li>
<li><a href="../425153/index.html">Three of the most popular misconceptions about emotions in Affective Computing</a></li>
<li><a href="../425155/index.html">Fascinating cryptography or research on reversible PHP encryption</a></li>
<li><a href="../425157/index.html">Meet the .Net community at CLRium # 4 + online. Where CoreCLR and C # are moving. All are invited</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>