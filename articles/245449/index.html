<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>.NET / Mono in Java? Easy!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. I want to introduce my project - the .NET / Mono compiler in Java. The goal of the project is to create a compiler, and a set of standard libra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>.NET / Mono in Java? Easy!</h1><div class="post__text post__text-html js-mediator-article">  Hello.  I want to introduce my project - the .NET / Mono compiler in Java.  The goal of the project is to create a compiler, and a set of standard libraries allowing to transfer written applications and libraries to the Java platform, version 1.6 and higher.  From similar projects I know only the dot42 project.  But it is sharpened for Android and has its own standard library not quite compatible with .NET / Mono. <br><br>  So far there is only an alpha version, and therefore the compiler is not yet suitable for real use, but it is already partially functional, generates valid Java code and supports part of the ECMA-335 standard. <br><br>  Source code on github.com: <a href="https://github.com/zebraxxl/CIL2Java">https://github.com/zebraxxl/CIL2Java</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br>  The compiler is a console application that, when run without parameters, displays help.  So with the use of problems should not arise. <br><br>  I also want to note that when working, the compiler proceeds from the assumption that all code submitted to it at the input is valid. <br><br><h2>  What is not supported </h2><br>  Just want to stipulate that at the moment is not supported: <br><ul><li>  Unmanaged pointers </li><li>  Math over pointers (both managed and unmanaged) </li><li>  P / Invoke </li><li>  Non-vector arrays (arrays with lower bound not equal to 0) </li><li>  The switch statement on the long type </li><li>  Opcode calli </li><li>  Exception filters </li></ul><br>  The last three points are planned to be implemented in the near future, at the expense of the others - these are long-term plans, if at all, they really will be implemented. <br><br><h2>  How it works </h2><br>  The compilation is divided into three major stages.  At the first stage, the compiler loads and converts all the types used to the internal representation.  The second is preparing for the third stage.  The third step converts the meta-information and compiles the code. <br><br>  Type conversion to internal representation occurs on the fly at the time of loading.  That is, a type is taken, converted to an internal representation, then added to the compilation list.  Then, all fields and methods are taken from the original type and are also converted into an internal representation.  Thus, all types are added to the compilation list, their fields and methods from those explicitly specified as input assemblies. <br><br>  But also, during the conversion of any type, field or method (hereinafter referred to as a member), it is also loaded, converted into an internal representation and added to the compilation list, all members on which the original member depends.  Only the really used members are added.  Thus, after the first stage in the compilation list there will be only those types that are in the original assemblies, plus those types and their members that are necessary.  Thanks to this, we get compiled source assemblies and the necessary pieces of the rest.  For example, take the code: <br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">TestConsole</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Hello world"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//    Java public static void main(string[] args) { Main(args); } } }</span></span></code> </pre> <br><br>  After the first stage, the compilation list will look like this: <br><pre> 0: type Foo.Program
     methods:
         Main
         main
 1: type System.Console
     methods:
         WriteLine
 2: type System.String
</pre><br><br>  Here it is also necessary to note the mechanism for replacing assemblies.  When a link to a type that is in an external assembly (not specified as an input) is detected, this assembly will be automatically loaded.  However, what if the loadable assembly has an implementation incompatible with Java?  For example, the standard mscorlib?  For this, you need a mechanism for replacing assemblies.  By default, at the moment, mscorlib is replaced by a special implementation that uses Java mechanisms to work.  You can also specify other assemblies, for substitution using the ‚Äìr compilation key.  Briefly, it works as follows: when Mono.Cecil begins to look for where to load the assembly, he addresses this issue to the AssemblyResolver, which was passed to him as a parameter when reading the original assembly.  The AssemblyResolver compiler first looks for an assembly with that name in the previously loaded ones, if it does not find it, then it looks to see whether it is in the lists for substitution.  If it is, it loads and returns the assembly specified in the list for substitution.  If it is not in the lists for substitution, then the standard assembly is loaded by standard means. <br><br>  Before the second compilation stage, a precompilation stage takes place, in which the compiler performs additional type processing to prepare them for direct compilation.  For example, it is at this stage that methods are added that are not explicitly invoked anywhere, but are overloaded with virtual methods of explicitly used methods. <br><br>  And actually the third stage is the most basic.  The transformation of meta-information process is fairly simple and straightforward.  The only thing I would like to note is that all types are declared as a result of public access due to incompatibility of the levels of visibility of Java and CIL.  Global types in Java can have either public access or access only from a package (namespace).  And nested types in Java, having for example a closed level of visibility, cannot be used at all outside of the type in which they are declared.  If any member of this type is addressed from an external class, an exception will be generated.  So all types automatically become open. <br><br>  But the compilation of code is a more complex and voluminous process, which is also divided into several stages.  The first step is to build a code graph.  This is the work of the ICSarpCode.Decompiler library from ILSpy.  In general, we get an almost ready to compile graph, but still some additional transformations are performed.  For example, the pseudo CompoundAssignment instructions that ICSharpCode.Decompiler generates are converted backwards.  Well, after that, the compilation into Java bytecode actually takes place. <br><br>  This is how the compiler itself works.  Now I will talk in more detail about some aspects of the work and how the support of certain things is realized. <br><br><h2>  Generics </h2><br>  From the point of view of JVM, generics do not exist.  Generics in Java is only an extension of the compiler and generic from the point of view of the JVM - this is a common object of type java.lang.Object.  CLI generics are compiled at runtime.  This means that when the compiler encounters a generic, it substitutes a real type instead of it and, in fact, creates a new type or method based on the original one.  CIL2Java acts in the same way, passing methods and types that have jerk parameters and creates them only when it encounters a link indicating which types to replace these parameters with. <br><br><h2>  Significant types </h2><br>  This is probably one of the main reasons why .NET / Mono is better than Java in disputes, which is better.  Yes, there is no support for such types in Java.  Therefore, all significant types are compiled as index.  But so that there would be no problems due to the difference in the behavior of the significant and indicative types, the behavior of the significant types is emulated.  First, a constructor without parameters is generated, and three internal methods are added: <br><ul><li>  c2j __ $ __ ZeroFill () - fills the contents of the type with zeros </li><li>  c2j __ $ __ CopyTo (ValueType) - copies the contents of the source type to the specified </li><li>  c2j __ $ __ GetCopy () - creates a new instance of the type, and copies into it the data from the source </li></ul><br><br>  Using these three methods, the behavior of significant types is fully emulated.  For example, the code ‚ÄúFoo (valType);‚Äù will be converted to ‚ÄúFoo (valType.c2j __ $ __ GetCopy ());‚Äù and a copy of valType will be passed to the Foo method. <br><br>  Also, for proper operation, all significant types are automatically initialized by the default constructor in constructors and at the very beginning of the methods (prologue). <br><br>  Thus, the main advantage of these types is that if used correctly, they increase the speed of the application, not only is lost, but on the contrary, their use will slow down the operation of the application. <br><br><h2>  Transfers </h2><br>  In .NET / Mono, enumerations are inherently significant types, but with additional restrictions.  They cannot have any methods, just one non-static field of a primitive type (int, short, etc.) having the name "value __" and static fields having the type of the enumeration itself. <br><br>  When compiling instead of an enumeration type, its base type is substituted.  That is, the method "void Foo (EnumType val);" after compilation will become "void Foo (int val);". <br><br><h2>  Packaging </h2><br>  The packaging of significant types is divided into three categories: packaging of primitive types, packaging of significant types and packaging of listings. <br><br>  The packaging of primitive types is implemented in two ways: packaging in CIL types or packaging in Java types.  In the first case, the standard for CIL types from the System namespace (System.Int32, System.Single, etc.) are used as types for packaging.  In the second, the standard types for Java (java.lang.Integer, java.lang.Float, etc.) <br><br>  In the case of packing into CIL types, we save information about unsigned types and the code like "uintType.ToString ()" will have the correct result.  However, when passing such parameters to Java, to methods where you need to pass a packaged primitive type (for example, java.lang.reflect.Method.invoke), the compiler will need to generate repackaging code (though there is no this function in the compiler), and thus performance drop. <br><br>  In the case of packing into Java types, all is accordingly vice versa.  The ‚ÄúuintType.ToString ()‚Äù code will give an incorrect result if the uintType value is greater than 2,147,483,647, but there will be no extra repacking from CIL to Java and back.  What method to use is up to you.  The compilation parameter box is responsible for this.  By default, packaging is done in CIL types. <br><br>  With packing of significant types everything is simpler.  We take a copy of the type and just pass it.  It is after the fact, after compilation, becomes a pointer type. <br><br>  But transfers are packaged in their real type.  That is, if there is an enum of the EnumType type, which has the basic int type, then, as mentioned above, when compiling, the int type will be substituted for EnumType.  But in the case of packaging, an object of the EnumType type will be created, and the value__ of this enumeration will be put in its value__ field.  Thus, type information will be saved. <br><br><h2>  Pointers </h2><br>  As already mentioned, the compiler does not support unsafe pointers.  But the transfer of the link works quite well.  If a value is passed to the method by reference, then the type of this parameter will be CIL2Java.VES.ByRef [type], where [type] is the type to which the link is being created (possible values: Byte, Short, Int, Long, Float, Double, Bool, Char, Ref).  Separate types for primitive types are necessary in order not to pack / unpack them with each call.  The type of the link itself is an abstract class with two abstract methods: get_Value and set_Value for getting and setting the value by reference, respectively.  This is how it looks like: <br><pre> <code class="hljs scala">public <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ByRef</span></span></span><span class="hljs-class">[type] </span></span>{ public <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> [<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">get_Value</span></span></span><span class="hljs-class">(</span><span class="hljs-params"></span><span class="hljs-class"><span class="hljs-params"></span>)</span></span>; public <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> void set_Value([<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">newValue</span></span></span><span class="hljs-class">)</span></span>; }</code> </pre><br><br>  When creating a reference to a value, an object is created that implements the corresponding abstract class.  And it implements depending on where the value is stored to which we create the link: <br><br>  LocalByRef [type] - a link to a local variable or method parameter.  It simply stores the value until it leaves the called place, after which the value of the variable or parameter is restored. <br>  Take this code: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> refValue</span></span></span><span class="hljs-function">)</span></span> { refValue = <span class="hljs-number"><span class="hljs-number">10</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localVar = <span class="hljs-number"><span class="hljs-number">0</span></span>; Foo(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> localVar); } <span class="hljs-comment"><span class="hljs-comment">//    Java public static void main(string[] args) { Main(args); } }</span></span></code> </pre><br><br>  After compilation, the code will look like this: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">LocalByRefInt</span></span> : <span class="hljs-title"><span class="hljs-title">ByRefInt</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LocalByRefInt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> initialValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = initialValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_Value</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_Value</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = newValue; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ByRefInt refValue</span></span></span><span class="hljs-function">)</span></span> { refValue.set_Value(<span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> localVar = <span class="hljs-number"><span class="hljs-number">0</span></span>; LocalByRefInt tmpByRef = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LocalByRefInt(localVar); Foo(tmpByRef); localVar = tmpByRef.get_Value(); } <span class="hljs-comment"><span class="hljs-comment">//    Java public static void main(string[] args) { Main(args); } }</span></span></code> </pre><br><br>  FieldByRef [type] - reference to the field of the object.  It is realized by the forces of reflection.  This is what this type looks like after compilation: <br><pre> <code class="hljs markdown">public class FieldByRef[<span class="hljs-string"><span class="hljs-string">type</span></span>] : ByRef[<span class="hljs-string"><span class="hljs-string">type</span></span>] { private object target; private java.lang.reflect.Field field; private [<span class="hljs-string"><span class="hljs-string">type</span></span>] value; public FieldByRefInt(object target, Field targetField) { this.target = target; this.field = targetField; paramField.setAccessible(true); this.value = targetField.get[<span class="hljs-string"><span class="hljs-string">type</span></span>](<span class="hljs-link"><span class="hljs-link">target</span></span>); } public [<span class="hljs-string"><span class="hljs-string">type</span></span>] get<span class="hljs-emphasis"><span class="hljs-emphasis">_Value() { return this.value; } public void set_</span></span>Value([<span class="hljs-string"><span class="hljs-string">type</span></span>] newValue) { this.field.set[<span class="hljs-string"><span class="hljs-string">type</span></span>](<span class="hljs-link"><span class="hljs-link">this.target, newValue</span></span>); this.value = newValue; } }</code> </pre><br><br>  ArrayByRef [type] - a link to an array element.  Everything is simple - we save the array itself (which is a pointer type) and the index in this array.  This is how it looks after compilation: <br><pre> <code class="hljs markdown">public class ArrayByRef[<span class="hljs-string"><span class="hljs-string">type</span></span>] : ByRef[<span class="hljs-string"><span class="hljs-string">type</span></span>] { private [<span class="hljs-string"><span class="hljs-string">type</span></span>][<span class="hljs-symbol"></span><span class="hljs-symbol"></span>] array; private int index; private int value; public ArrayByRefInt([<span class="hljs-string"><span class="hljs-string">type</span></span>][<span class="hljs-symbol"></span><span class="hljs-symbol"></span>] paramArray, int index) { this.array = paramArray; this.index = index; this.value = paramArray[index]; } public int get<span class="hljs-emphasis"><span class="hljs-emphasis">_Value() { return this.value; } public void set_</span></span>Value(int newValue) { this.array[this.index] = newValue; this.value = newValue; } }</code> </pre><br><br><h2>  Pointers to methods and delegates </h2><br>  This is what I miss most in Java.  One way to implement pointers to methods is reflection.  But I did not like this option because it requires the packaging of parameters, which reduces performance.  Thus the second method was used. <br><br>  In the following description, I will use this example: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">TestConsole</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deleg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> f</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(f); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Program p = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Program(); Deleg d = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Deleg(p.Foo); d(<span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-comment"><span class="hljs-comment">//    Java public static void main(string[] args) { Main(args); } } }</span></span></code> </pre><br><br>  The method is that if we meet the ldftn or ldvirtftn instruction, then the interface is first generated in the CIL2Java.VES.MethodPointers namespace with a name depending on the method signature and with a single invoke method that has almost the same signature as the method we we receive the pointer, having added the first parameter the link to object in which it is necessary to call a method.  In our example, this interface will look like this: <br><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">__void_int</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param)</span></span></span></span>; }</code> </pre><br><br>  Then, each ldftn or ldvirtftn instruction generates a nested type that implements the pointer interface to the method.  The invoke method simply calls the method to which the instruction receives the pointer.  In the example above, it looks like this: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C2J_anon_0</span></span></span><span class="hljs-class"> :</span></span> __void_int { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> paramInt)</span></span></span><span class="hljs-function"> </span></span>{ ((Program)target).Foo(paramInt); } }</code> </pre><br><br>  And already in the delegate constructor, as a pointer to a method, an instance of this class is passed. <br><br>  The delegate itself after compilation takes the following form: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Deleg</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MulticastDelegate { public Deleg</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> target, __void_int method_pointer) : <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(paramObject, method_pointer) { } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> void Invoke(int paramInt) { ((__void_int)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method).invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target, paramInt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.next != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ((Deleg)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.next).Invoke(paramInt); } }</code> </pre><br><br>  This is the default behavior of the compiler.  As you can see, the delegate constructor signature has been changed - the last parameter has the interface type of the method pointer, not the native int as necessary by the standard.  This is done again for optimization.  However, you can tell the compiler that it is necessary to compile the pointers to the method according to the standard using the "-method_pointers standart" parameter.  In this case, the creation of the delegate in our example takes the form: <br><pre> <code class="hljs lisp">Deleg d = new Deleg(<span class="hljs-name"><span class="hljs-name">p</span></span>, Global.AddMethodPointer(<span class="hljs-string"><span class="hljs-string">"TestConsole.Program$C2J_anon_0"</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  And the delegate himself becomes like this: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Deleg</span></span> : <span class="hljs-title"><span class="hljs-title">MulticastDelegate</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Deleg</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> target, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> paramInt</span></span></span><span class="hljs-function">) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target, Integer.valueOf(paramInt</span></span></span><span class="hljs-function">))</span></span>; { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sealed</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> paramInt</span></span></span><span class="hljs-function">)</span></span> { ((__void_int)Global.GetMethodPointer(((Integer)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.method).intValue())).invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target, paramInt); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.next != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ((Deleg)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.next).Invoke(paramInt); } }</code> </pre><br><br>  As you can see, in this case, the pointer to the method is of type int, but in reality, this is just an index in the global list of pointers to methods.  In this way, we comply with the standard, but lose in performance. <br><br><h2>  yield return / break </h2><br>  Here, to be honest there is nothing to tell.  It just works. <br><br><h2>  Async / await </h2><br>  Here, too, especially nothing to tell.  Code using async / await compiles, but does not work.  It does not work because there is no implementation of the types required for operation (System.Threading.Tasks.Task, System.Runtime.CompilerServices.AsyncTaskMethodBuilder and so on) <br><br><h2>  Unsigned numbers </h2><br>  Support for unsigned numbers in the compiler is available, but is included separately with the "-unsigned" parameter.  The article <a href="http://habrahabr.ru/post/225901/">http://habrahabr.ru/post/225901/</a> for the authorship of <a href="http://habrahabr.ru/users/elw00d/" class="user_link">elw00d</a> really helped with the <a href="http://habrahabr.ru/users/elw00d/" class="user_link">implementation</a> .  In general, in this article, everything is described and all operations with unsigned numbers were made for this article. <br><br><h2>  Exceptions </h2><br>  In general, exceptions in Java and in CIL are very similar.  So far, exception filters are not supported (ICSharpCode.Decompiler does not support them). <br><br>  Additionally, a mechanism for tying Java and CIL exception types has been added.  For example, in CIL there is an exception System.ArithmeticException.  Java has its own java.lang.ArithmeticException type.  How to make so that intercepting System. ArithmeticException intercepted as well java.lang. ArithmeticException?  For this, a JavaExceptionMapAttribute attribute was introduced which indicates to the compiler a similar exception in Java.  And when the compiler encounters a System.ArithmeticException intercept, it also adds interception and similar Java exceptions.  The only condition that is added is that an additional constructor must be entered into System.ArithmeticException, which takes only one parameter of type java.lang.ArithmeticException so that an instance of the exception of one type is passed to the interceptor. <br><br><h2>  Debugging </h2><br>  The compiler supports the generation of debugging information (if it is in the original builds) by specifying the compile key "-debug".  Here is an example of how a test application is debugged in Eclipse: <br><img src="https://habrastorage.org/files/cae/91f/5ce/cae91f5ceec741b99aa3acf313efb449.png"><br><br><h2>  Type substitution </h2><br>  This mechanism was created so that the types that are similar in Java could be turned into these analogs when compiled.  An example of this type is System.String.  In the mscorlib implementation, this type is marked with the TypeMapAttribute attribute, and when compiled it becomes java.lang.String.  The substitution of individual methods is also possible.  To do this, they must be marked with the attribute MethodMapAttribute. <br><br><h2>  Conclusion </h2><br>  Here in general, that's all.  This is only the alpha version of the project, and so far the stability of work leaves much to be desired.  So the further vector of work is the improvement of work stability and the implementation of the standard library.  Thank you for reading to the end. </div><p>Source: <a href="https://habr.com/ru/post/245449/">https://habr.com/ru/post/245449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245439/index.html">How to come up with ideas</a></li>
<li><a href="../245441/index.html">MindStream. How do we write software under FireMonkey. Part 4 Serialization</a></li>
<li><a href="../245443/index.html">Petooh programming language</a></li>
<li><a href="../245445/index.html">A vulnerability has been discovered in the anti-counterfeiting system.</a></li>
<li><a href="../245447/index.html">The simpler the better, or when ELB is not needed</a></li>
<li><a href="../245451/index.html">20 million pesos and half a year in Chile: how SmartProgress won a grant at the other end of the world</a></li>
<li><a href="../245453/index.html">Roslyn to automatically translate C # code into 1C code</a></li>
<li><a href="../245455/index.html">Problem, solution and stability check in statics</a></li>
<li><a href="../245459/index.html">Analog video input for Virturilki and its use in the national economy</a></li>
<li><a href="../245461/index.html">When running World of Tanks game replays, arbitrary code can be executed on your computer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>