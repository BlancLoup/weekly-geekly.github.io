<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast logging</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I put the benchmarks of the most private calls to the loggers. I conducted all experiments on log4net and NLog, on Windows 10 x64 Int...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast logging</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article, I put the benchmarks of the most private calls to the loggers.  I conducted all experiments on log4net and NLog, on Windows 10 x64 Intel with M.2 SSD. </p><br><p>  To not read for a long time, the results table is immediately on top. </p><br><p>  Raw results can be viewed on <a href="https://github.com/imanushin/nlog-log4net-performance-comparison/tree/master/Performance.Comparison/Results/2">github</a> .  In the same repository code (to run, you need .Net 4.7.2 + Microsoft Visual Studio 2017+). </p><br><p>  What, how and why - under the cut. </p><a name="habracut"></a><br><div class="scrollable-table"><table><thead><tr><th>  Method </th><th>  Mean </th><th>  Error </th><th>  Stddev </th><th>  Median </th><th>  Ratio </th><th>  Rank </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1,835.730 ns </td><td>  55.3980 ns </td><td>  163.3422 ns </td><td>  1,791.901 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = true </td><td>  1,910.814 ns </td><td>  37.9116 ns </td><td>  90.1008 ns </td><td>  1,908.513 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = true </td><td>  1,765.390 ns </td><td>  34.5893 ns </td><td>  33.9713 ns </td><td>  1,764.598 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = true </td><td>  1,834.002 ns </td><td>  36.2599 ns </td><td>  56.4523 ns </td><td>  1,838.500 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = false </td><td>  5,387.220 ns </td><td>  77.9523 ns </td><td>  69.1027 ns </td><td>  5,376.298 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = false </td><td>  11,171.048 ns </td><td>  58.5253 ns </td><td>  54.7446 ns </td><td>  11,186.697 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = false </td><td>  652,512.923 ns </td><td>  8,856.6000 ns </td><td>  8,284.4691 ns </td><td>  650,545.605 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = false </td><td>  642,003.054 ns </td><td>  12,750.3183 ns </td><td>  31,515.6277 ns </td><td>  645,749.609 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  CreateLog4NetFromString </td><td>  1,271.456 ns </td><td>  3.9287 ns </td><td>  3.4827 ns </td><td>  1,271.722 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  CreateNLogFromString </td><td>  199.004 ns </td><td>  0.3101 ns </td><td>  0.2901 ns </td><td>  199.046 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  CreateLog4NetLogger </td><td>  18,564.228 ns </td><td>  44.6344 ns </td><td>  41.7510 ns </td><td>  18,564.598 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td>  140,220.404 ns </td><td>  188.8802 ns </td><td>  176.6787 ns </td><td>  140,235.303 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  115,329.549 ns </td><td>  243.0537 ns </td><td>  227.3526 ns </td><td>  115,361.597 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  7,076.251 ns </td><td>  41.5518 ns </td><td>  38.8676 ns </td><td>  7,075,394 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  7,464.427 ns </td><td>  36.0445 ns </td><td>  33.7161 ns </td><td>  7,470.789 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  7,684.635 ns </td><td>  49.2505 ns </td><td>  46.0690 ns </td><td>  7,693.219 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  8,207.387 ns </td><td>  79.5855 ns </td><td>  74.4443 ns </td><td>  8,220.897 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  8,477.657 ns </td><td>  63.4105 ns </td><td>  59.3143 ns </td><td>  8,472.385 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  5,438.306 ns </td><td>  42.0170 ns </td><td>  37.2470 ns </td><td>  5,427.805 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  5,734.572 ns </td><td>  46.0770 ns </td><td>  40.8461 ns </td><td>  5,729.974 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  5,834.548 ns </td><td>  40.4125 ns </td><td>  35.8246 ns </td><td>  5,838.905 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  6,445.663 ns </td><td>  57.5870 ns </td><td>  53.8669 ns </td><td>  6,440.509 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  6,784.489 ns </td><td>  43.9255 ns </td><td>  38.9388 ns </td><td>  6,782.898 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  11.063 ns </td><td>  0.0141 ns </td><td>  0.0125 ns </td><td>  11.065 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  9.206 ns </td><td>  0.0321 ns </td><td>  0.0300 ns </td><td>  9.203 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  11.423 ns </td><td>  0.0147 ns </td><td>  0.0131 ns </td><td>  11.421 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  44.472 ns </td><td>  0.0474 ns </td><td>  0.0396 ns </td><td>  44.475 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  58.138 ns </td><td>  0.1598 ns </td><td>  0.1416 ns </td><td>  58.139 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  1.045 ns </td><td>  0.0037 ns </td><td>  0.0033 ns </td><td>  1.045 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  1.994 ns </td><td>  0.0033 ns </td><td>  0.0028 ns </td><td>  1.994 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2.025 ns </td><td>  0.0044 ns </td><td>  0.0042 ns </td><td>  2.024 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  34.800 ns </td><td>  0.0374 ns </td><td>  0.0312 ns </td><td>  34.798 ns </td><td>  1.00 </td><td>  one </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  47.509 ns </td><td>  0.1199 ns </td><td>  0.1063 ns </td><td>  47.511 ns </td><td>  1.00 </td><td>  one </td></tr></tbody></table></div><br><h1 id="nooplogging">  NoOpLogging </h1><br><p>  First, we estimate how much time we spend on calling the logging method, which ultimately leads to nothing.  In most cases (in my experience) the verbose Debug is disabled on the combat servers, but no one removes calls. </p><br><p>  First result: </p><br><div class="scrollable-table"><table><thead><tr><th>  Method </th><th>  Mean </th><th>  Error </th><th>  Stddev </th><th>  Median </th></tr></thead><tbody><tr><td>  NoOpLog4NetNoParams </td><td>  11.063 ns </td><td>  0.0141 ns </td><td>  0.0125 ns </td><td>  11.065 ns </td></tr><tr><td>  NoOpLog4NetSingleReferenceParam </td><td>  9.206 ns </td><td>  0.0321 ns </td><td>  0.0300 ns </td><td>  9.203 ns </td></tr><tr><td>  NoOpLog4NetSingleValueParam </td><td>  11.423 ns </td><td>  0.0147 ns </td><td>  0.0131 ns </td><td>  11.421 ns </td></tr><tr><td>  NoOpLog4NetMultipleReferencesParam </td><td>  44.472 ns </td><td>  0.0474 ns </td><td>  0.0396 ns </td><td>  44.475 ns </td></tr><tr><td>  NoOpLog4NetMultipleValuesParam </td><td>  58.138 ns </td><td>  0.1598 ns </td><td>  0.1416 ns </td><td>  58.139 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  1.045 ns </td><td>  0.0037 ns </td><td>  0.0033 ns </td><td>  1.045 ns </td></tr><tr><td>  NoOpNLogNetSingleReferenceParam </td><td>  1.994 ns </td><td>  0.0033 ns </td><td>  0.0028 ns </td><td>  1.994 ns </td></tr><tr><td>  NoOpNLogNetSingleValueParam </td><td>  2.025 ns </td><td>  0.0044 ns </td><td>  0.0042 ns </td><td>  2.024 ns </td></tr><tr><td>  NoOpNLogNetMultipleReferencesParam </td><td>  34.800 ns </td><td>  0.0374 ns </td><td>  0.0312 ns </td><td>  34.798 ns </td></tr><tr><td>  NoOpNLogNetMultipleValuesParam </td><td>  47.509 ns </td><td>  0.1199 ns </td><td>  0.1063 ns </td><td>  47.511 ns </td></tr></tbody></table></div><br><p>  And the code: </p><br><pre><code class="plaintext hljs">void Log4NetNoParams() =&gt; _log4Net.Debug("test"); void Log4NetSingleReferenceParam() =&gt; _log4Net.DebugFormat("test {0}", _stringArgument); void Log4NetSingleValueParam() =&gt; _log4Net.DebugFormat("test {0}", _intArgument); void Log4NetMultipleReferencesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void Log4NetMultipleValuesParam() =&gt; _log4Net.DebugFormat( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument); void NLogNetNoParams() =&gt; _nlog.Debug("test"); void NLogNetSingleReferenceParam() =&gt; _nlog.Debug("test {0}", _stringArgument); void NLogNetSingleValueParam() =&gt; _nlog.Debug("test {0}", _intArgument); void NLogNetMultipleReferencesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument, _stringArgument); void NLogNetMultipleValuesParam() =&gt; _nlog.Debug( "test {0} {1} {2} {3} {4} {5} {6} {7} {8}", _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument, _intArgument);</code> </pre> <br><p>  First, let's decide why these tests were chosen: </p><br><ul><li>  Experiments were performed on the most popular libraries. </li><li><p>  NLog and log4net have different function signatures for a small number of arguments: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">void DebugFormat(string format, object arg0)</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">void Debug(string message, string argument) void Debug&lt;TArgument&gt;(string message, TArgument argument)</code> </pre> <br><ul><li>  Theory: when transferring a meaningful type to log4net, boxing should occur, which simply spends processor time and leads to nothing.  In the case of NLog - this behavior is absent, because the latter should work faster. </li></ul><br></li><li>  The signatures for a large number of arguments in libraries are about the same, so I would like to know: <br><ul><li>  How much more effective to call methods with a small number of parameters. </li><li>  Is there a difference in the speed of calling the "Is ... Enabled" method between the two libraries? </li></ul></li></ul><br><p>  And now the analysis of the results: </p><br><ul><li>  Due to the use of generic arguments in NLog, it works faster for the case when direct logging is not needed.  That is, for the case when in your Debug program the level is enabled only on the test system, simply changing the library can speed up the work of the software (and improve the lives of users). </li><li>  If you have logging turned off, and you want to call a method with a large number of arguments, it is more efficient to split it into two.  Due to this, calls to the methods above will work ten times faster. </li><li>  When you write a function that can take any object, it is often most effective to get confused and make a generic function.  Due to such a simple optimization, the code will work faster (this is clearly seen on the time difference of calls to <code>Log4NetSingleReferenceParam</code> and <code>Log4NetSingleValueParam</code> ) </li></ul><br><h1 id="filelogging">  Filelogging </h1><br><p>  Most programs (according to my observations) still log the results to a file, so for comparison we will select this operation.  For simplicity, let's just take logger configurations when writing to a file without buffering, without additional locks, etc. </p><br><p>  Results: </p><br><div class="scrollable-table"><table><thead><tr><th>  Method </th><th>  Mean </th><th>  Error </th><th>  Stddev </th><th>  Median </th></tr></thead><tbody><tr><td>  FileLoggingLog4NetNoParams </td><td>  7,076.251 ns </td><td>  41.5518 ns </td><td>  38.8676 ns </td><td>  7,075,394 ns </td></tr><tr><td>  FileLoggingLog4NetSingleReferenceParam </td><td>  7,464.427 ns </td><td>  36.0445 ns </td><td>  33.7161 ns </td><td>  7,470.789 ns </td></tr><tr><td>  FileLoggingLog4NetSingleValueParam </td><td>  7,684.635 ns </td><td>  49.2505 ns </td><td>  46.0690 ns </td><td>  7,693.219 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleReferencesParam </td><td>  8,207.387 ns </td><td>  79.5855 ns </td><td>  74.4443 ns </td><td>  8,220.897 ns </td></tr><tr><td>  FileLoggingLog4NetMultipleValuesParam </td><td>  8,477.657 ns </td><td>  63.4105 ns </td><td>  59.3143 ns </td><td>  8,472.385 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  5,438.306 ns </td><td>  42.0170 ns </td><td>  37.2470 ns </td><td>  5,427.805 ns </td></tr><tr><td>  FileLoggingNLogNetSingleReferenceParam </td><td>  5,734.572 ns </td><td>  46.0770 ns </td><td>  40.8461 ns </td><td>  5,729.974 ns </td></tr><tr><td>  FileLoggingNLogNetSingleValueParam </td><td>  5,834.548 ns </td><td>  40.4125 ns </td><td>  35.8246 ns </td><td>  5,838.905 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleReferencesParam </td><td>  6,445.663 ns </td><td>  57.5870 ns </td><td>  53.8669 ns </td><td>  6,440.509 ns </td></tr><tr><td>  FileLoggingNLogNetMultipleValuesParam </td><td>  6,784.489 ns </td><td>  43.9255 ns </td><td>  38.9388 ns </td><td>  6,782.898 ns </td></tr></tbody></table></div><br><p>  Code used: </p><br><ul><li>  log4net: </li></ul><br><pre> <code class="plaintext hljs">var roller = new RollingFileAppender(); roller.ImmediateFlush = true; roller.RollingStyle = RollingFileAppender.RollingMode.Once; roller.MaxFileSize = 128 * 1000 * 1000;</code> </pre> <br><ul><li>  Nlog: </li></ul><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = false, KeepFileOpen = false };</code> </pre><br><p>  As you can see, the configuration of the loggers is more or less similar, but according to the results: </p><br><ul><li>  NLog is slightly faster than log4net, about 15%. </li><li>  According to the tests, it turned out that it is more efficient to log a smaller number of parameters.  However, we must not forget that with a larger number of parameters, the resulting string also expanded.  Therefore, in the table it is only correct to compare NLog versus log4net. </li></ul><br><h1 id="nlog---raznye-sposoby-blokirovok">  NLog - different locking methods </h1><br><div class="scrollable-table"><table><thead><tr><th>  Method </th><th>  Mean </th><th>  Error </th><th>  Stddev </th><th>  Median </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = false </td><td>  5,387.220 ns </td><td>  77.9523 ns </td><td>  69.1027 ns </td><td>  5,376.298 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = false </td><td>  11,171.048 ns </td><td>  58.5253 ns </td><td>  54.7446 ns </td><td>  11,186.697 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = false </td><td>  652,512.923 ns </td><td>  8,856.6000 ns </td><td>  8,284.4691 ns </td><td>  650,545.605 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = false </td><td>  642,003.054 ns </td><td>  12,750.3183 ns </td><td>  31,515.6277 ns </td><td>  645,749.609 ns </td></tr></tbody></table></div><br><p>  Source: </p><br><pre> <code class="plaintext hljs">new FileTarget($"target_{_logIndex++}") { ArchiveAboveSize = 128 * 1000 * 1000, MaxArchiveFiles = 16, AutoFlush = true, ConcurrentWrites = XXXXX, KeepFileOpen = YYYYY };</code> </pre><br><p>  If in place of XXXXX and YYYYY to put all possible combinations, we get a test from the table. </p><br><p>  The results are pretty predictable: </p><br><ul><li>  If you allow ConcurrentWrites, the system will constantly start to take and give to Mutex, which is not free.  But, as we see, writing one line to a file is approximately equivalent to one system lock. </li><li>  Closing and opening a file, as we see, affects the system performance even more.  In the examples with <code>KeepFileOpen=true</code> , we created a file for each logging operation (along with Handle), made a record on the disk, called Flush, gave it to Handle, and also made a lot of engine operations.  As a result, the speed drops hundreds of times. </li></ul><br><h1 id="asinhronnoe-loggirovanie-i-raznye-sposoby-blokirovok">  Asynchronous logging and various locking methods </h1><br><p>  The NLog library is also able to perform all IO operations on another thread, immediately freeing the current one.  Moreover, it does this competently, preserving the order of events, dropping all the data in blocks, and in each block an integer number of events (so as not to get truncated strings), and so on. </p><br><p>  The results of different ways of non-blocking work: </p><br><div class="scrollable-table"><table><thead><tr><th>  Method </th><th>  Mean </th><th>  Error </th><th>  Stddev </th><th>  Median </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1,835.730 ns </td><td>  55.3980 ns </td><td>  163.3422 ns </td><td>  1,791.901 ns </td></tr><tr><td>  KeepFileOpen = true, ConcurrentWrites = true, Async = true </td><td>  1,910.814 ns </td><td>  37.9116 ns </td><td>  90.1008 ns </td><td>  1,908.513 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = false, Async = true </td><td>  1,765.390 ns </td><td>  34.5893 ns </td><td>  33.9713 ns </td><td>  1,764.598 ns </td></tr><tr><td>  KeepFileOpen = false, ConcurrentWrites = true, Async = true </td><td>  1,834.002 ns </td><td>  36.2599 ns </td><td>  56.4523 ns </td><td>  1,838.500 ns </td></tr></tbody></table></div><br><p>  Comparison of blocking and asynchronous approaches will be further, and here - only the latter. </p><br><p>  <code>AsyncTargetWrapper</code> code: </p><br><pre> <code class="plaintext hljs">new AsyncTargetWrapper(fileTargetWithConcurrentWritesAndCloseFileAsync) { OverflowAction = AsyncTargetWrapperOverflowAction.Block, BatchSize = 4096, FullBatchSizeWriteLimit = 128 }</code> </pre> <br><p>  As you can see, the settings of the wrapper are such that a direct reset to the file does not take a long time.  Thus, a large buffer is accumulated, which means all resource-intensive operations like ‚Äúopen file‚Äù are performed once for the whole block.  However, this algorithm requires additional memory (and quite a lot). </p><br><p>  Findings: </p><br><ul><li>  If asynchronous output is used, then it doesn‚Äôt matter what file options are used.  You can open and close a file each time, with a large buffer it will be almost imperceptible. </li><li>  All measurements are true only for the case when the data is flushed to disk at about the same speed as the buffer filling (I did this at the expense of a fast file system + natural pauses between measurements). </li></ul><br><h1 id="sinhronnoe-i-asinhronnoe-loggirovanie">  Synchronous and asynchronous logging </h1><br><div class="scrollable-table"><table><thead><tr><th>  Results: </th><th>  Method </th><th>  Mean </th><th>  Error </th><th>  Stddev </th><th>  Median </th></tr></thead><tbody><tr><td>  KeepFileOpen = true, ConcurrentWrites = false, Async = true </td><td>  1,835.730 ns </td><td>  55.3980 ns </td><td>  163.3422 ns </td><td>  1,791.901 ns </td></tr><tr><td>  FileLoggingLog4NetNoParams </td><td>  7,076.251 ns </td><td>  41.5518 ns </td><td>  38.8676 ns </td><td>  7,075,394 ns </td></tr><tr><td>  FileLoggingNLogNetNoParams </td><td>  5,438.306 ns </td><td>  42.0170 ns </td><td>  37.2470 ns </td><td>  5,427.805 ns </td></tr><tr><td>  NoOpLog4NetNoParams </td><td>  11.063 ns </td><td>  0.0141 ns </td><td>  0.0125 ns </td><td>  11.065 ns </td></tr><tr><td>  NoOpNLogNetNoParams </td><td>  1.045 ns </td><td>  0.0037 ns </td><td>  0.0033 ns </td><td>  1.045 ns </td></tr></tbody></table></div><br><p>  Findings: </p><br><ul><li>  Despite the fast disk (in my case - M.2 SSD), writing to a file in another thread speeds up the work several times.  If your application writes to HDD drives, and even running on a virtual machine, the gain will be even greater. </li><li>  However, despite the even fast operation of the asynchronous code, the lack of logging gives an even greater gain (albeit a bit different, depending on the library). </li></ul><br><h1 id="sozdanie-loggerov">  Creating loggers </h1><br><div class="scrollable-table"><table><thead><tr><th>  Results: </th><th>  Method </th><th>  Mean </th><th>  Error </th><th>  Stddev </th><th>  Median </th></tr></thead><tbody><tr><td>  CreateLog4NetFromString </td><td>  1,271.456 ns </td><td>  3.9287 ns </td><td>  3.4827 ns </td><td>  1,271.722 ns </td></tr><tr><td>  CreateNLogFromString </td><td>  199.004 ns </td><td>  0.3101 ns </td><td>  0.2901 ns </td><td>  199.046 ns </td></tr><tr><td>  CreateLog4NetLogger </td><td>  18,564.228 ns </td><td>  44.6344 ns </td><td>  41.7510 ns </td><td>  18,564.598 ns </td></tr><tr><td>  CreateNLogTypeOfLogger </td><td>  140,220.404 ns </td><td>  188.8802 ns </td><td>  176.6787 ns </td><td>  140,235.303 ns </td></tr><tr><td>  CreateNLogDynamicLogger </td><td>  115,329.549 ns </td><td>  243.0537 ns </td><td>  227.3526 ns </td><td>  115,361.597 ns </td></tr></tbody></table></div><br><p>  What tested: </p><br><pre> <code class="plaintext hljs">[Benchmark] public object CreateLog4NetFromString() { return LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _log4NetStringLogIndex) % 1000)); } [Benchmark] public object CreateNLogFromString() { return NLog.LogManager.GetLogger("my-logger_" + (Interlocked.Increment(ref _nLogStringLogIndex) % 1000)); } [Benchmark] public object CreateLog4NetLogger() { return new [] { LogManager.GetLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogTypeOfLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(typeof(BaseTest)), // x16 times }; } [Benchmark] public object CreateNLogDynamicLogger() { return new[] { NLog.LogManager.GetCurrentClassLogger(), // x16 times }; }</code> </pre> <br><p>  An important remark: unfortunately, it was difficult for me to make a reproducible benchmark that does not lead to Out Of Memory, but that would create different loggers (i.e., for different types, for different lines, and so on). </p><br><p>  However, having studied the work of the libraries, I found that perhaps the most ponderous operations are performed to create the logger key (i.e., name definition, clearing of Generic arguments, and so on). <br>  Moreover, in order to stabilize the benchmark for creating a logger for log4net, I had to perform not one operation, but 16 (that is, an array of 16 identical objects is returned).  If you do not return anything, then .Net for me optimized execution (apparently, just not returning the result), which led to incorrect results. </p><br><p>  And the conclusions: </p><br><ul><li>  Loggers are created from strings most quickly (NLog is again faster, but the difference between libraries is small, considering that loggers are created not just for that, but for subsequent work with them). </li><li>  log4net is faster than NLog when initializing a project.  Perhaps it‚Äôs about additional caching on the NLog side, which helps to speed up calls to <code>Debug</code> , <code>Info</code> , etc. directly.  In fact, each <code>ILogger</code> knows the answer for itself: whether the following methods should be called or not (and this requires at least some sort of binding to the general configuration).  Because of this scheme of work, I went out of memory on most tests (if you use different lines, etc.). </li><li>  <code>LogManager.GetCurrentClassLogger()</code> is even slower than <code>LogManager.GetLogget(typeof(XXX))</code> .  This is logical, even NLog developers do not recommend calling the first method in a loop. </li><li>  And most importantly: the speed of all these methods often affects only the cold start of the application, when fields of the form <code>private static readonly ILogger Log = LogManager.GetCurrentClassLogger()</code> .  That is, it does not affect the performance of the system itself. </li></ul><br><h1 id="vyvod">  Conclusion </h1><br><p>  How best to handle logs: </p><br><ul><li>  If it is possible not to log at all, this will be the fastest (which is obvious so far). </li><li>  If there are many logger calls in the project that do not reset the data to a file (to the console, etc.), then NLog is faster.  In addition, it allocates fewer objects in the heap. </li><li>  If you still need to write to the file, then NLog works as fast as possible in asynchronous mode.  Yes, he eats more memory (compared to NLog in the synchronous mode, as according to my previous measurements, log4net does not even try to reuse arrays and <code>Stream</code> 's).  However, the program can work faster. </li><li>  Creating a logger is not a free operation, so it is often better to create it with a static field.  This does not apply to the creation of a string, that is, something like <code>LogManager.GetLogger("123")</code> .  Such calls work faster, which means that the logger can be created for large instances of objects (for example, "one logger for the context of the query execution"). </li><li>  If you want to output a lot of parameters to the log, however, in most cases, there will not be a direct reset of the data to the file, then it is best to make several calls.  Thus, NLog will not create additional objects on the heap if they are not needed there. </li></ul><br><p>  Conclusions for your code: </p><br><ul><li>  If your method accepts an arbitrary object (ie, <code>object</code> ) and in most cases does nothing (which is true for contracts / validators), then it is more correct to wrap the calls in a generic form (that is, to make methods of the form <code>Something&lt;TArg&gt;(TArg arg)</code> ).  This will really work faster. </li><li>  If in your code we allow a data reset of the file and work with something else in parallel, it is better to be confused and support this.  Yes, it seems obvious that parallel execution can speed up work, however, in the case of IO operations, this approach also gives an additional performance boost on machines with slow disks. </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/456488/">https://habr.com/ru/post/456488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456470/index.html">Pitfalls WSUS Package Publisher</a></li>
<li><a href="../456472/index.html">Introduction to Go and Mggo Framework</a></li>
<li><a href="../456474/index.html">Comparison: Svelte and React</a></li>
<li><a href="../45648/index.html">Rails. Rating system. Plugins</a></li>
<li><a href="../456482/index.html">Catch Me If You Can. King Version</a></li>
<li><a href="../456490/index.html">Lectures on the brain, part 1. The evolution of the human brain. The functions of the brain at each stage of its development</a></li>
<li><a href="../456492/index.html">Troll Army</a></li>
<li><a href="../456494/index.html">In the States, GOSTs are also so-so. Fatal vulnerability in YubiKey FIPS</a></li>
<li><a href="../456498/index.html">Device Manager. Extend IIA to devices</a></li>
<li><a href="../4565/index.html">"Expert" will accelerate your site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>