<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Classes and factory functions in javascript. What to choose?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are various ways to create objects in JavaScript. In particular, we are talking about constructions using the class keyword and the so-called fa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Classes and factory functions in javascript. What to choose?</h1><div class="post__text post__text-html js-mediator-article"> There are various ways to create objects in JavaScript.  In particular, we are talking about constructions using the <code>class</code> keyword and the so-called factory functions (Factory Function).  The author of the material, the translation of which we publish today, explores and compares these two concepts in search of an answer to the question of the pros and cons of each of them. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/352198/"><img src="https://habrastorage.org/getpro/habr/post_images/a05/549/c0d/a05549c0d53af4258490b83f1558852b.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Overview</font> </h2><br>  The <code>class</code> keyword appeared in ECMAScript 2015 (ES6), with the result that we now have two competing object creation patterns.  In order to compare them, I will describe the same object ( <code>TodoModel</code> ), using the syntax of the classes, and applying the factory function. <br><br>  Here‚Äôs the <code>TodoModel</code> <a href="https://jsfiddle.net/cristi_salcescu/m9dhpzfx/">description</a> using the <code>class</code> keyword: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoModel</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todos = [];       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.lastChange = <span class="hljs-literal"><span class="hljs-literal">null</span></span>;   }     addToPrivateList(){      <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"addToPrivateList"</span></span>);   }   add() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"add"</span></span>); }   reload(){} }</code> </pre> <br>  Here is a <a href="https://jsfiddle.net/cristi_salcescu/bcta6yyv/">description of</a> the same object made by means of a factory function: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoModel(){   var todos = [];   var lastChange = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;         <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> addToPrivateList(){       console.log("addToPrivateList");   }   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>() { console.log("add"); }   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reload(){}     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({       <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>,       reload   }); }</code> </pre> <br>  Consider the features of these two approaches to the creation of classes. <br><br><h2>  <font color="#3AC1EF">Encapsulation</font> </h2><br>  The first feature that can be noticed when comparing classes and factory functions is that all members, fields, and methods of objects created using the <code>class</code> keyword are publicly available. <br><br><pre> <code class="hljs pgsql">var todoModel = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> TodoModel(); console.log(todoModel.todos);     //[] console.log(todoModel.lastChange) //<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> todoModel.addToPrivateList();     //addToPrivateList</code> </pre> <br>  When using factory functions, only that which we consciously discover is generally available, everything else is hidden inside the received object. <br><br><pre> <code class="hljs coffeescript">var todoModel = TodoModel(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(todoModel.todos);     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">undefined</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(todoModel.lastChange) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-literal"><span class="hljs-literal">undefined</span></span> todoModel.addToPrivateList();     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>taskModel.addToPrivateList                                   <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> a function</code> </pre> <br><h2>  <font color="#3AC1EF">API Immunity</font> </h2><br>  After the object is created, I expect that its API will not change, that is, I expect immobility from it.  However, we can easily change the implementation of the public methods of objects created with the <code>class</code> keyword. <br><br><pre> <code class="hljs javascript">todoModel.reload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"a new reload"</span></span>); } todoModel.reload();            <span class="hljs-comment"><span class="hljs-comment">//a new reload</span></span></code> </pre> <br>  This problem can be <a href="https://jsfiddle.net/cristi_salcescu/y0k18og2/">solved</a> by calling <code>Object.freeze(TodoModel.prototype)</code> after declaring a class, or using the decorator to ‚Äúfreeze‚Äù classes when it is supported. <br><br>  On the other hand, the API of an object created using a factory function is immutable.  Note the use of the <code>Object.freeze()</code> command to process the returned object, which contains only the public methods of the new object.  Private data of this object can be modified, but this can be done only through these public methods. <br><br><pre> <code class="hljs javascript">todoModel.reload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"a new reload"</span></span>); } todoModel.reload();            <span class="hljs-comment"><span class="hljs-comment">//reload</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Keyword this</font> </h2><br>  Objects created using the <code>class</code> keyword are subject to the long-term problem of losing context <code>this</code> .  For example, <code>this</code> loses context in nested functions.  This not only complicates the programming process, such behavior is also a constant source of errors. <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoModel</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todos = [];   }     reload(){       setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{          <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.todos);    <span class="hljs-comment"><span class="hljs-comment">//undefined       }, 0);   } } todoModel.reload();                   //undefined</span></span></code> </pre> <br>  And this is how <code>this</code> loses context when using the corresponding method in a DOM event: <br><br><pre> <code class="hljs mel">$(<span class="hljs-string"><span class="hljs-string">"#btn"</span></span>).click(todoModel.reload);    <span class="hljs-comment"><span class="hljs-comment">//undefined</span></span></code> </pre> <br>  Objects created using factory functions do not suffer from this problem, since the keyword <code>this</code> not used here. <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TodoModel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">var</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">todos</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function">;         </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">{       </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setTimeout</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(function log()</span></span></span><span class="hljs-function"> {          </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">console</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(todos)</span></span></span><span class="hljs-function">;        //</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function">      }, 0);   } } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">todoModel</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">;                   //</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function"> $</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">("#btn")</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(todoModel.reload)</span></span></span><span class="hljs-function">;    //</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Keyword this and arrow functions</font> </h2><br>  The switch functions partially solve the problems associated with the loss of <code>this</code> context when using classes, but at the same time they create a new problem.  Namely, when using arrow functions in classes, the keyword <code>this</code> no longer loses context in nested functions.  However, <code>this</code> loses context when dealing with DOM events. <br><br>  I <a href="https://jsfiddle.net/cristi_salcescu/y0k18og2/">reworked</a> the <code>TodoModel</code> class using pointer functions.  It is worth noting that in the process of refactoring, when replacing ordinary functions with pointer ones, we lose something important for the readability of the code: the names of functions.  Take a look at the following example. <br><br><pre> <code class="hljs pgsql">//      setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">function</span></span> renderTodosForReview() {     <span class="hljs-comment"><span class="hljs-comment">/* code */</span></span> }, <span class="hljs-number"><span class="hljs-number">0</span></span>); //       setTimeout(() =&gt; {     <span class="hljs-comment"><span class="hljs-comment">/* code */</span></span> }, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  When using switch functions, I have to read the text of the function in order to understand exactly what it does.  I would also like to read the name of the function and understand its essence, and not to read all its code.  Of course, you can ensure good readability of the code when using arrow functions.  For example, you can make a habit of using switch functions like this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> renderTodosForReview = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    <span class="hljs-comment"><span class="hljs-comment">/* code */</span></span> }; setTimeout(renderTodosForReview, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><h2>  <font color="#3AC1EF">New operator</font> </h2><br>  When creating objects based on classes, use the operator <code>new</code> .  And when creating objects using factory functions, <code>new</code> not required.  However, if the use of <code>new</code> improves the readability of the code, this operator can also be used with factory functions, there will be no harm. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> todoModel= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TodoModel();</code> </pre> <br>  When <a href="https://jsfiddle.net/cristi_salcescu/4j8wpfhx/">using</a> <code>new</code> with a factory function, the function simply returns the object created to it. <br><br><h2>  <font color="#3AC1EF">Security</font> </h2><br>  Suppose that an application uses a <code>User</code> object to work with authorization mechanisms.  I created a couple of such objects using both approaches described here. <br><br>  Here is a <a href="https://jsfiddle.net/cristi_salcescu/9s9t5qyr/">description of</a> a <code>User</code> object using the class: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(){       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authorized = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;   }     isAuthorized(){       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.authorized;   } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> user = new User();</code> </pre> <br>  Here is the same object <a href="https://jsfiddle.net/cristi_salcescu/2jbd2go8/">described</a> by the factory function: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>() {   var authorized = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;        <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> isAuthorized(){      <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> authorized;   }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({       isAuthorized   }); } const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>();</code> </pre> <br>  Objects created using the <code>class</code> keyword are vulnerable to attacks if the attacker has an object reference.  Since all properties of all objects are public, an attacker can use other objects to gain access to the object in which he is interested. <br><br>  For example, you can obtain the corresponding rights directly from the developer console, if the <code>user</code> variable is global.  To verify this, open the <a href="https://plnkr.co/edit/8LTmGKHuuKm5iroomDyz">example</a> code and modify the <code>user</code> variable from the console. <br><br>  This example was prepared using the <a href="https://plnkr.co/edit/8LTmGKHuuKm5iroomDyz%3Fp%3Dinfo">Plunker</a> resource.  To access global variables, change the context in the console tab from <code>top</code> to <code>plunkerPreviewTarget(run.plnkr.co/)</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.authorized = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>;            //    <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.isAuthorized = <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }  // API console.log(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.isAuthorized());  //<span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f05/d00/790/f05d007901be790c2d5185eec7b37b37.png"></div><br>  <i>Modifying an object using the developer console</i> <br><br>  An object created using a factory function cannot be modified externally. <br><br><h2>  <font color="#3AC1EF">Composition and inheritance</font> </h2><br>  Classes support both inheritance and object composition. <br><br>  I created <a href="https://jsfiddle.net/cristi_salcescu/1xo96yt8/">an example of</a> inheritance in which the class <code>SpecialService</code> is a descendant of the class <code>Service</code> . <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{   log(){} } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SpecialService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{  logSomething(){ console.log(<span class="hljs-string"><span class="hljs-string">"logSomething"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> specialService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">SpecialService</span></span>(); specialService.log(); specialService.logSomething();</code> </pre> <br>  When using factory functions, inheritance is not supported, only composition can be used here.  Alternatively, you can use the <code>Object.assign()</code> command to copy all properties from existing objects.  <a href="https://jsfiddle.net/cristi_salcescu/jgbhkb4o/">For example</a> , suppose we need to reuse all members of the <code>Service</code> object in the <code>SpecialService</code> object. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> Service() {   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> log(){}          <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({       <span class="hljs-keyword"><span class="hljs-keyword">log</span></span>   }); } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> SpecialService(args){  var standardService = args.standardService;  <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> logSomething(){      console.log("logSomething");  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.assign({}, standardService, {      logSomething  })); } var specialService = SpecialService({      standardService : Service()   }); specialService.log(); specialService.logSomething();</code> </pre> <br>  Factory functions promote the use of composition instead of inheritance, which gives the developer a higher level of flexibility in terms of application design. <br><br>  When using classes, you can also prefer composition over inheritance; in fact, these are just architectural solutions for reusing existing behavior. <br><br><h2>  <font color="#3AC1EF">Memory</font> </h2><br>  The use of classes helps save memory, as they are implemented on the basis of a system of prototypes.  All methods are created only once, in the prototype, they are used by all instances of the class. <br><br>  The additional cost of memory consumed by objects created using factory functions is noticeable only when thousands of similar objects are created. <br><br>  Here is the <a href="https://plnkr.co/edit/4cxGfN%3Fp%3Dinfo">page</a> used to figure out the memory costs that are characteristic of using factory functions.  Here are the results obtained in Chrome for a different number of objects with 10 and 20 methods. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7dd/cab/7da/7ddcab7daf3a44336ebcad4cac061a52.png"></div><br>  <i><font color="#999999">Memory cost (in Chrome)</font></i> <br><br><h2>  <font color="#3AC1EF">OOP objects and data structures</font> </h2><br>  Before continuing the analysis of memory costs, one should distinguish between two types of objects: <br><br><ul><li>  OOP objects <br></li><li>  Objects with data (data structures). </li></ul><br>  <i>Objects provide behavior and hide data.</i> <i><br><br></i>  <i>Data structures provide data, but do not have any significant behavior.</i> <i><br><br></i>  <i>Robert Martin, " <a href="https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a> ".</i> <br><br>  Take a look at an example of a <code>TodoModel</code> object <code>TodoModel</code> you already know to clarify the difference between objects and data structures. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> TodoModel(){   var todos = [];            <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>() { }   <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> reload(){ }        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">freeze</span></span>({       <span class="hljs-keyword"><span class="hljs-keyword">add</span></span>,       reload   }); }</code> </pre> <br>  The <code>TodoModel</code> object <code>TodoModel</code> responsible for storing and managing the list of <code>todo</code> objects.  <code>TodoModel</code> is an OOP object, the one that provides the behavior and hides the data.  The application will have only one copy of it, so when you create it using the factory function, no additional memory costs are required. <br><br>  The objects stored in the <code>todos</code> array are data structures.  There can be many such objects in the program, but these are regular JavaScript objects.  We are not interested in making their methods private.  Rather, we strive to ensure that all their properties and methods would be publicly available.  As a result, all these objects will be built using a prototype system, so we can save memory.  They can be created using a regular object literal or by <code>Object.create()</code> command. <br><br><h2>  <font color="#3AC1EF">UI Components</font> </h2><br>  Applications can have hundreds or thousands of instances of user interface components.  This is the situation in which you need to find a compromise between encapsulation and saving memory. <br><br>  Components will be created in accordance with the methods adopted in the framework used.  For example, in Vue object literals are used, in React - classes.  Each member of the component object will be publicly available, but, thanks to the use of a prototype system, the use of such objects will save memory. <br><br><h2>  <font color="#3AC1EF">Two opposing OOP paradigms</font> </h2><br>  In a broader sense, classes and factory functions demonstrate the battle of two opposing paradigms of object-oriented programming. <br><br>  Class-based OOP, as applied to JavaScript, means the following: <br><br><ul><li>  All objects in the application are described using class syntax, using types defined by classes. </li><li>  For writing programs, they are looking for a language with static typing, the code of which is then transpiled into JavaScript. </li><li>  During development, interfaces are used. </li><li>  Apply composition and inheritance. </li><li>  Functional programming is used very little, or almost no interest in it. </li></ul><br>  OOP without the use of classes is as follows: <br><br><ul><li>  Types defined by the developer are not used.  In this paradigm there is no place for something like <code>instanceof</code> .  All objects are created using object literals, some of them with public methods (OOP objects), some with public properties (data structures). </li><li>  During development, dynamic typing is applied. </li><li>  Interfaces are not used.  The developer is only interested in whether the object has the property it needs.  Such an object can be created using the factory function. </li><li>  Composition is applied, but not inheritance.  If necessary, all members of one object are copied to another using <code>Object.assign()</code> . </li><li>  Used functional programming. </li></ul><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  The strength of classes is that they are well known to programmers who have come to JS from languages ‚Äã‚Äãbased on classes.  The classes in JS are the ‚Äúsyntactic sugar‚Äù for the prototype system.  However, security problems and the use of <code>this</code> , leading to permanent errors due to the loss of context, put classes in <a href="https://www.youtube.com/watch%3Fv%3DTllw4EPhLiQ">second place</a> compared to factory functions.  As an exception, classes are resorted to when they are used in the framework used, for example, in React. <br><br>  Factory functions are not only a tool for creating protected, encapsulated, and flexible OOP objects.  This approach to creating classes also opens the way for a new, unique to JavaScript, programming paradigm. <br><br>  Let me conclude this material by quoting <a href="https://www.youtube.com/watch%3Fv%3DDxnYQRuLX7Q%26feature%3Dyoutu.be%26t%3D45m41s">Douglas Crockford</a> : "I think that PLO without classes is a gift to humanity from JavaScript." <br><br>  Dear readers!  What and why is closer to you: classes or factory functions? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/352198/">https://habr.com/ru/post/352198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352188/index.html">Camel in questions and answers</a></li>
<li><a href="../352190/index.html">Divide and conquer: demarcation of access to the records of conversations</a></li>
<li><a href="../352192/index.html">How to become a GPU engineer in an hour</a></li>
<li><a href="../352194/index.html">How to grow from a junior tester into a good tester? Continuation</a></li>
<li><a href="../352196/index.html">Comparison of ITSM-systems</a></li>
<li><a href="../352200/index.html">How to turn a website into a mobile application using 7 lines of JSON</a></li>
<li><a href="../352202/index.html">The book "Head First. Design patterns. Updated anniversary edition ¬ª</a></li>
<li><a href="../352206/index.html">Release of PVS-Studio for macOS: 64 weaknesses in Apple XNU Kernel</a></li>
<li><a href="../352208/index.html">How to perform many UI tests in parallel using Selenium Grid?</a></li>
<li><a href="../352210/index.html">Automation in the development of the platform "1C: Enterprise"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>