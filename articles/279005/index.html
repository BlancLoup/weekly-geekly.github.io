<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating reports in PowerShell</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The issues of text output, reporting, sending mail. Tips are given on how to write reports so that you can use code fragments many times, add missing ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating reports in PowerShell</h1><div class="post__text post__text-html js-mediator-article">  The issues of text output, reporting, sending mail.  Tips are given on how to write reports so that you can use code fragments many times, add missing pieces, and collect a longer report. <br>  Definitely needed by everyone who collects information using PowerShell, or wants to learn how to use it effectively. <br><br><h2>  <b>Secrets of creating reports Chapter 33</b> </h2><br>  <b>This chapter contains</b> <br><ol><li>  <b>Work with HTML fragments</b> </li><li>  <b>Create stylish HTML reports</b> </li><li>  <b>Sending reports by email</b> </li></ol><br><br>  In this chapter, we will look at how PowerShell works when creating reports.  PowerShell does not shine if you need to work with strings, try to use objects for this.  The more you use objects when creating reports, the better you can do the processing. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <b>33.1 What not to do.</b> <br>  Let's start the chapter with what we consider an example of a bad reporting technique.  We constantly meet this style.  Most IT professionals do not think about it and perpetuate the style of other languages, such as VBScript, in code. <br>  The following code is written in a style that we hope you will not use, and which you will see in the code of less-informed system administrators. <br><a name="habracut"></a><br>  Listing 33.1 Poorly designed inventory script <br><pre><code class="cs hljs">param ($computername) Write-Host <span class="hljs-string"><span class="hljs-string">'------- COMPUTER INFORMATION -------'</span></span> Write-Host <span class="hljs-string"><span class="hljs-string">"Computer Name: $computername"</span></span> $os = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $computername Write-Host <span class="hljs-string"><span class="hljs-string">" OS Version: $($os.version)"</span></span> Write-Host <span class="hljs-string"><span class="hljs-string">" OS Build: $($os.buildnumber)"</span></span> Write-Host <span class="hljs-string"><span class="hljs-string">" Service Pack: $($os.servicepackmajorversion)"</span></span> $cs = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $computername Write-Host <span class="hljs-string"><span class="hljs-string">" RAM: $($cs.totalphysicalmemory)"</span></span> Write-Host <span class="hljs-string"><span class="hljs-string">" Manufacturer: $($cs.manufacturer)"</span></span> Write-Host <span class="hljs-string"><span class="hljs-string">" Model: $($cd.model)"</span></span> Write-Host <span class="hljs-string"><span class="hljs-string">" Processors: $($cs.numberofprocessors)"</span></span> $bios = Get-WmiObject -Class Win32_BIOS -ComputerName $computername Write-Host <span class="hljs-string"><span class="hljs-string">"BIOS Serial: $($bios.serialnumber)"</span></span> Write-Host <span class="hljs-string"><span class="hljs-string">''</span></span> Write-Host <span class="hljs-string"><span class="hljs-string">'------- DISK INFORMATION -------'</span></span> Get-WmiObject -Class Win32_LogicalDisk -Comp $computername ‚ÄìFilt <span class="hljs-string"><span class="hljs-string">'drivetype=3'</span></span> | Select-Object @{n=<span class="hljs-string"><span class="hljs-string">'Drive'</span></span>;e={$_.DeviceID}}, @{n=<span class="hljs-string"><span class="hljs-string">'Size(GB)'</span></span>;e={$_.Size / <span class="hljs-number"><span class="hljs-number">1</span></span>GB -<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]}}, @{n=<span class="hljs-string"><span class="hljs-string">'FreeSpace(GB)'</span></span>;e={$_.freespace / <span class="hljs-number"><span class="hljs-number">1</span></span>GB -<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]}} | Format-Table ‚ÄìAutoSize</code> </pre> <br>  The code in Listing 33.1 will produce an output like this. <br><img src="https://habrastorage.org/files/11b/f84/8b3/11bf848b3d22482ebcc63e0a82095de3.png" alt="image"><br>  Figure 33.1 conclusion based on strings. <br><br>  As you can see, this script works, Don Jones (one of the authors), seeing the output from the script in clear lines, angrily pronounces a saying with the participation of the deity and puppies (probably, the curse in the original and puppies that outputs pure text like this).  First of all - this script can only display on the screen, because  The output is conducted through the Write-Host.  In most cases, when you use <i>Write-Host</i> , you will do it wrong.  It would be nice if it would be possible to display this information in a file, or in HTML?  You can achieve this by changing all <i>Write-Host</i> to <i>Write-Output</i> , but this will still be the wrong way. <br><br>  There are more effective ways to generate a report, and this is the reason why we wrote this chapter.  First, we would suggest for each block or function where information is generated to create one object containing all the necessary information.  The more code you break into blocks, the more you can reuse these blocks.  In our bad example, the first section "Computer Information" should be the function we write.  It can be used in all reports of this type.  In the "disk information" section, the data is specified as one object, it is not necessary to combine information from different sources, but all cmdlets on Write must go.  (example of a translator. How to do this, see the example in section 33.2.1 Getting the initial information) <br><br>  <b>Exceptions to every rule</b> <br>  There are exceptions to every rule.  Richard Siddaway spends a lot of time auditing foreign systems.  It makes it a standard set of scripts.  Scripts are designed to produce output, which then either go directly to a Word document, or files are generated and then inserted into a document.  Thus, the initial data can be obtained and viewed very quickly, so that their analysis and discussion is not delayed. <br><br>  The rules violated in these scenarios are as follows <br><ol><li>  The output is a mixture of text and objects. </li><li>  Output immediately formatted </li></ol><br>  This is a conscious decision, since it is known how the scripts will be applied and how the report should look.  The moral of this story is to bring objects, and be ready to go beyond the paradigm if there are reasons. <br><br>  <b>33.2 Working with HTML snippets and files</b> <br>  The trick of our method is that ConvertTo-HTML can be used in two different ways.  The first way is to produce a full HTML page, the second is to produce an HTML fragment.  This fragment is just an HTML table with the data that was passed to the cmdlet, we will produce each section of the report as a fragment, and then we will assemble the fragments into a full HTML page. <br><br>  <b>33.2.1 Obtaining baseline information</b> <br>  We begin by collecting data into objects, one object for each section of the report.  In our case there will be two objects - information about the computer and information about the disks.  We agree that for meekness and clarity we will skip error handling and other subtleties.  In the wild, we would add them.  <i>Get-WMIObject</i> itself produces an object containing information on disks.  This means that you also need to create a function that gives out an object with information about the computer. <br><br><pre> <code class="cs hljs">function Get-CSInfo { param($computername) $os = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $computername $cs = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $computername $bios = Get-WmiObject -Class Win32_BIOS -ComputerName $computername <span class="hljs-meta"><span class="hljs-meta">#property names with spaces need to be enclosed in quotes $props = @{ComputerName = $computername 'OS Version' = $os.version 'OS Build' = $os.buildnumber 'Service Pack' = $os.sevicepackmajorversion RAM = $cs.totalphysicalmemory Processors = $cs.numberofprocessors 'BIOS Serial' = $bios.serialnumber} $obj = New-Object -TypeName PSObject -Property $props Write-Output $obj }</span></span></code> </pre><br>  The function retrieves information from three different WMI classes.  We create an object using a hash table assembled from three objects, since we want to be able to transfer the output of the function through a pipeline.  Usually we prefer to give names to properties without spaces, now we will deviate from this rule because we are going to use names in the final report. <br><br>  <b>33.2.2 Production of fragments of HTML reports.</b> <br><br>  Now we can use the written function to get the report in HTML <br><br><pre> <code class="cs hljs">$frag1 = Get-CSInfo ‚Äìcomputername SERVER2 | ConvertTo-Html -As LIST -Fragment ‚ÄìPreContent <span class="hljs-string"><span class="hljs-string">'&lt;h2&gt;Computer Info&lt;/h2&gt;'</span></span> | Out-String</code> </pre><br>  We have been moving for a long time to this trick, so it must be taken apart: <br>  1. You save the output as an HTML fragment in a variable named <i>$ frag1</i> , later we can insert it in the right place of the output or save it entirely in the file. <br>  2. <i>Get-CSInfo is launched</i> , the name of the computer from which we want to receive data is transferred to it, now we set the name of the computer hard, in the future we will replace it with a variable. <br>  3. The resulting output is <i>served</i> on <i>ConvertTo-HTML</i> , this command generates HTML fragment in the output in the form of a vertical list, not horizontally.  The list will mimic the look of the old report on <i>bad-technology-output-information</i> . <br>  4. We use the <i>‚ÄìPreContent</i> parameter to add an inscription in front of the report label.  We added tags to make a bold title. <br>  5. All that happened - this is a trick - is passed on to the <i>Out-String</i> .  You will see that <i>ConvertTo-HTML</i> will put a whole bunch in the pipeline.  You see that lines, collections of lines, and various other objects are written to the pipeline.  All this will lead to problems in the end, when you try to collect it all into a final HTML page, instead we just filed for an Out-String and got the good old string as output. <br><br>  You can go ahead and produce the second fragment.  This is easier because  no need to write a function, HTML generation will look exactly the same.  The only difference is that we collect the data in this section into a table, not a list: <br><br><pre> <code class="cs hljs">$frag2 = Get-WmiObject -Class Win32_LogicalDisk -Filter <span class="hljs-string"><span class="hljs-string">'DriveType=3'</span></span> -ComputerName SERVER2 | Select-Object @{name=<span class="hljs-string"><span class="hljs-string">'Drive'</span></span>;expression={$_.DeviceID}}, @{name=<span class="hljs-string"><span class="hljs-string">'Size(GB)'</span></span>;expression={$_.Size / <span class="hljs-number"><span class="hljs-number">1</span></span>GB -<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]}}, @{name=<span class="hljs-string"><span class="hljs-string">'FreeSpace(GB)'</span></span>;expression={ $_.freespace / <span class="hljs-number"><span class="hljs-number">1</span></span>GB -<span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]}} | ConvertTo-Html -Fragment -PreContent <span class="hljs-string"><span class="hljs-string">'&lt;h2&gt;Disk Info&lt;/h2&gt;'</span></span> | Out-String</code> </pre><br>  We have both fragments, we can proceed to the formation of the final report. <br><br>  <b>33.2.3 Building the final HTML file</b> <br>  The build includes adding your two fragments, and style sheets.  Using a CSS style sheet and language is beyond the scope of this book.  The style sheet allows you to control the formatting of the HTML page so that it looks much better.  If you want a good tutorial and links to additional CSS content, check out http://www.w3schools.com/css/ <br><br><pre> <code class="cs hljs">$head = @<span class="hljs-string"><span class="hljs-string">' &lt;style&gt; body { background-color:#dddddd; font-family:Tahoma; font-size:12pt; } td, th { border:1px solid black; border-collapse:collapse; } th { color:white; background-color:black; } table, tr, td, th { padding: 2px; margin: 0px } table { margin-left:50px; } &lt;/style&gt; '</span></span>@ ConvertTo-HTML -head $head -PostContent $frag1, $frag2 -PreContent <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hardware Inventory for SERVER2&lt;/h1&gt;"</span></span></code> </pre><br>  The style sheet <i>$ head is created</i> , the desired style is described in the string type variable.  This variable is then passed to the <i>‚Äìhead</i> parameter, and your fragments are listed separated by a comma in the <i>‚ÄìPostContent</i> parameter.  A report title is also added in the <i>‚ÄìPreContent</i> parameter.  Save the entire script as <i>C: \ Good.ps1</i> and run it as follows: <br>  <i>./good&gt; Report.htm</i> <br>  This will redirect the output to the <i>Report.htm</i> file, which will be beautiful, as in Figure 33.2. <br><br><img src="https://habrastorage.org/files/688/f16/239/688f162397864657b0cd5d7d1c5530fe.png" alt="image"><br>  Figure 33.2 report from several fragments <br><br>  Maybe this is not a work of art, but it is a report that looks better than a report on the screen that began this chapter.  Listing 33.2 shows a hung script where you can set the name of the computer, the default is <i>localhost</i> .  The header contains <i>[CmdletBinding ()],</i> which allows the use of <i>‚Äìverbose</i> .  <i>Write-Verbose is</i> inserted in the body of the script, you can see what each step is doing. <br><br>  Listing 33.2 HTML script inventory <br><pre> <code class="cs hljs">&lt;<span class="hljs-meta"><span class="hljs-meta"># .DESCRIPTION Retrieves inventory information and produces HTML .EXAMPLE ./Good &gt; Report.htm .PARAMETER The name of a computer to query. The default is the local computer. #&gt; [CmdletBinding()] param([string]$computername=$env:computername) # function to get computer system info function Get-CSInfo { param($computername) $os = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $computername $cs = Get-WmiObject -Class Win32_ComputerSystem -ComputerName $computername $bios = Get-WmiObject -Class Win32_BIOS -ComputerName $computername $props = @{'ComputerName'=$computername 'OS Version'=$os.version 'OS Build'=$os.buildnumber 'Service Pack'=$os.servicepackmajorversion 'RAM'=$cs.totalphysicalmemory 'Processors'=$cs.numberofprocessors 'BIOS Serial'=$bios.serialnumber} $obj = New-Object -TypeName PSObject -Property $props Write-Output $obj } Write-Verbose 'Producing computer system info fragment' $frag1 = Get-CSInfo -computername $computername | ConvertTo-Html -As LIST -Fragment -PreContent '&lt;h2&gt;Computer Info&lt;/h2&gt;' | Out-String Write-Verbose 'Producing disk info fragment' $frag2 = Get-WmiObject -Class Win32_LogicalDisk -Filter 'DriveType=3' -ComputerName $computername | Select-Object @{name='Drive';expression={$_.DeviceID}}, @{name='Size(GB)';expression={$_.Size / 1GB -as [int]}}, @{name='FreeSpace(GB)';expression={$_.freespace / 1GB -as [int]}} | ConvertTo-Html -Fragment -PreContent '&lt;h2&gt;Disk Info&lt;/h2&gt;' | Out-String Write-Verbose 'Defining CSS' $head = @' &lt;style&gt; body { background-color:#dddddd; font-family:Tahoma; font-size:12pt; } td, th { border:1px solid black; border-collapse:collapse; } th { color:white; background-color:black; } table, tr, td, th { padding: 2px; margin: 0px } table { margin-left:50px; } &lt;/style&gt; '@ Write-Verbose 'Producing final HTML' Write-Verbose 'Pipe this output to a file to save it' ConvertTo-HTML -head $head -PostContent $frag1,$frag2 -PreContent "&lt;h1&gt;Hardware Inventory for $ComputerName&lt;/h1&gt;"</span></span></code> </pre><br><br>  Script use <br><pre> <code class="cs hljs">PS C:\&gt; $computer = SERVER01 PS C:\&gt; C:\Scripts\good.ps1 -computername $computer | &gt;&gt; Out-File <span class="hljs-string"><span class="hljs-string">"$computer.html"</span></span> &gt;&gt; PS C:\&gt; Invoke-Item <span class="hljs-string"><span class="hljs-string">"$computer.html"</span></span></code> </pre><br>  The script generates an HTML file that can be used in the future, and displays a report.  Keep in mind that the <i>Get-CSInfo function</i> can be reused.  Since it displays the object, not the text, you can use it in various places where you need to display the same information. <br>  If you need to add more information to the report, then to add a new section you will need: <br><ul><li>  Write a function or command generating object, with the information of the new report section. </li><li>  Create an HTML fragment from this object and save it to a variable. </li><li>  Add this variable to the variable list of the final report assembly command.  So you complete the report. </li><li>  Everything </li></ul><br>  Yes, this report is text.  In the end, every report will be text, because the text is what we read.  The essence of this method is that everything remains an object until the last moment.  You let PowerShell format for you.  The work items of this script can be copied and used elsewhere, which is not possible using the source text at the beginning of the chapter. <br><br>  <b>33.3 Email Sending</b> <br>  What could be better than HTML report?  Report that will automatically come to email! <br><br>  By part, PowerShell already contains the <i>Send-MailMessage cmdlet</i> .  Let's fix our script a bit: <br><pre> <code class="cs hljs">Write-Verbose <span class="hljs-string"><span class="hljs-string">'Producing final HTML'</span></span> Write-Verbose <span class="hljs-string"><span class="hljs-string">'Pipe this output to a file to save it'</span></span> ConvertTo-HTML -head $head -PostContent $frag1,$frag2 -PreContent <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hardware Inventory for $ComputerName&lt;/h1&gt;"</span></span> | Out-File report.htm Write-Verbose <span class="hljs-string"><span class="hljs-string">"Sending e-mail"</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">params</span></span> = @{<span class="hljs-string"><span class="hljs-string">'To'</span></span>=<span class="hljs-string"><span class="hljs-string">'whomitmayconcern@company.com'</span></span> <span class="hljs-string"><span class="hljs-string">'From'</span></span>=<span class="hljs-string"><span class="hljs-string">'admin@company.com'</span></span> <span class="hljs-string"><span class="hljs-string">'Subject'</span></span>=<span class="hljs-string"><span class="hljs-string">'That report you wanted'</span></span> <span class="hljs-string"><span class="hljs-string">'Body'</span></span>=<span class="hljs-string"><span class="hljs-string">'Please see the attachment.'</span></span> <span class="hljs-string"><span class="hljs-string">'Attachments'</span></span>=<span class="hljs-string"><span class="hljs-string">'report.htm'</span></span> <span class="hljs-string"><span class="hljs-string">'SMTPServer'</span></span>=<span class="hljs-string"><span class="hljs-string">'mail.company.com'</span></span>} Send-MailMessage @<span class="hljs-keyword"><span class="hljs-keyword">params</span></span></code> </pre><br>  we changed the end of the pipeline by redirecting the output to a file.  Then used <i>Send-MailMessage</i> as an attachment.  You can send HTML as the message body itself.  You do not need to create a file on disk for this, you can take output from the pipeline directly.  Here is an alternative example. <br><pre> <code class="cs hljs">Write-Verbose <span class="hljs-string"><span class="hljs-string">'Producing final HTML'</span></span> $body = ConvertTo-HTML -head $head -PostContent $frag1,$frag2 -PreContent <span class="hljs-string"><span class="hljs-string">"&lt;h1&gt;Hardware Inventory for $ComputerName&lt;/h1&gt;"</span></span> | Out-String Write-Verbose <span class="hljs-string"><span class="hljs-string">"Sending e-mail"</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">params</span></span> = @{<span class="hljs-string"><span class="hljs-string">'To'</span></span>=<span class="hljs-string"><span class="hljs-string">'whomitmayconcern@company.com'</span></span> <span class="hljs-string"><span class="hljs-string">'From'</span></span>=<span class="hljs-string"><span class="hljs-string">'admin@company.com'</span></span> <span class="hljs-string"><span class="hljs-string">'Subject'</span></span>=<span class="hljs-string"><span class="hljs-string">'That report you wanted'</span></span> <span class="hljs-string"><span class="hljs-string">'Body'</span></span>=$Body <span class="hljs-string"><span class="hljs-string">'BodyAsHTML'</span></span>=$True <span class="hljs-string"><span class="hljs-string">'SMTPServer'</span></span>=<span class="hljs-string"><span class="hljs-string">'mail.company.com'</span></span>} Send-MailMessage @<span class="hljs-keyword"><span class="hljs-keyword">params</span></span></code> </pre><br>  Here we built the <i>Send-MailMessage parameters</i> in the hash table and saved them in the <i>$ Param</i> variable.  This allows you to use <i>splat</i> technique and feed all the parameters to the team at once.  It makes no difference that you type them as parameters or you specify it through a hash table, it will work anyway, but it‚Äôs better to read. <br><br>  <b>33.4 Total</b> <br>  Building reports is certainly a great need for administrators, we wanted to show that PowerShell is well suited for this task.  The trick is to create reports in such a way that the extraction of information is separated from formatting and creating output.  In fact, PowerShell can provide great formatting and output capabilities with a small amount of work on your part. <br><br>  ZY  from translator <br>  for correct display of Russian text you need to use <br><pre> <code class="cs hljs">$encoding = [System.Text.Encoding]::UTF8 Send-MailMessage @<span class="hljs-keyword"><span class="hljs-keyword">params</span></span> -Encoding $encoding</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/279005/">https://habr.com/ru/post/279005/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../278989/index.html">Android N makes it easy to work with encryption</a></li>
<li><a href="../278991/index.html">Report with MoscowJS February 25</a></li>
<li><a href="../278995/index.html">Calltracking in Minecraft or how to quickly make a three-dimensional UI</a></li>
<li><a href="../278997/index.html">Release Webix 3.2. New widgets for working with data and other features</a></li>
<li><a href="../278999/index.html">Thorny road to sales on Themeforest.net - Part 1</a></li>
<li><a href="../279007/index.html">Crutch for the signal-slot system in Qt</a></li>
<li><a href="../279011/index.html">Update DataGrid after DELETE (WPF)</a></li>
<li><a href="../279017/index.html">Bitrix, HMVC and a bit of nonsense ...</a></li>
<li><a href="../279019/index.html">Emoji appeared on Github: reactions to pull requests, bugs and comments</a></li>
<li><a href="../279021/index.html">Experiment: Using Google Trends to predict stock market crashes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>