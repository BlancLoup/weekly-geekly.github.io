<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Completion Port</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey. Now I will tell you about the IO Completion Ports mechanism in Windows. Developers describe the port of completion as "a tool that improves the p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Completion Port</h1><div class="post__text post__text-html js-mediator-article"> Hey.  Now I will tell you about the IO Completion Ports mechanism in Windows.  Developers describe the port of completion as "a tool that improves the performance of applications that often use I / O operations."  In general, they do not lie, so IOCP is often used when writing scalable server applications.  However, it is believed that the port of completion is a tricky and difficult topic to understand. <br><a name="habracut"></a><br>  <strong>Theory.</strong> <br><br>  The ‚Äúport‚Äù object, in essence, is a kernel event queue from which I / O operations are extracted and added.  Naturally, not all current operations are added there, but only those that we have indicated to the port.  This is done by associating the handle (handle) of the file (not necessarily the file on the disk, it can be a socket, pipe, mailslot, etc.) with a port handle.  When an asynchronous I / O operation is initiated on a file, after its completion, the corresponding entry is added to the port. <br>  For processing the results, a pool of threads is used, the number of which is selected by the user.  When a thread is attached to a pool, it retrieves one result from the queue and processes it.  If at the time of joining the queue is empty, then the thread falls asleep until a message for processing appears.  An interesting feature of the port of completion is the fact that a message can be put into the queue with a ‚Äúhand‚Äù in order to extract it later. <br>  Looks confusing?  In practice, somewhat easier. <br><br>  <strong>Implementation.</strong> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After the description of the scheme of work we proceed to more specific things.  Namely, the implementation of an application that uses IOCP.  As an example, I will use a server that simply accepts incoming connections and packets from clients.  Used language - C. <br><br>  So, for a start it would be nice to create this very port.  This is done by API <br><br> <code>HANDLE CreateIOCompletionPort( <br> HANDLE FileHandle, <br> HANDLE ExistingCompletionPort, <br> ULONG_PTR CompletionKey, <br> DWORD NumberOfConcurrentThreads);</code> <br> <br>  Remarkably, the same call is used to associate the file handle with an already existing port.  Why this was done - is unknown. <br>  Line <br> <code>HANDLE iocp=CreateIoCompletionPort(INVALID_HANDLE_VALUE,0,0,0);</code> <br>  will create a new port object of completion and return us its handle.  Here, the first argument is the value INVALID_HANDLE_VALUE, which means that we need a new port.  The following two arguments must be set to 0. When creating, you can specify how many threads can simultaneously work for this port using the last argument.  If you specify 0, the value equal to the number of processors in the system will be used. <br><br>  The next step is to create threads that will be involved in the pool.  You can not give universal advice.  Some say that there should be twice the number of processors in the system, others, that their number should be equal, others dynamically change the size of the pool.  What to do here depends on the application and configuration of the computer.  I have an old stump with HyperThreading, so the system sees my processor as two.  For this reason, in my example there will be 2 worker threads in the pool. <br><br> <code>for(int i=1;i&lt;=2;i++) <br> { <br> HANDLE hWorking=CreateThread(0,0,(LPTHREAD_START_ROUTINE)&amp;WorkingThread,iocp,0,0); <br> CloseHandle(hWorking); <br> }</code> <br> <br>  I draw your attention: we pass to the workflows the handle of the completion port as a parameter.  They will need it when the threads declare their willingness to work.  The function itself WorkingThread () will be shown below. <br><br>  Now that the threads have been created, you can begin receiving clients and their messages.  I will not give Winsock initialization code here (but it is in the source text of this article), so I‚Äôll just write: <br><br> <code>while(1) <br> { <br> SOCKET clientsock=WSAAccept(listensock,(sockaddr *)&amp;clientaddr,&amp;clientsize,0,0); <br> ... <br> }</code> <br> <br>  The accept call returns us the socket of the next client, to which we can write and from which we can read as from a regular file.  In your case, there may be a file on disk or any other IO object. <br>  Now we need to notify the port of completion that we want it to monitor this socket.  To do this, bind the socket and port descriptors: <br><br> <code>CreateIoCompletionPort((HANDLE)clientsock,iocp,(ULONG_PTR)key,0);</code> <br> <br>  The last argument in this case is ignored, since the port has already been created.  But the penultimate requires a special investigation.  In the prototype, it is listed as CompletionKey (‚Äúcompletion key‚Äù).  In fact, the key is a pointer to any data, i.e.  on the structure or instance of the class you defined.  It is used so that within a stream you can distinguish one operation from another, or to store the status of a particular client.  At a minimum, you will have to store there a byte indicating which operation has completed - sending or receiving (reading or writing). <br><br>  After binding the descriptors, you can initiate asynchronous I / O.  For sockets, Winsock2 functions are used - WSASend () and WSARecv () with the pointer to the OVERLAPPED structure passed there, which actually marks an asynchronous operation.  For files, you can use the WriteFile () and ReadFile () functions, respectively. <br>  In addition to the OVERLAPPED structure, you need to pass some other IO information to the stream ‚Äî for example, the address of the buffer, its length, or even the buffer itself.  This can be done either through the completion key, or you can create a structure containing OVERLAPPED in the first field and pass a pointer to it in WSASend () / WSARecv (). <br><br>  Now consider the API function that attaches the thread that calls it to the pool: <br><br> <code>BOOL GetQueuedCompletionStatus( <br> HANDLE CompletionPort, <br> LPDWORD lpNumberOfBytes, <br> PULONG_PTR lpCompletionKey, <br> LPOVERLAPPED *lpOverlapped, <br> DWORD dwMilliseconds);</code> <br> <br>  Here, CompletionPort is the handle of the port to which the pool should be connected;  lpNumberOfBytes - a pointer to a variable, in which the number of bytes transferred is written as a result of the completion of the operation (in fact, it is the return value of recv () and send () in synchronous mode);  lpCompletionKey - a pointer to a variable, into which a pointer to the termination key will be written;  lpOverlapped - pointer to OVERLAPPED associated with this IO transaction;  Finally, dwMilliseconds is the time for which the thread can fall asleep while waiting for the completion of any request.  If you specify INFINITE, it will wait forever. <br><br>  Now that we are familiar with the extraction function from the queue, we can look at the function with which the worker threads start executing. <br><br> <code>void WorkingThread(HANDLE iocp) <br> { <br> while(1) <br> { <br> if(!GetQueuedCompletionStatus(iocp,&amp;bytes,&amp;key,&amp;overlapped,INFINITE)) <br> //  <br> break; <br> if(!bytes) <br> //0     , ..   <br> switch(key-&gt;OpType) <br> { <br> ... <br> } <br> } <br> }</code> <br> <br>  Inside the switch, new asynchronous operations are invoked, which will be processed the next time the loop passes.  If we do not want a definite final operation to be transferred to the port (for example, when the result is not important to us), we can use the following trick - set the first bit of the OVERLAPPED.hEvent field to 1. It is worth noting that, in terms of performance, put processing the incoming information in the same cycle is not the most reasonable solution, since  this will slow down the server's reaction to incoming packets.  To solve the problem, you can make the parsing of the read information into another separate thread, and here the third API function is useful to us: <br><br> <code>BOOL PostQueuedCompletionStatus( <br> HANDLE CompletionPort, <br> DWORD dwNumberOfBytesTransferred, <br> ULONG_PTR dwCompletionKey, <br> LPOVERLAPPED lpOverlapped);</code> <br> <br>  Its essence is clear from the name - it puts a message in the port queue.  Actually all asynchronous functions upon completion of the operation imperceptibly call it.  All the arguments listed here are immediately passed to one of the threads.  Thanks to PostQueuedCompletionStatus, the termination port can be used not only for processing IO operations, but also simply for efficient queuing with a pool of threads. <br>  In our example, it makes sense to create another port and, after completing some operation, call PostQueuedCompletionStatus (), transferring the received packet to another stream for processing in the key. <br><br>  <strong>Internal organization.</strong> <br>  The port of completion is the following structure: <br><br> <code>typedef stuct _IO_COMPLETION <br> { <br> KQUEUE Queue; <br> } IO_COMPLETION;</code> <br> <br>  As noted above, this is just a kernel event queue.  Here is a description of the KQUEUE structure: <br><br> <code>typedef stuct _KQUEUE <br> { <br> DISPATCHER_HEADER Header; <br> LIST_ENTRY EnrtyListHead; //  <br> DWORD CurrentCount; <br> DWORD MaximumCount; <br> LIST_ENTRY ThreadListHead; //   <br> } KQUEUE;</code> <br> <br>  When creating the port, the CreateIoCompletionPort function calls the internal NtCreateIoCompletion service.  It is then initialized using the KeInitializeQueue function.  When the port is bound to the file object, the Win32 function CreateIoCompletionPort calls NtSetInformationFile. <br><br> <code>NtSetInformationFile( <br> HANDLE FileHandle, <br> PIO_STATUS_BLOCK IoStatusBlock, <br> PVOID FileInformation, <br> ULONG Length, <br> FILE_INFORMATION_CLASS FileInformationClass);</code> <br> <br>  For this function, FILE_INFORMATION_CLASS is set as FileCompletionInformation, and a pointer to the IO_COMPLETION_CONTEXT or FILE_COMPLETION_INFORMATION structure is passed as the FileInformation parameter. <br><br> <code>typedef struct _IO_COMPLETION_CONTEXT <br> { <br> PVOID Port; <br> PVOID Key; <br> } IO_COMPLETION_CONTEXT; <br> <br> typedef struct _FILE_COMPLETION_INFORMATION <br> { <br> HANDLE IoCompletionHandle; <br> ULONG CompletionKey; <br> } FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;</code> <br> <br>  After completing an asynchronous I / O operation for an associated file, the I / O manager creates a request packet from the OVERLAPPED structure and a completion key and places it in a queue by calling KeInsertQueue.  When a thread calls the GetQueuedCompletionStatus function, the NtRemoveIoCompletion function is actually called.  NtRemoveIoCompletion checks the parameters and calls the KeRemoveQueue function, which blocks the stream if there are no requests in the queue, or the CurrentCount field of the KQUEUE structure is greater than or equal to MaximumCount.  If there are requests and the number of active threads is less than the maximum, KeRemoveQueue removes the thread that caused it from the queue of waiting threads and increases the number of active threads by 1. When the stream is put on the queue of waiting threads, the Queue field of the KTHREAD structure is set to the address of the final port.  When a request is placed on the termination port with the PostQueuedCompletionStatus function, the NtSetIoCompletion function is actually called, which after checking the parameters and converting the port handle to the pointer, calls KeInsertQueue. <br><br>  I have it all.  Below is a link to the program with an example of use. <br>  <a href="">iocp.c</a> </div><p>Source: <a href="https://habr.com/ru/post/59282/">https://habr.com/ru/post/59282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../59270/index.html">Hosting heroku.com + custom domain name * setup for beginners</a></li>
<li><a href="../59272/index.html">Results of the first week</a></li>
<li><a href="../59274/index.html">OpenSource-caster, or force the teacher to precipitate</a></li>
<li><a href="../59275/index.html">Youtube + Universal = VEVO</a></li>
<li><a href="../59276/index.html">google & nginx</a></li>
<li><a href="../59284/index.html">Pegman today pegmom</a></li>
<li><a href="../59285/index.html">Children</a></li>
<li><a href="../59286/index.html">Russians can already pre-order the HTC Magic</a></li>
<li><a href="../59290/index.html">Russia is the champion!</a></li>
<li><a href="../59292/index.html">Version 1.0.5</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>