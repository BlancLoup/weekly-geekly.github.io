<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Criticism of Bob Martin‚Äôs book Principles, Patterns, and Techniques for Agile Development in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you ask ten developers about the best (or worthy) book on design, then at least 6 of them call Bob Martin's book Principles, Patterns and Agile Dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Criticism of Bob Martin‚Äôs book Principles, Patterns, and Techniques for Agile Development in C #</h1><div class="post__text post__text-html js-mediator-article">  If you ask ten developers about the best (or worthy) book on design, then at least 6 of them call Bob Martin's <a href="http://www.ozon.ru/context/detail/id/5800704/">book Principles, Patterns and Agile Development Techniques</a> .  If, after this, to show them some interesting moments of Bob‚Äôs ‚Äúuncle‚Äù scribbling, then most of them will clear their forehead with perplexity and change their opinion somewhat. <br><br>  When reading this note, it is worthwhile to include common sense and not consider it as an attack on the holy.  After all, it is quite possible that you read it several years ago, when there were fewer scars on the hands of littered projects, and with the word ‚Äúpatterns‚Äù the knees trembled a little.  So maybe you should look at the "classics" from the height of the new experience? <br><br><a name="habracut"></a><br>  From the first pages of the book, Martins are very weakly thrown onto the fan, starting the book as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <font>‚ÄúMy experience is that .NET programmers are often weaker than those written in Java or C ++.</font>  <font>It is clear that there are exceptions.</font>  <font>However, over and over again, watching my listeners, I was forced to conclude that .NET programmers usually have less knowledge of software development methods, patterns and design principles, etc.</font>  <font>It often happened that the .NET programmers present were not at all aware of these fundamental concepts.</font>  <font><i>This situation must be changed</i> .</font> <br><br>  <font>While working on this book, I often doubted whether to put my name on the cover of a book devoted to .NET.</font>  <font>I asked myself if I wanted to be associated with .NET and with all the negative perceptions associated with this platform.</font>  <font>But what's the point of denying?</font>  <font>I'm a .NET programmer.</font>  <font>Not!</font>  <font>I am a flexible .NET programmer.</font>  <font>And proud of it. "</font> <br><br>  Well, now let's see what we, illiterate .NET chicks, can learn from the comrades of the Martin. <br><br><h4>  Principles </h4><br>  In general, the description of all the principles of SOLID seemed to me very ambiguous.  On the one hand, many of them (such as DIP and OCP) are formulated very rigidly: DIP prohibits the use of a variable of a particular type, and OCP implies an extension without recompilation.  On the other hand, sometimes there are pragmatic notes that you need to use these principles wisely. <br><br>  Here is an interesting point: <br><br>  <font>‚ÄúFlexible teams apply these principles (meaning SOLID) only to eliminate odor;</font>  <font>when nothing bad smells, then the principles do not apply.</font>  <font>It would be a mistake to unconditionally adhere to a certain principle simply because it is a principle.</font>  <font>Principles exist to help eliminate bad odors.</font>  <font>These are not perfumes that need to be plentifully watered the entire system.</font>  <font>Excessive adherence to principles leads to vice of unnecessary complexity. ‚Äù</font> <br><br>  On the one hand, this is a very pragmatic point of view, but on the other hand, why should we make such rigid principles, in order to introduce additional rules about when to follow them and when not? <br><br>  In addition, it seems to me that the causes and effects are confused: the principles are needed primarily to determine the ‚Äúnice‚Äù in design and they do not help in their elimination. <br><br>  Below are descriptions of the principles, which cannot be broken. <br><br><h5>  Lsp </h5><br>  <font>‚ÄúIf during the creation of a derived class we are forced to make a change to the base class, then the design most likely has a flaw.‚Äù</font> <br><br>  Or there is another option: we live in the real world, in which evolutionary design is the key development approach. <br><br>  <font>‚ÄúDoes the LSP principle find application in real programs?</font>  <font>Consider an example taken from a project I worked on <b>several years ago</b> . ... <b>In the early 1990s</b> ... "</font> <br>  The original book was released in the middle of 2006 (already after the release of C # 2.0 and generalizations), and here a few years ago it was the beginning of the 1990s. <br><br>  <font>"The Liskov substitution principle is one of the main tools for implementing the OCP principle."</font> <br>  I would say that one of the options for achieving OCP is polymorphism, and LSP says that polymorphism works the way we expect it to.  There are other options for achieving OCP, for example, based on callback functions. <br><br>  If we are already talking about the formalization of the LSP principle, then we need to talk about contracts, about their role for the correct implementation of inheritance.  Contracts in the book are mentioned, but literally in passing. <br><br><h5>  Dip </h5><br>  The criticism of this principle is described in more detail in the article <a href="http://sergeyteplyakov.blogspot.com/2013/04/blog-post.html">‚ÄúA Critical Look at the Principle of Inversion of Dependencies‚Äù</a> . <br><br>  But here is one very emotional conclusion, which is very pleased: <br><br>  <font>‚ÄúIn fact, such dependency inversion is a great sign of object-oriented design.</font>  <font>It doesn't matter what language the program is written in.</font>  <font>If the dependencies are inverted, then we have an object-oriented design.</font>  <font>Otherwise, the design is procedural. ‚Äù</font> <br>  Very controversial statement, agree! <br><br><h5>  OCP </h5><br>  Not many people know that the author of the principle Open-Close is not Bob Martin, but Bertrand Meyer in his book <a href="http://sergeyteplyakov.blogspot.com/2012/03/blog-post_19.html">Object-Oriented Design of Software Systems</a> .  At the same time, even fewer people noticed that Bob Martin interprets this principle in his own way. <br><br>  <b>Definition from Bob Martin</b> : <i>program entities (classes, modules, functions, etc.) should be open for expansion, but closed for modification.</i> <br><br>  Thus, the modules have two main characteristics: <br><br><ul><li>  <b>They are open for expansion.</b>  This means that the behavior of the module can be expanded.  When the requirements for an application change, we add a new behavior to the module that meets the changed requirements.  In other words, we can change the composition of the module's functions. <br></li><li>  <b>They are closed for modification.</b>  The extension of module behavior is not associated with changes in the source or binary code of a module.  The binary executable representation of the module, be it a composable library, a DLL, or an .exe file, remains unchanged. </li></ul><br><br>  <b>Definition by Bertrand Meier</b> : <i>modules must be able to be both open and closed.</i> <br>  In this case, the concepts of <i>openness</i> and closeness are <i>defined</i> as follows: <br><br><ul><li>  <b>A module is called open</b> if it is still available for expansion.  For example, it is possible to expand the set of operations in it or add fields to its data structures. <br></li><li>  <b>A module is called closed</b> if it is available for use by other modules.  This means that the module (its interface - in terms of hiding information) already has a well-defined final description.  At the implementation level, the closed state of the module means that the module can be compiled, stored in the library and made available for use by other modules (its clients). </li></ul><br><br>  <b>In other words, Meyer speaks about the openness / closeness of the module interface, I Martin - about the openness / closeness of the module as a whole, including its interface and implementation.</b> <br><br>  The possibility of extending the behavior of a module without recompilation should be described in the requirements for the module, and not be based on principles. <br><br>  At the same time, it is amusing that as an example of the Open-Close principle, the <i>Shape</i> class is still given with the <i>Draw</i> method, which corresponds to the open-closed principle compared to the solution from structural design.  But at the same time, he is silent about how open this solution will be for expansion and closed for modification if we want to add a new type of shape or a new operation to the base class <i>Shape</i> . <br><br><h5>  ISP </h5><br>  While reading the book, I repeatedly found myself thinking that the book was not written from scratch, but was exactly the second edition, the examples of which were translated into C #.  Moreover, the book has been reworked "in the forehead," and not processed using the idioms of the .NET platform. <br><br>  One of the best manifestations of this property are the examples given in the description of the Interface Segregation Principle principle. <br><br>  The principle of separation of interfaces is considered in two examples, one of which is a security system with the class <i>Door</i> (Door) and a subclass of <i>TimedDoor</i> , which should give out a sound signal if the door is not closed for some time.  Here is one of the solutions to this task, given in the section ‚ÄúSeparation through delegation‚Äù, which, according to the author, will satisfy the ISP: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3cd/674/453/3cd6744535e63a16f0cab987b352d3a8.png"><br><br>  Here is what the authors write about this: <font>‚ÄúThis solution is consistent with the principle of the ISP and does not create connections between the Door customers and the Timer class.</font>  <font>... However, it is not too elegant.</font>  <font>Every time we want to register a timeout, we have to create a new object. ‚Äù</font> <br><br>  After reading this section, I imagined what the younger Martin (who is the .NET th son) had to say after reading it: <br><br>  ‚ÄúPa, listen, I understand that this design option is not the last, and we are not writing a book from scratch, but still ... <br>  After all, there are two extra classes, and for the <i>DoorTimeout</i> method in the <i>TimedDoor</i> class, which takes <i>timeoutId,</i> we‚Äôll tear off personal belongings!  After all, the timer in .NET is from the very beginning and the ‚Äúobserver‚Äù in them is built on the basis of events, and not on the basis of interfaces.  So it turns out that we can throw out the <i>TimerClient</i> and <i>DoorTimerAdapter</i> , and make the <i>DoorTimeout</i> method closed (and also throw out this timeoutId). <br>  So in terms of design, the code will be cleaner, and in terms of implementation, too.  So, this example should be thrown out, and the chapter should be completely reworked under the idioms of the C # language, and the community may not appreciate such creativity! ‚Äù <br><br>  However, such a conversation, apparently, was not!  Therefore, there are some very unfortunate examples in this chapter that cannot be found in a normal C # application. <br><br><h4>  UML </h4><br>  <font><i>‚ÄúStatic diagrams</i> describe the invariable logical structure of a program, namely, the elements ‚Äî classes, <b>objects</b> , data structures ‚Äî and the relationships between them.‚Äù</font> <br><br>  Objects are not part of the "immutable logical structure of the program." <br><br>  <font>"An association is a simple relation, in that one object stores a reference to another and calls methods of another object."</font> <br><br>  Association does not imply the preservation of links.  If class <i>A</i> uses <i>Singleton</i> directly, then there is no link, but there is an association. <br><br>  <font>‚ÄúComposition is a special case of aggregation.</font>  <font>Again, I note that the implementation is indistinguishable from the general association.</font>  <font>This time, the reason is that this relationship finds <b>few uses in</b> <b>C</b> <b>#</b> <b>programs</b> . ‚Äù</font> <br><br>  It must be said here that in controlled languages ‚Äã‚Äãof pure composition, when the whole strictly controls the lifetime of the component, it is impossible to achieve.  But if we speak from a logical point of view, the composition in the C # language is used quite often, if the developer does not abuse the principle of dependency inversion. <br><br><h4>  Patterns </h4><br>  It is very interesting that the book describes principles and patterns, while the description of some very rarely relies on the description of others.  So, many of the problems described in the DIP pattern are successfully solved by the observer, the strategy and the mediator, but when describing this principle, the patterns are hardly mentioned.  Or, when describing <i>Singleton's</i> problems, it would be necessary to say that all its users will violate DIP and get problems with testability, but, again, these parallels are not made. <br>  Now a little specifics. <br><br><h5>  Facade and intermediary </h5><br>  <font>‚ÄúBoth patterns, considered in this chapter, pursue one goal: to impose some sort of policy on a group of objects.</font>  <font>The fa√ßade imposes a policy on top and a mediator on the bottom.</font>  <font>The facade is visible and imposes restrictions. The Mediator is not visible and does not restrict anything. ‚Äù</font> <br><br>  Troll 80 Level Detected!  In this way, we can find a common ground between any two concepts, and even if they are not there, we can combine them in one place due to their differences! <br><br>  These patterns really have nothing in common, belong to different categories (facade - structural, mediator - behavioral) and are designed to solve different tasks at different levels of abstraction.  The chapter of the book should be as solid (cohesive) as the classes and modules, and attempts to describe heterogeneous concepts in one place seem dubious. <br><br><h5>  Decorator </h5><br>  <font>‚ÄúThere are two ways to use a decorator to work with databases.</font>  <font>You can decorate a business object by replenishing it with methods of reading and writing, or you can decorate a data object that already knows how to read and write itself, providing it with business rules.</font>  <font>The latter approach is often used when working with object-oriented databases. "</font> <br><br>  WTF ?!  The main essence of the decorator is that it allows you to change the behavior without changing the interface of the object to be decorated.  If we ‚Äúreplenish it with reading and writing methods‚Äù and do not override any virtual methods, then the resulting class will not be an adequate decorator! <br><br>  Yes, formally, the decorator allows you to add operations, but they still have to expand the functionality of an existing class, rather than adding fundamentally new operations.  Nevertheless, the decorator is used ‚Äúfor adding clients to objects dynamically, transparent for clients‚Äù. <br><br><h5>  Visitor </h5><br>  <font>‚ÄúThis dependency cycle links all visited subclasses ‚Äî all types of modems ‚Äî together, making it difficult to <b>incrementally compile</b> visitors or add new subclasses to the hierarchy that is being visited.‚Äù</font> <br><br>  Obviously, the selection was simply not updated after the transition from C ++ to C #. <br>  <font>‚ÄúWorse, the casting speed may depend on the width and depth of the hierarchy, and therefore it is difficult to predict.‚Äù</font> <br><br>  It is possible that for environments with multiple inheritance of implementations, large hierarchies may affect the performance of type conversions, but I could not find evidence of these words for .NET. <br><br><h5>  condition </h5><br>  Chapter 36 discusses a transition table based on a simple vector (fields of type <i>IList</i> ), which gives the following advice: <br><br>  <font>‚ÄúThe disadvantage of this solution is primarily low productivity.</font>  <font>The search in the jump table takes time.</font>  <font>If the state machine is very large, then the search time may be noticeable. ‚Äù</font> <br>  I have always thought that the <i>State</i> pattern based on the transition table is one of the most successful solutions in terms of development cost / efficiency.  But, of course, a typical solution involves the use of a dictionary that will provide O (1) the difficulty of finding a transition. <br><br><h5>  Template Method and Strategy </h5><br>  <font>‚ÄúThe Pattern Method pattern is easy to use in practice, but it is not flexible enough.</font>  <font>The Strategy pattern has the necessary flexibility, but you have to introduce an additional class, create an additional object and incorporate it into the system. Therefore, the choice between these patterns depends on whether you need the flexibility of the Strategy or you are ready to be satisfied with the simplicity of the Template method. ‚Äù</font> <br><br>  Insufficient flexibility of the pattern The templating pattern is not its flaw, but its particularity.  Since developing classes for convenient extension by successors is not an easy task, the base class can provide a framework in which the heir will have to squeeze. <br><br><h4>  Unit tests </h4><br>  Bob Martin is a well-known supporter of TDD, but I prefer to think about design in terms of contracts.  As a result, there are several bugs in the code of the book, since the implementation was "driven" by tests, and not by preconditions and postconditions.  In more detail about it it is possible to read in article: <a href="http://sergeyteplyakov.blogspot.co.uk/2013/03/blog-post.html">"Contracts, a state and unit tests"</a> . <br><br>  With unit tests for Martin there are a few problems.  First, a huge number of tests go to the database, which makes them essentially integration tests.  I do not know whether in 2006 there was a clear separation between these two concepts, but now the difference between them is more or less obvious. <br><br>  <b>Fallen unit test means bugs in the code or at least the mismatch of the actual behavior of the intended.</b>  <b>A fallen integration test doesn‚Äôt mean anything like that, since this may be a consequence of environmental problems.</b>  <b>That is why unit tests are cutting builds and run on each build, and integration tests are in a separate build and are not run so often.</b> <br><br>  Secondly, Martin leads too many tests written on the principle: they isolated the interfaces of all the classes, they wrote the tests, HAPPINESS.  This approach worries me that after working for a couple of months we will get a code with good coverage, but with a bad design. <br><br>  You can, of course, say: ‚Äúwell, this is still the second edition of the book, and the original of the first edition was released as early as 2002, then everything was different!‚Äù.  But the second edition came out in 2006, and the authors had time to update the material of the book based on the experience gained.  But that's not the point.  At the time of publication of the first edition (more precisely in a year), Evans published <a href="http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Domain-Driven Design</a> , which shows more pragmatic views on design, on tests, on struggle with complexity, and on many other issues.  Even then, in Evans, one can see thoughts about the benefits of immutability, about transferring logic to simple objects (called Value Objects), that one can almost always turn the design around so that complex composite objects become such high-level mediators. <br><br>  As a result, already at the beginning of the null it was known that instead of ‚Äúwe select interfaces and potest‚Äù, there is another approach: select behavior into classes that do not depend on anyone (neither on other classes, nor on the external environment);  then create higher-level classes that are built on the basis of proven lower-level classes.  As a result, we get a hierarchical system built on a solid foundation with the interfaces selected only when the application needs the ability to substitute behavior during execution. <br><br>  <b>NOTE</b> <br>  I wrote more about this in the article <a href="http://sergeyteplyakov.blogspot.com/2013/04/vs.html">‚ÄúTesting design vs.</a>  <a href="http://sergeyteplyakov.blogspot.com/2013/04/vs.html">Good design</a> . <br><br>  Interestingly, on the same topic, contracts vs.  unit tests, there is an interesting InfoQ video featuring Martin and Coplien: <a href="http://www.infoq.com/interviews/coplien-martin-tdd">Coplien and Martin Debate TDD, CDD and Professionalism</a> <br><br><h5>  A good example of terrible tests. </h5><br>  Well, the book provides examples of tests for which you need to select a keyboard.  Here is one of them: <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LoadingEmployeeDataCommand</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { operation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LoadEmployeeOperation(<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); SqlCommand command = operation.LoadEmployeeCommand; Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">"select * from Employee "</span></span> + <span class="hljs-string"><span class="hljs-string">"where EmpId=@EmpId"</span></span>, command.CommandText); Assert.AreEqual(<span class="hljs-number"><span class="hljs-number">123</span></span>, command.Parameters[<span class="hljs-string"><span class="hljs-string">"@EmpId"</span></span>].Value); }</code> </pre> <br><br>  This test does not check anything: if it passes, it means that the code of the test and the class is the same, but it does not say that the operation is implemented correctly.  Nevertheless, the test should be more abstract in comparison with the code under test, otherwise there will be no sense from them. <br><br><h4>  .NET </h4><br>  I already mentioned that when reading a book, it is felt that this is the second edition of the book, which was slightly adapted to C #, and not fully reworked using the idioms of a new programming language.  In many places, Java idioms are used (method names with a small letter, CONSTANT_WRITTED_WOT_TAK), the <i>Main</i> method is added to the domain object, occasionally the concept of ‚Äúpackage‚Äù is used instead of assemblies.  The examples lack the standard .NET idioms: for observers, interfaces are used and no events are used;  <i>readonly</i> modifier is not used, classes with resources do not implement <i>IDisposable</i> etc;  generalizations are not used, although they appeared a year before the book appeared. <br><br>  One of the most epic blunders is given in the next box, ‚ÄúWhere did I go?‚Äù. <br>  <font>‚ÄúGenerally speaking, it is not necessary to include in the name some kind of orthogonal concept, especially if this concept can change.</font>  <font>For example, what if we want to make <i>ICommand</i> not an interface, but an abstract class?</font>  <font>Will we look for all references to <i>ICommand</i> and replace them with <i>Command</i> ?</font>  <font><b>Are we going to recompile and deploy all the assemblies affected by this change?</b></font>  <font>"</font> <br><br>  IMHO, <b>it's easier to come to someone else's monastery with its own charter, than to come to another language with your idioms</b> .  If I program in Java, then I use local idioms for naming regardless of my own preferences, this is RIGHT!  But most of all in this box I like the argument. <br><br>  Junior Martin apparently did not tell the elder that the transition from the interface to the abstract class is a potential breaking change, regardless of whether we change the name of the entity or not: in any case, we will need to ‚Äúre-compile and deploy all the assemblies affected by this change‚Äù!  Attempting to replace the assembly on the fly with a similar change will lead to the collapse of the application! <br><br><h5>  PrimeGenerator </h5><br>  Martins are very fond of the condition, therefore, when refactoring a generator of primes (p. 80), static fields were highlighted: <br><br>  <font>‚ÄúAllocating three functions made me convert some local variables to static class fields.</font>  <font>As a result, it became much clearer which variables are actually local, and which ones have a wider scope. ‚Äù</font> <font><br><br></font> <pre> <font><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">PrimeGenerator</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>[] crossedOut; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] result; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">[] </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GeneratePrimeNumbers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//    crossedOut private static void UncrossIntegersUpTo(int maxValue) { } //  result   crossedOut private static void PutUncrossedIntegersIntoResult() { } }</span></span></code></font> </pre> <font><br><br></font>  <font>I do not understand the love of preserving intermediate results in the fields.</font>  <font>If you want to separate local variables from non-local variables, then the method arguments are suitable for this, it is not necessary to use a shared state for this.</font> <font><br><br></font>  <font>The shared state complicates the code (after all, now the order of calls is important), and also makes it impossible to get primes in parallel from different threads, which violates the generally accepted rule of the ‚ÄúFramework Design Guidelines‚Äù, which states that static class members must be thread-safe.</font> <font><br><br></font>  <font>I'm not saying for the fact that the code does not use blocks of iterators that came out a year before the release of this book.</font> <font><br><br></font> <h5>  <font>SocketServer</font> </h5> <font><br></font>  <font>This code is discussed on page 251 and is not in the examples that come with the book.</font>  <font>I put it <a href="https://gist.github.com/SergeyTeplyakov/8104932">here</a> .</font> <font><br><br></font> <pre> <font><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">SocketService</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Serve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Socket s</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SocketServer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TcpListener serverSocket = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Thread serverThread = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SocketService itsService = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArrayList threads = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SocketServer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> port, SocketService service</span></span></span><span class="hljs-function">)</span></span> { itsService = service; IPAddress addr = IPAddress.Parse(<span class="hljs-string"><span class="hljs-string">"127.0.0.1"</span></span>); serverSocket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TcpListener(addr, port); serverThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadStart(Server)); serverThread.Start(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Close</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { running = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; serverThread.Interrupt(); serverSocket.Stop(); serverThread.Join(); WaitForServiceThreads(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Server</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { serverSocket.Start(); running = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (running) { Socket s = serverSocket.AcceptSocket(); StartServiceThread(s); } } <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code></font> </pre> <font><br><br></font>  <font>There are two types of problems in the code: firstly, there are trivialities, such as the lack of readonly, the absence of the <i>IDisposable</i> interface, the use of interfaces instead of events to implement the observer, the manual manipulation of threads when there are asynchronous operations from the first version of the .NET Framework and the absence of exception handling.</font> <font><br><br></font>  <font>But most importantly, this code is an example of poor design.</font>  <font>The responsibilities of the classes <i>SocketServer</i> , <i>ServiceRunner</i> and the heirs of <i>SocketService</i> are blurred and not clear.</font> <font><br><br></font>  <font>For example, we have a class that implements the <i>SocketService</i> interface.</font>  <font>What can be done in the <i>Serve</i> <i>(Socket</i> <i>s</i> <i>)</i> method?</font>  <font>Somehow he says that this method is called in another thread?</font>  <font>Not.</font>  <font>How can he know that the parent socket is closed and he also needs to interrupt the execution of his operations?</font>  <font>And how to understand, is it possible to call blocking methods of type <i>Receive</i> in this method, or do you need to twist your own infinite loop?</font> <font><br><br></font>  <font>It can be seen that if it is impossible to write tests to the code, then the resulting design of the Martins will be terrible.</font>  <font>This code does not effectively use the built-in capabilities of the .NET Framework, but the funny thing is that it just does not work!</font>  <font>Look at the <i>Close</i> method, <i>running</i> there is set to <i>false</i> , and then <i>thread</i> <i>.Interrupt</i> <i>()</i> is called, which will not lead to anything, since the current server thread now hangs waiting for a new connection in the <i>serverSocket</i> <i>.AcceptSocket</i> <i>()</i> method.</font>  <font>A similar problem will <i>occur</i> with all client sockets if they call <i>s</i> <i>.Receive</i> <i>()</i> in the <i>Server</i> method: this whole city cannot be closed.</font> <font><br><br></font> <h5>  <font>Treemap</font> </h5> <font><br></font>  <font>The full code can be found <a href="https://gist.github.com/SergeyTeplyakov/8104967">here</a> .</font> <font><br><br></font> <pre> <font><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TreeMapNode</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> LESS = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GREATER = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IComparable key; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> TreeMapNode[] nodes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TreeMapNode[<span class="hljs-number"><span class="hljs-number">2</span></span>]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelectSubNode</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IComparable key</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (key.CompareTo(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.key) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) ? LESS : GREATER; } }</code></font> </pre> <font><br><br></font>  <font>Everything is not so fatal here, but the use of java-style constants, the lack of the <i>readonly</i> keyword for <i>key</i> and <i>nodes</i> fields, and the unsuccessful names of constants: <i>LESS</i> and <i>GREATER</i> , which in fact determine the subtree index, are striking.</font> <font><br><br></font> <h3>  <font>Conclusion</font> </h3> <font><br><img src="http://habrastorage.org/storage3/c90/99a/022/c9099a022696a8d80b7a4305abea3d11.jpg"><br><br></font>  <font>Someone asked me why I rated this book on <a href="https://www.goodreads.com/book/show/84983.Agile_Principles_Patterns_and_Practices_in_C_">goodreads.com</a> at 2 points.</font>  <font>Well, in that case I have another question: is it really worth putting more?</font> <font><br><br></font>  <font>I am very frightened that this book is almost a classic, although it contains a set of questionable principles, with questionable rules about when to follow them and when not.</font>  <font>In the book, a vague description of patterns that are not tied to the principles described earlier.</font>  <font>In the book, two buckets of slapstick that tests are driven by the example of fragile tests and code with a bunch of errors that would not exist if the design of the class had been thought at least a little in advance.</font>  <font>The book is aimed at C # programmers, but even by the standards of 2006, the code in it is no good.</font> <font><br><br></font>  <font>I am afraid that this book can lead to serious manifestations of the <a href="http://sergeyteplyakov.blogspot.co.uk/2013/09/blog-post_24.html">cult of cargo</a> , if it is read by an inexperienced developer, and she really does not give anything to the experienced.</font>  <font>So it turns out that the main advantage of this book is that it allows you to adequately participate in trolling about SOLID and other principles, but no more.</font> </div><p>Source: <a href="https://habr.com/ru/post/208454/">https://habr.com/ru/post/208454/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208444/index.html">We help the robot sorter in the mail</a></li>
<li><a href="../208446/index.html">Improved UPX compression ratio</a></li>
<li><a href="../208448/index.html">Agency DARPA launched a project to create biodegradable electronics, self-destructing on command</a></li>
<li><a href="../208450/index.html">The revived "moonwalker" or a toy, about which not all have heard</a></li>
<li><a href="../208452/index.html">The desired Start button will return to Windows 8.2</a></li>
<li><a href="../208458/index.html">Introducing Github Attendance Analytics</a></li>
<li><a href="../208460/index.html">Project Christine: Razer Liquid-cooled Modular PC</a></li>
<li><a href="../208464/index.html">C #. Sort Type Members with ReSharper</a></li>
<li><a href="../208466/index.html">ROBOT based on: android, arduino, bluetooth. Start</a></li>
<li><a href="../208468/index.html">Kali Linux introduces an ‚Äúemergency‚Äù password leading to full disk encryption</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>