<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blue Shift or iOS application launch time optimization. Yandex lecture</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It would seem that when you download the application, you can suffer a second or two. But when your program is used frequently, and in competitors - a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blue Shift or iOS application launch time optimization. Yandex lecture</h1><div class="post__text post__text-html js-mediator-article">  It would seem that when you download the application, you can suffer a second or two.  But when your program is used frequently, and in competitors - an analogue from the manufacturer of the OS itself, even the launch time starts to affect.  Yandex developer Victor Bryksin <a href="https://habrahabr.ru/users/bobermaniac/" class="user_link">bobermaniac</a> spoke at a meeting of the CocoaHeads community in the office of our colleagues at Mail.Ru and told how to make the iOS application run faster. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/sYkiM3XEiTg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - For a long time I was engaged in the development of Yandex Browser.  Actually, from the optimization of the start time of this application, my report was born. <br><a name="habracut"></a><br>  The problems we solved in the browser are common to all iOS applications.  If you take the phone and run something, then, most likely, you will watch the splash screen for 2-3 seconds.  My personal record holder is 7 seconds, I will not call the application, but this is amazing: while you open and look at the beautiful picture, you have already forgotten what you wanted to do with this application. <br><br>  Our browser could not afford this.  The browser has a number of scripts that require the application to respond immediately.  The user should be able to quickly, on the fly, open the browser, drive something into the search line, get an answer or read something on the run.  Probably, you are also on the run, in subway crossings, reading some articles in fragments, because there is not much time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Naturally, the browser has features that we cannot just get rid of - for the sake of them, users use our product. <br><br>  In addition, we have competitors.  And one of our main competitors, the iOS-built browser Safari, which hangs over us with a hundred-ton weight, occupies the same dominant position as IE had in Windows at one time, if you remember.  We also have to compete with it, so we need to constantly reduce the launch time of our browser. <br><br>  At one time we approached this problem with the naivety peculiar to all developers.  In their opinion, to optimize something, the profiler and own experience is enough. <br><br>  At some point, the manager came up to us and said that the application was dumb, slow, everything was bad.  The developers said - ok, let's see, optimize, everything will be fine. <br><br>  Optimized.  The result was an assembly, which the testing itself took and sat down with a stopwatch, because it was necessary to check that we did everything correctly, did not fix it anywhere, and everything starts faster.  With a stopwatch, they measured the start time, made sure that it became smaller, everything is fine. <br><br>  In the future, this approach has evolved.  Instead of planting a tester and giving him a stopwatch, we started using video.  They shot the video before optimization and after, superimposed on each other, looked frame by frame, where what element of the browser appears, how it reacts, is everything good? <br><br>  In the future, the manager felt in his video editor.  He started shooting five videos before, five videos after, to level the effects associated with randomness.  Everyone knows that sometimes the start time depends on the weather on Mars, and nothing can be done about it. <br><img src="https://habrastorage.org/webt/5c/wz/sg/5cwzsg6kuipmq_c3oxmanljv4cw.jpeg"><br>  The manager acquired the skills of a video editor, but this did not help us.  This approach had a huge amount of problems. <br><br>  First of all, we remembered optimization only when everything started to slow down.  We optimized, and after a while it all degraded.  Someone makes other changes, new features appear, and over time, everything again becomes very bad.  And we did not have the tools to control it.  And if we do not want to lose some effect, we need to exercise continuous monitoring.  Unfortunately, the version with the video that we used is laborious enough to use it constantly.  He did not suit us. <br><img src="https://habrastorage.org/webt/h6/3n/ns/h63nnsshqsxpfxt4lfbljcxoiu8.jpeg"><br>  Therefore, today we will talk about how to build the launch time optimization process correctly, if you really want to get some effect and maintain it for a long time. <br><br>  First of all, we will talk about metrics - without them, no process is possible at all, especially such as optimization. <br><br>  We will talk about the fact that from the experience of others managed to adapt for themselves.  Let's talk about the project Fake UI - thanks to him we managed to build an interface that literally flies into the face of the user and says: "Work with me faster." <br><br>  Briefly tell about the elimination of hot spots.  This is a topic in which everybody who has been involved in optimization has a little understanding.  About the lazy services that brought us a lot of problems, and about the assessment, which we end up with. <br><br>  Let's start with the metrics.  Here is the first and most important thing to go with this report.  If you do not have convenient metrics, you can never make a convenient optimization that will be supported.  An example from a video.  The manager needs to spend a lot of time to remove the metrics from the video, we could not shoot them all the time.  As a result, it was done somehow, everything was lost, and most importantly, we could not find in the interval where this or that optimization was lost.  Therefore, the more often we remove metrics, the better for us. <br><br>  Metrics should be removed quickly, often, be simple and understandable.  For the browser, we all divided the metrics divided into two large groups - main and auxiliary.  The main ones are those that are directly sensed by the user, which influence his or her perception of the browser, and those that it sees.  They should be quantitative, it is easy to work with numbers, you can add them, subtract, even subtract square roots, but I personally did not try.  And most importantly - they must be objective.  As the tester's example with a stopwatch showed, too many stochastic factors lead to the fact that the metric, instead of showing the effect of the improvements being made, begins to show the temperature outside the window. <br><br>  Core metrics are what we want to improve during the product development process.  There are auxiliary metrics.  They are very similar to the main ones, except for the fact that they already exist in the developer‚Äôs world.  These are some things that are not visible to users, but the developer will be told about what is happening in his product, much more than the usual number. <br><img src="https://habrastorage.org/webt/qh/sa/os/qhsaosdhnqwe1q8nqy35ht_qmk8.jpeg"><br>  For Yandex.Browser, we selected four metrics.  Two of them are auxiliary, there are for the developer, and two main ones. <br><br>  All these metrics are numbers that show the number, conditionally, of seconds that pass from the moment when the user pokes on the application icon. <br><br>  The first point we take off is the moment when Main starts.  The second, as soon as the RootViewController appeared in the window hierarchy and it has a View.  We remove the point at which ViewWillAppear is running. <br><br>  The third metric is ViewDidAppear.  The fourth, most interesting, is that at the end of ViewDidAppear we launch the main stream using the Dispatch Async block.  And the moment when it is executed, this is the fourth position, which we called the UI Ready, the most important.  We will often continue to use in the future.  And we will give the main estimates on it. <br><br>  Briefly about what each of these numbers mean.  Main shows the most understandable thing - this is the moment when we started the application, the whole image is launched into memory, load and initialise occur, all that concerns the dynamically loaded libraries is there.  It shows the effect of those libraries that we have loaded into the project. <br><br>  After that, application: didFinishLaunchingWithOptions is executed, naturally.  Some services are configured that will be used in the future, and after that comes the ViewDidAppear moment. <br><br>  Therefore, the second number of ViewDidAppear shows the effect of the configured, already our own user services. <br><br>  In turn, ViewDidAppear as the main metric shows the moment when the user finally saw on the screen the interface of the application with which he intends to work. <br><br>  Finally, UI Ready.  At the moment when the interface is shown, it can be blocked by a huge amount of code that still needs to be executed on the main thread.  Because of this, the user sees, but can not touch. <br><br>  The fourth metric of UI Ready, when we plan a block on the main thread, shows when it has finally unloaded, and the user can interact with our application. <br><br>  The main hypothesis from which we repelled that if we reduce the UI Ready metric, that is, the moment when the user can work with the application, the user will notice, understand that for him it is good, he can enjoy the product more.  This means that we will grow product metrics, such as the return percentage.  That is, we have to observe a correlation on the graphs: the start time of the UI Ready goes down - the product metrics go up. <br><br>  To evaluate the effect of optimization, we collect metrics from developers.  As soon as the developer does something, we take his assembly, after the pull request has joined the master, we are constantly assembling the assembly from the master and sending it to a special testing stand.  This is a regular Mac connected to the network to which the device is connected, we had an iPad Mini based on iOS 8, as the most braking device at that time.  An assembly is put on it, and it is launched several hundred times.  Each time we get some numbers on all four metrics, collect them, average them and send them to a special stand, where a beautiful graph of how time changes over time is built using these numbers.  Later I will show these graphs. <br><br>  We use these numbers to quickly understand what the changes we are making to the project lead to. <br><br>  Naturally, we do it for users, and we collect metrics from users too.  Those users who allowed sending anonymous statistics, we take these numbers and send them to ourselves.  Naturally, the user can not be asked to run our application 200 times, but the number of users basically eliminates the effect of randomness here. <br><br>  I hope you understand that metrics are important.  And when you have such a problem, you will use this advice. <br><br>  As for the experience that we have taken over from other people, first of all I would like to refer to the <a href="https://youtu.be/REaGfwq3Q5Y">report of my colleague Nikolay Likhogrud</a> - ‚ÄúOptimization of launch time of iOS applications‚Äù. <br><img src="https://habrastorage.org/webt/jt/mi/b2/jtmib232bnub-m41pud_srz7_l8.jpeg"><br>  It primarily concerns the launch time of system things, such as loading dynamic libraries, as I said at the beginning, the Main metric, image loading.  All this is very well described there, and we also used his advice, abandoned the dynamic libraries in the browser, everything is statistically linked. <br><br>  Naturally, we abandoned Swift when we did all this, we still had iOS 7, for which Swift support strongly influenced the metrics and led to a huge increase in all numbers.  We tried to use it, saw growth and abandoned this idea quickly enough. <br><br>  Surprisingly, the improvement in speed showed just the transfer of resources from raw resources ... Who knows, we can simply put a picture in xcassets that are loaded much faster than raw resources.  And for projects with a long history, when some things just don‚Äôt get touched by the fact that nobody needs it, it may be relevant if you still have raw resources in the project, I recommend to transfer them to xcassets, and you will get it out of the blue performance gain. <br><br>  Unfortunately, we have libraries that negatively affect the start time.  Apparently, due to the fact that multiple loads are performed there and a similar thing.  First of all, we encountered this when using the Facebook SDK, for which we used lazy loading and late binding, in which we do not interact with this library directly, but use Dial D and other such things. <br><br>  I will not have such a hardcore, like my colleagues.  There will be many beautiful pictures. <br><img src="https://habrastorage.org/webt/i6/gc/kd/i6gckdczvhb_qo7_c2hm3pzamiy.jpeg"><br>  The first problem in the browser is the kernel issue.  Many people know or guess that the browser is based on the Chromium core, there is the code from our guys, it is fumbled between our desktop browser, mobile browser, and provides a lot of functionality, without which the browser would not be very useful. <br><br>  The problem with the iOS version is that the kernel for iOS is a monolith.  This is a large amount of code that loads simultaneously, works for a while, and only when it finally loads can we provide the user with some kind of functionality. <br><br>  It was impossible to put up with it.  The user seems to have seen the interface, but the kernel did not boot, the interface is locked, he can do nothing. <br><br>  We decided to do something about it. <br><br>  The first idea we had was - what if it was cut out?  If the core slows down, let's just throw it out and there will be no problems, everything will be fine. <br><br>  We did not even try.  It is clear that when the kernel gives you a huge amount of reusable functionality, then throwing it out would be writing it from scratch, but using your own resources.  To go for it is pointless, throwing out code that works to write another one that will work worse. <br><br>  We went the other way.  If there is a kernel-dependent UI that can't do anything without it, why not give the user a different UI?  Small, which may not be able to do everything, but can work fine without a kernel, and which will allow the user to execute some set of scenarios characteristic of the mode when we need to quickly open the application and quickly do something in it. <br><br>  Naturally, it will be interactive, it will be possible to write in it, and it should switch transparently to a large UI as soon as the kernel is loaded. <br><img src="https://habrastorage.org/webt/hz/o-/ch/hzo-chbtgxiqrhd6t3usszyhkla.jpeg"><br><h5>  <sub><sup><a href="https://brughela.deviantart.com/art/Complex-mechanism-265556164">Deviantart link</a></sup></sub> </h5><br>  How did we do it with an example of such a component as Omnibox? <br><br>  Everyone knows or guesses that the browser consists of a WebView and a text field for entering a request.  Naturally, it is not.  The field for entering a query is called Omnibox.  The kernel gave a lot of things, such as sadgets, beautiful URL formatting, there was also work with the progress bar, and without it all Omnibox was a little functional.  But we really wanted us to give the user the opportunity to take and enter something before the start. <br><img src="https://habrastorage.org/webt/kz/ht/kv/kzhtkvmdbrt3bg4vi4tdy3bmlzs.jpeg"><br>  We took a large Omnibox and divided it into two.  The old Omnibox model remained exactly the same, it also worked with the kernel.  Nearby, we put a new model, which was completely cut off from it, worked with some cached data, we merged them into one large composite that routed calls depending on whether the kernel was loaded or not. <br><br>  While the kernel is not loaded, our calls went to the cached Omnibox and the answers came from there.  As soon as the kernel was loading, we switched. <br><img src="https://habrastorage.org/webt/-o/yj/eh/-oyjeh9cyhduw3xigtbt51a78yi.jpeg"><br>  To prevent the user from feeling that something broke, when he unloaded the browser, then launched it again and saw an empty Omnibox, and just that it was full, we made a small cache.  The large Omnibox, which depends on the kernel, wrote to this cache, and the cached Omnibox, as soon as it was up, read from this cache and gave the user the state with which it remained. <br><img src="https://habrastorage.org/webt/d1/m0/rs/d1m0rsaeykw0l06otbygbcd9qvm.jpeg"><br>  And to support seamless switching, we made a small component that, at the moment when the kernel finally starts, actually synchronizes the Omnibox caching state with the normal one.  And for the user, everything looks as if he just launched a browser, started doing something in it and the browser just works.  He does not even notice the moment of switching. <br><br>  At the same time, the interface started much faster.  As I said before, before the start of the kernel, we just did UserInteractionEnabled = null, and no, dear user, you will not do anything.  Now we resolved UserInteraction, and saw that the problems remained. <br><br>  Unfortunately, in addition to the kernel, we had our own services, written by us.  Some of them also depended on the kernel and were very fond of subscribing to a callback, which signaled that the kernel was finally running. <br><br>  At that moment, when the kernel was loaded, all these services happily ran to initialize, and clogged the main thread, as a result, the interface is there, it would be possible to interact with it, but the main thread is clogged, no message passes into it. <br><img src="https://habrastorage.org/webt/rd/e3/ue/rde3ueziwgxinsko3-m-rp7o-ri.jpeg"><br>  It looked like this.  There were two dozen of such conditional services that did something there, sometimes did a lot.  While there were one or two of them, this was not a problem, but their number was constantly growing along with the growth of the number of features. <br><img src="https://habrastorage.org/webt/mj/aw/t9/mjawt9wr_1vkdzk_sby8evomlta.jpeg"><br>  Chromium.performAfterStartup itself did not do anything, it just took all the callbacks that subscribed to it, and wrote it down to the main stream in a large bundle.  20 services in the main thread - alas, I had to do something. <br><br>  Therefore, we abandoned the simultaneous launch of all services.  The first thing we did, some services stopped waiting Chromium, and were postponed to a later date. <br><br>  Basically, this is all related to statistics and other things that users either do not need or are not necessary right away.  Everything that we could postpone, we postponed for a longer period. <br><img src="https://habrastorage.org/webt/y0/mx/qt/y0mxqtwjhbw2vskrf9srferi0li.jpeg"><br>  We decided that those services that we could not postpone, we will start one at a time - simply allowing the main thread to crank something in between the service launches.  Thus, although the users had an interface that lagged, but at the same time, he had the opportunity to interact with it.  And he was still a little closer to happiness. <br><br>  Unfortunately, the happiness was short-lived, because lazy services appeared. <br><img src="https://habrastorage.org/webt/sf/iq/bv/sfiqbvgvoj7uxbayxwrcgltzrqi.jpeg"><br>  The problem with lazy services is that their launch time is undefined.  On the one hand, this is not a problem, but their advantage, because we can use lazy services then we need to postpone its launch as much as possible until the moment when it is really needed.  But it happens that lazy services, referring to each other, and touching each other, gather in huge packs, start to run as a crowd, in this place a hot spot is formed, which can move to another place if you accidentally touch this lazy service.    ,         ,       ‚Äî     ,     ,       . <br><img src="https://habrastorage.org/webt/kd/c4/vk/kdc4vkw_btypwajmxob1b5wswa4.jpeg"><br>    ,   ,          .   ,  -     ,    . <br><img src="https://habrastorage.org/webt/_r/dw/d9/_rdwd9i9ovtpiwzwfwuftxmh_gi.jpeg"><br>  , , ,            .      ,      -     .  ,    ,      . <br><br>  ,  ,          ,   Promise.     ,     . <br><br>    . <br><img src="https://habrastorage.org/webt/um/db/_u/umdb_ujw3ynu51u-wmtdinpv5vs.jpeg"><br>      .  ,    .     ‚Äî .   ?  ,      ,   ,       ,   -     . ,     ,    ‚Äî  ,      ,         - ‚Äî     ,    7- . <br><br>      50%, 70%  90%.  ,            . <br><br>    ,   ,              .    ,          . <br><br>     ,   . <br><img src="https://habrastorage.org/webt/7o/qg/ny/7oqgny3hmznsraod7vqdn0o2b6m.jpeg"><br>     ,     .  ,   . ,      ,   ,   ,     . <br><img src="https://habrastorage.org/webt/-x/ra/w-/-xraw-w47u4q2ldo1gqzyfwxatu.jpeg"><br>      ,      . <br><br>    Swift   ,      .     ,     Main.      ,        ‚Äî   ,   ,     Swift.    Swift,    . <br><br>       .     ,       . ,   :      ,  ,  pull request,     .        ,         .      , ,   ,  ,    ,       .  - -      ,                 ,   . <br><br>  :      .        ,     ,      .         ,    ,          -   .  Thank. </div><p>Source: <a href="https://habr.com/ru/post/349874/">https://habr.com/ru/post/349874/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349864/index.html">Natasha - a library for extracting structured information from texts in Russian</a></li>
<li><a href="../349866/index.html">W3View - straight web UI path</a></li>
<li><a href="../349868/index.html">Changes in the Java 10 Standard Library</a></li>
<li><a href="../349870/index.html">Parsing ICO TenX: scam or not?</a></li>
<li><a href="../349872/index.html">How are the address tips "Dadata"</a></li>
<li><a href="../349876/index.html">Three ways to update a query in Jira from ScriptRunner using the Jira Java API</a></li>
<li><a href="../349880/index.html">Vue.js + Asp.NETCore + TypeScript application without Webpack</a></li>
<li><a href="../349886/index.html">Quick interactive layout of the hall on canvas</a></li>
<li><a href="../349888/index.html">The digest of interesting materials for the mobile developer # 242 (February 19 - February 25)</a></li>
<li><a href="../349890/index.html">We receive the list of passengers of flights of the largest air carrier of Ukraine</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>