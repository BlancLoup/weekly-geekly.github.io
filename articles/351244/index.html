<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mobile 3D game on Unity3D in less than 90 hours</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings Today I will tell you about my experience of developing a game on Unity for the Android platform, in less than 90 hours, using the example o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mobile 3D game on Unity3D in less than 90 hours</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/m_/vk/d8/m_vkd8tnlsqxhggle2abtfjxz0i.png" alt="image" align="left">  Greetings  Today I will tell you about my experience of developing a game on Unity for the Android platform, in less than 90 hours, using the example of creating a simple runner.  In the process of storytelling, I will touch on some details and key stages, with a description of all possible pitfalls and methods for their solution.  This story describes the process of creating a game for mobile platforms, starting from the concept and ending with the finished product.  I hope it will inspire you to create your own project, or help shed light on some features of the Unity engine.  Without further ado, let's get down to business! <br><a name="habracut"></a><br><h2>  Stage 1: concept </h2><br>  As a rule, novice developers, attacking their first and most significant rakes already at this stage, because before starting to create something, it would be nice to evaluate their own capabilities.  Just ask yourself a question: do you have enough strength, time and skills to create an AAA class project?  The answer is no!  Throw this idea in the back burner, and do not go back to it until you implement a damn dozen of successful projects.  By the way, by luck we mean the number of installations from 500 thousand, the rating is over 3.5 on a 5-point scale and commercial success.  For a start, work on simpler ones, I would even say mundane projects, like addictive games style arcades, combining all the criteria we need for a ‚Äúsuccessful‚Äù project. <br><br>  Advantages of addictive games style: <br><br><ol><li>  Addictive, "sticky" gameplay; </li><li>  Lack of plot; </li><li>  Simple and intuitive control, requiring the player a minimum of action; </li><li>  Minimum requirements for graphics. </li></ol><br>  The last point stands apart, since the lion's share of time is spent not on writing code, but on polishing the visual component of the game, which in our case does not play a special role.  Considering the above, I decided to stop at a 3D runner, namely on an odd job like the famous game <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.ketchapp.zigzaggame%26hl%3Dru">ZIGZAG</a> , only better. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Stage 2: Sketching </h2><br>  Here we come to the most important stage of development, and while a disappointing smile has not yet disappeared from your face, let me remind you that a sketch is a product vision.  Having created it, you actually approve the technical task of the future game, thanks to which all further shamanism and dancing will proceed precisely from this task.  The degree of elaboration of the sketch to determine you and only you.  After all, you create this sketch for yourself, not for an art gallery.  At this stage, I just take a pen and notebook, and then begin to draw, occasionally leaving brief comments and explanations: <br><br><img src="https://habrastorage.org/webt/ed/zk/xv/edzkxvelvihcktgpir57d8ybzpk.jpeg" alt="image"><br><br>  From the outline it is clear that the game is designed for mobile platforms, and it will be launched in portrait mode.  The gameplay is also simple-minded: the player‚Äôs task is to overcome dangerous ground on the car provided by the game, collecting crystals on the way.  For each collected crystal and successfully passed the turn, the player receives a reward in the form of bonus points.  Touching the screen causes you to change the direction of movement of the vehicle along the X and Z axes. <br><br><h2>  Stage 3: prototyping </h2><br>  Having at hand a detailed plan of action, you can safely begin to create a "mocap" or a prototype of the future game.  In essence, this stage is the beginning of work with Unity, and it should be started with setting up the environment.  Here is how I set it up: <br><br><img src="https://habrastorage.org/webt/q5/4x/tk/q54xtknhzqb-pmf7d1myx0qjfiw.png" alt="image"><br><br>  On the left side of the screen are the editor Scene and Game.  The latter displays exactly how the game looks on devices.  On the right side: the Hierarchy and Inspector panels, and just below are the Project and Console panels. <br><br><h2>  Stage 3.1: under the hood </h2><br>  Attention!  Below will be described the simplest code for the implementation of the game, designed for beginners, and demonstrating how quickly and simply you can achieve results in Unity.  The final game code is implemented on a deeper knowledge of the language, including problems of data storage, optimization and monetization of the project, however, for obvious reasons, this article will not talk about them.  We will write all the scripts in C #, and for those who are not interested, I suggest boldly moving on to <b>Stage 4: visual design</b> <br><br>  My prototyping always begins with blanks, that is, as actors, I always use primitive elements, like cubes and spheres.  This approach significantly simplifies the development process, allowing you to abstract from everything that is not related to the mechanics of the game.  In the first step, we form a basic understanding of the appearance of the future game, and since, as planned, our game is created in an isometric style, the first thing we need to do is set up the camera.  Here we come to one of the key features of Unity.  The fact is that you can experiment with the camera settings for a long time, selecting the necessary values ‚Äã‚Äã... But it is easier to simply set your favorite view using the View panel and then activate GameObject -&gt; Align With View, after which your camera will immediately take the necessary values.  Here is such a shortcut from the creators of Unity. <br><br><img src="https://habrastorage.org/webt/gq/pu/2g/gqpu2gw4johs6wor-b-t2ahrd2g.png" alt="image"><br><br>  So, the scene is ready, but how to give the character a movement?  To begin with, we will perform some manipulations with the Sphere object, adding components such as Rigidbody and the newly created sphereBehavior script to it.  Do not forget to disable the Use Gravity checkbox, since at this stage we will not need it. <br><br><img src="https://habrastorage.org/webt/1_/24/8n/1_248nuseyrw16w1aswx39-vd9w.png" alt="image"><br><br>  In short, the Rigidbody component allows an object to experience all the charms of the physical world, such as mass, gravity, gravity, acceleration, etc.  That is why for us it is so important!  And now, to make the body move in the direction we need, we only need to slightly change the velocity parameter, but we will do this with the help of the code.  Let's make the sphere move along the X axis, for this we will make changes to the sphereBehavior script: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">sphereBehavior</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Rigidbody rb; <span class="hljs-comment"><span class="hljs-comment">//    Rigidbody private float speed = 5f; //    void Start() { rb = GetComponent&lt;Rigidbody&gt; (); //    Rigidbody } void Update() { rb.velocity = new Vector3 (speed, 0f,0f); } }</span></span></code> </pre> <br>  In Unity, bodies describe their position and direction using special vectors that store values ‚Äã‚Äãalong the x, y, and z axes.  By changing these values, we achieve the direction or position of a particular body we need.  The string <b>rb.velocity = new Vector3 (speed, 0f, 0f)</b> sets a new direction for the body along the X axis, thereby giving our sphere the direction we need. <br><br>  If you did everything exactly as I did, then your sphere will go on an endless journey along the X axis, at a speed of speed. <br><br>  Now let's make our sphere change its direction, with each click of the left mouse button, as it is implemented in the game ZIGZAG.  To do this, we‚Äôll go back to the sphereBehavior code and change it as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">sphereBehavior</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Rigidbody rb; <span class="hljs-comment"><span class="hljs-comment">//    Rigidbody private bool isMovingRight = true; // ,     private float speed = 5f; //    void Start() { rb = GetComponent&lt;Rigidbody&gt; (); //    Rigidbody } void changeDirection() { if (isMovingRight) { isMovingRight = false; } else { isMovingRight = true; } } void Update() { if(Input.GetMouseButtonDown(0)) { changeDirection(); } if (isMovingRight) { rb.velocity = new Vector3 (speed, 0f, 0f); } else { rb.velocity = new Vector3 (0f, 0f, speed); } } }</span></span></code> </pre> <br>  Let us agree that when a sphere moves along the X axis, this movement is called ‚Äúright‚Äù movement, and along the Z axis - ‚Äúleft‚Äù.  Thus, we can easily describe the direction of our body with the special boolean variable isMovingRight. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { changeDirection(); }</code> </pre> <br>  This piece of code tracks the left mouse button, and if the key was pressed, runs the <b>changeDirection ()</b> function, with simple logic: if at the time the left mouse button was clicked, the isMovingRight variable was true, now it is false and vice versa.  Let me remind you that the Boolean variable allows us to answer one simple question: is the statement that the body moves along the X axis is true or not?  In other words, pressing the left mouse button constantly changes the value of isMovingRight, then to true (the body moves to the right), then to false (the body moves to the left). <br><br>  Alternatively, the <b>changeDirection ()</b> function can be written in one line: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changeDirection</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { isMovingRight = !isMovingRight; }</code> </pre> <br><br>  And the last thing that needs to be done is to rewrite the method of driving direction, taking into account the isMovingRight variable: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isMovingRight) { rb.velocity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3 (speed, <span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rb.velocity = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3 (<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>, speed); }</code> </pre> <br><br>  If isMovingRight is true (if the sphere is actually moving to the right), then the velocity value is taken by the new direction vector rb.velocity = new Vector3 (speed, 0f, 0f);  If isMovingRight is false, then the body no longer moves to the right, which means it's time to change the direction vector to rb.velocity = new Vector3 (0f, 0f, speed); <br><br>  Start the game, do a few mouse clicks, and if you did everything exactly as I did, you will see how the sphere begins to describe the zigzags. <br><br>  Cool?  Of course not!  After all, the sphere is moving, and we stand still.  Let's modify the game so that we can move with the sphere and not lose sight of it.  To do this, we need to create a cameraFollow script and attach it to the Main Camera object: <br><br><img src="https://habrastorage.org/webt/z2/ln/ic/z2lnicrtq5putpkgyamww4btynk.png" alt="image"><br><br>  But the script code of cameraFollow: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">cameraFollow</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject player; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 offset; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { offset = transform.position - player.transform.position; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.position = player.transform.position + offset; } }</code> </pre> <br>  How to carry out tracking object?  First, we need to calculate the offset difference between the Camera and Sphere objects.  To do this, it is enough to subtract the coordinates of the sphere from the position of the camera, and save the resulting difference in the variable offset.  But first, you need to get access to the coordinates of the sphere.  To do this, we need the player variable, which is a simple GameObject.  Since our sphere is in constant motion, we must synchronize the coordinates of the camera with the coordinates of the sphere, adding on the previously obtained offset.  It remains only to indicate in the player field our object of tracking, and you can safely admire the result.  Just drag the Sphere object into the Player field of the cameraFollow script, as shown in the picture (the Main Camera must remain selected): <br><br><img src="https://habrastorage.org/webt/kp/26/re/kp26repi9o0gtoz-9vynvkvz2di.png" alt="image"><br><br>  Now, let's think about the generation of the road along which our sphere could move, because now it literally floats in the air.  Let's start with setting up a Cube object, representing, in our opinion, a stretch of path. <br><br><img src="https://habrastorage.org/webt/5x/7j/kg/5x7jkgez1rhkgjiyptrcjqinnvw.png" alt="image"><br><br>  <i>If there is no Ground tag in your list, then you need to create it in the Add Tag tab ...</i> <br><br>  The next thing we have to do is to create a special folder called Prefabs in the root of the project, and drag our Cube into it, directly from the inspector.  If after this, the name of the Cube object became blue, it means that you did everything correctly. <br><br><img src="https://habrastorage.org/webt/4j/fp/3f/4jfp3fmojkonkhgqjmyrxqsp_mc.png" alt="image"><br><br>  Prefabs are a special type of object that allows you to store a GameObject, as well as all its values ‚Äã‚Äãand properties in one place.  Prefabs allow you to create an infinite number of objects, and any change to it immediately reflects on all its copies.  In other words, we can now call a section of the Cube path, directly from the Prefabs folder, as many times as necessary. <br><br>  Now let's create an empty GameObject, (right-click on the Hierarchy) rename it to RoadContainer and attach the roadBehavior script just created to it: <br><br><img src="https://habrastorage.org/webt/zx/e_/g4/zxe_g4appgmxzsj3teesvjf2am4.png" alt="image"><br><br><img src="https://habrastorage.org/webt/d_/_b/yp/d__bypt1vobfvu9j3tp9atap898.png" alt="image"><br><br>  And here is the roadBehavior code itself: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">roadBehavior</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject road; <span class="hljs-comment"><span class="hljs-comment">//    private Vector3 lastpos = new Vector3 (0f,0f,0f); //    void Start() { for(int i=0; i&lt;10; i++) { GameObject _platform = Instantiate (road) as GameObject; _platform.transform.position = lastpos + new Vector3 (1f,0f,0f); lastpos = _platform.transform.position; } } }</span></span></code> </pre> <br>  What is really going on here?  As you can see, we have a variable, which later will be manually tied to our Cube prefab, and there is a Vector3 object that stores the coordinates of the last prefab set (now the values ‚Äã‚Äãare zero). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { GameObject _platform = Instantiate (road) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> GameObject; _platform.transform.position = lastpos + <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3 (<span class="hljs-number"><span class="hljs-number">1f</span></span>,<span class="hljs-number"><span class="hljs-number">0f</span></span>,<span class="hljs-number"><span class="hljs-number">0f</span></span>); lastpos = _platform.transform.position; }</code> </pre> <br>  This section of the code performs the following: as long as i &lt;10, we will take the prefab, set its position taking into account the last position lastpos + position taking into account the X offset, keep the last position.  That is, as a result, we get 10 Cube prefabs set exactly one after the other.  Before checking, do not forget to assign our Cube object from the Prefabs folder to the road variable: <br><br><img src="https://habrastorage.org/webt/wi/ji/nw/wijinwy90ey_z4co8s5xkvioc5a.png" alt="image"><br><br><img src="https://habrastorage.org/webt/al/tr/zv/altrzvdebwdeplxwr_th6i00poo.png" alt="image"><br><br>  Ok, but what to do next?  And then we need to continue installing the blocks in random order.  To do this, we need a random pseudo-random number generator.  Let's tweak the roadBehavior script to reflect the innovations: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">roadBehavior</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject road; <span class="hljs-comment"><span class="hljs-comment">//    private Vector3 lastpos = new Vector3 (0f,0f,0f); //    void Start() { for(int i=0; i&lt;10; i++) { GameObject _platform = Instantiate (road) as GameObject; _platform.transform.position = lastpos + new Vector3 (1f,0f,0f); lastpos = _platform.transform.position; } InvokeRepeating ("SpawnPlatform", 1f, 0.2f); } void SpawnPlatform() { int random = Random.Range (0, 2); if (random == 0) { //     X GameObject _platform = Instantiate (road) as GameObject; _platform.transform.position = lastpos + new Vector3 (1f,0f,0f); lastpos = _platform.transform.position; } else { //     Z GameObject _platform = Instantiate (road) as GameObject; _platform.transform.position = lastpos + new Vector3 (0f,0f,1f); lastpos = _platform.transform.position; } } }</span></span></code> </pre> <br>  The <b>InvokeRepeating (‚ÄúSpawnPlatform‚Äù, 1f, 0.2f) line is</b> designed to activate the <b>SpawnPlatform ()</b> function 1 second after the start of the game, and to call it again every 0.2 second.  As for the function itself, then, as they say, everything is simpler than the steamed turnip!  Every 0.2 seconds, the system makes a random number between the numbers from 0 to 1. If the system has guessed 0 - we install a new prefab on the X axis, and if 1 - then the Z axis. That's all the magic! <br><br><img src="https://habrastorage.org/webt/fh/bx/e5/fhbxe5svgi9lt02_odgggvmnlvy.png" alt="image"><br><br>  Finally, let's make the sphere fall every time it drops out.  To do this, create a new playerFalls script and attach it to our Sphere object: <br><br><img src="https://habrastorage.org/webt/vj/2g/cs/vj2gcs45bncys1bvrjkxcg7sjxy.png" alt="image"><br><br>  And here is the playerFalls script code itself: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">playerFalls</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Rigidbody rb; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { rb = GetComponent&lt;Rigidbody&gt; (); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Physics.Raycast (transform.position, Vector3.down, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit, <span class="hljs-number"><span class="hljs-number">5f</span></span>) &amp;&amp; hit.transform.gameObject.tag == <span class="hljs-string"><span class="hljs-string">"Ground"</span></span>) { rb.useGravity = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { rb.useGravity = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } }</code> </pre> <br>  Raycast is a special kind of laser beam that radiates towards the scene.  In case the beam is reflected from an object, it returns information about the object it encountered.  And this is very cool, because that is how, through such a ray, directed from the center of the sphere downwards, we will check whether we are on the Cube platform or not (we check if the object has the tag "Ground").  And as soon as we leave the regions of the roadway, we automatically activate the Gravity parameter of our sphere (remember how we deliberately turned it off at the very beginning?), After which the sphere, under the influence of gravity, will fall down, ha ha! <br><br><h2>  Stage 4: Visual Design </h2><br>  When all the work on game mechanics is completed, it is time to move to the visual part of the project.  All the same, the gameplay is good, and the pleasant gameplay is even better.  And despite the fact that at the very beginning we outlined the graphics, how far the most important thing was, we still want to add some zest, adding colors to the game being created.  After some deliberation, the following idea came to mind: <br><br><img src="https://habrastorage.org/webt/zf/zh/1k/zfzh1ktsv7ohupr02qtdoedmepw.png" alt="image"><br><br>  According to the plan, you drive a car, rushing across the endless expanses of the sea, fleeing from the oncoming cataclysm.  Procrastination is akin to death, as the platforms now and then strive to topple into the depths of the sea, dragging the player into the abyss of shame and frustration.  Plus, from time to time, the platforms begin to change color, and the car spontaneously increases its speed.  All this is intended to bring into the game a kind of "Challenge".  As it was said, for each successfully completed turn or a collected crystal, the player is rewarded with ‚ÄúInkam‚Äù - the local likeness of salary.  Salary can then be exchanged in the shop for cars with a higher Inkam.  The concept gave the sonorous name "Income Racer". <br><br>  All assets were modeled in Blender, a free 3D editor.  In it, the necessary textures were created, subsequently brought to an acceptable form in Photoshop.  The nice thing was that Unity easily imports 3D models from Blender, without any headaches, making the creation process enjoyable and painless. <br><br><h2>  Stage 5: polishing </h2><br>  Finishing the project - those are still a rake, because there is always a place for something that can be improved, or redone.  Often, it happens that it is at the polishing and finishing stage that the development process loses much of its time, or even comes to a standstill.  The reason is that you are already noticeably tired: the game seems monotonous and not interesting enough.  Sometimes, at the end of development, comes the revelation that you are capable of remaking the game from scratch, improving it at least twice!  Drop those thoughts and think about the plan, how it all began.  It is better to complement the game after the release, by rolling out updates, rather than delaying the development indefinitely.  Otherwise, you risk ruining the project by putting a fat cross on it.  For example, at the time of this writing, the game did not even have an introductory screen.  The reason for this is the fact that according to the plan I could not go beyond the 90 hours allocated for the development process.  Of course, one could spend a few more hours creating the introductory screen, however, he is planning to follow it.  And it is normal that some moments are added to the game after its release. <br><br>  Last, it remains to create the presentation documents: a brief description, video, as well as the game icon.  This stage should be given as much attention as possible, because it is by the icon that users begin to judge your project. <br><br>  The result was what turned out.  Everything about everything was spent a little more than 90 hours, which by the standards of modern geymdev is not so much.  After this time, the game was uploaded to the Play Market and put up for a general trial, this is the story!  If you liked the article, or just have something to talk about, then welcome to the comments.  I will be glad to answer your questions. </div><p>Source: <a href="https://habr.com/ru/post/351244/">https://habr.com/ru/post/351244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351232/index.html">Pygest # 24. News, releases, articles, interesting projects and libraries from the world of Python [March 2018 - April 9, 2018]</a></li>
<li><a href="../351234/index.html">5 errors when developing WebRTC calls from the browser</a></li>
<li><a href="../351238/index.html">5 prioritization techniques for IT teams</a></li>
<li><a href="../351240/index.html">ZalgoFuzzing: Using non-standard payload blurring methods</a></li>
<li><a href="../351242/index.html">The origins of motivation in the management of Agile and SCRUM</a></li>
<li><a href="../351246/index.html">Image Optimization for the web</a></li>
<li><a href="../351248/index.html">Trends of retail at the international exhibition EuroCIS 2018</a></li>
<li><a href="../351250/index.html">Introduction to Postman</a></li>
<li><a href="../351252/index.html">Let's Encrypt began issuing wildcard certificates</a></li>
<li><a href="../351254/index.html">Using environment variables in Node.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>