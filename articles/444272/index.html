<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PyDERASN: as I wrote the ASN.1 library with slots and blobs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="ASN.1 is a standard (ISO, ITU-T, GOST) of a language describing structured information, as well as the coding rules for this information. For me, as a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PyDERASN: as I wrote the ASN.1 library with slots and blobs</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://ru.wikipedia.org/wiki/ASN.1">ASN.1</a> is a standard (ISO, ITU-T, GOST) of a language describing structured information, as well as the coding rules for this information.  For me, as a programmer, this is just another serialization and data presentation format, along with JSON, XML, XDR and others.  It is extremely common in our normal life, and many people encounter it: in cellular, telephone, VoIP communications (UMTS, LTE, WiMAX, SS7, H.323), in network protocols (LDAP, SNMP, Kerberos), in everything that concerns cryptography (X.509, CMS, PKCS-standards), in bank cards and biometric passports, and in many other places. <br><br>  This article discusses the <a href="http://pyderasn.cypherpunks.ru/">PyDERASN</a> : Python ASN.1 library that is actively used in projects related to cryptography in <a href="http://stcnet.ru/">Atlas</a> . <br><br><div style="text-align:center;"><img alt="My own" src="https://habrastorage.org/getpro/habr/post_images/7da/d0f/755/7dad0f755070999a4333d0206e830205.jpg"></div><a name="habracut"></a><br>  In general, it is not worthwhile to recommend ASN.1 for cryptographic tasks: ASN.1 and its codecs are complex.  This means that the code will not be simple, and it is always an extra attack vector.  Just look <a href="https://cve.mitre.org/cgi-bin/cvekey.cgi%3Fkeyword%3Dasn.1">at the list of</a> vulnerabilities in the ASN.1 libraries.  Bruce Schneier in his <a href="https://www.schneier.com/books/cryptography_engineering/">Cryptography engineering</a> also does not recommend using this standard because of its complexity: ‚ÄúThe best-known TLV encoding is ASN.1, but it is incredibly complex and we‚Äôre shy away from it.‚Äù  But, unfortunately, today we have <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D1%2580%25D0%25B0%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25B9">public key infrastructures</a> in which <a href="https://ru.wikipedia.org/wiki/X.509">X.509 certificates</a> , CRL, OCSP, TSP, CMP, <a href="https://en.wikipedia.org/wiki/Certificate_Management_over_CMS">CMC</a> , <a href="https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax">CMS</a> messages, and a lot of <a href="https://ru.wikipedia.org/wiki/PKCS">PKCS</a> standards are actively used.  Therefore, you have to be able to work with ASN.1 if you are doing something related to cryptography. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ASN.1 can be encoded in a variety of ways / codecs: <br><br><ul><li>  <a href="https://en.wikipedia.org/wiki/Canonical_Encoding_Rules">BER</a> (Basic Encoding Rules) </li><li>  <a href="https://en.wikipedia.org/wiki/Canonical_Encoding_Rules">CER</a> (Canonical Encoding Rules) </li><li>  <a href="https://en.wikipedia.org/wiki/Canonical_Encoding_Rules">DER</a> (Distinguished Encoding Rules) </li><li>  <a href="https://tools.ietf.org/html/rfc3641">GSER</a> (Generic String Encoding Rules) </li><li>  <a href="https://www.itu.int/rec/T-REC-X.697/en">JER</a> (JSON Encoding Rules) </li><li>  LWER (Light Weight Encoding Rules) </li><li>  <a href="https://www.itu.int/rec/T-REC-X.696-201508-I/en">OER</a> (Octet Encoding Rules) </li><li>  <a href="https://www.itu.int/rec/T-REC-X.691-201508-I/en">PER</a> (Packed Encoding Rules) </li><li>  SER (Signaling specific Encoding Rules) </li><li>  <a href="https://en.wikipedia.org/wiki/XML_Encoding_Rules">XER</a> (XML Encoding Rules) </li></ul><br>  and a number of others.  But in cryptographic tasks in practice, two are used: BER and DER.  Even in signed XML documents ( <a href="https://en.wikipedia.org/wiki/XML_Signature">XMLDSig</a> , <a href="https://en.wikipedia.org/wiki/XAdES">XAdES</a> ) there will still be Base64-encoded ASN.1 DER objects, as in the JSON-oriented <a href="https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment">ACME</a> protocol from Let's Encrypt.  You can better understand all of these codecs and the BER / CER / DER encoding principles in articles and books: <a href="https://habr.com/ru/post/150757/">ASN.1 in simple words</a> , <a href="https://www.oss.com/asn1/resources/books-whitepapers-pubs/dubuisson-asn1-book.PDF">ASN.1 -</a> <a href="http://www.oss.com/asn1/resources/books-whitepapers-pubs/larmouth-asn1-book.pdf">John Larmouth</a> . <br><br>  BER is a binary byte-oriented (for example, PER, popular in cellular communication - bit-oriented) TLV-format.  Each element is encoded as: a tag ( <strong>T</strong> ag) identifying the type of element being encoded (integer, string, date, etc.), length ( <strong>L</strong> ength) of the content and the content itself ( <strong>V</strong> alue).  BER optionally allows you to omit the length value, setting the particular indefinite length value and ending the message End-Of-Octets with a label.  In addition to length coding, there is a lot of variability in BER in the method of coding data types, such as <br><br><ul><li>  INTEGER, OBJECT IDENTIFIER, BIT STRING, and element length can be unnormalized (not encoded in minimal form); </li><li>  BOOLEAN is true for any non-zero content; </li><li>  BIT STRING may contain ‚Äúextra‚Äù zero bits; </li><li>  BIT STRING, OCTET STRING and all their derived string types, including date / time, can be broken into chunks of variable length, the length of which during (de) coding is not known in advance; </li><li>  UTCTime / GeneralizedTime can have different ways of setting the time zone offset and ‚Äúextra‚Äù zero fractions of seconds; </li><li>  DEFAULT SEQUENCE values ‚Äã‚Äãmay or may not be encoded; </li><li>  Named values ‚Äã‚Äãof the last bits in BIT STRING can optionally not be encoded; </li><li>  SEQUENCE (OF) / SET (OF) can have an arbitrary order of elements. </li></ul><br>  Because of all of the above, it is not always possible to encode the data so that they are identical to the original form.  Therefore, a subset of rules was invented: DER - tightly regulating only one acceptable encoding method, which is critical for cryptographic tasks, where, for example, changing one bit will make the signature or checksum invalid.  DER has a significant drawback: the lengths of all elements must be known in advance during encoding, which prevents streamlined serialization of data.  CER codec is devoid of this disadvantage, likewise guaranteeing an unambiguous presentation of data.  Unfortunately (or fortunately, we don‚Äôt have even more complex decoders?), It didn‚Äôt become popular.  Therefore, in practice, we encounter a ‚Äúmixed‚Äù use of BER and DER encoded data.  Since both CER and DER are a subset of BER, any BER decoder is able to process them. <br><br><h2>  Problems with pyasn1 </h2><br>  At work, we write many Python programs related to cryptography.  And a few years ago there was practically no choice of free libraries: either these are very low-level libraries that allow you to simply encode / decode, for example, an integer and a structure header, or this is the <a href="http://snmplabs.com/pyasn1/index.html">pyasn1</a> library.  We lived there for several years and at first were very pleased, as it allows working with ASN.1 structures as high-level objects: for example, a decoded X.509 certificate object allows you to access your fields through the dictionary interface: cert ["tbsCertificate"] ["SerialNumber"] will show us the serial number of this certificate.  Similarly, you can ‚Äúcollect‚Äù complex objects by working with them as with lists, dictionaries, and then simply call the pyasn1.codec.der.encoder.encode function and get a serialized view of the document. <br><br>  However, flaws, problems and limitations were revealed.  In pyasn1, there were and, unfortunately, errors still remain: at the time of this writing, in pyasn1, one of the basic types, GeneralizedTime, is <a href="https://sourceforge.net/p/pyasn1/mailman/message/36512292/">incorrectly</a> decoded and encoded. <br><br>  In our projects, to save space, we often store only the file path, offset and length in bytes of the object we want to refer to.  For example, an arbitrary signed file will most likely be located in the CMS SignedData ASN.1 structure: <br><br><pre><code class="plaintext hljs">0 [1,3,1018] ContentInfo SEQUENCE 4 [1,1, 9] . contentType: ContentType OBJECT IDENTIFIER 1.2.840.113549.1.7.2 (id_signedData) 19-4 [0,0,1003] . content: [0] EXPLICIT [UNIV 16] ANY 19 [1,3, 999] . . DEFINED BY id_signedData: SignedData SEQUENCE 23 [1,1, 1] . . . version: CMSVersion INTEGER v3 (03) 26 [1,1, 19] . . . digestAlgorithms: DigestAlgorithmIdentifiers SET OF [...] 47 [1,3, 769] . . . encapContentInfo: EncapsulatedContentInfo SEQUENCE 51 [1,1, 8] . . . . eContentType: ContentType OBJECT IDENTIFIER 1.3.6.1.5.5.7.12.2 (id_cct_PKIData) 65-4 [1,3, 751] . . . . eContent: [0] EXPLICIT OCTET STRING 751 bytes OPTIONAL      751  820 [1,2, 199] . . . signerInfos: SignerInfos SET OF 823 [1,2, 196] . . . . 0: SignerInfo SEQUENCE 826 [1,1, 1] . . . . . version: CMSVersion INTEGER v3 (03) 829 [0,0, 22] . . . . . sid: SignerIdentifier CHOICE subjectKeyIdentifier [...] 956 [1,1, 64] . . . . . signature: SignatureValue OCTET STRING 64 bytes . . . . . . C1:B3:88:BA:F8:92:1C:E6:3E:41:9B:E0:D3:E9:AF:D8 . . . . . . 47:4A:8A:9D:94:5D:56:6B:F0:C1:20:38:D2:72:22:12 . . . . . . 9F:76:46:F6:51:5F:9A:8D:BF:D7:A6:9B:FD:C5:DA:D2 . . . . . . F3:6B:00:14:A4:9D:D7:B5:E1:A6:86:44:86:A7:E8:C9</code> </pre> <br>  and we can get the original signed file at an offset of 65 bytes, with a length of 751 bytes.  pyasn1 does not store this information in its decoded objects.  The so-called TLVSeeker was written - a small library that allows you to decode tags and object lengths, in the interface of which we commanded ‚Äúgo to the next tag‚Äù, ‚Äúgo inside the tag‚Äù (go inside the SEQUENCE of the object), ‚Äúgo to the next tag‚Äù, ‚Äútell your offset and the length of the object where we are. "  This was a ‚Äúmanual‚Äù walk on ASN.1 DER-serialized data.  But it was impossible to work this way with BER-serialized data, since, for example, the OCTET STRING byte string could be encoded in the form of several chunk. <br><br>  Another drawback for our pyasn1 tasks is the impossibility to understand by decoded objects whether the specified field was present in the SEQUENCE or not.  For example, if a structure contains a Field SEQUENCE OF Smth OPTIONAL field, then it could be completely absent in the incoming data (OPTIONAL), but could be present, but at the same time be of zero length (empty list).  In general, this could not be figured out.  And this is necessary for a strict check of the validity of the incoming data.  Imagine that any certification authority would issue a certificate with ‚Äúnot quite‚Äù valid data from the point of view of ASN.1-schemes!  For example, the certification center ‚ÄúT√úRKTRUST Elektronik Sertifika Hizmet Saƒülayƒ±cƒ±sƒ±‚Äù in its root certificate went beyond the allowable <a href="https://tools.ietf.org/html/rfc5280">RFC 5280</a> boundaries of the length of the subject component - it cannot be honestly decoded according to the scheme.  The DER codec requires that a field whose value is equal to DEFAULT should not be encoded during transmission ‚Äî such documents occur in life, and the first version of PyDERASN even consciously allowed such invalid behavior (from the DER point of view) for the sake of backward compatibility. <br><br>  Another limitation is the impossibility of easily finding out in which form (BER / DER) one or another object in the structure was encoded.  For example, the CMS standard says that the message is BER-encoded, but the signedAttrs field over which the cryptographic signature is generated must be in DER.  If we decode DER, then we will fall on the processing of the CMS itself; if we decode with BER, we will not know what kind of signedAttrs was.  As a result, it is necessary for TLVSeeker (which has no analogue in pyasn1) to search for the location of each of the signedAttrs fields, and decode it separately, from the serialized view, with DER. <br><br>  The possibility of automatic processing of DEFINED BY fields, which are very common, was very welcome for us.  After decoding an ASN.1 structure, we may have many ANY fields left to be processed further according to a scheme chosen on the basis of the OBJECT IDENTIFIER specified in the structure field.  In Python code, this means writing an if and then calling the decoder for the ANY field. <br><br><h2>  PyDERASN appearance </h2><br>  In the Atlas, we regularly, having found some problems or modifying used free programs, send patches to the top.  In pyasn1, we sent improvements a few times, but the pyasn1 code is not the easiest to understand, and sometimes there were incompatible API changes that hit us.  Plus, we are used to writing tests with generative testing, which was not in pyasn1. <br><br>  One day I decided to suffice it to endure and it‚Äôs time to try to write your own library with __slot __s, offset and perfectly displayed blobs!  Just creating an ASN.1 codec would not be enough - you need to transfer all our dependent projects to each other, and these are hundreds of thousands of lines of code that are fully working with ASN.1 structures.  That is one of the requirements for it: the ease of translation of the current pyasn1 code.  Having spent my entire vacation, I wrote this library, transferred all the projects to it.  Since they have almost 100% coverage with tests, this also meant the full performance of the library. <br><br>  PyDERASN, similarly, has almost 100% test coverage.  Generative testing is used with a remarkable <a href="https://hypothesis.readthedocs.io/en/latest/">hypothesis</a> library.  <a href="https://en.wikipedia.org/wiki/Fuzzing">Fuzzing</a> <a href="http://jwilk.net/software/python-afl">py-afl was also</a> conducted on 32 nuclear machines.  Despite the fact that we have almost no Python2 code left, PyDERASN still maintains compatibility with it and because of this it has only <a href="https://six.readthedocs.io/">six</a> dependencies.  In addition, it has been tested against the <a href="https://habr.com/ru/post/152907/">ASN.1: 2008 compliance test suite</a> . <br><br>  The principle of working with it is similar to pyasn1 - working with high-level Python objects.  The description of the ASN.1 schema is similar. <br><br><pre> <code class="plaintext hljs">class TBSCertificate(Sequence): schema = ( ("version", Version(expl=tag_ctxc(0), default="v1")), ("serialNumber", CertificateSerialNumber()), ("signature", AlgorithmIdentifier()), ("issuer", Name()), ("validity", Validity()), ("subject", Name()), ("subjectPublicKeyInfo", SubjectPublicKeyInfo()), ("issuerUniqueID", UniqueIdentifier(impl=tag_ctxp(1), optional=True)), ("subjectUniqueID", UniqueIdentifier(impl=tag_ctxp(2), optional=True)), ("extensions", Extensions(expl=tag_ctxc(3), optional=True)), )</code> </pre><br>  However, PyDERASN has some sort of strong typing.  In pyasn1, if the field was of the type CMSVersion (INTEGER), then it could be assigned an int or INTEGER.  PyDERASN strictly requires that the object being assigned be exactly CMSVersion.  Besides the fact that we are writing Python3 code, we use <a href="https://www.python.org/dev/peps/pep-0484/">typing annotations</a> , so our functions will not have incomprehensible arguments like def func (serial, contents), but def func (serial: CertificateSerialNumber, contents: EncapsulatedContentInfo), and PyDERASN helps to observe such code. <br><br>  At the same time, PyDERASN has extremely convenient indulgences of this very typification.  pyasn1 did not allow the SubjectKeyIdentifier (). subtype (implicitTag = Tag (...)) field to assign the SubjectKeyIdentifier () object (without the necessary IMPLICIT TAG-a) and had to frequently copy and recreate objects only because of the changed IMPLICIT / EXPLICIT tags.  PyDERASN strictly keeps only the base type - it will automatically insert tags from the existing ASN.1 scheme of the structure.  This greatly simplifies the application code. <br><br>  If an error occurs during decoding, then in pyasn1 it is not easy to understand exactly where it occurred.  For example, in the above-mentioned Turkish certificate we get the following error: UTF8String (tbsCertificate: issuer: rdnSequence: 3: 0: value: DEFINED BY 2.5.4.10:utf8String) (at 138) unsatisfied bounds: 1 ‚áê 77 64 When writing ASN .1 structures can make mistakes, and this makes it easier to debug applications or figure out the problems of coded documents from the opposite side. <br><br>  The first version of PyDERASN did not support BER encoding.  Appeared much later and still does not support UTCTime / GeneralizedTime processing with time zones.  This will come in the future, because the project is written mainly in his free time. <br><br>  Also in the first version there was no work with DEFINED BY fields.  A few months later, this <a href="http://pyderasn.cypherpunks.ru/reference.html">opportunity appeared</a> and began to be actively used, significantly reducing the application code - in one decoding operation it was possible to get the entire structure disassembled to the very depth.  For this, the scheme defines which fields that ‚Äúdefine‚Äù.  For example, the description of the CMS scheme: <br><br><pre> <code class="plaintext hljs">class ContentInfo(Sequence): schema = ( ("contentType", ContentType(defines=((("content",), { id_authenticatedData: AuthenticatedData(), id_digestedData: DigestedData(), id_encryptedData: EncryptedData(), id_envelopedData: EnvelopedData(), id_signedData: SignedData(), }),))), ("content", Any(expl=tag_ctxc(0))), )</code> </pre><br>  says that if the contentType contains an OID with the id_signedData value, then the content field (located in the same SEQUENCE) needs to be decoded using the SignedData scheme.  Why so many brackets?  A field can ‚Äúdefine‚Äù several fields at the same time, as is the case with EnvelopedData structures.  The defined fields are identified by the so-called decode path - it defines the exact location of any element in all structures. <br><br>  Not always want or not always have the opportunity to immediately in the scheme to make these defines.  There may be application-specific cases where OIDs and structures are known only in a third-party project.  PyDERASN provides the ability to specify these directly at the time of decoding the structure: <br><br><pre> <code class="plaintext hljs">ContentInfo().decode(data, ctx={"defines_by_path": (( ( "content", DecodePathDefBy(id_signedData), "certificates", any, "certificate", "tbsCertificate", "extensions", any, "extnID", ), ((("extnValue",), { id_ce_authorityKeyIdentifier: AuthorityKeyIdentifier(), id_ce_basicConstraints: BasicConstraints(), [...] id_ru_subjectSignTool: SubjectSignTool(), }),), ),)})</code> </pre><br>  Here we say that in CMS SignedData for all attached certificates, decode all their extensions (AuthorityKeyIdentifier, BasicConstraints, SubjectSignTool, etc.).  We specify through the decode path, what element should be ‚Äúsubstituted‚Äù defines, as if it were specified in the scheme. <br><br>  Finally, PyDERASN has the ability to work from the <a href="http://pyderasn.cypherpunks.ru/examples.html">command line</a> to decode ASN.1 files and has a rich <a href="http://pyderasn.cypherpunks.ru/reference.html">pretty printing</a> .  You can decode an arbitrary ASN.1, or you can define a well-defined scheme and see something like this: <br><br><img alt="Pretty printing example" src="https://habrastorage.org/getpro/habr/post_images/3dc/981/000/3dc981000f30512bf2ca9488332345d4.png"><br><br>  Displayed information: object offset, tag length, length length, content length, presence of EOC (end-of-octets), BER encoding feature, encoding indefinite-length indication, EXPLICIT tag length and offset (if any), object nesting depth structures, IMPLICIT / EXPLICIT tag value, object name according to the scheme, its basic ASN.1 type, sequence number within SEQUENCE / SET OF, CHOICE value (if any), human readable INTEGER / ENUMERATED / BIT STRING number according to the scheme, value of any basic type , DEFAULT / OPTIONAL flag from the circuit, the sign that the object was automatically decoded as DEFINED BY and for with  gm of OID-and it happened, chelovekochitaemy OID. <br><br>  The pretty printing system is specially designed so that it generates a sequence of PP objects, which are already visualized by separate means.  The screenshot shows the renderer in plain color text.  There are renderer in JSON / HTML format, so that it can be backlit in an ASN.1 browser as in an <a href="https://lapo.it/asn1js/">asn1js</a> project. <br><br><h2>  Other libraries </h2><br>  This was not the goal, but PyDERASN was much <a href="http://pyderasn.cypherpunks.ru/features.html">faster</a> than pyasn1.  For example, decoding CRL files of megabyte sizes can take so long that you have to think about intermediate data storage formats (fast) and change the architecture of applications.  pyasn1 decodes the CRL <a href="https://www.cacert.org/">CACert.org</a> CRL on my laptop in more than 20 minutes, whereas PyDERASN in just 28 seconds!  There is an <a href="https://github.com/wbond/asn1crypto">asn1crypto</a> project aimed at quick work with cryptographic structures: it decodes (completely, not lazily) the same CRL in 29 seconds, but consumes almost twice as much RAM when running under Python3 (983 MiB versus 498 mi), and 3.5 times under Python2 (1677 against 488), while pyasn1 consumes 4.3 times as much (2093 against 488). <br><br>  asn1crypto, which I mentioned, we did not consider, because the project was still in its infancy, and we did not hear about it.  Now they would not have looked at him either, since I immediately discovered that the same GeneralizedTime does not accept an arbitrary form, and when serialized, it silently removes a split second.  This is acceptable for working with X.509 certificates, but in general it will not work. <br><br>  At the moment, PyDERASN is the strictest free Python / Go DER decoder known to me.  In the encoding / asn1 library of my favorite Go, I <a href="https://groups.google.com/forum/">do not have strict</a> OBJECT IDENTIFIER and UTCTime / GeneralizedTime string <a href="https://groups.google.com/forum/">checking</a> .  Sometimes severity can interfere (primarily due to backward compatibility with old applications that no one will fix), so <a href="http://pyderasn.cypherpunks.ru/reference.html">various settings</a> for debugging checks can be sent to PyDERASN during decoding. <br><br>  The project code tries to be as simple as possible.  The entire library is one file.  The code is written with an emphasis on ease of understanding, without unnecessary optimization of performance and DRY-code.  There is no, as I said, there is no support for full-BER decoding of UTCTime / GeneralizedTime strings, as well as REAL, RELATIVE OID, EXTERNAL, INSTANCE OF, EMBEDDED PDV, CHARACTER STRING data types.  In all other cases, I personally see no reason to use other libraries in Python. <br><br>  Like all my projects, such as <a href="http://pygost.cypherpunks.ru/">PyGOST</a> , <a href="http://gogost.cypherpunks.ru/">GoGOST</a> , <a href="http://www.nncpgo.org/">NNCP</a> , <a href="http://www.govpn.info/">GoVPN</a> , PyDERASN is completely <a href="https://www.gnu.org/philosophy/free-sw.ru.html">free software</a> , distributed under the <a href="https://www.gnu.org/licenses/lgpl-3.0.ru.html">LGPLv3 +</a> , and is available for free download.  Examples of use are <a href="http://pyderasn.cypherpunks.ru/examples.html">here</a> and in the <a href="https://git.cypherpunks.ru/cgit.cgi/pygost.git/tree/pygost/asn1schemas/cms.py">PyGOST tests</a> . <br><br>  <a href="http://www.stargrave.org/">Sergey Matveyev</a> , <a href="http://www.cypherpunks.ru/">Shifropank</a> , a member of <a href="https://www.fsf.org/">the SPO Foundation</a> , Python / Go-developer, Chief Specialist of the <a href="http://stcnet.ru/">Federal State Unitary Enterprise NTC Atlas</a> . </div><p>Source: <a href="https://habr.com/ru/post/444272/">https://habr.com/ru/post/444272/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444256/index.html">My first Sharp PC3000 reader</a></li>
<li><a href="../444260/index.html">We develop a system for evaluating the work of support agents</a></li>
<li><a href="../444262/index.html">Markdown2pdf ready solution with source code for Linux</a></li>
<li><a href="../444268/index.html">Security Week 12: keyboard attacks</a></li>
<li><a href="../444270/index.html">Group-IB Webinar ‚ÄúGroup-IB's Approach to Cyber ‚Äã‚ÄãFormation: A Review of Current Programs and Practical Cases‚Äù</a></li>
<li><a href="../444274/index.html">An extensive response to the comment, as well as a little about the life of providers in the Russian Federation</a></li>
<li><a href="../444276/index.html">Entry into React Fiber architecture</a></li>
<li><a href="../444278/index.html">How to make your English article for Habr read tens of thousands of people: 3 simple tips</a></li>
<li><a href="../444286/index.html">Parsing PTZ cameras: what's inside and how it works</a></li>
<li><a href="../444288/index.html">New mobile application LampTest.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>