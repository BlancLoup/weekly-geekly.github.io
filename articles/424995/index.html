<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Another particle system. Postmortem</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In September of this year, the mobile game Titan World from Unstoppable, the Minsk office of Glu mobile, was to be released. The project was canceled ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Another particle system. Postmortem</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/mr/k9/jt/mrk9jtkw0lnm7z8b6gh-hkxmwru.png" alt="image"><br><br>  <b>In September of this year, the mobile game Titan World from Unstoppable, the Minsk office of Glu mobile, was to be released.</b>  <b>The project was canceled right before the world release.</b>  <b>But the developments have remained, and the most interesting of them, with the kind permission of the heads of the studio Dennis Zdonov and Alex Paley, I would like to share with the public.</b> <br><a name="habracut"></a><br>  In March 2018, we had a meeting with the team leader, where we discussed what to do next: the render code was completed, and there were no new features and special effects in the plans.  The logical choice was to rewrite the particle system from scratch - for all the tests it gave the greatest drawdowns in performance, plus drove the designers crazy with its interface (text-based config file) and extremely scarce features. <br><br>  It should be noted that most of the time the team worked on the game in the "tomorrow release" mode, so I wrote all the subsystems, firstly, trying not to break what was already working, and secondly, with a short development cycle.  In particular, most of the effects that the standard system was not capable of were done in the fragment shader, without affecting the main code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The limitation on the number of particles (transformation matrices for each particle were formed on cpu, the conclusion - via gl-extension ios instancing) made it necessary to write, in particular, a shader that "emulated" a large array of particles, based on an analytical representation of the shape of objects, and composited with space podding fake data into the depth-buffer. <br><br>  The z-coordinate of the fragment was calculated for a flat part, as if we were drawing a sphere, and the radius of this sphere was modulated by the sine of Perlin noise with respect to time: <br><br><pre><code class="hljs pgsql">r=<span class="hljs-number"><span class="hljs-number">.5</span></span>+<span class="hljs-number"><span class="hljs-number">.5</span></span>*sin(perlin(specialUV)+<span class="hljs-type"><span class="hljs-type">time</span></span>)</code> </pre> <br>  A full description of the reconstruction of the depth of the sphere can be found in <a href="http://www.iquilezles.org/www/articles/sphereproj/sphereproj.htm">√ç√±igo Qu√≠lez</a> , I used a simplified, faster code.  He, of course, was a rough approximation, but on complex geometric shapes (smoke, explosions) gave quite a decent picture. <br><br><img src="https://habrastorage.org/webt/tt/un/lw/ttunlwe3v4wj0snsxkjt-drx_fi.png" alt="image"><br>  <i>Screenshot gameplay.</i>  <i>The smoke ‚Äúskirt‚Äù was made by one parktikl, several more were spent on the main body of the explosion.</i>  <i>Most effectively, of course, it looked ‚Äúfrom the ground‚Äù, when the smoke gently enveloped buildings and units, but the proposals to change the position of the camera during the explosion did not hit production.</i> <br><br><h4>  Formulation of the problem </h4><br>  What I wanted to get on the way out?  We came, rather, from the limitations with which we learned on the previous system of particles.  The situation was worsened by the fact that the frame budget was almost exhausted, and on weak devices (like ipad air) both pixel and vertex pipelines were loaded to the full.  Therefore, I wanted to get the most productive system as a result, even if I‚Äôve limited functionality a little. <br><br>  Designers formed a list of features and drew a sketch UI, based on their own experience and practice of working with unity, unreal and after effects. <br><br><h4>  Available technologies </h4><br>  Due to the legacy and limitations imposed by the head office, we were limited to opengl es 2. Thus, technologies like transform feedback used in modern particle systems were not available. <br><br>  What is left?  Use vertex texture fetch and store position / acceleration in textures?  The working version, but the memory is also almost over, the performance of such a solution is not the most optimal, and the result is not the same as the architectural beauty. <br><br>  By this time I read many articles on the implementation of particle systems on gpu.  The overwhelming majority contained a bright heading (‚Äúmillions of particles on mobile gpu, with preference and poetess‚Äù), but the implementation was reduced to examples of simple, though entertaining, emitters / attractors, and in general was almost useless for real use in the game. <br>  <a href="https://habr.com/post/151821/">This article</a> brought the maximum benefit: the author solved the real problem, and did not do ‚Äúspherical particles in a vacuum‚Äù.  The benchmark figures from this article and the results of the profiling saved a lot of time at the design stage. <br><br><h4>  Search for approaches </h4><br>  I began with the classification of problems solved by a system of particles, and the search for special cases.  It turned out about the following (a piece of the real concept docks from the correspondence with the team leader): <br><blockquote>  ‚Äú- Particle / mesh arrays with cyclic motion.  There is no processing position, all through the equation of motion.  Applications - smoke from pipes, steam above water, snow / rain, volumetric fog, swinging trees, partial exploitation of aka explosions is possible on non-cyclical effects. <br><br>  - Tapes.  Formation of vb by event, processing only on gpu (shots by rays, flying along a fixed (?) Trajectory with a trace).  Maybe the option will take off with the transfer of uniforms to start-finish coordinates and the construction of the tape using vertexID.  with tz  render cross with fresnel as on direct + uvscroll. <br><br>  - Particle generation and processing speeds.  The most versatile and the most complex / slowest option, see tech processing traffic. ‚Äù </blockquote><br>  In short: there are different particle effects, and some of them can be implemented easier than others. <br><br>  We decided to split the task into several iterations - from simple to complex.  Prototyping was done on my engine / editor under windows / directx11 due to the fact that the speed of such development was several orders of magnitude higher.  The project was compiled in a couple of seconds, and the shaders were edited altogether ‚Äúon the fly‚Äù and compiled in the background, displaying the result in real time and without requiring any additional gestures such as pressing buttons.  The one who collected big projects with a bunch of macbook / xcode, I think, will understand the reasons for this decision. <br><br>  All code samples will be taken exactly from the windows-prototype. <br><br><img src="https://habrastorage.org/webt/of/p6/pi/ofp6pi_sus1zqlyamxxkb8-zoem.png" alt="image"><br>  <i>Development environment for windows.</i> <br><br><h4>  Implementation </h4><br>  The first stage is the static output of an array of particle files.  Nothing complicated: we start vertex bufffer, fill it with quads (we write the correct uv for each quad), and sew the vertex id into the ‚Äúadditional‚Äù uv.  After that, in the shader, using vertex id, based on the emitter settings, we form the positions of the particle, and by uv, we restore the screen coordinates. <br><br>  If vertex_id is available natively, you can do without the buffer and without uv to restore the screen coordinates (as a result, done in the windows version). <br><br>  Shader: <br><br><pre> <code class="hljs pgsql">struct VS_INPUT { ‚Ä¶ uint v_id:SV_VertexID; ‚Ä¶ } //<span class="hljs-type"><span class="hljs-type">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.uv2.x/<span class="hljs-number"><span class="hljs-number">6.0</span></span>;// vertex_id   <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> = floor(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>);// vertex_id float2 map[<span class="hljs-number"><span class="hljs-number">6</span></span>]={<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>}; float2 quaduv=map[frac(<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.v_id/<span class="hljs-number"><span class="hljs-number">6.0</span></span>)*<span class="hljs-number"><span class="hljs-number">6</span></span>];</code> </pre> <br>  After that, it is possible to implement simple scenarios with a very small amount of code, for example, a cyclical motion with small deviations will be suitable for the snow effect.  However, our goal was to give the control of the behavior of the particle to the side of the artists, and, as is known, they rarely know how to shaders.  The variant with presets of behavior and editing parameters through sliders also did not deceive - switching shaders or branching inside, multiplying options of presets, lack of full control. <br><br>  The next task was the implementation of fade in / fade out for such a system.  Particles should not appear from nowhere and disappear to nowhere.  In the classical implementation of a particle system, we process the buffer programmatically using cpu, creating new particles and removing old ones.  In fact, to get a good speed, you need to write an intelligent memory manager.  But what will happen if you just do not draw "dead" particles? <br><br>  Suppose (for a start) that the time-interval of particle emission and the lifetime of a particle are constant within a single emitter. <br><br><img src="https://habrastorage.org/webt/96/bp/du/96bpdunpa_v6apnh6gqeoyh-7yq.jpeg" alt="image"><br>  Then we can speculatively present our buffer (which contains only the vertex id) as a ring and determine its maximum size as follows: <br><br><pre> <code class="cpp hljs">pCount = round (prtPerSec * LifeTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCountT = <span class="hljs-built_in"><span class="hljs-built_in">floor</span></span> (prtPerSec * EmissionEndTime / <span class="hljs-number"><span class="hljs-number">60.0</span></span>); pCount=min (pCount, pCountT);</code> </pre> <br>  and in the shader calculate the time based on the index and time (time elapsed from the start of the effect) <br><br><pre> <code class="cpp hljs">pTime=time-index/prtPerSec;</code> </pre> <br>  If the emitter is in the cyclic phase (all particles are emitted and now synchronously die and are born), we make frac particles against time and thus get a loop. <br><br>  We do not need to draw particles with pTime less than zero - they have not yet been born.  The same applies to particles in which the sum of the lifetime and the current time exceeds the end time of the emission.  In both cases, we will not draw anything by setting the particle size and / or throwing it off the screen.  This approach will give a small overhead on the fadein / fadeout phases, while maintaining maximum performance in the sustain phase. <br><br>  The algorithm can be somewhat improved by sending only that part of the vertex buffer that contains live particles to the drawing.  Due to the fact that the emission occurs sequentially, living particles will be segmented a maximum of one time, i.e.  need two drawcall'a. <br><br>  Now, knowing the current time of each particle, it is possible, by setting the speed, acceleration (and, in general, any other parameters) to write the equation of motion, having received as a result the coordinates in world space. <br><br>  Using the restored from vertex_id uv, we will get four points (more precisely, we will move each of the quad points in the direction we need), on which the vertex shader, having completed the projection, will complete its work. <br><br><pre> <code class="hljs">p.xy+=(quaduv-.5);</code> </pre><br>  With a free bonus, we were able to not only pause the emitter, but also rewind time back and forth with frame accuracy.  This feature has been very useful when designing complex effects. <br><br><h4>  We increase the functionality </h4><br>  The next iteration in the development was to solve the problem of a moving emitter.  Our party system knew nothing about its position, and as the emitter moved, the entire effect synchronously moved behind it.  For smoke from the exhaust pipe and similar effects, it looked more than strange. <br><br>  The idea was to record the position of the emitter in the vertex buffer at the birth of a new particle.  Since the number of such particles is small, the overhead should have been minimal. <br><br>  A colleague suggested that when developing his own UI, he used map / unmap only part of the vertex buffer and was quite pleased with the performance of this solution.  I did the tests, and it turned out that this approach works really well both on the desktop and on mobile platforms. <br><br>  The difficulty arose with the timing of cpu and gpu.  It was necessary to ensure that the update buffer was made exactly when the "new", looped particle will be in its starting position.  That is, in relation to the ring buffer, it is necessary to synchronize the boundaries of the update region with the emitter operation time. <br><br>  I transferred the hlsl code to c ++, wrote the emitter movement along Lissajous for the test, and it all suddenly worked.  However, from time to time the system ‚Äúspat‚Äù one or several particles, firing them in an arbitrary direction, not removing them in time or creating new ones in arbitrary places. <br><br>  The problem was solved by auditing the accuracy of counting the time in the engine and parallel to checking the time delta when recording the new position of the emitter - so that the entire portion of the buffer that was not affected on the previous iteration was updated.  It was also necessary for the system to work under the conditions of forced desync, a sudden drawdown of fps should not break the effect, especially since for different devices our game recorded different fps according to the performance - 60/30/20. <br><br>  The method code has expanded quite a lot (the ring buffer is difficult to handle elegantly), but after taking all the conditions into account, the system has worked correctly and stably. <br><br>  Around this time, the partner already made the ‚Äúfish‚Äù of the editor, sufficient for testing the system, and wrote out the / api templates for integrating the system into our engine. <br><br>  I ported all code under ios / opengl, integrated and finally made real effects tests on a real device.  It became clear that the system not only works, but also is suitable for production.  It remained to finish the editor's UI and polish the code to the state ‚Äúit‚Äôs not scary to release to release tomorrow.‚Äù <br><br>  We‚Äôve even got together to write a memory manager so as not to allocate / destroy the buffer (which ultimately kept the vertex_id, uv, position and initial particle vector) for each new effect with a dynamic emitter, as another idea came to mind. <br><br>  The very fact of the existence of vertex buffer in this system did not give me rest.  He clearly looked in her archaism, "the legacy of the dark ages of the fixed conveyor."  While doing the test effects on the windows prototype, I thought that the movement of the emitter is always smooth and always happens much slower than the movement of particles.  Moreover, with a large number of particles, a position update results in the same data being written to hundreds of particles.  The solution turned out to be simple: we will get a fixed array, into which the ‚Äúhistory‚Äù of the emitter position will fall, normalized by the particle lifetime.  And on gpu we interpolate the data.  After that, ios / gles2 version eliminated the need for dynamic buffers (only general static remained to implement vertex_id), and in windows / dx11 versions, the buffers disappeared altogether due to native vertex_id and the possibility of d3d api to accept null for drawing instead of a vertex buffer reference. <br><br>  Thus, the win-version of the system, by modern standards, does not consume memory at all, no matter how many particles we want to display.  Only a small constant buffer with parameters, a buffer of positions / bases (60 pairs of vectors was enough, with a margin, for any cases), and, if necessary, texture.  Performance measurements show speeds close to synthetic tests. <br><br>  In addition, the ‚Äútail‚Äù in effects like sparks began to look much more natural, since interpolation allowed removing frame sampling and thus the emitter changed position smoothly, as if drawing calls were performed at a frequency of hundreds of hertz. <br><br><h4>  Features </h4><br>  In addition to the basic functionality of the particle flight, (speed, acceleration, aggression, resistance to the environment), we needed a certain amount of functional ‚Äúfat‚Äù. <br>  As a result, motion blur (stretching a particle along a motion vector), particle orientation across the motion vector (this allows you to do, for example, a sphere of particles), changing the particle size according to the current time of its life and dozens of other trifles were implemented. <br><br>  Difficulty arose with vector fields: since the system does not store its state (position, acceleration, etc.) for each particle, but calculates them every time through the equation of motion, a number of effects (like the movement of foam when stirring coffee) were impossible in principle.  However, a simple modulation of the speed and acceleration by the noise of the perlin gave results that look quite modern.  The computation of real-time noise for such a number of particles turned out to be too expensive (even with a limit of five octaves), so the texture was generated, from which the vertex shader then sampled.  To enhance the effect of a fake vector field, a small offset of the sample coordinates was added depending on the current emitter time. <br><br><img src="https://habrastorage.org/webt/sq/vu/xs/sqvuxsyjwxocojucmja_ynqtnjc.png" alt="image"><br>  <i>The cigarette smoke test works by distributing the initial velocity and accelerating through perlin noise.</i> <br><br><h4>  Pixel conveyor </h4><br>  Initially we planned only to change the color / transparency of the particle depending on its time.  I added several algorithms to the pixel shader. <br><br>  Rotation of the texture color is simplified, sin (color + time).  Allows you to simulate the effect of permutation from AfterEffects to some extent. <br><br>  Fake lighting - modulation of a particle's color by a gradient in world coordinates, regardless of the angle of rotation of the particle. <br><br>  The evolution of boundaries - when a particle moves in space, its boundaries (alpha channel) are modulated by a combination of spotlight and perlin noise, which gives the dynamics of their flow, very similar to clouds, smoke and other fluid effects. <br><br>  Shader pseudocode: <br><br><pre> <code class="hljs lisp">b=perlin(<span class="hljs-name"><span class="hljs-name">uv</span></span>)<span class="hljs-comment"><span class="hljs-comment">;// , uv      a=saturate(1-length(input.uv.xy-.5)*2);//     a-=abs(ab);//‚Äù‚Äù,  </span></span></code> </pre> <br>  In a slightly sophisticated version, this shader could draw borders with arbitrary softness and with a highlight of the contour, which added realism to ‚Äúexplosive‚Äù effects. <br><br><img src="https://habrastorage.org/webt/fz/sp/lf/fzsplfbanmnupkdppk2gqj3mlcy.png" alt="image"><br>  <i>The first experiments with the evolution of boundaries.</i> <br><br><h4>  What's next? </h4><br>  Despite the editor that is already ready for work and integrated into the engine, the designers did not have time to make a single effect on it - the project was closed.  However, there are no obstacles to using these practices anywhere else - for example, to do work on Revision demos. <br><br>  From a technological point of view, there is also where to move - now, for example, there are several effects of the destruction of frame objects in the work: <br><br><img src="https://habrastorage.org/webt/g7/-0/ab/g7-0abs_dlath0s8dxewlrgs1ju.png" alt="image"><br><br>  The question of sorting partitions for alpha-blending is still open: since everything is considered analytically in the shader, there is not even the input data to be sorted.  But there is a big field for experiments! <br><br>  During the development of Titan World in the graphic part of the game, many more tricks were applied, but about this some time next. <br><br>  PS You can dig into the source code of the alpha engine <a href="">here</a> .  Examples are in the release / samples folder, the main control keys are space, alt | control + mouse.  Shaders are right in fxp files, their code is available through the editor window. </div><p>Source: <a href="https://habr.com/ru/post/424995/">https://habr.com/ru/post/424995/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424985/index.html">In an important case law, the US secret services were unable to eavesdrop on calls in the messenger</a></li>
<li><a href="../424987/index.html">Restore blurred and defocused images using a Wiener filter. Implementation on C ++ OpenCV</a></li>
<li><a href="../424989/index.html">Design process: 7 steps to an ideal project</a></li>
<li><a href="../424991/index.html">When the old methods do not work: Vasily Mazin - on a hybrid approach in the development of AI</a></li>
<li><a href="../424993/index.html">Food Marketing Practices at Epic Growth Conference</a></li>
<li><a href="../424997/index.html">‚ÄúIOS application VKontakte has a high threshold of entry‚Äù: interview with Alexei Savin</a></li>
<li><a href="../425001/index.html">Validation of generic parameters in Spring controllers</a></li>
<li><a href="../425003/index.html">Compare TCO purchases of "iron" and rent a cloud</a></li>
<li><a href="../425005/index.html">Rust News # 1 (September 2018)</a></li>
<li><a href="../425007/index.html">Jeff Bezos's Iridium and AWS have teamed up to develop a global satellite Internet project for IoT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>