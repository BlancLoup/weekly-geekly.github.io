<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Homemade cartridges for Dendy / Famicom</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="After my article about dumper cartridges (which for some reason was left on Habr√© for some reason), I was asked many times to tell how to collect and ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Homemade cartridges for Dendy / Famicom</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/1ec/6b8/075/1ec6b807551e43f692ee91f839096eb9.jpg"><br><br>  After my <a href="http://habrahabr.ru/post/248459/">article about dumper cartridges</a> (which for some reason was left on Habr√© for some reason), I was asked many times to tell how to collect and write cartridges for Dandy / Famicom myself.  Yes, this is a very hackneyed topic, even in the ancient issues of Radio magazine one could read about it, but progress does not stand still.  Consider this topic in terms of modern components.  Moreover, in my opinion, it is ideal for learning the basics of working with FPGAs, this is where I myself studied. <br><br><a name="habracut"></a><br>  Like last time, this publication is in two formats: entertaining video is simpler (yes, already the third series) and a regular article with more detailed information.  Who likes more, but look better and then, and more. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Video: </h1><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/CjzFmpoUz18%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhgQ56GEqJzzwpiDmxIJFKeVOTiECg" frameborder="0" allowfullscreen=""></iframe><br><br><h1>  Article: </h1><br>  You probably need to start with the fact that the cartridges that were sold and continue to be sold in our stores, alas, cannot be overwritten (in fact, some are possible, but more on that another time).  This is due to the fact that they installed the usual EPROM memory, which can be written only once.  However, nothing prevents you from collecting your own cartridge from scratch. <br><br>  Let me remind you that the cartridge is inserted directly into the CPU bus and into the PPU bus, and accordingly, first of all it contains two memory chips with parallel access: <b>PRG</b> - the processor accesses it, and it contains the game code itself, and <b>CHR</b> - the PPU works with it (graphical processor) and it contains images.  Moreover, the latter can easily be not a ROM, but a random access memory, where data is already recorded during the game. <br><br>  Thus, the simplest cartridge can be made from any two memory chips with parallel access, be it at least an EPROM, even a flash.  In this case, nothing more of the strapping is needed.  For example, this is how my first self-made cartridge looked like: <br><br><img src="https://habrastorage.org/files/fa9/b32/673/fa9b32673f1f4fdcb0b480bef36b8f08.jpg"><br><br>  Chips are simply connected directly to the corresponding pins on the cartridge connector.  Feet <b>/ RD</b> can be soldered directly to the ground, because the console will always only read the data, but I recorded the data after the cartridge was assembled, using the same <a href="http://habrahabr.ru/post/248459/">dumper</a> , so I connected all the conclusions as expected.  The bits of the address and data are mixed up in this way, but it absolutely does not matter.  At the bottom you can see a jumper that defines ‚Äúmirroring‚Äù - how the video memory will be mirrored horizontally or vertically.  It depends on the game, and in the simplest games it was determined by the jumper on the cartridge. <br><br>  And another very important point - you need to activate our memory only when the console accesses the cartridge, otherwise there will be a conflict on the bus.  To do this, the chip has output <b>/ CE</b> (chip enable), which includes memory.  Here in the course goes a fairly simple math.  Program ( <b>PRG</b> ) cartridge memory starts at <b>$ 8,000</b> and ends at <b>$ FFFF</b> , two to the fifteenth power.  Graphic ( <b>CHR</b> ) cartridge memory starts at <b>$ 0000</b> and ends at <b>$ 1FFF</b> , having a volume of 8 kilobytes, which is two to the thirteenth power.  Accordingly, our memory should be turned on with the fifteenth and thirteenth contacts on the address bus.  On the cartridge connector there are already special leads that give us the signal we need.  Moreover, in the case of <b>PRG</b> memory, the contact we need is called - <b>/ ROMSEL</b> - abbreviated as ROM Select.  There the console produces 0 volts when it accesses the cartridge's memory in the area between <b>$ 8000</b> and <b>$ FFFF</b> .  Everything is easier nowhere. <br><br>  However, it will be possible to record only the simplest games on such a cartridge.  More serious ones already use mapper cartridges to increase the maximum volume of the game.  I'll try to explain how they worked. <br><br>  In memory with parallel access, each bit of the address is set by a separate output from the chip.  In the cartridge connector there are pins <b>A0-A14</b> (15 pins) for <b>PRG</b> memory.  These are respectively 15 bits of the address, which give 32768 combinations of ones and zeros, i.e.  allow you to address 32 kilobytes.  For the <b>CHR</b> memory there, respectively, the pins <b>A0-A13</b> are 16384 combinations, i.e.  16 kilobytes, but half of them are allocated to the memory inside the console. <br><br>  Already in the eighties such volumes began to be missed.  Of course, nothing prevents you from putting a large amount of memory in the cartridge, but this memory has more address and pin outputs.  It is not difficult to calculate that each additional output doubles the number of possible addresses exactly.  But where to connect them if the number of contacts in the cartridge connector is limited?  This is where the mappers come to the rescue, it is they who manage the additional conclusions depending on various conditions.  Almost always, such conditions are attempts to write to the PRG-area of ‚Äã‚Äãthe cartridge memory.  Yes, the one where you can not write anything. <br><br>  Many games use simple logic chips for this purpose.  For example, in a cartridge, Battletoads has a four-bit counter <b>74161</b> , which is used as a trigger.  When writing to any address from <b>$ 8000</b> to <b>$ FFFF,</b> he memorizes the recorded value and gives it to the very additional conclusions from the memory, he also switches the mirroring. <br><br>  But most games use more complex chips for this purpose, which are designed specifically for this purpose. <br><br><img src="https://habrastorage.org/files/6df/24c/b54/6df24cb544dc4534a48b49aa4cc352a3.jpg"><br><br>  They, as a rule, are already able to switch different banks for different memory areas, manage additional memory, generate interrupts, and sometimes even expand the computing power of the console. <br><br>  As an example, take the most popular mapper - <b>MMC3</b> .  You can read about it in detail here: <a href="http://wiki.nesdev.com/w/index.php/MMC3">wiki.nesdev.com/w/index.php/MMC3</a> <br><br>  First of all, we read how it interacts with it.  And it happens through writing to certain addresses, their 8 groups: <b>$ 8000- $ 9FFE</b> (even), <b>$ 8001- $ 9FFF</b> (odd), <b>$ A000- $ BFFE</b> (even), <b>$ A001- $ BFFF</b> (odd), <b>$ C000- $ DFFE</b> (even), <b>$ C001- $ DFFF</b> (odd), <b>$ E000- $ FFFE</b> (even) and <b>$ E001- $ FFFF</b> (odd).  Writing to any address within the group is equivalent.  See the pattern?  The register is selected using the three address bits: <b>A0</b> , <b>A13</b> and <b>A14</b> , while the others have no values. <br><br>  Let's try to imitate the work of the mapper using FPGA.  I write the code in the Verilog language.  It is not highlighted here, I apologize for this. <br>  First, we describe our registers that store the current state: <br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] bank_select; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> prg_mode; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> chr_mode; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] r [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">7</span></span>]; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> mirroring; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span>] ram_protect; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] irq_latch; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] irq_counter; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] a12_low_time; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> irq_reload; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> irq_reload_clear; <span class="hljs-attribute"><span class="hljs-attribute">reg</span></span> irq_enabled;</code> </pre> <br><br>  We describe the reaction to the entry at the appropriate addresses.  The <b>rising</b> signal <b>/ ROMSEL is</b> talking about the fact that there was a memory access to the cartridge,  at addresses <b>$ 8000- $ FFFF</b> , we need to respond at this very moment. <br><pre> <code class="hljs bash">always @ (posedge romsel) begin //       <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cpu_rw_in == 0) begin //   A14, A13  A0,    <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> ({cpu_addr_in[14:13], cpu_addr_in[0]}) 3<span class="hljs-string"><span class="hljs-string">'b000: begin // $8000-$9FFE, even bank_select &lt;= cpu_data_in[2:0]; prg_mode &lt;= cpu_data_in[6]; chr_mode &lt;= cpu_data_in[7]; end 3'</span></span>b001: r[bank_select] &lt;= cpu_data_in; // <span class="hljs-variable"><span class="hljs-variable">$8001</span></span>-<span class="hljs-variable"><span class="hljs-variable">$9FFF</span></span>, odd 3<span class="hljs-string"><span class="hljs-string">'b010: mirroring &lt;= cpu_data_in[0]; // $A000-$BFFE, even 3'</span></span>b011: ram_protect &lt;= cpu_data_in[7:6]; // <span class="hljs-variable"><span class="hljs-variable">$A001</span></span>-<span class="hljs-variable"><span class="hljs-variable">$BFFF</span></span>, odd 3<span class="hljs-string"><span class="hljs-string">'b100: irq_latch &lt;= cpu_data_in; // $C000-$DFFE, even 3'</span></span>b101: irq_reload &lt;= 1; // <span class="hljs-variable"><span class="hljs-variable">$C001</span></span>-<span class="hljs-variable"><span class="hljs-variable">$DFFF</span></span>, odd 3<span class="hljs-string"><span class="hljs-string">'b110: irq_enabled &lt;= 0; // $E000-$FFFE, even 3'</span></span>b111: irq_enabled &lt;= 1; // <span class="hljs-variable"><span class="hljs-variable">$E001</span></span>-<span class="hljs-variable"><span class="hljs-variable">$FFFF</span></span>, odd endcase end <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq_reload_clear) irq_reload &lt;= 0; end</code> </pre><br><br>  Now we will describe which bank should be selected when accessing the corresponding part of the memory, depending on our registers. <br>  They are switched according to this table: <br><br><img src="https://habrastorage.org/files/369/58b/8b4/36958b8b460a47c9abcc67b9a75cd86d.PNG"><br><br>  Where <b>$ 8000 &amp; # $ 40</b> is our prg_mode, and -2 and -1 are the last and last bank respectively.  Such code turns out: <br><pre> <code class="hljs markdown">// PRG banking always @ (*) begin case ({cpu<span class="hljs-emphasis"><span class="hljs-emphasis">_addr_</span></span>in[<span class="hljs-string"><span class="hljs-string">14:13</span></span>], prg<span class="hljs-emphasis"><span class="hljs-emphasis">_mode}) // $8000-$9FFF 3'b000: cpu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[18:13] &lt;= r[6][5:0]; 3'b001: cpu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[18:13] &lt;= 6'b111110; //   // $A000-$BFFF 3'b010, 3'b011: cpu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[18:13] &lt;= r[7][5:0]; // $C000-$DFFF 3'b100: cpu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[18:13] &lt;= 6'b111110; //   3'b101: cpu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[18:13] &lt;= r[6][5:0]; // $E000-$FFFF -     default: cpu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[18:13] &lt;= 6'b111111; endcase // A12  MMC3      ,      cpu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[12] &lt;= cpu_</span></span>addr_in[12]; end</code> </pre><br><br>  Now CHR.  There is such a scheme: <br><br><img src="https://habrastorage.org/files/f65/d8e/a3f/f65d8ea3f30542e3a3dde3fd06d41c63.PNG"><br><br>  Where <b>$ 8000 &amp; # $ 40</b> is chr_mode.  It turns out like this: <br><pre> <code class="hljs markdown">// CHR banking always @ (*) begin if (ppu<span class="hljs-emphasis"><span class="hljs-emphasis">_addr_</span></span>in[<span class="hljs-string"><span class="hljs-string">12</span></span>] == chr<span class="hljs-emphasis"><span class="hljs-emphasis">_mode) ppu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[17:10] &lt;= {r[ppu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_in[11]][7:1], ppu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_in[10]}; else ppu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_out[17:10] &lt;= r[2+ppu_</span></span>addr<span class="hljs-emphasis"><span class="hljs-emphasis">_in[11:10]]; //   CHR  MMC3 - 256 ,  A18  0. ppu_</span></span>addr_out[18] <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">=</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">end</span></span></span></span></span></span></code> </pre><br><br>  The mirroring mode is described in just one line.  Depending on it, we close the output of the <b>CIRAM A10</b> cartridge to either the <b>A10</b> or the <b>A11</b> : <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">assign</span></span> ppu_ciram_a10 = mirroring ? ppu_addr_in[<span class="hljs-number"><span class="hljs-number">11</span></span>] : ppu_addr_in[<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br><br>  Further more difficult.  MMC3 can generate interrupts when a certain string is drawn on the screen.  This is very useful, and games often use it.  Lines on the screen are counted by referring to <b>A12</b> on the PPU.  With typical settings, the signal on <b>A12</b> goes from logical 0 to logical 1 exactly once per line, short of transitions to 0. And they should not be counted, this complicates things a bit: <br><br><pre> <code class="hljs vhdl">//    ,   A12   always @ (*) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_enabled) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> irq_ready = <span class="hljs-number"><span class="hljs-number">0</span></span>; irq &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'bZ</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq_enabled &amp;&amp; !irq_value) irq_ready = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq_ready &amp;&amp; irq_value) irq &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> //   always @ (posedge ppu_addr_in[<span class="hljs-number"><span class="hljs-number">12</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a12_low_time == <span class="hljs-number"><span class="hljs-number">3</span></span>) //    A12     <span class="hljs-number"><span class="hljs-number">3</span></span>  CPU <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((irq_reload &amp;&amp; !irq_reload_clear) || (irq_counter == <span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> irq_counter = irq_latch; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq_reload) irq_reload_clear &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> irq_counter = irq_counter-<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (irq_counter == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; irq_enabled) irq_value = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> irq_value = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!irq_reload) irq_reload_clear &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> //    A12     <span class="hljs-number"><span class="hljs-number">3</span></span>  CPU always @ (posedge m2, posedge ppu_addr_in[<span class="hljs-number"><span class="hljs-number">12</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ppu_addr_in[<span class="hljs-number"><span class="hljs-number">12</span></span>]) a12_low_time &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a12_low_time &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) a12_low_time &lt;= a12_low_time + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre><br><br>  Oh yeah, MMC3 also supports connecting additional RAM at <b>$ 6000- $ 7FFF</b> !  We must not forget and describe it: <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">assign</span></span> cpu_wr_out = cpu_rw_in || ram_protect[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">assign</span></span> cpu_rd_out = ~cpu_rw_in; <span class="hljs-keyword"><span class="hljs-keyword">assign</span></span> cpu_sram_ce = !(cpu_addr_in[<span class="hljs-number"><span class="hljs-number">14</span></span>] &amp;&amp; cpu_addr_in[<span class="hljs-number"><span class="hljs-number">13</span></span>] &amp;&amp; m2 &amp;&amp; romsel &amp;&amp; ram_protect[<span class="hljs-number"><span class="hljs-number">7</span></span>]);</code> </pre><br><br>  That's it, our MMC3 is ready!  The full code can be found here: <a href="">https://github.com/ClusterM/nes_mappers/blob/master/4%20(MMC3)/MMC3.v</a> <br>  In the same repository there are codes of many other mappers. <br><br>  In fact, it is very simple to assemble a cartridge for any one particular game, because you only need to install the necessary components.  But to make a universal cartridge is much more difficult. If you install the FPGA on 128 macrocells, 512 kilobytes flash for PRG, 512 kilobytes flash for 32 kr for CHR, 32 kilobytes for CHR, 32 kilobytes for SRR as additional memory, which is powered by a battery for games that can be saved, then about 90% -95% of games will go on it.  The scheme turns out very confused, I have long manually painted a board for the whole thing.  By the way, when choosing components, you should not forget that Famicom / Dendy has five-volt levels.  The Chinese now very often ignore it. <br><br>  The first revision of my universal cartridge looked something like this: <br><br><img src="https://habrastorage.org/files/588/06b/a3a/58806ba3a2ec4254a1f5df68749c4ca8.jpg"><br><br>  Well, I wrote a program for recording games: <br><br><img src="https://habrastorage.org/files/01b/60a/8c9/01b60a8c94534a68ba34114406a20f29.PNG"><br><br>  As you can see, everything is not so difficult, if you sit a little and understand the principles of work. </div><p>Source: <a href="https://habr.com/ru/post/366047/">https://habr.com/ru/post/366047/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../366037/index.html">Overview and humanization of the Tronsmart Orion r28 Pro Android</a></li>
<li><a href="../366039/index.html">Beloved Chicken Printed Prosthesis for $ 2500</a></li>
<li><a href="../366041/index.html">The draft of the space station of the BRICS countries</a></li>
<li><a href="../366043/index.html">Twitter added group private messages and video shooting and editing.</a></li>
<li><a href="../366045/index.html">Apple Watch will go on sale in April</a></li>
<li><a href="../366051/index.html">Hacker's List is designed to find the "right" hacker.</a></li>
<li><a href="../366053/index.html">How will the Falcon Heavy launch vehicle be launched?</a></li>
<li><a href="../366055/index.html">Scientists have discovered a super-Saturn with super rings</a></li>
<li><a href="../366057/index.html">The device DSCOVR shot the moon, passing against the background of the Earth</a></li>
<li><a href="../366059/index.html">How restaurants create menus: 4 design techniques</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>