<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Angular and RequireJS project builder and some build thoughts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is the most inconvenient in project builders? Right! The fact that you need to write the assembly yourself. Study grunt / gulp / webpack, shaman ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Angular and RequireJS project builder and some build thoughts</h1><div class="post__text post__text-html js-mediator-article">  What is the most inconvenient in project builders?  Right!  The fact that you need to write the assembly yourself.  Study grunt / gulp / webpack, shaman with plug-ins, think how to break the config into modules when it grows up to several hundred lines, then for several months rejoice that everything works, and when a critical change appears in the project, climb into this swamp again. <br><br>  I, too, am pretty tired of all this, so I wrote a <a href="https://www.npmjs.com/package/arjs-builder">collector, devoid of these shortcomings</a> .  Its gulpfile.js looks like this: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gulp = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'gulp'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arjs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'arjs-builder'</span></span>)(); gulp.task(<span class="hljs-string"><span class="hljs-string">'build'</span></span>, arjs.build); gulp.task(<span class="hljs-string"><span class="hljs-string">'test'</span></span>, arjs.test); gulp.task(<span class="hljs-string"><span class="hljs-string">'default'</span></span>, arjs.run);</code> </pre> <br>  They copied the project for themselves, and never go there again, and forever forget what an assembly is. <br>  The only thing you have to learn is three commands: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">gulp <span class="hljs-comment"><span class="hljs-comment">#,    gulp build #  gulp test # </span></span></code> </pre><br>  Open <a href="http://localhost:7000/">localhost: 7000</a> and enjoy the local version of the site, and in the <code>build <br></code> folder <code>build <br></code>  already lies down version. <br><br>  - But what about templates, they need to be implemented in js? <br>  - Of course!  Everything is implemented as it should be. <br>  - And I write styles on less, sass, stylus, do I need to compile them? <br>  - Write as they wrote, everything will miraculously work. <br>  - Are the pictures in CSS included? <br>  - So long ago everything is in CSS.  All included as a five star hotel. <br>  - A split the collapsed file into modules? <br>  - Check the build folder.  All modules?  With unique names based on file content?  Here, and you were worried! <br>  - And here's something else ... <br>  - And it works too. <br><br>  But how is this possible?  We will consider this in the article.  And at the end I'll tell you why RequireJS <br><a name="habracut"></a><br><h2>  Project structure </h2><br>  Always something to sacrifice.  In our case, these are restrictions imposed on the project structure and directly the result of the assembly.  But here it‚Äôs not to cry, but to rejoice, because we sacrificed such evil as ‚ÄúI need maximum flexibility and control, I will write everything myself‚Äù.  Let‚Äôs look around and hand in hand, we‚Äôll conclude that most developers have little idea of ‚Äã‚Äãthe front-end single-page application architecture, let alone how to build it correctly (in a single file, in modules, synchronously load, asynchronously, no one‚Äôs performance measured, no one analyzed anything).  And does a web developer need this?  For this he took a job? <br><br>  Closer to the topic.  The builder is designed for projects based on RequireJS and AngularJS.  However, it works with projects both on pure JS and theoretically with any other frameworks. <br><br>  The working directory with your application will have the following structure: <br><pre> <code class="bash hljs">projects/ ‚îú‚îÄ‚îÄproject1/ ‚îú‚îÄ‚îÄproject2/ ‚îú‚îÄ‚îÄproject3/ ‚îú‚îÄ‚îÄfiles/ ‚îú‚îÄ‚îÄvendor/ ‚îú‚îÄ‚îÄcompiled/ ‚îú‚îÄ‚îÄbuild/ ‚îú‚îÄ‚îÄindex.html ‚îú‚îÄ‚îÄlib.js ‚îî‚îÄ‚îÄlib.css .bowerrc bower.json package.json gulpfile.js</code> </pre><br>  <code>project1..3</code> - project folders.  The project describes a separate section of the site or a separate site.  Projects can be written on different frameworks or without them.  For projects can be used as a common index.html or your own.  There will be at least three projects in the middle tier application: <br><ul><li>  <code>main</code> - the main site </li><li>  <code>admin</code> - <code>admin</code> panel </li><li>  <code>old-browser</code> - stub for old browsers, written in the most primitive JS </li></ul><br>  In large applications, a <code>lib</code> project may appear in which the main modules used in other projects (routing, authorization, working with resources ...) will be assembled. <br><br>  In separate projects, it is worth making a new version of the site (to organize a smooth transition), assemblies for A / B testing, temporary landing pages, etc. <br><br>  <code>files</code> are put into files that will not be inserted into CSS (candidates for transfer to a file server).  The rest will be converted to base64 and inserted into styles, even if it is 2GB of video.  Because the project describes only the interface, the content must be taken from other places. <br>  The <code>vendor</code> copies libraries from bower. <br>  In <code>compiled</code> , temporary files for local work (styles, vendor libraries) are added. <br>  In the <code>build</code> collected projects, ready for uploading to the server. <br><br>  An example of <code>index.html</code> can be found <a href="https://github.com/tamtakoe/node-arjs-builder-seed/blob/master/projects/index.html">here</a> .  It, like gulpfile.js, never changes. <br>  - And how can I add my script there or connect analytics? <br>  - Through an array of scripts in the config or in the corresponding module in the project.  In the <a href="https://github.com/tamtakoe/node-arjs-builder-seed">demo application</a> specifically added an example with analytics and meta tags. <br><blockquote>  The abstract marketing agency asks you to add Yandex.Metrica, googleAnalitycs, googleTagManager, vkontakte, mailru, doubleClick counters ... and everyone needs to place their script in the index, and in order to increase others, so that it creates its own shit-ifframe or shit-picture in one pixel.  And not fucked you, gentlemen?  Do you think you can just shit in the index?  Now all these upstarts are enclosed in a separate module and are connected only if there is permission in the config.  We do not want to observe a bunch of left-hand queries in local development? </blockquote><br>  In <code>lib.js</code> are <s>microframe forks the</s> most necessary methods that should be available before loading the main framework.  Such as: the definition of the browser, the user's locale, loading scripts and so on.  In theory, it should not be necessary to change this file, but so far it has not debugged it enough to guarantee this. <br><br>  Now consider the simplified structure of a separate project: <br><pre> <code class="bash hljs">_config/ ‚îú‚îÄ‚îÄdefault.yaml ‚îú‚îÄ‚îÄdev.yaml ‚îî‚îÄ‚îÄproduction.yaml module1/ ‚îú‚îÄ‚îÄ_tests ‚îú‚îÄ‚îÄsomeFolder1/ ‚îÇ ‚îú‚îÄ‚îÄsome.js ‚îÇ ‚îú‚îÄ‚îÄstyle.sass ‚îÇ ‚îî‚îÄ‚îÄtemplate.html ‚îú‚îÄ‚îÄsomeFolder2/ ‚îî‚îÄ‚îÄconfig.js module2/ module3/ bootstrap.js requireconfig.js</code> </pre><br>  Come with the end. <br>  <code>requireconfig.js</code> - connects library files to the project <br>  <code>bootstrap.js</code> - include project files.  The standard work scheme require.js <br>  <code>module1..3</code> - project modules.  At the time of assembly, each module is collected in a separate file. <br>  In <code>_tests</code> are tests related to files in the current folder.  As tests, files ending in <code>spec.js</code> . <br>  The <code>config.js</code> describes the dependencies of the corresponding module. <br>  <code>someFolder</code> can have any structure (the main thing is that all dependencies are described) <br>  If next to the script file is template.html or style.css / .sass / .scss / .less / .stylus, they will be added to the template cache or compiled style file.  Very simple rule.  The collector does not drag anything, and takes only what is related to the script file in the sequence in which the scripts are loaded. <br><br>  The most interesting is <code>_config</code> <br>  Configurations for various environments are stored here.  Supported formats are json, json5, hjson, cson, yaml.  As soon as IDE starts supporting json5, I will translate all the examples into it and leave it with the only supported format.  In <code>default</code> settings common to all environments are described.  The rest of configs are defaulted. <br><br>  To build a project with the necessary config you need to specify its name by the first parameter. <br><pre> <code class="bash hljs">gulp --qa gulp build --production</code> </pre><br>  The default is <code>dev</code> . <br><br>  Configuration file structure: <br><pre> <code class="javascript hljs">{ <span class="hljs-attr"><span class="hljs-attr">public</span></span>: { ... }, <span class="hljs-comment"><span class="hljs-comment">//,     project.config localhost: { webserver: { ... }, //  - manifest: { ... } //     }, build: { /*      */ ... manifest: { ... }, //     modules: { ... }, //    ,   vendor    mangle: true,         copy: { ... } //   - ,  robots.txt }, vendor: { ... }, //   . ,   bootstrap  angularStrap     }</span></span></code> </pre><br>  The config is probably the hardest thing in the collector.  To present it, it is better to look at examples of applications <a href="https://github.com/tamtakoe/node-arjs-builder-seed">more difficult</a> , <a href="https://github.com/tamtakoe/node-arjs-builder/tree/master/demo">simpler</a> and <a href="https://github.com/tamtakoe/node-arjs-builder">documentation</a> . <br><br><h2>  Why all the RequireJS? </h2><br>  Of course, so that the modules are loaded as needed, and not all at once ... Someone will say.  But no. <br><br>  The assembled project has the following structure: <br><pre> <code class="bash hljs">vendor-f8acc4024d.js <span class="hljs-comment"><span class="hljs-comment">#800 vendor-9dcd7dad8d.css #100 common-95dafc6502.js #200 homepage-2979ff1937.js #30 news-ebf043aeac.js #10 ...</span></span></code> </pre><br>  If you think about it, you can conclude that in any vendor project (a module with library components) it will have the largest weight of about 1MB (in no way less than 500KB).  At the same time, lazy loading cannot be organized, since all libraries must be loaded before the project starts.  Of course, you can split it into files for each library, but then loading them will clog up all browser streams and postpone loading of the rest of the project files, which will not bring significant gains.  It is saved by the fact that vendor of all modules changes least of all, therefore it will almost always be taken from the cache. <br><br>  The next in size is the main module, which describes the general logic and common styles for the entire project.  It also rarely changes. <br><br>  Next are 10‚Äì20 modules for sections and various business logic.  They change often, but weigh a penny.  Moreover, in sum, their weight is comparable to the weight of all libraries. <br><br>  <i>To speed up the loading and quickly display the elements, it makes sense to move the style files from the vendor and the main module into separate modules (the assembly allows you to customize the inclusion of CSS in JS and the order of loading individually for each module).</i>  <i>In the example in the figure below, it would be possible to render the styles of the payment module, since they include heavy icons of payment systems</i> . <br><br>  And now let's see how the first download of the project will take place (the files have a small weight, since gzip is enabled): <br><img src="https://habrastorage.org/getpro/habr/post_images/65a/d9b/542/65ad9b5423d5aea775a735b52b778eb6.png" alt="network"><br><br>  It is well noticeable that while the vendor is loading, almost all project resources manage to load.  That is, there is no point in lazy loading modules.  Moreover, it will slow down the site, since you will have to wait for the download of some 10KB file if the user moves to another section.  In other words, neither for large projects nor for small projects, RequireJS is NOT NEEDED! <br><br>  So why is it used?  Exclusively for development. <br><br>  Its main advantage is that you can easily connect dependencies and borrow components from different projects.  For example, the same routing, the same resources, the same error handling are used in the admin.  Why copy-paste if you can just connect the necessary modules from the main project?  This allows you to deploy new projects as quickly as possible. <br><br>  The secondary advantage is that the local collector does not need a collector (only the server is running).  Scripts are not compiled.  The result is available instantly, and in large projects it costs a lot.  But what about Babel, ES6, Coffee, TypeScript?  No way.  The build was created for use in large and medium-sized projects in production.  If you have a university research paper or a homepage, why do you need an assembly at all?  And if all this is in a serious project, but in production ... Let us put our hands on the heart again, you just learn new technologies at the expense of the employer.  For the same reason, no html preprocessors are supported (although this is quite simple).  JS and HTML know any web developers, unlike other technologies that are popular today, and tomorrow everyone has forgotten about them. <br><br><h2>  So how does all this run? </h2><br>  Install globally bower and gulp: <br><pre> <code class="bash hljs">npm i -g bower npm i -g gulp</code> </pre><br>  Download a <a href="https://github.com/tamtakoe/node-arjs-builder/tree/master/demo">simplified</a> or <a href="https://github.com/tamtakoe/node-arjs-builder-seed">full</a> demo project, type commands in its folder: <br><pre> <code class="bash hljs">npm i bower i gulp</code> </pre><br>  Open <a href="http://localhost:7000/">localhost: 7000</a> , admire. <br><br>  Dial: <br><pre> <code class="bash hljs">gulp build --production gulp</code> </pre><br>  Open <a href="http://localhost:7200/">localhost: 7200</a> , admire the assembled version for production, which will appear in the build folder <br><br>  <b>Something didn't work?</b> <br>  So npm did not load or clumsily loaded modules.  If there is a problem with Karma, make sure that it and all its plugins are in the same node_modules folder.  If it does not find node-sass, most likely you recently updated the node - reinstall all the plugins.  No rights to change the folder - try another console.  When installing solid errors, but everything works / does not work - you have Winda. <br><br><h2>  Future plans </h2><br><ul><li>  Build build will be possible without RequireJS.  Now the extra 17KB are tolerable (compared to the weight of the entire project). </li><li>  Simplify API. </li><li>  Support for other frameworks (not alone). </li><li>  Speed ‚Äã‚Äã... Although now all processes occur in RAM, and livereload compiles only the styles of the changed module. </li><li>  Support for multilingual projects. </li><li>  Generating documentation from code. </li><li>  Write an article about the architecture of the project on AngularJS.  Now only the general structure has been affected, which does not explain what modules should be in the project and how they should be written. </li><li>  In general, rewrite everything in C ++, getting rid of the crap, and so on.  (probably not in this life) </li></ul><br>  Thank you for your attention, I am ready to listen to criticism. </div><p>Source: <a href="https://habr.com/ru/post/271281/">https://habr.com/ru/post/271281/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271271/index.html">What else affects the infrastructure: How to ensure the quality of equipment installation</a></li>
<li><a href="../271273/index.html">Introducing the new version of Kerio Connect 9</a></li>
<li><a href="../271275/index.html">NOT useful tips for the programmer</a></li>
<li><a href="../271277/index.html">Webinar "Kerio Operator - Why is VoIP?"</a></li>
<li><a href="../271279/index.html">400 amazing free services</a></li>
<li><a href="../271283/index.html">Trash in bookmarks and disabling side panels in the assembly Vivaldi 1.0.330.3</a></li>
<li><a href="../271285/index.html">Regular expressions and math parser</a></li>
<li><a href="../271287/index.html">Development of secure banking applications: the main problems and how to avoid them</a></li>
<li><a href="../271289/index.html">Transfer server farms to more advanced and energy efficient server cooling technologies</a></li>
<li><a href="../271291/index.html">Introduction to 3D Touch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>