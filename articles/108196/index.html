<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pattern Magic, CallWithType Pattern</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear Khabrovchane! 

 In this article I want to talk about how in C ++ you can do the conversion of compile-time data (types) into run-time ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pattern Magic, CallWithType Pattern</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear Khabrovchane! <br><br>  In this article I want to talk about how in C ++ you can do the <b>conversion of compile-time data</b> (types) <b>into run-time data</b> (integer values) <b>and back</b> . <br><br>  Example: <br><blockquote>  <font color="#0000ff">int</font> nType <font color="#000080">=</font> ... <font color="#008080">;</font> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <font color="#0000ff">if</font> <font color="#008000">(</font> boost <font color="#008080">::</font> <font color="#007788">is_base_of</font> <font color="#000080">&lt;</font> ISettable, <font color="#ff0000">/ * ... magically resolve type hidden here ... * /</font> <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">value</font> <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Do something</font> <br>  <font color="#008000">}</font> <br>  <font color="#0000ff">else</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Do something else</font> <br>  <font color="#008000">}</font> </blockquote><br>  This whole topic is aimed at understanding what to write instead of ‚Äúmagically resolve type hidden by nType here‚Äù. <br><a name="habracut"></a><br>  If you are only interested in the result, go directly to the last section. <br><br><h4>  A bit of history </h4><br>  It all started with the fact that I had to work with a complex factory of objects, which worked approximately as follows: to create an object, a certain function was invoked, which, based on the abyss of dynamic data, returned the ID of the type of object to be created.  This ID then got into switch case, which actually created the necessary object, like this: <br><blockquote>  <font color="#0000ff">int</font> nObjectType <font color="#000080">=</font> ResolveObjectType <font color="#008000">(</font> ... <font color="#008000">)</font> <font color="#008080">;</font> <br><br>  boost <font color="#008080">::</font> <font color="#007788">shared_ptr</font> <font color="#000080">&lt;</font> IObject <font color="#000080">&gt;</font> pObject <font color="#000080">=</font> CreateObject <font color="#008000">(</font> nObjectType <font color="#008000">)</font> <font color="#008080">;</font> </blockquote><br>  In this system, everything was fine until it turned out that, under certain runtime conditions, some objects need to be hung with wrappers like: <br><blockquote>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  <font color="#0000ff">class</font> CFilter <font color="#008080">:</font> <font color="#0000ff">public</font> TObject <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">virtual</font> <font color="#0000ff">bool</font> FilterValue <font color="#008000">(</font> ... <font color="#008000">)</font> <font color="#008000">{</font> ... <font color="#008000">}</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> </blockquote><br>  Such vrappers added some new functionality to objects, which is necessary under certain conditions.  Naturally, initially the wrappers were hung up a little more than constantly and a little less than on all types of objects (for this you only had to add a few lines of code, very simple).  However, the extra wrappers, although they did not harm the logic of the work, but increased the size of the objects, which was unacceptable: both the factory itself and the objects created with its help were critical in terms of performance and memory consumption. <br><br>  Thus, it was necessary to switch on the wrappers as an option.  Immediately there were problems: <br><ul><li>  When adding a single wrapper, the number of types of objects created grew almost 2 times, because  The wrapper was applicable not to a single type, but to a certain set of types. </li><li>  When adding these new types, I had to search for all switch cases by type for the entire code. <pre>  (after all, if before some code reacted to an object of type A, now it still has to react to CFilter &lt;A&gt;, because the type has not changed in fact, just added new features). </pre></li><li>  By the value returned by GetObjectType (...) it was absolutely impossible to restore the original type (without a manually written switch), which did not allow writing abstract code that turns on if the object is, say, inherited from a certain interface.  For example, under certain conditions, CFilter's wrapper should have been applied to all objects inherited from the ISettable. </li><li>  Already created objects could not normally determine their real type without using dynamic_cast (very slowly). </li></ul>  Having understood all this, I sat down and thought.  It turned out that all I need is to learn how to pull out the type that is hidden behind the value returned by GetObjectType (...), and this so that it is understandable to the compiler, i.e.  so that you can write things in the spirit of: <br><blockquote>  <font color="#0000ff">int</font> nType <font color="#000080">=</font> ... <font color="#008080">;</font> <br><br>  <font color="#0000ff">if</font> <font color="#008000">(</font> boost <font color="#008080">::</font> <font color="#007788">is_base_of</font> <font color="#000080">&lt;</font> ISettable, <font color="#ff0000">/ * ... magically resolve type hidden here ... * /</font> <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">value</font> <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Do something</font> <br>  <font color="#008000">}</font> <br>  <font color="#0000ff">else</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Do something else</font> <br>  <font color="#008000">}</font> </blockquote><br>  My first thought: ‚Äúthis is impossible!‚Äù <br><br><h4>  Stencil magic, or the impossible is possible! </h4><br>  After some more thought, I came to the conclusion that it was necessary to ‚Äúsimply‚Äù write the following two functions: <br><blockquote>  <font color="#666666">//!</font>  <font color="#666666">Returns object type descriptor correspondent to TObject.</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  <font color="#0000ff">inline</font> <font color="#0000ff">int</font> MakeDescriptor <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">Calls rcFunctor with nTypeDescriptor.</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TFunctor <font color="#000080">&gt;</font> <br>  <font color="#0000ff">inline</font> <font color="#0000ff">typename</font> Impl <font color="#008080">::</font> <font color="#007788">ResolveReturnType</font> <font color="#000080">&lt;</font> TFunctor <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> CallWithType <font color="#008000">(</font> <font color="#0000ff">const</font> TFunctor <font color="#000040">&amp;</font> rcFunctor, <font color="#0000ff">int</font> nTypeDescriptor <font color="#008000">)</font> <font color="#008080">;</font> </blockquote><br>  Everything is clear here: <br><ul><li>  The first function returns an object type descriptor (number) depending on the type of object (template parameter). </li><li>  The second function calls the functor passed to it, using as a parameter a pointer to the type of object encoded within the number nTypeDescriptor.  Thus, using the template operator () in the functor, you can completely restore the original type. </li></ul>  You can use it this way (in this example, we determine whether the type encoded by the descriptor from an interface is inherited): <br><blockquote>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TKind <font color="#000080">&gt;</font> <br>  <font color="#0000ff">struct</font> IsKindOfHelper <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">typedef</font> <font color="#0000ff">bool</font> <br>  R <font color="#008080">;</font> <br><br>  <font color="#0000ff">inline</font> <font color="#0000ff">bool</font> operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">return</font> <font color="#0000ff">false</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">inline</font> <font color="#0000ff">bool</font> operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> TKind <font color="#000040">*</font> <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">return</font> <font color="#0000ff">true</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> <br><br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  <font color="#0000ff">inline</font> <font color="#0000ff">bool</font> IsKindOf <font color="#008000">(</font> <font color="#0000ff">int</font> nTypeDescriptor <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">Return</font> CallWithType <font color="#008000">(</font> IsKindOfHelper <font color="#000080">&lt;</font> TObject <font color="#000080">&gt;</font> <font color="#008000">(</font> <font color="#008000">)</font> , nTypeDescriptor <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  ... <br><br>  <font color="#0000ff">int</font> nType <font color="#000080">=</font> ... <font color="#008080">;</font> <br><br>  <font color="#0000ff">if</font> <font color="#008000">(</font> IsKindOf <font color="#000080">&lt;</font> ISettable <font color="#000080">&gt;</font> <font color="#008000">(</font> nType <font color="#008000">)</font> <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Do something</font> <br>  <font color="#008000">}</font> <br>  <font color="#0000ff">else</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Do something else</font> <br>  <font color="#008000">}</font> </blockquote><br><h5>  Type lists and descriptors. </h5><br>  So, we will start implementation.  First of all, we need some kind of compile-time table that will determine the correspondence of type descriptors and types.  The simplest option here is Loki :: Typelist, this is a structure of the following form: <br><blockquote>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> T, <font color="#0000ff">class</font> U <font color="#000080">&gt;</font> <br>  <font color="#0000ff">struct</font> typelist <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">typedef</font> T Head <font color="#008080">;</font> <br>  <font color="#0000ff">typedef</font> U Tail <font color="#008080">;</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> </blockquote><br>  The contemplation of this structure in its time completely reversed my understanding of C ++.  Let's see what it is for.  It's very simple: with its help lists of types of arbitrary length are defined: <br><blockquote>  <font color="#0000ff">typedef</font> Loki <font color="#008080">::</font> <font color="#007788">Typelist</font> <font color="#000080">&lt;</font> <font color="#0000ff">int</font> , Loki <font color="#008080">::</font> <font color="#007788">Typelist</font> <font color="#000080">&lt;</font> <font color="#0000ff">char</font> , Loki <font color="#008080">::</font> <font color="#007788">Typelist</font> <font color="#000080">&lt;</font> <font color="#0000ff">void</font> , Loki <font color="#008080">::</font> <font color="#007788">NullType&gt;&gt;&gt;</font> <br>  TMyList <font color="#008080">;</font> </blockquote><br>  Here is a list of types of three elements: int, char, void.  Loki :: NullType means the end of the list.  Using special metafunctions from this list, you can pull out type indices and types by index: <br><blockquote>  <font color="#666666">// int MyInt;</font> <br>  Loki <font color="#008080">::</font> <font color="#007788">TypeAt</font> <font color="#000080">&lt;</font> TMyList, <font color="#0000dd">0</font> <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">Result</font> MyInt <font color="#008080">;</font> <br><br>  <font color="#666666">// char MyChar;</font> <br>  Loki <font color="#008080">::</font> <font color="#007788">TypeAt</font> <font color="#000080">&lt;</font> TMyList, <font color="#0000dd">1</font> <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">Result</font> MyChar <font color="#008080">;</font> <br><br>  <font color="#0000ff">int</font> nIndexOfChar <font color="#000080">=</font> Loki <font color="#008080">::</font> <font color="#007788">IndexOf</font> <font color="#000080">&lt;</font> TMyList, <font color="#0000ff">char</font> <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">value</font> <font color="#008080">;</font> </blockquote><br>  All these metafunctions are "called" at compile time and do not require the overhead of execution time.  More information about Loki, you can read in <a href="http://en.wikipedia.org/wiki/Loki_(C%252B%252B)">Wikipedia</a> , there is also a link to the source library.  In the book <a href="http://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315/ref%3Dsr_1_1%3Fie%3DUTF8%26qid%3D1294145634%26sr%3D8-1">"Modern design in C ++" (Alexandrescu)</a> you can find out how it all works. <br><br>  In practice, I used the <a href="http://www.boost.org/doc/libs/1_45_0/libs/mpl/doc/index.html">Boost MPL</a> library.  It is more difficult, but its possibilities are much wider.  Experiments have shown that the compiler maintains about 2000 types of objects, after which the following picture is observed: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/50e/30e/bcf50e30e18e8be796f779579012e794.png" alt="It compiles .."><br><br><h5>  Implementing a pattern through type lists. </h5><br>  Idea: <pre>  List all known object types in a list of types.  Then, the index of a particular type will be a type descriptor, but knowing the type descriptor, you can infer the type itself by looking at it in the list.  The only problem is the following: for type inference by index, the index must be represented as a constant (compile-time values), i.e.  we need to learn how to convert the values ‚Äã‚Äãof numerical variables to the corresponding types of the type mpl :: int_ &lt;# value #&gt; </pre><br><blockquote> <font color="#0000ff">using</font> <font color="#0000ff">namespace</font> boost <font color="#008080">;</font> <br><br>  <font color="#0000ff">namespace</font> impl <br>  <font color="#008000">{</font> <br>  <font color="#666666">//!</font>  <font color="#666666">A list of known object types.</font> <br>  <font color="#ff0000">/ ** In real world this structure constructed by templates.</font>  <font color="#ff0000">* /</font> <br>  <font color="#0000ff">typedef</font> mpl <font color="#008080">::</font> <font color="#007788">list</font> <font color="#000080">&lt;</font> TObjectType1, TObjectType2, TObjectType3 <font color="#000080">&gt;</font> <br>  TKnownObjectTypes <font color="#008080">;</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">Count of the known object types.</font> <br>  <font color="#0000ff">typedef</font> mpl <font color="#008080">::</font> <font color="#007788">size</font> <font color="#000080">&lt;</font> TKnownAtomTypes <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> <br>  TKnownObjectTypesCount <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">namespace</font> impl <br>  <font color="#008000">{</font> <br>  <font color="#666666">//!</font>  <font color="#666666">This metafunction returns an index of the TObject from the TKnownObjects.</font> <br>  <font color="#ff0000">/ ** If TObject is absent in TKnownObjects, returns -1 * /</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  <font color="#0000ff">struct</font> MakeDescriptorImpl <br>  <font color="#008080">:</font> <font color="#ff0000">/ * if * /</font> mpl <font color="#008080">::</font> <font color="#007788">eval_if</font> <font color="#000080">&lt;</font> <br>  <font color="#ff0000">/ * find (TObject) == end * /</font> <br>  is_same <font color="#000080">&lt;</font> <br>  <font color="#0000ff">typename</font> mpl <font color="#008080">::</font> <font color="#007788">find</font> <font color="#000080">&lt;</font> TKnownObjectTypes, TObject <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> , <br>  mpl <font color="#008080">::</font> <font color="#007788">end</font> <font color="#000080">&lt;</font> TKnownObjectTypes <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> <font color="#000080">&gt;</font> , <br>  <font color="#ff0000">/ * then return -1 * /</font> <br>  mpl <font color="#008080">::</font> <font color="#007788">identity</font> <font color="#000080">&lt;</font> mpl <font color="#008080">::</font> <font color="#007788">int_</font> <font color="#000080">&lt;</font> <font color="#000040">-</font> <font color="#0000dd">1</font> <font color="#000080">&gt;&gt;</font> , <br>  <font color="#ff0000">/ * else return distance (begin, find (TObject)) * /</font> <br>  mpl <font color="#008080">::</font> <font color="#007788">apply</font> <font color="#000080">&lt;</font> <br>  mpl <font color="#008080">::</font> <font color="#007788">distance</font> <font color="#000080">&lt;</font> <br>  mpl <font color="#008080">::</font> <font color="#007788">begin</font> <font color="#000080">&lt;</font> TKnownObjectTypes <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> , <br>  mpl <font color="#008080">::</font> <font color="#007788">find</font> <font color="#000080">&lt;</font> TKnownObjectTypes, _ <font color="#000080">&gt;&gt;</font> , <br>  TObject <font color="#000080">&gt;&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> <br>  <font color="#008000">{</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">Helps to call TFunctor with TObjectType *</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TFunctor <font color="#000080">&gt;</font> <br>  <font color="#0000ff">struct</font> CallWithObjectTypeHelperPointerBased <br>  <font color="#008000">{</font> <br><br>  <font color="#0000ff">public</font> <font color="#008080">:</font> <br><br>  <font color="#666666">// typename ResolveReturnType &lt;TFunctor&gt; :: type evalutes to TFunctor :: R if</font> <br>  <font color="#666666">// TFunctor :: R typedef is present, otherwise, it is to void.</font> <br>  <font color="#0000ff">typedef</font> <font color="#0000ff">typename</font> ResolveReturnType <font color="#000080">&lt;</font> TFunctor <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> <br>  R <font color="#008080">;</font> <br><br>  <font color="#0000ff">protected</font> <font color="#008080">:</font> <br><br>  <font color="#0000ff">const</font> TFunctor <font color="#000040">&amp;</font> <br>  m_rcFunctor <font color="#008080">;</font> <br><br>  <font color="#0000ff">public</font> <font color="#008080">:</font> <br><br>  CallWithObjectTypeHelperPointerBased <font color="#008000">(</font> <font color="#0000ff">const</font> TFunctor <font color="#000040">&amp;</font> rcFunctor <font color="#008000">)</font> <br>  <font color="#008080">:</font> m_rcFunctor <font color="#008000">(</font> rcFunctor <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">This function is called by CallWithInt (...).</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TIndex <font color="#000080">&gt;</font> <br>  R operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> TIndex <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Find object type by index</font> <br>  <font color="#0000ff">typedef</font> <font color="#0000ff">typename</font> mpl <font color="#008080">::</font> <font color="#007788">at</font> <font color="#000080">&lt;</font> TKnownObjectTypes, TIndex <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> <br>  TObject <font color="#008080">;</font> <br><br>  <font color="#666666">// Call functor with pointer to real object type</font> <br>  <font color="#0000ff">return</font> m_rcFunctor <font color="#008000">(</font> <font color="#008000">(</font> TObject <font color="#000040">*</font> <font color="#008000">)</font> <font color="#0000ff">NULL</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">This function is called by CallWithInt (...).</font> <br>  R operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> mpl <font color="#008080">::</font> <font color="#007788">void_</font> <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// The descriptor is broken, call functor with special value</font> <br>  <font color="#0000ff">return</font> m_rcFunctor <font color="#008000">(</font> mpl <font color="#008080">::</font> <font color="#007788">void_</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> <br><br>  <font color="#008000">}</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">Returns Object type descriptor correspondent to TObject.</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  <font color="#0000ff">inline</font> <font color="#0000ff">int</font> MakeDescriptor <font color="#008000">(</font> <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Attempt to make Object type description for unknown Object type!</font> <br>  BOOST_STATIC_ASSERT <font color="#008000">(</font> Impl <font color="#008080">::</font> <font color="#007788">MakeDescriptorImpl</font> <font color="#000080">&lt;</font> TObject <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">value</font> <font color="#000040">!</font> <font color="#000080">=</font> <font color="#000040">-</font> <font color="#0000dd">1</font> <font color="#008000">)</font> <font color="#008080">;</font> <br><br>  <font color="#666666">// Return descriptor, this is actually compile time generated constant.</font> <br>  <font color="#0000ff">return</font> Impl <font color="#008080">::</font> <font color="#007788">MakeDescriptorImpl</font> <font color="#000080">&lt;</font> TObject <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">value</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">Calls rcFunctor with TObject * correspondent to nObjectTypeDescriptor.</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TFunctor <font color="#000080">&gt;</font> <br>  <font color="#0000ff">inline</font> <font color="#0000ff">typename</font> Impl <font color="#008080">::</font> <font color="#007788">ResolveReturnType</font> <font color="#000080">&lt;</font> TFunctor <font color="#000080">&gt;</font> <font color="#008080">::</font> <font color="#007788">type</font> CallWithType <font color="#008000">(</font> <font color="#0000ff">const</font> TFunctor <font color="#000040">&amp;</font> rcFunctor, <font color="#0000ff">int</font> nObjectTypeDescriptor <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Call with int will call</font> <br>  <font color="#666666">// Impl :: CallWithObjectTypeHelperPointerBased &lt;TFunctor&gt; (rcFunctor)</font> <br>  <font color="#666666">// functor with mpl :: int_ &lt;N&gt; () argument, where N is compile time constant</font> <br>  <font color="#666666">// correspondent to the value of nObjectTypeDescriptor.</font> <br>  <font color="#666666">// If nObjectTypeDescriptor &lt;0 ||</font>  <font color="#666666">nObjectTypeDescriptor&gt; = TKnownObjectTypesCount</font> <br>  <font color="#666666">// functor will be used with mpl :: void_ (), indicating that type descriptor is broken.</font> <br>  <font color="#0000ff">return</font> Impl <font color="#008080">::</font> <font color="#007788">CallWithInt</font> <font color="#000080">&lt;</font> mpl <font color="#008080">::</font> <font color="#007788">int_</font> <font color="#000080">&lt;</font> <font color="#0000dd">0</font> <font color="#000080">&gt;</font> , TKnownObjectTypesCount <font color="#000080">&gt;</font> <font color="#008000">(</font> <br>  Impl <font color="#008080">::</font> <font color="#007788">CallWithObjectTypeHelperPointerBased</font> <font color="#000080">&lt;</font> TFunctor <font color="#000080">&gt;</font> <font color="#008000">(</font> rcFunctor <font color="#008000">)</font> , <br>  nObjectTypeDescriptor <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> </blockquote><br>  I tried to comment in detail on all the code, but it is still quite complicated, so there are some comments: <br><br>  one. <br>  typename ResolveReturnType :: type is interpreted by the compiler as TFunctor :: R.  If TFunctor :: R is an invalid expression (for example, if the definition of type R is not in the TFunctor), then typename ResolveReturnType :: type is interpreted as void.  <a href="http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/has-xxx-trait-def.html">Yes it is possible.</a>  <a href="http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/has-xxx-trait-def.html">No, I'm not lying</a> .  The implementation can be viewed below, by reference in which the implementation of CallWithInt is described. <br><br>  2 <br>  MakeDescriptorImpl is actively working with <a href="http://www.boost.org/doc/libs/1_44_0/libs/mpl/doc/refmanual/refmanual_toc.html">boost :: mpl</a> and it looks awesome.  For the sake of clarity, comments contain similar expressions in stl (which, of course, are not applicable at the compilation stage).  The indent style is torn out from <a href="http://ru.wikipedia.org/wiki/Scheme">Scheme</a> .  For those who are familiar with functional programming languages, you just need to understand that metaprogramming (template magic) in c ++ is a functional language. <br><br>  3 <br>  CallWithInt is engaged in converting integer runtime values ‚Äã‚Äãfrom a specific range of allowed values ‚Äã‚Äãto integer compile time values.  We will implement this feature later. <br><pre>  Example: 42 is converted to mpl :: int_ &lt;42&gt; </pre><br>  four. <br>  An implementation would be more efficient (in terms of compilation speed) if a binary tree is used instead of mpl :: list.  Unfortunately, I have not found such structures, but I myself have been writing for a long time.  For our project it was not critical, with the number of types less than 500 works and so. <br><br>  five. <br>  In terms of runtime performance, this code is <b>very</b> fast.  CallWithInt, as we will see below, works on nested switch cases, therefore, only a few unconditional jumps with an offset are needed to convert a number to a type.  For the inverse transformation, nothing is needed at all.  MakeDescriptor is inlined into a constant. <br><br>  6 <br>  In the real world, a list of known objects is constructed using patterned magic in the following way: <br><ul><li>  Sets the base list of objects (in the same way as in the example) </li><li>  Each wrapper is applied in turn to each type from the current list of types, if possible.  Wrapper himself determines how he will communicate with a specific type.  The result of the binding (new type) is added to the current type list. </li></ul>  This action is performed using templates at compile time, it takes about 200 lines of code.  To add a new wrapper (and all new types that a wrapper introduces) you need to write about 10 lines in total, while new types will be automatically picked up by the existing code. <br><br>  7 <br>  In addition to the above functions, in the real world several more variants are implemented (for example, MakeDescriptorNonStrict, which returns -1 (and not a compilation error, as usual), if it is applied to an unknown type of science).  CallWithType also has other variants that call a functor, for example, with two pointers (one can be used to specialize in the inheritance tree, and the second to determine the real type). <br><br><h5>  CallWithInt implementation </h5><br><pre>  It remains for us to perform the last (most difficult) step: write a function that will call a functor with the type mpl :: int_ &lt;N&gt; (), where N corresponds to the value stored inside the run-time variable.  This is perhaps the most difficult part, because  it is this that translates runtime values ‚Äã‚Äãinto types. </pre><br>  The idea is very simple: <br><pre>  We make a function with a switch, say one hundred elements, this function should call any functor with the value mpl :: int &lt;N&gt;, where N corresponds to the value of the variable passed to the function.  If we are asked to transform a different interval, we simply do additional manipulations: offset and separation into bins.  So for example, if we are asked to convert a number in the range 56 ... 156 to a type, you just need to subtract 56 times from the variable that was passed to us, and then, after the conversion to type, add 56 (but to the type!).  If we are asked to convert a number from the interval 200..400, we must first divide it into sections "100 each", then calculate the number of the section and the offset inside the section. </pre><br>  I guess I explain it incomprehensibly, so <a href="http://maxmessage.ru/r/3715">here‚Äôs a lot of killer code</a> . <br><br>  Remarks: <br><br>  0 <br>  Many beeches :( <br><br>  one. <br>  In the real world, a switch has 100 case-s (the value was chosen experimentally, the code is operational at any value&gt; = 2). <br><br>  2 <br>  In the real world, switch cases are generated by macros. <br><br>  3 <br>  It works fast.  Very fast.  For this one has to pay with such brutal expressions.  The compiler could not optimize the simple implementation through tail recursion before the switch: ( <br><br><h4>  Application </h4><br>  Now you can do this: <br><br>  1. Creating any objects, just add the type of the object to the list of known types.  Previously, when adding a new type of objects, it was necessary to search for all switch cases by type, now there is no switch case at all, which means that all new types of objects are supported out of the box.  This example illustrates the loss of a switch case. <br><br>  It was: <br><blockquote>  <font color="#0000ff">int</font> nObjectType <font color="#000080">=</font> ResolveObjectType <font color="#008000">(</font> ... <font color="#008000">)</font> <font color="#008080">;</font> <br><br>  <font color="#0000ff">switch</font> <font color="#008000">(</font> nObjectType <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">case</font> <font color="#0000dd">1</font> <font color="#008080">:</font> <br>  <font color="#0000ff">return</font> <font color="#0000dd">new</font> TObject1 <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000ff">case</font> <font color="#0000dd">2</font> <font color="#008080">:</font> <br>  <font color="#0000ff">return</font> <font color="#0000dd">new</font> TObject2 <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000ff">case</font> <font color="#0000dd">3</font> <font color="#008080">:</font> <br>  <font color="#0000ff">return</font> <font color="#0000dd">new</font> TObject3 <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#0000ff">case</font> <font color="#0000dd">4</font> <font color="#008080">:</font> <br>  <font color="#0000ff">return</font> <font color="#0000dd">new</font> TObject4 <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#ff0000">/ * ... 100+ more cases goes here * /</font> <br>  <font color="#0000ff">default</font> <font color="#008080">:</font> <br>  <font color="#0000ff">return</font> <font color="#0000ff">NULL</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> </blockquote><br>  It became: <br><blockquote>  <font color="#666666">//!</font>  <font color="#666666">This wrapper allows to determine real object type.</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TBase, <font color="#0000ff">class</font> TObject <font color="#000080">=</font> TBase <font color="#000080">&gt;</font> <br>  <font color="#0000ff">struct</font> CTypeWrapper <br>  <font color="#008080">:</font> <font color="#0000ff">public</font> TBase <br>  <font color="#008000">{</font> <br>  <font color="#666666">//!</font>  <font color="#666666">Returns type descriptor correspondent to this instance.</font> <br>  <font color="#0000ff">virtual</font> <font color="#0000ff">int</font> TypeDescriptor <font color="#008000">(</font> <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">Return</font> MakeDescriptor <font color="#000080">&lt;</font> TObject <font color="#000080">&gt;</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">Helps to create objects.</font>  <font color="#666666">Actually this is a functor, called with Object type.</font> <br>  <font color="#0000ff">class</font> CreateObjectHelper <br>  <font color="#008000">{</font> <br><br>  <font color="#0000ff">public</font> <font color="#008080">:</font> <br><br>  <font color="#666666">// Return type</font> <br>  <font color="#0000ff">typedef</font> IObject <font color="#000040">*</font> <br>  R <font color="#008080">;</font> <br><br>  <font color="#0000ff">private</font> <font color="#008080">:</font> <br><br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TBase, <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  <font color="#0000ff">inline</font> TBase <font color="#000040">*</font> MakeObject <font color="#008000">(</font> <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">return</font> <font color="#0000dd">new</font> CObjectTypeWrapper <font color="#000080">&lt;</font> TBase, TObject <font color="#000080">&gt;</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">public</font> <font color="#008080">:</font> <br><br>  <font color="#666666">//!</font>  <font color="#666666">Generic case</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  <font color="#0000ff">inline</font> TObject <font color="#000040">*</font> operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> TObject <font color="#000040">*</font> , ... <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">return</font> MakeObject <font color="#000080">&lt;</font> TObject, TObject <font color="#000080">&gt;</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">inline</font> IObject <font color="#000040">*</font> operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> boost <font color="#008080">::</font> <font color="#007788">mpl</font> <font color="#008080">::</font> <font color="#007788">void_</font> <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000dd">assert</font> <font color="#008000">(</font> <font color="#000040">!</font> <font color="#FF0000">"Type Descriptor Is Broken! Mustn't be here!"</font> <font color="#008000">)</font> <font color="#008080">;</font> <br><br>  <font color="#0000ff">return</font> <font color="#0000ff">NULL</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">public</font> <font color="#008080">:</font> <br><br>  <font color="#666666">// Special case for objects, derived from IObjectType1</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  IObject <font color="#000040">*</font> operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> TObject <font color="#000040">*</font> , IObjectType1 <font color="#000040">*</font> <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// ...</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#666666">// Special case for objects, derived from IObjectType2</font> <br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  IObject <font color="#000040">*</font> operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> TObject <font color="#000040">*</font> , IObjectType2 <font color="#000040">*</font> <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// ...</font> <br>  <font color="#008000">}</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> <br><br>  ... <br><br>  <font color="#0000ff">int</font> nObjectType <font color="#000080">=</font> ResolveObjectType <font color="#008000">(</font> ... <font color="#008000">)</font> <font color="#008080">;</font> <br><br>  <font color="#0000ff">return</font> ObjectTraits <font color="#008080">::</font> <font color="#007788">CallDoublePointerBasedFunctorWithObjectType</font> <font color="#008000">(</font> <br>  CreateObjectHelper <font color="#008000">(</font> <font color="#008000">)</font> , <br>  nObjectType <font color="#008000">)</font> <font color="#008080">;</font> <br></blockquote><br>  2. Changing the behavior of classes located in the middle of the inheritance tree, depending on the actual type of object, without using dynamic_cast (the approach with CallWithType is approximately 50 times faster on our class hierarchy): <br><blockquote>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TKind <font color="#000080">&gt;</font> <br>  <font color="#0000ff">struct</font> IsKindOfHelper <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">typedef</font> <font color="#0000ff">bool</font> <br>  R <font color="#008080">;</font> <br><br>  <font color="#0000ff">inline</font> <font color="#0000ff">bool</font> operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> ... <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">return</font> <font color="#0000ff">false</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">inline</font> <font color="#0000ff">bool</font> operator <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">(</font> TKind <font color="#000040">*</font> <font color="#008000">)</font> <font color="#0000ff">const</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">return</font> <font color="#0000ff">true</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br>  <font color="#008000">}</font> <font color="#008080">;</font> <br><br>  <font color="#0000ff">template</font> <font color="#000080">&lt;</font> <font color="#0000ff">class</font> TObject <font color="#000080">&gt;</font> <br>  <font color="#0000ff">inline</font> <font color="#0000ff">bool</font> IsKindOf <font color="#008000">(</font> <font color="#0000ff">int</font> nTypeDescriptor <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">Return</font> CallWithType <font color="#008000">(</font> IsKindOfHelper <font color="#000080">&lt;</font> TObject <font color="#000080">&gt;</font> <font color="#008000">(</font> <font color="#008000">)</font> , nTypeDescriptor <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br><br>  ... <br><br>  <font color="#666666">// TypeDescriptor is a virtual object type.</font> <br>  <font color="#666666">// Implementation shown in previous example (this function by hands)</font> <br>  <font color="#0000ff">if</font> <font color="#008000">(</font> IsKindOf <font color="#000080">&lt;</font> ISettable <font color="#000080">&gt;</font> <font color="#008000">(</font> this <font color="#000040">-</font> <font color="#000080">&gt;</font> TypeDescriptor <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Do something</font> <br>  <font color="#008000">}</font> <br>  <font color="#0000ff">else</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// Do something else</font> <br>  <font color="#008000">}</font> </blockquote><br>  3. Ability to operate with a variable containing a type descriptor directly as with a type.  This helps a lot during the procedure of determining what kind of object you should create (if the type depends on many external factors): <br><blockquote>  <font color="#0000ff">int</font> ApplySomeWrapper <font color="#008000">(</font> <font color="#0000ff">int</font> nType <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#0000ff">bool</font> bShouldBeWrapperApplied <font color="#000080">=</font> ... <font color="#008080">;</font> <br><br>  <font color="#0000ff">if</font> <font color="#008000">(</font> bShouldBeWrapperApplied <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// IsWrapperApplicable converts nType to the real type TObject using CallWithType</font> <br>  <font color="#666666">// and calls WrapperTraits :: CSomeWrapper :: IsApplicable &lt;TObject&gt; :: value metafunction</font> <br>  <font color="#0000ff">if</font> <font color="#008000">(</font> IsWrapperApplicable <font color="#000080">&lt;</font> WrapperTraits <font color="#008080">::</font> <font color="#007788">CSomeWrapper</font> <font color="#000080">&gt;</font> <font color="#008000">(</font> nType <font color="#008000">)</font> <font color="#008000">)</font> <br>  <font color="#008000">{</font> <br>  <font color="#666666">// IsWrapperApplicable converts nType to the real type TObject using CallWithType,</font> <br>  <font color="#666666">// calls WrapperTraits :: CSomeWrapper :: MakeWrappedType &lt;TObject&gt; :: type metafunction</font> <br>  <font color="#666666">// in order to resolve wrapped type, then calls MakeDescriptor for this type.</font> <br>  <font color="#0000ff">return</font> MakeWrappedType <font color="#000080">&lt;</font> WrapperTraits <font color="#008080">::</font> <font color="#007788">CSomeWrapper</font> <font color="#000080">&gt;</font> <font color="#008000">(</font> nType <font color="#008000">)</font> <font color="#008080">;</font> <br>  <font color="#008000">}</font> <br>  <font color="#008000">}</font> <br><br>  <font color="#0000ff">return</font> nType <font color="#008080">;</font> <br>  <font color="#008000">}</font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/108196/">https://habr.com/ru/post/108196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../108185/index.html">Akamai data rate statistics for the 50 largest countries</a></li>
<li><a href="../108188/index.html">Green Elephant in the Land of the Rising Sun</a></li>
<li><a href="../108190/index.html">Smarty 3 Final has been released. What's new?</a></li>
<li><a href="../108191/index.html">Django 1.3 alpha 1</a></li>
<li><a href="../108192/index.html">20 domains-in-gift.</a></li>
<li><a href="../108198/index.html">MeeGo 2010</a></li>
<li><a href="../108199/index.html">Apple MacBook Air still taxis. Video</a></li>
<li><a href="../108200/index.html">[Apple] Tomorrow is just another day. Mystic on the Apple site</a></li>
<li><a href="../108201/index.html">Putin's trailer</a></li>
<li><a href="../108204/index.html">Pre-release version of Chrome OS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>