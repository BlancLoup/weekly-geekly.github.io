<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The advantages of a non-blocking algorithm are not only and not so much in performance.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I hope that the final post of the series - unlike the three previous ones, which turned out to be too hardcore - will cause not only philological inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The advantages of a non-blocking algorithm are not only and not so much in performance.</h1><div class="post__text post__text-html js-mediator-article">  <i>I hope that the final post of the series - unlike the three previous ones, which turned out to be too hardcore - will cause not only philological interest in the habrapublica.</i> <br><br>  One of the commentators of <a href="http://habrahabr.ru/tag/lock%2520free/">the Chen series of posts about lock-free algorithms</a> inquired about the conditions under which these more complex algorithms significantly exceed such simple blocking primitives as critical sections in terms of performance. <br><br>  He is absolutely right that the transition from a simple algorithm to a complex one should be justified by measuring performance: if a simple algorithm copes with its task satisfactorily, then there is nothing to look for good from good. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But the advantages of non-blocking synchronization are not limited only to improved, compared to the usual blocking primitives, performance.  (Later in this post we will see how you can get these non-obvious advantages without switching to a completely lockless synchronization.) <br><a name="habracut"></a><br>  Suppose that to protect the initialization of a singleton, instead of a tricky non-blocking algorithm, we decided to use the usual critical section: <br><pre> CRITICAL_SECTION g_csSingletonX;
 X * g_px = NULL;

 X * GetSingletonX ()
 {
 EnterCriticalSection (&amp; g_csSingletonX);
 if (g_px == NULL)
 {
 g_px = new (nothrow) X ();
 }
 LeaveCriticalSection (&amp; g_csSingletonX);
 return g_px;
 }
</pre><br>  Problems begin if the <code>X()</code> constructor itself uses locks: then, in order to prevent deadlocks, the program must define a <i>hierarchy of locks</i> , and lock locks strictly in that order.  (Moreover, if the constructor code is not written by you, and you cannot influence the order of locks in it, then at this stage you will have to admit defeat.) <br><br>  When building a hierarchy of locks, it may be that some of the locks cannot always be locked in the same order, and therefore they need to be merged.  The sync gets coarser.  For example, it may turn out that <code>g_csSingletonX</code> needs to be combined with locks of all singleton constructors, as well as locks of all methods of class X. <br><br><pre> CRITICAL_SECTION g_csCommon;

 X * GetSingletonX ()
 {
 EnterCriticalSection (&amp; g_csCommon);
 if (g_px == NULL)
 {
 g_px = new (nothrow) X ();
 }
 LeaveCriticalSection (&amp; g_csCommon);
 return g_px;
 }

 Y * GetSingletonY ()
 {
 EnterCriticalSection (&amp; g_csCommon);
 if (g_py == NULL)
 {
 g_py = new (nothrow) Y ();
 }
 LeaveCriticalSection (&amp; g_csCommon);
 return g_py;
 }

 void X :: DoSomething ()
 {
 EnterCriticalSection (&amp; g_csCommon);
 .. something ..
 LeaveCriticalSection (&amp; g_csCommon);
 }
</pre><br>  Gee!  From the small and imperceptible critical section, a global block was obtained, for which a lot of threads are constantly competing. <br><br>  The essential advantage of a non-blocking algorithm is that if you do not have locks, then there can be no deadlocks;  hierarchy is no longer needed.  (Unless you build a nonblocking lock out of nonblocking operations, as in the <a href="http://habrahabr.ru/blogs/system_programming/118515/">unstable cache example</a> ).  Another nice feature of non-blocking is that once there are no locks, they will not remain in an ‚Äúunattended‚Äù state when the thread that seized the lock has crashed;  you will not have to wrestle with how to continue to work correctly in the case of <code>WAIT_ABANDONED</code> .  The protected data remains correct all the time, and atomic moves from one correct state to the next. <br><br>  Have you encountered products that, if an error occurs in any one component, can be returned to a working state only by restarting the computer?  Locklessness makes it easier to create programs that do not behave this way. <br><br><hr><br>  Even if you obviously prefer traditional blocking primitives - after all, using them is so convenient!  - then you should take a closer look at non-blocking algorithms.  Suppose in the following code: <br><br><pre> CRITICAL_SECTION g_cs;
 GORILLADATA g_data;

 void PokeGorilla (double intensity)
 {
 EnterCriticalSection (&amp; g_cs);
 DeformGorilla (intensity, &amp; g_data);
 Reticulate (&amp; g_data.spline);
 int stress = CalculateTension (&amp; g_data.spline);
 if (stress &lt;25) g_data.mood = RELAXED;
 else if (stress &lt;50) g_data.mood = ANNOYED;
 else g_data.mood = ANGRY;
 DeleteObject (g_data.hbmGorilla);
 g_data.hbmGorilla = RenderGorilla (&amp; g_data);
 LeaveCriticalSection (&amp; g_cs);
 }
</pre><br>  - There are a number of controversial places.  First of all, is the blocking hierarchy maintained?  For example, the <code>Reticulate()</code> function may require a lock protecting geometric operations;  and it may turn out that, according to the hierarchy, this lock needs to be captured before <code>g_cs</code> . <br><br>  If many threads compete for <code>g_cs</code> , then we would have to reduce the time during which <code>PokeGorilla()</code> holds the lock.  <code>RenderGorilla()</code> is probably a difficult and slow operation.  (You know how hard it is to depict realistic fur.) Then during the <code>RenderGorilla()</code> call, the <code>RenderGorilla()</code> lock <code>g_cs</code> held in vain. <br><br>  A possible solution to both problems is to switch to lockless synchronization;  but this is so hard!  (Almost as hard as realistic fur.) Maybe we can manage to spend only 20% of the work to get 80% of the benefits of non-blocking? <br><br> <code>void PokeGorilla(double intensity) <br> { <br> <font color="#000080">//    <br> EnterCriticalSection(&amp;g_cs); <br> GORILLADATA data = g_data; <br> LeaveCriticalSection(&amp;g_cs); <br> <br> //     </font> <br> DeformGorilla(intensity, &amp;data); <br> Reticulate(&amp;data.spline); <br> int stress = CalculateTension(&amp;data.spline); <br> if (stress &lt; 25)      data.mood = RELAXED; <br> else if (stress &lt; 50) data.mood = ANNOYED; <br> else                  data.mood = ANGRY; <br> data.hbmGorilla = RenderGorilla(&amp;data); <br> <br> <font color="#000080">//  <br> EnterCriticalSection(&amp;g_cs); <br> HBITMAP hbmToDelete = g_data.hbmGorilla; <br> g_data = data; <br> LeaveCriticalSection(&amp;g_cs);</font> <br> DeleteObject(hbmToDelete); <br> } <br></code> <br>  In accordance with the ‚Äúmake, write‚Äù model, we copy the state of the gorilla into a local variable, and perform all actions on this local variable: during the ‚Äúreticulation‚Äù the lock is released, so there are no problems with the hierarchy of locks;  and during the drawing of the gorilla the lock is also removed, so that the remaining threads are less idle for nothing.  When the state of the gorilla is processed, we again capture the lock, and record the changes. <br><br>  In this case, it turns out that the one who poked the gorilla last was the one who won: the state record he was making overwrites all changes made during the processing while the lock was released.  If the changes are independent of each other, then this behavior is acceptable;  but suppose the emotional stress of the gorilla accumulates with each poking.  We need to find out if the gorilla was poked during the time we processed the previous poke;  and if stuck - to take into account the final result of the new data. <br><br>  Then we return to <a href="http://habrahabr.ru/blogs/system_programming/118466/">the ‚Äúmake, write, (try again)‚Äù model</a> with a version counter: <br><br> <code><font color="#000080">LONG g_lCounter;</font> <br> <br> void PokeGorilla(double intensity) <br> { <br> <font color="#000080">BOOL fSuccess; <br> <br> do {</font> <br> //    <br> EnterCriticalSection(&amp;g_cs); <br> GORILLADATA data = g_data; <br> <font color="#000080">LONG lCounter = g_lCounter;</font> <br> LeaveCriticalSection(&amp;g_cs); <br> <br> //      <br> DeformGorilla(intensity, &amp;data); <br> Reticulate(&amp;data.spline); <br> int stress = CalculateTension(&amp;data.spline); <br> if (stress &lt; 25)      data.mood = RELAXED; <br> else if (stress &lt; 50) data.mood = ANNOYED; <br> else                  data.mood = ANGRY; <br> data.hbmGorilla = RenderGorilla(&amp;data); <br> <br> //  <br> EnterCriticalSection(&amp;g_cs); <br> HBITMAP hbmToDelete; <br> <font color="#000080">if (lCounter == g_lCounter) <br> {</font> <br> hbmToDelete = g_data.hbmGorilla; <br> g_data = data; <br> <font color="#000080">g_lCounter++; <br> fSuccess = TRUE; <br> } else { <br> hbmToDelete = data.hbmGorilla; <br> fSuccess = FALSE; <br> }</font> <br> LeaveCriticalSection(&amp;g_cs); <br> DeleteObject(hbmToDelete); <br> <font color="#000080">} while (!fSuccess);</font> <br> } <br></code> <br>  In addition to the usual gorilla data, we store the version number and increment it with each poking.  <code>GORILLADATA</code> , this number would be better stored in the structure of <code>GORILLADATA</code> .  (No, it would be really better not to poke a gorilla!) In a non-blocking algorithm, we would check the value of the version number by using <code>InterlockedCompareExchangeRelease</code> ;  but the structure of <code>GORILLADATA</code> impossible to update atomically, so we use the critical section to check it and simultaneously update it.  Nevertheless, the model remains the same as before: if the gorilla was poked behind our back, we are forced to throw out all the results we have received, and start the calculations in a new way, to reflect both pokes in the final result. </div><p>Source: <a href="https://habr.com/ru/post/118917/">https://habr.com/ru/post/118917/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../118910/index.html">Saving related models in Yii</a></li>
<li><a href="../118912/index.html">We put clouds in one basket</a></li>
<li><a href="../118913/index.html">What is wrong with Microsoft Student Partners (MSP)?</a></li>
<li><a href="../118915/index.html">New look at online Magic 8 Ball</a></li>
<li><a href="../118916/index.html">Google is experimenting with the design of the search results page</a></li>
<li><a href="../118918/index.html">Investors are natural enemies of startups</a></li>
<li><a href="../118919/index.html">DIY processor and PC: project BMOW 1</a></li>
<li><a href="../118921/index.html">You are NOT a software engineer!</a></li>
<li><a href="../118926/index.html">Accelerating the Linux kernel using a GPU GPU</a></li>
<li><a href="../118927/index.html">Getting the Y-combinator in 7 easy steps</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>