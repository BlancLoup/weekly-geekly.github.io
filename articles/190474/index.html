<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data structures, PHP. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue to combine business with pleasure and translate. Today we‚Äôll talk about heaps and graphs. As usual, the material is more suitable for begin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data structures, PHP. Part two</h1><div class="post__text post__text-html js-mediator-article">  I continue to combine business with pleasure and translate.  Today we‚Äôll talk about heaps and graphs.  As usual, the material is more suitable for beginners - most of the information, if not all, has already been covered in some way or another. <br><br>  At the end of the <a href="http://habrahabr.ru/post/190176/">last article,</a> trees were touched upon, so let's start with a heap, since there are common roots between the heap and the trees.  Then we go to the graphs and implement the Dijkstra algorithm. <br><br>  <b>UPD</b> : Added performance comparison <br><a name="habracut"></a><br>  A heap is a special, tree-like structure that has one property ‚Äî any parent node is always greater or equal to its descendants.  Thus, if this condition is met, the root element of the heap will always be maximal.  This option is called the maximum (full) heap or maxheap.  The heap where the root element is minimal and each parent node is less than or equal to its descendants is the minimal heap or minheap. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Binary heap (maxheap) can be represented as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/338/db4/4bf/338db44bfbd1b0f507bb360202252e86.png" alt="image"><br><br>  It is binary because each parent has two children. <br>  It should be noted that heaps, though implemented as binary trees, but they do not have such a thing as ordering and there is no specific order for traversing.  A heap is a variant of a table structure, therefore the following basic operations are applicable to it: <br><br><ol><li>  create - create an empty heap. </li><li>  isEmpty - determine if the heap is empty or not. </li><li>  insert - add an item to the heap. </li><li>  extract - extract and remove an element (root, vertex) from the heap. </li></ol><br><br>  Since the operations of receiving and deleting elements are combined in one extraction operation, we will consider it for the beginning. <br><br>  The rule for removing an element from a heap is that only the root element can be deleted.  Suppose we have removed the root element from the example above (100).  After deletion, we will be left with two separate heaps and we need to somehow rebuild it all into one separate heap.  It is easiest to do this by moving the last node to the root, but in this case such a heap will not be suitable for the main condition.  Such a pile is called semiheap: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e2/28f/d11/6e228fd119fd5b3ad5f1513dd67243a7.png" alt="image"><br><br>  Now it is necessary to make a normal pile out of half a heap.  One of the possible solutions to this problem is to lower the new root downwards, simultaneously comparing the root element with its descendants and changing its places with the maximum descendant.  Thus, we will return the maximum element to the root, while lowering the minimum to the maximum. <br><br>  We can implement maxheap as an array.  A node in a binary tree cannot have more than two children, so for any number of nodes n a binary heap will have 2n + 1 nodes. <br><br>  We implement a bunch as follows: <br><br><pre><code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinaryHeap</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $heap; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;heap = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isEmpty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">empty</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;heap); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    return count($this-&gt;heap) - 1; } public function extract() { if ($this-&gt;isEmpty()) { throw new RunTimeException(' !'); } //           $root = array_shift($this-&gt;heap); if (!$this-&gt;isEmpty()) { //        //         $last = array_pop($this-&gt;heap); array_unshift($this-&gt;heap, $last); //     $this-&gt;adjust(0); } return $root; } public function compare($item1, $item2) { if ($item1 === $item2) { return 0; } //     minheap return ($item1 &gt; $item2 ? 1 : -1); } protected function isLeaf($node) { //    2n + 1   "" return ((2 * $node) + 1) &gt; $this-&gt;count(); } protected function adjust($root) { //     if (!$this-&gt;isLeaf($root)) { $left = (2 * $root) + 1; //   $right = (2 * $root) + 2; //   $h = $this-&gt;heap; //      if ( (isset($h[$left]) &amp;&amp; $this-&gt;compare($h[$root], $h[$left]) &lt; 0) || (isset($h[$right]) &amp;&amp; $this-&gt;compare($h[$root], $h[$right]) &lt; 0) ) { //    if (isset($h[$left]) &amp;&amp; isset($h[$right])) { $j = ($this-&gt;compare($h[$left], $h[$right]) &gt;= 0) ? $left : $right; } else if (isset($h[$left])) { $j = $left; //   } else { $j = $right; //   } //     list($this-&gt;heap[$root], $this-&gt;heap[$j]) = array($this-&gt;heap[$j], $this-&gt;heap[$root]); //     //    $j $this-&gt;adjust($j); } } } }</span></span></code> </pre> <br><br>  Insertion is the opposite, the exact opposite of extraction: we insert an element down the heap and raise it until it is possible and the main condition is met.  Since we know that a full binary tree contains an n / 2 + 1 node, we can bypass the heap using a simple binary search. <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       $this-&gt;heap[] = $item; //     $place = $this-&gt;count(); $parent = floor($place / 2); //        while ( $place &gt; 0 &amp;&amp; $this-&gt;compare( $this-&gt;heap[$place], $this-&gt;heap[$parent]) &gt;= 0 ) { //   list($this-&gt;heap[$place], $this-&gt;heap[$parent]) = array($this-&gt;heap[$parent], $this-&gt;heap[$place]); $place = $parent; $parent = floor($place / 2); } }</span></span></code> </pre><br><br>  Let's see what we did and try to insert several values ‚Äã‚Äãinto the heap: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BinaryHeap(); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">19</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">36</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">54</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">100</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">17</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">3</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">25</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">1</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">67</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">2</span></span>); $heap-&gt;insert(<span class="hljs-number"><span class="hljs-number">7</span></span>);</code> </pre><br><br>  If we try to derive all this, we get the following: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [<span class="hljs-number"><span class="hljs-number">0</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">100</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">67</span></span> [<span class="hljs-number"><span class="hljs-number">2</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">54</span></span> [<span class="hljs-number"><span class="hljs-number">3</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">36</span></span> [<span class="hljs-number"><span class="hljs-number">4</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">19</span></span> [<span class="hljs-number"><span class="hljs-number">5</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">7</span></span> [<span class="hljs-number"><span class="hljs-number">6</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">25</span></span> [<span class="hljs-number"><span class="hljs-number">7</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> [<span class="hljs-number"><span class="hljs-number">8</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">17</span></span> [<span class="hljs-number"><span class="hljs-number">9</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> [<span class="hljs-number"><span class="hljs-number">10</span></span>] =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span> )</code> </pre><br><br>  As you can see, the order is not observed, and in general this is somewhat different than what we expected.  However, if we in turn take elements from the heap, then everything will be fine: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!$heap-&gt;isEmpty()) { <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> $heap-&gt;extract() . <span class="hljs-string"><span class="hljs-string">"n"</span></span>; }</code> </pre><br><br><pre> <code class="html hljs xml">100 67 54 36 25 19 17 7 3 2 1</code> </pre><br><br><h5>  SplMaxHeap and SplMinHeap </h5><br>  Fortunately, we already have ready-made implementations of SplHeap, SplMaxHeap and SplMinHeap.  All we need to do is just to inherit them and override the comparison method, like this: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyHeap</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplMaxHeap</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($item1, $item2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (int) $item1 - $item2; } }</code> </pre><br><br>  This method will perform any comparison of two nodes, and in the case of SplMaxHeap, it returns a positive number if $ item1 is greater than $ item2, 0 if they are equal to each other, and negative if $ item2 is greater than $ item1.  If we inherit SplMinHeap, then it will return a positive number if $ item1 is less than $ item2. <br><br>  It is not recommended to put several identical elements in a heap, since their position will be difficult to determine <br><br><h5>  SplPriorityQueue - priority queue </h5><br>  A priority queue is a special abstract data type that behaves like a queue, but is implemented as a heap.  Regarding the SplPriorityQueue this will be maxheap  The priority queue has quite a few real-world applications, for example, a ticket system or help desk. <br><br>  As in the case of SplHeap, you only need to inherit the SplPriorityQueue and override the comparison method: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PriQueue</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplPriorityQueue</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($p1, $p2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($p1 === $p2) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ,   //    return ($p1 &lt; $p2) ? 1 : -1; } }</span></span></code> </pre><br><br>  The main difference in SplPriorityQueue is that when inserting, in addition to the element value, the priority of this element is also expected.  The insert operation uses priority to sift through the heap based on the result that your comparator returns. <br><br>  Let's check the work of the priority queue, set the numbers as numbers: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $pq = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PriQueue(); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'C'</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'D'</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'F'</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'G'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'H'</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); $pq-&gt;insert(<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($pq-&gt;valid()) { print_r($pq-&gt;current()); <span class="hljs-keyword"><span class="hljs-keyword">echo</span></span> <span class="hljs-string"><span class="hljs-string">"n"</span></span>; $pq-&gt;next(); }</code> </pre><br><br>  What ultimately will give us the following: <br><br><pre> <code class="html hljs xml">I G E B A C H F D</code> </pre><br><br>  In this case, our elements go in descending order of priority - from the highest to the lowest (lower value means higher priority).  You can change the order in which items are returned by simply changing the comparison method so that it returns a positive number if $ p1 is greater than $ p2. <br><br>  By default, only the value of the element is retrieved.  If you want to get only the values ‚Äã‚Äãof the priority, or the values ‚Äã‚Äãand their priority, you need to set the appropriate flag to extract: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-comment"><span class="hljs-comment">//    $pq-&gt;setExtractFlags(SplPriorityQueue::EXTR_PRIORITY); //    (   //   ) $pq-&gt;setExtractFlags(SplPriorityQueue::EXTR_BOTH);</span></span></code> </pre><br><br><h5>  Counts </h5><br>  Behind the graphs there are quite a few real-world applications ‚Äî network optimization, routing, or analysis of social networks.  Google PageRank, recommendations from Amazon are some examples of their use.  In this part of the article I will try to explain two tasks in which they are used - problems finding a short cut and the least number of stops. <br><br>  A graph is a mathematical construct used to represent relationships between key-value pairs.  A graph consists of a set of vertices (nodes) and an arbitrary number of connections between nodes connecting them to each other.  These links can be directional (oriented) and non-directional.  A directional link is a link between two nodes and the link A ‚Üí B is not the same as B ‚Üí A.  The non-directional link has no direction, so the AB and BA links are identical.  Based on these rules, we can say that trees are one of the undirected graphs, where each vertex is connected to one of the nodes by a simple link. <br><br>  Counts can also have weight.  A weighted graph, or a network, is a graph whose weight is indicated for each connection (the ‚Äúprice‚Äù of the transition from node A to node B).  Such constructions are widely used to determine the most optimal path, or the most ‚Äúcheap‚Äù path between two points.  Laying the way in GoogleMap is carried out with the help of a weighted graph. <br><br><h5>  Minimum number of stops (jumps) </h5><br>  The general application of graph theory is used when searching for the minimum number of stops between two nodes.  As for trees, here the graphs help in traversing the tree in one of two directions - in depth or in width.  Since last time we considered the search in depth, now let's take a look at another method. <br><br>  Imagine the following graph: <br><br><img src="http://1450827998816113352488" alt="image"><br><br>  For simplicity, we agree that this graph is undirected.  The task is to find the minimum number of stops between any two nodes.  When searching in width, we start from the root (well, or from another node, which we denote as root) and go down the tree level by level.  To implement this, we need a queue to organize a list of nodes that we have not yet walked around in order to return to it and process it at each level.  The general algorithm is as follows: <br><br><ul><li>  1. Create a queue </li><li>  2. Add the root element there and mark it as visited </li><li>  3. Until the queue is empty: </li><li><ul><li>  3a.  extract current node </li><li>  3b.  if the current node is the desired one, we stop </li><li>  3c.  otherwise, add each unvisited neighbor node to the queue and mark it as visited </li></ul><br></li></ul><br><br>  But how do we know which nodes are adjacent or unvisited without resorting to traversing the graph?  This brings us to the question of how graphs can be modeled. <br><br><h5>  Graph representation </h5><br>  Usually, graphs are represented in two ways - a table or a matrix, where neighboring nodes are described. <br>  Here is how it looks for the first example: <br><br><img src="http://habrastorage.org/getpro/habr/post_images/795/094/f63/795094f6383974072090ac9b6f5b6ab1.png" alt="image"><img src="http://habrastorage.org/getpro/habr/post_images/67b/a5d/a12/67ba5da126ad9801db231e107b9decd1.png" alt="image"><br><br>  In the matrix, at the intersection of nodes is put "1", if the nodes are neighbors. <br><br>  The list is useful if most of the vertices do not have connections between themselves, the matrix provides a faster search.  In the end, the type of representation of the graph depends on what operations with the graph will be performed.  We will use the list. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $graph = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'A'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'F'</span></span>), <span class="hljs-string"><span class="hljs-string">'B'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>, <span class="hljs-string"><span class="hljs-string">'E'</span></span>), <span class="hljs-string"><span class="hljs-string">'C'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'F'</span></span>), <span class="hljs-string"><span class="hljs-string">'D'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'E'</span></span>), <span class="hljs-string"><span class="hljs-string">'E'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span>, <span class="hljs-string"><span class="hljs-string">'F'</span></span>), <span class="hljs-string"><span class="hljs-string">'F'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-string"><span class="hljs-string">'E'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>), );</code> </pre><br><br>  And write our search in width: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Graph</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $graph; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $visited = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($graph)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;graph = $graph; } <span class="hljs-comment"><span class="hljs-comment">//     ()  2  public function breadthFirstSearch($origin, $destination) { //      foreach ($this-&gt;graph as $vertex =&gt; $adj) { $this-&gt;visited[$vertex] = false; } //   $q = new SplQueue(); //           $q-&gt;enqueue($origin); $this-&gt;visited[$origin] = true; //          $path = array(); $path[$origin] = new SplDoublyLinkedList(); $path[$origin]-&gt;setIteratorMode( SplDoublyLinkedList::IT_MODE_FIFO|SplDoublyLinkedList::IT_MODE_KEEP ); $path[$origin]-&gt;push($origin); $found = false; //         while (!$q-&gt;isEmpty() &amp;&amp; $q-&gt;bottom() != $destination) { $t = $q-&gt;dequeue(); if (!empty($this-&gt;graph[$t])) { //     foreach ($this-&gt;graph[$t] as $vertex) { if (!$this-&gt;visited[$vertex]) { //     ,       $q-&gt;enqueue($vertex); $this-&gt;visited[$vertex] = true; //      $path[$vertex] = clone $path[$t]; $path[$vertex]-&gt;push($vertex); } } } } if (isset($path[$destination])) { echo " $origin  $destination  ", count($path[$destination]) - 1, " "; $sep = ''; foreach ($path[$destination] as $vertex) { echo $sep, $vertex; $sep = '-&gt;'; } echo "n"; } else { echo "   $origin  $destinationn"; } } }</span></span></code> </pre><br><br>  By running this example we get the following: <br><br><div class="spoiler">  <b class="spoiler_title">Look at the graph again</b> <div class="spoiler_text"><img src="http://1450827998816113352488" alt="image"></div></div><br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $g = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Graph($graph); <span class="hljs-comment"><span class="hljs-comment">//     D  C $g-&gt;breadthFirstSearch('D', 'C'); // : //  D  C  3  // D-&gt;E-&gt;F-&gt;C //     B  F $g-&gt;breadthFirstSearch('B', 'F'); // : //  B  F  2  // B-&gt;A-&gt;F //     A  C $g-&gt;breadthFirstSearch('A', 'C'); // : //  A  C  2  // A-&gt;F-&gt;C //     A  G $g-&gt;breadthFirstSearch('A', 'G'); // : //   A  G </span></span></code> </pre><br><br>  If we used the stack instead of the queue, then the round would be in depth. <br><br><h5>  Search for the best path </h5><br>  Another common problem is finding the optimal path between any two nodes.  Earlier, I already spoke about building a route in GoogleMaps as an example of solving this problem.  Alternatively, this task can be applied to routing, traffic management, and so on. <br><br>  One of the famous algorithms aimed at solving this problem was invented in 1959 by a 29-year-old scientist named <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D0%25B0,_%25D0%25AD%25D0%25B4%25D1%2581%25D0%25B3%25D0%25B5%25D1%2580_%25D0%2592%25D0%25B8%25D0%25B1%25D0%25B5">Edsger Wibe Dijkstra</a> .  You can learn more about the algorithm in <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B5%25D0%25B9%25D0%25BA%25D1%2581%25D1%2582%25D1%2580%25D1%258B">Wikipedia</a> or look at it at the <a href="http://habrahabr.ru/users/splitface/" class="user_link">splitface</a> .  In general, Dijkstra‚Äôs solution comes down to checking each connection between all possible pairs of nodes, starting from the starting node, and maintaining an updated set of nodes with the shortest distance until the target node is reached, if possible. <br><br>  There are several ways to implement this solution, as well as their additions.  Some of them improved performance, while others only pointed out the weaknesses of Dijkstra‚Äôs solution, since it only works with positively weighted graphs ‚Äî such where there are no negative weights for relationships. <br><br>  For example, take the following positive graph and present it through the list, where we indicate the connection between the nodes: <br><br><img src="http://habrastorage.org/getpro/habr/post_images/740/6b2/a52/7406b2a5243a27028e5db2cf8f2a9fe1.png" alt="image"><br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $graph = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'A'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'B'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'F'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>), <span class="hljs-string"><span class="hljs-string">'B'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'A'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'E'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">'C'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'E'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'F'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>), <span class="hljs-string"><span class="hljs-string">'D'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'A'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'B'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'E'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'F'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-string"><span class="hljs-string">'E'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'B'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'F'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>), <span class="hljs-string"><span class="hljs-string">'F'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'A'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'D'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'E'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>), );</code> </pre><br><br>  We implement the algorithm using the priority queue to create a list of all "non-optimized" nodes: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dijkstra</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $graph; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($graph)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;graph = $graph; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shortestPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($source, $target)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       $d = array(); //  ""    $pi = array(); //     $Q = new SplPriorityQueue(); foreach ($this-&gt;graph as $v =&gt; $adj) { $d[$v] = INF; //      $pi[$v] = null; //     foreach ($adj as $w =&gt; $cost) { //      $Q-&gt;insert($w, $cost); } } //      - 0 $d[$source] = 0; while (!$Q-&gt;isEmpty()) { //    $u = $Q-&gt;extract(); if (!empty($this-&gt;graph[$u])) { //      foreach ($this-&gt;graph[$u] as $v =&gt; $cost) { //        $alt = $d[$u] + $cost; //     if ($alt &lt; $d[$v]) { $d[$v] = $alt; // update minimum length to vertex        $pi[$v] = $u; //       } } } } //       //    $S = new SplStack(); //     $u = $target; $dist = 0; //       while (isset($pi[$u]) &amp;&amp; $pi[$u]) { $S-&gt;push($u); $dist += $this-&gt;graph[$u][$pi[$u]]; //     $u = $pi[$u]; } //   ,     if ($S-&gt;isEmpty()) { echo "   $source  $targetn"; } else { //        //   (LIFO)  $S-&gt;push($source); echo "$dist:"; $sep = ''; foreach ($S as $v) { echo $sep, $v; $sep = '-&gt;'; } echo "n"; } } }</span></span></code> </pre><br><br>  You may notice that Dijkstra's solution is a simple search option in width.  Let's go back to the example and try it out: <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> $g = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dijkstra($graph); $g-&gt;shortestPath(<span class="hljs-string"><span class="hljs-string">'D'</span></span>, <span class="hljs-string"><span class="hljs-string">'C'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 3:D-&gt;E-&gt;C $g-&gt;shortestPath('C', 'A'); // 6:C-&gt;E-&gt;D-&gt;A $g-&gt;shortestPath('B', 'F'); // 3:B-&gt;D-&gt;F $g-&gt;shortestPath('F', 'A'); // 5:F-&gt;D-&gt;A $g-&gt;shortestPath('A', 'G'); //    A  G</span></span></code> </pre><br><br>  Everything.  On it, apparently, articles from Ignatius Teo on structures have ended.  I thank everyone who read, I didn‚Äôt expect that the first part will be placed by so many people into favorites, although we all know that favorites are rarely read and all posts remain there forever :) <br><br>  Performance benchmarks for implementations of these scopipastil structures <a href="http://matthewturland.com/2010/05/20/new-spl-features-in-php-5-3/">from here</a> <br><div class="spoiler">  <b class="spoiler_title">take a look</b> <div class="spoiler_text"> <nobr><img src="http://habrastorage.org/getpro/habr/post_images/b58/51b/427/b5851b427773adc2d6dbfc2363af685a.png" alt="image"></nobr> <nobr><img src="http://habrastorage.org/getpro/habr/post_images/e31/3ce/8bc/e313ce8bcf6099bc8cb2f4455ce6fc27.png" alt="image"><br></nobr> <br><br> <nobr><img src="http://habrastorage.org/getpro/habr/post_images/46a/889/f5c/46a889f5c5ffb916a6be60f119ff7a59.png" alt="image"></nobr> <nobr><img src="http://habrastorage.org/getpro/habr/post_images/08c/42e/91c/08c42e91cb990501f9dd462f880f11e7.png" alt="image"><br></nobr> <br></div></div><br>  Unlike the previous article, here the choice in favor of SPL implementations over ordinary arrays is obvious - using them gives more operations that can be performed in a second + less memory is used. <br><br>  As usual, in lichku my mistakes are accepted in the text, translation, conflicting information, as well as impudent lies. <br>  Comments welcome discussion and subsequent additions to the article. </div><p>Source: <a href="https://habr.com/ru/post/190474/">https://habr.com/ru/post/190474/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../190462/index.html">YouTube for the sake of experiment offers to disable advertising on the site</a></li>
<li><a href="../190464/index.html">The srcset WebKit attribute guide in img tag</a></li>
<li><a href="../190466/index.html">Florida, are going to use drones to fight mosquitoes</a></li>
<li><a href="../190468/index.html">Crossed the border - lost e-books</a></li>
<li><a href="../190472/index.html">The most popular article in a scientific journal</a></li>
<li><a href="../190478/index.html">The developer reported a bug in Facebook on the page Zuckerberg</a></li>
<li><a href="../190480/index.html">How to close the Internet in Russia</a></li>
<li><a href="../190482/index.html">Working with data from related tables in ASP.NET MVC or developing a Lookup component</a></li>
<li><a href="../190484/index.html">Creating a browser igrulki in the social network from and to</a></li>
<li><a href="../190488/index.html">Cookie without cookies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>