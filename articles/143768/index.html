<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Networks for the smallest. Part Four STP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think that I never see 
 A graph more lovely than a tree. 
 A tree whose crucial propertyeu 
 Is loop-free connectivity. 
 A tree that must be sure ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Networks for the smallest. Part Four STP</h1><div class="post__text post__text-html js-mediator-article">  <i>I think that I never see</i> <i><br></i>  <i>A graph more lovely than a tree.</i> <i><br></i>  <i>A tree whose crucial propertyeu</i> <i><br></i>  <i>Is loop-free connectivity.</i> <i><br></i>  <i>A tree that must be sure to span</i> <i><br></i>  <i>So packets can reach every LAN.</i> <i><br></i>  <i>First, the root must be selected.</i> <i><br></i>  <i>By ID, it is elected.</i> <i><br></i>  <i>Least-cost paths from root are traced.</i> <i><br></i>  <i>In the tree, these paths are placed.</i> <i><br></i>  <i>A mesh is made by folks like me,</i> <i><br></i>  <i>Then bridges find a spanning tree.</i> <br>  - Radia Joy Perlman <br><br><h2>  All issues </h2><br>  <a href="http://linkmeup.ru/blog/33.html">6. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/33.html">Part six.</a>  <a href="http://linkmeup.ru/blog/33.html">Dynamic routing</a> <br>  <a href="http://linkmeup.ru/blog/16.html">5. Networks for the smallest: Part Five.</a>  <a href="http://linkmeup.ru/blog/16.html">NAT and ACL</a> <br>  <a href="http://linkmeup.ru/blog/15.html">4. Networks for the smallest: Part Four.</a>  <a href="http://linkmeup.ru/blog/15.html">STP</a> <br>  <a href="http://linkmeup.ru/blog/14.html">3. Networks for the smallest: Part Three.</a>  <a href="http://linkmeup.ru/blog/14.html">Static routing</a> <br>  <a href="http://linkmeup.ru/blog/13.html">2. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/13.html">Part two.</a>  <a href="http://linkmeup.ru/blog/13.html">Switching</a> <br>  <a href="http://linkmeup.ru/blog/12.html">1. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/12.html">Part one.</a>  <a href="http://linkmeup.ru/blog/12.html">Connection to the equipment cisco</a> <br>  <a href="http://linkmeup.ru/blog/11.html">0. Networks for the smallest.</a>  <a href="http://linkmeup.ru/blog/11.html">Part zero.</a>  <a href="http://linkmeup.ru/blog/11.html">Planning</a> <br><br>  In the <a href="http://habrahabr.ru/post/140552/">last issue,</a> we stopped at static routing.  Now we need to take a step aside and discuss the issue of the stability of our network. <br>  Once, when you - the only network administrator of the company ‚ÄúLift Ei Ap‚Äù - asked for a half day before, the connection with the servers suddenly fell, and the directors did not receive several important letters.  After a short but tangible thrashing, you go to figure out what's the matter, but it turned out that, due to some carelessness, the only cable that led to the switch in the server cable fell out of the connector.  A small problem that you could fix in two minutes, and even avoid it altogether, significantly affected your income this month and growth opportunities. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So today we are discussing: <br><br><ul><li>  broadcast storm problem </li><li>  operation and configuration of the STP protocol and its modifications (RSTP, MSTP, PVST, PVST +) </li><li>  interface aggregation technology and load redistribution between them </li><li>  some issues of stability and security </li><li>  how to change the scheme of the existing network so that everyone is good </li></ul><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/qktkRnIamqE%3Ffeature%3Doembed&amp;xid=25657,15700023,15700186,15700190,15700253,15700255,15700259&amp;usg=ALkJrhhB1OUOE0HgG8kcTJzjLfQaFKfeSw" frameborder="0" allowfullscreen=""></iframe><br><br><a name="habracut"></a><br><br>  The equipment operating at the second level of the OSI model (switch) should perform 3 functions: storing addresses, forwarding (switching) packets, protection from loops in the network.  Let us consider the points of each function. <br><br>  <i>Memorizing addresses and packet forwarding</i> : As we said <a href="http://habrahabr.ru/post/138043/">earlier</a> , each switch has a MAC address and port mapping table (aka CAM-table - Content Addressable Memory Table).  When a device connected to a switch sends a frame to the network, the switch looks at the sender's MAC address and the port from which the frame was received, and adds this information to its table.  Next, it must transfer the frame to the recipient whose address is specified in the frame.  In theory, the information about the port where the frame is to be sent, it takes from the same CAM table.  But suppose that the switch has just been turned on (the table is empty), and it has no idea which of its ports the receiver is connected to.  In this case, it sends the received frame to all its ports, in addition, from where it was received.  All end devices, having received this frame, look at the recipient's MAC address, and, if it is not addressed to them, discard it.  The receiving device responds to the sender, and in the field of the sender puts its address, and now the switch already knows that such and such address is on such and such port (makes a record in the table), and next time it will forward the frames addressed to this device , only to this port.  To view the contents of the CAM table, use the <b>show mac address-table</b> command.  Once in the table, the information does not remain there for life, the content is constantly updated and if a certain mac-address is not accessed for 300 seconds (by default), the entry about it is deleted. <br>  Everything should be clear here.  But why <i>protection from loops</i> ?  And what is it all about? <br><br><h2>  Broadcast storm </h2><br>  Often, to ensure the stability of the network in case of problems with communication between the switches (port failure, wire break), use redundant links (additional connections).  The idea is simple - if between links for some reason one link does not work, we use a spare one.  It seems everything is correct, but imagine a situation like this: two switches are connected by two wires (let it be that they have fa0 / 1 and fa0 / 24 connected). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/85e/0c2/48b/85e0c248bb62c8e097e0122465b9886d.jpg"><br><br>  One of their wards, workstations (for example, PC1), suddenly wanted to send a broadcast frame (for example, an ARP request).  Once broadcast, a helmet to all ports, in addition, from which it was received. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd2/a8f/362/dd2a8f3629dcc09ee53f976a5e151fc3.jpg"><br><br>  The second switch receives a frame in two ports, sees that it is broadcast, and also sends to all ports, but already, it turns out, and back to those from which it received (a frame from fa0 / 24 sends to fa0 / 1, and vice versa). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b2d/773/160/b2d773160ed92b791b2a9ae4de705c91.jpg"><br><br>  The first switch does exactly the same, and in the end we get a broadcast storm (broadcast storm), which tightly blocks the network, because the switches are now only engaged in sending each other the same frame. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d13/f1f/86f/d13f1f86f1ab8e49eebf1390987e4edd.jpg"><br><br>  How can you avoid this?  After all, we, on the one hand, do not want storms on the network, but on the other, we want to increase its resiliency by using redundant connections?  This is where STP (Spanning Tree Protocol) comes to our rescue. <br><br><h2>  STP </h2><br>  The main objective of STP is to prevent loops from appearing on the second level.  How to do it?  Yes, just chop off all the redundant links until we need them.  Here, many questions immediately arise: which link of two (or three or four) to chop off?  How to determine that the main link fell, and it's time to include a spare?  How to understand that the network has formed a loop?  To answer these questions, you need to figure out how STP works. <br><br>  STP uses the STA (Spanning Tree Algorithm) algorithm, the result of which is a tree-like graph (connected and without <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584_%2528%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0%2529">simple cycles</a> ) <br><br>  To exchange information between themselves, the switches use special packages, the so-called BPDU (Bridge Protocol Data Units).  BPDUs are of two types: configurational (Configuration BPDU) and panic ‚ÄúAAA, topology changed!‚Äù TCN (Topology Change Notification BPDU).  The first ones are regularly sent by the root switch (and relayed by the others) and are used to build the topology, the second ones, as the name implies, are sent when the network topology changes (in other words, connecting / disconnecting the switch).  Configuration BPDUs contain several fields, let's dwell on the most important ones: <br><br><ul><li>  sender ID (Bridge ID) </li><li>  root switch ID (Root Bridge ID) </li><li>  ID of the port from which this packet is sent (Port ID) </li><li>  the cost of the route to the root switch (Root Path Cost) </li></ul><br><br>  What is all this and why it is needed, I will explain a little lower.  Since the devices do not know and do not want to know their neighbors, they do not establish any relationship (adjacency / neighborhood) with each other.  They send BPDUs from all working ports to the multicast ethernet address <b>01-80-c2-00-00-00</b> (every 2 seconds by default), which all switches with STP on will listen. <br><br>  So, how does the topology form without loops? <br><br>  First, the so-called root bridge is selected.  This is the device that the STP considers the point of reference, the center of the network  the whole STP tree converges to it.  The choice is based on the concept of a Bridge ID.  Bridge ID is a number of 8 bytes in length, which consists of Bridge Priority (priority, from 0 to 65535, default 32768 + vlan number or MSTP instance, depending on the implementation of the protocol), and the MAC address of the device.  At the beginning of the election, each switch considers itself to be the root, and it declares everything else with the help of BPDU, in which it presents its ID as the root switch ID.  At the same time, if he gets a BPDU with a smaller Bridge ID, he stops bragging about his own and dutifully begins to announce the resulting Bridge ID as the root.  As a result, the root switch is the one whose Bridge ID is the least. <br><br><blockquote>  This approach is fraught with quite a serious problem.  The fact is that with equal values ‚Äã‚Äãof Priority (and they are equal, if you don‚Äôt change anything), the oldest switch is selected as root, since poppy addresses are assigned to production sequentially, respectively, the poppy is smaller, the device is older (of course, if we have all equipment of one vendor).  Understandably, this leads to a drop in network performance, since the old device, as a rule, has the worst characteristics.  This behavior of the protocol should be stopped by setting the priority value on the desired root switch manually, about it in the practical part. <br></blockquote><br><br><h4>  Port roles </h4><br>  After the switches have found their way out and have chosen the root bridge, each of the other switches should find one and only one port that will lead to the root switch.  This port is called the <b>root port</b> .  To understand which port is best to use, each non-root switch determines the cost of the route from each of its ports to the root switch.  This cost is determined by the sum of the cost of all links that need to go through the frame to get to the root switch.  In turn, the cost of a link is determined simply by its speed (the higher the speed, the lower the cost).  The process of determining the cost of the route is associated with the BPDU ‚ÄúRoot Path Cost‚Äù field and happens as follows: <br><br><ol><li>  A root switch sends a BPDU with a Root Path Cost of zero. </li><li>  The nearest switch looks at the speed of its port, where BPDU came, and adds the cost according to the table <br><table border="1"><tbody><tr><td>  Port speed </td><td>  STP Cost (802.1d) </td></tr><tr><td>  10 Mbps </td><td>  100 </td></tr><tr><td>  100 Mbps </td><td>  nineteen </td></tr><tr><td>  1 Gbps </td><td>  four </td></tr><tr><td>  10 Gbps </td><td>  2 </td></tr></tbody></table></li><li>  Further, this second switch sends this BPDU to downstream switches, but with a new Root Path Cost value, and further down the chain </li></ol><br><br>  If the same costs occur (as in our example with two switches and two wires between them, each path will have a cost of 19) - the smaller port is selected as the root. <br><br>  Next, select <b>Designated</b> ports.  From each particular network segment, there should be only one way towards the root switch, otherwise it is a loop.  In this case, we mean the physical segment, in modern networks without hubs, roughly speaking, this is just a wire.  The designated port is the one that has the best value in this segment.  At the root switch, all ports are designated. <br><br>  And now, after the root and designated ports are selected, the remaining ones are blocked, thus breaking the loop. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/12d/06b/a31/12d06ba319526c38f704a50ad5480a17.jpg"><br>  * In the picture, routers act as switches.  In real life this can be done with the help of an additional switchboard. <br><br><h4>  Port states </h4><br>  Earlier we mentioned the port blocking status, now let's talk about what this means, and about other possible port states in STP.  So, in the usual (802.1D) STP there are 5 different states: <br><br><ul><li>  blocking: a blocked port does not send anything.  This state is intended, as mentioned above, to prevent loops in the network.  A blocked port, however, listens to BPDUs (to be aware of events, this allows it to unblock and start working when necessary) </li><li>  listening (listening): the port listens and starts sending BPDU itself, does not send frames with data. </li><li>  learning: the port listens and sends BPDUs, and also makes changes to the CAM table, but does not forward the data. </li><li>  forwarding: this one can do everything: and sends / receives BPDUs, operates on data, and participates in maintaining the table of mac-addresses.  That is, this is the normal state of the working port. </li><li>  disabled (disabled): administratively down, disabled by <b>shutdown command</b> .  Understandably, can not do anything at all until manually included. </li></ul><br><br>  The order of enumeration of states is not accidental: when turned on (as well as when a new wire is plugged in), all ports on the device with STP pass through the above states in that order (except for disabled ports).  A natural question arises: why such difficulties?  And just STP cautious.  After all, at the other end of the wire, which has just been plugged into the port, there can be a switch, and this is a potential loop.  That's why the port first 15 seconds (by default) is in the listening state - it watches BPDUs that fall into it, finds out its position in the network - no matter how it happens, then it goes to training for 15 seconds - trying to figure out which mac- the addresses are ‚Äúin progress‚Äù on the link, and then, making sure that he does not break anything, he begins his work.  In total, we have as many as 30 seconds of idle time before the connected device can exchange information with its neighbors.  Modern computers are loaded in less than 30 seconds.  Now the computer has booted up, is already breaking into the network, hysteria on the subject ‚ÄúDHCP server, you bastard, will you issue an IP address, or not?‚Äù  Naturally, after such Exercises, no one will listen to him on the network, because ‚Äúnot local‚Äù with his 169.254.xx It is clear that all this is not the case, but how to avoid it? <br><br><h4>  Portfast </h4><br>  For such cases, a special port mode is used - portfast.  When a device is connected to such a port, it, bypassing the intermediate stages, immediately goes to the forwarding state.  Of course, portfast should be enabled only on interfaces leading to end devices (workstations, servers, telephones, etc.), but not to other switches. <br><br><blockquote>  There is a very convenient interface configuration mode command to enable the necessary features on the port that will include end devices: <b>switchport host</b> .  This command switches PortFast at once, switches the port to access mode (similar to switchport mode access), and disables the PAgP protocol (for details on this protocol, see the link aggregation section). <br></blockquote><br><br><h3>  Types of STP </h3><br>  STP is quite an old protocol, it was created to work in one LAN segment.  What to do if we want to implement it in our network, which has several VLANs? <br><br>  The 802.1Q standard we mentioned in the article about <a href="http://habrahabr.ru/post/138043/">switching</a> determines how the vlans are transmitted inside the trunk.  In addition, it defines one STP process for all vlans.  BPDUs on trunks are transmitted untagged (to the native VLAN).  This variant of STP is known as <b>CST</b> (Common Spanning Tree).  Having only one process for all vlans greatly simplifies the setup work and offloads the switch processor, but, on the other hand, CST has drawbacks: redundant links between switches are blocked in all vlans, which is not always acceptable and does not allow them to be used for load balancing. <br><br>  Cisco has its own look at STP, and its proprietary protocol implementation - <b>PVST</b> (Per-VLAN Spanning Tree) - which is designed to work on a network with several VLANs.  In PVST, for each vlan, there is its own STP process, which allows independent and flexible adjustment to the needs of each vlan, but most importantly, it allows the use of load balancing due to the fact that a specific physical link can be blocked in one vlan, but work in another.  The disadvantage of this implementation is, of course, proprietary: for the functioning of PVST, a proprietary ISL trunk between switches is required. <br><br>  There is also a second version of this implementation - <b>PVST +</b> , which allows you to establish a connection between switches with CST and PVST, and works with both ISL-trunk and 802.1q.  PVST + is the default protocol on Cisco switches. <br><br><h4>  Rstp </h4><br>  Everything we talked about earlier in this article belongs to the first implementation of the STP protocol, which was developed in 1985 by Radia Permman (her poem was used as an epigraph).  In 1990, this implementation was included in the IEEE 802.1D standard.  Then the time flowed more slowly, and the STP topology reorganization, which takes 30-50 seconds (!!!), suited everyone.  But times are changing, and ten years later, in 2001, IEEE introduces a new <b>RSTP</b> standard (aka 802.1w, aka Rapid Spanning Tree Protocol, aka Fast STP).  To structure the previous material and see the differences between normal STP (802.1d) and RSTP (802.1w), let's put together a table with the main facts: <br><br><table border="1"><tbody><tr><td>  <b>STP (802.1d)</b> </td><td>  <b>RSTP (802.1w)</b> </td></tr><tr><td>  In the already established topology, only the root switch sends BPDUs, the rest relays </td><td>  All switches send BPDUs according to the hello-timer (2 seconds by default) </td></tr><tr><td colspan="2">  <b>Port states</b> </td></tr><tr><td>  - blocking <br>  - listening (listening) <br>  - learning <br>  - forwarding / forwarding <br>  - disabled </td><td>  - discarding, replacing disabled, blocking and listening <br>  - learning <br>  - forwarding </td></tr><tr><td colspan="2">  <b>Port roles</b> </td></tr><tr><td>  - root (root), participates in data transfer, leads to the root switch <br>  - designated, also works, leads from root switch <br>  - unassigned (non-designated), does not participate in data transfer </td><td>  - root (root), participates in data transfer <br>  - designated, also works <br>  - additional (alternate), does not participate in data transfer <br>  - backup (backup), is also not involved </td></tr><tr><td colspan="2">  <b>Mechanisms of work</b> </td></tr><tr><td>  Uses timers: <br>  Hello (2 seconds) <br>  Max Age (20 seconds) <br>  Forward delay timer (15 seconds) </td><td>  Uses the proposal and agreement process </td></tr><tr><td>  The switch that detected the topology change notifies the root switch, which, in turn, requires all others to clear their current topology records during the forward delay timer </td><td>  Detecting changes in topology results in immediate cleanup of records. </td></tr><tr><td>  If a non-root switch does not receive hello packets from the root during Max Age, it starts a new election. </td><td>  It starts to act if it does not receive BPDU within 3 hello intervals </td></tr><tr><td>  Sequential port passing through Blocking states (20 seconds) - Listening (15 seconds) - Learning (15 seconds) - Forwarding </td><td>  Quick transition to Forwarding for p2p and Edge ports </td></tr></tbody></table><br><br>  As we can see, in RSTP, such port roles as the root and assigned ones remained, and the role of the blocked one was divided into two new roles: Alternate and Backup.  Alternate is the backup root port, and backup is the designated backup port.  It is in this concept of backup ports that one of the reasons for fast switching in case of failure lies.  This changes the behavior of the system as a whole: instead of reactive (which starts looking for a solution to the problem only after it has happened), the system becomes proactive, calculating the ‚Äúescape routes‚Äù before the problem occurs.  The point is simple: in order for the main to fail to switch to the backup link, RSTP does not need to re-calculate the topology, it will simply switch to the spare, previously calculated. <br><br>  Previously, in order to make sure that the port could participate in data transmission, timers were required, i.e.  the switch was passively waiting for the allotted time while listening to the BPDU.  The key feature of RSTP was the introduction of the concept of port types based on link mode ‚Äî full duplex or half duplex (port types p2p or shared, respectively), as well as the concept of border port (type edge p2p) for end devices.  The border ports are assigned, as before, by the spanning-tree portfast command, and with them everything is clear; when you turn on the wires, we immediately go to the forwarding state and work.  Shared ports operate according to the old scheme with passing through BLK - LIS - LRN - FWD states.  But on p2p-ports RSTP uses the process of proposal and agreement (proposal and agreement).  Without going into details, it can be described as follows: the switch rightly believes that if the link works in the full duplex mode, and it is not marked as borderline, it means that there are only two devices on it, he and the other switch.  Instead of waiting for incoming BPDUs, he tries to contact the switch on the other end of the wire with the help of a special proposal BPDU, which, of course, has information about the cost of the route to the root switch.  The second switch compares the received information with its current one, and makes a decision about what the first switch notifies by agreement BPDU.  Since this whole process is no longer tied to timers, it happens very quickly ‚Äî they just plugged in a new switch, and it almost immediately fit into the general topology and got to work (you can yourself evaluate the switching speed in comparison with regular STP on video).  In the Cisco world, RSTP is called PVRST (Per-Vlan Rapid Spanning Tree). <br><br><h4>  MSTP </h4><br>  Slightly above, we mentioned PVST, in which each Vlan has its own STP process.  Vlans are a fairly convenient tool for many purposes, and therefore, they can be quite a lot even in a medium-sized organization.  And in the case of PVST, each will have its own topology, processor time and switch memory.  Do we need to calculate STP for all 500 vlans, when the only place where we need it is a backup link between two switches?  Here MSTP helps us out.  In it, each vlan is not required to have its own STP process, they can be combined.  Here we have, for example, 500 vlans, and we want to balance the load so that half of them work on one link (the second one is blocked and kept in reserve), and the second one is different.  This can be done with the help of a regular STP, by assigning one root switch in the range of Vlans 1-250, and the other in the range of 250-500.  But the processes will work for each of the five hundred vlans separately (although they will act in exactly the same way for each half).  It is logical that there will be enough two processes.  MSTP allows you to create as many STP processes as we have logical topologies (in this example, 2), and distribute Vlans over them.  We think that there is not much point in delving into the theory and practice of MSTP within the framework of this article (for theories there-th), those interested can follow the <a href="http://blog.ine.com/2010/02/22/understanding-mstp/">link.</a> <br><br><h2>  Channel aggregation </h2><br>  But whatever STP option we use, we still somehow have a broken link.  Is it possible to use parallel links to the full and avoid loops?  Yes, we answer with ciscus, starting the story about EtherChannel. <br><br>  Otherwise it is called link aggregation, link bundling, NIC teaming, port trunkinkg <br>  Channel aggregation (aggregation) technologies perform 2 functions: on the one hand, it is the aggregation of the capacity of several physical links, and on the other, ensuring the fault tolerance of the connection (in the event of a link falling, the load is transferred to the remaining ones).  Linking can be performed either manually (static aggregation) or using special protocols: LACP (Link Aggregation Control Protocol) and PAgP (Port Aggregation Protocol).  LACP, defined by the IEEE 802.3ad standard, is an open standard, that is, it does not depend on the hardware vendor.  Accordingly, PAgP is a proprietary tsiskovskaya development. <br>  Up to eight ports can be combined into one such channel.  The load balancing algorithm is based on parameters such as the IP / MAC addresses of the recipients and senders and the ports.  Therefore, in case of a question: ‚ÄúHey, why is it so poorly balanced?‚Äù First of all look at the balancing algorithm. <br><br>  The topic of channel aggregation deserves a separate article, and even books, so we will not go deep for those interested in <a href="http://xgu.ru/wiki/link_aggregation">reference.</a> <br><br><h2>  Port security </h2><br>  Now we will tell briefly how to ensure network security at the second OSI level.  In this part of the article, the theory and practical configuration are combined.  Alas, Packet Tracer is not able to do anything of the commands mentioned in this section, therefore everything is without illustrations and checks. <br><br>  To begin with, mention should be made of the <b>switchport port-security</b> interface configuration command, which includes security on a specific switch port.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then, using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">switchport port-security maximum 1,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we can limit the number of mac-addresses associated with this port (that is, in our example, only one mac-address can work on this port). Now we specify which address is allowed: you can manually set the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">switchport port-security mac-address </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">address</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or use the magic </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">switchport port-security mac-address sticky</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">that secures the port address that is currently running on the port. Next, we set the behavior in case of violation of the </font><b><font style="vertical-align: inherit;">switchport</font></b><font style="vertical-align: inherit;"> rule </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">port-security violation {shutdown | restrict | protect}</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: the port is either disabled, and then it needs to be lifted manually (shutdown), or it discards packets from an unregistered poppy and writes about it to the console (restrict), or simply discards the packets (protect).</font></font><br><br>    ‚Äî      ‚Äî     , ,  :  .    ‚Äî  CAM-.       , , ,      MAC- .        .    , ,  -   ,     16000     .        .         :     ,   , ,  ,   MAC-    (  ),      .          ,    . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DHCP snooping </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another possible attack is aimed at a DHCP server. </font><font style="vertical-align: inherit;">As we know, DHCP provides client devices with all the necessary information to work on the network: ip-address, subnet mask, default address, DNS server, and so on. </font><font style="vertical-align: inherit;">The attacker can raise his own DHCP, which, in response to a request from the client device, will send as the default gateway (as well as, for example, the DNS server) the address of the attacker-controlled machine. </font><font style="vertical-align: inherit;">Accordingly, all traffic sent outside the subnet by deceived devices will be available for the attacker to study - a typical man-in-the-middle attack. </font><font style="vertical-align: inherit;">Either this option: a vile scammer generates a bunch of DHCP requests with fake MAC addresses and a DHCP server for each such request issues an IP address until the pool is exhausted.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order to protect against this type of attack, a feature called DHCP snooping is used. </font><font style="vertical-align: inherit;">The idea is quite simple: tell the switch on which port the real DHCP server is connected, and only allow DHCP responses from this port, prohibiting others. </font><font style="vertical-align: inherit;">We enable globally with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip dhcp snooping</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">, then we say in which vlans </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip dhcp snooping vlan number (a)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> should work </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Then, on a specific port, we say that it can forward DHCP responses (this port is called trusted): </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip dhcp snooping trust</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IP Source Guard </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After turning on DHCP Snooping, it starts to maintain a base of matching MACs and device IP addresses, which it updates and replenishes by listening to DHCP requests and responses. </font><font style="vertical-align: inherit;">This database allows us to resist another type of attack - IP address spoofing (IP Spoofing). </font><font style="vertical-align: inherit;">With IP Source Guard enabled, each incoming packet can be checked for:</font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> match the source IP address to the address obtained from the DHCP Snooping database (in other words, the IP address is assigned to the switch port) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> match the source MAC address to the address obtained from the DHCP snooping database </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP Source Guard is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enabled</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the </font><b><font style="vertical-align: inherit;">ip verify source</font></b><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">on the desired interface. </font><font style="vertical-align: inherit;">In this form, only the binding of the IP address is checked, in order to add a MAC check, use </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ip verify source port-security</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Of course, IP Source Guard requires DHCP snooping enabled, and port security must be enabled for controlling MAC addresses.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dynamic ARP Inspection </font></font></h3><br>    ,  ,   MAC-    IP-,   ARP:     ‚Äú  ip- 172.16.1.15,  172.16.1.1‚Äù,    172.16.1.15 .     ,  ARP-poisoning aka ARP-spoofing:      172.16.1.15   ,    ,   172.16.1.15   .          Dynamic ARP Inspection.      DHCP-Snooping':      ,    ARP-  :  ,    ,  ,    (    MAC-IP,     DHCP Snooping).   -       syslog.     (): <b>ip arp inspection vlan ()</b> .     ,     <b>ip arp inspection trust</b> . <br><br><h2>  Practice </h2><br><blockquote> ,    Packet Tracer    ,    STP,  .    ,  PT    <br></blockquote><br><br> ,   .        ‚Äî   .     ,             ‚Äî     msk-arbat-asw2    asw1,    .   (,    )  ,    msk-arbat-dsw1  msk-arbat-asw3,     asw2. Asw3     Fa0/2 dsw1.  : <br><br><blockquote> msk-arbat-dsw1(config)#interface gi1/2 <br> msk-arbat-dsw1(config-if)#description msk-arbat-asw2 <br> msk-arbat-dsw1(config-if)#switchport trunk allowed vlan 2,3 <br> msk-arbat-dsw1(config-if)#int fa0/2 <br> msk-arbat-dsw1(config-if)#description msk-arbat-asw3 <br> msk-arbat-dsw1(config-if)#switchport mode trunk <br> msk-arbat-dsw1(config-if)#switchport trunk allowed vlan 2,101-104 <br><br> msk-arbat-asw2(config)#int gi1/2 <br> msk-arbat-asw2(config-if)#description msk-arbat-dsw1 <br> msk-arbat-asw2(config-if)#switchport mode trunk <br> msk-arbat-asw2(config-if)#switchport trunk allowed vlan 2,3 <br> msk-arbat-asw2(config-if)#no shutdown <br><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to make all changes to the documentation! </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6cf/e25/20f/6cfe2520ffacd459babe1bad42beeb6c.png"><br><br> <a href="http://dl.dropbox.com/u/47476169/Habr/V4/Network_Planning_v4.xlsx"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download the current version of the document. </font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now let's see how </font><font style="vertical-align: inherit;">STP is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">self-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tuned </font><font style="vertical-align: inherit;">at the moment </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">We are only interested in VLAN0003, where we, judging by the scheme, loop.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msk-arbat-dsw1&gt; en </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msk-arbat-dsw1 # show spanning-tree vlan 3</font></font><br></blockquote><br><br>      <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f3/4f1/c0f/2f34f1c0fbf7a97e7b970aa692565606.png"><br><br> ,     ?         PVST+ (..      STP),       ,       ,     .    STP: ieee  PVST, rstp ‚Äî Rapid PVST, mstp   .        :    ,  mac-,       , ,       (  ),     STP. -         (   ). -   ,      ( ): <br><ul><li> ,  </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> its role (Root- root port, Desg- designated port, Altn- additional, Back- reserve) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> its status (FWD-running, BLK-blocked, LIS-listening, LRN-training) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> route cost to root switch </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Port ID format: port priority. Port number </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connection type </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So, we see that Gi1 / 1 is the root port, this gives some chance that there is a root switch on the other end of the link. </font><font style="vertical-align: inherit;">We look under the scheme where the link leads: aha, a certain msk-arbat-asw1.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> msk-arbat-asw1 # show spanning-tree vlan 3 </font></font><br></blockquote><br>  And what do we see? <br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLAN0003</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Spanning tree enabled protocol ieee</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Root ID Priority 32771</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            Address 0007.ECC4.09E2</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            This bridge is the root</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here it is, our root switch for VLAN0003. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now look at the scheme. Earlier, in the ports state, we saw that dsw1 was blocking Gi1 / 2 port, thus breaking the loop. But is this the best solution?</font></font> Of course not.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now our new network works exactly as the old traffic from asw2 goes only through asw1. Choosing a root router never needs to be left on the stupid STP conscience. Based on the scheme, the most optimal choice will be dsw1 as the root switch; thus, STP will block the link between asw1 and asw2. Now all this should be explained to the near protocol. And for him the main thing is what? Bridge ID. And it is no coincidence that it consists of two numbers. Priority is the very thing that is left to the network engineer, so that it can influence the result of the choice of the root switch. So, our task is to reduce (less-better, STP thinks) the priority of the necessary switch, so that it becomes Root Bridge. There are two ways: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1) to manually set a priority that is obviously lower than the current one:</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msk-arbat-dsw1&gt; enable </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msk-arbat-dsw1 # configure terminal </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msk-arbat-dsw1 (config) # spanning-tree vlan 3 priority? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;0-61440&gt; bridge in increments of 4096 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msk-arbat-dsw1 (config) # spanning-tree vlan 3 priority 4096</font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now it has become root for Vlan 3, since it has a smaller Bridge ID: </font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msk-arbat-dsw1 # show spanning-tree vlan 3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLAN0003 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spanning tree enabled protocol ieee </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Root ID Priority 4099 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Address 000B.BE2E.392C </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This bridge is for </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 sec Forward Delay 15 sec</font></font><br></blockquote><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2) give a smart piece of iron to solve everything for you: </font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> msk-arbat-dsw1 (config) # spanning-tree vlan 3 root primary </font></font><br></blockquote><br>  Checking: <br><br><blockquote> msk-arbat-dsw1#show spanning-tree vlan 3 <br> VLAN0003 <br> Spanning tree enabled protocol ieee <br> Root ID Priority 24579 <br> Address 000B.BE2E.392C <br> This bridge is the root <br> Hello Time 2 sec Max Age 20 sec Forward Delay 15 sec <br></blockquote><br><br>  ,    -  .     ,  ?   - STP    (.. ,    ),        (  4096, ..   8192).   ?          spanning-tree vlan n root secondary ( = -4096),     , ,      - ,     , ‚Äú‚Äù. ,     ,      asw2  asw1 ?  STP  .     ,    . Sweet!  :  ‚Äî  ,   ‚Äî  . <br><br><pre><code class="hljs pgsql">msk-arbat-asw2#<span class="hljs-keyword"><span class="hljs-keyword">show</span></span> spanning-tree vlan <span class="hljs-number"><span class="hljs-number">3</span></span> VLAN0003 Spanning tree enabled protocol ieee Root ID Priority <span class="hljs-number"><span class="hljs-number">24579</span></span> Address <span class="hljs-number"><span class="hljs-number">000</span></span>B.BE2E<span class="hljs-number"><span class="hljs-number">.392</span></span>C <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> Port <span class="hljs-number"><span class="hljs-number">26</span></span>(GigabitEthernet1/<span class="hljs-number"><span class="hljs-number">2</span></span>) Hello <span class="hljs-type"><span class="hljs-type">Time</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> sec Max Age <span class="hljs-number"><span class="hljs-number">20</span></span> sec Forward Delay <span class="hljs-number"><span class="hljs-number">15</span></span> sec Bridge ID Priority <span class="hljs-number"><span class="hljs-number">32771</span></span> (priority <span class="hljs-number"><span class="hljs-number">32768</span></span> sys-id-ext <span class="hljs-number"><span class="hljs-number">3</span></span>) Address <span class="hljs-number"><span class="hljs-number">000</span></span>A.F385.D799 Hello <span class="hljs-type"><span class="hljs-type">Time</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> sec Max Age <span class="hljs-number"><span class="hljs-number">20</span></span> sec Forward Delay <span class="hljs-number"><span class="hljs-number">15</span></span> sec Aging <span class="hljs-type"><span class="hljs-type">Time</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span> Interface <span class="hljs-keyword"><span class="hljs-keyword">Role</span></span> Sts <span class="hljs-keyword"><span class="hljs-keyword">Cost</span></span> Prio.Nbr <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> <span class="hljs-comment"><span class="hljs-comment">---------------- ---- --- --------- -------- -------------------------------- Fa0/1 Desg FWD 19 128.1 P2p Gi1/1 Altn BLK 4 128.25 P2p Gi1/2 Root FWD 4 128.26 P2p</span></span></code> </pre> <br>  Now we will see how STP works: we go to the command line on the PTO1 laptop and start to ping our mail server endlessly (172.16.0.4).  Ping is now following the route laptop-asw3-dsw1-gw1-dsw1 (well, it's clear why he does the hook - they are from different vlans) -asw2 server.  And now let's work Godzilla from SimSity: break the connection between dsw1 and asw2, by pulling the wire out of the port (we notice the time needed to recalculate the tree). <br><br>  Ping disappears, STP takes over, and for <i>some</i> 30 seconds the connection is restored.  Godzilla was driven away, the fires were extinguished, the connection was repaired, we stuck the wire back.  Pings disappear again for 30 seconds!  Hmm, well, somehow not very fast, especially if you imagine that this happens, for example, in the processing center of a bank. <br><br>  But we have the answer to slow PVST +!  And this answer is - Fast PVST + (this is called, this is not a joke: Rapid-PVST).  Let's see what he gives us.  We change the type of STP on all switches in Moscow with a configuration mode command: spanning-tree mode rapid-pvst <br><br>  Start the ping again, call Godzilla ... Hey, where are the missing pings?  They are not, this is Rapid-PVST.  As you probably remember from the theoretical part, this STP implementation, so to say, ‚Äúunderlay the straw‚Äù in case the main link falls, and switches to an additional (alternate) port very quickly, which we observed.  Okay, stick the wire back.  One lost ping.  Not bad compared to 6-8, right? <br><br><h4>  EtherChannel </h4><br><br>  Remember, we took away their gigabit link from office workers and gave it to servers?  Now they, poor things, are sitting on some hundred megabits, the last century!  Let's try to expand the channel, and call for help EtherChannel.  At the moment we have a connection from fa0 / 2 dsw1 to Gi1 / 1 asw3, disconnect the wire.  We look, what ports we can use on asw3: aha, fa0 / 20-24 are free, it seems.  Here we take them.  On the dsw1 side, let fa0 / 19-23 be.  We connect ports for EtherChannel among themselves.  On asw3, we have configured something on the interfaces, usually in such cases, the configuration interface command default interface range fa0 / 20-24 is used, which resets the port settings (or ports, as in our case) to default.  Packet tracer, alas, does not know such a good team, so in manual mode we remove each setting and extinguish the ports (better to do this, to avoid problems) <br><blockquote>  msk-arbat-asw3 (config) #interface range fa0 / 20-24 <br>  msk-arbat-asw3 (config-if-range) #no description <br>  msk-arbat-asw3 (config-if-range) #no switchport access vlan <br>  msk-arbat-asw3 (config-if-range) #no switchport mode <br>  msk-arbat-asw3 (config-if-range) #shutdown <br></blockquote><br>  well now the magic team <br><blockquote>  msk-arbat-asw3 (config-if-range) # channel-group 1 mode on <br></blockquote><br>  same on dsw1: <br><blockquote>  msk-arbat-dsw1 (config) #interface range fa0 / 19-23 <br>  msk-arbat-dsw1 (config-if-range) # channel-group 1 mode on <br></blockquote><br>  we lifted asw3 interfaces, and voila: here it, our EtherChannel, was stretched already on 5 physical links.  In the config, it will be reflected as interface Port-channel 1. Configure the trunk (repeat for dsw1): <br><blockquote>  msk-arbat-asw3 (config) #int port-channel 1 <br>  msk-arbat-asw3 (config-if) #switchport mode trunk <br>  msk-arbat-asw3 (config-if) #switchport trunk allowed vlan 2,101-104 <br></blockquote><br>  As with STP, there is some difficulty when working with etherchannel in the Packet Tracer.  In principle, we can configure the scenario described above, but the performance test is a big question: after one of the ports in the group is disconnected, the traffic flows to the next, but as soon as you cut down the second port, the connection is lost and cannot be restored even after switching on ports. <br><br>  Partly due to the reasons just stated, partly due to limited resources, we will not be able to fully address these issues and therefore leave most of it to self-study. <br><br><h3>  Release materials </h3><br>  <a href="http://dl.dropbox.com/u/47476169/Habr/V4/Network_Planning_v4.xlsx">New commutation plan</a> <br>  <a href="">PT file with lab</a> . <br>  <a href="http://dl.dropbox.com/u/47476169/Habr/V4/Configuration.doc">Device configuration</a> <br>  <a href="http://en.wikipedia.org/wiki/Spanning_Tree_Protocol">STP</a> or <a href="http://xgu.ru/wiki/STP">STP</a> <br>  <a href="http://xgu.ru/wiki/l2security">Link Layer Security</a> <br>  <a href="http://xgu.ru/wiki/link_aggregation">Channel aggregation</a> <br><br>  According to the established tradition, all the unanswered questions by unnamed readers of Habr are set in the blog of the cycle in <a href="http://eucariot.livejournal.com/66249.html">LiveJournal</a> . <br><br>  Thanks for the video and help in preparing the article thanks <a href="http://habrahabr.ru/users/eucariot/" class="user_link">eucariot</a> </div><p>Source: <a href="https://habr.com/ru/post/143768/">https://habr.com/ru/post/143768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../143763/index.html">Interactive Universe Scale</a></li>
<li><a href="../143764/index.html">Ponobalize: Meat grinder</a></li>
<li><a href="../143765/index.html">Customize your google</a></li>
<li><a href="../143766/index.html">Creating a 1k / 4k intro for Linux, part 2</a></li>
<li><a href="../143767/index.html">The whole truth about Chrome (and not only) Web Inspector. Part 1</a></li>
<li><a href="../143769/index.html">Droider Show # 40. Ay yes box! Apple iTV</a></li>
<li><a href="../143770/index.html">This is what Android development looks like.</a></li>
<li><a href="../143771/index.html">HTC One S - powerful thin-case stuffing</a></li>
<li><a href="../143772/index.html">About geeks, the industry of mass art and how copyright killed classical music</a></li>
<li><a href="../143773/index.html">Crowd funding in Russia: get out of the valley of death</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>