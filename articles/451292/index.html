<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RxDart: magical stream transformations</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welcome to this third part of my Flutter architecture series. 


- Introduction 
- Dart Streams Basics 
- RxDart: magical stream transformations (this...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RxDart: magical stream transformations</h1><div class="post__text post__text-html js-mediator-article"><p>  Welcome to this third part of my Flutter architecture series. </p><br><ul><li>  <a href="https://habr.com/ru/post/448776/">Introduction</a> </li><li>  <a href="https://habr.com/ru/post/450950/">Dart Streams Basics</a> </li><li>  <strong>RxDart: magical stream transformations (this post)</strong> </li><li>  <a href="https://habr.com/ru/post/449872/">RxVMS Basics: RxCommand and GetIt</a> </li><li>  RxVMS: Services and Managers </li><li>  RxVMS: self-contained widgets </li><li>  User Authentication with RxVMS </li></ul><br><p>  This time we will make a slight immersion in the magical realm of reactive expansions (Rx).  I will focus on the most used Rx functions and explain their application.  If you have not read the previous post, now is the time for this, before moving on. </p><br><p>  <a href="https://github.com/ReactiveX/rxdart">RxDart</a> is an implementation of the Rx concept for the Dart language, for which we should say thanks to <a href="https://github.com/frankpepermans">Frank Pepermans</a> and <a href="https://github.com/brianegan">Brian Egan</a> .  If you previously used Rx in other languages, you will surely notice a difference in the naming of a number of functions, but this is unlikely to cause you any difficulty. </p><br><p>  The code for testing is <a href="https://github.com/escamoteur/stream_rx_tutorial/tree/rx_magic">here</a> . </p><br><p>  So far, we have used streams as a way to transfer data from one place to another in our application, but they can do much more.  Let's take a look at some of the features that Rx adds to Streams. </p><a name="habracut"></a><br><h2 id="sozdanie-observables">  Creating Observables </h2><br><p>  As <a href="https://habr.com/ru/post/450950/">mentioned earlier</a> , Observables are Rx varieties of high-capacity streams.  There are several interesting ways to create them: </p><br><h3 id="iz-potoka">  Out of stream </h3><br><p>  Any Stream can be converted to Observable by passing it to the constructor: </p><br><pre><code class="cpp hljs">var controller = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StreamController&lt;String&gt;(); var streamObservable = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable(controller.stream); streamObservable.listen(print);</code> </pre> <br><h3 id="povtoryayuschiesya-sobytiya">  Recurring events </h3><br><pre> <code class="cpp hljs">var timerObservable = Observable.periodic(Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), (x) =&gt; x.toString() ); timerObservable.listen(print);</code> </pre> <br><p>  This way will be constructed Observable, displaying values ‚Äã‚Äãwith a certain period.  So you can replace the timer. </p><br><h3 id="iz-odinochnogo-znacheniya">  From single value </h3><br><p>  Sometimes the API expects Stream / Observable where you just have a value.  For such cases, Observable has a factory. </p><br><pre> <code class="cpp hljs">var justObservable = Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;.just(<span class="hljs-number"><span class="hljs-number">42</span></span>); justObservable.listen(print); <span class="hljs-comment"><span class="hljs-comment">//   : 42</span></span></code> </pre> <br><h3 id="iz-future">  From the future </h3><br><pre> <code class="cpp hljs"> Future&lt;String&gt; asyncFunction() async { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Future.delayed(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Duration(seconds: <span class="hljs-number"><span class="hljs-number">1</span></span>), () =&gt; <span class="hljs-string"><span class="hljs-string">"AsyncRsult"</span></span>); } test(<span class="hljs-string"><span class="hljs-string">'Create Observable from Future'</span></span>, () async { print(<span class="hljs-string"><span class="hljs-string">'start'</span></span>); var fromFutureObservable = Observable.fromFuture(asyncFunction()); fromFutureObservable.listen(print);</code> </pre> <br><p>  Creating an <code>Observable</code> from a <a href="https://api.dartlang.org/stable/2.3.0/dart-async/Future-class.html">Future</a> will wait for the completion of the Future and return the value of its result, or <code>null</code> if no value is returned.  Another way to create a stream from Future is <code>toStream()</code> for any Future. </p><br><p>  You may be wondering what is the point of converting a Future into an Observable / Stream instead of just waiting for it.  Rest assured, this will become clear when we examine the available functions for manipulating data while they are "in the flow". </p><br><h3 id="subjects">  Subjects </h3><br><p>  <code>Subjects</code> are a replacement for <code>StreamController</code> in RxDart, and this is how they are implemented somewhere in the bowels of the library. </p><br><p>  But their behavior is slightly different from basic StreamControllers: </p><br><ul><li>  you can use <code>listen()</code> directly on the Subject, without referring to the Stream property </li><li>  any number of subscriptions available, and all listeners get the same data at the same time </li><li>  There are three types of Subjects, which are explained below with examples: </li></ul><br><h4 id="publishsubjects">  PublishSubjects </h4><br><p>  <code>PublishSubjects</code> behave like <code>StreamControllers</code> , except for the possibility of many listeners: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    subject.listen((item) =&gt; print(item.toUpperCase())); subject.add("Item2"); subject.add("Item3"); //        await Future.delayed(Duration(seconds: 5)); //    subject.close;</span></span></code> </pre> <br><p>  Run this code and you will get: </p><br><pre> <code class="cpp hljs">Item1 ITEM2 Item2 ITEM3 Item3</code> </pre> <br><p>  It is clear that the second listener, who was late for the party (we will call them late subscribers), missed the first item.  To avoid this, you can use the <code>BehaviourSubject</code> </p><br><h4 id="behavioursubject">  BehaviourSubject </h4><br><p>  With the <code>BehaviourSubject</code> each new subscriber will first receive the last accepted value: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject&lt;String&gt;(); subject.listen((item) =&gt; print(item)); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.listen((item) =&gt; print(item.toUpperCase())); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p>  At the exit </p><br><pre> <code class="cpp hljs">Item1 ITEM2 ITEM3 Item2 Item3</code> </pre> <br><p>  You can see that <code>Item1</code> lost for the second subscriber, but it gets <code>Item2</code> .  You may be surprised that the second subscriber receives <code>Item3</code> before the first subscriber receives <code>Item2</code> .  This is because the sequence of servicing subscribers is not guaranteed, although all subscribers receive data in the correct order.  <code>BehaviourSubject</code> caches only the last item received for late subscribers.  If you need to cache more items, you can use <a href="https://pub.dev/documentation/rxdart/latest/rx/ReplaySubject-class.html">ReplaySubject</a> .  In most cases, this is not necessary. </p><br><h2 id="manipulirovanie-dannymi-na-letu">  Manipulate data on the fly </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ea5/dfe/1c6/ea5dfe1c65f93367e3207e2a0fe68908.gif"></p><br><p>  The true power of Rx is that it allows data to be processed during transmission over the stream.  Each of the Rx methods returns a new stream with the resulting data (as in the illustration), which means you can link them together in one processing pipeline, and this makes Rx an extremely powerful tool. </p><br><h3 id="map">  Map </h3><br><p>  If there is any operation Stream, which I most of all do not want to miss, then this is <code>map()</code> .  What <code>map()</code> does is that it takes each element of data to be transferred and applies a function to it, and then puts the result in the result stream.  A simple example: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8e0/05a/ecc/8e005aecc11e119b7c856a4cadec9b11.gif"></p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()).listen(print); subject.add(<span class="hljs-string"><span class="hljs-string">"Item1"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item2"</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">"Item3"</span></span>);</code> </pre> <br><p>  Result: </p><br><pre> <code class="cpp hljs">ITEM1 ITEM2 ITEM3</code> </pre> <br><p>  But <code>map</code> not obliged to return the same data type that it receives as input.  The following example will accept integers instead of strings.  Additionally, we will associate two transformations: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((intValue) =&gt; intValue.toString()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((item) =&gt; item.toUpperCase()) .listen(print); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre> <br><p>  or something like this: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0bb/73f/2a2/0bb73f2a2ccb82e6a920efbf2c395b0d.gif"></p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DataClass</span></span></span><span class="hljs-class">{</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WrapperClass</span></span></span><span class="hljs-class"> {</span></span> final DataClass wrapped; WrapperClass(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.wrapped); } var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;WrapperClass&gt;(); subject.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WrapperClass&gt;((a) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WrapperClass(a));</code> </pre> <br><p>  One of the most useful uses of <code>.map</code> is when you get data in a format from some REST API or from a database and want it to be converted into your own objects: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> {</span></span> final String name; final String adress; final String phoneNumber; final <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; <span class="hljs-comment"><span class="hljs-comment">//       - //   factory User.fromJson(String jsonString) { var jsonMap = json.decode(jsonString); return User( jsonMap['name'], jsonMap['adress'], jsonMap['phoneNumber'], jsonMap['age'], ); } User(this.name, this.adress, this.phoneNumber, this.age); @override String toString() { return '$name - $adress - $phoneNumber - $age'; } } void main() { test('Map', () { // -  var jsonStrings = [ '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }', '{"name": "Stephen King", "adress": "Castle Rock", "phoneNumber":"123456","age": 71 }', '{"name": "Jon F. Kennedy", "adress": "Washington", "phoneNumber":"111111","age": 66 }', ]; //   json-,    API/DB. var dataStreamFromAPI = new PublishSubject&lt;String&gt;(); dataStreamFromAPI .map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)) // json -&gt; User .listen((user) =&gt; print(user.toString())); //    dataStreamFromAPI.add(jsonStrings[0]); dataStreamFromAPI.add(jsonStrings[1]); dataStreamFromAPI.add(jsonStrings[2]); });</span></span></code> </pre> <br><p>  <em>I note, not only Streams, but also any Iterable offers a <code>map</code> function, which you can use for conversions in lists.</em> </p><br><h3 id="where">  Where </h3><br><p>  If you are only interested in certain values ‚Äã‚Äãfound in the stream, you can use the <code>.where()</code> function instead of using the <code>if</code> in your listener, this is more expressive and easier to read: </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); subject.where((val) =&gt; val.isOdd) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints odd numbers: $val'</span></span>)); subject.where((val) =&gt; val.isEven) .listen( (val) =&gt; print(<span class="hljs-string"><span class="hljs-string">'This only prints even numbers: $val'</span></span>)); subject.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); subject.add(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">//: This only prints odd numbers: 1 This only prints even numbers: 2 This only prints odd numbers: 3</span></span></code> </pre> <br><h3 id="debounce">  Debounce </h3><br><p>  This is one of the little Rx pearls!  Imagine that you have a search field that makes a call to the REST API if its text is modified.  Making an API call for each keystroke is expensive.  Thus, you would like to make a call only if the user pauses for a moment.  This is exactly what the <code>debounce()</code> function is used for, which swallows all incoming events if there is no pause after them. </p><br><pre> <code class="cpp hljs">var subject = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PublishSubject&lt;String&gt;(); subject.debounce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">500</span></span>)).listen((s) =&gt; print(s)); subject.add(<span class="hljs-string"><span class="hljs-string">'A'</span></span>); subject.add(<span class="hljs-string"><span class="hljs-string">'AB'</span></span>); await Future.delayed(Duration(milliseconds: <span class="hljs-number"><span class="hljs-number">200</span></span>)); subject.add(<span class="hljs-string"><span class="hljs-string">"ABC"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    await Future.delayed(Duration(milliseconds: 700)); //       : 'ABC'</span></span></code> </pre> <br><p>  Therefore, if you convert the <code>TextField.onChanged</code> handler to <code>Observable</code> , you will get an elegant solution. </p><br><h3 id="expand">  Expand </h3><br><p>  If your source Stream emits an array of objects, and you want to process each object yourself, you can use an <code>.expand</code> that does exactly that: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e8e/8d7/2b3/e8e8d72b36dddd0d3469107c6cdae2b1.gif" alt="image"></p><br><p>  You will see the application of this method below in the FireStore example. </p><br><h3 id="merge">  Merge </h3><br><p>  If you have several different threads, but you want to process their objects together, you can use <code>.mergeWith</code> (in other implementations of Rx, just <code>merge</code> ), which takes an array of threads and returns one combined stream. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a2f/9ba/82b/a2f9ba82b88b555841c21dc623c3d298.gif" alt="image"></p><br><p>  <code>.mergeWith</code> does not guarantee compliance with any order in the streams when they are combined.  Data is emitted in the order of entry. </p><br><p>  For example, if you have two components that report errors through a stream, and you want them to appear together in a dialog, you can do this as follows (pseudocode): </p><br><pre> <code class="cpp hljs">@<span class="hljs-function"><span class="hljs-function">override </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ super.initState(); component1.errors.mergeWith([component2.errors]) .listen( (error) async =&gt; await showDialog(error.message)); }</code> </pre> <br><p>  or if you want a combined display of messages from several social networks, it might look like this (pseudo-code): </p><br><pre> <code class="cpp hljs">final observableTwitter = getTwitterStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromTwitter(data)); final observableFacebook = getFacebookStream().<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>((data) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAppPost.fromFaceBook(data)); final postStream = observableTwitter.mergeWith([observableFacebook]);</code> </pre> <br><h3 id="zipwith">  Zipwith </h3><br><p>  <code>zipWith</code> also combines one stream with another.  But, unlike <code>.mergeWith</code> , it does not send data as soon as it receives an element from one of its source streams.  He waits until items from both source streams arrive, and then combines them using the provided <code>zipper</code> function: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5ef/611/847/5ef611847db6bfa40237fb3622d93822.gif" alt="image"></p><br><p>  The <code>zipWith</code> signature looks scary, but for now we‚Äôll look at it: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// R :   Stream/Observable // S :   Stream/Observable // zipper: - Observable&lt;R&gt; zipWith&lt;S, R&gt;(Stream&lt;S&gt; other, R zipper(T t, S s))</span></span></code> </pre> <br><p>  A very simplified example: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// .just()  Observable,    .zipWith(new Observable.just(2), (one, two) =&gt; one + two) .listen(print); //  3</span></span></code> </pre> <br><p>  More practical application - if you need to wait for two asynchronous functions that return <code>Future</code> , and you want to process the data as soon as both results are returned.  In this slightly contrived example, we present two REST APIs: one returns the <code>User</code> , the other the <code>Product</code> as JSON strings, and we want to wait for both calls before returning the <code>Invoice</code> object. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Invoice</span></span></span><span class="hljs-class"> {</span></span> final User user; final Product product; Invoice(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.user, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.product); printInvoice() { print(user.toString()); print(product.toString()); } } <span class="hljs-comment"><span class="hljs-comment">//  HTTP ,  Product,  JSON Future&lt;String&gt; getProduct() async { print("Started getting product"); await Future.delayed(Duration(seconds: 2)); print("Finished getting product"); return '{"name": "Flux compensator", "price": 99999.99}'; } //  HTTP ,  User,  JSON Future&lt;String&gt; getUser() async { print("Started getting User"); await Future.delayed(Duration(seconds: 4)); print("Finished getting User"); return '{"name": "Jon Doe", "adress": "New York", "phoneNumber":"424242","age": 42 }'; } void main() { test('zipWith', () async { var userObservable = Observable.fromFuture(getUser()).map&lt;User&gt;((jsonString) =&gt; User.fromJson(jsonString)); var productObservable = Observable.fromFuture(getProduct()) .map&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)); Observable&lt;Invoice&gt; invoiceObservable = userObservable.zipWith&lt;Product, Invoice&gt;( productObservable, (user, product) =&gt; Invoice(user, product)); print("Start listening for invoices"); invoiceObservable.listen((invoice) =&gt; invoice.printInvoice()); //        await Future.delayed(Duration(seconds: 5)); }); }</span></span></code> </pre> <br><p>  Looking at the output, you can see how it is done asynchronously. </p><br><pre> <code class="cpp hljs">Started getting User Started getting product Start listening <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> invoices Finished getting product Finished getting User Jon Doe - New York - <span class="hljs-number"><span class="hljs-number">424242</span></span> - <span class="hljs-number"><span class="hljs-number">42</span></span> Flux compensator - <span class="hljs-number"><span class="hljs-number">99999.99</span></span></code> </pre> <br><h3 id="combinelatest">  CombineLatest </h3><br><p>  <code>combineLatest</code> also combines the values ‚Äã‚Äãof streams, but a little differently than <code>merge</code> and <code>zip</code> .  It listens to more streams and gives the combined value whenever a new value comes from one of the streams.  Interestingly, it generates not only the modified value, but also the last obtained values ‚Äã‚Äãof all other source streams.  Look closely at this animation: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/633/acb/bee/633acbbee01158bb7a6ad0450d39f712.gif" alt="image"></p><br><p>  Before <code>combineLates</code> its first value, all source streams must receive at least one element as input. </p><br><p>  Unlike the methods used previously, <code>combineLatest</code> is static.  In addition, since Dart does not allow operator overload, there are versions of <code>combLastest</code> depending on the number of source threads: <strong>combineLatest2 ... combineLatest9</strong> </p><br><p>  Good use <code>combineLatest</code> , for example, if you have two <code>Observable&lt;bool&gt;</code> , which signal that some parts of your application are busy, and you want to display the "Busy" spinner if one of them is busy.  It might look like this (pseudocode): </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; get isBusy =&gt; Observable.combineLatest2(isBusyOne,isBusyTwo, (b1, b2) =&gt; b1 || b2); PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyOne; PublishSubject&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusyTwo; }</code> </pre> <br><p>  In your UI, you can use <code>isBusy</code> with <code>StreamBuilder</code> to display <code>Spinner</code> if the value obtained is true. </p><br><p>  <code>combineLatest</code> very suitable feature in combination with <strong>FireStore snapshots</strong> streams. </p><br><p>  Imagine that you want to create an application that displays a news feed along with a weather forecast.  Ticker messages and weather data are stored in two different FireStore collections.  Both are updated independently.  You want to display data updates with StreamBuilder.  With <code>combineLatest</code> is easy: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WeatherForecast</span></span></span><span class="hljs-class"> {</span></span> final String forecastText; final GeoPoint location; factory WeatherForecast.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WeatherForecast(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'forecastText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } WeatherForecast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecastText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsMessage</span></span></span><span class="hljs-class"> {</span></span> final String newsText; final GeoPoint location; factory NewsMessage.fromMap(Map&lt;String, dynamic&gt; <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage(<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'newsText'</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">map</span></span>[<span class="hljs-string"><span class="hljs-string">'location'</span></span>]); } NewsMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsText, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.location); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CombinedMessage</span></span></span><span class="hljs-class"> {</span></span> final WeatherForecast forecast; final NewsMessage newsMessage; CombinedMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.forecast, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.newsMessage); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> {</span></span> CollectionReference weatherCollection; CollectionReference newsCollection; Model() { weatherCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'weather'</span></span>); newsCollection = Firestore.instance.collection(<span class="hljs-string"><span class="hljs-string">'news'</span></span>); } Observable&lt;CombinedMessage&gt; getCombinedMessages() { Observable&lt;WeatherForecast&gt; weatherForecasts = weatherCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;WeatherForecast&gt;((document) =&gt; WeatherForecast.fromMap(document.data)); Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Observable.combineLatest2( weatherForecasts, news, (weather, news) =&gt; CombinedMessage(weather, news)); } }</code> </pre> <br><p>  In your UI, it would look something like this: <code>StreamBuilder&lt;CombinedMessage&gt;(stream: model.getCombinedMessages(),...).</code> </p><br><h3 id="distinct">  Distinct </h3><br><p>  In the scenario described above, it may happen that <strong>isBusyOne</strong> and <strong>isBusyTwo return</strong> the same value, which will update the user interface with the same data.  To prevent this, we can use <code>.distinct()</code> .  It ensures that the data is transmitted by stream only if the value of the new element differs from the last one.  So we would change the code to: </p><br><pre> <code class="cpp hljs"> Observable&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; isBusy =&gt; isBusyOne.mergeWith([isBusyTwo]).distinct();</code> </pre> <br><p>  and it also demonstrates that we can combine our functions into different chains at will. </p><br><h3 id="asyncmap">  Asyncmap </h3><br><p>  In addition to <code>map()</code> there is also a function <code>asyncMap</code> , which allows you to use an asynchronous function as a map function.  Let's imagine a slightly different setting for our FireStore example.  Now the required <strong>WeatherForecast</strong> depends on the location of <strong>NewsMessage</strong> and should be updated only when a new <strong>NewsMessage is received</strong> : </p><br><pre> <code class="cpp hljs">Observable&lt;CombinedMessage&gt; getDependendMessages() { Observable&lt;NewsMessage&gt; news = newsCollection.snapshots().expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }).<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> news.asyncMap((newsEntry) async { var weatherDocuments = await weatherCollection.where(<span class="hljs-string"><span class="hljs-string">'location'</span></span>, isEqualTo: newsEntry.location).getDocuments(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CombinedMessage( WeatherForecast.fromMap(weatherDocuments.documents.first.data), newsEntry); }); }</code> </pre> <br><p>  The observable returned by getDependendMessages will generate a new CombinedMessage each time the newsCollection changes. </p><br><h2 id="otladka-observables">  Debugging Observables </h2><br><p>  Looking at the elegant Rx call chains, it seems almost impossible to debug an expression like this: </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) =&gt; snapShot.documents) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) =&gt; NewsMessage.fromMap(document.data));</code> </pre> <br><p>  But keep in mind that <code>=&gt;</code> is only a short form for an anonymous function.  Using <strong>Convert to block body</strong> , you will get: </p><br><pre> <code class="cpp hljs">Observable&lt;NewsMessage&gt; news = newsCollection .snapshots() .expand((snapShot) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> snapShot.documents; }) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;NewsMessage&gt;((document) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NewsMessage.fromMap(document.data); });</code> </pre> <br><p>  And now we can set a breakpoint or add print statements at every stage of our ‚Äúpipeline‚Äù. </p><br><h2 id="osteregaytes-pobochnyh-effektov">  Avoid side effects </h2><br><p>  <strong>If you want to take advantage of Rx to make your code more reliable, always keep in mind that Rx is the conversion of data as it moves "along a conveyor belt."</strong>  <strong>Therefore, never call functions that change any variables / states outside the processing pipeline until you reach the .listen function.</strong> <br>  Instead of doing this: </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) { var product = Product.fromJson(jsonString); database.save(product); setState((){ _product = product }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> product; }).listen();</code> </pre> <br><p>  do this: </p><br><pre> <code class="cpp hljs">Observable.fromFuture(getProduct()) .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;Product&gt;((jsonString) =&gt; Product.fromJson(jsonString)) .listen( (product) { database.save(product); setState((){ _product = product }); });</code> </pre> <br><p>  Charge <code>map()</code> - data conversion in the stream, and nothing else!  If the transferred display function does something else, it will be viewed as a side effect, producing potential errors that are difficult to detect when reading the code. </p><br><h2 id="nekotorye-mysli-ob-osvobozhdenii-resursov">  Some thoughts on the release of resources </h2><br><p>  To avoid memory leaks, always call <code>cancel()</code> for subscriptions, <code>dispose()</code> for StreamControllers, <code>close()</code> for Subjects as soon as you no longer need them. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  Congratulations if you stayed with me until this moment.  Now, not only can you use Rx to make your life easier, but also prepare for the next posts, in which we delve into the details of <strong>RxVMS</strong> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/451292/">https://habr.com/ru/post/451292/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../451270/index.html">B = Attention, or how to create time</a></li>
<li><a href="../451272/index.html">If already knocking on the door: how to protect information on devices</a></li>
<li><a href="../451274/index.html">Perfect Weapon, Perspective War and Human Being Reaching the Ceiling</a></li>
<li><a href="../451278/index.html">Wavelet analysis. Part 1</a></li>
<li><a href="../451280/index.html">The most interesting metals</a></li>
<li><a href="../451296/index.html">Announced ML.NET 1.0</a></li>
<li><a href="../451298/index.html">How to make a game console with the case, ordering a single PCB</a></li>
<li><a href="../4513/index.html">The founder of "MegaFon" asks for protection from the Russian minister</a></li>
<li><a href="../451300/index.html">How to solve the traveling salesman problem?</a></li>
<li><a href="../451304/index.html">The ‚Äútip‚Äù from Yandex: how to maximize profits on a paid subscription</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>