<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is useful monomorphism?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Speeches and blog posts about JavaScript performance often draw attention to the importance of monomorphic code, but usually there is no clear explana...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is useful monomorphism?</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/a52/d52/8f8/a52d528f8ce74ed690733b9aef7b78c4.png"></div><br><br>  Speeches and blog posts about JavaScript performance often draw attention to the importance of <i>monomorphic</i> code, but usually there is no clear explanation of what monomorphism / polymorphism is and why it matters.  Even my own performances are often reduced to the dichotomy in the style of the Incredible Hulk: <b>‚ÄúONE TYPE IS GOOD!</b>  <b>TWO TYPE IS BAD! ‚Äù</b> .  It is not surprising that when people turn to me for advice on performance, they often ask to explain what monomorphism really is, where polymorphism comes from and what is wrong with it. <br><br>  The situation is further complicated by the fact that the word ‚Äúpolymorphism‚Äù itself has many meanings.  In classical object-oriented programming, polymorphism is associated with the creation of child classes, in which you can override the behavior of the base class.  Programmers working with Haskell will instead think about parametric polymorphism.  However, the polymorphism warned about in JavaScript performance reports is the polymorphism <i>of function calls</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I explained this mechanism in so many different ways that I finally got together and wrote this article: now you can not improvise, but simply link to it. <br><br>  <sub>I also tried a new way to explain things - portraying the interaction of the constituent parts of a virtual machine in the form of short comics.</sub>  <sub>In addition, this article does not cover some of the details, which I considered insignificant, redundant or not directly related.</sub> <a name="habracut"></a><br><br><h2>  Dynamic search for dummies </h2><br><img src="https://habrastorage.org/files/4b2/f99/1c0/4b2f991c07bc4e11875314f9629aa170.png" align="left"><br>  For the sake of simplicity, we will mainly consider the most elementary references to properties in JavaScript, such as <code>ox</code> in the code below.  At the same time, it is important to understand that everything we are talking about refers to any operation with <i>dynamic linking</i> , be it a property call or an arithmetic operator, and is applicable not only in JavaScript. <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ox</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ x: 1 })</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ x: 2 })</span></span></span></span></code> </pre><br>  Imagine for a moment that you will be interviewed for an excellent position in Interpreters LLC, and you are asked to come up with and implement a mechanism for accessing the property in a JavaScript virtual machine.  What answer would be the most banal and simple? <br><br>  It's hard to come up with something simpler than to take the ready-made JS semantics from the ECMAScript specification (ECMA 262) and rewrite the algorithm <a href="http://es5.github.io/">[[Get]]</a> word for word from English to C ++, Java, Rust, Malbolge or any other language that you prefer for an interview. <br><br>  Generally speaking, if you open a random JS interpreter, you can most likely see something like: <br><br><br><pre> <code class="hljs ruby">jsvalue Get(jsvalue <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, jsvalue property_name) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">8.12</span></span>.<span class="hljs-number"><span class="hljs-number">3</span></span>    [[Get]] } void Interpret(jsbytecodes bc) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/*    */</span></span>) { switch (op) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-symbol"><span class="hljs-symbol">OP_GETPROP:</span></span> { jsvalue property_name = pop(); jsvalue receiver = pop(); push(Get(receiver, property_name)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> TODO(mraleph):    strict mode,    <span class="hljs-number"><span class="hljs-number">8.7</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>  <span class="hljs-number"><span class="hljs-number">3</span></span>. <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } /<span class="hljs-regexp"><span class="hljs-regexp">/ ... } } }</span></span></code> </pre><br>  This is an absolutely correct way to implement property reference, but it has one significant drawback: compared to modern JS virtual machines, our implementation is very slow. <br><br>  Our interpreter suffers from amnesia: every time when accessing a property, he is forced to perform the entire generalized algorithm for finding a property.  He does not learn from previous attempts and is forced to pay the maximum each time.  Therefore, performance-oriented virtual machines implement property access in a different way. <br><br><img src="https://habrastorage.org/files/969/03d/286/96903d2862954ce0b081de9c704d342c.png" align="left"><br>  Now, if it were possible to get information about the objects that we have already seen, and apply it to similar objects!  In theory, this would allow us to save a lot of time using not the general algorithm, but the most suitable for objects of a particular <i>form</i> . <br><br>  We know that searching for a property in a random object is a time-consuming operation, so it would be nice to do it once, and cache the found <i>path</i> using the object's <i>form</i> as a key.  The next time we meet an object of the same form, it will be possible to get the path from the cache much faster than calculating it from scratch. <br><br>  These optimization techniques are called <abbr title="Inline caching">inline caching</abbr> and I already <a href="http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html">wrote about it before</a> .  For this article, we will not go into the details of the implementation, but pay attention to two important things that I previously kept silent about: like any other cache, the inline cache has a <i>size</i> (the number of cached elements at the moment) and a <i>capacity</i> (the maximum number of elements, which can be cached). <br><br>  Let's go back to the example: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ox</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ x: 1 })</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ x: 2 })</span></span></span></span></code> </pre><br>  How many entries will be in inline cache for <code>ox</code> value? <br><br>  Since <code>{x: 1}</code> and <code>{x: 2}</code> have the same form (it is sometimes called the <abbr title="hidden class / map">hidden class</abbr> ), the answer is 1. It is this cache state that we call <i>monomorphic</i> , because we only come across objects of the same form. <br><br>  <sub>Mono (‚Äúone‚Äù) + morph (‚Äúform‚Äù)</sub> <br><br><img src="https://habrastorage.org/files/684/395/c7c/684395c7cdb6457eb06a7e357c7b9176.png" align="right"><br><br><br><br><br>  And what happens if we call the function <code>f</code> with an object of another form? <br><br><pre> <code class="hljs objectivec">f({ x: <span class="hljs-number"><span class="hljs-number">3</span></span> }) <span class="hljs-comment"><span class="hljs-comment">//  ox    f({ x: 3, y: 1 }) //  ?</span></span></code> </pre><br>  The objects <code>{x: 3}</code> and <code>{x: 3, y: 1}</code> have a different shape, so our cache now contains two entries: one for <code>{x: *}</code> and one for <code>{x: *, y: *}</code> .  The operation became polymorphic with a polymorphism level of two. <br><br>  If we continue to transfer objects of various shapes to <code>f</code> , the level of polymorphism will increase until it reaches the capacity limit for the inline cache (for example, in V8, to access the properties, the capacity limit will be four).  After that, the cache will go to the <i>megamorphic</i> state. <br><br><pre> <code class="hljs ruby">f({ <span class="hljs-symbol"><span class="hljs-symbol">x:</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">y:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> }) /<span class="hljs-regexp"><span class="hljs-regexp">/ ,  2 f({ x: 5, z: 1 }) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,  3 f({ x: 6, a: 1 }) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,  4 f({ x: 7, b: 1 }) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ </span></span></code> </pre><br><img src="https://habrastorage.org/files/e77/612/986/e776129862e644c096ea6f19d08ba6cd.png" align="left"><br>  The megamorphic state is needed in order not to allow the cache to grow uncontrollably, and in fact means "There are too many forms here, it is useless to track them further."  In a V8 virtual machine, caches in a megamorphic state can still continue to cache something, but not locally, but into a global hash table.  It has a fixed size and overwrites values ‚Äã‚Äãin case of collisions. <br><br><br><br><br>  A little exercise to test understanding: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b, o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ox } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ox } } ff(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, { x: <span class="hljs-number"><span class="hljs-number">1</span></span> }) ff(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }) ff(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, { x: <span class="hljs-number"><span class="hljs-number">1</span></span> }) ff(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> })</code> </pre><br><ol><li>  How many inline property access caches are declared in the <code>ff</code> function? </li><li>  What condition are they in? </li></ol><br><div class="spoiler">  <b class="spoiler_title">Answers</b> <div class="spoiler_text">  Keshes are two and both are monomorphic, since only objects of the same form fell into each of them. <br></div></div><br><br><h4>  Performance impact </h4><br>  At this stage, the performance of the various inline cache states become apparent: <br><br><ul><li>  Monomorphic - the fastest if you access the value from the cache each time ( <b>ONE TYPE IS GOOD!</b> ) </li><li>  Polymorphic - linear search among cache values </li><li>  Megamorphic - referring to the global hash table.  The slowest option from cached, but still faster than cache miss </li><li>  Slip cache - referring to the field, which is not in the cache.  You have to pay for the transition to runtime and the use of the most general algorithm. </li></ul><br>  In fact, this is only half the truth: in addition to direct code acceleration, inline caches also work as spies in the service of the omnipotent optimizing compiler, which sooner or later will come and speed up your code even more. <br><br><h2>  Speculation and optimization </h2><br>  Inline caches cannot maximize performance alone for two reasons: <br><br><ul><li>  Each inline cache works independently and knows nothing about its neighbors. </li><li>  Each inline cache can miss, and then you have to use runtime: ultimately it is a generalized operation with generalized side effects, and even the type of return value is often unknown. </li></ul><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ox</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ox</span></span></span><span class="hljs-function"> + </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oy</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oy</span></span></span><span class="hljs-function"> } </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">g</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({x: 0, y: 0})</span></span></span></span></code> </pre><br>  In the example above, there are seven inline-caches: two for <code>.x</code> , two for <code>.y</code> , two more for <code>*</code> and one for <code>+</code> .  Each acts independently, checking the object <code>o</code> for compliance with the cached form.  The arithmetic cache of the operator <code>+</code> will check whether both operands are numbers, although this could be inferred from the states of the operator caches <code>*</code> .  In addition, V8 has several internal representations for numbers, so this will also be taken into account. <br><br>  Some arithmetic operations in JS have a specific type inherent to them, for example <code>a | 0</code>  <code>a | 0</code> always returns a 32-bit integer, and <code>+a</code> is just a number, but for most other operations there are no such guarantees.  For this reason, writing an <abbr title="Ahead-of-time">AOT</abbr> compiler for JS is an incredibly complex task.  Instead of compiling the JS code in advance once, most JS virtual machines have several execution modes. <br><br>  For example, V8 first compiles everything with an ordinary compiler and immediately starts to execute.  Later, frequently used functions are recompiled using optimizations.  On the other hand, Asm.js uses implicit types of operations and with their help describes a very strictly limited Javascript subset with static typing.  Such code can be optimized even before its launch, without speculations of adaptive compilation. <br><br>  ‚ÄúWarming up‚Äù code is needed for two purposes: <br><br><ul><li>  Reduces delay at start: the optimizing compiler is included only if the code has been used enough times </li><li>  Inline caches manage to collect information about the shapes of objects. </li></ul><br>  As mentioned above, JavaScript code written by people usually does not contain enough information so that it can be fully statically typed and AOT compiled.  The JIT compiler has to speculate on how your program behaves and produce optimized code that is only suitable under certain assumptions.  In other words, he needs to know which objects are used in the function being optimized.  By a happy coincidence, this is exactly the information that inline caches collect! <br><br><ul><li>  Monomorphic cache says: ‚ÄúI <strong>only</strong> saw type A‚Äù </li><li>  Polymorphic cache says: ‚ÄúI have <strong>only</strong> seen types  <sub>1</sub> , ..., A <sub>N</sub> ‚Äù </li><li>  Megamorphic cache says: "Yes, I saw a lot of things ..." </li></ul><br><img src="https://habrastorage.org/files/010/c23/bc5/010c23bc59e04e00b63a0ea01e333615.png" align="left"><br>  The optimizing compiler analyzes the information collected by inline-caches and builds <i>an intermediate representation</i> ( <abbr title="Interpretation">IR</abbr> ) on it.  IR instructions are usually more specific and lower-level than operations in JS.  For example, if the cache for accessing the <code>.x</code> property saw only objects of the form <code>{x, y}</code> , then the compiler can generate an IR instruction that gets the value at a fixed offset from the pointer to the object.  Of course, it‚Äôs not safe to use this optimization for any incoming object, so the compiler will also add <abbr title="type guard">a type check</abbr> before it.  Type checking compares the shape of the object with the expected one, and if they differ, the optimized code cannot be executed.  Instead, the non-optimized code is called and execution continues from there.  This process is called <i>deoptimization</i> .  Type mismatch is not the only reason why de-optimization can occur.  It can also happen if the arithmetic operation was ‚Äúsharpened‚Äù for 32-bit numbers, and the result of the previous operation caused an overflow, or when accessing the nonexistent array index <code>arr[idx]</code> (out of range, sparse array with gaps, etc. .). <br><br><img src="https://habrastorage.org/files/58a/941/ad6/58a941ad60da4167b14b08519e535cf5.png" align="right"><br>  It becomes clear that optimization is needed to eliminate the disadvantages described above: <br><br><table><tbody><tr><th>  Non-optimized code </th><th>  Optimized code </th></tr><tr><td>  Each operation may have unknown side effects and implements full semantics. </td><td>  Code specialization eliminates or limits uncertainty, side effects are strictly known (for example, there is no property reference to a property by offset) </td></tr><tr><td>  Each operation is on its own, is trained independently and does not share the experience with its neighbors. </td><td>  Operations are decomposed into low-level IR instructions that are optimized together, which eliminates redundancy. </td></tr></tbody></table><br><img src="https://habrastorage.org/files/5b9/dfd/320/5b9dfd320af1423f8fbd4076c551d447.png" align="left"><br>  Of course, building IR for specific forms of objects is only the first step in the optimization chain.  When the intermediate representation is formed, the compiler will run over it several times, detecting invariants and cutting out the excess.  This type of analysis is usually limited to the scope of the procedure and compilers are forced to take into account the worst possible side effects on each call.  It should be remembered that a call can be hidden in any non-specific operation: for example, the <code>+</code> operator can call <code>valueOf</code> , and calling its property will call its getter method.  Thus, if the operation could not be specified in the first stage, all subsequent passes of the optimizer will stumble over it. <br><br>  One of the most common types of redundant instructions is to continually check that the same object has the same form.  This is how the initial intermediate representation might look like for the function <code>g</code> from the example above: <br><br><pre> <code class="hljs pgsql"> CheckMap v0, {x,y} ;; shape <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> v1 <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> v0, @<span class="hljs-number"><span class="hljs-number">12</span></span> ;; <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> ox CheckMap v0, {x,y} v2 <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> v0, @<span class="hljs-number"><span class="hljs-number">12</span></span> ;; <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> ox i3 Mul v1, v2 ;; ox * ox CheckMap v0, {x,y} v4 <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> v0, @<span class="hljs-number"><span class="hljs-number">16</span></span> ;; <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> oy CheckMap v0, {x,y} v5 <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> v0, @<span class="hljs-number"><span class="hljs-number">16</span></span> ;; <span class="hljs-keyword"><span class="hljs-keyword">load</span></span> oy i6 Mul v4, v5 ;; oy * oy i7 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> i3, i6 ;; ox * ox + oy * oy</code> </pre><br>  Here the form of the object in the variable <code>v0</code> checked 4 times, although there are no operations between checks that could cause its change.  The attentive reader will also notice that the download of <code>v2</code> and <code>v5</code> also redundant, since no code overwrites them.  Fortunately, a subsequent pass to <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D1%2583%25D0%25BC%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25B7%25D0%25BD%25D0%25B0%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B9">global numbering of values</a> will remove these instructions: <br><br><pre> <code class="hljs pgsql">;;   CheckMap v0, {x,y} v1 <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> v0, @<span class="hljs-number"><span class="hljs-number">12</span></span> i3 Mul v1, v1 v4 <span class="hljs-keyword"><span class="hljs-keyword">Load</span></span> v0, @<span class="hljs-number"><span class="hljs-number">16</span></span> i6 Mul v4, v4 i7 <span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> i3, i6</code> </pre><br>  As mentioned above, it was only possible to remove these instructions because there were no side effects operations between them.  If there was a challenge between the downloads of <code>v1</code> and <code>v2</code> , we would have to assume that it can change the shape of the object in <code>v0</code> , and therefore the verification of the form <code>v2</code> would be mandatory. <br><br>  If the operation is not monomorphic, the compiler cannot simply take the same bundle of ‚Äúform validation and concrete operation‚Äù, as in the examples above.  Inline cache contains information about several forms.  If you take any of them and start only on it, then all the rest will lead to de-optimization, which is undesirable.  Instead, the compiler will build <i>a decision tree</i> .  For example, if the inline cache for accessing the <code>ox</code> property met only forms A, B, and C, then the expanded structure would be similar to the following (this is pseudocode, in fact, a <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584_%25D0%25BF%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25B0_%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">control flow graph</a> will be constructed): <br><br><pre> <code class="hljs ruby">var o_x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($GetShape(o) === A) { o_x = $LoadByOffset(o, offset_A_x) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($GetShape(o) === B) { o_x = $LoadByOffset(o, offset_B_x) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($GetShape(o) === C) { o_x = $LoadByOffset(o, offset_C_x) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ox   A, B, C /<span class="hljs-regexp"><span class="hljs-regexp">/   ,  **     $Deoptimize() } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ,  o   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   - A, B  C.     , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  </span></span></code> </pre><br>  Monomorphic references have one very useful property that polymorphic properties do not have: before the next side effect operation, there is a guarantee that the shape of the object remains unchanged.  Polymorphic treatment provides only a weak guarantee ‚Äúan object has one of several forms‚Äù, with which little can be optimized (at best, one could remove the last comparison and the block with deoptimization, but V8 does not do that). <br><br>  On the other hand, V8 can form an effective intermediate representation if the field is located at the same offset in all forms.  In this case, the polymorphic form check will be used: <br><br><pre> <code class="hljs perl">// ,       A, B  C -   $TypeGuard(o, [A, B, C]) //  ,        var o_x = $LoadByOffset(o, offset_x)</code> </pre><br>  If there are no side effects between two polymorphic checks, the second one can also be removed as unnecessary, as in the case of monomorphic ones. <br><br>  When the inline cache transfers to the compiler information about the possible forms of the object, the compiler can calculate what to do for each of them branching in the graph is impractical.  In this case, a slightly different graph will be generated, where at the end there will be not a de-optimization, but a generalized operation: <br><br><pre> <code class="hljs ruby"> var o_x <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($GetShape(o) === A) { o_x = $LoadByOffset(o, offset_A_x) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($GetShape(o) === B) { o_x = $LoadByOffset(o, offset_B_x) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($GetShape(o) === C) { o_x = $LoadByOffset(o, offset_C_x) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,    ox . /<span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   : o_x = $LoadPropertyGeneric(o, 'x') /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ^^^^^^^^^^^^^^^^^^^^    } /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       "" /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   </span></span></code> </pre><br>  In some cases, the compiler may even abandon the idea of ‚Äã‚Äãspecifying operations: <br><br><ul><li>  There is no way to effectively specify it. </li><li>  The operation is polymorphic and the compiler does not know how to build a decision tree (this used to happen with a polymorphic call to <code>arr[i]</code> , but it has already been fixed) </li><li>  There is no information about the type by which the operation can be specified (the code was never executed, the garbage collector deleted the collected information about the forms, etc.) </li></ul><br>  In these (rather rare) cases, the compiler produces a generic version of the intermediate representation. <br><br><h4>  Performance impact </h4><br>  As a result, we have the following: <br><br><ul><li>  Monomorphic operations are optimized most easily and give the optimizer room for action.  As the Hulk would say - " <strong>ONE TYPE CLOSE TO IRON!</strong> " </li><li>  Operations with a low level of polymorphism, requiring a form check, or a decision tree, are slower than monomorphic: <br><ul><li>  Decision trees complicate the flow of execution.  It is harder for the compiler to distribute type information and remove unnecessary instructions.  Conditional tree transitions can also spoil performance if they fall into a loaded cycle. </li><li>  Polymorphic forms checks do not impede optimization so much and still allow you to delete some unnecessary instructions, but still slower than monomorphic ones.  The impact on performance depends on how well your processor works with conditional transitions. </li></ul></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Megamorphic or highly polymorphic operations are not concretized at all, and in the intermediate representation there will be a challenge, with all the ensuing consequences for the optimization and performance of the CPU. </font></font></li></ul><br> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Translator's note: the author gave a link to the microbenchmark, but the site itself no longer works.</font></font></sub> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Undiscised </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I deliberately did not go into some details of the implementation so that the article would not become too extensive. </font></font><br><br><h4>  Forms </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We did not discuss how forms (or hidden classes) are structured, how they are calculated and assigned to objects. </font><font style="vertical-align: inherit;">A general idea can be obtained from my </font></font><a href="http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">previous article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><a href="http://mrale.ph/talks/awp2014/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">speech on AWP2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One need only remember that the very concept of ‚Äúform‚Äù in JS virtual machines is a heuristic approximation. </font><font style="vertical-align: inherit;">Even if, from the point of view of a person, the two objects have the same shape, from the point of view of the machine it may be different:</font></font><br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A, b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> B, c = { x: <span class="hljs-number"><span class="hljs-number">1</span></span> }, d = { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> dy <span class="hljs-comment"><span class="hljs-comment">// a, b, c, d -     V8</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Since the objects in JS are carelessly implemented as dictionaries, you can apply polymorphism by accident: </font></font><br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(), b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(); <span class="hljs-comment"><span class="hljs-comment">//   if (something) { ay = 2; //  a      b }</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intentional polymorphism </font></font></h4><br>   ,         (Java, C#, Dart, C++  ..),   .   ,           ‚Äî    .          . <br><br> ,  JVM  -    <code>invokeinterface</code>  <code>invokevirtual</code> . <br><br><h4>      </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be borne in mind that some caches are not based on the forms of objects, and / or have a smaller capacity compared to others. For example, a function call inline cache can have only three states: uninitialized, monomorphic, or megamorphic. It does not have an intermediate polymorphic state, because the form of the object does not matter for the function call, and the function object is cached.</font></font><br><br><pre> <code class="hljs actionscript"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cb)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cb(<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">G</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v + <span class="hljs-number"><span class="hljs-number">1</span></span> } inv(F) <span class="hljs-comment"><span class="hljs-comment">// - ,   F inv(G) // -  </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the function is </font></font><code>inv</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optimized and the inline cache is in a monomorphic state, the optimizer can embed the function body in the call site (which is especially important for short functions in frequently called places). If the cache is in the megamorphic state, the optimizer does not know </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">body </font><font style="vertical-align: inherit;">can be embedded, and therefore leaves the generalized call operator in the intermediate representation. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, calls to methods like</font></font><code>om(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">works similarly to accessing a property. Inline cache method calls can also have an intermediate polymorphic state. The V8 virtual machine can embed a call to such a function in a monomorphic, polymorphic, or even megamorphic form in the same way as with the property: first, a type check or a decision tree, after which the function body itself is located. There is only one limitation: the method must be in the form of an object. </font></font><br><br> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, it </font></font><code>om(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses two inline caches at once - one to load the property, the other to directly call the function. The second has only two states, as in the example above for the function </font></font><code>cb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Therefore, its state is ignored when optimizing a call, and only the inline cache of the property call is used.</font></font></sub> <br><br><pre> <code class="hljs actionscript"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inv</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(o)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o.cb(<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> f = { cb: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v }, }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = { cb: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">G</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v + <span class="hljs-number"><span class="hljs-number">1</span></span> }, }; inv(f) inv(f) <span class="hljs-comment"><span class="hljs-comment">// -   , //     f inv(g) //    ,   //  f    g</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It may seem surprising that in the example above </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">they </font></font><code>g</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">have a different shape. </font><font style="vertical-align: inherit;">This happens because when we assign a function to an object's property, V8 tries (if possible) to bind it to the form of the object, and not to the object itself. </font><font style="vertical-align: inherit;">In the example above it </font></font><code>f</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has a form </font></font><code>{c: F}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, then the form itself refers to a closure. </font><font style="vertical-align: inherit;">In all the examples before this form, there was only a sign of the presence of a certain property ‚Äî in this case, its value is also kept, and the form becomes similar to a class from languages ‚Äã‚Äãlike Java or C ++. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, if you later overwrite a property with another function, V8 will consider that it no longer resembles the relationship between class and method, so the form changes:</font></font><br><br><pre> <code class="hljs lua">var f = { cb: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">F</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v }, }; //  f  {cb: F} f.cb = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">H</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v - <span class="hljs-number"><span class="hljs-number">1</span></span> } //  f  {cb: *}</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> About how V8 builds and maintains the form of objects, it would be worth writing a separate large article. </font></font><br><br><h4>     </h4><br>     ,  -    <code>ox</code> ‚Äî   ,      ,  <code>Dictionary&lt;Shape, int&gt;</code> .        :         ,     . ,    -   ,     . <br><br> ,  <code>o = {x: 1}</code>    ,               : <br><br><pre> <code class="hljs bash">// ,  o = { x: 1 } var o = { get <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span></span> () { <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> <span class="hljs-variable"><span class="hljs-variable">$LoadByOffset</span></span>(this, offset_of_x) }, <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> x (value) { <span class="hljs-variable"><span class="hljs-variable">$StoreByOffset</span></span>(this, offset_of_x, value) } // /    //     JS- }; <span class="hljs-variable"><span class="hljs-variable">$StoreByOffset</span></span>(o, offset_of_x, 1)</code> </pre><br> <sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, something like this is implemented in Dart VM properties.</font></font></sub> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you look at it this way, then the inline cache should be more likely represented as </font></font><code>Dictionary&lt;Shape, Function&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparing forms with accessor functions. </font><font style="vertical-align: inherit;">Unlike the naive representation with an offset, both properties from a chain of prototypes, and getters-setters, and even proxy objects from ES6 can be described.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pre-monomorphic state </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Some inline caches in V8 have another state called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pre-monomorphic</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It serves to avoid compiling code for caches that were accessed only once. </font><font style="vertical-align: inherit;">I did not mention this state, because it is a little-known feature of the implementation.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final Performance Council </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The best performance advice can be taken from the title of Dale Carnegie‚Äôs book ‚ÄúHow to stop worrying and start living.‚Äù </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indeed, worrying about polymorphism is usually meaningless. </font><font style="vertical-align: inherit;">Instead, run your code with normal data, look for bottlenecks with a profiler - and if they are related to JS, then you should look at the intermediate representation that the compiler produces. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And only then, if in the middle of your loaded cycle you see a statement called </font></font><code>XYZGeneric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or something will be marked with an attribute </font></font><code>changes [*]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(that is, ‚Äúchanges everything‚Äù), then (and only then) you can begin to worry.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f4c/1d8/8b7/f4c1d88b74bc40ea85fb870b6989ae9d.png"></div></div><p>Source: <a href="https://habr.com/ru/post/303542/">https://habr.com/ru/post/303542/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303532/index.html">About the importance of user stories</a></li>
<li><a href="../303534/index.html">Checking the OpenJDK project with PVS-Studio</a></li>
<li><a href="../303536/index.html">Android Security Rewards is 1 year old</a></li>
<li><a href="../303538/index.html">Relinx is another implementation of .NET LINQ methods in C ++, with support for lazy evaluation.</a></li>
<li><a href="../303540/index.html">NetApp AltaVault Storage Systems</a></li>
<li><a href="../303546/index.html">How to distinguish a trademark from a trademark</a></li>
<li><a href="../303548/index.html">SEM-startups and realities of the crisis</a></li>
<li><a href="../303552/index.html">Unraveling the story of Ada Lovelace (the first programmer in history)</a></li>
<li><a href="../303554/index.html">VIM: why, if there is an IDE, and how?</a></li>
<li><a href="../303560/index.html">Money does not smell: the scandalously bankrupt edition of Gawker begin to pull apart in parts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>