<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>VMware vSphere 6 Storage Technology. Part 1 - Old School</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I present to you the first part of a series of publications on VMware vSphere storage technologies. This article will look at the old proven features ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>VMware vSphere 6 Storage Technology. Part 1 - Old School</h1><div class="post__text post__text-html js-mediator-article">  I present to you the first part of a series of publications on VMware vSphere storage technologies.  This article will look at the old proven features available in 4 and 5 versions of the product. <br><a name="habracut"></a><br><h3>  VASA - vSphere API for Storage Awareness / Storage Monitoring API Kit </h3><br>  VASA is a set of APIs provided by VMware and designed to develop vSphere infrastructure storage providers.  Storage providers are software components provided by vSphere or developed by 3rd parties for integrating (tracking) storage (software and hardware storage) and input / output filters (VAIO) with the vSphere infrastructure. <br><br>  Storage provider (VASA-provider) is needed in order for the virtual infrastructure: <br><br><ul><li>  received information about the status, characteristics and capabilities of the storage; </li><li>  could work with entities like Virtual SAN and Virtual Volumes; </li><li>  could interact with input / output filters (VAIO). </li></ul><br>  The availability of the corresponding VASA-provider provides the above possibilities and allows them to be used in policies (SPBM).  If the required storage provider is not available, vSphere does not see the characteristics of storage systems, VAIO filters, cannot work with vVOL, there is no possibility to create corresponding rules in policies. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Third-party VASA providers are used as tracking services for this vSphere storage.  Such providers require separate registration and installation of the corresponding plug-ins. <br><br>  Built-in storage providers are vSphere components and do not require registration.  For example, the provider for Virtual SAN is automatically registered when it is deployed. <br><br>  vSphere collects information about storage (characteristics, status, capabilities) and data services (VAIO filters) across the entire infrastructure through the storage provider, this information is available for monitoring and decision making through the vSphere Web Client. <br><br>  Information collected by VASA-providers can be divided into 3 categories: <br><br><ul><li>  Opportunities and services storage.  This is exactly what SPBM Common rules and Rules Based on Storage-Specific Data Services rules are based on ‚Äî the capabilities and services provided by Virtual SAN, vVol, and I / O filters. </li><li>  The state of the repository.  Information on the status and events on the storage side, incl.  alarm events, configuration changes. </li><li>  Information Storage DRS.  This information allows to take into account the internal processes of storage management in the work of the Storage DRS mechanism. </li></ul><br>  Developing a VASA provider for product integration (3rd party), in particular storage, with vSphere falls on the vendor‚Äôs shoulders.  Such storage providers can be installed on virtually any infrastructure node with the exception of the vCenter server.  As a rule, third-party VASA-providers are installed on the storage controller or a dedicated server. <br><br>  Multiple vCenter servers can simultaneously access the same storage provider.  One vCenter can simultaneously interact with multiple storage providers (multiple arrays and I / O filters). <br><br><h3>  VAAI - vSphere API for Array Integration / Array Integration API Kit </h3><br>  API of this type can be divided into 2 categories: <br><br><ul><li>  Hardware Acceleration APIs.  Designed for transparent transfer of loads to perform individual operations related to storage from hypervisors to storage systems. </li><li>  Array Thin Provisioning APIs.  Designed to monitor the space on the "thin" partitions of arrays to prevent situations with lack of space and perform the recall (unused) space. </li></ul><br><h3>  Storage Hardware Acceleration (VAAI for Hardware Acceleration) </h3><br>  This functionality integrates ESXi hosts and compatible storage systems, allows you to transfer individual VM maintenance operations and storage from the hypervisor (ESXi host) to an array (storage system), thereby increasing the speed of these operations, reducing the load on the processor and host memory. as well as a storage area network. <br><br>  Storage Hardware Acceleration is supported for block (FC, iSCSI) and file (NAS) storage.  For the operation of the technology, it is necessary that the block device supports the T10 SCSI standard or has a VAAI plug-in.  If the block array supports the T10 SCSI standard, then the VAAI plugin is not needed to support Hardware Acceleration, everything will work directly.  File storage requires a separate VAAI plugin.  The development of VAAI plug-ins falls on the shoulders of the storage vendor. <br><br>  In general, VAAI for Hardware Acceleration allows to optimize and transfer the following processes to an array: <br><br><ul><li>  VM migration through Storage vMotion. </li><li>  Deploy VM from template. </li><li>  Clone VM or VM templates. </li><li>  VMFS locks and metadata operations for VMs. </li><li>  Work with "thick" disks (block and file access, eager-zero disks). </li></ul><br>  For block devices, Hardware Acceleration optimizes operations: <br><br><ul><li>  Full copy (clone blocks or copy offload).  Allows the array to make a complete copy of the data, avoiding host read / write operations.  This operation reduces the time and network load when cloning, deploying from a template, or migrating (moving a disk) to a VM. </li><li>  Block zeroing (write same).  It allows the array to reset a large number of blocks, which significantly optimizes the creation of ‚Äúeager zero thick‚Äù disks for VMs. </li><li>  Hardware assisted locking (atomic test and set - ATS).  Allows you to avoid blocking LUNs with VMFS entirely (there is no need to use the SCSI reservation command) thanks to the support of selective blocking of individual blocks.  Loss (reduced probability of loss) of storage performance is eliminated when the hypervisor makes changes to the metadata on the LUN with VMFS. </li></ul><br><blockquote><h5>  Explanation </h5><br>  VMFS is a cluster FS (file system) and supports parallel operation of several ESXi hosts (hypervisors) with one LUN (which is formatted for it).  On a LUN with VMFS, multiple VM files can be stirred, as well as metadata.  In normal mode, while changes are not made to the metadata, everything works in parallel, many hosts access VMFS, no one bothers anyone, there are no locks. <br><br>  If Hardware Acceleration (VAAI) is not supported by a block device, then any host has to use the SCSI reservation command to make changes to the metadata on VMFS, the LUN is transferred to the exclusive use of this host, for other hosts at the time of making changes to the metadata this LUN becomes unavailable, which can cause a noticeable loss of performance. <br><br>  Metadata contains information about the VMFS partition itself and VM files.  Metadata changes occur in the following cases: turning on / off VMs, creating VM files (creating VMs, cloning, migrating, adding a disk, creating snapshots), deleting files (deleting VMs or VM disks), changing the owner of the VM file, increasing the VMFS partition, resizing VM files (if VMs have thin disks or snapshots are used, this happens all the time). </blockquote><br>  Hardware Acceleration for VMFS will not work and the load will fall on the host if: <br><br><ul><li>  VMFS source and destination partitions have different block sizes </li><li>  Source file is in RDM format, non-RDM destination file </li><li>  Source file "eager-zeroed thick", destination file "thin" </li><li>  VM has snapshots </li><li>  VMFS stretched across multiple arrays </li></ul><br>  For file storage, Hardware Acceleration optimizes operations: <br><br><ul><li>  Full File Clone.  Allows you to clone VM files at the NAS device level. </li><li>  Reserve Space.  Allows you to reserve space for VMs with ‚Äúthick‚Äù disks (by default, NFS does not reserve space and does not allow making ‚Äúthick‚Äù disks). </li><li>  Native Snapshot Support.  Support for creating snapshots VM at the array level. </li><li>  Extended Statistics.  It gives the opportunity to see the use of space on the array. </li></ul><br><br><h3>  Multipathing Storage APIs - Pluggable Storage Architecture (PSA) / API Multipathing Kit </h3><br>  The ESXi hypervisor uses a separate set of Storage APIs called Pluggable Storage Architecture (PSA) to manage multi-patching.  PSA is an open modular framework coordinating the simultaneous operation of multiple multipathing plug-ins (MPPs).  PSA allows manufacturers to develop (integrate) their own multi-looping technologies (load balancing and disaster recovery) to connect their storage systems to vSphere. <br><br>  PSA performs the following tasks: <br><br><ul><li>  Load and unload multi-plugin plugins </li><li>  Hides from VM the specifics of the work of multi-plugin plugins </li><li>  Forwards MPP I / O requests </li><li>  Handles I / O queues </li><li>  Allocates bandwidth between VMs. </li><li>  Performs detection and deletion of physical paths. </li><li>  Collects I / O statistics </li></ul><br>  By default, ESXi uses VMware's built-in Native Multipathing Plug-In (NMP) plugin.  In general, NMP supports all types and storage models compatible with vSphere and selects the default multi-pattern algorithm, depending on the specific model. <br><br>  NMP in turn is also an extensible module that manages two sets of plug-ins: Storage Array Type Plug-Ins (SATPs), and Path Selection Plug-Ins (PSPs).  SATPs and PSPs can be embedded VMware plug-ins or third-party development.  If necessary, the storage developer can create their own MPP for use in addition to or instead of NMP. <br><br>  The SATP is responsible for restoring the path after a failure (failover): monitoring the state of physical paths, informing them of a change in their state, switching from a bad path to a working path.  NMP provides SATPs for all possible array models supported by vSphere, and selects the appropriate SATP. <br><br>  The PSP is responsible for choosing the physical data transfer path.  NMP offers 3 PSP built-in options: Most Recently Used, Fixed, Round Robin.  Based on the SATP selected for the array, the NMP module selects the default PSP option.  In this case, the vSphere Web Client allows you to select the PSP option manually. <br><br>  The principle of the PSP options: <br><br><ul><li>  Most Recently Used (MRU) - the host chooses the path that was used last (recently).  If this path becomes unavailable, the host proceeds to the alternate path.  Return to the original path after its recovery does not occur.  Ability to set the preferred path is missing.  MRU is the default option for most active-passive arrays. <br><br></li><li> Fixed - the host uses the preferred path, which can be set manually, or selects the first working path that was detected during system boot.  Manually set the preferred path retains its status even being inaccessible, so after its restoration, the host will switch back to it.  If the preferred path is not explicitly set manually and was chosen automatically, if it is not available, a duplicate path is assigned to the preferred path and there will be no return to the original path after its restoration.  Fixed is the default option for most active-active arrays. <br><br></li><li>  Round Robin (RR) - the host uses an automatic path selection algorithm performing the rotation of active paths for active-passive arrays, or the rotation of all paths for active-active arrays.  As you can see, RR can be used for both types of arrays and allows load balancing on paths for different LUNs. </li></ul><br>  Thank you for your attention, to be continued. </div><p>Source: <a href="https://habr.com/ru/post/314400/">https://habr.com/ru/post/314400/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314386/index.html">Java Programmer Cheat Sheets 9: Java SE - Cheat Sheet for Interviews and Repetitions</a></li>
<li><a href="../314390/index.html">IBM expands Bluemix ecosystem to give China access to blockchain and IoT</a></li>
<li><a href="../314392/index.html">Roskomnadzor: keep your ears open. How to notice the listing on time</a></li>
<li><a href="../314394/index.html">Making a project on Node.js using Mongoose, Express, Cluster. Part 1</a></li>
<li><a href="../314396/index.html">Text translation HighLoad ++ 2016. Day One</a></li>
<li><a href="../314402/index.html">Bushed Bricks: A simple and exciting JavaScript game.</a></li>
<li><a href="../314404/index.html">How we built our mini data center. Finance, pricing</a></li>
<li><a href="../314408/index.html">Once met JMeter and a stranger ...</a></li>
<li><a href="../314410/index.html">Going deeper into the Underground: the story of one extreme game design</a></li>
<li><a href="../314412/index.html">Setting UEFI-loader. The quickest guide in the world</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>