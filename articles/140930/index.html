<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Amateur Game Translation: Anatomy of a Process, Part One</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Amateur localization is a phenomenon that has affected many gamers, and sometimes even played a significant role in shaping their interests and attitu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Amateur Game Translation: Anatomy of a Process, Part One</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/4c2/65c/dac/4c265cdac7094f1474e3fea0a7f1081d.png" align="left">  Amateur localization is a phenomenon that has affected many gamers, and sometimes even played a significant role in shaping their interests and attitudes towards the gaming industry as a whole.  Probably due to the fact that it has long pursued mainly good goals, the majority of fans of interactive entertainment at its mention appear mostly positive associations, and sometimes even nostalgic emotions. <br><br>  Last time I expounded <a href="http://habrahabr.ru/post/140513/">my view</a> on the phenomena of both amateur and official localization.  Since there were people who were close or interested in this topic, and it wasn‚Äôt enough without anyone who would like to know more about the technical details of the process, I have no choice but to tell about it, albeit in a somewhat specific style. <br><br><br clear="all">  The picture shows the logo of the Russian Romanshaking community according to the <a href="http://romhacking.net.ru/">Russian Romhacking</a> project. <br><a name="habracut"></a><br><h1>  Before reading </h1><br>  First of all, I want to say that I review only the experience that I had the opportunity to observe or practice personally.  So far from being a fact that all unofficial localizers adhered to the techniques described below, and even more so for the mentioned toolkit.  First of all, I will talk about the approach that I used myself.  I believe that it is sufficiently indicative and benefits from many other methods practiced by other enthusiasts.  However, the concept of the technique here is rather vague, and for many it is completely absent. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Just in case, I will mention that my actions, on which all the described experience is based, have never pursued mercenary goals and were not destructive in nature.  All this was done, first of all, for the sake of the process and self-development, and it was just my hobby. <br><br>  To be honest, I thought for a long time how to structure an article and what exactly to include in it - first I wanted to tell not only about the technical features of the process, but also to describe the essence of the social component.  However, at some point I caught myself thinking that because of the abundance of criticism, the article is suitable for a somewhat different place than for Habr - the majority of non-professionals reproach the lack of professionalism and lack of desire to improve the techniques somewhat cynically. <br><br>  As a result, I decided to describe only the technical part and only in general form - a detailed description with examples would be enough for a dozen of such articles, or even for another useless book, so for now let's put it on the back burner.  Despite this, the article, even in its incomplete form, turned out to be quite large, and I decided to split it into several posts.  How it came out interesting or useful - to judge you. <br><br><h1>  The technical side of the issue </h1><br>  If you make a small breakdown of the translation process into subtasks, you can get something like this: <br><ul><li>  <b>Reverse engineering</b> is a process much better known by the term reverse engineering.  The game is examined, analyzed formats, define algorithms, find the necessary data. </li><li>  <b>Resource Extraction</b> - converts the <b>resources</b> needed to translate into an easy-to-edit form.  Text - in text files, graphics - in common image formats, etc.  All this can be done either manually (inscrutable ways are amateurish), or through tools - written at best by the translators themselves. </li><li>  <b>Translation and editing</b> is the essence of the process.  The result of these works is estimated by the players. </li><li>  <b>Translation assembly</b> - converting resources back into game formats and replacing original game data with them.  Ideally, this process should consist only in launching tools for automatic assembly, but, unfortunately, for most translators it consists in manual editing each time if necessary to make changes. </li><li>  <b>Testing</b> is a mandatory step that allows you to identify many errors and sometimes improve the translation.  Among those who desire to play their favorite game in their native language, the most responsible and competent are selected, then they are handed a beta version of the translation with a request to reproduce as many game situations as possible.  And a fresh view from the outside is always good, the team may simply not see many mistakes. </li></ul><br><br>  If you delve into the details, then there is no sequence of actions that is the same for all cases, which must be carried out in order to prepare the game for translation.  Also, there are no universal methods with which you can perform certain steps.  In fact, it is always improvisation, but still there is a list of tasks that occur almost always. <br><br>  I will try to highlight the most often arising and important tasks, having told about each of them separately.  As a platform, we will not consider anything concrete - i.e.  Everything described below is valid for both PCs and any other platform - be it from any PlayStation, XBOX, or at least Sega or Dendy (NES). <br><br>  Since in this context most of the reverse engineering tasks can be solved by means of a debugger or disassembler, I will only mention them in some cases. <br><br><h3>  Text encoding definition </h3><hr><br><img src="https://habrastorage.org/getpro/habr/post_images/696/eea/99e/696eea99ea784c3818b4db16ab4549cb.png" align="right">  It would seem that a completely trivial task is to determine in which encoding the text is stored.  And in most cases this is really not difficult, but even here the thought of the developers knows no bounds. <br><br>  Not always the displayed text is stored exactly as text, more often it is just a set of character indexes in the font that need to be displayed.  Often they are made compatible or partially compatible with any encoding, mostly the first 256 Unicode characters.  Whatever it was, you still need to establish an exact match between the characters and their codes.  However, in modern games, it is increasingly common to use ordinary encodings instead of indexes and serialize text into formats like XML - no one has ever thought much about performance for a long time. <br><br>  For the encoding representation, ‚Äúencoding tables‚Äù are used - text files, where in each line of a certain sequence of bytes a certain sequence of characters is mapped.  It looks like this: <br><pre><code class="sql hljs">41=A 42=B ... 5A=Z 1E20=Hero 1E21=Item 1E22=Bonus</code> </pre> <br><br>  For example, the text ‚ÄúHero obtains Item!‚Äù Would be encoded as follows: ‚Äú <code>1E 20 20 6F 62 74 61 69 6E 73 20 1E 21 21</code> ‚Äù.  However, if it turns out that the resulting encoding is sufficiently compatible with any usable encoding (say, with Unicode), then the table is generally not needed and you can skip this step. <br><br>  The most common way to determine the encoding and find the text is the so-called "relative search" (relative search).  Its essence is that no absolute values ‚Äã‚Äãare searched for: the search criterion is the difference between the values ‚Äã‚Äãof the desired sequence.  To do this, it is enough to take some not too short word found in the game, and all sequences of bytes will be found in which the difference between the elements is equal to the difference between the character codes of the source word. <br><br>  For example, for the word "WORLD" there is both the sequence "57 4F 52 4C 44" and "77 6F 72 6C 64".  Yes, at least "13 0B 0E 08 00"!  Finding such sequences and making sure that it is an encoded word, we can easily create a table of encoding.  The most famous program with such functionality is the <a href="http://www.romhacking.net/utilities/219/">Hex</a> editor <a href="http://www.romhacking.net/utilities/219/">Translhexion</a> .  There is also a bunch of specialized utilities like <a href="http://www.romhacking.net/utilities/43/">Search Relative</a> .  And many of the technically literate translators wrote similar utilities for themselves. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/50e/8fb/83f/50e8fb83fc7e9107141d1fc6e9673227.png"><br><br>  A typical case: if you compare this screenshot with a canvas of a font, you can see that the sequence found is the character indexes in the font: <br><img src="https://habrastorage.org/getpro/habr/post_images/90b/eb7/8d4/90beb78d42bad3eb8ac28aeafe2d9a79.png"><br><br>  In general, this technique, although applicable in the vast majority of cases, but without some tweaks, does not always work.  After all, no one guarantees that the character codes in the encoding are in the same order as the letters in the alphabet. <br><br>  For example, in reprints of many parts of Final Fantasy for the GameBoy Advance and Nintendo DS, the characters in the font are sorted by frequency of occurrence, and for encoding indices the method resembling UTF-8 is used.  Those.  Any character with a code greater than 0x7F is encoded with two bytes, while the first 128 characters are encoded with only one: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">uint16 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint16 code)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0x8000</span></span> | ((code &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1F00</span></span>) | (code &amp; <span class="hljs-number"><span class="hljs-number">0x3F</span></span>); }</code> </pre><br><br>  A more severe case in my memory is Final Fantasy: 20th Anniversary Edition for the PlayStation Portable.  For each location there existed its own font, its own text and, as a result, its own encoding.  The font consisted only of characters found in the text, which were also ordered by frequency of occurrence.  It would be good to use neural networks to recognize the encoding of each location, but the benefit is enough pixel-by-pixel comparison of the character transparency masks. <br><br>  In these cases, the relative search is also suitable for solving the problem, but it is necessary to search not for the difference between the numbers of letters, but for the difference between the indexes of their characters in the font.  Those.  You can simply write a sequence of indexes - it is quite fit for such a search. <br><br>  Like other resources, text can be packed or encrypted.  In this case, the search among the game data will help only in cases where at least some fragments of words are still present in the packed or encrypted data (this often happens when using algorithms like <a href="http://habrahabr.ru/post/141827/">LZ77 or RLE</a> ).  Therefore, the output can be a search in the core dump.  The ability to extract a dump depends on the platform for which the transfer is being made.  For emulated consoles and PCs, there should be no difficulties - there are a lot of tools for accessing the game‚Äôs memory.  But in other cases, you need the opportunity during the game to run the necessary code on the console, for which, as a rule, the console must be ‚Äúhacked‚Äù.  I will tell you about the methods for analyzing the algorithms themselves in the next article. <br><br><h3>  Pointer Search </h3><hr><br><img src="https://habrastorage.org/webt/dp/8f/bx/dp8fbx8fyypdteqdygl0haovtiu.png" align="left" alt="Hand of Fate">  If the data is stored in serialized form, this item can be safely skipped.  If resources are stored in an executable file (which is almost always true for consoles using cartridges) in a ready-to-use form, then, as a rule, there is a pointer to each such resource.  Naturally, this also applies to the text.  Moreover, in order to make it possible to freely modify the text, it is necessary to find all the pointers and references to each of the variable lines. <br><br>  It's funny that for a number of beginners understanding the concept of pointers is one of the most difficult obstacles in mastering the art of amateur translation.  As a rule, such people for a long time do not bother themselves with the technical side of the process and translate the text so that it fits in the length of the original line.  Even more amusing is that in order to improve skills, many of them end up mastering programming.  It would be worth it in the reverse order - and everything would be much easier.  Although it is worth noting that people who have become full-fledged IT-specialists often leave this scene and begin to deal with things more seriously. <br><br>  Very often, all pointers are stored in a single place, which is usually called the "table of pointers" - it is an array of pointers or elements containing them.  In such cases, the game accesses the rows by indices, which, in turn, take a pointer from such a table.  Then it suffices to find a pointer to any line in the block of text - and the table is found! <br><br><img src="https://habrastorage.org/webt/6g/ze/4x/6gze4xematxanh_qlgcmvjpgtts.png"><br><br>  But not everything is so simple ... or rather, not always everything is so simple.  One of the difficulties that make it difficult to find pointers is called the ‚Äúoffset difference‚Äù.  The fact is that the pointer can be not only absolute (pointing to the logical or physical address of the resource), but also relative (indicating an offset relative to some address).  Or, say, on old disk consoles like the PlayStation, data is often stored in a form prepared for loading into memory - i.e.  as long as they are in the file, it is impossible to just calculate what the pointer will point to without knowing the address where the download will take place. <br><br>  Until the difference in offsets is known, it is impossible to uniquely calculate the pointer.  Therefore, the first step is usually to check the availability of the table - for this the same relative search can help.  As the elements of the desired sequence, the distances between the beginnings of the lines are taken - the difference between the values ‚Äã‚Äãof the pointers will be exactly the same.  If the table is not found - repeat the search, sorting out possible sizes of pointers and possible distances between them (if in addition to pointers there are other data in the tables). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    char* strings[] = {...}; //     ... struct Message { int characterId; int messageType; char* string; }; Message messages[] = {...};</span></span></code> </pre><br>  However, not all cat Shrovetide - some games refer to the line straight at the pointer without using tables.  Then the difference is calculated as they can: for example, by visual analysis of data or using a disassembler.  There is one more ‚Äúold-fashioned‚Äù way: the data sections will be ‚Äúlousy‚Äù, replacing the bytes, and see if this has any effect on the game.  Thus, by shortening the search range using the exclusion method, you can localize the code segment that is responsible for displaying any line and find the pointer.  For such purposes, there are even whole specialized tools such as <a href="http://magicteam.net/index.php%3Fpage%3Dprograms">Toadstool</a> or <a href="http://bhlady.narod.ru/">Visual Poganka</a> . <br><br>  Without the use of tables, the pointers will be scattered throughout the code space in the executable file, and sometimes not in a single instance.  If the text is stored in one place, this problem can be solved by scanning it and finding all the pointers to the beginning of each line.  And in most cases it is not difficult - due to the peculiarities of the address space, the likelihood of a pointer's value colliding with another value is minimal (for example, the memory is addressed in the range 0x08000000-0x09FFFFFF or the data section starts at 0x00472000). <br><br><img src="https://habrastorage.org/webt/n0/on/ez/n0onez9_oh9opyedeituca4943o.png"><br><br><img src="https://habrastorage.org/webt/rf/fe/ef/rffeef16dd7scgu-zczlichpx6k.png"><br><br>  But it also happens that the memory is addressed in a less successful way for the translator: for example, starting with a zero address.  And then the collisions are certainly not to be avoided ... It is necessary to manually check each value that occurs more than once for whether it is a pointer or data with the same value.  And if the text itself is scattered around the file, then you can only automate the process of searching for pointers by writing some script or plugin for <a href="http://www.idapro.ru/">IDA Pro</a> . <br><br>  One way or another, patience and hard work are going to be done.  It is enough to find the pointers once and then with this task you can not bother, moving on to the next step. <br><br><h3>  Extract text </h3><hr><br><img src="https://habrastorage.org/webt/0a/bw/og/0abwoghpi6rktdtwfod3nvs61lu.png" align="right">  The method of ‚Äúdigging out‚Äù the text on the tables depends on the level of organization of the translators.  So, the most unorganized guys (as a rule, beginners) do not bother at all and translate the text directly into hex editors.  A little bit more serious - they use for extracting all-matching programs like <a href="http://shedevr.org.ru/cgi-bin/utilz.cgi%3Fn%3D7">PokePerevod</a> or the same Translhexion.  People with deeper knowledge use more specialized automation tools like <a href="http://magicteam.net/index.php%3Fpage%3Dprograms">Kruptar</a> .  The most advanced specialists usually write their own scripts or tools for this, which completely allows them to control the process completely. <br><br>  In any case, in most cases the process is reduced to converting a stream of bytes into a form suitable for reading and editing, using information about encodings, binary tags and bytecode used by the game, if it takes place. <br><br><img src="https://habrastorage.org/webt/bz/sa/50/bzsa50so5xanzof2lxa0tqunjfs.png"><br><br>  But it‚Äôs not at all the fact that the developers initially stored the text separately and in a pure form.  Very often it is only a part of other data - level maps, scenarios, etc.  If someone is familiar with game editors like the <a href="http://cs.elderscrolls.com/index.php/The_Elder_Scrolls_Construction_Set">TES Construction Set</a> , he will understand what this is about.  In such cases, since the text is stored together with other data, it is necessary to ‚Äúparse‚Äù their structure and accurately extract text and other necessary information ‚Äî for example, sometimes in addition to text, you also need to change data such as its output coordinates and the size of dialog boxes.  Sometimes, whole editors are written for this, which partially reproduce the functionality of the tools used by the developers. <br><br>  In general, to extract the text I have my own approach.  To begin with, the standard encoding table format is quite simple and does not cover all cases.  For example, it is sometimes important to know which byte sequences are used to indicate the end of text, line breaks, or clear the screen.  Also in the game can be used, for example, markup codes, where a certain part of the bits acts as a parameter.  In this case, you would have to write down the whole thing like this: <br><pre> <code class="sql hljs">1E40=[size=0] 1E41=[size=1] 1E42=[size=2] ... 1E4F=[size=15]</code> </pre> <br><br>  Therefore, there are many add-ons over this format - I even developed my own extension, which allowed to describe even markup codes and other bytes with parameters, and also supported directives like include (conveniently, when there are tables for different languages, but they have the same elements) . <br><br>  Consider an example of a table in an extended format: <br><pre> <code class="sql hljs">;   escape- ( \n  ..) .format ;      ( ) ;    ,     C2A5=[Av-0] C2B3={Hero} ;    ,  ¬´¬ª   ("~") ;    (  ,    ..) C2B7C391~=\n-&gt; C2B7~=\n- ;   ‚Äî    ,  ¬´¬ª  "^" ;      ...   :) C28E^=\n ;    .include opcodes.tbl .include avatars.tbl ;    ( -  C string),  ¬´¬ª   ;  ,          , ;        0D!=</code> </pre> <br><br>  Despite some porridge in the table, the output was pretty neat for the game script text: <br><br><blockquote>  Jenica: I've served this castle for quite <br>  some time.  I looked after both Princess <br>  Lenna and Princess Sarisa. <br>  - <br>  [Av-0] {Hero}: Sarisa? <br>  -&gt; <br>  Jenica: Princess Lenna's older sister. <br>  Sarisa was sailing with her father when <br>  a storm hit </blockquote><br>  The role of neatness will be discussed below, and now we will consider the problem of bytecode.  Some games even use their own <a href="http://wiki.qhimm.com/FF7/Field/Script/Opcodes">scripting languages</a> , and it's good if the text in them is used as external resources.  But sometimes still have to rake a jumble of text and code. <br><br>  If it is impossible to separate the code from the text, then usually for each instruction, a mnemonic and a form of a recording are created on the basis of its purpose.  Having a database with information about all instructions, it is easy to write a translator.  But in order not to write such things every time, I came up with another extension for the encoding table. <br><br>  The instruction in the bytecode is identified by the specific values ‚Äã‚Äãof some bits.  Suppose we have two instructions the size of a byte.  In one instruction, bits one through four are <code>0101</code> , i.e.  it looks like <code>0101nnnn</code> ;  the other one - the first two bits are <code>11</code> , i.e.  We write it as <code>11nnnnnn</code> .  The easiest way to identify an instruction is by mask comparison ‚Äî i.e.  it is necessary to produce a logical multiplication of the identifiable code by the bit mask, thus highlighting the necessary bits, and compare the result with the reference data (hereinafter, we will call this the instruction identifier).  Thus, for the first instruction, the mask will be <code>11110000</code> , since we need to take only the first 4 bits, and the identifier, respectively, will be <code>01010000</code> .  For the second instruction, both the mask and the identifier are equal to <code>11000000</code> . <br><br><img src="https://habrastorage.org/webt/0u/7h/aq/0u7haqp5x9k-kot_f01vuq5cwuw.png"><br><br>  The essence of the extension is that for instructions, you can directly write bit masks and identifiers in the table that are needed to define them and read the parameters.  And instead of a simple sequence of characters, you can use a special string that will talk about how to format and convert the text representation of the instruction back to bytecode.  Those.  according to such tables one could even primitively disassemble executable files. <br><br>  The form of such an instruction record in the encoding table is as follows: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OpcodeMask</span></span></span><span class="hljs-tag">&gt;</span></span>?<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">OpcodeID</span></span></span><span class="hljs-tag">&gt;</span></span>:<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ValuesMasks</span></span></span><span class="hljs-tag">&gt;</span></span>=<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">FormatString</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Where OpcodeMask is a mask, OpcodeID is an identifier, ValueMasks is a comma-separated list of bitmasks of parameters, and FormatString is a string for formatting the text representation of the instruction and converting it back into bytecode (this is a modified equivalent of format strings for the printf function). <br><br>  For example, we have an instruction of the form <code>1010iiii cccccccc</code> , showing in the pop-up window the colors <i>with the</i> item <i>i</i> .  Let's call it "popup (item, color)".  The mask of this instruction is <code>11110000 00000000</code> , which in hexadecimal representation will be <code>F000</code> .  The instruction identifier will be equal to <code>10100000 00000000</code> , i.e.  <code>C000</code> , and the parameter masks are <code>00001111 00000000</code> and <code>00000000 11111111</code> , that is, <code>0F00</code> and <code>00FF</code> respectively. <br><br>  Suppose we have such a coded text: <br> <code>0000: 4F 62 74 61 69 6E 65 64 20 61 6E 20 69 74 65 6D  Obtained an item</code> <br> <code>0010: 21 <font color="red">C1 0F</font> 0A 4E 6F 77 20 79 6F 75 20 63 61 6E 20  !##\nNow you can</code> <br> <code>0020: 6F 70 65 6E 20 74 68 65 20 64 6F 6F 72 2E     open the door.</code> <br> <br>  Let's try to decode it using a table in which there is such a record: <br><pre> <code class="sql hljs">F000?C000:0F00,00FF=popup(%d, %d)</code> </pre> <br><br>  We get the following result: <br><blockquote>  Obtained an item! Popup (1, color) <br>  Now you can open the door. </blockquote><br>  Not very well combined with the text.  Therefore we will try to resort to the help of tags.  Let it be XML tags: <br><pre> <code class="sql hljs">F000?C000:0F00,00FF=&lt;popup item="%d" color="%d"/&gt;</code> </pre> <br>  Already much better: <br><blockquote>  Obtained an item! &lt;Popup item = "1" color = "255" /&gt; <br>  Now you can open the door. </blockquote><br>  But it would be even better if instead of ‚Äúmagic constants‚Äù we saw a textual representation of the parameters.  For this, I introduced the ability to declare transfers in the form: <br><pre> <code class="xml hljs">%{<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member1</span></span></span><span class="hljs-tag">&gt;</span></span>[=value],<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">member2</span></span></span><span class="hljs-tag">&gt;</span></span>[=value],...}</code> </pre> <br>  Suppose such an instruction applies only to three items: a bomb with the number 0, a key with the number 1, and a coin with the number 10: <br><pre> <code class="sql hljs">F000?C000:0F00,00FF=&lt;popup item="%{Bomb,Key,Coin=10}" color="<span class="hljs-comment"><span class="hljs-comment">#%2x"/&gt;</span></span></code> </pre> <br>  As you can see, at the same time for the color, I applied a more familiar entry.  Of course, it‚Äôs silly to do this with an eight-bit color representation, but this is just an example taken from the head for clarity. <br><br>  Next, we just have to turn on tag highlighting and can get more or less readable text: <br><pre> <code class="xml hljs">Obtained an item!<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">popup</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">item</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Key"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#0F"</span></span></span><span class="hljs-tag">/&gt;</span></span> Now you can open the door.</code> </pre> <br><br>  If the semantics of instructions are not so important (that is, the translation does not imply editing them), then it is better to resort to a shorter record, or in some places the code may turn out more than text.  For example: <br><blockquote>  Obtained an item! {Popup: Key, 0F} <br>  Now you can open the door. </blockquote><br>  For instructions with exactly one parameter, I provided a shortened form of recording.  The following are two equivalent strings: <br><pre> <code class="sql hljs">FF00?3C00:00FF=&lt;pause time="%d"&gt; 3C??=&lt;pause time="%d"&gt;</code> </pre> <br>  As can be seen from the record, I selected the parameter bits with the question marks, the remaining bits are considered the unit bits of the mask, and the identifier is obtained by replacing the question marks with zeros.  Unfortunately, such a record is possible only for instructions where the sizes of the parameter and identifier are a multiple of four bits, i.e.  the size of one hexadecimal character. <br><br><h3>  Text presentation </h3><hr><br><img src="https://habrastorage.org/webt/ic/ar/5m/icar5mbtwb3syeswhhqkeyihkig.png" align="left">  This is one of the most important parts of the process, because the extracted text will go straight to the translators, and not only the productivity of their work, but also the number of structural and semantic errors that they make will depend on how tidy it is.  In essence, this process is the refinement of the text extraction mechanism so as to simplify the work of translators as much as possible. <br><br>  If we consider the text described in the previous paragraph, then for the translator a brief excursion on the purpose of tags and other rubbish is sufficient, especially it should not frighten him.  But, it should be noted that the main, in my opinion, error in the presentation of the text is an overwhelming amount of technical information.  For most amateurs, such a text would look very different: <br><blockquote>  Jenica: I've served this castle for quite ^ <br>  some time.  I looked after both Princess ^ <br>  Lenna and Princess Sarisa. ^ {CLS} <br>  [# C2] [# A5] [# C2] [# B3]: Sarisa? ^ {CLS} [# C3] [# 91] <br>  Jenica: Princess Lenna's older sister. ^ <br>  Sarisa was sailing with her father when ^ <br>  a storm hit the sea. {END} </blockquote><br>  In the place of a translator, I would say: ‚Äúand how would you like <i>it to be</i> translated?‚Äù <br><br>  Alas, judging by the fragmentary information, this is also encountered in the process of official localizations: they will give the text in XML or INI format with ‚Äú\ n‚Äù as a line break, and translate as you wish.  At the same time, many people, even in such cases, do not change Word, which is able to kill almost any such format with any kind of auto replacement, or worse. <br><br> ,  ,      ,       ,      . -   ¬´¬ª          ‚Äî     Word,   ¬´¬ª,      . <br><br>  ,        .   ,        ,       , ..      .    ,   : <br><blockquote> &amp;push;&amp;main-color=#E67E00FF;Energy Cell ID:&amp;pop; <br> SN-3871S-7 <br><br> &amp;push;&amp;main-color=#E67E00FF;Status:&amp;pop; <br> &amp;if=hasitem:Fuse7Used;Used&amp;else;&amp;if=hasitem:Fuse7;Acquired&amp;else;Unknown&amp;endif;&amp;endif;&amp;if=scan:SCAN,0x6479E69556A56AC8; <br> &amp;if=(hasitem:Fuse7Used)|(hasitem:Fuse7); <br> &amp;push;&amp;main-color=#E67E00FF;Previous Coordinates:&amp;pop;&amp;else; <br> &amp;push;&amp;main-color=#E67E00FF;Coordinates:&amp;pop;&amp;endif; <br> &amp;if=mapped:PirateCommand;04P-MET, Pirate Homeworld&amp;else;04P-MET, Unknown&amp;endif; <br><br> &amp;just=left;Data indicates Energy Cell is connected to &amp;push;&amp;main-color=#FF6705B3;processing&amp;pop; containment core.&amp;endif; </blockquote><br> ,   ,        ( ,  ).       WYSIWYG-, ,   ,           .     (  ) ,         -  . <br><br>      (   )     ,    . ,   ,      ¬´{code}¬ª  ¬´{&lt;group_number&gt;}¬ª,      . ,      ,         ,     . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> But there was still some way out, and it lies in syntax highlighting. </font></font> Because<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All technical data are usually easily processed automatically, and it is not a problem to select them among the rest of the text. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For these purposes, I used the capabilities of the well-known Notepad ++ - it has a tool for creating my own backlight mechanism. </font><font style="vertical-align: inherit;">I was lucky that the translator with whom I worked used Notepad ++ myself, so I didn't have to persuade anyone. </font><font style="vertical-align: inherit;">Despite the limitations in creating the rules for highlighting, this possibility turned out to be quite enough, although sometimes it was necessary to resort to various crutches. </font></font><br><img src="https://habrastorage.org/storage2/c6f/e6f/fca/c6fe6ffca72e8fb78820fc2e7a72598c.png" alt="Metroid Prime 3 Notepad++ Highlighting"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With this, it is quite possible to live. </font><font style="vertical-align: inherit;">And sometimes I went even further and wrote visualizers - programs that displayed text just as it would look in a game. </font><font style="vertical-align: inherit;">Well, or almost the same ...</font></font><br><img src="https://habrastorage.org/webt/z9/jv/zt/z9jvztg7cdnikxjkwft6gnwkx7g.png" alt="Mario Text Viewer"><br><br> ,    ,              .         ,     ,        . ,        . <br><br><h1>  To be continued </h1><br>    : <br><ul><li> <b> </b> ‚Äî  ,    ,     . </li><li> <b> </b> ‚Äî         ,        . </li><li> <b> </b> ‚Äî   ,          ,    . </li><li> <b></b> ‚Äî          ,      ¬´ ¬ª. </li><li> <b> </b> ‚Äî            . </li><li> <b> </b> ‚Äî                . </li><li> <b></b> ‚Äî  ,           . </li><li> <b></b> ‚Äî     ,  ,          . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/140930/">https://habr.com/ru/post/140930/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../140924/index.html">ActiveGift.me is no longer in stealth</a></li>
<li><a href="../140925/index.html">The fastest processor module</a></li>
<li><a href="../140926/index.html">Skype went on the advertising path</a></li>
<li><a href="../140928/index.html">Android Notifications. Alerts via the Status Bar</a></li>
<li><a href="../140929/index.html">Is Google Drive launching in April?</a></li>
<li><a href="../140931/index.html">Installing Linux (Lubuntu) on a Sony Vaio P netbook</a></li>
<li><a href="../140932/index.html">Google Drive will be launched in early April</a></li>
<li><a href="../140933/index.html">PlayStation 4 may not be compatible with games from previous PS versions.</a></li>
<li><a href="../140934/index.html">Promotional action Drei.AT and Dropbox. And again + 2GB for your account</a></li>
<li><a href="../140935/index.html">Brief Description of the CImg Library</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>