<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What I learned by converting a project to Kotlin using Android Studio</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="To my great joy, I finally had the opportunity to work with the popular Kotlin language - convert a simple Java application using the Convert Java Fil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What I learned by converting a project to Kotlin using Android Studio</h1><div class="post__text post__text-html js-mediator-article">  To my great joy, I finally had the opportunity to work with the popular Kotlin language - convert a simple Java application using the <a href="https://developer.android.com/kotlin/get-started.html">Convert Java File to Kotlin</a> tool from Android Studio.  I tried the language and would like to talk about my experience. <br><br>  I quickly became convinced that this tool converts most of the classes into Java almost flawlessly.  But in some places I had to clean up the code behind it, and in the process I learned a few new keywords! <br><br>  Below I will share my observations.  Before we begin, I note: if at some point you want to take a look at what is happening ‚Äúunder the hood‚Äù, Android Studio allows you to track all the processes;  just go to the panels in the following path: Tools ‚Üí Kotlin ‚Üí Show Kotlin Bytecode. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/web/243/a51/97c/243a5197c71e4e52827ad13275dd898e.png"></div><a name="habracut"></a><br><h4>  Constant long </h4><br>  I did not even notice the first change at first - it was so insignificant.  Magically, the converter replaced the long constant in one of the classes with an int and converted it back to long with each call.  Brr! <br><br><pre><code class="hljs scala">companion <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">TIMER_DELAY</span></span> = <span class="hljs-number"><span class="hljs-number">3000</span></span> } <span class="hljs-comment"><span class="hljs-comment">//... handler.postDelayed({ //... }, TIMER_DELAY.toLong())</span></span></code> </pre> <br>  Good news: The constant is still recognized by the val keyword. <br><br>  The bad news: many processes were accompanied by unnecessary transformations.  I expected that the security of types in Kotlin will be at a higher level, that everything will be implemented better there.  Maybe I overestimated how smart this converter is? <br><br>  The solution turned out to be simple: you just needed to add an ‚ÄúL‚Äù at the end of the variable declaration (something like in Java). <br><br><pre> <code class="hljs scala">companion <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> <span class="hljs-type"><span class="hljs-type">TIMER_DELAY</span></span> = <span class="hljs-number"><span class="hljs-number">3000</span></span>L } <span class="hljs-comment"><span class="hljs-comment">//... handler.postDelayed({ //... }, TIMER_DELAY)</span></span></code> </pre> <br><h4>  Better late than never </h4><br>  One of the main advantages of Kotlin is <a href="https://kotlinlang.org/docs/reference/null-safety.html">null security</a> , which eliminates the threat of null references.  This is accomplished using a type system that distinguishes between non-null and non-null references.  In most cases, you prefer the links that do not allow null values, with which there is no risk of facing NPE (Null Pointer Exceptions).  However, in some situations, null links can be useful, for example, when initializing from an onClick () event, such as AsyncTask. <br><br>  There are several ways to work with zero links: <br><br><ol><li>  Good old if statements that check properties for zero references before giving access to them (Java should have taught you to them). </li><li>  A <a href="https://kotlinlang.org/docs/reference/null-safety.html">cool Safe Call Operator</a> (syntax?.) That checks for zero values ‚Äã‚Äãin the background for you.  If the object is a null reference, then it returns zero (not NPE).  No more annoying if statements! </li><li>  Forcible return of NPE with the help of the operator !! .. In this case, you are actually writing a familiar Java code and you need to return to the first step. </li></ol><br>  Determining exactly which pattern to stop in order to ensure null security is not an easy task, so the converter chooses the simplest solution by default (the third one), allowing the developer to cope with the problem in the best way for his case. <br><br>  I understood that allowing the Kotlin code to throw out the null pointer exception somehow contradicts the advantages of this language, and began to dig deeper in the hope of finding a solution that would be better than the existing ones. <br><br>  So I discovered the powerful lateinit keyword.  Using lateinit in Kotlin, you can <a href="https://kotlinlang.org/docs/reference/properties.html">initialize non-zero properties</a> after calling the constructor, which gives you the opportunity to move away from zero properties altogether. <br><br>  This means that I get all the advantages of the second approach without the need to prescribe an additional "?.".  I simply treat the methods as if they are in principle never null, without wasting time on routine checks and using the syntax I‚Äôm used to. <br><br>  Using lateinit is an easy way to remove operators !!!  from the Kotlin code.  If you are interested in other tips on how to get rid of them and make the code more accurate, I recommend the <a href="https://android.jlelse.eu/how-to-remove-all-from-your-kotlin-code-87dc2c9767fb%3Fgi%3D26743d7b8c09">post David V√°vra</a> . <br><br><h4>  Internal and his inner world </h4><br>  Since I was converting from class to class, I wondered how the already converted classes would interact with those that still remain in Java.  I read that <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html">Kotlin is perfectly compatible with Java</a> , so, logically, everything should work without visible changes. <br><br>  I had a public method in one fragment, which was converted to the <a href="https://kotlinlang.org/docs/reference/visibility-modifiers.html">internal</a> function in Kotlin.  In Java, he had no <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">access modifiers</a> , and, accordingly, he was package private. <br><br><pre> <code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fragment</span></span></span><span class="hljs-class"> </span></span>{ void setErrorContent() { <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre> <br>  The converter noticed the absence of access modifiers and decided that the method should be visible only within the module / package, using the internal keyword to set <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html">the visibility parameters</a> . <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ErrorFragment</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Fragment</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setErrorContent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br>  What does this new keyword mean?  Looking into the decompiled bitcode, we will immediately see that the method name from setErrorContent () has become setErrorContent $ production_sources_for_module_app (). <br><br><pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> setErrorContent$production_sources_for_module_app() { <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Good news: in other Kotlin classes, it‚Äôs enough to know the original name of the method. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">mErrorFragment</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.setErrorContent</span></span>()</code> </pre> <br>  Kotlin will translate it into the generated name.  If you look at the decompiled code again, you can see how the translation was made. <br><br><pre> <code class="hljs pgsql">// Accesses the ErrorFragment instance <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> invokes the actual <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> ErrorActivity.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>$getMErrorFragment$<span class="perl"><span class="perl">p(ErrorActivity.this) .setErrorContent$production_sources_for_module_app();</span></span></code> </pre> <br>  Thus, Kotlin understands the changes in the names on their own.  What about the rest of the Java classes? <br><br>  You cannot call the errorFragment.setErrorContent () method from the Java class, because this ‚Äúinternal‚Äù method does not actually exist (since the name has changed). <br><br>  The setErrorContent () method is now invisible for classes in Java, as can be seen in the API and in the Intellisense window in Android Studio.  So you have to use the generated (and very cumbersome) method name. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/474/7cd/f54/4747cdf547a94690a78ce9d416bf8a0f.png"></div><br>  Despite the fact that Java and Kotlin usually interact without problems, when calling the Kotlin classes from Java classes, unforeseen difficulties may arise with the keyword internal.  If you plan to move to Kotlin in stages, keep this in mind. <br><br><h4>  Companion difficulties </h4><br>  Kotlin <a href="https://kotlinlang.org/docs/reference/classes.html">does not allow public static variables and methods</a> that are so typical of Java.  Instead, it offers a concept such as <a href="https://kotlinlang.org/docs/reference/object-declarations.html">a companion object</a> , which is responsible for the behavior of static objects and interfaces in Java. <br><br>  If you create a constant <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html">in a Java class</a> and then convert it to Kotlin, the converter does not recognize that the static final variable should be used as a constant, which can lead to interference with Java and Kotlin compatibility. <br><br>  When you need a constant in the Java class, you create a static final variable: <br><br><pre> <code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DetailsActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ public static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">SHARED_ELEMENT_NAME</span></span> = <span class="hljs-string"><span class="hljs-string">"hero"</span></span>; public static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">MOVIE</span></span> = <span class="hljs-string"><span class="hljs-string">"Movie"</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  As you can see, after converting, they all ended up in a companion class: <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DetailsActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> SHARED_ELEMENT_NAME = <span class="hljs-string"><span class="hljs-string">"hero"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> MOVIE = <span class="hljs-string"><span class="hljs-string">"Movie"</span></span> } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  When they are used by other Kotlin classes, everything happens as expected: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intent = Intent(context, DetailsActivity::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">intent</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">putExtra</span></span></span></span>(DetailsActivity.MOVIE, item)</code> </pre> <br><br>  However, since Kotlin, converting a constant, places it in a companion‚Äôs own class, access to such constants from the Java class is not intuitive. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">intent</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.putExtra</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">DetailsActivity</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Companion</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getMOVIE</span></span>(), <span class="hljs-selector-tag"><span class="hljs-selector-tag">item</span></span>)</code> </pre> <br>  Decompiling the class in Kotlin, we can see that the constants have become private and are expanded through the companion wrapper class. <br><br><pre> <code class="hljs scala">public <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DetailsActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">SHARED_ELEMENT_NAME</span></span> = <span class="hljs-string"><span class="hljs-string">"hero"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">MOVIE</span></span> = <span class="hljs-string"><span class="hljs-string">"Movie"</span></span>; public static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">DetailsActivity</span></span>.<span class="hljs-type"><span class="hljs-type">Companion</span></span> <span class="hljs-type"><span class="hljs-type">Companion</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">DetailsActivity</span></span>.<span class="hljs-type"><span class="hljs-type">Companion</span></span>((<span class="hljs-type"><span class="hljs-type">DefaultConstructorMarker</span></span>)<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//... public static final class Companion { @NotNull public final String getSHARED_ELEMENT_NAME() { return DetailsActivity.SHARED_ELEMENT_NAME; } @NotNull public final String getMOVIE() { return DetailsActivity.MOVIE; } private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre> <br>  As a result, the code is much more complicated than we would like. <br><br>  The good news is that we can partially correct the situation and achieve the desired behavior by entering the keyword <a href="https://kotlinlang.org/docs/reference/properties.html">const</a> in the companion class. <br><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DetailsActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> SHARED_ELEMENT_NAME = <span class="hljs-string"><span class="hljs-string">"hero"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> MOVIE = <span class="hljs-string"><span class="hljs-string">"Movie"</span></span> } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  Now, if you look at the decompiled code, we will see our constants!  But alas, ultimately we still create an empty companion class. <br><br><pre> <code class="hljs scala">public <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DetailsActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> public static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">SHARED_ELEMENT_NAME</span></span> = <span class="hljs-string"><span class="hljs-string">"hero"</span></span>; <span class="hljs-meta"><span class="hljs-meta">@NotNull</span></span> public static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-type"><span class="hljs-type">MOVIE</span></span> = <span class="hljs-string"><span class="hljs-string">"Movie"</span></span>; public static <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">DetailsActivity</span></span>.<span class="hljs-type"><span class="hljs-type">Companion</span></span> <span class="hljs-type"><span class="hljs-type">Companion</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">DetailsActivity</span></span>.<span class="hljs-type"><span class="hljs-type">Companion</span></span>((<span class="hljs-type"><span class="hljs-type">DefaultConstructorMarker</span></span>)<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//... public static final class Companion { private Companion() { } // $FF: synthetic method public Companion(DefaultConstructorMarker $constructor_marker) { this(); } } }</span></span></code> </pre> <br>  But access from Java classes occurs in the usual way! <br><br>  Please note that this method only works <a href="https://kotlinlang.org/docs/reference/properties.html">for primitives and strings</a> .  To learn more about non-primitives, read <a href="https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html">JvmField</a> and the <a href="https://medium.com/%40BladeCoder/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62">Kotlin's hidden costs</a> article. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/f7b/547/abd/f7b547abd40e4181abf8818bd2fd457b.png"></div><br><h4>  Cycles, and how Kotlin improves them </h4><br>  By default, Kotlin converts loops in the range with 0..N-1 bounds, which makes it difficult to maintain the code, increasing the probability of <a href="https://en.wikipedia.org/wiki/Off-by-one_error">errors by one</a> . <br><br>  In my code, for example, there was a nested for loop to add maps to each row ‚Äî the most common example of a for loop on Android. <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_ROWS; i++) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; NUM_COLS; j++) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... } //... }</code> </pre> <br>  The conversion took place without any special tricks. <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..NUM_ROWS - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..NUM_COLS - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... } /<span class="hljs-regexp"><span class="hljs-regexp">/... }</span></span></code> </pre> <br>  The resulting code may seem unusual to Java developers - as if it was written in Ruby or Python. <br><br>  As <a href="http://blog.danlew.net/2017/06/05/musings-on-kotlin-ranges/">Dan Lew</a> writes on his blog, Kotlin‚Äôs range function is inclusive by default.  However, having familiarized myself with the <a href="https://kotlinlang.org/docs/reference/ranges.html">characteristics of</a> the Kotlin <a href="https://kotlinlang.org/docs/reference/ranges.html">range</a> , I found them very well developed and flexible.  We can simplify the code and make it more readable by taking advantage of the opportunities they offer. <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> NUM_ROWS) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> NUM_COLS) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... } /<span class="hljs-regexp"><span class="hljs-regexp">/... }</span></span></code> </pre> <br>  The until function makes loops non-inclusive and easier to read.  You can finally throw all these ridiculous -1 out of your head! <br><br><h4>  Useful tips for advanced </h4><br>  <b>For the lazy</b> <br><br>  Sometimes it is useful to lazily load the member variable.  Imagine that you have a singleton class that manages a list of data.  Each time there is no need to re-create this list, so we often turn to the <a href="https://en.wikipedia.org/wiki/Lazy_initialization">lazy getter</a> .  The pattern is like this: <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Movie&gt; getList() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">list</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">list</span></span> = createMovies(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>; }</code> </pre><br>  If the converter tries to convert this pattern, the code will not compile, since the list is registered as immutable, while createMovies () has a changeable return type.  The compiler will not allow returning a mutable object if the method signature specifies an immutable one. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/5df/cf2/8cc/5dfcf28ccf7c4d359bb242f14bbfd96a.png"></div><br>  This is a very powerful pattern for delegating object loading, so Kotlin incorporates a special function, <a href="https://kotlinlang.org/docs/reference/delegated-properties.html">lazy</a> , to simplify loading in a lazy way.  With it, the code is compiled. <br><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> list: <span class="hljs-type"><span class="hljs-type">List</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Movie</span></span>&gt; by <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> { createMovies() }</code> </pre> <br>  Since the last line is the returned object, now we can create an object that requires less code to load it lazily! <br><br>  <b>Destructuring</b> <br><br>  If you had to destructurize arrays or objects in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">javascript</a> , then <a href="https://kotlinlang.org/docs/reference/multi-declarations.html">declarations on restructuring</a> will seem familiar to you. <br><br>  In Java, we constantly create and move objects.  However, in some cases, we need literally several properties of the object, and it is a pity to take them to variables.  If we are talking about a large number of properties, it is easier to access them through a getter.  For example: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-type"><span class="hljs-type">Movie</span></span> movie = (<span class="hljs-type"><span class="hljs-type">Movie</span></span>) getActivity() .getIntent().getSerializableExtra(<span class="hljs-type"><span class="hljs-type">DetailsActivity</span></span>.<span class="hljs-type"><span class="hljs-type">MOVIE</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Access properties from getters mMediaPlayerGlue.setTitle(movie.getTitle()); mMediaPlayerGlue.setArtist(movie.getDescription()); mMediaPlayerGlue.setVideoUrl(movie.getVideoUrl());</span></span></code> </pre> <br>  Kotlin, however, offers a powerful destructor declaration that simplifies the process of retrieving object properties, reducing the amount of code needed to assign a separate variable to each property. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (_, title, description, _, _, videoUrl) = activity .intent.getSerializableExtra(DetailsActivity.MOVIE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Movie <span class="hljs-comment"><span class="hljs-comment">// Access properties via variables mMediaPlayerGlue.setTitle(title) mMediaPlayerGlue.setArtist(description) mMediaPlayerGlue.setVideoUrl(videoUrl)</span></span></code> </pre> <br><br>  It is not surprising that in the decompiled code the methods we refer to are getters in data classes. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Serializable</span></span> var10000 = this.getActivity().getIntent().getSerializableExtra(<span class="hljs-string"><span class="hljs-string">"Movie"</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">Movie</span></span> var5 = (Movie)var10000; <span class="hljs-attribute"><span class="hljs-attribute">String</span></span> title = var5.component2(); <span class="hljs-attribute"><span class="hljs-attribute">String</span></span> description = var5.component3(); <span class="hljs-attribute"><span class="hljs-attribute">String</span></span> videoUrl = var5.component6();</code> </pre> <br>  The converter was smart enough to simplify the code by destructuring the object.  Nevertheless, I would advise you to read <a href="https://kotlinlang.org/docs/reference/multi-declarations.html">about lambda and destructurization</a> .  In Java 8, there is a common practice to enclose the parameters of lambda functions in parentheses if there are more than one, but in Kotlin this can be interpreted as destructuring. <br><br><h4>  Conclusion </h4><br>  Using the tool to convert to Android Studio was for me a great first step in mastering Kotlin.  But, having overlooked some sections of the received code, I was forced to begin to delve deeper into this language in order to find more efficient ways to write on it. <br><br>  It is good that I was warned: after the conversion, the code must be deducted.  Otherwise, on Kotlin, I would have got something unintelligible!  Although, to be honest, I have no better with Java. <br><br>  If you want to learn other useful information about Kotlin for beginners, I advise you to read <a href="https://developer.android.com/kotlin/get-started.html">this post</a> and watch the <a href="https://www.youtube.com/watch%3Fv%3DczKo-jPVweg">video</a> . </div><p>Source: <a href="https://habr.com/ru/post/332598/">https://habr.com/ru/post/332598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332584/index.html">Making an image recognition service using TensorFlow Serving</a></li>
<li><a href="../332586/index.html">Fix bugs in 1988 style</a></li>
<li><a href="../332588/index.html">How to create your own metro</a></li>
<li><a href="../332594/index.html">Let's Encrypt will start issuing wildcard certificates in January 2018</a></li>
<li><a href="../332596/index.html">We remove and deposit cash at an ATM using a smartphone. World's first</a></li>
<li><a href="../332600/index.html">Tuning typical roles of Windows. Part One: Files and Printing</a></li>
<li><a href="../332602/index.html">Why mobile apps take up more space</a></li>
<li><a href="../332604/index.html">How to build a database for mailings and do not turn into a spammer?</a></li>
<li><a href="../332608/index.html">How to create a vegetation billboard texture in Unreal Engine 4</a></li>
<li><a href="../332612/index.html">Seminar "Clouds and reality: cases, rakes, good news", July 13, St. Petersburg</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>