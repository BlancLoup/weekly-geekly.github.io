<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagger 2.11 & Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article discusses the use of the specialized Dagger 2 module under android and implies that you have basic knowledge of Dagger 2. 


 In Dagger 2...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagger 2.11 & Android</h1><div class="post__text post__text-html js-mediator-article"><p>  This article discusses the use of the specialized Dagger 2 module under android and implies that you have basic knowledge of Dagger 2. </p><br><p>  In Dagger 2.10, a new module was introduced specifically for Android.  This module is supplied as an addition, consisting of an additional library and compiler. <br>  In version 2.11 there were some small changes, in particular, some classes were renamed, so this version will be used. </p><a name="habracut"></a><br><h2 id="bazovaya-teoriya">  Basic theory </h2><br><p>  Consider some of the features of Dagger 2 that will be used in the examples. </p><br>
<h4 id="static-provides-metody">  static <code>@Provides</code> methods </h4><br><p>  We have the opportunity to write static <code>@Provides</code> methods: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepositoryModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> NewsRepository </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newsRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SQLiteDatabase db)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NewsRepositoryImpl(db); } }</code> </pre> <br><p>  The main difference between the static <code>@Provides</code> method and the usual one is that it is jerked by the component directly, and not through the module instance.  Static <code>@Provides</code> methods can be used both in the abstract and in the normal class of the module.  Static methods can be scope and unscope. </p><br><h4 id="binds"> <code>@Binds</code> </h4> <br><p>  Dagger 2 allows us to provide dependencies without the presence of <code>@Provides</code> methods.  This is achieved by having <code>@Inject</code> over the constructor of the class we need to create. </p><br><p>  Consider an example: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsRepositoryImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NewsRepository</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SQLiteDatabase database; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewsRepositoryImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SQLiteDatabase database)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.database = database; } <span class="hljs-comment"><span class="hljs-comment">//.. } ... public class MyActivty extends BaseActivity { @Inject NewsRepositoryImpl newsRepo; @Override protected void onCreate(Bundle savedInstanceState) { getAppComponent.inject(this); } }</span></span></code> </pre> <br><p>  With this approach, we can write a concrete class as a type, we cannot query the dependency on the NewsRepository interface.  Dagger 2 will not be able to find the desired implementation for this interface. </p><br><p>  In order to circumvent this restriction, we need <code>@Binds</code> in order to bind (tie) the implementation to the interface. </p><br><p>  Features <code>@Binds</code> : </p><br><ul><li>  It is applied over the abstract method or over the module interface method. </li><li>  The return type of the method is the interface to which we are implementing the implementation. </li><li>  As a parameter of the method, it is not the dependencies that is indicated, but the type of the specific implementation. </li><li>  Can be applied to the <code>@Qualifier/@Named</code> method. </li><li>  You can specify scope. </li></ul><br><p>  Example: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RepositoryModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> NewsRepository </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newsRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NewsRepositoryImpl repo)</span></span></span></span>; }</code> </pre> <br><p>  Now we can safely write the following: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyActivty</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> NewsRepository newsRepo; ...</code> </pre> <br><p>  The modules presented in the form of abstract classes have the following features: </p><br><ul><li>  May contain abstract methods annotated with <code>@Binds</code> </li><li>  May contain <strong>only static</strong> <code>@Provide</code> methods.  <strong>Non-static</strong> provider methods are <strong>not supported</strong> . </li><li>  May contain abstract methods annotated with <code>@Multibinds</code> </li></ul><br><p>  When using <code>@Binds + @Inject</code> over a constructor, we don‚Äôt have to write and implement the <code>@Provides</code> methods completely. </p><br><p>  If the module has methods for binding only ( <code>@Binds</code> ), then it makes sense to make this module as an interface: </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-function"><span class="hljs-function">NewsRepository </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newsRepository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NewsRepositoryImpl newsRepository)</span></span></span></span>; }</code> </pre> <br><h2 id="dagger-android">  Dagger-Android </h2><br><p>  A typical android application using Dagger 2 looks like this: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Api api; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ DaggerAppComponent .builder() .app(getApplication()) .build() .inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><p>  There may also be sub components for different scopes (for example, Activity scope, Fragment scope). </p><br><p>  Hence the following problems: </p><br><ul><li>  Copy-paste of the similar block.  Even if we took this code to the base class, we will still have to call the inject method. </li><li>  The / Subcomponent component should have a method for each class where it should inject. </li><li>  If we have a multi-level structure of the scopes, then we need to ‚Äúforward‚Äù the sub components through the levels. </li></ul><br><p>  This problem is solved by a new module for android. </p><br><h4 id="podklyuchenie-zavisimostey">  Add dependencies </h4><br><pre> <code class="hljs pgsql">//Dagger <span class="hljs-number"><span class="hljs-number">2</span></span> compile <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger:2.11'</span></span> annotationProcessor <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger-compiler:2.11'</span></span> //Dagger-Android compile <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger-android:2.11'</span></span> annotationProcessor <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger-android-processor:2.11'</span></span> //    support  compile <span class="hljs-string"><span class="hljs-string">'com.google.dagger:dagger-android-support:2.11'</span></span></code> </pre> <br><p>  You can not just connect the dependencies only related to android.  They go as an addition. </p><br><h4 id="realizaciya">  Implementation </h4><br><p>  As it is known, the <code>@Scope</code> annotation and its heirs mark methods in modules, as well as components / subcomponents that provide the dependencies we need. <br>  <code>@Scope</code> determines the lifetime of the objects being created ( <code>@Scope</code> ), thus representing effective memory management. </p><br><p>  Consider an example of the structure of the application for scopam </p><br><ul><li>  <code>@Singletone</code> - the application level (Application), the root scopes, living the longest.  (Components: Context, Database, Repository).  What we may need most often. </li><li>  <code>@ActivityScope</code> - the standard of living over the life of the activity.  May not live long because of the frequent transition from one screen to another.  (Components: Router, Facade).  It makes sense to clean up everything that is not used on a specific activation. </li><li>  <code>@FragmentScope</code> - the level of life throughout the life of the fragment.  He lives the least, the change of fragments can be organized inside one activit.  The same does not make sense to store that which is no longer used on a specific fragment and must be cleaned up.  (Constituent: Presenter) </li></ul><br><p>  In this example, Facade is the equivalent of UseCase / Interactor.  The application has a structure consisting of 3 Ospreys for demonstration of how this can be applied with the help of the new Dagger 2 module. Also here is an option using only with the <code>@ContributesAndroidInjector</code> annotation. </p><br><p>  We start implementation: </p><br><p>  <strong>1. Define our main module.</strong> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span>(includes = {AndroidSupportInjectionModule.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-function"><span class="hljs-function">Repository </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">repository</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RepositoryImpl repository)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContributesAndroidInjector</span></span>(modules = {MainActivityModule.class}) <span class="hljs-function"><span class="hljs-function">MainActivity </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainActivityInjector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  The following has been added to this module: </p><br><ul><li>  <code>AndroidSupportInjectionModule</code> is a built-in dagger-android module that, according to the documentation, must be necessarily added to the root component to ensure the availability of all <code>AndroidInjector</code> .  It is required to inject the DispatchingAndroidInjector (see below). </li><li>  <code>@ContributesAndroidInjector</code> - This annotation will generate an <code>AndroidInjector</code> for the return type, so dagger will be able to inject dependencies into this activity.  A subcomponent for the <code>MainActivity</code> with the @ActvitiyScope <code>@ActvitiyScope</code> will also be generated.  <code>AndroidInjection</code> is essentially a subcomponent for a specific activation.  We can also indicate which modules will apply only to this particular activation.  This <code>AndroidInjector</code> will have all the dependencies of this module ( <code>AppModule</code> ) plus the dependencies that are listed in the <code>ContributesAndroidInjector</code> annotation modules. <br>  <code>@ContributesAndroidInjector</code> - applied over abstract methods or over interface methods. </li></ul><br><p>  <strong>2. MainActivityModule</strong> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-function"><span class="hljs-function">Facade </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">facade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FacadeImpl facade)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-function"><span class="hljs-function">MainRouter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MainRouterImpl mainRouter)</span></span></span></span>; }</code> </pre> <br><p>  When using <code>AndroidInector</code> , we will have an <code>AndroidInector</code> instance available to us, since  This activation is part of the graph. This is because we call <code>AndroidInjection.inject(this)</code> , thereby passing the activation instance (see below). </p><br><p>  An example of getting an activation instance as a dependency. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainRouterImpl</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseRouterImpl</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainRouterImpl</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MainActivity activity)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(activity); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showSomeScreen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ replaceFragment(R.id.content, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyFragment()); } }</code> </pre> <br><p>  <strong>3. We write our root component, which will contain our AppModule, as well as the only injection in Application.</strong> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Singleton</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = { AppModule.class }) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>.Builder <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Builder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@BindsInstance</span></span> <span class="hljs-function"><span class="hljs-function">Builder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">context</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">AppComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">build</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(App app)</span></span></span></span>; }</code> </pre> <br><p>  <strong>4. It is necessary to implement the HasActivityInjector interface in Application and inject the AndroidInector dispatcher.</strong> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasActivityInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> DispatchingAndroidInjector&lt;Activity&gt; dispatchingAndroidInjector; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(); DaggerAppComponent .builder() .context(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) .build() .inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AndroidInjector&lt;Activity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">activityInjector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dispatchingAndroidInjector; } }</code> </pre> <br><p>  <code>DispatchingAndroidInjector</code> needed to search for <code>AndroidInector</code> for a specific <code>Activity</code> . </p><br><p>  <strong>5. Now we can take advantage of all this.</strong> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Repository repository; <span class="hljs-comment"><span class="hljs-comment">//Singleton scope @Inject Facade facade; //activity scope @Inject MainRouter router; //activity scope public void onCreate(Bundle savedInstanceState) { AndroidInjection.inject(this); //     super.onCreate(savedInstanceState); } }</span></span></code> </pre> <br><p>  As we can see here there are no components and subcomponents, but at the same time we have the possibility of obtaining dependencies with different scopes.  In addition, we have a router, for the creation of which is necessary (as a dependency) the activation instance itself. </p><br><p>  The design of <code>AndroidInjection.inject(this)</code> can be rendered to the base class and everything will work as well. </p><br><p>  How it works?  When you call <code>AndroidInjection.inject(this)</code> , Dagger 2 gets access to the Application, which implements the <code>HasActivityInjector</code> interface, where through the dispatcher it finds the desired <code>AndroidInector</code> (sub-component of the activit </p><br><p>  <strong>6. We turn to the implementation of <code>@FragemntScope</code> .</strong> </p><br><p>  We need to update our <code>MainActivityModule</code> : </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivityModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-function"><span class="hljs-function">Facade </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">facade</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FacadeImpl facade)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@ActivityScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-function"><span class="hljs-function">MainRouter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">router</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MainRouterImpl mainRouter)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">@FragmentScope</span></span> <span class="hljs-meta"><span class="hljs-meta">@ContributesAndroidInjector</span></span>(modules = {MyFragmentModule.class}) <span class="hljs-function"><span class="hljs-function">MyFragment </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myFragment</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><p>  We added a similar <code>AndroidInject</code> design for the fragment, as we did for activating. <br>  Thus, AndroidInject (subcomponent) will be generated for us for a specific fragment with the @FragmentScope <code>@FragmentScope</code> .  We will have the <code>@Singleton</code> , <code>@ActivityScope</code> that are specified in this module and those that are specified as modules for this fragment. </p><br><p>  <strong>7. Add the basic activation and implementation of the <code>HasSupportFragmentInjector</code> interface.</strong> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasSupportFragmentInjector</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> DispatchingAndroidInjector&lt;Fragment&gt; fragmentInjector; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ AndroidInjection.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> AndroidInjector&lt;Fragment&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supportFragmentInjector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fragmentInjector; } }</code> </pre> <br><p>  By analogy with <code>Application</code> , we will be <code>AndroidInjector</code> manager, which will provide us with the one we need for the <code>AndroidInjector</code> fragment (subcomponent). </p><br><p>  <strong>8. MyFragmentModule</strong> </p><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFragmentModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Binds</span></span> <span class="hljs-function"><span class="hljs-function">MyView </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(MyFragment myFragment)</span></span></span></span>; }</code> </pre> <br><p>  In the same way as with activit, we use <code>AndroidInjection</code> ( <code>AndroidSupportInjection</code> , if we use the support library), we can access the instance instance, because  it is part of the graph, we can transfer it as a dependency, and also send it to some kind of interface. </p><br><p>  Example presenter: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPresenter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> MyView view; <span class="hljs-comment"><span class="hljs-comment">//  , ..     private Facade facade; //@ActivityScope private MainRouter router; //@ActivityScope @Inject public MyPresenter(MyView view, Facade facade, MainRouter router) { this.view = view; this.facade = facade; this.router = router; } //... }</span></span></code> </pre> <br><p>  <strong>9. Inject into fragment</strong> </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> MyPresenter presenter; <span class="hljs-comment"><span class="hljs-comment">//@FragmentScope @Override public void onAttach(Context context) { AndroidSupportInjection.inject(this); super.onAttach(context); presenter.doSomething(); } @Override public void onResult(String result) { //Todo } }</span></span></code> </pre> <br><p>  The design of <code>AndroidSupportInjection</code> can be rendered to the base class. </p><br><h2 id="vyvod">  Conclusion </h2><br><p>  In my opinion, the new android-dagger module provides a more correct provision of dependencies for android.  We can put injection methods into base classes, get a more convenient division by scopes, we do not need to forward subcomponents, and in our dependency graph, activation and fragment objects that we can use as external dependencies, for example, in presenter, are available. </p><br><p>  <a href="https://github.com/tx-drive/dagger-android-example">GitHub</a> example <br>  <a href="https://habrahabr.ru/post/336462/">Part 2</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/335940/">https://habr.com/ru/post/335940/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335930/index.html">New features in Laravel 5.5</a></li>
<li><a href="../335932/index.html">Test Management for JIRA and its application in software development</a></li>
<li><a href="../335934/index.html">Get ready for a total solar eclipse of 2017</a></li>
<li><a href="../335936/index.html">Double eclipse! Or why Carbondale, Illinois, is special</a></li>
<li><a href="../335938/index.html">Work in Sweden</a></li>
<li><a href="../335944/index.html">Why does the Dwarf Fortress game start during apt-get upgrade?</a></li>
<li><a href="../335948/index.html">Key Criteria for Choosing and Evaluating an Internet Promotion Agency</a></li>
<li><a href="../335952/index.html">Multiformat banners in Tinkoff.ru and the approach to the layout of responsive banners in Google AdWords</a></li>
<li><a href="../335954/index.html">ReactOS versus Windows XP SP3: the epic battle in 3DMark</a></li>
<li><a href="../335958/index.html">Implementation, analog and adaptation for ‚Äúpure‚Äù javascript JavaScript jQuery () functions; and adjacent to it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>