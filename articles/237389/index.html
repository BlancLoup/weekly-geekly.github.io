<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Improving LINQ to work with IReadOnly-collections</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, when using the IEnumerable <> interface, where the collection is implied, problems can occur (see, for example, Problems using IEnumerabl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Improving LINQ to work with IReadOnly-collections</h1><div class="post__text post__text-html js-mediator-article">  As you know, when using the <b>IEnumerable &lt;&gt;</b> interface, where the collection is implied, problems can occur (see, for example, <a href="http://habrahabr.ru/post/193774/">Problems using IEnumerable</a> and <a href="http://habrahabr.ru/post/191770/">LINQ against LSP</a> ).  Fortunately, in .NET v4.5 in 2012 (a little late, but better late than never), the interfaces <b>IReadOnlyCollection &lt;&gt;</b> , <b>IReadOnlyList &lt;&gt;</b> , <b>IReadOnlyDictionary &lt;&gt; appeared</b> (hereinafter I will generally call them <b>IReadOnly-</b> interfaces).  Unlike <b>IEnumerable &lt;&gt;</b> , <b>IReadOnly</b> interfaces allow you to sufficiently designate the collection functionality without any unnecessary requirements, which allows them to be recommended for use instead of <b>IEnumerable &lt;&gt;</b> everywhere where reading of the collection is implied.  But there is one difficulty.  One of the important components that consume and create collections is <a href="https://ru.wikipedia.org/wiki/Language_Integrated_Query">LINQ,</a> and especially its part ‚ÄúLINQ to objects‚Äù.  Unfortunately, <b>IReadOnly</b> interfaces appeared 5 years after LINQ, and are not used in it.  All input and output collections of LINQ operations have the basic <b>IEnumerable &lt;&gt;</b> type, based on the limited capabilities of which, many operations imply unnecessary costs: complete sequential enumeration or even creating intermediate copies of the input collections.  Moreover, by returning the same <b>IEnumerable &lt;&gt;</b> from operations, LINQ requires that further use of the result again uses a full search and the creation of intermediate copies.  In this regard, I have long had the thought to ‚Äúmake friends‚Äù LINQ with <b>IReadOnly</b> interfaces. <br><a name="habracut"></a><br>  Found on the Internet development on this topic did not satisfy me.  For example, the <a href="http://twistedoakstudios.com/blog/Post1585_linq-to-collections-beyond-ienumerablet">Linq to Collections</a> library offers an effective replacement for only some LINQ operations for the <b>IReadOnlyList &lt;&gt;</b> interface <b>only</b> , is poorly optimized, and for some reason it forcibly adds a number of ambiguous extension methods for the basic types.  In another found project on this topic, <a href="https://github.com/azyobuzin/CountableSharp">CountableSharp</a> , a small number of optimized LINQ operations are offered only for the <b>IReadOnlyCollection &lt;&gt;</b> interface, in which a <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D0%25BA%25D0%25BE%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580_%2528%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F%2529">decorator</a> is returned, delegating all calls to the base <b>System.Linq.Enumerable</b> and only the <b>Count</b> property is calculated in advance without requiring a full busting collection. <br><br>  Next, I propose to use my <b>Collection.LINQ</b> library, which optimizes ‚ÄúLINQ to objects‚Äù by providing efficient implementation of most operations for collections that implement <b>IReadOnly</b> interfaces. <br><br>  First of all, I will allow myself a small digression, allowing you to better understand and use the work I have done.  As many of you have probably noticed, in the series of <b>IReadOnly</b> interfaces, there is clearly not enough interface for sets.  Therefore, <a href="">we will create it ourselves</a> in this obvious form: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IReadOnlyFiniteSet</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IReadOnlyCollection</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span></span>{ bool Contains (T item); }</code> </pre> <br>  The only thing that is ambiguous here is the finiteness of the set associated with the inheritance of the <b>IReadOnlyCollection &lt;&gt;</b> .  Alternatively, it was possible to create an intermediate interface of an infinite set of <b>IReadOnlySet &lt;&gt;</b> inherited from <b>IEnumerable &lt;&gt;</b> .  However, there is no practical need for it, since infinite sets are only of academic interest and it is difficult to imagine where they can find application.  All the sets existing in the base class library already implement the methods necessary for <b>IReadOnlyFiniteSet &lt;&gt;</b> , so there will be no problems with its implementation.  Next, I will talk about optimizing LINQ operations, including for the <b>IReadOnlyFiniteSet &lt;&gt;</b> interface, hoping that it will someday be made part of the base library. <br><br>  So, we will consider what operations are implemented in <b>Collection.LINQ</b> and how exactly they increase the efficiency of LINQ to objects. <br><br>  We start by specifying those operations where optimization is not required.  Aggregate Aggregate (), Average (), Min (), Max (), Sum () methods do not need any optimization because <b>IEnumerable &lt;&gt;</b> is a necessary and sufficient interface for them, but they return a value, not a collection.  For the same reason, they do not need to optimize the overloading of the methods All (), Any (), Count (), LongCount (), First (), FirstOrDefault (), Last (), LastOrDefault (), Single (), SingleOrDefault (), taking parameter predicate filter.  The presence of a predicate dictates the need for complete exhaustive search, for which <b>IEnumerable &lt;&gt;</b> is sufficient.  Obviously, they also do not require optimization and the ToArray (), ToList (), ToDictionary (), ToLookup () methods, because they semantically imply brute-force and copy creation.  Only the creation of an array in the ToArray () method can be slightly optimized by knowing in advance the number of elements in the collection. <br><br>  The methods for creating the collections Empty (), Range () and Repeat () require one obvious optimization: they must not return a basic <b>IEnumerable &lt;&gt;</b> , but a specific <b>IReadOnly</b> interface. <br><br>  Now about the main optimization.  In operations that return a collection, the result is created in the form of a decorator, which delegates calls to members directly to the input collections, without prior iterations and creating copies of the elements.  In order for such optimization to work when sequentially applying several operations, it is also important that the returned collections also be an <b>IReadOnly</b> type.  In LINQ to objects, a similar internal optimization is already implemented: many methods first of all check the implementation of some interfaces by the input collection, and use them for more efficient execution of actions.  But, of course, <b>IReadOnly</b> interfaces (which did not exist at the moment LINQ appeared) are not used, and the returned collection always has only the basic type <b>IEnumerable &lt;&gt;</b> .  In my library, optimization in the form of direct decoration is used in the following LINQ operations. <table><tbody><tr><td colspan="2">  <a href="">for collections of type <b>IReadOnlyCollection &lt;&gt;</b></a> </td></tr><tr><td>  Any (), Count (), LongCount () </td><td>  immediately return the result using the <b>Count</b> property </td></tr><tr><td>  DefaultIfEmpty () </td><td>  returns IReadOnlyCollection &lt;&gt;, depending on the <b>Count</b> property, initial or one-element </td></tr><tr><td>  Select (), Zip () </td><td>  return IReadOnlyCollection &lt;&gt; - decorator </td></tr><tr><td>  Skip (), Take () </td><td>  return IReadOnlyCollection &lt;&gt;, depending on the <b>Count</b> property, original, empty or decorator </td></tr><tr><td>  Concat () </td><td>  returns IReadOnlyCollection &lt;&gt;, depending on the properties of the <b>Count,</b> one of the source or the decorator </td></tr><tr><td>  Reverse () </td><td>  returns an IReadOnlyCollection &lt;&gt;, depending on the <b>Count</b> property, either the original or the decorator, which creates a complete copy of the collection when the enumeration request </td></tr><tr><td>  OrderBy (), OrderByDescending (), ThenBy (), ThenByDescending () </td><td>  return an IReadOnlyCollection &lt;&gt;, depending on the <b>Count</b> property, either the original or the decorator, which creates an entire copy of the collection and a sorted index when an enumeration request is made </td></tr><tr><td colspan="2">  <a href="">for <b>IReadOnlyFiniteSet &lt;&gt;</b> sets</a> (in addition to what is available for <b>IReadOnlyCollection &lt;&gt;</b> collections) </td></tr><tr><td>  Contains () </td><td>  immediately returns the result using the <b>Contains ()</b> method </td></tr><tr><td>  Distinct () </td><td>  returns the original IReadOnlyFiniteSet &lt;&gt; set </td></tr><tr><td>  Except (), Intersect (), Union () </td><td>  return IReadOnlyFiniteSet &lt;&gt;, depending on the <b>Count</b> property, one of the initial, empty or decorator, when creating a fully enumerating the smaller of the input sets </td></tr><tr><td>  DefaultIfEmpty () </td><td>  returns IReadOnlyFiniteSet &lt;&gt;, depending on the <b>Count</b> property, initial or one-element </td></tr><tr><td>  Reverse () </td><td>  returns IReadOnlyFiniteSet &lt;&gt;, depending on the <b>Count</b> property, the original or decorator that creates a complete copy of the set </td></tr><tr><td colspan="2">  <a href="">for <b>IReadOnlyList &lt;&gt;</b> lists</a> (in addition to what is available for <b>IReadOnlyCollection &lt;&gt;</b> collections) </td></tr><tr><td>  ElementAt (), ElementAtOrDefault (), First (), FirstOrDefault (), Last (), LastOrDefault () </td><td>  immediately return the result using the methods IReadOnlyList &lt;&gt; </td></tr><tr><td>  DefaultIfEmpty () </td><td>  returns IReadOnlyList &lt;&gt;, depending on the <b>Count</b> property, initial or one-element </td></tr><tr><td>  Skip (), Take (), Select (), Concat (), Zip (), Reverse () </td><td>  return IReadOnlyList &lt;&gt; - decorator </td></tr><tr><td>  OrderBy (), OrderByDescending (), ThenBy (), ThenByDescending () </td><td>  return IReadOnlyList &lt;&gt;, depending on the <b>Count</b> property, the source or decorator that creates a sorted index to delegate the receipt of items by position number and enumeration </td></tr></tbody></table>  Unfortunately, for some LINQ operations, the functionality of <b>IReadOnly</b> collections cannot add efficiency.  These are the operations that result in a collection obtained by filtering the values ‚Äã‚Äãof the elements of the input collections.  There is no way without complete brute force and copying.  The filtering operations SkipWhile (), TakeWhile (), Where (), as well as the conditional grouping and join methods Join (), GroupJoin (), GroupBy (), SelectMany () are not optimized. <br><br>  Additionally, I will mention a few optimizations in my <b>Collection.Linq</b> , not related to <b>IReadOnly</b> interfaces: <ul><li>  The LINQ operation SequenceEqual () is <a href="">implemented</a> as a direct delegation to the Equals () method of the <b>IStructuralEquatable</b> interface for collections that implement this interface (appeared 3 years later LINQ). </li><li>  Significantly reduced the number of method overloads due to the widespread use of optional parameters (appeared a year later LINQ). </li><li>  A clearly missing set operation is added - a symmetric difference in the form of the <a href="">SymmetricExcept ()</a> method. </li></ul><br>  To make sure that I didn‚Äôt miss anything and did it more efficiently than the library <b>System.Linq.Enumerable</b> , I constantly spied on its <a href="http://referencesource.microsoft.com/System.Core/System/Linq/Enumerable.cs.html">sources</a> . <br><br>  Using the <b>Collection.LINQ</b> library is easy: just in your code by line <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Linq;</code> </pre> <br>  add line <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BusinessClassLibrary</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Collections</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Linq</span></span>;</code> </pre> <br>  It doesn't matter how you use ‚ÄúLINQ to objects‚Äù, in the form of query syntax or in a fluent form.  After connecting my library, your LINQ code will automatically use the most optimal methods, provided that collections that implement <b>IReadOnly</b> interfaces are <b>input</b> .  The only exception is the methods for creating collections of the class <b>System.Linq.Enumerable</b> , which are not extension methods: Enumerable.Empty (), Enumerable.Range () and Enumerable.Repeat ().  These methods will need to be manually replaced with ReadOnlyFiniteSet.Empty () / ReadOnlyList.Empty (), ReadOnlyFiniteSet.Range () / ReadOnlyList.Range () and ReadOnlyList.Repeat (), respectively. <br><br>  The entire library is presented in a <a href="https://github.com/novar0/CollectionLinq">public project on github</a> .  At the request of readers, a <a href="https://www.nuget.org/packages/CollectionLinq">nuget-package with a library was</a> also created. </div><p>Source: <a href="https://habr.com/ru/post/237389/">https://habr.com/ru/post/237389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237379/index.html">The new version of Android will encrypt default user data</a></li>
<li><a href="../237381/index.html">Overview of mail clients for Android, or how I chose the mailer</a></li>
<li><a href="../237383/index.html">MAVEN approached Mars orbit</a></li>
<li><a href="../237385/index.html">How we help startups</a></li>
<li><a href="../237387/index.html">Apple has released a set of updates for its products.</a></li>
<li><a href="../237391/index.html">Outsourcing rake or 9 mistakes when opening an accounting business that any startup needs to know</a></li>
<li><a href="../237393/index.html">We check Oracle VM VirtualBox. Part 1</a></li>
<li><a href="../237395/index.html">Yet another registry. What in practice means getting into the register of information dissemination organizers</a></li>
<li><a href="../237399/index.html">Mobile application "Guess the game"</a></li>
<li><a href="../237403/index.html">Smart antennas help make 5G affordable (part 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>