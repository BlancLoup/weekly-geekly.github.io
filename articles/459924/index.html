<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Full cycle of testing React-applications. Report Avto.ru</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The desire to get away from manual regression testing is a good reason to implement autotests. The question is which ones? Interface developers Nataly...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Full cycle of testing React-applications. Report Avto.ru</h1><div class="post__text post__text-html js-mediator-article"> The desire to get away from manual regression testing is a good reason to implement autotests.  The question is which ones?  Interface developers Natalya Stus and Alexey Androsov recalled how their team went through several iterations and built testing frontend in Avto.ru on the basis of Jest and Puppeteer: unit tests, tests for individual React components, integration tests.  The most interesting thing about this experience is isolated testing of React components in a browser without Selenium Grid, Java and others. <br><br> <a href="https://youtu.be/jPqNyF0hH3k%3Ft%3D16913"><img src="https://habrastorage.org/webt/yr/np/zo/yrnpzon4-5momllzoy0bg1zz-ie.jpeg"></a> <br><br>  Alexey: <br>  - First you need to tell a little about what Avto.ru is.  This is a website for selling cars.  There is a search, personal account, car services, spare parts, reviews, dealers' offices and much more.  Avto.ru - a very big project, a lot of code.  All the code we write in a big monorep, because it's all mixed up.  The same people do similar tasks, for example, for mobile and desktop.  It turns out a lot of code, and we are vital mono.  The question is how to test it? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><img src="https://habrastorage.org/webt/vn/qv/qf/vnqvqfbci0v-wlfceczgd5snhgi.jpeg"><br><br>  We have React and Node.js, which performs server-side rendering and requests data from the backend.  Small pieces on the BEM also remained. <br><br><img src="https://habrastorage.org/webt/xb/1p/_b/xb1p_b-9j8huy-rle317mtp5sjc.jpeg"><br><br>  Natalia: <br>  - We started thinking towards automation.  The release cycle of our individual applications included several steps.  First, the feature is developed by the programmer in a separate branch.  After that, in the same separate branch, the feature is tested by manual testers.  If all is well, the task falls into the release candidate.  If not, then we return to the development iteration, test it again.  Until the tester says that everything is OK in this feature, it will not get into the release candidate. <br><br>  After assembling the candidate release, there is a manual regression - not just Avto.ru, but only the package that we are going to roll.  For example, if we are going to roll the desktop web, then there is a manual regression of the desktop web.  This is a lot of test cases that are carried out manually.  Such a regression took about one working day per manual tester. <br><br>  When regression is completed, release occurs.  After this release branch merges into the master.  At this point, we can just infuse the master code, which we tested only for the desktop web, and this code can break the mobile web, for example.  This is not checked immediately, but only on the next manual regression - the mobile web. <br><br><img src="https://habrastorage.org/webt/uc/pp/f6/ucppf6mqcfn6rcjayzc7mzgzzwe.jpeg"><br><br>  Naturally, the most painful place in this process was manual regression, which took a very long time.  All manual testers are naturally tired of going through the same thing every day.  Therefore, we decided to automate everything.  The first solution that was executed was the autotest of Selenium and Java, written by a separate command.  These were the end-to-end tests, e2e, which tested the entire application.  They wrote about 5 thousand such tests.  What have we achieved in the end? <br><br>  Naturally, we accelerated regress.  Auto tests are much faster than a manual tester does, about 10 times faster.  Accordingly, routine testers that they performed every day were removed from manual testers.  Found bugs from auto tests easier to play.  Just restart this test or look at the steps, what it does - unlike the manual tester, who will say: ‚ÄúI clicked something, and everything broke.‚Äù <br><br>  Ensure the stability of the coating.  We always run the same run of tests - in contrast, again, from manual testing, when the tester may find that we did not touch this place, and I will not check it this time.  We added tests for comparison of screenshots, increased the accuracy of testing UI - now we check the discrepancy in a couple of pixels, which the tester will not see with his eyes.  All thanks to the screenshots. <br><br>  But there were also disadvantages.  The biggest one is that for e2e tests we need a test environment that fully complies with the products.  It must always be kept up to date and in working condition.  To do this, you need almost as much strength as to support stability of the sale.  Naturally, we can not always afford it.  Therefore, we often had situations where the test environment is lying or something is broken somewhere, and tests are falling - although there were no problems in the front-end package. <br><br>  Also, these tests are developed by a separate team, which has its own tasks, its own line in the task tracker, and new features are covered with some delay.  Immediately after the release of a new feature, they cannot come and immediately write autotests to it.  Since tests are expensive and difficult to write and maintain, we do not cover all the scenarios with them, but only the most critical ones.  At the same time, a separate team is needed, and it will have separate tools, a separate infrastructure, all its own.  And analyzing dropped tests is also not a trivial task for manual testers or for developers.  I will show a couple of examples. <br><br><img src="https://habrastorage.org/webt/gn/ix/c6/gnixc6p8h1phrdhcjlosttb0ai8.jpeg"><br><br>  We have run tests.  500 tests passed, some of them fell.  We can see such a thing in the report.  Here the test simply did not start, and it is not clear whether everything is good there or not. <br><br><img src="https://habrastorage.org/webt/40/70/6p/40706pwn5i1vfzfpl4ekmfhpeom.jpeg"><br><br>  Another example - the test was launched, but it fell with such an error.  He could not find any element on the page, but why - we do not know.  Either this element simply did not appear, either turned out to be on the wrong page, or the locator changed.  This is all you need to go and debug hands. <br><br><img src="https://habrastorage.org/webt/vh/_f/xd/vh_fxdrktlr3llkbrcloced22ks.jpeg"><br><br>  Screenshot tests also do not always give us good accuracy.  Here we load some kind of map, it moved a little bit, our test dropped. <br><br><img src="https://habrastorage.org/webt/_r/1y/dm/_r1ydm4pdscdlxgdse5focstyje.jpeg"><br><br>  We tried to solve a number of these problems.  We began to run part of the tests on products that do not touch the user data, do not change anything in the database.  That is, we have made a separate machine on the sale, which looks into the food environment.  We simply install a new frontend package and run tests there.  Prod is at least stable. <br><br>  We transferred part of the tests to moki, but we have a lot of different backends, different APIs, and it‚Äôs very difficult to fix all this, especially for 5 thousand tests.  For this, a special service called mockritsa was written, it helps quite easily make the necessary mocks for the frontend and it is quite easy to get proxied into them. <br><br>  We also had to buy a bunch of hardware so that our Selenium grid devices from which these tests are run were larger so that they did not fall because they could not lift the browser, and, accordingly, passed quickly.  Even after we tried to solve these problems, we still came to the conclusion that such tests are not suitable for CI, they go for a very long time.  We cannot run them on every pull request.  We simply never in our lives will then analyze these reports, which will be generated for each pool-request. <br><br><img src="https://habrastorage.org/webt/od/0z/rl/od0zrladzvsshl04e52vipgtcvo.jpeg"><br><br>  Accordingly, for CI we need fast and stable tests that will not fall for any random reasons.  We want to run tests on a pool-request without any test benches, backends, databases, without any complicated user cases. <br><br>  We want these tests to be written at the same time as the code, and according to the test results it was immediately clear which file went wrong. <br><br>  Alexey: <br>  - Yes, and we decided to try everything we want, right from the beginning to the end, to lift everything in the same infrastructure of Jest.  Why did we choose Jest?  We already wrote unit tests on Jest, we liked it.  This is a popular, supported tool, it already has a bunch of ready-made integrations there: React test render, Enzyme.  Everything works out of the box, do not build anything, everything is simple. <br><br><img src="https://habrastorage.org/webt/js/bo/sa/jsbosapwtytq_x6a8zkvxl6gdv0.jpeg"><br><br>  And for me personally, Jest won by the fact that, unlike some moki, it is difficult to shoot myself with a side effect from some third-party dough, if I forgot to clean it or something else.  In mock, this is done once or twice, but in Jest it is difficult to do: it is constantly running in separate threads.  It is possible, but difficult.  And for e2e Puppeteer was released, we also decided to try it.  That's what we did. <br><br><img src="https://habrastorage.org/webt/ab/ph/oa/abphoap_rzksxw_spwh4t_0nfra.jpeg"><br><br>  Natalia: <br>  - I will also start with an example of unit tests.  When we write tests just for some function, there are no special problems.  We call this function, pass some arguments, compare what happened with what should have happened. <br><br>  If we are talking about React-components, then everything becomes a little more complicated.  We need to render them somehow.  There is a React test renderer, but it is not very convenient for unit tests, because it will not allow us to test components in isolation.  It will render the component completely to the end, to the layout. <br><br>  And I want to show how using Enzyme to write unit tests for React-components on the example of such a component, where we have a certain MyComponent.  He gets some props, there is some logic in him.  Then it returns the Foo component, which, in turn, will return the bar component, which, in fact, returns the layout to the bar component. <br><br><img src="https://habrastorage.org/webt/h2/1e/e6/h21ee6qkeeucwkgnvye6ewsgxog.jpeg"><br><br>  We can use a tool from Enzyme like shallow rendering.  This is exactly what we need to test the MyComponent component in isolation.  And these tests will not depend on the fact that the components foo and bar inside will contain them.  We will simply test the logic of the MyComponent component. <br><br>  There is such a thing as a Snapshot in Jest, and they can help us here too.  ‚ÄúExpect something toMatchSnapshot‚Äù will create such a structure for us, just a text file, which actually stores what we passed to expect, what we get, and when you first run such tests, this file is written.  With further runs of tests, what is obtained will be compared with the standard contained in the file MyComponent.test.js.snap. <br><br>  Here we see just that the whole rendering, it returns exactly what the render method from MyComponent returns, and what foo is, to him, in general, do not care.  We can write these two tests for our two cases, for our two cases on the MyComponent component. <br><br><img src="https://habrastorage.org/webt/wu/b3/iw/wub3iwlwsatz7ytgzpeim8vsbqs.jpeg"><br><br>  In principle, we can test the same thing without a Snapshot, simply by checking the scripts we need, for example, checking which props are passed to the foo component.  But this approach has one drawback.  If we add some more element to MyComponent, our new test, it doesn‚Äôt display anything. <br><br><img src="https://habrastorage.org/webt/pd/9e/vy/pd9evyrhuh7kfzrqcukvwpbudaq.jpeg"><br><br>  Therefore, all the same, Snapshot tests are those that will show us practically any changes inside the component.  But if we write both tests on Snapshot, and then we make the same changes in the component, then we will see that both tests fall.  In principle, the results of these dropped tests will tell us about the same thing, that we have added some ‚Äúhello‚Äù there. <br><br><img src="https://habrastorage.org/webt/gv/c1/dc/gvc1dcwq9aw2m3owq6c-esulpsg.jpeg"><br><br>  And this is also redundant, therefore, I believe that it is better to use one Snapshot test for the same structure.  The rest of the logic to check something else, without a Snapshot, because Snapshot, they are not very revealing.  When you see a Snapshot, you simply see that something has been rendered, but it is not clear what kind of logic you are testing here.  This is completely inappropriate for TDD if you want to use it.  And do not go as documentation.  That is, then, when you go to look at this component, you will see that yes, the Snapshot corresponds to something, but what logic was there is not very clear. <br><br><img src="https://habrastorage.org/webt/wa/yc/ia/wayciagk2zoa51amkq8bb9xcqic.jpeg"><br><br><img src="https://habrastorage.org/webt/zk/mj/sa/zkmjsaoqa-34pqk2flku7_n7nsy.jpeg"><br><br>  In the same way, we will write unit tests on the foo component, on the bar component, say, Snapshot. <br><br><img src="https://habrastorage.org/webt/bg/eu/lk/bgeulklgkyqg-woog9tkqhkkpco.jpeg"><br><br>  We will get one hundred percent coverage for these three components.  We think that we have checked everything, we are great. <br><br>  But let's say we changed something in the bar component, added some new prop to it, and we dropped the test for the bar component, obviously.  We corrected the test, and we pass all three tests. <br><br><img src="https://habrastorage.org/webt/4i/pe/xc/4ipexciijx7ss998ugl84hr6smi.jpeg"><br><br>  But in fact, if we collect this whole story, then nothing will work, because MyComponent does not collect this error.  We do not, in fact, pass the prop that it expects to the bar component.  Therefore, we say that in this case we also need integration tests that will check, including whether we correctly call its child component from our component. <br><br><img src="https://habrastorage.org/webt/8e/aa/zk/8eaazkltwuurjeh7fhef39ovblq.jpeg"><br><br>  Having such components and changing one of them, you immediately see what the changes in this component have affected. <br><br>  What opportunities do we have in Enzyme to do integration testing?  Shallow rendering itself returns just such a structure.  It has a dive method, if it is called on some React component, it will fail in it.  Accordingly, by calling it on the foo component, we get what the foo component renders, bar, if we make a dive again, we will get, in fact, the layout that the bar component returns to us.  This will be an integration test. <br><br><img src="https://habrastorage.org/webt/oo/jm/af/oojmafj91rsbbpprnhyqf868qoy.jpeg"><br><br>  Or you can render everything at once using the mount method, which performs full DOM rendering.  But I do not advise doing this, because it will be a very heavy Snapshot.  And, as a rule, you do not need to check the entire structure.  You only need to check the integration between the parent and child components in each case. <br><br><img src="https://habrastorage.org/webt/q9/ud/i-/q9udi-03qar0hjqhxe6th8an6zc.jpeg"><br><br>  And for MyComponent, we add an integration test, so in the first test I add just dive, and it turns out that we tested not only the logic of the component itself, but also its integration with the foo component.  The same thing, we add the integration test for the foo component, that it correctly calls the bar component, and then we check the whole chain and be sure that no changes will break us, in fact, the rendering of MyComponent <br><br><img src="https://habrastorage.org/webt/ff/zu/fq/ffzufq_vcw5lmuygnztd0lycvao.jpeg"><br><br>  Another example, already from a real project.  Just briefly about what Jest and Enzyme can do.  Jest can moki.  You can, if you use some external function in your component, you can lock it.  For example, in this example we call some kind of api, we naturally don‚Äôt want to go into any api in modular tests, so we simply moka the geiResource function with a certain jest.fn object.  In fact, the IC function.  Then we can check whether it was called or not, how many times it was called, with which arguments.  This all allows you to do jest. <br><br><img src="https://habrastorage.org/webt/z8/lb/ap/z8lbapgq_qzer-1vz3yazx9wo-o.jpeg"><br><br>  In shallow-rendering, you can pass a store to a component.  If you need a store, you can simply transfer it there, and it will work. <br><br><img src="https://habrastorage.org/webt/y2/tl/ih/y2tlihjjqqwogsbftvcirxe_njc.jpeg"><br><br>  Also in the already rendered component, you can change the State and prop. <br><br><img src="https://habrastorage.org/webt/ew/8g/hc/ew8ghcc6gtv3347yt8ik6o9v6s4.jpeg"><br><br>  You can call the simulate method on some component.  It will simply call the handler.  For example, if you do simulate click, it will call onClick for the button component here.  All this can be read, of course, in the documentation for Enzyme, a lot of useful pieces.  These are just a few examples from a real project. <br><br><img src="https://habrastorage.org/webt/tw/kn/9t/twkn9txihstmq5pdpc9yqgc1nnw.jpeg"><br><br>  Alexey: <br>  - We come to the most interesting question.  We are able to check Jest, we can write unit tests, check components, check which elements react incorrectly to a click.  We are able to check their html.  Now we need to check the layout of the component, css. <br><br><img src="https://habrastorage.org/webt/fw/dj/8p/fwdj8pbfn6ywa4he7ejwjnq6hs4.jpeg"><br><br>  And it is desirable to do this so that the principle of testing does not differ in any way from the one I described earlier.  If I check html, then I called shallow rendering, it took me and rendered html.  I want to check css, just call some kind of render and just check - without lifting anything, without setting up any tools. <br><br><img src="https://habrastorage.org/webt/mz/u-/p2/mzu-p2y3eiblryntol0eelzghtc.jpeg"><br><br>  I began to look for it, and about the same answer was given everywhere to all this piece, which is called Puppeteer, or Selenium grid.  You open some tab, you go to some page html, take a screenshot and compare it with the previous version.  If not changed, then all is well. <br><br>  The question is, what is page html if I just want to check one component in isolation?  Desirable - in different states. <br><br><img src="https://habrastorage.org/webt/w2/t0/vn/w2t0vni_fdskrtopftgiigmxows.jpeg"><br><h5>  <sup><sub><a href="https://habr.com/ru/company/avito/blog/350604/">Link from the slide</a></sub></sup> </h5><br>  I do not want to write a bunch of these page html for each component, for each state.  Avito has a good run.  Roma Dvornov published an article on Habr√©, and, by the way, he had a speech.  What did they do?  They take components, through a standard render collect html.  Then with the help of plug-ins and all sorts of tricks they collect all the assets that they have - pictures, css.  They put it all in html, and they just get the right html. <br><br><img src="https://habrastorage.org/webt/0j/yr/zk/0jyrzkzvwzebsx36hos2vvi1uvs.jpeg"><br><h5>  <sup><sub><a href="https://habr.com/ru/company/avito/blog/350604/">Link from the slide</a></sub></sup> </h5><br>  And then they raised a special server, send html there, it renders it, and returns some result.  Very interesting article, read, however, you can draw a lot of interesting ideas from there. <br><br><img src="https://habrastorage.org/webt/z5/xp/gb/z5xpgbasgyr6gooqi_dt-p4_mxw.jpeg"><br><br>  What I don't like there.  Component assembly is different from how it goes to production.  We have, for example, a webpack, and some babel assets are going there, it is pulled out differently.  I can not guarantee that I have tested what I am about to shake. <br><br>  And again, a separate service for screenshots.  I want to do something simpler.  And there was, in fact, the idea that, let us collect it exactly the same way as we collect it.  And we will try to use something like Docker, because it is such a thing, it can be put on the computer, locally, it will be simple, isolated, nothing touches, everything is fine. <br><br><img src="https://habrastorage.org/webt/9k/nz/hm/9knzhmk3-qivjt6peujxtmjnovw.jpeg"><br><br>  But this problem with page html, it remains all the same, what it is, in fact.  And the idea was born.  You have such a simplified webpack.conf, and it has some EntryPoint for client js.  The modules are described, how to build them, the output file, all the plugins you have described, everything is set up, everything is fine. <br><br><img src="https://habrastorage.org/webt/3f/km/ha/3fkmhal86lf6s38oq8rnnhchsdg.jpeg"><br><br>  And what if I do like this?  It will go to my component and assemble it in isolation.  And there will be exactly one component.  If I add another html webpack there, then it will give me an output also html, and these assets will be collected there, and this thing, however, can already be tested automatically. <br><br>  And I was about to write all this, but then I found this. <br><br><img src="https://habrastorage.org/webt/hq/ju/0s/hqju0sbemjp1z3ryufas0pk0tfu.jpeg"><br><br>  Jest-puppeteer-React, a young plugin.  And I started actively contributing to it.  If you suddenly want to try it, you can, for example, come to me, I somehow can help.  The project is not really mine. <br><br>  You write a regular file as test.js, and these files need to be written a little separately to help them find, so as not to compile the entire project for you, but to compile only the necessary components.  In fact, you take a webpack config.  And the input points change to these browser.js files, that is, in this way, exactly what we want to test is going to, pack everything in html, and with the help of Puppeteer it will give you screenshots. <br><br><img src="https://habrastorage.org/webt/3e/jh/fr/3ejhfrfte3ucybs-vvl6ncw28vo.jpeg"><br><br>  What does he do?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">He can take screenshots, he can save them using another jest-image-snapshot plugin. </font><font style="vertical-align: inherit;">And can compare them. </font><font style="vertical-align: inherit;">You can do everything in it that you can do in a browser, execute js, you can test media-query, for example, right away. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you don‚Äôt like the headless mode, it‚Äôs difficult there, we can‚Äôt debug, we don‚Äôt understand what the problem is, turn off the headless mode and you‚Äôll see the usual Chrome with a regular debager. </font><font style="vertical-align: inherit;">An ordinary web console, and you sit right there, debug, you understand what is wrong.</font></font><br><br>       Docker.          .  .  ,  Docker,  .   .  Docker     ,         , ,     Linux,   -   ,      -  .  Docker   ,            . <br><br><img src="https://habrastorage.org/webt/gt/26/zc/gt26zcwy-madcquchbm37l89lwo.jpeg"><br><br>      ?   ,       . ,  .    before-after,     ,  .   ,    .   ,         Chrome,       Firefox.    . <br><br>       .    pixelmatch.  ,   looksame,    ¬´¬ª,    .   ,         . <br><br><img src="https://habrastorage.org/webt/ep/zg/ov/epzgovfoqseh2bj5r7jcr8z0lr0.jpeg"><br><br>  ‚Äî   .   ,  ,     .  ,    :    - ,             ‚Äî    Enzyme.      Redux   store .  .    viewport,  ,      .   , ,     . <br><br><img src="https://habrastorage.org/webt/ln/wh/qu/lnwhqusfy-4mqef59zw0lmnoaus.jpeg"><br><br>      .  ,   .  ?     ,     . <br><br><img src="https://habrastorage.org/webt/ut/l6/xb/utl6xb7objmhjnhozdlamgwzjyk.jpeg"><br><br>   :       5-10        . Selenium    .    ,  , ,           .        . <br><br><img src="https://habrastorage.org/webt/md/qr/rf/mdqrrf6ueg73uu25m6wqfihyo3q.jpeg"><br><br>      Puppeteer,    e2e-.      ,          e2e- ‚Äî   ,    Selenium. <br><br> : <br> ‚Äî ,         Selenium Java ,    .     - JS   Puppeteer,    ,         . <br><br>     ,       .     ,           ,    . <br><br><img src="https://habrastorage.org/webt/0s/7u/ns/0s7uns7oaxi3dcwuejuhk5kwuoy.jpeg"><br><br>   ‚Äî  Selenium  Java,   ‚Äî  JS Puppeteer.   .   18  .          ,   ,    Java.  ,           ,       Java  Selenium. <br><br><img src="https://habrastorage.org/webt/kk/us/pj/kkuspjg5dwwz6h2tuhkwfkssth0.jpeg"><br><br> : <br> ‚Äî     ?       .    , html-,    css   .   e2e. .  ,       . <br><br><img src="https://habrastorage.org/webt/sj/wg/58/sjwg58se3lov3vvrskvjjh2pw90.jpeg"><br><br>     ,    ,  .        . ,   , ‚Äî  , .        ,     . -    , ,      :     ,     . <br><br>   ,         ,     .     git hook,  -,      .    green master ‚Äî   ,   ,  ,      .  Thank. </div><p>Source: <a href="https://habr.com/ru/post/459924/">https://habr.com/ru/post/459924/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45991/index.html">Lenovo will implement theft protection, remote shutdown by one SMS</a></li>
<li><a href="../459910/index.html">Situation: companies are not in a hurry to develop services for voice assistants - what are the risks</a></li>
<li><a href="../459914/index.html">SQL Index Manager is a free tool for defragmenting and maintaining indexes.</a></li>
<li><a href="../459918/index.html">Solution of the task with pwnable.kr 03 - bof. Stack buffer overflow</a></li>
<li><a href="../45992/index.html">Power over Ethernet technology</a></li>
<li><a href="../459928/index.html">The student's path to developing mobile applications</a></li>
<li><a href="../45993/index.html">Nokia N97: New Smartphone Company with Touchscreen and Sliding QWERTY Keyboard</a></li>
<li><a href="../459930/index.html">Automate imports to Python</a></li>
<li><a href="../459934/index.html">The digest of interesting materials for the mobile developer # 306 (July 8 - 14)</a></li>
<li><a href="../459936/index.html">9 more tricks to work with Visual Studio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>