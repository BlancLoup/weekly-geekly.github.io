<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>High-quality image reduction in constant time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I want to share a very simple and effective method for resizing an image that works in constant time relative to the size of the original image and gi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>High-quality image reduction in constant time</h1><div class="post__text post__text-html js-mediator-article"><p>  I want to share a very simple and effective method for resizing an image that works in constant time relative to the size of the original image and gives an unexpectedly high-quality result.  The method is applicable for all languages ‚Äã‚Äãand applications. </p><br><p>  To begin, let's reason logically.  If you resize the image, you probably want the result to even remotely resemble the original.  To do this, take into account as much information as possible from the original image.  Have you heard of the ‚Äúnearest neighbor‚Äù method?  In this method, for each point of the final image, just one point of the original image is taken in an unchanged form. </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd6a1208a409488648.png"><br>  <em>Reducing the image to 4928 √ó 3280 to 256 √ó 170 nearest neighbor.</em> </p><br><blockquote>  I recommend to watch examples from the article in the browser on a scale of 100% and without retina.  That is, to the maximum exclude resize when viewing. </blockquote><p>  The result is no good.  The image is jerky, grainy, it is even difficult to understand what is depicted on it.  Especially if the original image had many small details, or it was itself grainy.  Why is this so?  Because in the final image was taken into account very little information from the source.  If we conditionally mark on the source image those points that fall into the final one, we get the following grid: <br></p><br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd8900be5616103973.png"><br>  <em>Points that fall into the final image size of 20 √ó 13.</em> <br><a name="habracut"></a><br><p>  Now you can visually assess how little information about the original image falls into the final one.  Agree, it is unlikely that it is for this grid will be located pixels, which will give a good idea of ‚Äã‚Äãthe image on the original image. </p><br><p>  A completely different result is, for example, resizing using convolutions.  In it, each pixel of the original image contributes to the final, and more than once.  Therefore, the image is smooth, and when choosing a good filter, clear. </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd834ca4a495104240.png"><br>  <em>Reduction from 4928 √ó 3280 to 256 √ó 170 convolutions with a bicubic filter.</em> </p><br><p>  Nevertheless, the ‚Äúnearest neighbor‚Äù method has one indisputable advantage: it works in constant time relative to the size of the original image.  This means that no matter how large or small the original image was, the time to decrease to a certain size will be the same.  I will give examples on Python with the <a href="https://pillow.readthedocs.io/">Pillow</a> library, but you can get almost the same result with any language and libraries. </p><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; im = Image.open(<span class="hljs-string"><span class="hljs-string">'pineapple.jpeg'</span></span>); im.load(); im.size (<span class="hljs-number"><span class="hljs-number">2560</span></span>, <span class="hljs-number"><span class="hljs-number">1600</span></span>) &gt;&gt;&gt; %time im.resize((<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">170</span></span>), Image.NEAREST) Wall time: <span class="hljs-number"><span class="hljs-number">0.35</span></span> ms &gt;&gt;&gt; im = Image.open(<span class="hljs-string"><span class="hljs-string">'space.jpeg'</span></span>); im.load(); im.size (<span class="hljs-number"><span class="hljs-number">4928</span></span>, <span class="hljs-number"><span class="hljs-number">3280</span></span>) &gt;&gt;&gt; %time im.resize((<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">170</span></span>), Image.NEAREST) Wall time: <span class="hljs-number"><span class="hljs-number">0.44</span></span> ms</code> </pre> <br><blockquote>  In reality, the time is not quite constant, since various factors like processor caches and data locality interfere, but even for 4 times the larger source image, we received a slowdown of only 23%. </blockquote><p>  The speed of convolutions, on the contrary, decreases linearly with an increase in the original image. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; im = Image.open(<span class="hljs-string"><span class="hljs-string">'pineapple.jpeg'</span></span>); im.load(); im.size (<span class="hljs-number"><span class="hljs-number">2560</span></span>, <span class="hljs-number"><span class="hljs-number">1600</span></span>) &gt;&gt;&gt; %time im.resize((<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">170</span></span>), Image.BICUBIC) Wall time: <span class="hljs-number"><span class="hljs-number">33.2</span></span> ms &gt;&gt;&gt; im = Image.open(<span class="hljs-string"><span class="hljs-string">'space.jpeg'</span></span>); im.load(); im.size (<span class="hljs-number"><span class="hljs-number">4928</span></span>, <span class="hljs-number"><span class="hljs-number">3280</span></span>) &gt;&gt;&gt; %time im.resize((<span class="hljs-number"><span class="hljs-number">256</span></span>, <span class="hljs-number"><span class="hljs-number">170</span></span>), Image.BICUBIC) Wall time: <span class="hljs-number"><span class="hljs-number">130</span></span> ms</code> </pre> <br><p>  For 4 times larger original image, time also increased by 4 times. </p><br><h2 id="fiksirovannoe-yadro">  Fixed core </h2><br><p>  Some applications and libraries for working with graphics use this trick: they sort of use the same filters for resizing as resize convolutions (there are, for example, bilinear, bicubic and Lanczosh filter), but when reducing the image, they do not increase the filter core adaptively.  As a result, to build any point of the final image, only 4 pixels of the original image are used with a bilinear filter, with a bicubic one - 16, with a 3-frontal Lanczos filter - 36. That is, the running time is also constant relative to the original size. </p><br><p>  But this approach only works to reduce about 2 times, and then the result is not much different from the ‚Äúnearest neighbor‚Äù. </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd87cd801901985474.png"><br>  <em>From 4928 √ó 3280 to 256 √ó 170 with a bilinear filter with a fixed core.</em> </p><br><p>  And saying "not much different from the" nearest neighbor "," I mean not only that it is also ragged and grainy, I mean that it almost coincides with the result of the "nearest neighbor."  Open both pictures in the adjacent tabs of the browser and switch between them, the pictures are almost the same.  It may even seem that there is an error somewhere, that this should not be so, because with a fixed core 4 pixels are interpolated, and the first one that comes across is not stupid, and the result should be closer to the original.  But there is no error, and here's why: </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd884990c879799521.png"><br>  <em>Points that will be interpolated when decreasing to 20 √ó 13.</em> </p><br><p>  These are the points of the original image, on which the final is built.  There are 4 times more of them, but they are all located in the same places as in the method of the nearest neighbor.  That is, most likely, we will not receive new information about the image.  You can try to further increase the number of points of the original image involved in the process by applying a bicubic filter, but the result will again be almost the same and even <em>slightly more ragged</em> , because the extreme pixels in the bicubic filter are taken with negative coefficients. </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd879d1a6019573744.png"><br>  <em>From 4928 √ó 3280 to 256 √ó 170 with a bicubic filter with a fixed core.</em> </p><br><p>  As it is not difficult to guess, the complexity and execution time when using filters with large coverage increases significantly, while the final image almost does not change.  All three of the following examples give approximately the same picture, but their work time differs up to 20 times. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>im = Image.open(<span class="hljs-string"><span class="hljs-string">'space.jpeg'</span></span>); im.load(); im.size (<span class="hljs-number"><span class="hljs-number">4928</span></span>, <span class="hljs-number"><span class="hljs-number">3280</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   &gt;&gt;&gt; %time im.resize((256, 170), Image.NEAREST) Wall time: 0.441 ms #    &gt;&gt;&gt; %time im.transform((256, 170), Image.AFFINE, (im.width / 256, 0, 0, 0, im.height / 170, 0), Image.BILINEAR) Wall time: 3.62 ms #    &gt;&gt;&gt; %time im.transform((256, 170), Image.AFFINE, (im.width / 256, 0, 0, 0, im.height / 170, 0), Image.BICUBIC) Wall time: 9.21 ms</span></span></code> </pre> <br><p>  Here I simulated a resize with a fixed core using affine transformations.  But some applications and libraries really do this: they use more expensive filters to reduce, the result of which is almost equal to the nearest neighbor method.  So does OpenCV, so do <a href="https://habrahabr.ru/post/252175/">browsers when they draw an image on the canvas</a> , so do video cards when texturing without mip levels.  Because even though time is more, it is constant relative to the resolution of the original image.  What about quality?  For quality, there are convolutions. </p><br><h2 id="kak-ispravit">  How to fix </h2><br><p>  You probably think why I‚Äôm telling you all this, it‚Äôs still clear: if speed is needed, you need to take a ‚Äúneighbor‚Äù or a fixed core, if the quality is convolution.  But the fact is that, it turns out, a decrease with a fixed core can be corrected so that its result will be radically better.  So much better that it is possible for your problems, this will be enough and no convolutions will be needed.  Moreover, the complexity will not just be a constant relative to the size of the original image, it will be <em>the same constant</em> as when using a fixed core. </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd85108e9097019074.png"><br>  <em>The resize result is 4928 √ó 3280 to 256 √ó 170 for constant time.</em> </p><br><p>  As you can see, the result of this algorithm cannot be compared with the multi-colored dumbness obtained after the ‚Äúnearest neighbor‚Äù or a fixed core.  For the examples for this article, I deliberately took a rather large picture with a fine grid, with lots of details (look at the astronaut's reflection in the helmet) and reduce it very much.  I did my best to get as many artifacts as possible, but the algorithm still copes!  When I first learned about this method from <a href="https://habrahabr.ru/users/random1st/" class="user_link">random1st</a> , I thought that the method most likely gives only a slight improvement over the fixed core, because the number of pixels involved is the same.  But the result greatly exceeded my expectations. </p><br><p>  The secret is to take for processing not the points that are missed by 4 pieces, as with a fixed core, but to use a uniform grid with 2 times higher resolution than it should be in the end.  And from it already interpolate the final image. </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd8867080049343232.png"><br>  <em>Points to be used when decreasing to 20 √ó 13.</em> </p><br><p>  As you can see, quite a few points of the original image are still taken.  But because they are evenly distributed, they are more representative.  And due to the fact that they are exactly 4 times larger, they all make the same contribution to the final image. </p><br><p>  And now the most interesting thing: to use this method, you do not need to program anything!  All you need you already have.  The first step is to make a uniform grid of pixels of 2 times higher resolution using the ‚Äúnearest neighbor‚Äù method, and at the second step you can compress it by 2 times at least a fixed filter, even with convolutions, even a box-filter (depending on what is in your library).  The only thing for bundles, I would advise to take a Hamming filter or bicubic, but not bilinear. </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>im = Image.open(<span class="hljs-string"><span class="hljs-string">'space.jpeg'</span></span>); im.load(); im.size (<span class="hljs-number"><span class="hljs-number">4928</span></span>, <span class="hljs-number"><span class="hljs-number">3280</span></span>) <span class="hljs-comment"><span class="hljs-comment">#      &gt;&gt;&gt; %time im.resize((512, 340), Image.NEAREST)\ .transform((256, 170), Image.AFFINE, (2, 0, 0, 0, 2, 0), Image.BILINEAR) Wall time: 3.59 ms #       &gt;&gt;&gt; %time im.resize((512, 340), Image.NEAREST)\ .resize((256, 170), Image.HAMMING) Wall time: 2.42 ms #       &gt;&gt;&gt; %time im.resize((512, 340), Image.NEAREST)\ .resize((256, 170), Image.BICUBIC) Wall time: 3.53 ms #   - #    ,    OpenCV #      INTER_NEAREST # . https://github.com/opencv/opencv/issues/9096 &gt;&gt;&gt; import cv2 &gt;&gt;&gt; im = cv2.imread('space.jpeg') &gt;&gt;&gt; %time cv2.resize(cv2.resize(im, (512, 340), interpolation=cv2.INTER_NEAREST), (256, 170), interpolation=cv2.INTER_AREA) Wall time: 0.81 ms</span></span></code> </pre> <br><h2 id="dalneyshee-razvitie-idei">  Further development of the idea </h2><br><p>  This improvement is impressive, but you can not stop there.  Who said that to build you need to use exactly 2 times larger image?  Why not take 3 times or 4 for better quality.  However, it will be impossible to use a resize with a fixed core for the second step, because the same problems that we are trying to get rid of will come out.  But convolutions - please.  In this case, the time will remain constant, just the constant will be more. </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd81aad91396379577.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd824b89f020629552.png"><br>  <em>Resize from 4928 √ó 3280 to 256 √ó 170 using 2x and 4x intermediate images.</em> </p><br><p>  Perhaps on this scale the differences are not very visible, but they are quite strong.  To see them, look at the gif with a zoom: </p><br><p><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd87e14f1497764055.gif"></p><br><p>  Well, time: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>im = Image.open(<span class="hljs-string"><span class="hljs-string">'space.jpeg'</span></span>); im.load(); im.size (<span class="hljs-number"><span class="hljs-number">4928</span></span>, <span class="hljs-number"><span class="hljs-number">3280</span></span>) <span class="hljs-comment"><span class="hljs-comment">#   2x   &gt;&gt;&gt; %time im.resize((512, 340), Image.NEAREST)\ .resize((256, 170), Image.BICUBIC) Wall time: 3.53 ms #   3x   &gt;&gt;&gt; %time im.resize((768, 510), Image.NEAREST)\ .resize((256, 170), Image.BICUBIC) Wall time: 6.27 ms #   4x   &gt;&gt;&gt; %time im.resize((1024, 680), Image.NEAREST)\ .resize((256, 170), Image.BICUBIC) Wall time: 9.23 ms</span></span></code> </pre> <br><p>  As you can see, the version with 2x intermediate image works for a time approximately equal to the bilinear filter with a fixed core, and the version with 4x intermediate image during bicubic time.  Well, generally speaking, you can use not a whole number of points. </p><br><h3 id="kak-sdelat-pravilnyy-vybor">  How to make the right choice </h3><br><p>  The question arises: if this method gives such best results and works at the speed of a fixed core, why bother to use a fixed core to reduce it?  Of course, this method has a field of applicability - it is better not to use it with a decrease of <em>less than 2 times</em> .  And this coincides with the limit of applicability of a fixed core, which is better not to use with a decrease of <em>more than 2 times</em> .  It turns out, by combining methods, it is possible to obtain a resize of acceptable quality for a fixed time at any scale. </p><br><h3 id="vazhnoe-dopolnenie">  Important addition </h3><br><p>  <a href="https://habrahabr.ru/users/vintage/" class="user_link">Vintage</a> comments correctly indicate that this method is correctly called supersampling.  Supersampling is often used in games to eliminate aliasing.  In essence, the game scene is an image of infinite resolution, because we could draw it in any resolution.  For supersampling, the scene is drawn at a higher resolution than necessary and several neighboring pixels are averaged over one.  That is a complete analogy.  But this does not negate the fact that such a method is very rarely used in software despite its merits. </p><br><h3 id="primery">  Examples </h3><br><p>  And finally, a few examples with other images.  From left to right: <br>  1) fixed core, bilinear filter (what many are using now) <br>  2) bicubic convolutions as a reference <br>  3) supersampling with 2x magnification <br>  4) supersampling with 4x magnification </p><br><p>  The main thing when viewing is to remember that the third image is generated at exactly the same time as the first one, and the fourth one even ‚âà3 times longer, but also for a constant time and often up to 20 times faster than the second one. </p><br><p>  Once again, an example from the article.  <a href="https://unsplash.com/photos/OLlj17tUZnU">The image is 4928 √ó 3280</a> reduced by 19.25 times. <br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd849a258762739775.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd834ca4a495104240.png"><br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd81aad91396379577.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd824b89f020629552.png"></p><br><p>  The same picture, but this time reduced from 600 √ó 399, that is 2.34 times. <br>  Such a small decrease is a more difficult case for this method. <br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd837ab6d034431985.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd822a86d629265308.png"><br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd858f8b2230735305.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd8658568986605702.png"></p><br><p>  <a href="https://unsplash.com/photos/t-W4_309hi8">Image 2560 √ó 1600</a> reduced by 10 times. <br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd8391e0f598172203.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd8281363965464165.png"><br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd855d930793270820.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd86a94ef747969568.png"></p><br><p>  <a href="https://unsplash.com/photos/vXpcpTl2Tt4">Image 4000 √ó 2667</a> reduced 15.625 times. <br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd840162c583142648.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd82bd07f113376198.png"><br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd85d3620433982157.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd86efd4d532845063.png"></p><br><p>  The image is 2448 √ó 3264 reduced 9.5625 times. <br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd8438ed3378078530.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd82f1306790148805.png"><br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd85ecbdb817188795.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd8707c80083918241.png"></p><br><p>  <a href="">Image 2000 √ó 2000</a> reduced by 7.8125 times. <br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd850813c315814858.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd830f99a176923187.png"><br><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd867748a588612837.png"><img src="https://habrastorage.org/webt/59/f0/bd/59f0bd8741b89062741604.png"></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/340966/">https://habr.com/ru/post/340966/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340956/index.html">Requirements analysis</a></li>
<li><a href="../340958/index.html">How to apply neurotechnology in practice: hakaton Neuromedia-2017</a></li>
<li><a href="../340960/index.html">IdM implementation. Part 2. How to determine what is worth thinking about the implementation of IdM?</a></li>
<li><a href="../340962/index.html">Lenovo solutions for data centers. Part 2</a></li>
<li><a href="../340964/index.html">Perfect shuffle</a></li>
<li><a href="../340968/index.html">Window shop in Vivaldi 1.13.997.3</a></li>
<li><a href="../340972/index.html">10 most simple and frequent mistakes on sites</a></li>
<li><a href="../340974/index.html">Student supercomputer competitions: instructions for use</a></li>
<li><a href="../340976/index.html">Photo storage and upload architecture in Badoo</a></li>
<li><a href="../340978/index.html">PostgreSQL Indexes - 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>