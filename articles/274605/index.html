<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Low-level optimization of parallel algorithms or SIMD in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Currently, a huge number of tasks require high system performance. Infinitely increasing the number of transistors on a processor chip does not allow ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Low-level optimization of parallel algorithms or SIMD in .NET</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/126/dc5/05f/126dc505fe9cec9e24c6f5f80e5dcc02.jpg" alt="image"><br><br>  Currently, a huge number of tasks require high system performance.  Infinitely increasing the number of transistors on a processor chip does not allow physical limitations.  The geometrical dimensions of transistors cannot be physically reduced, since when the permissible dimensions are exceeded, phenomena that are not noticeable with large sizes of active elements begin to manifest themselves - quantum size effects begin to have a strong effect.  Transistors do not start working as transistors. <br>  And Moore's law has nothing to do with it.  This was and remains the law of value, and an increase in the number of transistors on a chip is rather a consequence of the law.  Thus, in order to increase the power of computer systems we have to look for other ways.  This is the use of multiprocessors, multicomputers.  This approach is characterized by a large number of processor elements, which leads to independent execution of subtasks on each computing device. <br><a name="habracut"></a><br><br><h3>  Parallel processing methods: </h3><table><tbody><tr><th>  Source of concurrency </th><th>  Acceleration </th><th>  Programmer effort </th><th>  Popularity </th></tr><tr><td>  Many cores </td><td>  2x-128x </td><td>  Moderate </td><td>  High </td></tr><tr><td>  Many cars </td><td>  1x-Infinity </td><td>  Moderately high </td><td>  High </td></tr><tr><td>  Vectorization </td><td>  2x-8x </td><td>  Moderate </td><td>  Low </td></tr><tr><td>  Graphics cards </td><td>  128x-2048x </td><td>  High </td><td>  Low </td></tr><tr><td>  Coprocessor </td><td>  40x-80x </td><td>  Moderately high </td><td>  Extremely low </td></tr></tbody></table><br>  There are many ways to improve the efficiency of systems and they are all quite different.  One of such methods is the use of vector processors, which significantly increase the speed of calculations.  Unlike scalar processors that process one data element per instruction (SISD), vector processors are capable of processing several data elements (SIMD) per instruction.  Most modern processors are scalar.  But many of the tasks that they solve require a large amount of computation: video processing, sound processing, work with graphics, scientific calculations, and much more.  To speed up the computation process, processor manufacturers began to build additional streaming SIMD extensions into their devices. <br>  Accordingly, with a certain programming approach, it became possible to use vector data processing in the processor.  Existing extensions: MMX, SSE and AVX.  They allow you to use additional features of the processor for accelerated processing of large data arrays.  At the same time, vectorization allows to achieve acceleration without explicit parallelism.  Those.  it is from the point of view of data processing, but from the point of view of the programmer, this does not require any development costs of special algorithms to prevent race or synchronization, and the development style is no different from synchronous.  We get accelerated effortlessly, almost completely free.  And there is no magic in it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  What is SSE? </h3><br>  SSE (English Streaming SIMD Extensions, streaming SIMD processor expansion) is SIMD (English Single Instruction, Multiple Data, One Instruction - Multiple Data) set of instructions.  SSE includes eight 128-bit registers and a set of instructions in the processor architecture.  SSE technology was first introduced in the Pentium III in 1999.  Over time, this set of instructions has been improved by adding more complex operations.  Eight (in x86-64 - sixteen) 128-bit registers were added to the processor: from xmm0 to xmm7. <br><img src="https://habrastorage.org/getpro/habr/post_images/76b/2a7/d96/76b2a7d96ef0f4648e4fcebd98e7f716.png" alt="image"><br>  Initially, these registers could only be used for single-precision calculations (i.e., for the type float).  But after the release of SSE2, these registers can be used for any primitive data type.  Given a standard 32-bit machine in this way, we can store and process in parallel: <br><ul><li>  2 double </li><li>  2 long </li><li>  4 float </li><li>  4 int </li><li>  8 short </li><li>  16 char </li></ul><br>  If you use the AVX technology, then you will manipulate already 256-bit registers, respectively, more numbers for a single instruction.  So there are already 512-bit registers. <br><img src="https://habrastorage.org/getpro/habr/post_images/bcc/54c/7ca/bcc54c7ca27096de07d326460b4941f3.jpg" alt="image"><br>  First, using the example of C ++ (who is not interested, you can skip), we will write a program that will summarize two arrays of 8 float elements. <br><br><h3>  An example of vectorization in C ++ </h3><br>  The SSE technology in C ++ is implemented by low-level instructions, presented in the form of pseudo-code, which reflect assembler commands.  So, for example, the command <i>__m128 _mm_add_ps (__ m128 a, __m128 b);</i>  converted to assembler instruction <i>ADDPS operand1, operand2</i> .  Accordingly, the command <i>__m128 _mm_add_ss (__ m128 a, __m128 b);</i>  will be converted to an <i>ADDSS</i> instruction <i>operand1, operand2</i> .  The two teams do almost the same operations: they stack the elements of the array, but in slightly different ways.  <i>_mm_add_ps</i> adds the entire register to the register, so that: <br><ul><li>  r0: = a0 + b0 </li><li>  r1: = a1 + b1 </li><li>  r2: = a2 + b2 </li><li>  r3: = a3 + b3 </li></ul><br>  In this case, the entire register __m128 is the set r0-r3.  But the <i>_mm_add_ss</i> command adds only a part of the register, so: <br><ul><li>  r0: = a0 + b0 </li><li>  r1: = a1 </li><li>  r2: = a2 </li><li>  r3: = a3 </li></ul><br>  By the same principle, other commands are arranged, such as subtraction, division, square root, minimum, maximum, and other operations. <br>  For writing a program, you can manipulate 128-bit registers of the type __m128 for float, __m128d for double and __m128i for int, short, char.  In this case, you can not use arrays of the type __m128, but use the reduced pointers of the array float of type __m128 *. <br>  Thus it is necessary to consider several working conditions: <br><ul><li>  Float data loaded and stored in an __m128 object must have 16-byte alignment </li><li>  Some built-in functions require that their argument be of constant type, because of the nature of the instruction </li><li>  The result of arithmetic operations acting on two NAN arguments is not defined. </li></ul><br>  Such a small excursion into the theory.  However, consider an example program using SSE: <br><pre><code class="hljs mel">#include <span class="hljs-string"><span class="hljs-string">"iostream"</span></span> #include <span class="hljs-string"><span class="hljs-string">"xmmintrin.h"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main() { const auto N = <span class="hljs-number"><span class="hljs-number">8</span></span>; alignas(<span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a[] = { <span class="hljs-number"><span class="hljs-number">41982.0</span></span>, <span class="hljs-number"><span class="hljs-number">81.5091</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">42.666</span></span>, <span class="hljs-number"><span class="hljs-number">54776.45</span></span>, <span class="hljs-number"><span class="hljs-number">342.4556</span></span>, <span class="hljs-number"><span class="hljs-number">6756.2344</span></span>, <span class="hljs-number"><span class="hljs-number">4563.789</span></span> }; alignas(<span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b[] = { <span class="hljs-number"><span class="hljs-number">85989.111</span></span>, <span class="hljs-number"><span class="hljs-number">156.5091</span></span>, <span class="hljs-number"><span class="hljs-number">3.14</span></span>, <span class="hljs-number"><span class="hljs-number">42.666</span></span>, <span class="hljs-number"><span class="hljs-number">1006.45</span></span>, <span class="hljs-number"><span class="hljs-number">9999.4546</span></span>, <span class="hljs-number"><span class="hljs-number">0.2344</span></span>, <span class="hljs-number"><span class="hljs-number">7893.789</span></span> }; __m128* a_simd = reinterpret_cast&lt;__m128*&gt;(a); __m128* b_simd = reinterpret_cast&lt;__m128*&gt;(b); auto <span class="hljs-keyword"><span class="hljs-keyword">size</span></span> = sizeof(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>); void *ptr = _aligned_malloc(N * <span class="hljs-keyword"><span class="hljs-keyword">size</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>* c = reinterpret_cast&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>*&gt;(ptr); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N/<span class="hljs-number"><span class="hljs-number">2</span></span>; i++, a_simd++, b_simd++, c += <span class="hljs-number"><span class="hljs-number">4</span></span>) _mm_store_ps(c, _mm_add_ps(*a_simd, *b_simd)); c -= N; std::cout.precision(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) std::cout &lt;&lt; c[i] &lt;&lt; std::endl; _aligned_free(ptr); <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>(<span class="hljs-string"><span class="hljs-string">"PAUSE"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><ul><li>  <i>alignas (#)</i> is the standard for C ++ portable way of specifying custom alignment of variables and custom types.  Used in C ++ 11 and supported by Visual Studio 2015. You can use another option - <i>__ declspec (align (#)) declarator</i> .  These tools to control alignment with static memory allocation.  If alignment with dynamic selection is necessary, you must use <i>void * _aligned_malloc (size_t size, size_t alignment);</i> </li><li>  Then we convert the pointer to the array a and b to the type _m128 * using reinterpret_cast, which allows you to convert any pointer to a pointer of any other type. <br></li><li>  After that we dynamically allocate the leveled memory using the <i>_aligned_malloc</i> function already mentioned above <i>(N * sizeof (float), 16);</i> </li><li>  The number of necessary bytes is selected based on the number of elements, taking into account the type dimension, and 16 is the alignment value, which should be a power of two.  And then we bring the pointer to this memory location to another pointer type, so that we can work with it taking into account the type of float as an array. <br></li></ul><br>  Thus, all preparations for the SSE work are made.  Further in the cycle, we summarize the elements of the arrays.  The approach is based on pointer arithmetic.  Since <i>a_simd</i> , <i>b_simd,</i> and <i>c</i> are pointers, increasing them leads to a shift to sizeof (T) from memory.  If we take, for example, a dynamic array <i>with</i> , then <i>with [0]</i> and <i>* with</i> show the same value, since  <i>c</i> points to the first element of the array.  Incrementing <i>with</i> will move the pointer 4 bytes forward and now the pointer will point to 2 elements of the array.  This way you can move back and forth along the array by increasing and decreasing the pointer.  But at the same time, the dimension of the array should be taken into account, since it is easy to go beyond its limits and refer to someone else's memory.  Working with the <i>a_simd</i> and <i>b_simd pointers is</i> similar, only the increment of the pointer will lead to a 128-bit forward and, from the point of view of the float type, 4 variables of the array a and b will be skipped.  In principle, the pointer <i>a_simd</i> and <i>a</i> , like <i>b_simd</i> and <i>b</i> , respectively point to one section in memory, except for the fact that they are processed differently taking into account the pointer type dimension: <br><img src="http://s011.radikal.ru/i315/1601/c0/44446e55cc77.jpg" alt="image"><br><br><pre> <code class="hljs matlab"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; N/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++, a_simd++, b_simd++, c += <span class="hljs-number"><span class="hljs-number">4</span></span>) _mm_store_ps(c, _mm_add_ps(*a_simd, *b_simd));</code> </pre><br>  Now I understand why in this cycle such pointer changes.  At each iteration of the cycle, 4 elements are added and the obtained result is saved to the addresses of the pointer <i>c</i> from the xmm0 register (for this program).  Those.  as we see, such an approach does not change the source data, but stores the sum in the register and, if necessary, transfers it to the operand we need.  This allows you to improve the performance of the program in cases where it is necessary to reuse operands. <br>  Consider the code that the assembler generates for the <i>_mm_add_ps</i> method: <br><pre> <code class="hljs ruby">mov eax,dword ptr [b_simd] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   b_simd   eax(   ,   ) mov ecx,dword ptr [a_simd] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   a_simd   ecx movups xmm<span class="hljs-number"><span class="hljs-number">0</span></span>,xmmword ptr [ecx] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-number"><span class="hljs-number">4</span></span>       ecx   xmm<span class="hljs-number"><span class="hljs-number">0</span></span>; xmm<span class="hljs-number"><span class="hljs-number">0</span></span> = {a[i], a[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], a[i+<span class="hljs-number"><span class="hljs-number">2</span></span>], a[i+<span class="hljs-number"><span class="hljs-number">3</span></span>]} addps xmm<span class="hljs-number"><span class="hljs-number">0</span></span>,xmmword ptr [eax] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  : xmm<span class="hljs-number"><span class="hljs-number">0</span></span> = xmm<span class="hljs-number"><span class="hljs-number">0</span></span> + b_simd ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> xmm<span class="hljs-number"><span class="hljs-number">0</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] = xmm[<span class="hljs-number"><span class="hljs-number">0</span></span>] + b_simd[<span class="hljs-number"><span class="hljs-number">0</span></span>] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> xmm<span class="hljs-number"><span class="hljs-number">0</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] = xmm[<span class="hljs-number"><span class="hljs-number">1</span></span>] + b_simd[<span class="hljs-number"><span class="hljs-number">1</span></span>] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> xmm<span class="hljs-number"><span class="hljs-number">0</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>] = xmm[<span class="hljs-number"><span class="hljs-number">2</span></span>] + b_simd[<span class="hljs-number"><span class="hljs-number">2</span></span>] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span> xmm<span class="hljs-number"><span class="hljs-number">0</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>] = xmm[<span class="hljs-number"><span class="hljs-number">3</span></span>] + b_simd[<span class="hljs-number"><span class="hljs-number">3</span></span>] movaps xmmword ptr [ebp-<span class="hljs-number"><span class="hljs-number">190</span></span>h],xmm<span class="hljs-number"><span class="hljs-number">0</span></span> ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>          movaps xmm<span class="hljs-number"><span class="hljs-number">0</span></span>,xmmword ptr [ebp-<span class="hljs-number"><span class="hljs-number">190</span></span>h] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    mov edx,dword ptr [c] ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ecx    movaps xmmword ptr [edx],xmm<span class="hljs-number"><span class="hljs-number">0</span></span> ;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ecx      ,   (ecx)  .   xmmword       ,   _m128 - <span class="hljs-number"><span class="hljs-number">128</span></span>- ,   <span class="hljs-number"><span class="hljs-number">4</span></span>    </code> </pre><br>  As can be seen from the code, one <i>addps</i> instruction processes 4 variables at once, which is implemented and supported by the hardware processor.  The system does not take any part in the processing of these variables, which gives a good performance gain without extra costs from the outside. <br>  In this case, I would like to note one feature that in this example, the compiler uses the <i>movups</i> instruction, for which operands are not required, which must be aligned along a 16-byte boundary.  From which it follows that one could not align the array <i>a</i> .  However, array <i>b</i> must be aligned, otherwise a read memory error will occur in the <i>addps</i> operation, because the register is added to a 128-bit memory location.  In a different compiler or environment there may be other instructions, so it‚Äôs better, in any case, for all operands involved in such operations, to do alignment along the boundary.  In any case, to avoid memory problems. <br>  Another reason to do the alignment is when we operate with array elements (and not only with them), we are actually constantly working with 64-byte cache lines.  SSE and AVX vectors always fall into the same cache line if they are equalized by 16 and 32 bytes, respectively.  But if our data is not aligned, then it is very likely that we will have to load another ‚Äúadditional‚Äù cache line.  This process has a strong impact on performance, and if we are at the same time and to the elements of the array, and therefore to memory, we turn inconsistently, then everything can be even worse. <br><br><h3>  SIMD support in .NET </h3><br>  The first mention of JIT support for SIMD technology was announced on the .NET blog in April 2014.  Then the developers announced a new preview version of RyuJIT, which provided SIMD functionality.  The reason for the addition was the rather high popularity of the request for support for C # and SIMD.  The initial set of supported types was not large and there were limitations in functionality.  Initially, the SSE suite was supported, and AVX was promised to be added in the release.  Later, updates were released and new types were added with support for SIMD and new methods for working with them, which in recent versions represents an extensive and convenient library for hardware data processing. <br><img src="http://s003.radikal.ru/i204/1601/0e/ccf71d56a638.jpg" alt="image"><br>  This approach makes life easier for a developer who does not have to write CPU-dependent code.  Instead, the CLR abstracts the hardware, providing a virtual execution environment that translates its code into machine commands either at run time (JIT) or during installation (NGEN).  Leaving the CLR code generation, you can use the same MSIL code on different computers with different processors, without abandoning optimizations specific to this particular CPU. <br>  Currently, support for this technology in .NET is represented in the System.Numerics.Vectors namespace and is a library of vector types that can take advantage of SIMD hardware acceleration.  Hardware acceleration can lead to significant performance improvements in mathematical and scientific programming, as well as in graphics programming.  It contains the following types: <br><ul><li>  Vector - a collection of static convenience methods for working with universal vectors </li><li>  Matrix3x2 - represents a 3x2 matrix </li><li>  Matrix4x4 - represents a 4x4 matrix </li><li>  Plane - represents a three-dimensional plane </li><li>  Quaternion - represents a vector used to encode three-dimensional physical turns. </li><li>  Vector &lt;(Of &lt;(&lt;'T&gt;)&gt;)&gt; represents a vector of a specified numeric type that is suitable for low-level optimization of parallel algorithms. </li><li>  Vector2 - represents a vector with two single-precision floating point values. </li><li>  Vector3 - represents a vector with three single-precision floating-point values. </li><li>  Vector4 - represents a vector with four single-precision floating point values. </li></ul><br>  The Vector class provides methods for addition, comparison, minimum and maximum search, and many other transformations over vectors.  In this case, operations operate using SIMD technology.  The remaining types also support hardware acceleration and contain transformations specific to them.  For matrices, this can be multiplication, for vectors, the Euclidean distance between points, etc. <br><br><h3>  Sample C # Program </h3><br>  So what is needed to use this technology?  You must first have RyuJIT compiler and .NET version 4.6.  System.Numerics.Vectors via NuGet is not set if the version is lower.  However, when the library was installed, I lowered the version and everything worked as it should.  Then you need an assembly for x64, for this you need to remove in the properties of the project ‚Äúprefer 32-bit platform‚Äù and can be assembled under Any CPU. <br>  Listing: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Numerics; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Program { static <span class="hljs-type"><span class="hljs-type">void</span></span> Main(string[] args) { const Int32 N = <span class="hljs-number"><span class="hljs-number">8</span></span>; Single[] a = { <span class="hljs-number"><span class="hljs-number">41982.0</span></span>F, <span class="hljs-number"><span class="hljs-number">81.5091</span></span>F, <span class="hljs-number"><span class="hljs-number">3.14</span></span>F, <span class="hljs-number"><span class="hljs-number">42.666</span></span>F, <span class="hljs-number"><span class="hljs-number">54776.45</span></span>F, <span class="hljs-number"><span class="hljs-number">342.4556</span></span>F, <span class="hljs-number"><span class="hljs-number">6756.2344</span></span>F, <span class="hljs-number"><span class="hljs-number">4563.789</span></span>F }; Single[] b = { <span class="hljs-number"><span class="hljs-number">85989.111</span></span>F, <span class="hljs-number"><span class="hljs-number">156.5091</span></span>F, <span class="hljs-number"><span class="hljs-number">3.14</span></span>F, <span class="hljs-number"><span class="hljs-number">42.666</span></span>F, <span class="hljs-number"><span class="hljs-number">1006.45</span></span>F, <span class="hljs-number"><span class="hljs-number">9999.4546</span></span>F, <span class="hljs-number"><span class="hljs-number">0.2344</span></span>F, <span class="hljs-number"><span class="hljs-number">7893.789</span></span>F }; Single[] c = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Single[N]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i += Vector&lt;Single&gt;.Count) // Count  <span class="hljs-number"><span class="hljs-number">16</span></span>  <span class="hljs-type"><span class="hljs-type">char</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-type"><span class="hljs-type">float</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>  <span class="hljs-type"><span class="hljs-type">double</span></span>  .. { var aSimd = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vector&lt;Single&gt;(a, i); //     i var bSimd = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vector&lt;Single&gt;(b, i); Vector&lt;Single&gt; cSimd = aSimd + bSimd; //   Vector&lt;Single&gt; c_simd = Vector.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(b_simd, a_simd); cSimd.CopyTo(c, i); //     } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; a.Length; i++) { Console.WriteLine(c[i]); } Console.ReadKey(); } }</code> </pre><br>  From a general point of view, the C ++ approach, the .NET are quite similar.  It is necessary to convert / copy the source data, perform copying to the final array.  However, the C # approach is much simpler, many things are done for you and you just have to use and enjoy.  There is no need to think about aligning data, allocating memory and doing it statically or dynamically with certain operators.  On the other hand, you have more control over what is happening with the use of pointers, but also more responsibility for what is happening. <br>  And in the cycle everything happens as in the cycle in C ++.  And I'm not talking about pointers.  The algorithm for calculating the same.  At the first iteration, we put the first 4 elements of the original arrays into the <i>aSimd</i> and <i>bSimd structures</i> , then summarize and save them in the final array.  Then, at the next iteration, we add the next 4 elements with an offset and sum them.  That's how everything is done quickly and easily.  Consider the code that the compiler generates for this command <i>var cSimd = aSimd + bSimd</i> : <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">addps</span></span> xmm0,xmm1</code> </pre><br>  The only difference from C ++ is that both registers are added, while there was a folding of the register with a section of memory.  Register placement occurs when <i>aSimd</i> and <i>bSimd are initialized</i> .  In general, this approach, when comparing the code of C ++ compilers and .NET compilers, is not very different and gives approximately equal performance.  Although the option with pointers will still work faster.  I would like to note that SIMD instructions are generated when code optimization is enabled.  Those.  see them in the disassembler in Debug does not work: it is implemented as a function call.  However, in Release, where optimization is enabled, you will receive these instructions in an explicit (embedded) form. <br><br><h3>  At last </h3><br>  What we have: <br><ul><li>  In many cases, vectorization gives a 4-8 √ó increase in performance. </li><li>  Complex algorithms will require ingenuity, but without it </li><li>  System.Numerics.Vectors currently covers only part of the simd instructions.  For a more serious approach, you will need C ++. </li><li>  There are many other ways besides vectorization: proper use of the cache, multithreading, heterogeneous calculations, good memory management (so that the garbage collector does not sweat), etc. </li></ul><br>  In the course of a brief twitter correspondence with Sasha Goldstein (one of the authors of the book ‚ÄúOptimization of Applications on the .NET Platform‚Äù), who considered hardware acceleration in .NET, I wondered how, in his opinion, SIMD support was implemented in .NET and what compared with C ++.  To which he replied: ‚ÄúUndoubtedly, you can do more in C ++ than in C #.  But you do get cross-processor support in C #.  For example, automatic selection between SSE4 and AVX. "  In general, this is good news.  At the cost of small efforts, we can get as much performance from the system as possible, using all possible hardware resources. <br>  For me, this is a very good opportunity to develop productive programs.  At least in my thesis work, on modeling physical processes, I basically achieved efficiency by creating a certain number of flows, as well as using heterogeneous calculations.  I use both CUDA and C ++ AMP.  Development is conducted on a universal platform under Windows 10, where WinRT is very appealing to me, which allows you to write a program in C # and C ++ / CX.  Basically, I write a kernel for large calculations (Boost) on pluses, and in C # I already manipulate data and develop the interface.  Naturally, the transfer of data through the binary interface ABI for the interaction of two languages ‚Äã‚Äãhas its price (although not very large), which requires a more reasonable development of the C ++ library.  However, my data is sent only if necessary and quite rarely, only to display the results. <br>  If I need to manipulate data in C #, I will convert them to .NET types in order not to work with WinRT types, thereby increasing processing performance already in C #.  For example, when you need to process several thousand or tens of thousands of elements or processing requirements have no special specifications, data can be calculated in C # without using the library (it counts from 3 to 10 million structures, sometimes only for one iteration).  So the hardware accelerated approach will simplify the task and make it faster. <br><img src="http://s019.radikal.ru/i623/1601/2d/355a66138508.jpg" alt="image"><br><br><h3>  List of sources when writing an article </h3><br><ul><li>  <a href="http://habrahabr.ru/post/219841/">Translation of a .NET blog article about a new JIT with SIMD support</a> </li><li>  <a href="http://blogs.msdn.com/b/dotnet/archive/2014/11/05/using-system-numerics-vector-for-graphics-programming.aspx">About System.Numerics.Vector in the .NET blog</a> </li><li>  <a href="http://konishchevdmitry.blogspot.ru/2010/01/blog-post.html">What is alignment, and how does it affect the performance of your programs?</a> </li><li>  <a href="http://habrahabr.ru/company/intel/blog/262933/">Intel's blog about aligning data when vectoring cycles</a> </li></ul><br>  Well, special thanks to Sasha Goldstein for the help and information provided. </div><p>Source: <a href="https://habr.com/ru/post/274605/">https://habr.com/ru/post/274605/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274593/index.html">Universal Memcomputing Machines as an alternative to Turing Machine</a></li>
<li><a href="../274595/index.html">Next week, Microsoft stops supporting all versions of IE, except 11</a></li>
<li><a href="../274597/index.html">Overview of the example application of reinforcement learning using TensorFlow</a></li>
<li><a href="../274601/index.html">Tips for novice microcontroller programmers</a></li>
<li><a href="../274603/index.html">PROLOG for programmers</a></li>
<li><a href="../274611/index.html">Use apply, sapply, lapply in R</a></li>
<li><a href="../274613/index.html">Wi-Fi Alliance announced a new type of Wi-Fi for IoT and low-power devices</a></li>
<li><a href="../274615/index.html">The pitfalls of using Excel Power Query and MySQL to automate reporting</a></li>
<li><a href="../274617/index.html">Disable the bomb with Radare2</a></li>
<li><a href="../274619/index.html">Some sugar in combinatorics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>