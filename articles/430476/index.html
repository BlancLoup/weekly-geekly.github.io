<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>NCBI Genome Workbench: Scientific Research Under Threat</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern computer technology, technical and software solutions - all this greatly facilitates and accelerates the conduct of various scientific studies....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>NCBI Genome Workbench: Scientific Research Under Threat</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9ce/9dc/792/9ce9dc792e9661eba72b3692521754be.png" align="left">  Modern computer technology, technical and software solutions - all this greatly facilitates and accelerates the conduct of various scientific studies.  Often, computer simulation is the only way to test many theories.  Scientific software has its own characteristics.  For example, such software is often subjected to very thorough testing, but is poorly documented.  However, software is written by people, and people make mistakes.  Errors in scientific programs can cast doubt on entire studies.  This article will cover dozens of problems found in the code of the NCBI Genome Workbench software package. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  <a href="https://www.ncbi.nlm.nih.gov/tools/gbench/">NCBI Genome Workbench</a> offers researchers a wide range of tools for studying and analyzing genetic data.  Users can explore and compare data from multiple sources, including NCBI (National Center for Biotechnology Information) databases or their own personal data. <br><br>  As mentioned earlier, scientific software is usually well covered by unit tests.  When checking this project, 85 directories with test files were excluded from the analysis.  This is about a thousand files.  Probably, this is due to the requirements for testing various complex algorithms that are invented for various studies.  But the quality of the rest of the code (not test) is not at such a high level as we would like.  However, as in any project that has not yet taken care of the implementation of static code analysis tools :). <br><br>  Data for the review (or even research) of the code was provided by a static code analyzer for C / C ++ / C # / Java - <a href="https://www.viva64.com/ru/pvs-studio/">PVS-Studio</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Just two digits that will ruin your project. </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dad/9f3/20b/dad9f320b84473428205cc1227a20fe6.png"></div><br><br>  Based on our database of errors, which currently amounts to more than 12 thousand selected examples, we notice and describe special patterns of writing code that lead to numerous errors.  For example, we conducted the following studies: <br><br><ol><li>  <a href="https://www.viva64.com/ru/b/0260/">Last line effect</a> ; </li><li>  <a href="https://www.viva64.com/ru/b/0360/">The most dangerous feature in the C / C ++ world</a> ; </li><li>  <a href="https://www.viva64.com/ru/b/0390/">Boolean expressions in C / C ++.</a>  <a href="https://www.viva64.com/ru/b/0390/">How are the professionals mistaken</a> ; </li><li>  <a href="https://www.viva64.com/ru/b/0509/">Evil lives in comparison functions</a> . </li></ol><br>  This project initiated the description of the new pattern.  We are talking about the numbers <b>1</b> and <b>2</b> in the names of variables, for example, <i>file1</i> and <i>file2</i> , etc.  It is very easy to confuse two such variables.  This is a special case of typos in the code, but one error leads to the appearance of such errors - the desire to work with variables of the same name, differing only in numbers 1 and 2 at the end of the name. <br><br>  Looking ahead a bit, I‚Äôll say that all the listed studies have been confirmed in the code of this project: D. <br><br>  Consider the first example from the Genome Workbench project: <br><br>  <a href="https://www.viva64.com/ru/w/v501/">V501</a> There are identical sub-expressions '(! Loc1.IsInt () &amp;&amp;! Loc1.IsWhole ())'  operator.  nw_aligner.cpp 480 <br><br><pre><code class="cpp hljs">CRef&lt;CSeq_align&gt; CNWAligner::Run(CScope &amp;scope, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc &amp;loc2, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> trim_end_gaps) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((!loc1.IsInt() &amp;&amp; !loc1.IsWhole()) || (!loc1.IsInt() &amp;&amp; !loc1.IsWhole())) { NCBI_THROW(CException, eUnknown, <span class="hljs-string"><span class="hljs-string">"Only whole and interval locations supported"</span></span>); } .... }</code> </pre> <br>  We see two variables, <i>loc1</i> and <i>loc2</i> .  And also an error in the code: the variable <i>loc2 is</i> not used, because instead of it <i>loc1</i> is used once again. <br><br>  Another example: <br><br>  <a href="https://www.viva64.com/ru/w/v560/">V560</a> A part of the conditional expression is always false: s1.IsSet ().  valid_biosource.cpp 3073 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_PCRPrimerSetLess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> CPCRPrimerSet&amp; s2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; s1.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!s1.IsSet() &amp;&amp; !s2.IsSet()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &lt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (s1.Get().size() &gt; s2.Get().size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ..... }</code> </pre> <br>  The first line of the code mixed up the variables <i>s1</i> and <i>s2</i> .  As the name suggests, this is a comparison function.  But such an error can be anywhere, because by calling the variables <i>Number 1</i> and <i>Number 2</i> , the programmer will almost certainly make a mistake in the future.  And the more uses of such names in the function, the higher the probability of making a mistake. <br><br><h2>  Other typos and copy-paste </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d5/d9f/f6b/6d5d9ff6bf8083922701b25273fa50b2.png"></div><br><br>  <a href="https://www.viva64.com/ru/w/v501/">V501</a> There are identical sub-expressions to the left and the right! ‚Äù= 'Operator: bd.bit_.bits [i]! = Bd.bit_.bits [i] bm.h 296 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compare_state</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> iterator_base&amp; ib)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;block_type_ == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.ptr != ib_db.bit_.ptr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.idx != ib_db.bit_.idx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.cnt != ib_db.bit_.cnt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.pos != ib_db.bit_.pos) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bd.bit_.cnt; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (bd.bit_.bits[i] != bd.bit_.bits[i]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } } .... }</code> </pre> <br>  I suppose that after all the checks, the sizes of the arrays <i>bits</i> of the <i>bd.bit_</i> and <i>ib_db.bit_ objects</i> are equal.  Therefore, the author of the code wrote one cycle for the elementwise comparison of the <i>bits</i> arrays, but made a typo in the name of one of the compared objects.  As a result, the compared objects can be mistakenly considered equal in some situations. <br><br>  This example is worthy of the article " <a href="https://www.viva64.com/ru/b/0509/">Evil lives in comparison functions</a> ." <br><br>  <a href="https://www.viva64.com/ru/w/v501/">V501</a> There are identical sub-expressions 'CFieldHandler :: QualifierNamesAreEquivalent (field, kFieldTypeSeqId)' to the left |  operator.  field_handler.cpp 152 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CFieldHandlerFactory::s_IsSequenceIDField(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; field) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId) || CFieldHandler::QualifierNamesAreEquivalent(field, kFieldTypeSeqId)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Most likely, one of the checks is superfluous.  I did not find in the code variables similar to <i>kFieldTypeSeqId</i> .  However, there may be an extra function call due to the operator "||", which degrades performance. <br><br>  A couple more of the same type of places with a warning analyzer, requiring verification: <br><br><ul><li>  V501 There are identical sub-expressions 'uf-&gt; GetData (). IsBool ()' the operator.  variation_utils.cpp 1711 </li><li>  V501 There are identical sub-expressions 'uf-&gt; GetData (). IsBool ()' the operator.  variation_utils.cpp 1735 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v766/">V766</a> An item with the same key 'kArgRemote' has already been added.  blast_args.cpp 3262 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastAppArgs::x_IssueWarningsForIgnoredOptions(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CArgs&amp; args) { <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; can_override; .... can_override.insert(kArgOutputFormat); can_override.insert(kArgNumDescriptions); can_override.insert(kArgNumAlignments); can_override.insert(kArgMaxTargetSequences); can_override.insert(kArgRemote); <span class="hljs-comment"><span class="hljs-comment">// &lt;= can_override.insert(kArgNumThreads); can_override.insert(kArgInputSearchStrategy); can_override.insert(kArgRemote); // &lt;= can_override.insert("remote_verbose"); can_override.insert("verbose"); .... }</span></span></code> </pre> <br>  The analyzer detected the addition of 2 identical values ‚Äã‚Äãto the <i>set</i> container.  Recall that this container stores only unique values, so duplicates are not added to it. <br><br>  Code like the one above is often written using the copy-paste method.  There may just be an extra value, or perhaps the author forgot to rename one of the variables when copied.  When removing an extra call, the <i>insert</i> code is slightly optimized, which, however, is not essential.  It is much more important that there may be a serious mistake hiding because of a missing element in the set. <br><br>  <a href="https://www.viva64.com/ru/w/v523/">V523</a> The 'then' statement is the subsequent code fragment.  vcf_reader.cpp 1105 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CVcfReader::xAssignFeatureLocationSet(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_SetType == CVcfData::ST_ALL_DEL) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data.m_strRef.size() == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); //-1 for 0-based, //another -1 for inclusive end-point ( ie [], not [) ) pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; } //default: For MNV's we will use the single starting point //NB: For references of size &gt;=2, this location will not //match the reference allele. Future Variation-ref //normalization code will address these issues, //and obviate the need for this code altogether. if (data.m_strRef.size() == 1) { //deletion of a single base pFeat-&gt;SetLocation().SetPnt().SetPoint(data.m_iPos-1); pFeat-&gt;SetLocation().SetPnt().SetId(*pId); } else { pFeat-&gt;SetLocation().SetInt().SetFrom(data.m_iPos-1); pFeat-&gt;SetLocation().SetInt().SetTo( data.m_iPos -1 + data.m_strRef.length() - 1); pFeat-&gt;SetLocation().SetInt().SetId(*pId); } return true; }</span></span></code> </pre> <br>  The function contains large and completely identical code fragments.  However, they contain different accompanying comments.  The code is not optimally written, complicated, and possibly contains an error. <br><br>  The entire list of suspicious places with an if-else operator looks like this: <br><br><ul><li>  V523 The 'then' statement is equivalent to the 'else' statement.  blk.c 2142 </li><li>  V523 The 'then' statement is the subsequent code fragment.  odbc.c 379 </li><li>  V523 The 'then' statement is the subsequent code fragment.  odbc.c 1414 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  seqdbvol.cpp 1922 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  seqdb_demo.cpp 466 </li><li>  V523 The 'then' statement is the subsequent code fragment.  blast_engine.c 1917 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  blast_filter.c 420 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  blast_parameters.c 636 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  unordered_spliter.cpp 684 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  bme.cpp 333 </li><li>  V523 The 'then' statement is equivalent to the 'else' statement.  gme.cpp 484 </li></ul><br><h2>  / * with security is best be pedantic * / </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/914/df5/670/914df5670813e7eb410e446f60a0ed5e.png"></div><br>  <a href="https://www.viva64.com/ru/w/v597/">V597</a> The compiler couldn‚Äôt <a href="https://www.viva64.com/ru/w/v597/">need the call memorization</a> function, which is used to flush 'passwd_buf' buffer.  The memset_s () function should be used to erase the private data.  challenge.c 366 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * Crypt a given password using schema required for NTLMv1 authentication * @param passwd clear text domain password * @param challenge challenge data given by server * @param flags NTLM flags from server side * @param answer buffer where to store crypted password */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds_answer_challenge</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAX_PW_SZ 14 .... </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (ntlm_v == 1) { .... </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* with security is best be pedantic */</span></span></span><span class="hljs-meta"> memset(hash, 0, sizeof(hash)); memset(passwd_buf, 0, sizeof(passwd_buf)); memset(ntlm2_challenge, 0, sizeof(ntlm2_challenge)); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { .... } }</span></span></code> </pre> <br>  As you probably already guessed, in the section title there is an amusing comment about security from the code. <br><br>  In short, the <i>memset</i> function will be deleted by the compiler, because cleared buffers are no longer used.  And data such as <i>hash</i> or <i>passwd_buf</i> , in fact, will not be overwritten with zeros.  More details about this unobvious compiler mechanism can be found in the article " <a href="https://www.viva64.com/ru/b/0388/">Safe Private Data Cleansing</a> ". <br><br>  <a href="https://www.viva64.com/ru/w/v597/">V597</a> The compiler couldn‚Äôt delete the memset function call, which is used to flush the answer object.  The memset_s () function should be used to erase the private data.  challenge.c 561 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> TDSRET </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tds7_send_auth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-comment"><span class="hljs-comment">/* for security reason clear structure */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;answer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TDSANSWER)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tds_flush_packet(tds); }</code> </pre> <br>  That was not the only example with comments about "security."  Judging by the comments, we can assume that security is really important for the project.  Therefore, I‚Äôm enclosing a whole list of problems that are not small: <br><br><ul><li>  V597 The compiler could delete the memset function call, which is used to flush the heap object.  The memset_s () function should be used to erase the private data.  ncbi_heapmgr.c 1300 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the context.  The memset_s () function should be used to erase the private data.  challenge.c 167 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the ks object.  The memset_s () function should be used to erase the private data.  challenge.c 339 </li><li>  V597 The compiler could delete the memset function call, which is used to flush the md5_ctx object.  The memset_s () function should be used to erase the private data.  challenge.c 353 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush 'hash' buffer.  The memset_s () function should be used to erase the private data.  challenge.c 365 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the ks object.  The memset_s () function should be used to erase the private data.  challenge.c 406 </li><li>  V597 The compiler couldn‚Äôt have the function call, which is used to flush 'ntlm_v2_response' object.  The memset_s () function should be used to erase the private data.  login.c 795 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the answer object.  The memset_s () function should be used to erase the private data.  login.c 801 </li><li>  V597 The compiler couldn‚Äôt have the function call, which is used to flush to packet buffer buffer.  The memset_s () function should be used to erase the private data.  numeric.c 256 </li><li>  V597 The compiler couldn‚Äôt have the function call, which is used to flush to packet buffer buffer.  The memset_s () function should be used to erase the private data.  numeric.c 110 </li><li>  V597 The compiler couldn‚Äôt have to remember the function call, which is used to flush 'pwd' buffer.  The memset_s () function should be used to erase the private data.  getpassarg.c 50 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the context.  The memset_s () function should be used to erase the private data.  challenge.c 188 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the buf buffer.  The memset_s () function should be used to erase the private data.  challenge.c 243 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the ntlm_v2_hash buffer.  The memset_s () function should be used to erase the private data.  challenge.c 309 </li><li>  V597 The compiler could delete the memset function call, which is used to flush the md5_ctx object.  The memset_s () function should be used to erase the private data.  challenge.c 354 </li><li>  V597 The compiler couldn‚Äôt need the call memorization function, which is used to flush 'passwd_buf' buffer.  The memset_s () function should be used to erase the private data.  challenge.c 380 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the ks object.  The memset_s () function should be used to erase the private data.  challenge.c 393 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush 'hash' buffer.  The memset_s () function should be used to erase the private data.  challenge.c 394 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the ntlm2_challenge buffer.  The memset_s () function should be used to erase the private data.  challenge.c 395 </li><li>  V597 The compiler couldn‚Äôt delete the memset function call, which is used to flush the ks object.  The memset_s () function should be used to erase the private data.  challenge.c 419 </li><li>  V597 The compiler couldn‚Äôt have the function call, which is used to flush 'ntlm_v2_response' object.  The memset_s () function should be used to erase the private data.  challenge.c 556 </li></ul><br><h2>  Suspicious cycles </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ac/c77/124/8acc77124e5a13a1d25926c95d9eb2cf.png"></div><br><br>  <a href="https://www.viva64.com/ru/w/v534/">V534</a> It is likely that a variable is being compared inside the 'for' operator.  Consider reviewing 'i'.  taxFormat.cpp 569 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CTaxFormat::x_LoadTaxTree(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; alignTaxids.size(); i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tax_id = alignTaxids[i]; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; taxInfo.seqInfoList.size(); j++) { SSeqInfo* seqInfo = taxInfo.seqInfoList[j]; seqInfo-&gt;taxid = newTaxid; } .... } .... }</code> </pre> <br>  I think, in the condition of the inner cycle, the variable <i>i</i> got stuck randomly.  Instead, the variable <i>j</i> should be used. <br><br>  <a href="https://www.viva64.com/ru/w/v535/">V535</a> The variable 'i' is being used for the loop.  Check lines: 302, 309. sls_alp.cpp 309 <br><br><pre> <code class="cpp hljs">alp::~alp() { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(d_alp_states) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=d_nalp;i++) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { if(i&lt;=d_alp_states-&gt;d_dim) { if(d_alp_states-&gt;d_elem[i]) { for(i=0;i&lt;=d_nalp;i++) // &lt;= { .... .... }</span></span></code> </pre> <br>  Two nested identical cycles, in which the global counter is also reset, look well, very suspiciously.  Developers should check out what's going on here. <br><br><h2>  Abnormal array indexing </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a8/136/5b2/4a81365b2534c606f6d12df389841299.png"></div><br><br>  <a href="https://www.viva64.com/ru/w/v520/">V520</a> The comma operator ',' in array index expression '[- i2, - k]'.  nw_spliced_aligner16.cpp 564 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CSplicedAligner16::x_DoBackTrace ( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Uint2* backtrace_matrix, CNWAligner::SAlignInOut* data, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i_global_max, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j_global_max) { .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(intron_length &lt; m_IntronMinSize || (Key &amp; donor) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { Key = backtrace_matrix[--i2, --k]; ++intron_length; data-&gt;m_transcript.push_back(eTS_Intron); } .... }</code> </pre> <br>  At once I will say that there seems to be no error here (so far, lol).  Consider the following line: <br><br><pre> <code class="cpp hljs">Key = backtrace_matrix[--i2, --k];</code> </pre> <br>  The word 'matrix' and double indexing may suggest that the array is two-dimensional, but it is not.  This is a regular pointer to an array of integers.  But the diagnosis of the <a href="https://www.viva64.com/ru/w/v520/">V520</a> did not just appear.  Programmers are really confused about how to index two-dimensional arrays. <br><br>  In this case, the author simply decided to save on one line of code, although he could write this: <br><br><pre> <code class="cpp hljs">--i2; Key = backtrace_matrix[--k];</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v661/">V661</a> A suspicious expression 'A [B == C]'.  Probably meant 'A [B] == C'.  ncbi_service_connector.c 180 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EHTTP_HeaderParse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_ParseHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* header, ....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header, <span class="hljs-string"><span class="hljs-string">"%u.%u.%u.%u%n"</span></span>, &amp;i1, &amp;i2, &amp;i3, &amp;i4, &amp;n) &lt; <span class="hljs-number"><span class="hljs-number">4</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">sscanf</span></span>(header + n, <span class="hljs-string"><span class="hljs-string">"%hu%x%n"</span></span>, &amp;uuu-&gt;port, &amp;tkt, &amp;m) &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> || (header[m += n] &amp;&amp; !(header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>) &amp;&amp; !<span class="hljs-built_in"><span class="hljs-built_in">isspace</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)((header + m) [header[m] == <span class="hljs-string"><span class="hljs-string">'$'</span></span>])))) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span><span class="hljs-comment"><span class="hljs-comment">/*failed - unreadable connection info*/</span></span>; } .... }</code> </pre> <br>  Another example of code in which I tried for a long time to understand what was happening: D.  The <i>isspace ()</i> function checks the character with the index <i>m</i> , but if this character is '$', then the character with the index <i>m + 1 is</i> passed to the function.  In this case, the comparison with '$' was already in advance.  Perhaps there is no error here, but the code can be accurately rewritten more clearly. <br><br>  <a href="https://www.viva64.com/ru/w/v557/">V557</a> Array overrun is possible.  The 'row' index is pointing beyond array bound.  aln_reader.cpp 412 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CAlnReader::x_IsGap(TNumrow row, TSeqPos pos, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; residue) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_MiddleSections.size() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { x_CalculateMiddleSections(); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt; m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos &lt; m_MiddleSections[row].first) { .... } .... }</code> </pre> <br>  Here there is a serious mistake.  Proper check of <i>row</i> index should be like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row &gt;= m_MiddleSections.size()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre> <br>  Otherwise, it is possible to access data outside of the <i>MiddleSections</i> vector. <br><br>  Many more places like this: <br><br><ul><li>  V557 Array overrun is possible.  The 'i' index is pointing beyond array bound.  resource_pool.hpp 388 </li><li>  V557 Array overrun is possible.  The 'row' index is pointing beyond array bound.  aln_reader.cpp 418 </li><li>  V557 Array overrun is possible.  The 'fmt_idx' index is pointing beyond array bound.  seq_writer.cpp 384 </li><li>  V557 Array overrun is possible.  The 'fmt_idx' index is pointing beyond array bound.  blastdb_formatter.cpp 183 </li><li>  V557 Array overrun is possible.  The 'num' index is beyond array bound.  newcleanupp.cpp 13035 </li></ul><br><h2>  How to earn distrust of functions </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/029/c18/147029c18e4ccacc04f11f688084034f.png"></div><br><br>  <a href="https://www.viva64.com/ru/w/v570/">V570</a> The 'm_onClickFunction' variable is assigned to itself.  alngraphic.hpp 103 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetOnClickFunctionName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> onClickFunction)</span></span></span><span class="hljs-function"> </span></span>{ m_onClickFunction = m_onClickFunction; }</code> </pre> <br>  Here there is nothing to even comment on.  One can only sympathize with the person who clicked on something, clicked, but nothing has changed. <br><br>  Two more cases of assigning variables to myself will give a list: <br><br><ul><li>  V570 The 'iter-&gt; level' variable is assigned to itself.  align_format_util.cpp 189 </li><li>  V570 The 'd_elements_values ‚Äã‚Äã[ind]' variable is assigned to itself.  sls_alp_data.cpp 1416 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v763/">V763</a> Parameter 'w1' is always rewritten in function body before being used.  bmfunc.h 5363 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Bit COUNT functor template&lt;typename W&gt; struct bit_COUNT { W operator()(W w1, W w2) { w1 = 0; BM_INCWORD_BITCOUNT(w1, w2); return w1; } };</span></span></code> </pre> <br>  The function in which the argument is ground immediately upon entering the function may be misleading by the developers using it.  The code should be double-checked. <br><br><h2>  Errors when designing classes </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/033/e75/06c/033e7506c36604696731f73024f57c78.png"></div><br><br>  <a href="https://www.viva64.com/ru/w/v688/">V688</a> The 'm_qsrc' function argument.  compart_matching.cpp 873 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CElementaryMatching</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> CObject { .... ISequenceSource * m_qsrc; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateIndex</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode index_more, ....)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_CreateRemapData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, EIndexMode mode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_LoadRemapData</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISequenceSource *m_qsrc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; sdb)</span></span></span></span>; .... };</code> </pre> <br>  Immediately 3 functions of the class contain arguments whose names coincide with the field of the class.  This can lead to errors in the function bodies: the programmer may think that he is working with a member of a class, actually changing the value of a local variable. <br><br>  <a href="https://www.viva64.com/ru/w/v614/">V614</a> Uninitialized variable 'm_BitSet' used.  SnpBitAttributes.hpp 187 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// SNP bit attribute container. class CSnpBitAttributes { public: .... private: /// Internal storage for bits. Uint8 m_BitSet; }; inline CSnpBitAttributes::CSnpBitAttributes(Uint8 bits) : m_BitSet(bits) { } inline CSnpBitAttributes::CSnpBitAttributes(const vector&lt;char&gt;&amp; octet_string) { auto count = sizeof(m_BitSet); auto byte = octet_string.end(); do m_BitSet = (m_BitSet &lt;&lt; 8) | *--byte; while (--count &gt; 0); }</span></span></code> </pre> <br>  One of the constructors does not work <i>properly</i> with the <i>m_BitSet</i> variable.  The fact is that the variable is uninitialized.  Its ‚Äúgarbage‚Äù value is used at the first iteration of the loop, after which initialization occurs.  This is a very serious mistake, leading to an undefined program behavior. <br><br>  <a href="https://www.viva64.com/ru/w/v603/">V603</a> The object was not used.  If you wish to call the constructor, 'this-&gt; SIntervalComparisonResult :: SIntervalComparisonResult (....)' should be used.  compare_feats.hpp 100 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//This struct keeps the result of comparison of two exons struct SIntervalComparisonResult : CObject { public: SIntervalComparisonResult(unsigned pos1, unsigned pos2, FCompareLocs result, int pos_comparison = 0) : m_exon_ordinal1(pos1), m_exon_ordinal2(pos2), m_result(result), m_position_comparison(pos_comparison) {} SIntervalComparisonResult() { SIntervalComparisonResult(0, 0, fCmp_Unknown, 0); } .... };</span></span></code> </pre> <br>  A long time ago I did not encounter such errors when checking projects.  But the problem is still relevant.  The mistake is that calling a parameterized constructor in this way results in the creation and deletion of a temporary object.  And class fields remain uninitialized.  Call another constructor via the initialization list (see <a href="https://en.cppreference.com/w/cpp/language/initializer_list">Delegating constructor</a> ). <br><br>  <a href="https://www.viva64.com/ru/w/v591/">V591</a> Non-void function should return a value.  bio_tree.hpp 266 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// Recursive assignment CBioNode&amp; operator=(const CBioNode&amp; tree) { TParent::operator=(tree); TBioTree* pt = (TBioTree*)tree.GetParentTree(); SetParentTree(pt); }</span></span></code> </pre> <br>  The analyzer considers that there is not enough line in the overloaded operator: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;</code> </pre> <br>  <a href="https://www.viva64.com/ru/w/v670/">V670</a> The uninitialized class member 'm_OutBlobIdOrData' is used to initialize the 'm_StdOut' member.  Remember that members are initialized in the order of declarations inside a class.  remote_app.hpp 215 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NCBI_XCONNECT_EXPORT</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CRemoteAppResult</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CRemoteAppResult(CNetCacheAPI::TInstance netcache_api, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> max_inline_size = kMaxBlobInlineSize) : m_NetCacheAPI(netcache_api), m_RetCode(<span class="hljs-number"><span class="hljs-number">-1</span></span>), m_StdOut(netcache_api, m_OutBlobIdOrData, m_OutBlobSize), m_OutBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StdErr(netcache_api, m_ErrBlobIdOrData, m_ErrBlobSize), m_ErrBlobSize(<span class="hljs-number"><span class="hljs-number">0</span></span>), m_StorageType(eBlobStorage), m_MaxInlineSize(max_inline_size) { } .... };</code> </pre> <br>  On this fragment of the code 3 warnings of the analyzer are issued immediately.  Class fields are initialized not in the order in which they are listed in the initialization list, but in how they are declared in the class.  The classic reason for the error is that not all programmers remember or know about this rule.  Here and in the initialization list is just the wrong order.  One gets the feeling that the list of fields was entered in a random order. <br><br>  <a href="https://www.viva64.com/ru/w/v746/">V746</a> Object slicing.  By reference rather than by value.  cobalt.cpp 247 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CMultiAligner::SetQueries(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; CRef&lt;objects::CBioseq&gt; &gt;&amp; queries) { .... <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { seq_loc-&gt;SetId(*it-&gt;GetSeqId()); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (objects::CObjMgrException e) { NCBI_THROW(CMultiAlignerException, eInvalidInput, (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>)<span class="hljs-string"><span class="hljs-string">"Missing seq-id in bioseq. "</span></span> + e.GetMsg()); } m_tQueries.push_back(seq_loc); .... }</code> </pre> <br>  Intercepting exceptions by value can lead to the loss of some information about the exception due to the creation of a new object.  It is much better and safer to catch an exception by reference. <br><br>  Similar places: <br><br><ul><li>  V746 Object slicing.  By reference rather than by value.  agp_validate_reader.cpp 562 </li><li>  V746 Object slicing.  By reference rather than by value.  aln_build_app.cpp 320 </li><li>  V746 Object slicing.  By reference rather than by value.  aln_test_app.cpp 458 </li><li>  V746 Object slicing.  By reference rather than by value.  cobalt.cpp 691 </li><li>  V746 Object slicing.  By reference rather than by value.  cobalt.cpp 719 </li><li>  V746 Object slicing.  By reference rather than by value.  cobalt.cpp 728 </li><li>  V746 Object slicing.  By reference rather than by value.  cobalt.cpp 732 </li></ul><br><h2>  About unreachable code and other code execution issues </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d1/8f5/263/1d18f52633776adc7ca32f92446c4b9f.png"></div><br>  <a href="https://www.viva64.com/ru/w/v779/">V779</a> Unreachable code detected.  It is possible that an error is present.  merge_tree_core.cpp 627 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CMergeTree::x_FindBefores_Up_Iter(....) { .... FirstFrame-&gt;Curr = StartCurr; FirstFrame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FirstFrame-&gt;VisitCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; FrameStack.push_back(FirstFrame); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!FrameStack.empty()) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eAfter) { Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; FrameStack.pop_back(); <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Rel == CEquivRange::eBefore) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Frame-&gt;VisitCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } Frame-&gt;Returned = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">// &lt;= FrameStack.pop_back(); continue; } // end stack loop FirstFrame-&gt;ChildFrames.clear(); return FirstFrame-&gt;Returned; }</span></span></code> </pre> <br>  The code of the conditional operator is written in such a way that absolutely all branches of the code end with the <i>continue</i> operator.  This led to the fact that in a <i>while loop there</i> were several lines of unreachable code.  These lines look very suspicious.  Most likely, such a problem arose after the code was refactored, and now a careful code-review is required here. <br><br>  <a href="https://www.viva64.com/ru/w/v519/">V519</a> The 'interval interval' variable is assigned values ‚Äã‚Äãtwice successively.  Perhaps this is a mistake.  Check lines: 454, 456. aln_writer.cpp 456 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CAlnWriter::AddGaps(....) { .... <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(exon_chunk-&gt;Which()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Match: interval_width = exon_chunk-&gt;GetMatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Mismatch: interval_width = exon_chunk-&gt;GetMismatch(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> CSpliced_exon_chunk::e_Diag: interval_width = exon_chunk-&gt;GetDiag(); genomic_string.append(....); product_string.append(....); genomic_pos += interval_width; product_pos += interval_width/res_width; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; .... } .... }</code> </pre> <br>  The variable <i>interval_width is</i> overwritten several times, because  There are no <i>break</i> statements in the <i>case</i> branches.  Although a classic, but very bad mistake. <br><br>  A few more suspicious places: <br><br><ul><li>  V779 Unreachable code detected.  It is possible that an error is present.  dbapi_driver_utils.cpp 351 </li><li>  V779 Unreachable code detected.  It is possible that an error is present.  net.c 780 </li><li>  V779 Unreachable code detected.  It is possible that an error is present.  bcp.c 1495 </li><li>  V779 Unreachable code detected.  It is possible that an error is present.  remote_blast.cpp 1470 </li><li>  V779 Unreachable code detected.  It is possible that an error is present.  remote_blast.cpp 1522 </li></ul><br>  <a href="https://www.viva64.com/ru/w/v571/">V571</a> Recurring check.  The 'if (m_QueryOpts-&gt; filtering_options)' condition was already verified in line 703. blast_options_local_priv.hpp 713 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CBlastOptionsLocal::SetFilterString(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* f) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_QueryOpts-&gt;filtering_options) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { SBlastFilterOptions* old_opts = m_QueryOpts-&gt;filtering_options; m_QueryOpts-&gt;filtering_options = NULL; SBlastFilterOptionsMerge(&amp;(m_QueryOpts-&gt;filtering_options), old_opts, new_opts); old_opts = SBlastFilterOptionsFree(old_opts); new_opts = SBlastFilterOptionsFree(new_opts); } else { if (m_QueryOpts-&gt;filtering_options) // &lt;= m_QueryOpts-&gt;filtering_options = SBlastFilterOptionsFree(m_QueryOpts-&gt;filtering_options); m_QueryOpts-&gt;filtering_options = new_opts; new_opts = NULL; } .... }</span></span></code> </pre> <br>  Obviously, the <i>else</i> branch requires rewriting.  I have a few ideas on what they wanted to do with the <i>m_QueryOpts-&gt; filtering_options</i> pointer, but the code is still some kind of tangled.  I appeal to the authors of the code. <br><br>  Well, the problem does not come alone: <br><br><ul><li>  V571 Recurring check.  The 'if (sleeptime)' condition was already verified in line 205. request_control.cpp 208 </li><li>  V571 Recurring check.  The 'if (assignValue.empty ())' condition was already verified in line 712. classstr.cpp 718 </li></ul><br><h2>  Read errors </h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/761/548/f6b/761548f6b44470fe7b64db8ce0b0eb11.png"></div><br>  <a href="https://www.viva64.com/ru/w/v739/">V739</a> EOF should not be compared with a value of the 'char' type.  The 'linestring [0]' should be of the 'int' type.  alnread.c 3509 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> EBool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">s_AfrpInitLineData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* linestring = readfunc (pfile); .... </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">while</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (linestring != </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">NULL</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;&amp; linestring [</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">] != EOF) { s_TrimSpace (&amp;linestring); .... } .... }</span></span></span></span></code> </pre> <br>  Characters to be compared with EOF should not be stored in variables of type <i>char</i> .  Otherwise, there is a risk that a character with a value of 0xFF (255) becomes -1 and will be interpreted in the same way as the end of file (EOF).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also (just in case) it is worth checking the implementation of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">readfunc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. </font></font><br><br> <a href="https://www.viva64.com/ru/w/v663/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V663</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Infinite loop is possible. </font><font style="vertical-align: inherit;">The 'cin.eof ()' condition is not a loop from the loop. </font><font style="vertical-align: inherit;">Consider adding the 'cin.fail ()' function call to the conditional expression. </font><font style="vertical-align: inherit;">ncbicgi.cpp 1564</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::istream CNcbiIstream; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CCgiRequest::Serialize(CNcbiOstream&amp; os) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... CNcbiIstream* istrm = GetInputStream(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (istrm) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buf[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!istrm-&gt;eof()) { istrm-&gt;read(buf, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(buf)); os.write(buf, istrm-&gt;gcount()); } } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The analyzer has detected a potential error due to which an infinite loop may occur. </font><font style="vertical-align: inherit;">In case of a failure in reading the data, the call to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eof ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">will always return </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">To complete the loop in this case, additional verification of the value returned by the function </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fail ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is necessary </font><font style="vertical-align: inherit;">.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mistakes </font></font></h2><br><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/132/51d/701/13251d701a22cae67c852d1bed7d33a5.png"></div><br> <a href="https://www.viva64.com/ru/w/v502/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V502</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Perhaps the '?:' Operator was different. </font><font style="vertical-align: inherit;">The '?:' Operator has a operator. </font><font style="vertical-align: inherit;">ncbi_connutil.c 1135</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x_ClientAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* client_host, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*bool*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> local_host)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((client_host == c &amp;&amp; x_IsSufficientAddress(client_host)) || !(ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)) || SOCK_ntoa(ip, addr, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(addr)) != <span class="hljs-number"><span class="hljs-number">0</span></span> || !(s = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(client_host) + <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(addr) + <span class="hljs-number"><span class="hljs-number">3</span></span>))) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> client_host<span class="hljs-comment"><span class="hljs-comment">/*least we can do :-/*/</span></span>; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pay attention to the expression: </font></font><br><br><pre> <code class="cpp hljs">!local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(eDefault)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It is not calculated as the programmer expected, because the whole expression looks like this: </font></font><br><br><pre> <code class="cpp hljs">ip = *c &amp;&amp; !local_host ? SOCK_gethostbyname(c) : SOCK_GetLocalHostAddress(...)</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The priority of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&amp;&amp;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operator is </font><font style="vertical-align: inherit;">higher than that of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">?:</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">For this reason, the code is not executed as intended. </font></font><br><br> <a href="https://www.viva64.com/ru/w/v561/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V561</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It's probably better to assign value to 'seq' variable than to declare it anew. </font><font style="vertical-align: inherit;">Previous declaration: validator.cpp, line 490. validator.cpp 492</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CValidator::IsSeqLocCorrectlyOrdered(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CSeq_loc&amp; loc, CScope&amp; scope) { CBioseq_Handle seq; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { CBioseq_Handle seq = scope.GetBioseqHandle(loc); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (CObjMgrException&amp; ) { <span class="hljs-comment"><span class="hljs-comment">// no way to tell return true; } catch (const exception&amp; ) { // no way to tell return true; } if (seq &amp;&amp; seq.GetInst_Topology() == CSeq_inst::eTopology_circular) { // no way to check if topology is circular return true; } return CheckConsecutiveIntervals(loc, scope, x_IsCorrectlyOrdered); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Due to the fact that the programmer declared the new variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inside the try / catch section, the other variable </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seq</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> remains uninitialized and is used below by code. </font></font><br><br> <a href="https://www.viva64.com/ru/w/v562/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V562</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It's a </font><a href="https://www.viva64.com/ru/w/v562/"><font style="vertical-align: inherit;">bit</font></a><font style="vertical-align: inherit;"> to compare value with a value of 0: ((((status) &amp; 0x7f) == 0)! = 0. ncbi_process.cpp 111</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CProcess::CExitInfo::IsExited(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { EXIT_INFO_CHECK; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != eExitInfo_Terminated) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(NCBI_OS_UNIX) return WIFEXITED(status) != 0; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> defined(NCBI_OS_MSWIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// The process always terminates with exit code return true; #endif }</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nothing foreshadowed trouble, but WIFEXITED turned out to be a macro, opening like this: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (((status) &amp; <span class="hljs-number"><span class="hljs-number">0x7f</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It turns out that the function returns the opposite value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code found another such function, for which a warning was issued:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> V562 It's a bit to compare a bool type with a value of 0. ncbi_process.cpp 126 </font></font></li></ul><br> <a href="https://www.viva64.com/ru/w/v595/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V595</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The 'dst_len' pointer was used before it was verified against nullptr. </font><font style="vertical-align: inherit;">Check lines: 309, 315. zlib.cpp 309</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> CZipCompression::CompressBuffer( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* src_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> src_len, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* dst_buf, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> dst_size, <span class="hljs-comment"><span class="hljs-comment">/* out */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>* dst_len) { *dst_len = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Check parameters if (!src_len &amp;&amp; !F_ISSET(fAllowEmptyData)) { src_buf = NULL; } if (!src_buf || !dst_buf || !dst_len) { SetError(Z_STREAM_ERROR, "bad argument"); ERR_COMPRESS(48, FormatErrorMessage("CZipCompression::CompressBuffer")); return false; } .... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pointer </font><i><font style="vertical-align: inherit;">is</font></i><font style="vertical-align: inherit;"> dereferenced at the very beginning of the function, while further on the code is checked for equality to zero. </font><font style="vertical-align: inherit;">There is an error in the code that leads to undefined behavior if the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dst_len</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pointer </font><i><font style="vertical-align: inherit;">turns</font></i><font style="vertical-align: inherit;"> out to be </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nullptr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br> <a href="https://www.viva64.com/ru/w/v590/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V590</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider inspecting the 'ch! =' \ 0 '&amp;&amp; ch ==' '' expression. </font><font style="vertical-align: inherit;">The expression is misprint. </font><font style="vertical-align: inherit;">cleanup_utils.cpp 580</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Asn2gnbkCompressSpaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; val)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch != <span class="hljs-string"><span class="hljs-string">'\0'</span></span> &amp;&amp; ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { ptr++; ch = *ptr; } .... }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The condition for stopping the loop depends only on whether the character </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ch is a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> space or not. </font><font style="vertical-align: inherit;">The expression can be simplified to this:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (ch == <span class="hljs-string"><span class="hljs-string">' '</span></span>) { .... }</code> </pre> <br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of computer programs in scientific research helps and will help to make discoveries. </font><font style="vertical-align: inherit;">Let's hope that the most important of them will not be missed because of any typos. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I invite the developers of the NCBI Genome Workbench project to contact us, and we will provide the full report issued by the PVS-Studio analyzer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that this small code study will help to correct many errors and, in general, improve the reliability of the project. </font><font style="vertical-align: inherit;">Try running PVS-Studio on the code of your projects, if you haven‚Äôt done so yet. </font><font style="vertical-align: inherit;">You might like it :).</font></font><br><br><p> <a href="https://www.viva64.com/en/b/0591/"><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you want to share this article with an English-speaking audience, then please use the link to the translation: Svyatoslav Razmyslov. </font></font><a href="https://www.viva64.com/en/b/0591/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NCBI Genome Workbench: Scientific Research under Threat</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/430476/">https://habr.com/ru/post/430476/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430466/index.html">Mini AI Cup # 3: Writing a Top Bot</a></li>
<li><a href="../430468/index.html">We raise citizens' consciousness</a></li>
<li><a href="../430470/index.html">Why keeping the context on the client's account is fair and profitable</a></li>
<li><a href="../430472/index.html">Seamless DECT-network do it yourself</a></li>
<li><a href="../430474/index.html">CephFS vs GlusterFS</a></li>
<li><a href="../430478/index.html">Trading bots for cryptographic. Where to begin?</a></li>
<li><a href="../430480/index.html">As we wrote the application on the NASA Space Apps Challenge hackathon</a></li>
<li><a href="../430482/index.html">Theme of armor lifts in the culture of East and West</a></li>
<li><a href="../430484/index.html">Typical NGFW implementation scenarios</a></li>
<li><a href="../430486/index.html">How do freelancers live: from developer to technical copywriter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>