<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Leakpocalypse: Rust can surprise unpleasantly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note Trans .: Someone had to do a translation of this article, despite the fact that it is quite old (2015), because it shows a very important feature...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Leakpocalypse: Rust can surprise unpleasantly</h1><div class="post__text post__text-html js-mediator-article"><p> <i>Note</i>  <i>Trans .: Someone had to do a translation of this article, despite the fact that it is quite old (2015), because it shows a <u>very important feature of working with memory in Rust - using a safe (not marked as <code>unsafe</code> ) code, you can create memory leaks</u> .</i>  <i>This should sober up the people who believe in the all-embracing borrow checker.</i> <i><br></i>  <i>Spoiler - inside about the impossibility of tracking cyclic references, as well as old diseases of some types from <code>std</code> , at the time of the transfer safely cured.</i> <i><br></i>  <i>Despite the presence in the Book of a <a href="https://doc.rust-lang.org/book/first-edition/unsafe.html">chapter on safe code</a> (thanks for reminding <a href="https://habrahabr.ru/users/ozkriff/" class="user_link">ozkriff</a> ), as well as an <a href="https://rustycrate.ru/%25D0%25BE%25D0%25B1%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5/2016/04/25/memory-leaks-are-memory-safe.html">explanatory article by the Russian-speaking community</a> (thanks for reminding <a href="https://habrahabr.ru/users/mkpankov/" class="user_link">mkpankov</a> ), I decided to translate to clearly demonstrate the seriousness of misunderstanding Rust memory management features.</i> <i><br></i>  <i>Most likely, this article has not previously been translated due to the very specific terms of the author, which the UFO will not miss in circulation.</i>  <i>For this reason, the translation is not quite literal.</i> </p><a name="habracut"></a><br><h3 id="utechkokalipsis">  Leakage </h3><br><p>  Like a bolt from the blue, a <a href="https://github.com/rust-lang/rust/issues/24292">bug with circular references</a> to <code>std::thread::JoinGuard</code> plunged the community into an abyss of existential horror.  If you follow the news and are already aware of the <strong>leakage</strong> , you can safely skip this section and move on to the next one.  If you follow my comments in the community, then in principle you have nothing to read here, you can safely close the window and return to further study of my comments. </p><br><p>  So, the bug: </p><br><blockquote>  With the help of circular references, you can miss JoinGuard, as a result of which the scoped thread can access the already freed memory area. </blockquote><p>  Extremely serious statement, since all used APIs are marked as safe, which should exclude such behavior of safe code in principle. </p><br><p>  The main focus is on the <code>thread::scoped</code> , which creates a thread with access to the stack window of another thread, the security of which is statically guaranteed by the compiler.  The idea behind the security is a <code>JoinGuard</code> , returned by <code>thread::scoped</code> , whose destructor blocks the execution of the pending and thread-owning stack;  accordingly, nothing more than that passed to the expected stream can survive this <code>JoinGuard</code> .  This allows you to implement quite useful things like: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::vec::<span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::thread; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">increment_elements</span></span></span></span>(slice: &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [<span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> slice.iter_mut() { *a += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> v = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">100</span></span>) { v.push(i); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> threads = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> slice <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> v.chunks_mut(<span class="hljs-number"><span class="hljs-number">10</span></span>) { threads.push(thread::scoped(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { increment_elements(slice); })); } <span class="hljs-comment"><span class="hljs-comment">// JoinGuard' `threads`  ,  `main`   //        }</span></span></code> </pre> <br><p>  Here we do some useful work for each of the ten elements of the array in a separate stream (well, like how. Here is just an example, imagine the payload there yourself.).  Magically, Rust is able to statically guarantee the security of data access without even knowing what exactly is happening in the child threads!  He just needs to see an array (Join) of JoinGuards of threads that borrow <code>v</code> , respectively, <code>v</code> <strong>cannot</strong> die before the threads end.  (And more precisely, Rust doesn't know about the array itself, it is enough for it that <code>threads</code> borrow <code>v</code> - even if <code>threads</code> are empty at all). </p><br><p>  And it is very cool.  And alas, <strong>wrong</strong> . </p><br><p>  It is assumed that destructors ( <em>hereinafter - the implementation of <code>Drop</code> - approx. Per.</em> ) <em>Are</em> guaranteed to be executed in a safe, not marked <code>unsafe</code> code.  What can we say, your humble servant, like many in the community, grew up with faith in this postulate.  In the end, we even have a separate function that specifically removes the connection with the element without calling the destructor, <code>mem::forget</code> , and in the name of this postulate, it is intentionally marked as <code>unsafe</code> ! </p><br><p>  As it turned out, these are just echoes of old API variants.  In fact, <code>mem::forget</code> in the standard library is used in some places in safe code.  And if almost all of these places were later referred to as implementation errors, the one remaining is quite fundamental.  This is <code>rc::Rc</code> . </p><br><p>  Rc is a smart pointer with a link count.  It is very simple - put in the constructor <code>Rc::new</code> data to share between multiple links and use.  <code>clone()</code> ( <code>clone()</code> ) Rc - counter increases.  Delete ( <code>drop()</code> ) clone - the counter decreases.  Everything works only at the expense of the borrow checker ‚Äî tracking the lifetimes ensures that references to the data are released until Rc is deleted, through which they (references) are obtained. </p><br><p>  Rc itself is quite a cake - thanks to the principle of the counter, we work only with references to the internals, the data itself remains in place in terms of freeing the memory, it is impossible to read something outside this memory ... except in cases of internal mutability.  Although the distribution of copies of references to data in Rust implies immutability (data, not references), the data itself is still possible to change, as an exception to the rule.  For these purposes, serves <code>Cell</code> , whose insides can be changed even in the case of multiple access.  Actually, therefore, <code>Cell</code> types are marked as non-thread safe.  For threads, there is <code>sync::Mutex</code> . </p><br><p>  Now let's mix <code>Rc</code> with <code>drop</code> and write safe <code>forget</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">safe_forget</span></span></span></span>&lt;T&gt;(data: T) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::rc::Rc; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::cell::RefCell; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Leak</span></span></span></span>&lt;T&gt; { cycle: RefCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Rc&lt;Rc&lt;Leak&lt;T&gt;&gt;&gt;&gt;&gt;, data: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = Rc::new(Leak { cycle: RefCell::new(<span class="hljs-literal"><span class="hljs-literal">None</span></span>), data: data, }); *e.cycle.borrow_mut() = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Rc::new(e.clone())); <span class="hljs-comment"><span class="hljs-comment">// ,   }</span></span></code> </pre> <br><p>  It looks like a fierce heresy.  In short, you can create cyclically dependent readable references with <code>Rc</code> and <code>RefCell</code> .  The bottom line is the fact that a destructor of the type inside <code>Leak&lt;T&gt;</code> will never be called, although we no longer have references to Rc.  In principle, not calling a destructor is not in itself terrible; you can also terminate the program from the outside or work in an infinite loop.  But not in this case - <strong><code>Rc</code> told us that it caused the destructor</strong> .  It can even be checked: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">Drop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Foo&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drop</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { *<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span> += <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> data = <span class="hljs-number"><span class="hljs-number">0</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> foo = Foo(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> data); safe_forget(foo); } <span class="hljs-comment"><span class="hljs-comment">//    ,       //       data += 1; println!("{:?}", data); //   1,    2 }</span></span></code> </pre> <br><p>  It <a href="http://is.gd/QSrQjK">works</a> .  Now we need to understand the problem from the source ticket that caused the panic.  Reduce the example from the ticket to the following: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> v = <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-literal"><span class="hljs-literal">Ok</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> v) = v { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> jg = thread::scoped(<span class="hljs-keyword"><span class="hljs-keyword">move</span></span> || { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, v); <span class="hljs-comment"><span class="hljs-comment">//     }); safe_forget(jg); // JoinGuard ,   , join  } *v = Err("foo"); //       -  }</span></span></code> </pre> <br><p>  We have disclosed undefined behavior. <br>  And this is undoubtedly a hole in the standard Rust library, since the impossibility of use-after-free and data racing seems to be promised and statically guaranteed, and we have achieved <em>both of these with a</em> trivial example.  The question arises - what exactly was done wrong.  The original ticket predictably casts a shadow on <code>thread::scoped</code> , since it was created by a compiler developer who is 100% aware of the possibility of a destructor leaking from "safe" code. </p><br><p>  This immediately gave rise to a wave of frustration in the community - until this point, they only saw leaks in <code>unsafe</code> .  <code>thread::scoped</code> stabilized.  <a href="https://github.com/rust-lang/rfcs/pull/574"><code>mem::forget</code> marked as <code>unsafe</code></a> , just because in no way, never, by no means and absolutely can not flow from under <code>unsafe</code> ! <br>  After the trial, the origins of the bug revealed a confluence of circumstances: </p><br><ul><li>  Link Sharing </li><li>  Intrinsic variability </li><li>  <code>Rc</code> takes non-static data (not <code>'static</code> ) </li></ul><br><p>  in which, and no more, the bug manifests itself.  This immediately led to the appearance of personalities (alas, me too), requiring in one form or another a ban on the existence of any combination of these circumstances at the compiler level.  So that you understand the level of despair - even there was an insistent request for an internal type of <code>Leak</code> , marking the possibility of a destructor leaking to safe. </p><br><p>  Attention.  <em>Release <code>1.0</code> after three weeks</em> , there is simply no time to implement the above.  The conclusions are the only correct ones - remove <code>mem::forget</code> from unsafe (since it doesn‚Äôt do anything secretly), remake <code>thread::scoped</code> .  Relevant RFCs: </p><br><ul><li>  <a href="https://github.com/rust-lang/rfcs/pull/1066"><code>mem::forget</code> should be safe</a> </li><li>  <a href="https://github.com/rust-lang/rfcs/pull/1084">Fix scoped threads</a> </li><li>  <a href="https://github.com/rust-lang/rfcs/pull/1085">Approve destructor and leakage warranties</a> </li></ul><br><p>  Please note: <u><strong>Rust never guaranteed no leaks in principle</strong></u> .  Leaks, as well as data races, is a concept that has no clear boundaries, therefore it is virtually unavoidable.  If you put something in a <code>HashMap</code> and never ask it - it's also a kind of leak.  Allocate something on the stack, then start an infinite loop - there too.  Any case of heaping data and then forgetting about their existence is the most leakage, which for some reason causes panic in people in this form.  An error can be considered data that you forgot to call the destructor during normal "safe" execution, because from the point of view of static analysis, this data does not exist. </p><br><h3 id="chto-delat">  What to do? </h3><br><p>  Thus, I was dejected and confused.  Working with collections in my understanding always implied guaranteed execution of destructors.  There were excellent opportunities to assemble a descriptor for an arbitrarily complex and dependent type, which acts transparently, but hides all entrails, and parse it correctly when removed.  When working with the Rust lifetimes, this guaranteed, however, that the <em>indefinite state of the type data outside this descriptor is statically non-separable</em> !  That is, Rust is even more carefree than C! <br>  A typical example of this is <code>Vec::drain_range</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//      ? ? //     . struct DrainRange&lt;'a, T&gt; { vec: &amp;'a mut Vec&lt;T&gt;, num_to_drain: usize, start_pos: usize, left: *mut T, right: *mut T, } impl&lt;T&gt; Vec&lt;T&gt; { //  ,    `self[a..b]` // : b    ,   Rust range fn drain_range(&amp;mut self, a: usize, b: usize) -&gt; DrainRange&lt;T&gt; { assert!(a &lt;= b, "invalid range"); assert!(b &lt;= self.len(), "index out of bounds"); DrainRange { left: self.ptr().offset(a as isize), right: self.ptr().offset(b as isize), start_pos: a, num_to_drain: b - a, vec: self, } } } impl&lt;'a, T&gt; Drop for DrainRange&lt;'a, T&gt; { fn drop(&amp;mut self) { //    for _ in self { } let ptr = self.vec.ptr(); let backshift_src = self.start_pos + self.num_to_drain; let backshift_dst = self.start_pos; let old_len = self.vec.len(); let new_len = old_len - self.num_to_drain; let to_move = new_len - self.start_pos; unsafe { //    ! ptr::copy( ptr.offset(backshift_src as isize), ptr.offset(backshift_dst as isize), to_move, ); //  Vec,         self.vec.set_len(new_len); } } } //    impl&lt;'a, T&gt; Iterator for DrainRange&lt;'a, T&gt; { type Item = T; fn next(&amp;mut self) -&gt; Option&lt;T&gt; { if self.left == self.right { None } else { unsafe { let result = Some(ptr::read(self.left)); //  size_of&lt;T&gt; == 0   self.left = self.left.offset(1); result } } } } impl&lt;'a, T&gt; DoubleEndedIterator for DrainRange&lt;'a, T&gt; { fn next_back(&amp;mut self) -&gt; Option&lt;T&gt; { if self.left == self.right { None } else { unsafe { //  size_of&lt;T&gt; == 0   self.right = self.right.offset(-1); Some(ptr::read(self.right)) } } } }</span></span></code> </pre> <br><p>  It even works correctly unwind, class!  And the destructor does not work, see: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[<span class="hljs-built_in"><span class="hljs-built_in">Box</span></span>::new(<span class="hljs-number"><span class="hljs-number">1</span></span>)]; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> drainer = vec.drain_range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    `box 1` - ,   ,  drainer.next(); safe_forget(drainer); } println!("{}", vec); // use-after-free ,   `box 1` }</span></span></code> </pre> <br><p>  Not cool.  I rummaged in the code of the collections of the standard library for something that hopes for a destructor for security, and, fortunately, I did not find anything (which, of course, does not mean at all that it is not there).  More specifically, I was looking for something that fits into the following hierarchy of nastiness of the current destructor: </p><br><ol><li>  No destructor - no leakage: primitives, pointers </li><li>  The leak of system resources is not really a problem: most of the collections and smart pointers around primitives, which have a lot of leakage during a leak </li><li>  Plain destructor leak is unpleasant but not fatal: collections and smart pointers around structures </li><li>  The world is in an indefinite, but safe state - sure "pyshch" in step: <code>RingBuf::drain</code> should clean the collection after its link to its drain iterator finishes living, but this is currently guaranteed only by the destructor.  The collection itself is consistent. </li><li>  The world is broken - unacceptable: the aforementioned <code>Vec::drain_range</code> </li></ol><br><p>  In general, you should move the dependency on the destructor as far as possible according to this hierarchy, with the exception of code from the last category from all APIs that are not marked <code>unsafe</code> . <br>  This hierarchy is based on the assumption that the current destructor in a running program is a bug.  No more, no less, the application code is obliged to assume that there will be no leaks in its arbitrary place or under adequate conditions.  As a common practice in Rust, third-party libraries are solely obliged to confirm the impossibility of leaks. </p><br><p>  The fact that there is a code that <em>may</em> cause a leak, in the API, like <code>Rc</code> , should not be regarded as a bug of the API or its implementation.  Moreover, if leakage is possible only under certain conditions created by the end user.  Despite removing <code>mem::forget</code> from <code>unsafe</code> and the possibility of its calls in safe code, in general cases it must be remembered that the consequences of calling it are unsafe. </p><br><h3 id="rust-mozhet-zastavit-obdelatsya-nepriyatno-udivit">  Rust can <del>  force crap </del>  unpleasant surprise </h3><br><p>  ( <em>most likely this site is the reason why this article is little cited - comment. per.</em> ) </p><br><p>  How can we protect the use of <code>Vec::drain_range</code> and move it higher in the hierarchy?  Adding the following line to the <code>drain_range</code> constructor.  Everything is so simple! </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  Vec,       . unsafe { self.set_len(a); }</span></span></code> </pre> <br><p>  Now, if <code>DrainRange</code> , we will leak the destructors of the elements that need to be raised, because we have completely lost the values ‚Äã‚Äãshifted to the beginning of the vector.  This is quite relevant to the category of "uncertain, but safe state", well, possible and various other leaks are also added.  Still bad, but already a big progress regarding the use-after-free that happened earlier! </p><br><p>  This is what I call the <strong>‚Äú</strong> Pre-Poop Your Pants (PPYP) pattern‚Äù pattern ‚Äî to save the designer‚Äôs situation, at least partially, if the destructor does not turn on.  Why such a dumb title?  Mm  I used to imagine the life cycle between the designer and the destructor as a digestive process.  Something you can eat (designer), process and go to the toilet (destructor).  If the destructor disappears, the toilet never shines.  Depending on the life situation (destructor), various consequences are possible: </p><br><ol><li>  The types are broken at the structural level - that's all, the end, no one goes anywhere anymore.  Where is the surgeon? </li><li>  The types seem to be intact, but the system is already <em>damaged</em> by them, and will break at any time if the constipation is prolonged </li><li>  Types are large and complex - There is a chance that there is nothing unpleasant inside </li><li>  Types-safe <em>drugs</em> - If you do not follow safety instructions, you can show you a helicopter and lead to worse consequences, but under certain conditions you can survive and return to service. </li><li>  Types of dangerous <em>drugs</em> - overdose and death are possible, should be as much as possible controlled. </li></ol><br><p>  Actually, the "It is better to crap" pattern is the following deviation from the usual digestive process: if you have eaten something unexpected, be prepared for "premature trouble."  Usually, the troubles do not overtake, and you have time to reach the toilet according to the plan of his visit.  But if they nevertheless overtook, it is better to crumble and embarrass than to fall into unconsciousness and wake up on the table at the surgeon.  The pattern highlights the following: </p><br><ul><li>  This is a non-optimal compromise: no one wants to find himself in such a situation, but this is not the worst thing that can happen </li><li>  This is imperceptible if it happens according to a plan: if you foresaw this and specifically went into a deep forest to <em>see a bear</em> , no one will know anything.  Nothing was ^^ </li><li>  This is not always inevitable: in practice, all garbage is tightly mixed with the normal processed data, and, perhaps, in your particular case, it is possible simply not to <code>thread::scoped</code> all garbage (such as <code>thread::scoped</code> ) </li><li>  This is meaningless and useless in itself: the heir and fruit of the vulnerable RAII template. </li><li><del>  It's funny: I wrote about the trousers full of embarrassment, and you read it </del>  (no, not funny - comment. per.) </li></ul><br><p>  By the way.  <code>Vec::drain_range</code> <a href="https://github.com/rust-lang/rust/pull/24781">managed to save</a> ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348344/">https://habr.com/ru/post/348344/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348332/index.html">Bored mail or how to send messages from the site to Telegram via Node.js (Express)</a></li>
<li><a href="../348334/index.html">Game design to life. An example of the analysis of the mechanics of the game</a></li>
<li><a href="../348336/index.html">Animations in Android on the shelves (Part 2. Complex animations)</a></li>
<li><a href="../348338/index.html">Implementing a parallel quick sort using ForkJoinPool</a></li>
<li><a href="../348340/index.html">29% of websites are vulnerable to a DOS attack even by one machine (CVE-2018-6389)</a></li>
<li><a href="../348346/index.html">New industry requirements: Certification Centers stop issuing 3-year SSL certificates from March 1, 2018</a></li>
<li><a href="../348348/index.html">It is dangerous to use EDS in Kazakhstan</a></li>
<li><a href="../348350/index.html">Updating strings on the fly in mobile apps: part 2</a></li>
<li><a href="../348352/index.html">How to work with Jira plugin from ScriptRunner or how to avoid code duplication</a></li>
<li><a href="../348354/index.html">How ZFS Stores Data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>