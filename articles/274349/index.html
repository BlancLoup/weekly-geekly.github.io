<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The subtle virtues of regular expressions in Python</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The standard Python library has quite a few nightmarish modules, but this cannot be said about the re module. Despite its advanced age and the long-te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The subtle virtues of regular expressions in Python</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/37b/b56/e2e/37bb56e2e5bfab9ee28b6030bb6ad02e.png" alt="image"><br><br>  The standard Python library has quite a few nightmarish modules, but this cannot be said about the re module.  Despite its advanced age and the long-term lack of updates, I consider this module to be one of the best among all dynamic languages. <br><br>  Python is one of the few dynamic languages ‚Äã‚Äãin which there is no built-in support for regular expressions, but this is compensated for by a well-developed basic system (from an API point of view).  At the same time, he is quite bizarre.  For example, the behavior of a parser written in Python may surprise you.  If you try to profile Python during the import, then most likely you will spend 90% of the time working with the re module. <br><a name="habracut"></a><br><h1>  Old but proven </h1><br>  The regular expression module in Python was developed a long time ago and is used by default in the standard library.  Apart from Python 3, this module has not evolved since its introduction, except for the introduction of Unicode support.  To this day, the enumeration of members (member enumeration) works incorrectly in it (see what the dir () function returns to the object of the regular expression pattern). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The ‚Äúold age‚Äù of the module plays into its hands in the sense that it does not change depending on the version of Python and has proven its reliability.  I often had to redo something just because changes were made to the regular expression module.  And if you consider how many of these expressions I have to write, the immutability of the module can not but rejoice. <br><br>  An interesting detail: the parser and compiler are written in Python, and the matcher - in C. This means that, if necessary, we can transfer the internal structures from the parser to the compiler without full parsing of regular expressions.  The documentation does not describe this, but it works. <br><br>  There are many other interesting points related to regular expressions that are not mentioned or poorly covered in the documentation.  So I‚Äôll give here some examples that characterize the regular expressions module in Python from the best side. <br><br><h1>  Iterative comparison </h1><br>  Undoubtedly, the best feature of regular expressions in Python is the clear distinction between comparison and search.  Not all engines can boast of this.  In particular, you can use an index to offset a match check, but the match object itself will remain tied to a specific position.  For example, you can do something like this: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>pattern = re.compile(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) &gt;&gt;&gt; string = <span class="hljs-string"><span class="hljs-string">'foobar'</span></span> &gt;&gt;&gt; pattern.match(string) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> &gt;&gt;&gt; pattern.match(string, <span class="hljs-number"><span class="hljs-number">3</span></span>) &lt;_sre.SRE_Match object at <span class="hljs-number"><span class="hljs-number">0x103c9a510</span></span>&gt;</code> </pre> <br>  This is a very useful feature when creating lexers.  After all, you can use the ^ symbol to indicate the beginning of the entire line.  You just need to increase the index for later comparison.  It also means that you can do without cutting the lines themselves, thereby saving a lot of memory and not wasting resources on multiple copying of lines.  Although it cannot be said that, in general, according to these criteria, Python stands out for the better. <br><br>  In addition to the comparison, in Python you can search, that is, skip until a match is found: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>pattern = re.compile(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>) &gt;&gt;&gt; pattern.search(<span class="hljs-string"><span class="hljs-string">'foobar'</span></span>) &lt;_sre.SRE_Match object at <span class="hljs-number"><span class="hljs-number">0x103c9a578</span></span>&gt; &gt;&gt;&gt; _.start() <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br><h1>  Mismatch is also a coincidence. </h1><br>  An important problem is the high cost of processing situations where there are no matches.  Suppose we need to write a tokenizer for a wiki-like language, say Markdown.  Between denoting formatting tokens contains a large amount of text, which also needs to be processed.  And when we define wiki-syntax between the necessary tokens, we have to handle even more tokens.  How do we solve this problem? <br><br>  One way is to combine a group of regular expressions into one list and run one after the other.  If no match is found, then we skip the symbol: <br><br><pre> <code class="python hljs">rules = [ (<span class="hljs-string"><span class="hljs-string">'bold'</span></span>, re.compile(<span class="hljs-string"><span class="hljs-string">r'\*\*'</span></span>)), (<span class="hljs-string"><span class="hljs-string">'link'</span></span>, re.compile(<span class="hljs-string"><span class="hljs-string">r'\[\[(.*?)\]\]'</span></span>)), ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tokenize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span><span class="hljs-function">:</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span> last_end = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pos &gt;= len(string): <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> tok, rule <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rules: match = rule.match(string, pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: start, end = match.span() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start &gt; last_end: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'text'</span></span>, string[last_end:start] <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> tok, match.group() last_end = pos = match.end() <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pos += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> last_end &lt; len(string): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'text'</span></span>, string[last_end:]</code> </pre><br>  The solution is not perfect and not the fastest.  The fewer matches, the lower the performance, since we are moving one character at a time, and the loop is executed in interpreted Python code.  Also, this method is not very flexible: for each token we only have matching text, and if groups of tokens are used, the code will have to be reworked. <br><br>  Is there any more convenient solution?  What if you could give the command to the engine to scan for any regular expressions to choose from? <br><br>  The question is interesting.  In general, this is exactly what we do when we write regulars with subpatterns: (a | b).  In this case, either a or b is searched.  So, it is possible to form one huge one from all the available regulars and compare it with it already.  But the downside of such a decision is that in the end we will definitely get confused with all these groups. <br><br><h1>  Scanner </h1><br>  The last 15 years in the regular expression engine, there is one undocumented tool: a scanner.  This is a property of the SRE template object in which the engine, after finding a match, continues to look for the following.  There is even an undocumented re.Scanner class that runs on top of the SRE template scanner, which provides a slightly higher level interface. <br><br>  Unfortunately, the scanner itself, located in the re module, is not very useful from the point of view of speeding up work with ‚Äúmismatches‚Äù.  But if we analyze its source code, it becomes clear that the scanner is implemented on top of the SRE primitives.  It works as follows: takes the list of regulars and the corresponding callbacks.  For each coincidence, he compares a callback with a sample and on the basis of this creates a result list.  Under the hood, this is implemented by creating a SRE template and subpattern objects.  In principle, it creates a larger regular schedule without parsing it.  Armed with this knowledge, what can we do with this code? <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sre_parse <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Pattern, SubPattern, parse <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sre_compile <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> compile <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> sre_compile <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sre_constants <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BRANCH, SUBPATTERN <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Scanner</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, rules, flags=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> pattern = Pattern() pattern.flags = flags pattern.groups = len(rules) + <span class="hljs-number"><span class="hljs-number">1</span></span> self.rules = [name <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> name, _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rules] self._scanner = sre_compile(SubPattern(pattern, [ (BRANCH, (<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, [SubPattern(pattern, [ (SUBPATTERN, (group, parse(regex, flags, pattern))), ]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> group, (_, regex) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> enumerate(rules, <span class="hljs-number"><span class="hljs-number">1</span></span>)])) ])).scanner <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scan</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, string, skip=False)</span></span></span><span class="hljs-function">:</span></span> sc = self._scanner(string) match = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> iter(sc.search <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> skip <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sc.match, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> self.rules[match.lastindex - <span class="hljs-number"><span class="hljs-number">1</span></span>], match <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> skip <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> match <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> match.end() &lt; len(string): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> EOFError(match.end())</code> </pre><br>  For example, here's what: <br><br><pre> <code class="python hljs">scanner = Scanner([ (<span class="hljs-string"><span class="hljs-string">'whitespace'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\s+'</span></span>), (<span class="hljs-string"><span class="hljs-string">'plus'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\+'</span></span>), (<span class="hljs-string"><span class="hljs-string">'minus'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\-'</span></span>), (<span class="hljs-string"><span class="hljs-string">'mult'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\*'</span></span>), (<span class="hljs-string"><span class="hljs-string">'div'</span></span>, <span class="hljs-string"><span class="hljs-string">r'/'</span></span>), (<span class="hljs-string"><span class="hljs-string">'num'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\d+'</span></span>), (<span class="hljs-string"><span class="hljs-string">'paren_open'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\('</span></span>), (<span class="hljs-string"><span class="hljs-string">'paren_close'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\)'</span></span>), ]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token, match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> scanner.scan(<span class="hljs-string"><span class="hljs-string">'(1 + 2) * 3'</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> (token, match.group())</code> </pre><br>  If the lexical analysis fails, an EOFError error will pop up.  But if you specify skip = True, then parts that are not amenable to analysis will be skipped, which facilitates the process of creating such things as wiki-syntax lexical analyzers. <br><br><h1>  Interval scanning </h1><br>  We can use match.start () and match.end () to denote the sections that should be skipped.  Example: <br><br><pre> <code class="python hljs">scanner = Scanner([ (<span class="hljs-string"><span class="hljs-string">'bold'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\*\*'</span></span>), (<span class="hljs-string"><span class="hljs-string">'link'</span></span>, <span class="hljs-string"><span class="hljs-string">r'\[\[(.*?)\]\]'</span></span>), ]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tokenize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(string)</span></span></span><span class="hljs-function">:</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> rule, match <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.scan(string, skip=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): hole = string[pos:match.start()] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hole: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'text'</span></span>, hole <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> rule, match.group() pos = match.end() hole = string[pos:] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hole: <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'text'</span></span>, hole</code> </pre><br><h1>  Fix groups </h1><br>  Annoying is the fact that our group indices are not local to our own regular expression, unlike the combined one.  That is, for example, one cannot refer to a group with an index if there is a rule (a | b).  To do this, you have to tinker with the class, acting as a wrapper for the SRE-sample, allowing you to customize the indexes and group names.  If you are interested in the details, you can explore the implementation of such a wrapper on <a href="https://github.com/mitsuhiko/python-regex-scanner">GitHub</a> 'e, along with some examples of use. </div><p>Source: <a href="https://habr.com/ru/post/274349/">https://habr.com/ru/post/274349/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274327/index.html">Useful add-ons to ReSharper</a></li>
<li><a href="../274329/index.html">Printf Oriented Programming</a></li>
<li><a href="../274333/index.html">How to create a convincing mechanics of death and not screw it up</a></li>
<li><a href="../274335/index.html">AI, BigData & HPC Digest # 3</a></li>
<li><a href="../274339/index.html">Network Optimization Practice Stories</a></li>
<li><a href="../274353/index.html">Tale of how I wrote my REST framework with web sockets</a></li>
<li><a href="../274357/index.html">Working alone is very difficult.</a></li>
<li><a href="../274359/index.html">Cybersecurity 2015</a></li>
<li><a href="../274361/index.html">How to monitor the appearance of questions on toster.ru ,.stackoverflow.com and stackoverflow.com</a></li>
<li><a href="../274363/index.html">Receptions work in Blender. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>