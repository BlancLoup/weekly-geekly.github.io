<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Teamwork in Git</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In all the many articles on git I could find on the network, one essential point is missing - a description of teamwork. What is commonly described as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Teamwork in Git</h1><div class="post__text post__text-html js-mediator-article">  In all the many articles on git I could find on the network, one essential point is missing - a description of teamwork.  What is commonly described as teamwork is actually just working with a remote repository. <br><br>  Below I want to describe my experience of team working on a project using git. <br><a name="habracut"></a><br><h5>  1. General principle </h5><br>  My workflow is organized as follows. <br><br>  I am the lead dash developer, the head of the dash project manager.  I have several developers in my team. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      My job is this: <br><br>  1) talk to the customer <br>  2) to transform the vague and confused wishes of the customer into a clearly defined task <br>  3) put this task to the developer <br>  4) check the result of the task by the developer <br>  5) unsatisfactory result to return to the developer for revision <br>  6) to submit a satisfactory result to the customer for approval or immediately send to production <br>  7) send the result approved by the customer in production <br>  8) the result not approved by the customer back to the developer for revision <br><br>  The work of the developer, respectively, is as follows: <br><br>  1) get me the task <br>  2) execute it <br>  3) send me the result <br>  4) if the task is returned for revision - to finalize and send to me again <br><br>  For task management, I use <a href="http://trac.edgewall.org/">Trac</a> .  Also in Trac the project documentation is kept, both programmer and user. <br><br>  Having formulated the task, I write it down in Trac and assign it to some developer.  The developer, after completing the task, reassigns it to me.  I check the result and, either reassign it to the developer again, or mark it as completed. <br><br>  The algorithm for working with git and the general picture of what is happening is shown schematically in the picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/261/a06/717/261a0671764e3e975d55deed74900f55.png" alt="image"><br><br>  Now, from the theoretical part, let us turn to the practical one and see what all this means and how it works. <br><br><h5>  2. Git </h5><br>  Install git.  Read some <a href="http://habrahabr.ru/blogs/Git/60347/">manual</a> .  Understand the local repository. <br><br>  Please note - this article is not about git commands, but about how to link these commands into the desired sequence.  Therefore, I will continue to give git commands without detailed explanations, assuming that you know the purpose of individual commands. <br><br><h5>  3. Access to the repository </h5><br>  When working as a team, you will need to provide access to the repository for several users.  For convenient access rights to the repository, I use <a href="http://eagain.net/gitweb/%3Fp%3Dgitosis.git">gitosis</a> . <br><br>  Gitosis is a set of scripts that implement convenient management of git repositories and access to them.  It works like this: <br><br>  - a server is started on the server to which all repositories will belong <br>  - all calls to repositories are made via SSH, under the name of this user, user authorization is made by keys <br>  - when logging in via SSH, gitosis scripts are automatically launched, which, depending on the setting, allow or prohibit further actions with repositories <br><br>  The gitosis scripts and configs are stored in the repository themselves and configured by sending commits to this repository.  It sounds crazy, but in fact nothing particularly tricky, quite simple and convenient. <br><br><h5>  4. Install gitosis </h5><br>  To install gitosis, you need (surprise!) To pull out the gitosis installation repository from the gitosis developer server: <br><br>  <b>$ git clone git: //eagain.net/gitosis.git</b> <br><br>  Install gitosis: <br><br>  <b>$ cd gitosis</b> <b><br></b>  <b>$ su</b> <b><br></b>  <b># python setup.py install</b> <br><br>  The installation repository is no longer needed, it can be deleted. <br><br>  Now you need to create a user in the system to which all repositories will belong: <br><br>  <b>$ su</b> <b><br></b>  <b># adduser gituser</b> <br><br>  And then initialize gitosis in the home directory of the created user, with the public key of who will be the gitosis administrator.  The public key, of course, needs to be put somewhere, from where the user gituser can read it: <br><br>  <b># su gituser</b> <b><br></b>  <b>$ cd ~</b> <b><br></b>  <b>$ gitosis-init &lt;id_rsa.pub</b> <br><br>  Note that the gituser user and the gitosis administrator are not one person.  The gituser user is simply the ‚Äúkeeper‚Äù of the repositories and never performs any actions at all. <br><br>  I use another registered user in the system as a gitosis administrator.  But, generally speaking, the administrator does not have to be a user registered in the system.  The main thing is to specify the public key of the administrator when initializing gitosis. <br><br>  After gitosis is initialized, the repositories directory will appear in the gituser user's home directory, in which all repositories will be stored.  At first, there will only be the gitosis-admin.git repository, which stores the settings of the gitosis itself. <br><br>  Please note - for some reason related to the features of different versions of Python, you may need to assign permissions to execute the post-update script located in the gitosis repository: <br><br>  <b>$ chmod 755 ~ / repositories / gitosis-admin.git / hooks / post-update</b> <br><br>  This completes the gitosis installation and the setup begins. <br><br><h5>  5. Setting up gitosis and creating repositories </h5><br>  Setting up gitosis is to change the contents of the gitosis repository by the administrator. <br><br>  We become the gitosis administrator (if the administrator is a registered user in the system) or log out at all and log in where the administrator is registered (for example, on his laptop). <br><br>  Now we pull out the gitosis setup repository: <br><br>  <b>$ git clone gituser @ githost: gitosis-admin.git</b> <br><br>  Where githost is the name of the server where we installed gitosis (and where we will store the repositories). <br><br>  Please note that whatever the administrator‚Äôs name is, the server is always accessed under the username gituser. <br><br>  After that, the gitosis-admin directory will appear in the admin home directory.  In this directory we are interested in the gitosis.conf file, it is in it that all repositories are configured. <br><br>  By default, it will have something like this: <br><br>  [group gitosis-admin] <br>  writable = gitosis-admin <br>  members = admin @ host <br><br>  What means "admin user is allowed to write to the gitosis-admin repository". <br><br>  Creating a new repository is to add a new group to the config.  The name of the group can be any, it is just for clarity.  We need two repositories to work with: <br><br>  [group project-write] <br>  writable = project <br>  members = superdeveloper <br><br>  [group project-read] <br>  readonly = project <br>  members = developer1 developer2 developer3 user1 user2 <br><br>  [group dev] <br>  writable = dev <br>  members = superdeveloper developer1 developer2 developer3 <br><br>  where superdeveloper is the lead developer, developer * is the developers, user * is the other interested <br><br>  This config means the following: <br><br>  1) the lead developer is allowed to write to the main repository <br>  2) everyone is allowed to read from the main repository <br>  3) the lead developer and all developers are allowed to write to the working repository <br><br>  All these users, like the gitosis administrator, do not necessarily have to be registered users in the system.  The main thing is that they have public keys. <br><br>  The public keys of the users specified in the config need to be copied to the gitosis-admin / keydir directory.  Key files must have names like username.pub.  In this example, these will be the names superdeveloper.pub, developer1.pub, user1.pub, etc. <br><br>  After editing the config and copying keys, you need to commit the changes to the local repository: <br><br>  <b>$ git add.</b> <b><br></b>  <b>$ git commit -am 'Add project Project'</b> <br><br>  And send the commit to the central repository, where the settings you have made will be picked up by gitosis: <br><br>  <b>$ git push</b> <br><br>  Everything, now our server of repositories is configured and necessary repositories are created (I say lies, repositories are not created yet, but will be created automatically at the first commit). <br><br><h5>  6. Assign repositories </h5><br>  If in the previous section you had a question - why for one project you need two repositories - then here is the answer. <br><br>  The first repository, the main one, is production.  The combat copy of the project will work on the code from this repository.  The second repository, which is also a worker, is a development.  In this repository is, of course, the development of the project. <br><br>  I tried different schemes of teamwork and the most convenient at the moment seems to me to be a ‚Äúdual repository" scheme.  Work in it is approximately as follows: <br><br>  1) I set the task for the developer <br>  2) the developer takes the current project branch from the main repository and makes a local brunch from it <br>  3) in this brunch, the developer solves the problem <br>  4) the developer sends a brunch with the task to the working repository <br>  5) I take this brunch from the working repository and check it <br>  6) if the task is completed correctly, I merge this brunch with the current project branch in the main repository <br><br>  This scheme has two key differences from the widely described scheme, when all development goes in the master branch of one repository. <br><br>  Firstly, in my scheme, developers cannot make unauthorized changes (both accidental and intentional) to the current branch, i.e.  in production. <br><br>  Secondly, the current branch I never have inoperative. <br><br>  The second reason, in fact, is more important.  Unauthorized changes at any time can be rolled back, and the version control system.  But to fix the non-working state of the current branch can be very difficult. <br><br>  Let me explain by example. <br><br>  Suppose the developer P1 edited P1 and sent it to the master branch.  I checked this edit and found it bad.  Bad editing needs to be redone. <br><br>  While I checked, the P2 developer made the P2 edit and also sent it to the master.  This edit was good.  Good editing needs to be sent to production. <br><br>  But now there are two edits in the master branch, good and bad.  A good edit would need to be sent to production, but the presence of a bad edit does not allow it.  You have to wait for a bad revision to be fixed. <br><br>  Or another example - all edits are good, but some are not approved by the customer.  Unapproved edits do not allow to get into production approved, and approval can take a long time. <br><br>  In general, you need to make changes so that you can steer separately from each other, without dumping them all in a bunch in the master branch. <br><br>  To do this, the developers send to the repository all their branches separately, without merging them with the master.  I do merging.  Accordingly, only the edits I have checked go to the current branch.  Bad edits are sent for revision, and edits awaiting customer approval are sent to the test branch and just ... wait.  And no one interferes. <br><br>  Thus, the current branch is always in working condition. <br><br>  In principle, sending brunch separately can be done in one repository.  But in one repository it is impossible to separate access to individual branches, i.e.  It is not allowed to write to the repository new branches and at the same time prohibit changing the current branch.  Therefore, we need a second repository - in one there is an actual branch, in the other - all new working branches that appear as individual tasks are solved. <br><br>  In fact, in large projects, each developer should generally have his own separate repository.  But for now, it is quite convenient for me to live with two repositories - one is mine (production), the other is common for all developers (development). <br><br><h5>  7. Initial download of the project to the repository </h5><br>  Please note - the primary download is done by the lead developer, since only he has the right to write to the main repository. <br><br>  Create a local repository in the project directory and drive the project files into it: <br><br>  <b>$ cd / old / directory / project</b> <b><br></b>  <b>$ git init</b> <b><br></b>  <b>$ git add.</b> <b><br></b>  <b>$ git commit -am 'poehali!'</b> <br><br>  We inform the local repository about where the main repository is located: <br><br>  <b>$ git remote add origin gituser @ githost: project.git</b> <br><br>  Now we send the commit to the main repository: <br><br>  <b>$ git push origin master</b> <br><br>  Everything, the project is sent to the main repository.  Now the old project directory can be easily banged and started working in a new directory (or on another computer), under the control of git. <br><br><h5>  8. Lead Developer Repository </h5><br>  Go to the new directory (or even to another computer) and pull out the main repository: <br><br>  <b>$ cd / new / directory / project</b> <b><br></b>  <b>$ git clone gituser @ githost: project.git</b> <br><br>  This we got a copy of the main repository.  It is the current branch.  Now you need to create a test branch. <br><br>  Just copy the current branch to the main repository under the name of the test: <br><br>  <b>$ git push origin master: stage</b> <br><br>  And then pull out the test branch from the main repository under your own name: <br><br>  <b>$ git checkout -b stage origin / stage</b> <br><br>  Now the local repository contains two branches, master and stage.  Both branches are associated with the same branches in the main repository. <br><br>  In this local repository, the lead developer will check the branches sent by other developers and merge the checked branches with the branches of the main repository. <br><br>  In addition, you need to specify the location of the dev working repository: <br><br>  <b>$ git remote add dev gituser @ githost: dev.git</b> <br><br><h5>  9. Project Infrastructure </h5><br>  Our project includes not only repositories, but also ‚Äúexecuting‚Äù nodes - production and debugging. <br><br>  Production and debugging are the essence of local repositories that are updated from the main repository.  The difference between production and debugging is that production is updated from the current branch, and debugging from the test. <br><br>  The launch of production, without going into details, was as follows: <br><br>  1) to register in the system a new user, from under which production will work <br>  2) add this user to gitosis (see section 5, in my example it is user *) <br>  3) clone the main project repository to this user's directory <br>  4) Configure the Apache virtual host (or whatever you like) on the project directory <br><br>  And now for the update of production it is enough just to go to this directory and execute one single command: <br><br>  <b>$ git pull</b> <br><br>  All updates that are in the current branch, in the blink of an eye will be in production. <br><br>  The debugging copy of the project is identical, except that after cloning the main repository, a switch was made from the current master branch to the test stage branch: <br><br>  <b>$ git checkout -b stage origin / stage</b> <br><br>  Now pull in the debug will pull updates from the test branch. <br><br><h5>  10. Developer repository </h5><br>  When starting to work on a project, the developer must first set up his local repository.  The developer will deal with two remote repositories - the main and the working. <br><br>  The main repository needs to be cloned: <br><br>  <b>$ git clone gituser @ githost: project.git</b> <br><br>  And the working repository is simply added to the config: <br><br>  <b>$ git remote add dev gituser @ githost: dev.git</b> <br><br>  This setting is performed only once.  All further work is carried out according to the standard scheme (print the memo and stick it on the monitor). <br><br><h5>  11. Developer's Memo </h5><br>  Check mail.  If there is a notification from Trac about a new task - start working: <br><br>  <b>$ quake exit</b> <br><br>  Create a new brunch based on the current branch from the main repository (we have agreed to call the brunch ticket numbers from Trac): <br><br>  <b>$ git checkout -b new_branch origin / master</b> <br><br>  Or return to work on the old brunch from the working repository. <br><br>  <b>$ git checkout -b old_branch dev / old_branch</b> <br><br>  Pull out the latest changes: <br><br>  <b>$ git pull</b> <br><br><pre>  ---
 Perform a task in a new brunch.  Here is the work with the code.
 --- </pre><br>  If new files were created during the work, add them to the brunch: <br><br>  <b>$ git add.</b> <br><br>  Save changes to local repository: <br><br>  <b>$ git commit -am 'komment'</b> <br><br>  Send a new brunch to the working repository: <br><br>  <b>$ git push new_branch dev</b> <br><br>  Or re-send the same old brunch: <br><br>  <b>$ git push</b> <br><br>  To re-assign the completed task in Trac to the leading developer.  Back to the developer, it will return either with an indication of what needs to be redone, or with the closed status. <br><br>  <b>10 goto check mail;</b> <br><br>  Here it must be said about a couple of subtleties.  The state of the local repository of each particular developer, in general, does not bother me, but still, so that people do not get confused once again, I recommend them to do two things. <br><br>  Firstly, the branches sent to the working repository are no longer needed locally and can be safely removed: <br><br>  <b>$ git branch -D new_branch</b> <br><br>  Secondly, the list of brunches in remote repositories, issued by the command <br><br>  <b>$ git branch -r</b> <br><br>  it becomes outdated with time, since I remove from there the branches tested and merged with the current branch.  To update information about remote repositories you need to run the command <br><br>  <b>$ git remote prune dev</b> <br><br>  which deletes the branches in the remote repository from the local cache.  Please note - you only need to update the working repository.  There are never any changes in the main repository, the same master and stage branches are always there. <br><br><h5>  12. Lead Developer Actions </h5><br>  Having received a notification from Trac about the task that was reassigned to me, I open this task and look at what it was all about to know what to check. <br><br>  Then I update the data about the remote repositories: <br><br>  <b>$ git remote update</b> <br><br>  Now I will see new branches in the working repository, including the branch corresponding to the task being checked: <br><br>  <b>$ git branch -r</b> <br><br>  Then I pull the checked brunch from the working repository to myself (since the name of the brunch corresponds to the ticket number, I always know for sure which brunch to pull): <br><br>  <b>$ git checkout -b branch dev / branch</b> <br><br>  If this is not a new brunch, but a fix for the old one, then you still need to pull out the updates: <br><br>  <b>$ git pull</b> <br><br>  Now I can check the performance and correctness of the edits made by the developer. <br><br>  Let's say the edit passed the test.  Further actions depend on whether this edit is simple, one that can be sent to production without agreement with the customer, or is it a big edit that needs to be agreed. <br><br>  If editing is simple, then I simply merge the checked brunch with the current branch and send the updated current branch to the main repository: <br><br>  <b>$ git checkout master</b> <b><br></b>  <b>$ git merge branch</b> <b><br></b>  <b>$ git push</b> <br><br>  After that, I delete the brunch locally and from the working repository, no one will ever need this brunch: <br><br>  <b>$ git branch -D branch</b> <b><br></b>  <b>$ git push dev: branch</b> <br><br>  There is such a moment - first I wanted to entrust the removal of brunches from the working repository to the developers so that each of them would delete their brunches.  But then he decided not to complicate people's lives.  Those.  the approach is this - if the developer sent a brunch that suited me, then this brunch should not bother the developer. <br><br>  If editing requires coordination, then the checked brunch merges not with the actual branch, but with the test: <br><br>  <b>$ git checkout stage</b> <b><br></b>  <b>$ git merge branch</b> <b><br></b>  <b>$ git push</b> <br><br>  After sending the updated test branch to the main repository, I delete the checked brunch only locally: <br><br>  <b>$ git branch -D branch</b> <br><br>  In the working repository, this brunch remains.  It is possible that the customer will want to remake something and then the developer will need this brunch to fix it. <br><br>  In the test branch, the checked brunch lies and is not asking.  When the customer gets to him and approves, then I will again pull this brunch from the working repository and salt with the current branch. <br><br>  After all the branches are merged with the necessary branches and the whole thing is sent to the main repository, I go into production and debugging and update them. <br><br>  ( <a href="http://m-ivanov.livejournal.com/7988.html">original article</a> ) </div><p>Source: <a href="https://habr.com/ru/post/75990/">https://habr.com/ru/post/75990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../75979/index.html">Scroll clock</a></li>
<li><a href="../75982/index.html">The concept of the new theme ‚ÄúUbuntu Sun‚Äù</a></li>
<li><a href="../75983/index.html">Military robots from Boston Dynamic</a></li>
<li><a href="../75984/index.html">Return mobile phone</a></li>
<li><a href="../75989/index.html">Skype sold for 2.75 billion dollars to its creators</a></li>
<li><a href="../75993/index.html">Alternative way to get SID</a></li>
<li><a href="../75995/index.html">Linus - Nobel!</a></li>
<li><a href="../75996/index.html">Windows 8</a></li>
<li><a href="../75998/index.html">CodeCraft - the battle of programmers</a></li>
<li><a href="../75999/index.html">Taming rsync on Mac OS X</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>