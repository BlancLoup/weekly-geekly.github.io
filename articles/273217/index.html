<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HTML5 Mastery: Fragments</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are several types of DOM nodes, such as Document, Element, Text, and many others, which form a common Node. One of the most interesting nodes is...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>HTML5 Mastery: Fragments</h1><div class="post__text post__text-html js-mediator-article">  There are several types of DOM nodes, such as Document, Element, Text, and many others, which form a common Node.  One of the most interesting nodes is the DocumentFragment, despite the fact that until now it has hardly been used.  It is, for the most part, a special container for other nodes. <br><br>  DocumentFragment is handled in most DOM algorithms in a special way.  In this article, we will look at some of the API methods developed for use with DocumentFragment.  We also learn that the concept of a node container plays an important role in other modern web technologies, such as the template element or the entire shadow DOM API.  But before we begin, let's take a quick look at parsing fragments, which is not directly related to DocumentFragment. <br><a name="habracut"></a><br><h4>  Fragment parsing </h4><br>  The HTML5 parser can be used not only to analyze the whole document.  It can also be used to parse parts of a document.  To trigger fragment parsing, you need to set properties such as innerHTML or outerHTML.  Fragment analysis is performed in the same way as regular parsing, with some exceptions.  The most significant difference is the need for a contextual root. <br><br>  The analyzed fragment is most likely to be placed as a child of some other element, which may or may not have additional parent elements.  This information is extremely important for determining the current parsing mode, which depends on the current tree hierarchy.  In addition, fragment parsing does not lead to script execution for security reasons. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, we can use code like the one below, but we will not get additional results.  This will not execute the script. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#foo'</span></span>); foo.innerHTML = <span class="hljs-string"><span class="hljs-string">'&lt;b&gt;Hallo World!&lt;/b&gt;&lt;script&gt;alert("Hi.");&lt;/script&gt;'</span></span>;</code> </pre> <br>  Using fragment parsing is an easy way to reduce the number of DOM operations.  Instead of creating, modifying and adding nodes, each of which involves context switching, and thus DOM operations, we work exclusively with building a string, which is then evaluated and processed by the parser.  Thus, we have only one or two DOM operations.  The disadvantage of this method is that we need a parser, and we need to do more work in JavaScript.  The main question is this: What needs more time?  Are various DOM operations more expensive than all the necessary JavaScript manipulations, or vice versa? <br><br>  It is clear that everything depends on the situation.  Regarding this scenario, Grgur Grisogono compared performance using several methods.  It also depends on the browser, especially on how fast the JavaScript engine is.  The higher the value - the more operations, and the more desirable such a result. <br><br><img src="https://habrastorage.org/files/b0b/198/08a/b0b19808a09146888ef9f4dffec89b41.png"><br>  Although browsers are much faster today, relative behavior still matters.  This should motivate us to look for optimal solutions and study DocumentFragment in more detail. <br><br><h4>  Generalized DOM operations </h4><br>  The meaning of the DocumentFragment node is quite simple: it is a container for Node objects.  When a DocumentFragment is added, it expands to the extent that it only adds the contents of the container, not the container itself.  When a complete copy of the DocumentFragment is requested, its content is also cloned.  The container itself is never attached to another node, even if it must have an owner, which is the document from which the fragment was created. <br><br>  Creating a DocumentFragment is as follows: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragment = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createDocumentFragment();</code> </pre><br>  From this point of view, fragment behaves in the same way as any other parent DOM node.  We can add, remove nodes, or access already existing nodes.  There is an option to launch CSS queries using querySelector and querySelectorAll.  Most importantly, as mentioned, we can clone a node with cloneNode (). <br><br><h4>  Creating HTML Templates </h4><br>  In essence, DocumentFragment cannot be built in pure HTML, since this concept can only be implemented through the DOM API.  Therefore, containers can only be created in JavaScript.  This greatly understates the benefits.  We start by putting our template in a pseudo-element script.  This element is a pseudo-element because the type attribute will be set to an invalid mime type.  Thus, nothing will be executed, but the text content of the element will use different parsing rules. <br><br><img src="https://habrastorage.org/files/bee/a23/c76/beea23c76f654373a66739fb84a762ba.png"><br><br>  The above image shows tokenization states.  For script tags, special parsing rules are used, since the parsing will be performed in a special tokenization state.  In HTML, there are five tokenization states, but the fifth, Plaintext, is not particularly interesting. <br><br>  The state of Rawtext is very similar to Script, and therefore we need to explain only three states. <br><br>  Let's take an example.  We use three elements that fairly well reflect each of the remaining states.  The div element, like many others, is in parsed characters mode (PCData).  textarea uses RCData like the title element.  The Rawtext state is even more like free characters that can be represented using the style element.  There are some minor differences between exiting Rawtext and Script.  Therefore, in the following discussion, we will consider them the same. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> example = <span class="hljs-string"><span class="hljs-string">'&lt;br&gt;me &amp; you &gt; them'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> types = [<span class="hljs-string"><span class="hljs-string">"div"</span></span>, <span class="hljs-string"><span class="hljs-string">"textarea"</span></span>, <span class="hljs-string"><span class="hljs-string">"script"</span></span>]; types.forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(type); foo.innerHTML = example; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo.innerHTML); })</code> </pre><br><br>  Perhaps we could expect to get the same result, but, even realizing that there are differences, what will be the final result? <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span>me &amp;amp; you &amp;gt; them &amp;lt;br&amp;gt;me &amp;amp; you &amp;gt; them <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span>me &amp; you &gt; them</code> </pre><br><br>  Only in the latter case, the input line is the same.  That is, we have a winner.  But here the fun begins.  Most engines create a function from a string that takes a model and breaks it up for viewing into a list of generated DOM nodes. <br><br>  Some may associate values ‚Äã‚Äãin advance, depending on the model.  The most important part is the generation of the node that is most focused on the string, at least during the first iteration. <br><br>  W3C recognized the situation and responded by introducing the template element.  The element can be recognized as a DocumentFragment media.  Since DocumentFragment is not directly involved in the DOM tree, it is attached to the node through a property. <br>  Using an element is quite simple, as the following example demonstrates: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{src}"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">alt</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{alt}"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"comment"</span></span></span><span class="hljs-tag">&gt;</span></span>{comment}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">template</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In the DOM, we will not find a single child of this element.  All child objects are attached to a nested DocumentFragment instance, which can be accessed through the content property. <br><br>  Let's get these child elements: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragment = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'template'</span></span>).content; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> img = fragment.querySelector(<span class="hljs-string"><span class="hljs-string">'img'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> comments = fragment.querySelectorAll(<span class="hljs-string"><span class="hljs-string">'.comment'</span></span>);</code> </pre><br><br>  The text is enclosed in braces, which reflects our intention to treat it as a stub.  There is no system for automatic filling. <br><br>  Let's create a function to return processed nodes.  To do this, adjust the code to the previous example. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createNodes</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">model</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fragment = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'template'</span></span>).content; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> instance = fragment.clone(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);<span class="hljs-comment"><span class="hljs-comment">//deep cloning! var img = instance.querySelector('img'); img.setAttribute('src', model.src); img.setAttribute('alt', model.alt); var div = instance.querySelector('div'); div.textContent = model.comment; return instance; }</span></span></code> </pre><br>  A generalization is possible by iterating all the attributes of elements and child nodes, replacing the text corresponding to a predefined structure in attributes and text nodes.  And finally, the processed nodes can be added somewhere: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> nodes = createNodes({ <span class="hljs-attr"><span class="hljs-attr">src</span></span>: <span class="hljs-string"><span class="hljs-string">'image.png'</span></span>, <span class="hljs-attr"><span class="hljs-attr">alt</span></span>: <span class="hljs-string"><span class="hljs-string">'Image'</span></span>, <span class="hljs-attr"><span class="hljs-attr">comment</span></span>: <span class="hljs-string"><span class="hljs-string">'Great!'</span></span> }); <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#comments'</span></span>).appendChild(nodes);</code> </pre><br>  There are three important aspects of the template element: <br><ol><li>  It calls a different parsing mode.  Therefore, it is more than just an element. </li><li>  Its child element will not be appended to the DOM, but a DocumentFragment will be available through content. </li><li>  We need to make an exact copy of the fragment before using it. </li></ol><br>  Finally, DocumentFragment is so useful that it can even be used to make small parts of sites reusable and more flexible. <br><br><h4>  Shadow DOM </h4><br>  Recently, the demand for web components has increased significantly.  Most front-end frameworks attempt to replicate their structure.  However, you still need to have real support for DOM, even though you can use polyfills. <br><br>  Shadow DOM allows us to add a DocumentFragment to any Element.  There are three limitations: <br><ol><li>  The DocumentFragment must be specific - it must be a ShadowRoot. </li><li>  Each Element can contain only one ShadowRoot, or none. </li><li>  The contents of the ShadowRoot should be separated from the original DOM. </li></ol><br><br>  <b>These restrictions have consequences.</b> <br><br>  One of the consequences of the ShadowRoot application for an element is that the element is not displayed, the contents of the root element of the shadow tree are displayed instead.  Content has a special purpose, which means that it can follow its own design rules. <br><br>  Also, the entire event handling process will be slightly different.  As a result, another new concept appears: slots.  We can define slots in our shadow DOM that are filled with nodes from the element containing ShadowRoot.  It seems obvious that creating custom elements that contain a shadow DOM is a good idea.  The entire specification of custom elements is a reaction to this. <br><br>  So how can we use a shadow DOM?  To understand the API, run some JavaScript.  Let's start with the following HTML fragment: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#shadow-dialog"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"header"</span></span></span><span class="hljs-tag">&gt;</span></span> My header title <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>Some very important content<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  At this point, everything behaves as usual.  Here we need JavaScript skills: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> context = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#shadow-dialog'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = context.attachShadow({ <span class="hljs-attr"><span class="hljs-attr">mode</span></span>: <span class="hljs-string"><span class="hljs-string">'open'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headerSlot = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'slot'</span></span>); headerSlot.name = <span class="hljs-string"><span class="hljs-string">'header'</span></span>; root.appendChild(headerSlot); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentSlot = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'slot'</span></span>); contentSlot.name = <span class="hljs-string"><span class="hljs-string">'content'</span></span>; root.appendChild(contentSlot);</code> </pre><br><br>  At this stage, we have achieved little.  We started with a few elements and returned to them.  An effectively composed DOM tree looks like this: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"#shadow-dialog"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"header"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"header"</span></span></span><span class="hljs-tag">&gt;</span></span> My header title <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">span</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">slot</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"content"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>Some very important content<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">slot</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  By default, all nodes of our shadow root are assigned a standard slot, if there is one.  The default slot has no name property.  So what have we achieved?  We integrated several transparent elements.  But, more importantly, to change the structure, attributes, or layout of our DOM tree, you don‚Äôt have to change our original markup.  We only need to change which elements will be added to the shadow root, and that's it.  We broke the front-end into modules. <br><br>  Now you might think that we already had similar techniques on the server.  And of course, some client frameworks also tried to generalize the code in a similar way.  However, there are some major differences. <br><br>  First, we have full browser support. <br>  Secondly, the sandbox simplifies the drawing of this module by special rules - no overlaps with existing CSS rules.  This ensures that the module will work on every page.  No more debugging in a search where the CSS rules interfere with each other.  And finally, we have a more accurate code.  It is easy to generate and transfer, and we can expect more performance. <br><br><h4>  Conclusion </h4><br>  DocumentFragment is an efficient helper that has the ability to significantly reduce the number of DOM operations.  It is also an important cornerstone of modern technology, especially in the field of web components.  It has already led to the emergence of two outstanding technologies: the template element and ShadowRoot.  While the former greatly simplifies the creation of templates, allowing for good performance improvements and easy transfer of pre-generated nodes, the latter is the basis of the components. <br><br>  Is the real virtual DOM faster?  Of course, but it may not be so fast if you do not use DocumentFragment to summarize multiple operations. <br><br><hr><br><div class="spoiler">  <b class="spoiler_title">Paysto payment solutions for Habr readers:</b> <div class="spoiler_text">  ‚Üí <a href="http://linkcharge.ru/email">Get paid by credit card right now.</a>  <a href="http://linkcharge.ru/email">Without a site, PI and LLC.</a> <br>  ‚Üí <a href="http://linkcharge.ru/">Accept payments from companies via the Internet.</a>  <a href="http://linkcharge.ru/">Without a site, PI and LLC.</a> <br>  ‚Üí <a href="http://linkcharge.ru/api">Acceptance of payments from companies for your site.</a>  <a href="http://linkcharge.ru/api">With document circulation and exchange of originals.</a> <br>  ‚Üí <a href="http://linkcharge.ru/automat">Automation of sales and service transactions with legal entities.</a>  <a href="http://linkcharge.ru/automat">Without intermediary in the calculations.</a> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/273217/">https://habr.com/ru/post/273217/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273199/index.html">Apply machine learning to improve PostgreSQL performance.</a></li>
<li><a href="../273201/index.html">Installing the VNC server, and setting it up over SSH</a></li>
<li><a href="../273205/index.html">3 business projects that improve the data center industry</a></li>
<li><a href="../273209/index.html">Update Windows 10 SDK - build 10586</a></li>
<li><a href="../273213/index.html">Critical 0-day vulnerability detected in CMS Joomla</a></li>
<li><a href="../273219/index.html">How we made ABBYY FineReader, or a story that happened 20 years ago</a></li>
<li><a href="../273221/index.html">Website recognizes user annoyance by cursor movement.</a></li>
<li><a href="../273223/index.html">Localization of products or another post with the title "Toggle to start"</a></li>
<li><a href="../273225/index.html">Responsibility of the vendor. Who is responsible for the accident?</a></li>
<li><a href="../273231/index.html">Fast algorithm for graph isomorphism problem published</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>