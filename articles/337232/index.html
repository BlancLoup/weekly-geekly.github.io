<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Concurrency patterns in Rust from Java</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Under the cut there are notes that describe how to implement cunning concurrency patterns in Rust, which I can easily write in Java, and what is the d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Concurrency patterns in Rust from Java</h1><div class="post__text post__text-html js-mediator-article"><p>  Under the cut there are notes that describe how to implement cunning concurrency patterns in Rust, which I can easily write in Java, and what is the difference in concurrency approaches in these languages.  The article will be useful to those who switch to Rust from C #, because it has a similar memory model. <br><img src="https://habrastorage.org/web/36b/3e2/b72/36b3e2b729a1410ea9d90bc74d3b04a7.png"></p><a name="habracut"></a><br><h1 id="para-slov-o-raznice-v-podhodah-java-i-rust">  A couple of words about the difference in the approaches of Java and Rust </h1><br><p>  Java is the first language with a memory model (which describes the synchronization of read and write operations to memory), Rust inherits the C ++ 11 memory model in the LLVM implementation.  So in terms of terminology, there are a lot of differences.  In fact, in Java there are 3 mechanisms for synchronizing shared memory: volatile variables, locks (synchronized blocks, ReentrantLock, etc.) and atomic.  In Rust, only locks (Mutex, Rwlock) and atomic.  Volatile is not needed because it duplicates the atomic functionality.  The transmission of messages through the channels is omitted. </p><br><p>  More differences: </p><br><ol><li>  In Rust there is no garbage collector, so you have to put objects shared between threads in the atomic arc reference counter Arc.  Moreover, Rust reverently treats immutable objects, so in order to change the internal state of an object without capturing the link, you will have to wrap it in a Cell or an analog (RefCell, UnsafeCell). </li><li>  Atomic operations at Rust use four types of barriers, but this does not change the rules of the game much.  Use Relaxed when reading through the race is acceptable (for example, under blocking), Acquire to read + Release to write - when it is not necessary that all threads see the same order of operations, and SeqCst - when necessary.  I remind you that volatile in Java guarantees SeqCst.  For atomic operations that do both reading and writing at the same time (for example, swap), the AcqRel (Acquire + Release) option is provided. </li><li>  Rust has no null and cannot be used as an indicator.  For this, use Option, which does not cost anything around the pointer.  In Java, sometimes the use of null for an indicator is also not without its dangers - see the second example. </li><li>  AtomicPtr in Rust is not the same as AtomicReferenc in Java.  This is not an obvious point, if you look only at semantics, but it becomes obvious when used - see the last example.  It‚Äôs often easier to use a separate AtomicBool for synchronization. </li><li>  In Rust, locking (Mutex, RwLock) is inseparable from the object around which it is taken.  And access to the object can not be obtained in any other way, except through the lock seizure.  In Java, you also need a synchronization object for the monitor, but you can access it without capturing it. </li><li>  You must consciously inherit Sync using unsafe for the class that you want to transfer between threads. </li><li>  In contrast to the relatively simple idea of ‚Äã‚Äãhappens-before, which is good in common, the idea of ‚Äã‚Äãbarriers is much more complicated for code analysis.  I think you will see it in examples. </li><li>  <strong>All the same, Rust implies that you will not often fumble changing data between threads and organize work <a href="https://doc.rust-lang.org/book/second-edition/ch16-02-message-passing.html">differently</a> .</strong> </li></ol><br><p>  Consider the same way that I just teach Rust myself, so the code on it should be taken skeptically.  I tested it, but in the context of concurrency it does not guarantee anything. </p><br><h1 id="double-check-lock">  Double-check lock </h1><br><p>  In the Java world, love double-check-lock because  before Java 1.5, it could not be implemented correctly.  I remind you how it looks: </p><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lazy</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> T val; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Supplier&lt;T&gt; supp; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lazy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;T&gt; supp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.supp = supp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { val = supp.get(); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } }</code> </pre> <br><p>  People who are used to writing concurrency code are not so surprised, but if you think about it, there are a lot of dangerous operations.  First, reading through the race.  Secondly, we scroll a variable object between threads (the get method changes the internal state of the object).  Rust does not like this.  He is generally angry.  Nevertheless, the closest analogue in Rust looks like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lazy</span></span></span></span>&lt;T, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() -&gt; T&gt; { init: AtomicBool, val: UnsafeCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;&gt;, supp: Mutex&lt;F&gt; } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> &lt;T, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() -&gt; T&gt; <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Lazy&lt;T, F&gt; {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> &lt;T, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() -&gt; T&gt; Lazy&lt;T, F&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(func: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { Lazy{ init: AtomicBool::new(<span class="hljs-literal"><span class="hljs-literal">false</span></span>), val: UnsafeCell::new(<span class="hljs-literal"><span class="hljs-literal">None</span></span>), supp: Mutex::new(func) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.init.load(Ordering::Acquire) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.supp.lock().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.init.load(Ordering::Relaxed) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.val.get() }; *value = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(func()); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.init.store(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, Ordering::Release); } } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { (*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.val.get()).as_ref().unwrap() } } }</code> </pre> <br><p>  It looks unusual, <a href="https://stackoverflow.com/questions/45681531/what-is-the-right-way-to-write-double-checked-locking-in-rust/">but stackoverflow thinks so</a> . </p><br><p>  There is a lot more code here.  Do not pay attention to Mutex around supp - it just has to be somewhere.  Due to the lack of null, I had to wrap val in Option.  And because of the difficulties in using AtomicPtr, I had to add an AtomicBool initialization flag. </p><br><p>  Here note the difference in proof of correctness.  For example, in Java, if you remove volatile, then you just say that there is no happens-before from the record to read, and the analysis ends here.  It is not necessary to search for a specific version of the execution in which the problem is implemented. </p><br><p>  In Rust, you run the risk of being trapped due to different options of memory barriers.  Therefore it is necessary to run through all versions of execution.  If you read in init true it means you see an entry in it and in val (by transitivity).  Therefore, everything will work fine.  Otherwise, you take a lock, then reading true there also guarantees the visibility of the record in val.  In the last third case, if you are the stream that recorded the value, you will also see it because  other threads do not write the value (and if you could not read your own record, it would break single-threaded programs). </p><br><h1 id="double-check-lock-s-udaleniem-supplier">  Double-check lock with Supplier removal </h1><br><p>  In the last example, the variable supp is not needed after use.  I met this example in <a href="https://youtu.be/puYPHysBN7U%3Ft%3D2h12m23s">Shipilev's report on JMM</a> . </p><br><p>  Java code: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LazyOpt</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> Supplier&lt;T&gt; supp; T val; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Supplier EMPTY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Supplier() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LazyOpt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Supplier&lt;T&gt; supp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.supp = supp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (supp != EMPTY) { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { val = supp.get(); supp = EMPTY; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } }</code> </pre> <br><p>  Everything is simple and familiar: it is almost double-check-lock, with the only difference that we remove the function that calculates the value.  The JMM specification allows us to see supp == null before someone put something there, so EMPTY must be used (for more details, see <a href="https://youtu.be/puYPHysBN7U%3Ft%3D2h44m43s">Shipilev's report at the very end</a> , he asked not to ask it at the interviews).  Volatile to supp is needed in order to forward the happens-before between a write operation inside a synchronized and a read outside it.  Volatile on val is not needed, because  the one who sees the record in supp, also sees the record in val. </p><br><p>  Immediately it should be said that this example may not make sense in Rust.  The structures on the stack have a fixed size, and if supp is not a pointer, then nothing will be won if you wipe it in None.  But if supp is for some reason Arc, then it is possible. </p><br><p>  Analog in Rust: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lazy</span></span></span></span>&lt;T, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() -&gt; T&gt; { init: AtomicBool, val: UnsafeCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;T&gt;&gt;, supp: Mutex&lt;UnsafeCell&lt;<span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;Arc&lt;F&gt;&gt;&gt;&gt;, } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> &lt;T, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() -&gt; T&gt; <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Lazy&lt;T, F&gt; {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> &lt;T, F: <span class="hljs-built_in"><span class="hljs-built_in">Fn</span></span>() -&gt; T&gt; Lazy&lt;T, F&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(func: F) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { Lazy{ init: AtomicBool::new(<span class="hljs-literal"><span class="hljs-literal">false</span></span>), val: UnsafeCell::new(<span class="hljs-literal"><span class="hljs-literal">None</span></span>), supp: Mutex::new(UnsafeCell::new(<span class="hljs-literal"><span class="hljs-literal">Some</span></span>(Arc::new(func)))), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt;(&amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; &amp;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> T { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.init.load(Ordering::Acquire) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> supp = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.supp.lock().unwrap(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.init.load(Ordering::Relaxed) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> value = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.val.get() }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp; *supp.get() }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> f) = *func { *value = <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(f()); } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *supp.get() }; *func = <span class="hljs-literal"><span class="hljs-literal">None</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.init.store(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, Ordering::Release); } } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { (*<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.val.get()).as_ref().unwrap() } } }</code> </pre> <br><p>  As for me, the option on Rust looks too difficult to use in practice.  However, from the point of view of the proof of correctness, nothing has changed.  all operations with the function are done under blocking. </p><br><h1 id="bezopasnaya-gonka-benign-races">  Safe race (benign races) </h1><br><p>  Another clever trick, from <a href="https://youtu.be/puYPHysBN7U%3Ft%3D2h34m36s">the same report</a> , allows you to write lazy initialization for a small number of cases, such as counting an object hash, which does not require locks. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LazyHash</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> hash; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> temp = hash; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp == <span class="hljs-number"><span class="hljs-number">0</span></span>) { temp = supp(); hash = temp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> temp; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>; } }</code> </pre> <br><p>  Here the main secret is that: </p><br><ol><li>  We do not soar the non-transitivity of the visibility of the fields of an object if: they are not there, they are final, or if it is not a class, but a primitive (with the exception of long and double).  In other cases, it hovers, because  it cannot be fixed retroactively. </li><li>  If supp call multiple times, it returns the same value (not equal to the link). </li><li>  We do not soar that the objects may be different by reference, if otherwise they are the same. </li><li>  We save the object to a local copy to avoid returning null on double-reading. </li><li>  Optimization in this place is necessary (point cutting off most situations). </li></ol><br><p>  Although the code looks like we do not use other guarantees for operations, in addition to guarantees for single-threaded programs, this is not so.  After all, Java guarantees atomicity of read and write operations on primitives (including references) except long and double, and without atomicity this code is not correct.  Also with a local variable trick we add a guarantee of monotony.  <a href="http://llvm.org/docs/Atomics.html">Rust gives exactly the same guarantees if you make a relaxed operation.</a>  . </p><br><p>  Heshes believe in Rust is smarter than in Java, so the example below is an abstract getter: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LazyHash</span></span></span></span> { hash: AtomicIsize } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> LazyHash { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { LazyHash{hash: AtomicIsize::new(<span class="hljs-number"><span class="hljs-number">0</span></span>)} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">isize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> temp = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.hash.load(Ordering::Relaxed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> temp == <span class="hljs-number"><span class="hljs-number">0</span></span> { temp = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.supp(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.hash.store(temp, Ordering::Relaxed); } temp } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">supp</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt;<span class="hljs-built_in"><span class="hljs-built_in">isize</span></span> { <span class="hljs-number"><span class="hljs-number">4</span></span> } }</code> </pre> <br><p>  In Rust, you could return honest self.hash.load (Ordering :: Relaxed) instead of temp, it just doesn't make sense.  Also in the nightly assembly of Rust, a bunch of atomics (even 128 bit ones), but in Java you can‚Äôt do the same trick with a 64 bit long and you‚Äôll have to sculpt volatile. </p><br><h1 id="read-write-struktura-dlya-odnogo-pisatelya">  Read-write structure for one writer </h1><br><p>  I heard about this idea in the report <a href="https://youtu.be/Ra2RSsyO4XU%3Ft%3D29m20s">computer science is still alive</a> , which described the cunning algorithms used in IDEA. </p><br><p>  The idea is as follows: Read-write locks are too slow, with thousands of readers and exactly one writer.  But you can speed up if reading threads write flags to ThreadLocal and check the writer's atomic flag.  There were no other details, so my implementation will be completely different. </p><br><p>  Honestly, the task description is similar to mvcc for the poor.  I will explain.  If there is no need for monotony, then you can do without locks in a situation where there is no more than one writer and many readers.  The readers read from the last (at the time of the operation) copies of the data, and the writer writes in a personal copy.  When the writer finishes his work, he updates the general copy atomically, and new readers will already take it.  Old readers will work with the old copy.  Here monotony is violated.  The new fast reader can return a new value, and after it the old slow reader will return the old value.  However, it is impossible to notice a violation of monotony if you receive values ‚Äã‚Äãin the same order in which tasks were created or do not expect tasks from other threads to complete.  In the implementation below it is considered acceptable. </p><br><p>  However, at least two ways to fix the monotony come to mind: </p><br><ol><li>  For the case when throughput is important to us, you can add a block: the new readers and the writer will not report the completion of their work until all the old readers do this.  This is not the same as ReadWrite blocking, since tasks are physically performed at the same time and we simply synchronize visibility: after removing the blocking, all the finished results will be visible instantly.  You can keep track of the latter who took the current copy for reading, and everyone who took the next copy will have to wait until he releases it before releasing his own. </li><li>  If we assume that the writer is in our priority and his latency is important for us and there is an opportunity to cancel and restart the tasks of the readers, then you can restart all the tasks that did not have time to be completed by the time the writer updated the value - probably it is more suitable for use case from the report. </li></ol><br><p>  The code below does not use ThreadLocal (the information in the report is not enough to understand why it is needed, if you can do without it).  This code remains valid even if there are more than one writer.  But it will break if readers start writing. </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PoorMvcc</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PoorMvcc</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Copyable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> T currentValue; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ReentrantLock writersSync = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReentrantLock(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PoorMvcc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T val)</span></span></span><span class="hljs-function"> </span></span>{ currentValue = val; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getReadCopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> currentValue; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWriteCopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ writersSync.lock(); <span class="hljs-comment"><span class="hljs-comment">// Copy shoud not throw any exception. return currentValue.copy(); } public void returnReadCopy(T oldValue) { // No-op because we don't care about monotonic. } public void returnWriteCopy(T newValue) { currentValue = newValue; writersSync.unlock(); } // Because Cloneable isn't generic and method clone is protected. public static interface Copyable&lt;T&gt; { T copy(); } }</span></span></code> </pre> <br><p>  For Rust developers, it may seem wild that you have to declare your own interface for copying.  In Java, the clone method is declared protected ie.  it is visible only to descendants (where you can declare it public) and even if you declare type T as the heir of Cloneable, this will not solve the problem.  By the way, in C # with this, everything is also <a href="https://stackoverflow.com/questions/536349/why-no-icloneablet">not thankful to God</a> : the ICloneable interface is not generic and returns Object, which still needs to be cast to the desired type. </p><br><p>  I did a benchmark on JMH.  Even in the case of 1 writer and 1 reader, the implementation on PoorMvcc is much faster than the implementation on ReentrantReadWriteLock.  With the increase in the number of writers, the gap is only growing.  I do not know how to write a similar benchmark on Rust.  It seems there is no functionality to check how the methods influence each other when executed simultaneously. </p><br><div class="spoiler">  <b class="spoiler_title">Benchmark 1 writer and 10 readers and its results</b> <div class="spoiler_text"><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LongCopy</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PoorMvcc</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Copyable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LongCopy</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> val; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LongCopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.val = val; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> LongCopy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LongCopy(val); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> PoorMvcc&lt;LongCopy&gt; poorMvcc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PoorMvcc&lt;&gt;(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LongCopy(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-meta"><span class="hljs-meta">@Group</span></span>(<span class="hljs-string"><span class="hljs-string">"g"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GroupThreads</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LongCopy copy = poorMvcc.getWriteCopy(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { copy.val++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> copy.val; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { poorMvcc.returnWriteCopy(copy); } } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-meta"><span class="hljs-meta">@Group</span></span>(<span class="hljs-string"><span class="hljs-string">"g"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GroupThreads</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LongCopy copy = poorMvcc.getReadCopy(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> copy.val; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { poorMvcc.returnReadCopy(copy); } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> LongCopy longCopy = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LongCopy(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ReentrantReadWriteLock lock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReentrantReadWriteLock(); <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-meta"><span class="hljs-meta">@Group</span></span>(<span class="hljs-string"><span class="hljs-string">"g2"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GroupThreads</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inc2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock(); writeLock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { longCopy.val++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> longCopy.val; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { writeLock.unlock(); } } <span class="hljs-meta"><span class="hljs-meta">@Benchmark</span></span> <span class="hljs-meta"><span class="hljs-meta">@Group</span></span>(<span class="hljs-string"><span class="hljs-string">"g2"</span></span>) <span class="hljs-meta"><span class="hljs-meta">@GroupThreads</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ReentrantReadWriteLock.ReadLock readLock = lock.readLock(); readLock.lock(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> longCopy.val; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { readLock.unlock(); } }</code> </pre> <br><p>  Result: </p><br><pre> <code class="hljs vhdl">Benchmark Mode Cnt Score <span class="hljs-literal"><span class="hljs-literal">Error</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Units</span></span> Main.g avgt <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">60</span></span>,<span class="hljs-number"><span class="hljs-number">452</span></span> ¬± <span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">956</span></span> ns/op Main.g:inc avgt <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">344</span></span>,<span class="hljs-number"><span class="hljs-number">700</span></span> ¬± <span class="hljs-number"><span class="hljs-number">33</span></span>,<span class="hljs-number"><span class="hljs-number">870</span></span> ns/op Main.g:read avgt <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>,<span class="hljs-number"><span class="hljs-number">027</span></span> ¬± <span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">935</span></span> ns/op Main.g2 avgt <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">4093</span></span>,<span class="hljs-number"><span class="hljs-number">235</span></span> ¬± <span class="hljs-number"><span class="hljs-number">3403</span></span>,<span class="hljs-number"><span class="hljs-number">373</span></span> ns/op Main.g2:inc2 avgt <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">28628</span></span>,<span class="hljs-number"><span class="hljs-number">403</span></span> ¬± <span class="hljs-number"><span class="hljs-number">37297</span></span>,<span class="hljs-number"><span class="hljs-number">944</span></span> ns/op Main.g2:read2 avgt <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-number"><span class="hljs-number">1639</span></span>,<span class="hljs-number"><span class="hljs-number">718</span></span> ¬± <span class="hljs-number"><span class="hljs-number">52</span></span>,<span class="hljs-number"><span class="hljs-number">243</span></span> ns/op</code> </pre> <br><p>  The increment is 83 times faster, and the reading is 51. If there are 100 readers, then the increment will be 12,000 times faster, and 17 000 reading. </p></div></div><br><p>  In Rust there is a Thread local, but we will not need it here either. </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PoorMvcc</span></span></span></span>&lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; { current_value: AtomicPtr&lt;T&gt;, write_copy: Mutex&lt;T&gt; } <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> &lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">Sync</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> PoorMvcc&lt;T&gt; {} <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> &lt;T: <span class="hljs-built_in"><span class="hljs-built_in">Clone</span></span>&gt; PoorMvcc&lt;T&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>(val: T) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span> { PoorMvcc { write_copy: Mutex::new(val.clone()), current_value: AtomicPtr::new(Arc::into_raw(Arc::new(val)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> _) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_read_copy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; Arc&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> val = <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> {Arc::from_raw(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.current_value.load(Ordering::Acquire))}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> copy = Arc::clone(&amp;val); Arc::into_raw(val); copy } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return_read_copy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, val: Arc&lt;T&gt;) { <span class="hljs-comment"><span class="hljs-comment">// Eliminate a link } fn get_write_copy(&amp;self) -&gt; MutexGuard&lt;T&gt; { self.write_copy.lock().unwrap() } fn return_write_copy(&amp;self, val: MutexGuard&lt;T&gt;) { let new_val = Arc::new(val.clone()); let old_val = self.current_value.swap(Arc::into_raw(new_val) as *mut _, Ordering::AcqRel); //To avoid a memory leak we have to eliminate the old value. unsafe {Arc::from_raw(old_val);} } }</span></span></code> </pre> <br><p>  Let's first consider getting the value to read.  Working with AtomicPtr in Rust must be done carefully so that the memory does not leak and is not released too early.  I put the Arc inside because the result will be passed between the threads.  Respectively get_read_copy gets the atomically current Arc link and returns its clone (this is how Arc links are passed to Rust).  If there is nothing more to be done, then the pointer will get rotten in AtomicPtr, because the link read from there will free the Arc, so I‚Äôm doing into_raw to prevent this from happening.  And return_read_copy takes the Arc link, destroying this copy. </p><br><p>  Getting the value to write is more cunning.  Since it is necessary to synchronize records with locking, I start a separate copy of the data wrapped in Mutex.  When I call get_write_copy, I simply return the value from Mutex (it is wrapped in MutexGuard to release the lock later - this is the complete equivalent of Java code).  And in return_write_copy I accept it back, then I replace the old value for reading with a new copy.  There is a trick with the swap operation that needs to be done atomically, which would then release the old Arc link (other threads may have a copy). </p><br><p>  That's all for today.  Finding bugs is welcome. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337232/">https://habr.com/ru/post/337232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337216/index.html">"Rock is hard" or ya. Music as a graph</a></li>
<li><a href="../337218/index.html">Business game Kanban-pizza in the office Tutu.ru</a></li>
<li><a href="../337226/index.html">BeagleBone: support for 7 '' BB-View display on the new linux-4.4 core</a></li>
<li><a href="../337228/index.html">The practice of forming requirements in IT projects from A to Z. Part 4. Business processes automated by the system</a></li>
<li><a href="../337230/index.html">Conduct usability testing or experience cones</a></li>
<li><a href="../337234/index.html">Mobile applications and their testers: all you need to know</a></li>
<li><a href="../337236/index.html">We write GraphQL API server on Yii2 with a client on Polymer + Apollo. Part 4. Validation. findings</a></li>
<li><a href="../337238/index.html">Cheat Sheet for the entrepreneur in the IT world</a></li>
<li><a href="../337240/index.html">Creating a programming language using LLVM. Part 10: Conclusion and other goodies LLVM</a></li>
<li><a href="../337242/index.html">Do you have a lot of different printers in your organization and you need to collect the number of prints from all?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>