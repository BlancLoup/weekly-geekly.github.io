<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Increasing network device performance: fast path technology in Marvell Kirkwood processors</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="High-speed data networks surround us everywhere: at work at the computer, in telephone calls, digital TV, ATMs and in other situations when you need t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Increasing network device performance: fast path technology in Marvell Kirkwood processors</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d59/c9d/6e5/d59c9d6e59f949e187dde583675ad36a.jpg"><br><br>  High-speed data networks surround us everywhere: at work at the computer, in telephone calls, digital TV, ATMs and in other situations when you need to transmit digital information.  And the greater the volume of this information and the number of its customers, the more stringent requirements are placed on speed and throughput. <br><br>  In the process of developing telecom and datacom devices, we are constantly confronted with the tasks of ensuring high data transfer speeds.  In this article, we will discuss how to solve them.  As an example, let us analyze the work of the fast path technology in the processors of the <a href="http://promwad.ru/tehnologii/processory-marvell">Marvell Kirkwood</a> line, measure the network parameters of the network and show how to improve the performance of various devices for routing traffic. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We invite engineers and programmers to cut - everyone who designs hardware and develops software for network routers.  Our recipes can be used in the SOHO sector (small office / home office) and in the Enterprise segment (development of high-performance network devices). <br><a name="habracut"></a><br>  In local and global computer networks, the de facto standard is data transmission using Ethernet and TCP / IP protocols.  These protocols provide different topologies with the separation of the original large networks into subnets using routers.  The simplest way to build a network is presented below: <br><br><img src="https://habrastorage.org/files/d42/23c/10a/d4223c10a4094ebbbf6d07cd8978f098.png"><br><br>  When transmitting information flow from computer A to computer B, traffic in the form of packets arrives at the interface of the eth0 router, from where the packet is sent to the operating system, where it sequentially passes through different levels of the TCP / IP protocol stack and is decoded to determine the further route of the packet.  After receiving the destination address and determining the redirection rule, the operating system re-packs the packet, depending on the protocols used, and displays it through the eth1 interface.  At the same time, most of the package remains unchanged; only some of its header fields change.  The faster the packet goes through all these stages, the more bandwidth the router can provide.  And if at the time of networks with a capacity of 100 Mbps, the performance problem of routers did not stand so sharply, then with the advent of gigabit speeds there was a need to improve the efficiency of equipment. <br><br>  It is easy to see that such full traffic processing is redundant for most packets of a known type.  By eliminating and redirecting packets at an early stage, which are not intended for the device itself, it is possible to significantly reduce the processing time of passing traffic.  Such processing is most often carried out before the operating system, which reduces time delays.  Due to the minimization of the packet path, this technology is called the fast path.  Since this method of acceleration depends on the low-level part of the network stack and provides for the exchange of information with the network driver, the specific implementation of the fast path technology depends on the equipment used. <br><br><h4>  Marvell Kirkwood processors </h4><br>  Marvell Kirkwood is a system-on-chip based on ARMv5TE-compatible architecture Sheeva.  These processors are designed specifically for use in network devices such as routers, access points, STB devices, network drives, media servers and plug computers. <br><br>  The Kirkwood line consists of processors with one or two cores and an extensive set of peripherals.  The operating frequencies are from 600 MHz to 2 GHz, the entire line carries 256 KB of L2 cache on board.  Older dual-core models boast the presence of FPU. <br><br>  The main characteristics of Marvell Kirkwood processors are presented in the table: <br><table border="1"><tbody><tr><td><p>  <b>CPU</b> </p><br></td><td><p>  <b>Clock frequency</b> </p><br></td><td><p>  <b>Number of Cores</b> </p><br></td><td><p>  <b>Memory interface</b> </p><br></td><td><p>  <b>Ethernet ports</b> </p><br></td><td><p>  <b>PCI-Express</b> </p><br></td><td><p>  <b>USB 2.0</b> </p><br></td><td><p>  <b>SATA 2.0</b> </p><br></td></tr><tr><td><p>  88F6321 </p><br></td><td><p>  800 MHz </p><br></td><td><p>  2 </p><br></td><td><p>  32/40-bit DDR2 up to 800 MHz </p><br></td><td><p>  2GE </p><br></td><td><p>  one </p><br></td><td><p>  one </p><br></td><td><p>  0 </p><br></td></tr><tr><td><p>  88F6322 </p><br></td><td><p>  800 MHz </p><br></td><td><p>  2 </p><br></td><td><p>  32/40-bit DDR2 up to 800 MHz </p><br></td><td><p>  2GE </p><br></td><td><p>  2 </p><br></td><td><p>  2 </p><br></td><td><p>  0 </p><br></td></tr><tr><td><p>  88F6323 </p><br></td><td><p>  1.0 GHz </p><br></td><td><p>  2 </p><br></td><td><p>  32/40-bit DDR2 up to 800 MHz </p><br></td><td><p>  3GE </p><br></td><td><p>  2 </p><br></td><td><p>  3 </p><br></td><td><p>  one </p><br></td></tr><tr><td><p>  88F6282 </p><br></td><td><p>  1.6‚Äî2.0 GHz </p><br></td><td><p>  one </p><br></td><td><p>  16-bit DDR2 / 3 up to 1066 MHz </p><br></td><td><p>  2GE </p><br></td><td><p>  2 </p><br></td><td><p>  one </p><br></td><td><p>  2 </p><br></td></tr><tr><td><p>  88F6283 </p><br></td><td><p>  600 MHz </p><br></td><td><p>  one </p><br></td><td><p>  16-bit DDR2 / 3 up to 1066 MHz </p><br></td><td><p>  2GE </p><br></td><td><p>  2 </p><br></td><td><p>  one </p><br></td><td><p>  2 </p><br></td></tr><tr><td><p>  88F6281 </p><br></td><td><p>  1.0‚Äì1.2 GHz </p><br></td><td><p>  one </p><br></td><td><p>  16-bit DDR2 up to 800 MHz </p><br></td><td><p>  2GE </p><br></td><td><p>  one </p><br></td><td><p>  one </p><br></td><td><p>  2 </p><br></td></tr><tr><td><p>  88F6280 </p><br></td><td><p>  1.0 GHz </p><br></td><td><p>  one </p><br></td><td><p>  16-bit DDR2 up to 400 MHz </p><br></td><td><p>  1GE </p><br></td><td><p>  0 </p><br></td><td><p>  one </p><br></td><td><p>  0 </p><br></td></tr><tr><td><p>  88F6192 </p><br></td><td><p>  800 MHz </p><br></td><td><p>  one </p><br></td><td><p>  16-bit DDR2 up to 400 MHz </p><br></td><td><p>  2GE </p><br></td><td><p>  one </p><br></td><td><p>  one </p><br></td><td><p>  2 </p><br></td></tr><tr><td><p>  88F6190 </p><br></td><td><p>  600 MHz </p><br></td><td><p>  one </p><br></td><td><p>  16-bit DDR2 up to 600 MHz </p><br></td><td><p>  1FE + 1GE </p><br></td><td><p>  one </p><br></td><td><p>  one </p><br></td><td><p>  one </p><br></td></tr><tr><td><p>  88F6180 </p><br></td><td><p>  600-800 MHz </p><br></td><td><p>  one </p><br></td><td><p>  16-bit DDR2 up to 600 MHz </p><br></td><td><p>  1GE </p><br></td><td><p>  one </p><br></td><td><p>  one </p><br></td><td><p>  0 </p><br></td></tr></tbody></table><br><p></p><br><h4>  Network Fast Processing component </h4><br>  Since the line of Kirkwood processors is focused on the use of traffic redirection devices, Marvell also faced the need to implement the fast path technology in their devices.  To solve this problem, Network Fast Processing component, or shortly NFP, was added to the HAL-part of the platform support driver in the Linux 2.6.31.8 kernel. <br><br>  The relationship of Marvell NFP with the rest of the Linux operating system can be represented as follows: <br><br><img src="https://habrastorage.org/files/2c9/f26/505/2c9f26505fbf4e1ca579efd510e9ba30.png"><br><br>  NFP is implemented as a ‚Äúlayer‚Äù between the gigabit interface driver and the operating system's network stack.  In short, the basic principle of accelerating the passage of traffic is to screen incoming routed packets and output them through the necessary interface bypassing the OS.  Those packages that are intended for the local interface, or which cannot be processed within the fast path, are sent to the Linux kernel for processing by standard means. <br><br>  The fast path technology implemented by Marvell does not process all possible packet formats, but only the most common protocols up to the transport layer of the OSI / ISO model.  The chain of supported protocols can be represented as follows: <br><br><pre><code class="html hljs xml">Ethernet (802.3) ‚Üí [ VLAN (802.1) ] ‚Üí [ PPPoE ] ‚Üí IPv4 ‚Üí [ IPSEC ] ‚Üí TCP/UDP</code> </pre> <br>  Support for higher-level protocols is not necessary, since this information is not used to route traffic.  The analysis of transport protocol headers is necessary for the operation of NAT. <br><br>  Due to the modular structure, the settings of the parts used can be made at the compilation stage of the Linux kernel.  The following optional parts can be distinguished: <br><br><ul><li>  FDB_SUPPORT is a hash table for matching MAC addresses and interfaces. </li><li>  PPP - PPPoE protocol support. </li><li>  NAT_SUPPORT - support for IP address translation. </li><li>  SEC - support for IPSec encryption protocol. </li><li>  TOS - replacing the type of service field in the IP header based on iptables rules. </li></ul><br>  FDB (forwarding database) - a traffic redirection database located in the Linux kernel.  Unlike the routing table, FDB is optimized for quick search of records.  Marvell‚Äôs fast path implementation uses its own local ruleDb rule table, which, like the deletion, writes from the OS network stack (the corresponding changes have been made to the stack code). <br><br>  For quick lookup, ruleDB is a hash table with key-value pairs, where the value is the packet forwarding rule with a specific destination address, and the key for quick indexing of this rule is the index generated from source and destination addresses using a special hash function.  The optimally constructed hash function guarantees maximum chances that one rule will correspond to one index. <br><br>  Since initially FDB (and, therefore, ruleDb) is empty, every first packet (packet without an existing entry in FDB) is sent to the OS kernel, where after processing a rule is created.  After a certain timeout has elapsed, this entry will be removed from the FDB and from ruleDB to the NFP. <br><br>  Consider the processing of traffic in more detail: <br><br><ol><li>  The raw data of the received packet is transferred to the NFP input. </li><li>  If the packet is destined for a multicast MAC address, it is sent to the OS TCP / IP stack. </li><li>  If FDB is used and there is no entry in the table for this MAC address, the packet is sent to the OS stack. </li><li>  An entry for this MAC address is retrieved from FDB.  If the address is not marked as local, the system recognizes it as connected in bridge mode and sends the packet through the interface specified in the FDB table entry. </li><li>  If a VLAN or PPPoE header is detected, it is discarded and a link to the beginning of the IP header is calculated. </li><li>  Packets marked as fragments are transferred to the OS network stack. </li><li>  If the packet contains ICMP protocol data, the packet is sent to the stack. </li><li>  Packets with an expired lifetime are sent to the OS stack.  Of course, such packets should be dropped, but the ICMP TTL expired response should be generated by the operating system. </li><li>  There is a check for the presence of the IPSec protocol header and the corresponding processing of such packets with certificate verification. </li><li>  Next, we look for the Destination NAT rule to determine the destination IP address for this packet. </li><li>  If there is no route for the existing destination address, the packet is sent to the network stack.  Such packets must also be discarded, but a corresponding ICMP response must be generated. </li><li>  Next, we look for the Source NAT rule and update the IP and TCP / UDP header fields, taking into account the DNAT and SNAT rules. </li><li>  Based on the routing table, the interface is calculated through which the packet must be output. </li><li>  If PPP tunneling is used for the output interface, the IP packet wraps around the PPPoE header, first reducing TTL and updating the Ethernet header.  Since in this case the checksum of the IP packet cannot be calculated in hardware, it is necessary to recalculate the checksum.  But since the old checksum and the change in the packet data are known, the sum is not calculated completely, but is only adjusted to the required value. </li><li>  If the packet size exceeds the maximum - the packet is sent to the OS stack. </li><li>  In other cases, the Ethernet header, checksum, and type of service fields are updated (if necessary, and there is a record in iptables). </li><li>  The received Ethernet packet is output via the appropriate network interface. </li></ol><br>  This sequence of checks can be represented graphically in the form of a diagram: <br><br><img src="https://habrastorage.org/files/2d4/adc/5e1/2d4adc5e116444f5a44e19395eaf80a5.png"><br>  <sup>Chart ‚ÄúPackage Processing in NFP‚Äù</sup> <br><br>  It is easy to see that the processing of traffic in NFP is a set of checks for the most common special cases; it is not a universal solution for all types of packets.  However, in most cases such a set of protocols is sufficient for a noticeable increase in the performance of routing in the network. <br><br>  As for the shortcomings of the implementation of the fast path technology in Marvell, one cannot help but notice cases of sending traffic to the OS kernel in case of any need for ICMP packet generation.  This will lead to increased load on the router in case of network attacks or any other increased amount of ICMP traffic. <br><br>  In case of a large amount of multicast traffic, the router will also experience increased load, since this traffic is not processed by NFP and passes through the OS network stack. <br><br>  Also, this implementation does not support IPv6, but the developers have provided the possibility of its support in the future. <br><br>  As for the shortcomings of the fast path technology as a whole, one can notice the fact that in any case it shares processor time with the operating system, which means it does not use all possible resources.  This problem is easily solved by Marvell multiprocessor solutions, such as Armada XP quad-core processors. <br><br><h4>  Router Performance Measurement </h4><br>  How much does Network Fast Processing have a real impact on the performance of a router?  To answer this question, we estimate the speed of packets passing through the router with NFP turned on and off. <br><br>  As a test device, we take a router based on a Marvell Kirkwood 88F6282 system on a chip with a clock frequency of 1 GHz.  This processor has two 1000Base-TX network interfaces on board, which makes it a good choice for this type of device. <br><br><img src="https://habrastorage.org/files/3c4/6b1/acf/3c46b1acf55240988d4a0b07e62d87f1.png"><br>  <sup>In the diagram: the architecture of the Markell Kirkwood 88F6282 SoC</sup> <br><br>  Network traffic in most networks is not consistent over time, so a hardware or software traffic generator is needed to evaluate the actual performance.  Let's consider several possible options for software package generation. <br><br>  <b>PackETH</b> is a GUI utility for generating Ethernet frames, there are versions for it under Linux, Windows and Mac.  This is one of the easiest to use tools for generating traffic, it has the following features: <br><br><ul><li>  Frame generation Ethernet II, Ethernet 802.3, 802.1q, QinQ or user-defined. </li><li>  Supports ARP, IPv4, IPv6, UDP, TCP, ICMP, ICMPv6, IGMP, RTP (with the ability to set the payload) or user-defined. </li><li>  Jumbo frame generation (if supported by the driver). </li><li>  Sending a queue of packets with a custom delay and the number of packets. </li><li>  Ability to save settings. </li></ul><br>  The graphical interface of the utility looks like this: <br><br><img src="https://habrastorage.org/files/3eb/f16/5da/3ebf165daa474c2ea309e8b8c3191e2b.png"><br>  <sup>PackETH utility interface</sup> <br><br>  <b>iperf</b> is another solution for generating traffic, it is much more common, but it almost does not offer any options for setting the packet format.  This console utility can measure network bandwidth by generating and receiving TCP and UDP packets. <br><br>  To use it, just launch one copy of the application in server mode with the command: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iperf -s</span></span></code> </pre><br>  And another copy on the second machine in client mode with the address or server name: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># iperf -c server_host</span></span></code> </pre><br>  Within 10 seconds, the program will measure the network bandwidth and give the result. <br><br>  The ability to directly generate UDP traffic is also provided by the pktgen kernel module.  You can configure the parameters of the generated packages in the procfs file system‚Äôs / proc / net / pktgen directory.  The simplest configuration is defined as follows: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># echo "add_device eth0" &gt; /proc/net/pktgen/kpktgend_0 # echo "count 1000" &gt; /proc/net/pktgen/eth0 # echo "dst 192.168.1.1" &gt; /proc/net/pktgen/eth0 # echo "pkt_size 1000" &gt; /proc/net/pktgen/eth0 # echo "delay 50" &gt; /proc/net/pktgen/eth0</span></span></code> </pre><br>  Run the generator: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># echo "start" &gt; /proc/net/pktgen/pgctrl</span></span></code> </pre><br>  After completion of the generator in its status / proc / net / pktgen / eth0, the sending speed will be displayed. <br><br>  The main advantage of pktgen is that it generates a packet for transmission only once, and then sends copies of this packet, which allows it to achieve higher speeds. <br><br>  There are other solutions for generating traffic and measuring network bandwidth, such as brute, netperf, mpstat or sprayd. <br><br>  Since we do not have the task of verifying all possible cases, iperf capabilities will suffice.  We will send TCP and UDP packets of 1400 bytes in two modes - with Network Fast Processing turned off and on.  The NFP can be directly managed via procfs using the manager /proc/net/mv_eth_tool. For example, in order to disable the NFP, it is enough to send the command ‚Äúc 0‚Äù to the manager: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># echo "c 0" &gt; /proc/net/mv_eth_tool</span></span></code> </pre><br>  Where "c" is the command code, "0" is the NFP status to be set. <br><br>  Let's measure network performance in these modes and enter the results: <br><table border="1"><tbody><tr><td><p>  <b>Package type</b> </p><br></td><td><p>  <b>Tcp</b> </p><br></td><td><p>  <b>UDP</b> </p><br></td></tr><tr><td><p>  Package size, byte </p><br></td><td><p>  1400 </p><br></td><td><p>  1400 </p><br></td></tr><tr><td><p>  Bandwidth without NFP, Mbps </p><br></td><td><p>  281 </p><br></td><td><p>  338 </p><br></td></tr><tr><td><p>  Bandwidth with NFP, Mbps </p><br></td><td><p>  551 </p><br></td><td><p>  552 </p><br></td></tr></tbody></table><br>  Since the actual bandwidth strongly depends on the device configuration and running applications, it is not worthwhile to focus on the absolute values ‚Äã‚Äãobtained.  But first of all, we are interested in productivity growth with the inclusion of NFP.  As you can see, in the case of TCP traffic, the bandwidth has almost doubled (by 96%), which is quite noticeable.  For UDP packets, the effect is not so strong - an increase of 63% was recorded, but this is also a good result. <br><br><h4>  Examples of our development </h4><br><img src="https://habrastorage.org/files/26d/479/2c8/26d4792c81c142a9997de7d4da9502a5.jpg"><br><ol><li>  One of the examples of our developments in which the fast path technology was used is the thin-client AK1100, which we <a href="http://habrahabr.ru/company/promwad/blog/241626/">already talked about in Habr√©</a> .  The hardware platform of this device is based on Marvell Kirkwood 88F6282 (Sheeva core; 1.6 GHz).  This processor has two Gigabit Ethernet (connected to Marvell's external PHY 88E1121R) and two PCIe ports: the first port is used to connect the GPU, and the second is connected to the internal mini-PCI connector, to which additional external devices or WI-FI modules can be connected .  In more detail about the project from the technical point of view it is told here: <a href="http://promwad.ru/sites/default/files/portfolio/download/CaseStudy-thin-client-ak1100-ru_0.pdf">development of the thin-client</a> . </li><li>  Another example is the mini-server IP-Plug, the first commercial plug-in computer in Russia and our first project on the Marvell processor.  The device was designed based on Marvell Kirkwood 88F6283 and Linux Debian 6.0.  We will also tell on Habr√© how NetBSD was installed on this plug-in, for now attentive readers can get acquainted with the detailed description of the device here: <a href="http://promwad.ru/sites/default/files/portfolio/download/caseStudy-ak-systems-ip-plug-mini-server-ru.pdf">mini-server development</a> . </li></ol><br><br><h4>  findings </h4><br>  It would seem that at the current level of technology development, such a problem as a lack of productivity should become irrelevant.  However, in some projects, the developers of the electronics center Promwad still face the need to control energy consumption or a rigid cost framework.  In such cases, NFP helps us to significantly increase the efficiency of the device exclusively by software. <br><br>  Of course, Network Fast Processing is not a universal solution, and in the case of using non-standard protocols it can even prevent the correct routing of traffic.  But in most cases, software engineers can optimize NFP to specified conditions and get all the advantages of fast path technology in developed devices. </div><p>Source: <a href="https://habr.com/ru/post/243447/">https://habr.com/ru/post/243447/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243431/index.html">Why you should never say "never"</a></li>
<li><a href="../243433/index.html">How we tested the dependence of LTE speed on S1 parameters</a></li>
<li><a href="../243437/index.html">C ++ code refactoring in Visual Studio 2015</a></li>
<li><a href="../243439/index.html">Document life cycle in professional help system. A little fabulous post about how a pile of paper turns into a system</a></li>
<li><a href="../243441/index.html">Kiev Speakers' Corner with Moti Granovsky: "Intelligence to the masses: BI today & in the future", November 26</a></li>
<li><a href="../243449/index.html">How to make profitable design development sites (part 5)</a></li>
<li><a href="../243451/index.html">Battle key-value vaults</a></li>
<li><a href="../243453/index.html">OpenStack predicts the renaissance of the cloud service market, flexibility should come first</a></li>
<li><a href="../243457/index.html">Solar system on graphics2d.js</a></li>
<li><a href="../243461/index.html">Solving problems on the determination of a fake coin weighing 2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>