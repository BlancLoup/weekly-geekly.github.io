<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn ActionBlock: or a short story about otherwise deadlock</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I think that almost every real project uses one or another form of implementation of the supplier -consumer queue . The idea behind the problem is qui...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn ActionBlock: or a short story about otherwise deadlock</h1><div class="post__text post__text-html js-mediator-article">  I think that almost every real project uses one or another form of implementation of the supplier <a href="https://en.wikipedia.org/wiki/Producer%25E2%2580%2593consumer_problem">-consumer queue</a> .  The idea behind the problem is quite simple.  The application needs to unleash the production of some data from their processing.  Take, for example, the thread pool in the CLR: we add an item for processing by calling <b>ThreadPool.QueueUserWorkItem</b> , and the thread pool itself decides what number of worker threads are most optimal and calls methods to process items with the right degree of parallelism. <br><br>  But using a standard thread pool is not always possible and / or reasonable.  Although it is possible to specify the minimum and maximum number of threads, this configuration is global and will affect the application as a whole, rather than the parts it needs.  There are many other ways to solve the problem of the supplier of the consumer.  It can be a head-on solution when the application logic is mixed with aspects of multithreading, queues, and synchronization.  It can be a wrapper over the <a href="https://msdn.microsoft.com/en-us/library/dd267312%2528v%3Dvs.110%2529.aspx%3Ff%3D255%26amp%3BMSPPError%3D-2147217396">BlockingCollection</a> with manual control of the number of workflows or tasks.  Or it could be a solution based on a completely turnkey solution, such as an <a href="https://msdn.microsoft.com/en-us/library/hh194684(v%3Dvs.110).aspx">ActionBlock &lt;T&gt;</a> from a TPL DataFlow. <br><br>  Today we will look at the internal device of the <b>ActionBlock</b> class, discuss the design decisions that were made by its authors and find out why we need to know all this in order to get around some of the problems when using it.  Ready?  Well then, let's go! <br><a name="habracut"></a><br>  On my current project we have a number of cases when we need to solve the problem of the supplier-consumer.  One of them looks like this: we have a custom parser and interpreter for a language very similar to TypeScript.  Without going deep into details, we can say that we need to parse a set of files and get the so-called "transitive closure" of all dependencies.  Then they need to be converted into a performance suitable for execution and execute. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The parsing logic looks like this: <br><br><ol><li>  Parsim file. </li><li>  We analyze its contents and look for its dependencies (by analyzing all the 'import * from', 'require' and similar constructions). </li><li>  We calculate the dependencies (i.e., we find the set of files that are required by the current file for normal operation). </li><li>  Add the resulting file dependencies to the list for parsing. </li></ol><br>  Pretty simple, isn't it?  And there is.  Here is how a slightly simplified implementation based on TPL Dataflow and the <b>ActionBlock &lt;T&gt;</b> class will look like: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Task&lt;ParsedFile&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParseFileAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> path</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Parsing '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{path}</span></span></span><span class="hljs-string">'. {{0}}"</span></span>, <span class="hljs-string"><span class="hljs-string">$"Thread Id - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Task.FromResult( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ParsedFile() { FileName = path, Dependencies = GetFileDependencies(path), }); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> numberOfProcessedFiles = <span class="hljs-number"><span class="hljs-number">0</span></span>; ActionBlock&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; actionBlock = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, Task&gt; processFile = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> path =&gt; { Interlocked.Increment(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> numberOfProcessedFiles); ParsedFile parsedFile = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ParseFileAsync(path); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dependency <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parsedFile.Dependencies) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Sending '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{dependency}</span></span></span><span class="hljs-string">' to the queue... {{0}}"</span></span>, <span class="hljs-string"><span class="hljs-string">$"Thread Id - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{Thread.CurrentThread.ManagedThreadId}</span></span></span><span class="hljs-string">"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> actionBlock.SendAsync(dependency); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actionBlock.InputCount == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// This is a marker that this is a last file and there // is nothing to process actionBlock.Complete(); } }; actionBlock = new ActionBlock&lt;string&gt;(processFile); actionBlock.SendAsync("FooBar.ts").GetAwaiter().GetResult(); Console.WriteLine("Waiting for an action block to finish..."); actionBlock.Completion.GetAwaiter().GetResult(); Console.WriteLine($"Done. Processed {numberOfProcessedFiles}"); Console.ReadLine(); }</span></span></code> </pre> <br>  Let's see what happens here.  For simplicity, all the main logic is in the <b>Main</b> method.  The variable <b>numberOfProcessedFiles is</b> used to validate the logic and contains the total number of processed files.  The main work is done in the <b>processFile</b> delegate, which is then passed to the <b>ActionBlock</b> constructor.  This delegate simultaneously plays the role of "consumer" and "supplier": it takes the path to the file through the <b>path</b> argument, parses the file, finds its dependencies, and sends new files to the queue by calling the <b>actionBlock.SendAsync</b> method.  Then there is a check of the number of elements in the processing queue, and if there are no new elements, the whole operation is completed by calling <b>actionBlock.Complete ()</b> (*).  Then, the <b>Main</b> method creates an instance of <b>ActionBlock</b> , starts processing the first file, and waits until the end of the entire process. <br><br>  The <b>ParseFileAsync</b> method emulates the file parsing process and calculates dependencies using the following primitive logic: the file 'foo.ts' depends on 'fo.ts', which depends on 'f.ts'.  Those.  each file depends on a file with a shorter name.  This is unrealistic logic, but it allows you to show the basic idea of ‚Äã‚Äãcalculating the transitive closure of files. <br><br>  The <b>ActionBlock</b> class manages concurrency for you.  The truth is that it should be taken into account that the default ‚Äúdegree of parallelism‚Äù (degree of parallelism) is 1 and to change this, you must pass an instance of the class <b><a href="https://msdn.microsoft.com/en-us/library/system.threading.tasks.dataflow.executiondataflowblockoptions(v%3Dvs.110).aspx">ExecutionDataflowBlockOptions</a></b> in the <b>ActionBlock</b> constructor.  If the <b><a href="https://msdn.microsoft.com/en-us/library/system.threading.tasks.dataflow.executiondataflowblockoptions.maxdegreeofparallelism(v%3Dvs.110).aspx">MaxDegreeOfParallelism</a></b> property is greater than 1, then the <b>ActionBlock</b> will call a callback delegate from different threads (in fact, from different tasks) for parallel processing of queue elements. <br><br><h3>  Post vs.  SendAsync: what and when to use </h3><br>  Everyone who at least once tried to independently solve the problem of the supplier-consumer faced the problem: what to do when the flow of input data exceeds the capabilities of consumers in processing?  How do you throttle the input stream?  Just keep all input elements in memory?  Generate an exception?  Return <b>false</b> in the add item method?  Use a circular buffer and discard old items?  Or block the execution of this method until there is a place in the queue? <br><br>  To solve this problem, the <b>ActionBlock</b> authors decided to use the following generally accepted approach: <br><br><ol><li>  The client can set the queue size when creating an <b>ActionBlock</b> object. </li><li>  If the queue is full, the <b><a href="https://msdn.microsoft.com/en-us/library/hh462696(v%3Dvs.110).aspx">Post</a></b> method returns <b>false</b> , and the <b><a href="https://msdn.microsoft.com/en-us/library/hh194681(v%3Dvs.110).aspx">SendAsync</a></b> extension <b><a href="https://msdn.microsoft.com/en-us/library/hh194681(v%3Dvs.110).aspx">method</a></b> returns the task to be completed when free space appears in the queue. </li></ol><br>  In our previous example, we did not specify the queue size.  This means that if new elements are added faster than they are processed, the application will sooner or later fall with an <b>OutOfMemoryException</b> .  But let's try to fix this situation.  And set the queue is very small, for example, in 1 element. <br><br><pre> <code class="cs hljs">actionBlock = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActionBlock&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(processFile, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ExecutionDataflowBlockOptions() {BoundedCapacity = <span class="hljs-number"><span class="hljs-number">1</span></span>});</code> </pre> <br>  Now, if we run this code, we get ... deadlock! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d4a/e6d/7d4/d4ae6d7d4d23019a56c7c0dc38bc818a.png" alt="image"></div><br><h3>  Deadlock </h3><br>  Let's think about the problem of the consumer-supplier in terms of design.  We write our own queue, which accepts a callback method for handling elements.  We need to decide whether it should support limiting the number of elements or not.  If we need a ‚Äúbounded‚Äù queue, then we will probably come up with a design that is very similar to the <b>ActionBlock</b> class <b>design</b> : we will add a synchronous method for adding elements, which will return <b>false</b> if the queue is full, and an asynchronous method that will return the task.  In the case of a full queue, the client of our class will have the opportunity to decide what to do: handle the ‚Äúoverflow‚Äù by calling the synchronous version of adding items or ‚Äúwaiting‚Äù (await) for free space in the queue using the asynchronous version. <br><br>  Then you will need to decide when to call the callback method.  As a result, you can come to the following logic: if the queue is not empty, then the first element is taken, the callback method is called, processing is expected to complete, after which the element is removed from the queue.  (The actual implementation will be significantly more difficult than it seems, simply because it must take into account all sorts of races).  The queue may decide to remove the item before calling the callback method, but, as we will see shortly, this will not affect the ability to receive deadlock. <br><br>  We have come to a simple and elegant design, but it can easily lead to a problem.  Suppose the queue is full and a callback call is in progress to process one of the items.  But what if, instead of quickly ‚Äúreturning‚Äù the management queue, the handler tries to add another element by calling <b>await</b> <b>SendAsync</b> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/173/47b/d56/17347bd5653091359035925ed1ca1c79.png" alt="image"></div><br>  The queue is full and cannot accept new items, because the callback method is not yet complete.  But this method is also stuck waiting for <b>await</b> <b>SendAsync to complete</b> and can not move on until the place <b>becomes</b> free in the queue.  Classic deadlock! <br><br>  Ok, we get deadlock, because <b>ActionBlock</b> removes an item from the queue * after * completing the callback method.  But let's consider an alternative scenario: what happens if the <b>ActionBlock deletes the</b> element * before * calling the callback method?  In fact, nothing will change.  Deadlock will still be possible. <br><br>  Imagine that the queue size is one, and the degree of parallelism is two. <br><br><ul><li>  The T1 thread adds an item to the queue.  <b>ActionBlock</b> takes an item from the queue (reducing the number of items in the queue to 0) and calls the callback method. </li><li>  The T2 thread adds an item to the queue.  <b>ActionBlock</b> takes an item from the queue (reducing the number of items in the queue to 0) and calls the callback method. </li><li>  The T1 thread adds an item to the queue.  ActionBlock cannot call the handler of a new element, since the level of parallelism is 2, and we already have two handlers.  <b>The queue is full.</b> </li><li>  The first handler during processing tries to add a new item in the queue, but sticks on the call ' <b>await SendAsync</b> ', because the queue is full. </li><li>  The second handler tries to add a new item in the queue during processing, but it sticks on the ' <b>await SendAsync</b> ' call because the queue is full. </li></ul><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b6f/632/8bc/b6f6328bce365eba65c7890d811b4247.png" alt="image"></div><br>  It turns out that removing an item from the queue before processing does not help.  Moreover, this will only exacerbate the problem, since the likelihood of the de-block is significantly reduced (it is necessary that with a degree of concurrency equal to N, all N callback methods try to add new items to the queue at the same time). <br><br>  Another disadvantage is less obvious.  <b>ActionBlock</b> is not a general-purpose solution.  This class implements the <b>ITargetSource</b> interface and can be used to process elements in complex dataflow scenarios.  For example, we can have a <b>BufferBlock</b> with several ‚Äútarget‚Äù blocks for parallel processing of elements.  In the current implementation, balancing handlers is implemented in a trivial way.  As soon as the receiver (in our case <b>ActionBlock</b> ) is full, it stops accepting new elements as input.  This allows other blocks in the chain to process the element instead. <br><br>  If an element is deleted only after it has been processed, the ActionBlock will become more greedy and will accept more elements than it can handle at the moment.  In this case, the size (bounded capacity) of each block will be equal to 'BoundedCapaciy' + 'MaxDegreeOfParallelism'. <br><br><h3>  How to solve the problem with deadlock? </h3><br>  I'm afraid that way.  If at the same time you need to limit the number of elements in the queue and the callback method can add new elements, then <b>ActionBlock</b> will have to be abandoned.  An alternative would be a solution based on the <b>BlockingCollection</b> and ‚Äúmanual‚Äù control of the number of workflows, for example, using a task pool or Parallel.Invoke. <br><br><h3>  Degree of Parallelism </h3><br>  Unlike primitives from TPL, all blocks from TPL Dataflow, by default, are single-threaded.  Those.  <b>ActionBlock</b> , <b>TransformerBlock,</b> and others call the callback method one at a time.  The authors of TPL Dataflow decided that simplicity is more important than possible performance gains.  Thinking about dataflow graphs is generally quite difficult, and parallel data processing by all blocks will make this process even harder. <br><br>  To change the degree of parallelism, the block needs to pass <b>ExecutionDataflowBlockOptions</b> and set the <b>MaxDegreeOfParallelism</b> property <b>to a</b> value greater than 1. By the way, if this property is set to -1, then all incoming elements will be processed by the new task and parallelism will be limited only by the capabilities of the used task scheduler ( <b>TaskScheduler</b> object), which can also be passed via <b>ExecutionDataflowBlockOptions</b> . <br><br><h3>  Conclusion </h3><br>  Designing easy-to-use components is challenging.  Designing easy-to-use components that solve concurrency issues is doubly more complicated.  To use these components correctly, you need to know how they are implemented and what restrictions their developers have in mind. <br><br>  The class <b>ActionBlock &lt;T&gt;</b> is a great thing that greatly simplifies the implementation of the supplier-consumer pattern.  But even in this case, you should be aware of some aspects of TPL Dataflow, like the degree of parallelism and the behavior of blocks in the event of overflow. <br><br>  - (*) This example is not thread-safe and a full implementation should not use <b>actionBlock.InputCount</b> .  Do you see a problem? <br><br>  (**) The <b>Post</b> method returns <b>false</b> in one of two cases: the queue is full or already completed (the <b>Complete</b> method is called).  This aspect may make it difficult to use this method, since it is impossible to distinguish between these two cases.  The <b>SendAsync</b> method, on the other hand, behaves somewhat differently: the method returns a <b>Task &lt;bool&gt;</b> object, which will be in an incomplete state while the queue is full, and if the queue is already completed and not able to accept new items, the <b>task.Result</b> will be <b>false</b> . </div><p>Source: <a href="https://habr.com/ru/post/319208/">https://habr.com/ru/post/319208/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319196/index.html">How does the language support service for 1237 Russian IT engineers work, and how does this differ from conventional translation?</a></li>
<li><a href="../319198/index.html">The history of the development of Tower Defense for VK and Android</a></li>
<li><a href="../319200/index.html">Python: collections, part 2/4: indexing, slicing, sorting</a></li>
<li><a href="../319202/index.html">Pure Python Architecture: A Walkthrough. Part 2</a></li>
<li><a href="../319204/index.html">VulnHub: Parse the shortest quest DC416 Fortress</a></li>
<li><a href="../319210/index.html">Bitrix Start Performance on Proxmox and Virtuozzo 7 & Virtuozzo Storage</a></li>
<li><a href="../319212/index.html">"IT infrastructure": Where we go with the "cloud" in 2017</a></li>
<li><a href="../319214/index.html">Cheap Ways to Heat Up Storage with an SSD</a></li>
<li><a href="../319216/index.html">Simple FDTD implementation in Java</a></li>
<li><a href="../319218/index.html">Detection in the code of the defect "null pointer dereferencing"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>