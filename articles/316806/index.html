<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>htop and more on your fingers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For a long time, I did not fully understand htop. I thought that the average load [load average] of 1.0 means that the processor is 50% loaded, but th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>htop and more on your fingers</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac4/066/032/ac40660327d5febdfe8da4d9c6502781.png"></div><br><br>  For a long time, I did not fully understand htop.  I thought that the average load [load average] of 1.0 means that the processor is 50% loaded, but this is not the case.  And then, why 1.0? <br><br>  Then I decided to sort it all out and write about it.  It is said that the best way to learn something new is to try to explain it. <br><a name="habracut"></a><br><h1>  htop on Ubuntu Server 16.04 x64 </h1><br>  Below is a screenshot of htop, which I will discuss in the article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e04/60f/e96/e0460fe96167c473800dc888eafceda9.png"></div><br><br><h1>  Uptime </h1><br>  Uptime shows the time of continuous system operation.  This can be recognized by the <b>uptime</b> team. <br><br><pre><code class="bash hljs">$ uptime 12:17:58 up 111 days, 31 min,  1 user,  load average: 0.00, 0.01, 0.05</code> </pre> <br>  Where does the <b>uptime</b> program take it?  It reads information from the <b>/ proc / uptime</b> file. <br><br><pre> <code class="bash hljs">9592411.58 9566042.33</code> </pre> <br>  The first number is the number of seconds the system has been running.  The second shows how many seconds the system was idle.  It is worth noting that on systems with multiple processors, the second indicator may be larger than the first, since this is the sum of the processors. <br><br>  How did I find out about this?  I looked at what files opens <b>uptime</b> at startup.  For this, you can use the <b>strace</b> utility. <br><br><pre> <code class="bash hljs">strace uptime</code> </pre> <br>  There will be a lot of output, it is better to make <b>grep</b> to search for the <b>open</b> system call.  But this does not quite work, because  by default it outputs to standard error stream (stderr).  You can redirect stderr to the standard stream with <b>2&gt; &amp; 1</b> . <br><br>  The result is: <br><br><pre> <code class="bash hljs">$ strace uptime 2&gt;&amp;1 | grep open ... open(<span class="hljs-string"><span class="hljs-string">"/proc/uptime"</span></span>, O_RDONLY)          = 3 open(<span class="hljs-string"><span class="hljs-string">"/var/run/utmp"</span></span>, O_RDONLY|O_CLOEXEC) = 4 open(<span class="hljs-string"><span class="hljs-string">"/proc/loadavg"</span></span>, O_RDONLY)         = 4</code> </pre> <br>  This contains the mentioned <b>/ proc / uptime</b> file.  It turned out that it is enough to run <b>strace -e open uptime</b> and not suffer with <b>grep</b> . <br><br>  If you can take it directly from the file, then why do we need the <b>uptime</b> utility?  The fact is that <b>uptime</b> formats the output in a readable form, whereas seconds in the file are convenient to use when writing your own scripts and programs. <br><br><h1>  Load average </h1><br>  In addition to the time of continuous work, uptime shows the average load of the system, they are displayed as 3 numbers. <br><br><pre> <code class="bash hljs">$ uptime 12:59:09 up 32 min,  1 user,  load average: 0.00, 0.01, 0.03</code> </pre> <br>  And they are taken from the file <b>/ proc / loadavg</b> .  If you look at the <b>strace</b> output again, you will notice that this file has also been opened. <br><br><pre> <code class="bash hljs">$ cat /proc/loadavg 0.00 0.01 0.03 1/120 1500</code> </pre> <br>  The first 3 numbers measure the average system load for the last 1, 5 and 15 minutes.  The 4th parameter is the number of active processes and their total number.  The last number is the ID of the last process used. <br><br>  Let's start from the end. <br><br>  When the process starts, it is assigned an ID.  As a rule, they go in ascending order, except for cases when the number has been exhausted and the system has to start counting anew.  ID 1 is assigned to the <b>/ sbin / init</b> process, which starts at startup. <br><br>  Take another look at <b>/ proc / loadavg</b> and try to run the <b>sleep</b> command in the background.  When running in the background, you can see the process ID. <br><br><pre> <code class="bash hljs">$ cat /proc/loadavg 0.00 0.01 0.03 1/123 1566 $ sleep 10 &amp; [1] 1567</code> </pre> <br>  Thus, <b>1/123</b> means that 1 process is executed or is ready for execution, and there are 123 of them. <br><br>  When you start <b>htop</b> , you see that only one process is running, it is the htop process itself. <br><br>  If you start <b>sleep 30</b> and open <b>htop</b> , then the number of running processes will still be 1. This is because the <b>sleep</b> process is not executed, but ‚Äúsleeps‚Äù, i.e.  is at rest, in other words, waiting for a certain event.  A running or active process is a process that is currently being processed in a processor (CPU), or is waiting for its turn in the processor. <br><br>  Try running <b>cat / dev / urandom&gt; / dev / null</b> , where the random bytes generated are written to a special file that cannot be read from.  Then you will see that the running processes are now 2. <br><br><pre> <code class="bash hljs">$ cat /dev/urandom &gt; /dev/null &amp; [1] 1639 $ cat /proc/loadavg 1.00 0.69 0.35 2/124 1679</code> </pre> <br>  So, there are exactly 2 active processes (random number generator and <b>cat</b> utility, which reads the <b>/ proc / loadavg file</b> ), you can still notice that the average load has increased. <br><br>  <b>load average</b> is the average system load over a period of time. <br><br>  The number of downloads is counted as the sum of the number of processes that are running (are running or are awaiting launch) and uninterrupted processes (the types of processes will be described below).  Those.  it's just the number of processes. <br><br>  And the average load is obtained just an average value for 1, 5 and 15 minutes, right? <br><br>  It turns out that not everything is so simple. <br><br>  Mathematically speaking, all three values ‚Äã‚Äãaverage load average over the entire system operation time.  They become obsolete exponentially, but at different speeds.  Thus, the average load for 1 minute is the sum of 63% of the load for the last minute + 37% of the load since the launch without taking into account the last minute.  The same ratio is true for 5, 15 minutes.  Therefore, it is not quite true that the average load for the last minute includes activity only for the last minute, but most of it for the last minute. <br><br>  Did you know that? <br><br>  Let's go back to the random number generator. <br><br><pre> <code class="bash hljs">$ cat /proc/loadavg 1.00 0.69 0.35 2/124 1679</code> </pre> <br>  Although this is not entirely correct, but this is how I have simplified the average load indicator for understanding. <br><br>  In this case, the generator uses a processor, the average load per last minute is <b>1.00</b> , in other words, an average of 1 process running. <br><br>  In my system, this means that the processor is 100% loaded, because  the processor is one, and it can only perform one process at a time. <br><br>  If there were 2 processors, then the load would accordingly be 50%, since  2 processes could be performed simultaneously.  The maximum average load (100% CPU usage) of a dual processor system is <b>2.00</b> . <br><br>  The number of processors in the system can be found in the upper left corner of <b>htop</b> or with the help of <b>nproc</b> . <br><br><h1>  Processes </h1><br>  In the upper right corner, <b>htop</b> shows the total number of processes and how many of them are active.  But why are tasks written there [Tasks], and not processes? <br><br>  A task is synonymous with a process.  In the Linux kernel, processes are tasks.  <b>htop</b> uses the term job, perhaps because the name is shorter and saves a bit of space. <br>  In <b>htop,</b> you can see the threads.  To switch this option you need to use the combination <i>Shift + H.</i>  If something like <b>Tasks is</b> displayed <b>: 23, 10 thr</b> , it means they are visible. <br><br>  The display of kernel threads [kernel threads] can be enabled with <i>Shift + K</i> , and then the tasks will look like <b>Tasks: 23, 40 kthr</b> . <br><br><h1>  Process ID / PID </h1><br>  Each time the process starts, it is assigned an identifier (ID), abbreviated PID. <br><br>  If you run the program in the background ( <b>&amp;</b> ) from <b>bash</b> , then the [job] task number is displayed in square brackets, and next to it is the process PID. <br><br><pre> <code class="bash hljs">$ sleep 1000 &amp; [1] 12503</code> </pre> <br>  Another way is to use the <b>$</b> variable <b>!</b>  in <b>bash</b> , which stores the PID of the last process running in the background. <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> $! 12503</code> </pre> <br>  The process id is very useful.  With it, you can learn the details of the process and manage it. <br><br>  There is a pseudo <b>procfs</b> file system with which programs can get information from the system kernel by reading files.  Most often it is mounted in <b>/ proc /</b> and for the user it looks like a normal directory that can be viewed with commands such as <b>ls</b> and <b>cd</b> . <br><br>  All information about the process is in <b>/ proc / &lt;id&gt; /</b> . <br>  $ ls / proc / 12503 <br><br><pre> <code class="bash hljs">attr        coredump_filter  fdinfo     maps        ns             personality  smaps    task auxv        cpuset           gid_map    mem         numa_maps      projid_map   stack    uid_map cgroup      cwd              io         mountinfo   oom_adj        root         <span class="hljs-built_in"><span class="hljs-built_in">stat</span></span>     wchan clear_refs  environ          limits     mounts      oom_score      schedstat    statm cmdline     exe              loginuid   mountstats  oom_score_adj  sessionid    status comm        fd               map_files  net         pagemap        setgroups    syscall</code> </pre> <br>  For example, <b>/ proc / &lt;id&gt; / cmdline</b> contains a command with which the process started. <br><br><pre> <code class="bash hljs">$ cat /proc/12503/cmdline sleep1000$</code> </pre> <br>  Um ... not exactly like that.  The delimiter here is the byte <b>\ 0</b> , <br><br><pre> <code class="bash hljs">$ od -c /proc/12503/cmdline 0000000   s   l   e   e   p  \0   1   0   0   0  \0 0000013</code> </pre> <br>  which can be replaced with a space or a line break <br><br><pre> <code class="bash hljs">$ tr <span class="hljs-string"><span class="hljs-string">'\0'</span></span> <span class="hljs-string"><span class="hljs-string">'\n'</span></span> &lt; /proc/12503/cmdline sleep 1000 $ strings /proc/12503/cmdline sleep 1000</code> </pre> <br>  There may be links in the process catalog!  For example, <b>cwd</b> refers to the current working directory, and <b>exe</b> to the running executable file. <br><br><pre> <code class="bash hljs">$ ls -l /proc/12503/{cwd,exe} lrwxrwxrwx 1 ubuntu ubuntu 0 Jul  6 10:10 /proc/12503/cwd -&gt; /home/ubuntu lrwxrwxrwx 1 ubuntu ubuntu 0 Jul  6 10:10 /proc/12503/exe -&gt; /bin/sleep</code> </pre> <br>  Thus, the utilities <b>htop</b> , <b>top</b> , <b>ps</b> and others show information about the process, they simply read <b>/ proc / &lt;id&gt; / &lt;file&gt;</b> . <br><br><h1>  Process tree </h1><br>  When a new process is launched, the process that starts it is usually called the parent process or simply the parent.  Thus, a new process is a child process of the parent.  These relationships form a tree-like structure. <br><br>  If you press <i>F5</i> in <b>htop</b> , you can see the hierarchy of processes. <br><br>  The same effect from the <b>f</b> command flag <b>ps</b> . <br><br><pre> <code class="bash hljs">$ ps f PID TTY      STAT   TIME COMMAND 12472 pts/0    Ss     0:00 -bash 12684 pts/0    R+     0:00  \_ ps f</code> </pre> <br>  Or <b>pstree</b> . <br><br><pre> <code class="bash hljs">$ pstree -a init ‚îú‚îÄatd ‚îú‚îÄcron ‚îú‚îÄsshd -D ‚îÇ   ‚îî‚îÄsshd ‚îÇ       ‚îî‚îÄsshd ‚îÇ           ‚îî‚îÄbash ‚îÇ               ‚îî‚îÄpstree -a ‚Ä¶</code> </pre> <br>  If you have ever wondered why <b>bash</b> or <b>sshd</b> is the parent for some processes, then here‚Äôs why. <br><br>  Below, I wrote what happens if, for example, you call <b>date</b> from the <b>bash</b> console. <br><br><ul><li>  <b>bash</b> will create a new copy of its process (using the <b>fork</b> system call) <br></li><li>  It will then move the <b>/ bin / date</b> executable to memory (using the <b>exec</b> system call). <br></li><li>  <b>bash</b> , as the parent process will wait for the child to finish. <br></li></ul><br>  Thus, <b>/ sbin / init</b> , which has ID 1, started executing at system startup and spawned the SSH daemon <b>sshd</b> .  Once connected to the system, <b>sshd</b> will spawn the process for the current session, which in turn will start the <b>bash</b> console. <br><br>  I prefer to use the tree structure in the <b>htop</b> when I want to see all the streams. <br><br><h1>  Process owner </h1><br>  Each process has an owner - user.  Users, in turn, have numerical IDs. <br><br><pre> <code class="bash hljs">$ sleep 1000 &amp; [1] 2045 $  grep Uid /proc/2045/status Uid:    1000    1000    1000    1000</code> </pre> <br>  You can use the <b>id</b> command to find out the name of this user. <br><br><pre> <code class="bash hljs">$ id 1000 uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm)</code> </pre> <br>  As it turned out, <b>id</b> takes this information from the <b>/ etc / passwd</b> and <b>/ etc / group</b> files. <br><br><pre> <code class="bash hljs">$ strace -e open id 1000 open(<span class="hljs-string"><span class="hljs-string">"/etc/passwd"</span></span>, O_RDONLY|O_CLOEXEC) = 3 open(<span class="hljs-string"><span class="hljs-string">"/etc/group"</span></span>, O_RDONLY|O_CLOEXEC)  = 3</code> </pre> <br>  These are plain text files in which IDs are associated with usernames. <br><br><pre> <code class="bash hljs">$ cat /etc/passwd root:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin ubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bash $ cat /etc/group root:x:0: adm:x:4:syslog,ubuntu ubuntu:x:1000:</code> </pre><br>  <b>passwd</b> ?  But where are the passwords?  And they are actually in <b>/ etc / shadow</b> . <br><br><pre> <code class="bash hljs">$ sudo cat /etc/shadow root:<span class="hljs-variable"><span class="hljs-variable">$6</span></span><span class="hljs-variable"><span class="hljs-variable">$mS9o0QBw</span></span><span class="hljs-variable"><span class="hljs-variable">$P1ojPSTexV2PQ</span></span>.Z./rqzYex.k7TJE2nVeIVL0dql/:17126:0:99999:7::: daemon:*:17109:0:99999:7::: ubuntu:<span class="hljs-variable"><span class="hljs-variable">$6</span></span><span class="hljs-variable"><span class="hljs-variable">$GIfdqlb</span></span>/<span class="hljs-variable"><span class="hljs-variable">$ms9ZoxfrUq455K6UbmHyOfz7DVf7TWaveyHcp</span></span>.:17126:0:99999:7:::</code> </pre> <br>  If you run the program, it will run on your behalf, even if you are not its owner.  If you need to run it as <b>root</b> , then you need to use <b>sudo</b> . <br><br><pre> <code class="bash hljs">$ id uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm) $ sudo id uid=0(root) gid=0(root) groups=0(root) $ sudo -u ubuntu id uid=1000(ubuntu) gid=1000(ubuntu) groups=1000(ubuntu),4(adm) $ sudo -u daemon id uid=1(daemon) gid=1(daemon) groups=1(daemon)</code> </pre> <br>  But what if you need to run several programs on behalf of other users?  You can start the console on their behalf by using the commands <b>sudo bash</b> or <b>sudo -u user bash</b> . <br><br>  If you do not want to enter the administrator password every time you start programs, you can disable this feature by adding your username to the <b>/ etc / sudoers</b> file. <br><br>  Let's try. <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string"> ALL=(ALL) NOPASSWD: ALL"</span></span> &gt;&gt; /etc/sudoers -bash: /etc/sudoers: Permission denied</code> </pre> <br>  Yes, exactly, this can be done only with <b>root</b> privileges. <br><br><pre> <code class="bash hljs">$ sudo <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$USER</span></span></span><span class="hljs-string"> ALL=(ALL) NOPASSWD: ALL"</span></span> &gt;&gt; /etc/sudoers -bash: /etc/sudoers: Permission denied</code> </pre> <br>  What the‚Ä¶? <br><br>  Here we are trying to call <b>echo</b> on behalf of the administrator, but at the same time we still write to the <b>/ etc / sudoers</b> file on our behalf. <br><br>  As a rule, there are 2 ways out of this situation: <br><br><ul><li>  echo "$ USER ALL = (ALL) NOPASSWD: ALL" |  sudo tee -a / etc / sudoers <br></li><li>  sudo bash -c "echo '$ USER ALL = (ALL) NOPASSWD: ALL' &gt;&gt; / etc / sudoers" <br></li></ul><br>  In the first case, <b>tee -a</b> will write from the standard input stream to the file on behalf of the administrator. <br><br>  In the second case, we run the console as an administrator and ask to execute commands ( <b>-c</b> ) and all commands will be executed as root.  Pay attention to the placement of quotation marks <b>"</b> / <b>'</b> , with which the variable $ USER is dereferenced correctly. <br><br>  Suppose you want to change your password.  The <b>passwd</b> command to help you.  It will save the password in the <b>/ etc / shadow</b> file, which we saw above. <br><br>  This file is writable only for root: <br><br><pre> <code class="bash hljs">$ ls -l /etc/shadow -rw-r----- 1 root shadow 1122 Nov 27 18:52 /etc/shadow</code> </pre> <br>  How is it possible that a program launched on behalf of the user can write to a protected file? <br><br>  I have already said that when you call, the program runs on behalf of the user who starts it, even if it belongs to another user. <br><br>  It turns out that this behavior can be changed by editing the file permissions.  Let's get a look. <br><br><pre> <code class="bash hljs">$ ls -l /usr/bin/passwd -rwsr-xr-x 1 root root 54256 Mar 29  2016 /usr/bin/passwd</code> </pre> <br>  Pay attention to the symbol <b>s</b> .  It was added using <b>sudo chmod u + s / usr / bin / passwd</b> .  And that means that the executable file will always run as the owner, in this case, root. <br><br>  The so-called <b>setuid executables</b> can be searched for using <b>find / bin -user root -perm -u + s</b> . <br><br>  This can also be done for groups ( <b>g + s</b> ). <br><br><h1>  Process states </h1><br>  Next, we will deal with the state column of the processes in the <b>htop</b> , in which, by example, are the characters <b>S.</b> <br><br>  Possible state values: <br><br><ul><li>  R - [running or runnable] running or are in the queue to start <br></li><li>  S - [interruptible sleep] interrupted sleep <br></li><li>  D - [uninterruptible sleep] uninterrupted sleep (mostly IO) <br></li><li>  Z - [zombie] zombie process, terminated but not picked up by the parent <br></li><li>  T - Stopped by job control signal <br></li><li>  t - Debugger stopped <br></li><li>  X - Dead (should not be shown) <br></li></ul><br>  They are sorted by how often I usually see them. <br><br>  Note that when <b>ps</b> starts up, it can also show substates as <b>Ss</b> , <b>R +</b> , <b>Ss +</b> , etc. <br><br><pre> <code class="bash hljs">$ ps x PID TTY      STAT   TIME COMMAND 1688 ?        Ss     0:00 /lib/systemd/systemd --user 1689 ?        S      0:00 (sd-pam) 1724 ?        S      0:01 sshd: vagrant@pts/0 1725 pts/0    Ss     0:00 -bash 2628 pts/0    R+     0:00 ps x</code> </pre> <br><h3>  R - Launched or Queued </h3><br>  Processes in this state are either running or are in the queue to run. <br><br>  What does it mean? <br><br>  When you compile the code, the output is an executable file in the form of instructions for the processor.  At startup, this file is placed in memory, where the processor executes these instructions, in other words, is engaged in calculations. <br><br><h3>  S - Interrupted sleep </h3><br>  In this state, program instructions are not executed in the processor, in other words, they sleep.  The process is waiting for an event or any condition for continuation.  After the event has occurred, the state changes to running. <br><br>  For example, you can take the <b>sleep</b> utility from coreutils.  He will be in a state of sleep a certain number of seconds. <br><br><pre> <code class="bash hljs">$ sleep 1000 &amp; [1] 10089 $ ps f PID TTY      STAT   TIME COMMAND 3514 pts/1    Ss     0:00 -bash 10089 pts/1    S      0:00  \_ sleep 1000 10094 pts/1    R+     0:00  \_ ps f</code> </pre> <br>  So this <i>is</i> an <i>interrupted</i> sleep, how can it be interrupted?  Using the signal. <br><br>  You can send a signal using <b>htop</b> by pressing the <i>F9</i> key and selecting the desired signal type in the menu. <br><br>  Signal transmission is also known as the <b>kill</b> command, because it is actually a system call that can send a signal to a process.  There is the program <b>/ bin / kill of the</b> same name, which can execute a system call from the user's environment and by default sends a <b>TERM</b> signal that kills a process, kills it. <br><br>  The signal is just a number.  Numbers are hard to remember, so they were called by their names.  Their names are usually capitalized and can be prefixed with <b>SIG</b> . <br><br>  Frequently used signals are: <b>INT</b> , <b>KILL</b> , <b>STOP</b> , <b>CONT</b> , <b>HUP</b> . <br><br>  Let's try to interrupt the sleeping process by sending it an <b>INT</b> signal, aka <b>SIGINT</b> , just <b>2</b> , or an <b>interrupt signal from the terminal</b> . <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -INT 10089 [1]+  Interrupt               sleep 1000</code> </pre> <br>  The same signal is sent if you press the <i>CTRL + C</i> combination.  <b>bash</b> will send a <b>SIGINT</b> signal to the foreground process, just like we did it manually. <br><br>  By the way, the <b>kill</b> command is built into <b>bash</b> , although many systems have a program <b>/ bin / kill</b> .  Why?  To be able to "kill" the process even if the limit on the number of created processes is exceeded. <br><br>  The following commands are identical: <br><br><ul><li>  kill -INT 10089 <br></li><li>  kill -2 10089 <br></li><li>  / bin / kill -2 10089 <br></li></ul><br>  Another useful signal is <b>SIGKILL</b> or <b>9</b> .  You may have used it when you could not complete the process with an uncontrolled click <i>CTRL + C.</i> <br><br>  When writing a program, you can catch these signals and create functions that will be triggered when the corresponding signal is received.  For example, you can clear the memory or neatly shut down.  Therefore, sending a signal, such as an interrupt signal from a terminal, does not mean that the process will be terminated. <br><br>  You may have encountered such an exception when running Python scripts: <br><br><pre> <code class="bash hljs">$ python -c <span class="hljs-string"><span class="hljs-string">'import sys; sys.stdin.read()'</span></span> ^C Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;string&gt;"</span></span>, line 1, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; KeyboardInterrupt</code> </pre> <br>  But there is a signal that can stop the process, not giving him the opportunity to answer it.  This is a <b>KILL</b> signal. <br><br><pre> <code class="bash hljs">$ sleep 1000 &amp; [1] 2658 $ <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> -9 2658 [1]+  Killed                  sleep 1000</code> </pre> <br><h3>  D - uninterrupted sleep </h3><br>  In contrast to interrupted sleep, the processes in this state cannot be stopped with the help of signals.  Therefore, many people do not like this state. <br><br>  In this state, the process waits and cannot be interrupted, for example, if a continuation event is about to occur, such as read / write to disk.  This usually happens in a split second. <br><br>  <a href="http://stackoverflow.com/questions/223644/what-is-an-uninterruptable-process">There</a> is a good answer <a href="http://stackoverflow.com/questions/223644/what-is-an-uninterruptable-process">on StackOverflow</a> : <br><blockquote>  Continuous processes are usually waiting for an IO after a page fault.  The process cannot be interrupted at this time by a signal, because it cannot process them.  If it could, the page fault would reappear and everything would remain as it is. </blockquote><br>  In other words, this can happen if, for example, you use the NFS network access protocol and it takes time to read / write to / from it. <br><br>  From my own experience I can say that this happens when the process is often pumped up, i.e.  there is not enough free memory for it. <br><br>  Let's try to cause this condition. <br><br>  <b>8.8.8.8</b> is the public DNS from Google.  There are no NFS, but it will not stop us. <br><br><pre> <code class="bash hljs">$ sudo mount 8.8.8.8:/tmp /tmp &amp; [1] 12646 $ sudo ps x | grep mount.nfs 12648 pts/1    D      0:00 /sbin/mount.nfs 8.8.8.8:/tmp /tmp -o rw</code> </pre> <br>  How to find out what makes the process in such a state?  <b>strace</b> ! <br><br>  Call <b>strace</b> for the <b>ps</b> command above. <br><br><pre> <code class="bash hljs">$ sudo strace /sbin/mount.nfs 8.8.8.8:/tmp /tmp -o rw ... mount(<span class="hljs-string"><span class="hljs-string">"8.8.8.8:/tmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"/tmp"</span></span>, <span class="hljs-string"><span class="hljs-string">"nfs"</span></span>, 0, ...</code> </pre> <br>  And here we will see that the <b>mount</b> system call blocks the process. <br><br>  And <b>mount</b> , by the way, can be called with the <b>intr</b> option, so that it can be interrupted: <b>sudo mount 8.8.8.8:/tmp / tmp -o intr</b> . <br><br><h3>  Z - Zombie process </h3><br>  When a process finishes its work with <b>exit</b> and it has child processes, the child processes become zombies. <br><br><ul><li>  Absolutely normal if the zombie process is short-lived. <br></li><li>  Zombie processes that exist for a long time, can talk about a bug in the program <br></li><li>  Zombie processes do not use memory, only the process ID <br></li><li>  Zombie process can not be "killed" <br></li><li>  You can politely ask the parent process to get rid of the zombies (sending a <b>SIGCHLD</b> ) <br></li><li>  You can complete the parent process to get rid of both. <br></li></ul><br>  I will demonstrate this by writing a small code in C. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { printf("Running\n"); int pid = fork(); if (pid == 0) {   printf("  \n");   printf("   \n");   exit(0); } else {   printf("  \n");   printf("  \n");   sleep(20);   printf("  \n"); } return 0; }</span></span></span></span></code> </pre> <br>  Install the C compiler, the GNU C Compiler (GCC). <br><br><pre> <code class="bash hljs">sudo apt install -y gcc</code> </pre> <br>  Compile and run the program. <br><br><pre> <code class="bash hljs">gcc zombie.c -o zombie ./zombie</code> </pre> <br>  Look at the process hierarchy <br><br><pre> <code class="bash hljs">$ ps f PID TTY      STAT   TIME COMMAND 3514 pts/1    Ss     0:00 -bash 7911 pts/1    S+     0:00  \_ ./zombie 7912 pts/1    Z+     0:00      \_ [zombie] &lt;defunct&gt; 1317 pts/0    Ss     0:00 -bash 7913 pts/0    R+     0:00  \_ ps f</code> </pre> <br>  We have zombies!  When the parent process ends, the zombie disappears. <br><br><pre> <code class="bash hljs">$ ps f PID TTY      STAT   TIME COMMAND 3514 pts/1    Ss+    0:00 -bash 1317 pts/0    Ss     0:00 -bash 7914 pts/0    R+     0:00  \_ ps f</code> </pre> <br>  If you replace <b>sleep (20)</b> with a <b>while (true)</b> instruction, the zombie will disappear immediately. <br><br>  When you call <b>exit</b> , all occupied memory and resources are freed so that they are available to others.  Why, then, need a zombie process? <br><br>  Parent processes have the opportunity to find out the exit code of the child processes (in the signal handler) using the <b>wait</b> system call.  If the child process is sleeping, the parent will wait first. <br><br>  Why then do not forcefully wake up the process and complete it?    ,        ,     .    . <br><br><h3> T ‚Äî     </h3><br>            <b>ps u</b> . <br><br><pre> <code class="bash hljs">$ ps u USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND ubuntu    1317  0.0  0.9  21420  4992 pts/0    Ss+  Jun07   0:00 -bash ubuntu    3514  1.5  1.0  21420  5196 pts/1    Ss   07:28   0:00 -bash ubuntu    3528  0.0  0.6  36084  3316 pts/1    R+   07:28   0:00 ps u</code> </pre> <br>      <b>-bash</b>  <b>ps</b> . <br><br>       <b>cat /dev/urandom &gt; /dev/nul</b> .    <b>R+</b> ,      . <br><br><pre> <code class="bash hljs">$ ps u USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND ubuntu    3540  103  0.1   6168   688 pts/1    R+   07:29   0:04 cat /dev/urandom</code> </pre> <br>  <i>CTRL+Z</i> ,   . <br><br><pre> <code class="bash hljs">$ <span class="hljs-comment"><span class="hljs-comment"># CTRL+Z [1]+  Stopped                 cat /dev/urandom &gt; /dev/null $ ps aux USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND ubuntu    3540 86.8  0.1   6168   688 pts/1    T    07:29   0:15 cat /dev/urandom</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, he is able to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you want to continue the process, you can call </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fg</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the first terminal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is another way to stop processes, for this you need to send them a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">STOP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> signal </font><font style="vertical-align: inherit;">using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kill</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and to continue, respectively, the signal </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CONT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> t - Debugger stopped </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> First, install the GNU Debugger (gdb) debugger </font></font><br><br><pre> <code class="bash hljs">sudo apt install -y gdb</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run the program to listen on port 1234. </font></font><br><br><pre> <code class="bash hljs">$ nc -l 1234 &amp; [1] 3905</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> He is in a state of sleep, because he is waiting for incoming messages. </font></font><br><br><pre> <code class="bash hljs">$ ps u USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND ubuntu    3905  0.0  0.1   9184   896 pts/0    S    07:41   0:00 nc -l 1234</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run the debugger and link it to the process with PID 3905. </font></font><br><br><pre> <code class="bash hljs">sudo gdb -p 3905</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the process will be traced to [trace] in the debugger and its state will change to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="bash hljs">$ ps u USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND ubuntu    3905  0.0  0.1   9184   896 pts/0    t    07:41   0:00 nc -l 1234</code> </pre> <br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Processing time </font></font></h1><br> Linux ‚Äî   ,       ,         . ,       SSH     <b>htop</b> ,            . <br><br>   ,        ? <br><br>  . <br><br>      ,    ,      .. <br><br>  ,     ,      , ,  ,   . <br><br><h1>     </h1><br>      ,     ,        .     . <br><br>    Linux              ,   . <br><br> ,  ,      ,           , ,   . <br><br>    nice ( <b>NI</b> )      ,   -20,     ,  19,   .   ,      , ..   ,     . <br><br>  ,     StackOverflow   ,       1    10%   . <br><br>  ( <b>PRI</b> )          .    0  139.   0  99     ,  , .  100  139,  . <br><br>    ,  , ,     ,     . <br><br>     : <b>PR = 20 + NI.</b> <br>     <b>PR = 20 + (-20 to +19)</b>     100  139. <br><br>       . <br><br><pre> <code class="bash hljs">nice -n  program</code> </pre> <br>          <b>renice</b> . <br><br><pre> <code class="bash hljs">renice -n niceness -p PID</code> </pre> <br> <a href="http://askubuntu.com/questions/656771/process-niceness-vs-priority">http://askubuntu.com/questions/656771/process-niceness-vs-priority</a> <br><br><h1>  ‚Äî VIRT/RES/SHR/MEM </h1><br>    ,       .   ‚Äî    . <br><br>        .      ,   ,        ,   . ,  ,     ,    . <br><br>   ,  -           .     [shared]   ,   ? ,  ,  ,  , <b>htop</b>            . <br><br><h3> VIRT/VSZ ‚Äî   </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The total amount of memory occupied by the process. </font><font style="vertical-align: inherit;">It includes all the code, data, shared libraries, pages that were moved to disk, as well as pages that were projected by the kernel but were not used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIRT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is all that is used by the process. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the application requests 1 GB of memory, but uses only 1 MB for this, then the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIRT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memory </font><font style="vertical-align: inherit;">will still be displayed as 1 GB. </font><font style="vertical-align: inherit;">Even if it calls mmap for a file weighing 1 GB and never uses it, the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIRT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will still remain 1 GB. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In most cases, this indicator is useless.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RES / RSS - Resident Memory </font></font></h3><br>  <b>RSS</b> [resident set size]  ,          . <br><br> <b>RES</b> , ,        <b>VIRT</b> ,    : <br><br><ul><li>    ,    <br></li><li>         <br></li></ul><br>    1     <b>fork()</b> ,        <b>RES</b>  1 ,           1 ,    Linux      [copy-on-write]. <br><br><h3> SHR ‚Äî   </h3><br>  ,       . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; int main() { printf("\n"); sleep(10); size_t memory = 10 * 1024 * 1024; // 10 MB char* buffer = malloc(memory); printf(" 10M\n"); sleep(10); for (size_t i = 0; i &lt; memory/2; i++)   buffer[i] = 42; printf(" 5M\n"); sleep(10); int pid = fork(); printf(" \n"); sleep(10); if (pid != 0) {   for (size_t i = memory/2; i &lt; memory/2 + memory/5; i++)     buffer[i] = 42;   printf(". 2M \n"); } sleep(10); return 0; }</span></span></span></span></code> </pre> <br>  Then <br><br><pre> <code class="bash hljs">fallocate -l 10G gcc -std=c99 mem.c -o mem ./mem</code> </pre> <br>  AND <br><br><pre> <code class="bash hljs">               VIRT  RES SHR                   4200  680 604    10M         14444  680 604    5M      14444 6168 1116              14444 6168 1116              14444 5216 0   . 2M             8252 1116   . 2M             5216 0</code> </pre> <br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Note. This section is not finished until the end; as soon as the article is updated, I will post updates)</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MEM% - Memory Usage </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The percentage of physical memory usage. </font><font style="vertical-align: inherit;">This is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RES</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> divided by total RAM. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If, for example, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RES</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is 200M and 8 GB of memory is installed in the system, then </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEM%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be 200/8192 * 100 = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4%</font></font></b> <br><br><h1>  Processes </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I ran a virtual machine with Ubuntu Server in Digital Ocean. </font><font style="vertical-align: inherit;">What processes are started at system startup? </font><font style="vertical-align: inherit;">Are they needed? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below is an analysis of the processes that run on a clean version of the machine with Ubuntu Server 16.04.1 LTS x64 in Digital Ocean.</font></font><br><br><h3>  Before </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2fe/43e/3b0/2fe43e3b01da489fb5f263925b9edd53"></div><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / sbin / init </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This program coordinates all other applications at startup and configures the user's environment. </font><font style="vertical-align: inherit;">Once launched, it becomes the parent or progenitor of all automatically starting processes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is that </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">systemd</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br><br><pre> <code class="bash hljs">$ dpkg -S /sbin/init systemd-sysv: /sbin/init</code> </pre> <br>  Yes, he is.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What happens if you stop it? </font></font> Nothing. <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / lib / systemd / systemd-journald </font></font></h3><br> <b>ystemd-journald</b>   ,     .   ,     ,       . <br><br>  , <br><br>     <b>journald</b>          .        . <br><br>    ,   <b>journalctl</b> . <br><br><ul><li> <b>journalctl _COMM=sshd</b>   sshd <br></li><li> <b>journalctl _COMM=sshd -o json-pretty</b>   sshd  JSON <br></li><li> <b>journalctl --since ¬´2015-01-10¬ª --until ¬´2015-01-11 03:00¬ª</b> <br></li><li> <b>journalctl --since 09:00 --until ¬´1 hour ago¬ª</b> <br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">journalctl --since yesterday</font></font></b> <br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">journalctl -b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> history since system startup</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">journalctl -f</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to follow logs</font></font><br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">journalctl --disk-usage</font></font></b> <br></li><li> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">journalctl --vacuum-size = 1G</font></font></b> <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Impressive. </font><font style="vertical-align: inherit;">This process, it seems, cannot be stopped or removed, you can only turn off the history.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / sbin / lvmetad -f </font></font></h3><br>  <b>lvmetad</b>   LVM,   LVM       .              . <br><br>    LVM [Logical Volume Management] (  )?  ,  LVM   ,   // ,   ¬´ ¬ª     ,    . <br><br>  ,       LVM. <br><br><pre> <code class="bash hljs">$ lvscan $ sudo apt remove lvm2 -y --purge</code> </pre> <br><h3> /lib/systemd/udevd </h3><br> <b>systemd-udevd</b>    <b>uevents</b> .   , <b>systemd-udevd</b>        <b>udev</b> . <br><br> <b>udev</b>     Linux.   <b>devfsd</b>  <b>hotplug</b> , <b>udev</b>        <b>/dev</b> . <br><br>         . <br><br><h3> /lib/systemd/timesyncd </h3><br> <b>systemd-timesyncd</b>           NTP. <br><br>   <b>ntpd</b> . <br><br><pre> <code class="bash hljs">$ timedatectl status     Local time: Fri 2016-08-26 11:38:21 UTC Universal time: Fri 2016-08-26 11:38:21 UTC       RTC time: Fri 2016-08-26 11:38:20      Time zone: Etc/UTC (UTC, +0000) Network time on: yes NTP synchronized: yes RTC <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">local</span></span> TZ: no</code> </pre> <br>     : <br><br><pre> <code class="bash hljs">$ sudo netstat -nlput Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      2178/sshd tcp6       0      0 :::22                   :::*                    LISTEN      2178/sshd</code> </pre> <br>  Beauty!  Ubuntu 14.04   : <br><br><pre> <code class="bash hljs">$ sudo apt-get install ntp -y $ sudo netstat -nlput Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      1380/sshd tcp6       0      0 :::22                   :::*                    LISTEN      1380/sshd udp        0      0 10.19.0.6:123           0.0.0.0:*                           2377/ntpd udp        0      0 139.59.256.256:123      0.0.0.0:*                           2377/ntpd udp        0      0 127.0.0.1:123           0.0.0.0:*                           2377/ntpd udp        0      0 0.0.0.0:123             0.0.0.0:*                           2377/ntpd udp6       0      0 fe80::601:6aff:fxxx:123 :::*                                2377/ntpd udp6       0      0 ::1:123                 :::*                                2377/ntpd udp6       0      0 :::123                  :::*                                2377/ntpd</code> </pre> <br>  Brr <br><br><h3> /usr/sbin/atd -f </h3><br> <b>atd</b>  ,       <b>at</b> . <br><br>    <b>cron</b> ,     , <b>at</b>      . <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"touch /tmp/yolo.txt"</span></span> | at now + 1 minute job 1 at Fri Aug 26 10:44:00 2016 $ atq 1       Fri Aug 26 10:44:00 2016 a root $ sleep 60 &amp;&amp; ls /tmp/yolo.txt /tmp/yolo.txt</code> </pre> <br> ,         . <br><br><pre> <code class="bash hljs">sudo apt remove at -y --purge</code> </pre> <br><h3> /usr/lib/snapd/snapd </h3><br> Snappy Ubuntu Core    Ubuntu    ‚Äî          Ubuntu,       . <br><br>  What? <br><br>    Linux          ¬´snap¬ª   Linux,              , ,     Linux. <br><br> ,    <b>deb</b> ,     .     snappy       . <br><br><pre> <code class="bash hljs">sudo apt remove snapd -y --purge</code> </pre> <br><br><h3> /usr/bin/dbus-daemon </h3><br> D-Bus ‚Äî   ,          . <br><br>   ,       ,      ? <br><br><pre> <code class="bash hljs">sudo apt remove dbus -y --purge</code> </pre> <br> ,         NTP? <br><br><pre> <code class="bash hljs">$ timedatectl status Failed to create bus connection: No such file or directory</code> </pre> <br> , ,   . <br><br><h3> /lib/systemd/systemd-logind </h3><br> <b>systemd-logind</b>   ,    . <br><br><h3> /usr/sbin/cron -f </h3><br> <b>cron</b> ‚Äî       (Vixie Cron) <br> <b>-f</b> ‚Äî   . <br><br>   <b>cron</b>     . <br><br>   ,   <b>crontab -e</b> ,    <b>/etc/cron.hourly</b> , <b>/etc/cron.daily</b> ,  .. <br><br>      : <br><ul><li> <b>grep cron /var/log/syslog</b>  <br></li><li> <b>journalctl _COMM=cron</b>    <br></li><li> <b>journalctl _COMM=cron --since=¬´date¬ª --until=¬´date¬ª</b> <br></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surely, </font><font style="vertical-align: inherit;">you will need </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cron</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But if not, then before deleting, you need to stop and disable it.</font></font><br><br><pre> <code class="bash hljs">sudo systemctl stop cron sudo systemctl <span class="hljs-built_in"><span class="hljs-built_in">disable</span></span> cron</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otherwise, when trying to remove with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apt remove cron</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> command </font><font style="vertical-align: inherit;">, it will try to install </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">postfix</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br><br><pre> <code class="bash hljs">$ sudo apt remove cron The following packages will be REMOVED: cron The following NEW packages will be installed: anacron bcron bcron-run fgetty libbg1 libbg1-doc postfix runit ssl-cert ucspi-unix</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It seems that cron needs a mail server for mailing. </font></font><br><br><pre> <code class="bash hljs">$ apt show cron Package: cron Version: 3.0pl1-128ubuntu2 ... Suggests: anacron (&gt;= 2.0-1), logrotate, checksecurity, exim4 | postfix | mail-transport-agent $ apt depends cron cron ... Suggests: anacron (&gt;= 2.0-1) Suggests: logrotate Suggests: checksecurity |Suggests: exim4 |Suggests: postfix Suggests: &lt;mail-transport-agent&gt;   ...   exim4-daemon-heavy   postfix</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / usr / sbin / rsyslogd -n </font></font></h3><br> Rsyslogd ‚Äî    . <br><br>  ,  ,     <b>/var/log/</b> ,   <b>/var/log/auth.log</b>        SSH. <br><br>    <b>/etc/rsyslog.d</b> . <br><br>   <b>rsyslogd</b>  ,        ,      . <br><br>  <b>logger</b>     <b>/var/log/syslog</b>   ,   . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash logger Starting doing something # NFS, get IPs, etc. logger Done doing something</span></span></code> </pre> <br> ,      <b>systemd-journald</b> .     <b>rsyslogd</b> ? <br><br> <b>Rsyslog</b>  <b>Journal</b> ,      .      ,        .       , ,         .          <b>Rsyslog</b>   <b>Journal</b> . <br><br>   ?   ,   . <br><br><h3> /usr/sbin/acpid </h3><br> <b>acpid</b> ‚Äî        . <br><br> <b>acpid</b>        ACPI.  ,        . <br><br> <b>ACPI</b>     ,        , , ,      . <br><br>           .      . <br><br><pre> <code class="bash hljs">sudo apt remove acpid -y --purge</code> </pre> <br>        <b>reboot</b> ,   <b>halt</b> , Digital Ocean   ,            . <br><br> ,     . <br><br><h3> /usr/bin/lxcfs /var/lib/lxcfs/ </h3><br> <b>Lxcfs</b>      .  Ubuntu 15.04     : ,     <b>/proc</b>  ,      <b>cgroup</b> . <br><br>  ,       <b>lxc-create</b>       <b>uptime</b> , <b>top</b> ,  ..          ,     . <br><br>     LXC,      <br><br><pre> <code class="bash hljs">sudo apt remove lxcfs -y --purge</code> </pre> <br><h3> /usr/lib/accountservice/accounts-daemon </h3><br> <b>AccountsService</b>   D-Bus      .      <b>usermod(8)</b> , <b>useradd(8)</b>  <b>userdel(8)</b> . <br><br>    D-Bus,   <b>timedatectl</b> .  ,  ,     . <br><br><pre> <code class="bash hljs">sudo apt remove accountsservice -y --purge</code> </pre> <br>  Time will tell. <br><br><h3> /sbin/mdadm </h3><br> <b>mdadm</b>   Linux      <b>RAID</b> . <br><br> RAID ‚Äî   ,        .  RAID  2  : 1)    : RAID 0.   2   500 ,   1 . 2)        : , RAID 1, RAID 5, RAID 6,  RAID 10. <br><br>    : <br><br><pre> <code class="bash hljs">sudo apt remove mdadm -y --purge</code> </pre> <br><h3> /usr/lib/policykit-1/polkitd --no-debug </h3><br> <b>polkit</b>   .   ,     <b>sudo</b>           , ,  . <br><br>    .     <br><br><pre> <code class="bash hljs">sudo apt remove policykit-1 -y --purge</code> </pre> <br>     ,  -  . <br><br><h3> /usr/sbin/sshd -D </h3><br> <b>sshd</b> (OpenSSH Daemon)   ssh.  <b>-D</b>        .      <b>sshd</b> . <br><br><h3> /sbin/iscsid </h3><br> <b>iscsid</b>   ,    ,    iSCSI   . <br><br>      iSCSI: <br><br> iSCSI ‚Äî ,    TCP/IP          ,   . <br><br>    <br><pre> <code class="bash hljs">sudo apt remove open-iscsi -y --purge</code> </pre> <br><br><h3> /sbin/agetty --noclear tty1 linux </h3><br> <b>agetty</b> ‚Äî Linux  <b>getty</b> . <br><br> <b>getty</b>  Unix ,        .  ,        <b>login</b>  . <br><br>          .  Digital Ocean, ,           (  VNC). <br><br> ,         (  <b>/etc/inittab</b> ),     <b>systemd</b> . <br><br>  ,    ,     <b>agetty</b> : <br><br><pre> <code class="bash hljs">sudo rm /etc/systemd/system/getty.target.wants/getty@tty1.service sudo rm /lib/systemd/system/getty@.service</code> </pre> <br>   ,       SSH,      . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/c42/855/c2d/c42855c2de24408fbb23aec2f5dce3e7"></div><br><h3> sshd: root@pts/0, -bash  htop </h3><br> <b>sshd: root@pts/0</b> ,    SSH    <b>root</b>   ( <b>pts</b> ) ‚Ññ <b>0</b> . <br><br> <b>bash</b>   ,   .    <b>bash</b>  ?  Reddit   hirnbrot : <br><br>   ,      "-bash",  login-. Login-   ,        0 ,      --login.      . <br><br> <b>htop</b> ‚Äî     ,    . <br><br><h1>  </h1><br><pre> <code class="bash hljs">sudo apt remove lvm2 -y --purge sudo apt remove at -y --purge sudo apt remove snapd -y --purge sudo apt remove lxcfs -y --purge sudo apt remove mdadm -y --purge sudo apt remove open-iscsi -y --purge sudo apt remove accountsservice -y --purge sudo apt remove policykit-1 -y --purge</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/e17/557/127/e175571276e4434cb82b1a8444cc2c9e"></div><br><h1>  : </h1><br><pre> <code class="bash hljs">sudo apt remove dbus -y --purge sudo apt remove rsyslog -y --purge sudo apt remove acpid -y --purge sudo systemctl stop cron &amp;&amp; sudo systemctl <span class="hljs-built_in"><span class="hljs-built_in">disable</span></span> cron sudo rm /etc/systemd/system/getty.target.wants/getty@tty1.service sudo rm /lib/systemd/system/getty@.service</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/e0c/a18/8ca/e0ca188ca10644d685493f0e089770bf"></div><br>           <a href="https://peteris.rocks/blog/unattended-installation-of-wordpress-on-ubuntu-server/">   WordPress  Ubuntu Server</a>   . <br><br>  nginx, PHP7  MySQL. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a89/71e/4df/a8971e4dfdd84e31ae7ec992b8625f9c"></div><br><h1>  Behind the scenes </h1><br><h2>  Source </h2><br>     <b>strace</b> .   ,          <br><br> ,     . <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">which</span></span> uptime /usr/bin/uptime $ dpkg -S /usr/bin/uptime procps: /usr/bin/uptime</code> </pre> <br>  ,  <b>uptime</b>   <b>/usr/bin/uptime</b>    Ubuntu    <b>procps</b> . <br><br> ,    <a href="http://packages.ubuntu.com/">packages.ubuntu.com</a>    . <br><br>  <b>procps</b> : <a href="http://packages.ubuntu.com/source/xenial/procps">http://packages.ubuntu.com/source/xenial/procps</a> <br><br>        : <br><br><ul><li> Debian Package Source Repository git://git.debian.org/collab-maint/procps.git <br></li><li> Debian Package Source Repository ( ) <a href="https://anonscm.debian.org/cgit/collab-maint/procps.git/">https://anonscm.debian.org/cgit/collab-maint/procps.git/</a> <br></li></ul><br><h2>     </h2><br>       ( <b>stderr</b> )    ,     <b>2&amp;&gt;1</b>  <b>2&gt;&amp;1</b> ? <br><br>      ,  <b>echo  &gt; </b>  <b></b>   <b></b> .   ,  <b>echo  1&gt; </b> .   <b>echo  2&gt; </b>     <b></b> . <br><br>   <b>echo  2&gt; 1</b> ,      ,   <b>1</b> . <br><br>    <b>1</b>  <b>&amp;</b> ,    ,  <b>1</b>    ,   .   <b>echo  2&gt;&amp;1</b> . <br><br><h2>   PuTTY </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b2c/832/7d2/b2c8327d24ce41bd9b002ea4fe0dfc65"></div><br>         PuTTY,     . <br><br><ol><li>       <br></li><li>  <i>Change settings</i> <br></li><li>   <i>Window ‚Üí Colours</i> <br></li><li>   <i>Both</i> <br></li><li>  <i>Apply</i> <br></li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bb7/b44/854/bb7b448542634746a9f23e7092d228b6"></div><br><br><h2>    C </h2><br>        C,      <b>fork</b> / <b>exec</b> / <b>wait</b> .  <b>shell.c</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;sys/wait.h&gt; int main() { printf(" \n"); char line[1024]; while (1) {   printf("&gt; ");   fgets(line, sizeof(line), stdin);   line[strlen(line)-1] = '\0'; // strip \n   if (strcmp(line, "exit") == 0) // shell built-in     break;   int pid = fork();   if (pid == 0) {       printf(": %s\n", line);       if (execlp(line, "", NULL) == -1) {         printf("!\n");         exit(1);       }   } else if (pid &gt; 0) {       int status;       waitpid(pid, &amp;status, 0);       printf("    %d\n", WEXITSTATUS(status));   } else {       printf("!\n");       break;   } } return 0; }</span></span></span></span></code> </pre> <br>  : <br><br><pre> <code class="bash hljs">gcc shell.c -o shell</code> </pre> <br>   : <br><br><pre> <code class="bash hljs">$ ./shell   &gt; date : date Thu Dec  1 14:10:59 UTC 2016     0 &gt; <span class="hljs-literal"><span class="hljs-literal">true</span></span> : <span class="hljs-literal"><span class="hljs-literal">true</span></span>     0 &gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> : <span class="hljs-literal"><span class="hljs-literal">false</span></span>     1 &gt; <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span></code> </pre> <br>             ,     ,    <b>Enter</b> ? <br><br><pre> <code class="bash hljs">$ sleep 1 &amp; [1] 11686 $ <span class="hljs-comment"><span class="hljs-comment">#  Enter [1]+  Done                    sleep 1</span></span></code> </pre> <br>  ,    .    ,        ,   . <br><br><h1>   </h1><br> ,     .       .  ,     ,    ,          ,  .   , , ,    ,        .  ,        ,         . </div><p>Source: <a href="https://habr.com/ru/post/316806/">https://habr.com/ru/post/316806/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316790/index.html">URL rewriting on github pages</a></li>
<li><a href="../316792/index.html">Networks for the harshest. Micro issue ‚Ññ7. EVPN</a></li>
<li><a href="../316794/index.html">The digest of interesting materials for the mobile developer # 182 (November 28-December 4)</a></li>
<li><a href="../316800/index.html">Diary of performances from Minsk DevGAMM 2016</a></li>
<li><a href="../316802/index.html">Running PHP applications on Docker containers (PHP-FPM, Nginx, PostgreSQL)</a></li>
<li><a href="../316808/index.html">An easy way to present your UX solutions to a potential client.</a></li>
<li><a href="../316810/index.html">Quantum dots and why they are put</a></li>
<li><a href="../316812/index.html">The digest of fresh materials from the world of frontend for the last week ‚Ññ239 (November 28 - December 4, 2016)</a></li>
<li><a href="../316814/index.html">The most necessary program in the world</a></li>
<li><a href="../316816/index.html">Chaos and gremlins: testing web interfaces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>