<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Depth of field in computer graphics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unlike the human eye, the computer renders the entire scene in focus. Both the camera and the eye have a limited depth of field due to the final diame...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Depth of field in computer graphics</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/774/908/98e/77490898ef29ccb47cc23b3ca7845fb4.jpg" width="256" height="189" alt="Dof" align="left">  Unlike the human eye, the computer renders the entire scene in focus.  Both the camera and the eye have a limited depth of field due to the final diameter of the pupil or lens aperture.  To achieve greater photorealism, it is recommended to use the effect of depth of field in images obtained on a computer.  In addition, the management of depth of field helps to reveal the artistic intent of the author, highlighting an important object within the meaning. <br>  Until now, the task of imaging realistic depth of field in computer graphics has not been completely solved.  There are many solutions that have pros and cons, applicable in different cases.  We will consider the most popular to date. <a name="habracut"></a><br><br><h2>  In optics </h2>  The light, refracted in the lens, forms an image on the photosensitive element: film, matrix, retina.  In order for a sufficient amount of light to enter the camera, the entrance aperture (diameter of the light beam at the entrance to the optical system) must be of sufficient size.  Rays from a single point in space always converge exactly at one point behind the lens, but this point does not necessarily coincide with the selected picture plane (the sensor's half-fullness).  Therefore, the images have a limited depth of field - that is, the objects will be all the more blurred, the greater the difference in distance from the object to the lens and the focal length.  As a result, we will see a point located at a certain distance as a blurred spot: the scattering spot (Circle of Confusion, CoC).  The blur radius is calculated according to a certain law: <br><img src="https://habrastorage.org/storage2/f67/461/d3e/f67461d3e4de7222e12e357405f7c903.png" alt="Blur disk diameter formula"><br>  <font color="#aaa">Determination of the diameter of the blur (for more details, see <a href="http://en.wikipedia.org/wiki/Depth_of_field">Wikipedia</a> ).</font> <br><br>  The methods used in renderers use the <a href="http://en.wikipedia.org/wiki/Pinhole_camera">pinhole camera</a> model (in which the input aperture ‚Üí 0, and, therefore, all objects will be in focus).  Simulating an aperture of finite size and, therefore, depth of field requires additional effort. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/ca3/655/195/ca3655195b85bc4355268c0a39b8cac3.png" alt="CoC"><br>  <font color="#aaa">A point in the scene is projected onto the picture plane as a scattering spot.</font> <br><br><h2>  general review </h2>  The methods for implementing depth of field can be divided into two large groups: methods of the object space (object space) and methods of the image space (image space). <br><br>  Object space methods work with a 3D representation of scene objects and are thus applied during rendering.  Image space methods, also known as postprocess methods, operate on raster images obtained using the standard pinhole camera model (fully in focus).  To achieve the effect of depth of field, these methods blur parts of the image, taking into account the depth map (depth map).  In general, object space methods are capable of producing a more physically accurate result and have fewer artifacts than image space methods, while image space methods are much faster. <br>  Object space methods are either based on geometric optics or wave optics.  Most applications use geometric optics, which is enough to achieve the vast majority of goals.  However, in defocused images, diffraction and interference may play a significant role;  To take them into account, it is necessary to apply the laws of wave optics. <br><br>  Image space methods can be divided into those applied to generated images and applied in digital photography.  Traditional post-processing techniques require a depth map, which contains information about the remoteness of the image point from the camera, but such a map is difficult to obtain for photographs.  There is an interesting light field technique that allows you to blur objects that are not in focus without a depth map.  The lack of technology is that it requires special equipment, but the resulting images are not limited to the complexity of the scene. <br><br><h2>  Object Space Approach Methods </h2><br><h3>  Distributed ray tracing </h3>  The method directly simulates geometric optics.  Instead of tracing one ray per sample (the original is a pixel, but I found it inappropriate, because the number of counted rays will vary depending on the AA settings and rarely equals one pixel), which simulates a pinhole camera, you must select several rays to get an analogue of the image obtained on the camera with the final aperture.  The rays for each sample come from one point on the picture plane, but are directed to different parts of the lens.  After refraction by the lens, the beam is emitted into the scene. <br><br>  From the description it is clear that the image is formed, taking into account the physical laws of optics (excluding wave).  Therefore, the images obtained in this way are quite realistic and are considered the ‚Äúgold standard‚Äù by which you can check the post-processing methods.  The disadvantage of the method is obvious: for each sample, it is necessary to calculate the number of rays sufficient to obtain a high-quality blur, respectively, the render time increases.  If you want to get a shallow depth of field, you will need to increase the rendering time of hundreds or thousands of times.  If you use an insufficient number of additional rays in the blurred areas, noise will appear. <br><br>  The method is implemented in the mia_lens_bokeh shader: <pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   struct depth_of_field { miScalar focus_plane_distance; miScalar blur_radius; miInteger number_of_samples; }; miBoolean depth_of_field ( miColor *result, miState *state, struct depth_of_field *params ) { //   miScalar focus_plane_distance = *mi_eval_scalar(&amp;params-&gt;focus_plane_distance); miScalar blur_radius = *mi_eval_scalar(&amp;params-&gt;blur_radius); miUint number_of_samples = *mi_eval_integer(&amp;params-&gt;number_of_samples); miVector camera_origin, camera_direction, origin, direction, focus_point; double samples[2], focus_plane_z; int sample_number = 0; miColor sum = {0,0,0,0}, single_trace; //      miaux_to_camera_space(state, &amp;camera_origin, &amp;camera_direction); //    focus_plane_z = state-&gt;org.z - focus_plane_distance; miaux_z_plane_intersect(&amp;focus_point, &amp;camera_origin, &amp;camera_direction, focus_plane_z); //     while (mi_sample(samples, &amp;sample_number, state, 2, &amp;number_of_samples)) { miaux_sample_point_within_radius(&amp;origin, &amp;camera_origin, samples[0], samples[1], blur_radius); mi_vector_sub(&amp;direction, &amp;focus_point, &amp;origin); mi_vector_normalize(&amp;direction); miaux_from_camera_space(state, &amp;origin, &amp;direction); mi_trace_eye(&amp;single_trace, state, &amp;origin, &amp;direction); miaux_add_color(&amp;sum, &amp;single_trace); } //   miaux_divide_color(result, &amp;sum, number_of_samples); return miTRUE; }</span></span></code> </pre> <br><img src="https://habrastorage.org/storage2/14d/20e/fd6/14d20efd64c2667b97f223af9f33ae3b.jpg" alt="Dof shader"><br>  <font color="#aaa">The result of using the shader (the code is taken from the <a href="http://www.writingshaders.com/lecture_slides/WMRS_part6_image_april_2008.pdf">manual mental ray</a> , the picture is from the same place).</font> <br><br><h3>  Realistic camera models </h3>  In the previous method, the lens refractive index was calculated according to one law.  However, this is not always the case.  Lenses consist of groups of lenses with different properties: <br><img src="https://habrastorage.org/storage2/e99/ff5/5cf/e99ff55cf4e0afdbe15384875e0e9243.png" alt="Lens model"><br>  <font color="#aaa">Lens groups in the lens (picture by Pat Hanrahan).</font> <br><br>  Optical lens specifications provided by manufacturers are correctly implemented as a mathematical model.  The model includes a simulation of lens groups and also provides an exit hole model (within which the renderer will emit rays for one sample).  The rays entering the exit hole are calculated taking into account the optical properties of the lens groups through which they pass. <br><br>  The method allows to physically correctly simulate both the depth of field and the distortion introduced by the lens. <br><img src="https://habrastorage.org/storage2/ca1/031/1e4/ca10311e48d80d8835401ae25856ae69.jpg" alt="Different lens models"><br>  <font color="#aaa">Lenses with different focal lengths: with a change in focal length and lens model, the perspective changes and there may be distortions (for example, as in the upper picture) - Pat Hanrahan image.</font> <br><br>  An example of a shader that implements a lens-fashay: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fisheye</span></span></span><span class="hljs-class"> {</span></span> miColor outside_color; }; <span class="hljs-function"><span class="hljs-function">miBoolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fisheye</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(miColor *result, miState *state, struct fisheye *params )</span></span></span><span class="hljs-function"> </span></span>{ miVector camera_direction; miScalar center_x = state-&gt;camera-&gt;x_resolution / <span class="hljs-number"><span class="hljs-number">2.0</span></span>; miScalar center_y = state-&gt;camera-&gt;y_resolution / <span class="hljs-number"><span class="hljs-number">2.0</span></span>; miScalar radius = center_x &lt; center_y ? center_x : center_y; miScalar distance_from_center = miaux_distance(center_x, center_y, state-&gt;raster_x, state-&gt;raster_y); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (distance_from_center &lt; radius) { mi_vector_to_camera(state, &amp;camera_direction, &amp;state-&gt;dir); camera_direction.z *= miaux_fit(distance_from_center, <span class="hljs-number"><span class="hljs-number">0</span></span>, radius, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); mi_vector_normalize(&amp;camera_direction); mi_vector_from_camera(state, &amp;camera_direction, &amp;camera_direction); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mi_trace_eye(result, state, &amp;state-&gt;org, &amp;camera_direction); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { *result = *mi_eval_color(&amp;params-&gt;outside_color); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> miTRUE; } }</code> </pre><br><img src="https://habrastorage.org/storage2/96c/d22/be3/96cd22be34d65a7b258206127530521b.jpg" alt="Fish eye"><br>  <font color="#aaa">The result of using the shader (the code is taken from the <a href="http://www.writingshaders.com/lecture_slides/WMRS_part6_image_april_2008.pdf">manual mental ray</a> , the picture is from the same place).</font> <br><br><h3>  Accumulation buffer </h3>  To achieve the effect of depth of field, you can also use an accumulation buffer.  A few frames are rendered, after which, by averaging them, we get the desired image.  The method is very similar to distributed ray tracing, but faster than it, since  Rendering occurs using hardware.  However, in the first method, we can adaptively control the number of samples and get a picture of acceptable quality, using fewer samples.  The method is applicable only where it is possible to average the scene by hardware. <br><br><h3>  Waves propagation simulation </h3>  All the methods discussed above use the laws of geometric optics, ignoring diffraction and interference.  If there are several point sources in the scene that emit light of a certain wavelength, you can track the propagation of light waves in space.  The picture plane is located at a certain distance and to determine the value of the sample, the contribution from all the waves emitted by the sources is taken into account.  Calculations can be performed in the frequency domain using the Fourier transform. <br><br><h3>  Splatting [Krivanek] </h3>  When rendering, the scene is presented not as a set of geometric primitives with textures, but as a set of points.  Points are scattered according to a certain law, most often according to Gauss.  To achieve higher speeds, when scattering points, the convolution operation is used, taking into account the point spread function (PSF).  In the case of a Gaussian blur, the PSF parameter is the standard deviation. <br><br>  The resulting points are stored in a tree and when a point is selected from a blurred area, the search is performed within a certain radius.  This allows you to calculate a smaller number of samples in the out-of-focus areas of the image. <br><br>  It is logical to assume that a rather rigid limitation of the method is the possibility of representing the scene in the required form. <br><img src="https://habrastorage.org/storage2/8a7/c3a/d7a/8a7c3ad7a7373f27103f1973f4a0008f.jpg" alt="Splatting"><br>  <font color="#aaa">Image obtained by the scatter method.</font>  <font color="#aaa">In blurred areas, sampling density is less (picture by Jaroslav Krivanek).</font> <br><br><h3>  Analytical visibility (Catmull) </h3>  Having a three-dimensional scene, you can analytically determine which objects are out of focus.  For such objects, a smaller number of samples is taken, as a result, they look blurry.  The method allows to obtain accurate images without noise, in contrast to the distributed ray tracing. <br><br><h2>  Image space methods (image space approaches) </h2><br>  The ideal post-processing method should have the following properties: <ul><li>  Point spread function selection (PSF) <br>  The type of blur depends on the PSF, which determines which spot of scattering we will get from one point.  Since this characteristic will be different in different optical systems, a good method should allow you to choose the type of PSF. <br><img src="https://habrastorage.org/storage2/45c/386/3bc/45c3863bcb414c7a7f8785c12ab90c5c.jpg" alt="PSF choice"><br>  <font color="#aaa">Different PSF allow you to get a different nature of the blur.</font> </li><li>  Pixel pixel control <br>  At each point in the image, the size and nature of the scattering spot is different.  Typically, post-processing methods do not allow changing the nature of the blur depending on the position of the point.  This is also due to the fact that often either separable filters or Fourier transforms are used in the methods, which makes such a choice difficult to implement. <br><img src="https://habrastorage.org/storage2/a90/3b4/3e0/a903b43e00b8068385f14af709ac7897.jpg" alt="PSF transformation"><br>  <font color="#aaa">The first PSF image is the same;</font>  <font color="#aaa">the second is changing, which more accurately simulates the <s>Helios-44</s> features of some lenses.</font> </li><li>  No intensity leakage artifacts (intensity leakage artifacts) <br>  The blurred object in the background never goes beyond the boundaries of the object in focus.  However, primitive linear filters may not take this fact into account;  artifacts of lack of intensity resulting from this error reduce the realism of the image. <br><img src="https://habrastorage.org/storage2/6d3/288/2e0/6d32882e0f96e31d8c7ae7f80c27e560.png"><br>  <font color="#aaa">The image has a green figure in focus, therefore, the blurring of an object in the background should not apply to it.</font> </li><li>  No artifacts due to non-continuous depth (depth discontinuity artifacts) <br>  In reality, the blurring of the object in the foreground will be soft, the object will not have a visible hard contour.  Often filters blur an object so that it simultaneously has both a blur and a silhouette, which is wrong.  This behavior is due to the features of smoothing the depth map, with the result that the depth of the object changes in steps (and it turns out that pixels of mixed colors are on the edge of the object, as well as outside of it). <br><img src="https://habrastorage.org/storage2/9a1/cc7/df0/9a1cc7df032819a7ce632477a429354f.png" alt="Depth discontinuity artifact"><br>  <font color="#aaa">The result of applying different filters.</font>  <font color="#aaa">Due to the fact that the image (beauty map) is smoothed and the depth map is not, such artifacts may occur.</font> </li><li>  Correct simulation of partial object intersection (partial occlusion) <br>  In reality, defocused objects at the front have smoothly blurred boundaries through which objects behind are visible.  This effect is called a partial intersection, because the rear object is only partially blocked by the front one.  We would not be able to see these visible parts of the object in the background if we looked through the pinhole camera.  A geometric explanation of the effect is shown in the figure.  Because  post-processing methods work with images obtained on a pinhole camera; simulation of partial intersection is a difficult task: the color of invisible points must be extrapolated from the available data. <br><img src="https://habrastorage.org/storage2/533/3b2/47d/5333b247d68d7304b8c6aee7590a51c0.png" alt="Partial occlusion"><br>  <font color="#aaa">Partial intersection of objects (picture Barsky).</font> </li><li>  High performance <br>  The performance of filters applied ‚Äúdirectly‚Äù in the image space (meaning the simplest implementation of the filter), decreases with increasing blur radius.  For large radii, the process can take several minutes.  Ideally, you want the filter to be applied in real time, which is not always possible. </li></ul><br><br><h3>  Linear filtering [Potmesil and Chakravarty] </h3>  One of the first methods for obtaining DoF at the post-processing stage.  Depending on the depth of the point (determined by the depth map), the parameters of the blur function (PSF) change.  The larger the radius of the PSF, the lower the filter performance.  The filter can be expressed by the formula: <br><img src="https://habrastorage.org/storage2/143/e71/dd6/143e71dd685afda3a4e23c9f349ac5dc.png" alt="Linear filter formula"><br>  <font color="#aaa">where B is a blurred image, psf is the core of the filter, x and y are the coordinates in the output image, S is the original image, i and j are the coordinates in the input image.</font> <br><br>  PSF can in some sense take into account optical effects such as diffraction and interference.  Disadvantages of the method: lack of intensity, non-continuous depth. <br><br><h3>  Ray distribution buffer [Shinya] </h3>  In the method it is proposed to take into account the visibility of objects, thereby we can get rid of the lack of intensity.  Instead of creating a blurred image, first, for each point, a buffer is created for the distribution of the rays emanating from it.  Possible coordinates are included into such a buffer, in which light can come from a point, with depth.  After rendering the distribution buffers for all points, the average color value is calculated.  The method works with the visibility of objects quite correctly, but requires more memory and calculations, compared to linear filtering.  Note that the set of maps obtained by the RDB method is called the light field. <br><br><h3>  Layered DoF [Scofield] </h3>  The method is intended for a particular case of the location of objects: the objects must be parallel to the picture plane.  Objects are divided into layers, the layers are blurred separately in the frequency domain (using the fast Fourier transform).  FFT allows you to use PSF large radii without affecting performance.  The method has no shortage of intensity and works very quickly, but its area of ‚Äã‚Äãapplication is very limited. <br><br><h3>  Intersection and discretization (occlusion and discretization) [Barsky] </h3>  The limitation imposed by the previous method is very strict.  The image is divided into layers, so the depth of the image samples is rounded to the selected depth of the nearest layer.  The resulting image will have discretization artifacts in the form of stripes or rigid boundaries along the lines of intersection of the layers.  In this method, the problem of such artifacts is solved by using the ID of objects obtained by the method of finding boundaries (or using the ObjectId map).  If one object belongs to two layers, the layers are merged.  Another problem with the method is partial intersection.  To blur the objects in the background, approximation by visible samples is used. <br><img src="https://habrastorage.org/storage2/0c2/b34/38c/0c2b3438cf52a2bec307a786824e18cb.jpg" alt="Layered dof"><br>  <font color="#aaa">In the upper image you can see black stripes - artifacts arising from the use of layer-by-layer blur without using ObjectId (Barsky image).</font> <br><br><h3>  Blur, taking into account the characteristics of the human eye (vision-realistic rendering) [Kolb] </h3>  The human eye is difficult to describe in the form of an analytical model consisting of several lenses - how this can be done for the lens.  In this method, using a special device called a wavefront aberrometer (I did not dare to translate it), a set of PSFs corresponding to the human eye is determined.  Next, blur by layers according to the PSF obtained.  The method allows to obtain images visible to people with eye diseases. <br><img src="https://habrastorage.org/storage2/845/2c8/b59/8452c8b59fce24fada6f96014749743a.jpg" alt="Vision realistic DoF"><br>  <font color="#aaa">An image that takes into account the peculiarities of the eye of a person with keratoconus (picture Barsky).</font> <br><br><h3>  Importance ordering [Fearing] </h3>  The method works similarly to the renderer's antialiasing mechanism: first, an image with a low resolution is formed, after which the samples next to which the color change exceeds the threshold are processed at the next iteration and more samples of the original image are taken to obtain the pixel of the final image, and so on.  Thus, the method achieves better quality in less time. <br><br><h3>  Hybrid perceptual method (perceptual hybrid method) [Mulder and van Lier] </h3>  Features of human perception of the image are such that the details in the center are more important than the details along the edges of the image.  The center of the image can be blurred in a slower and more accurate way, while a fast approximation of blur is used for the periphery.  For a quick blur, the Gauss pyramid is used, the blur level is selected depending on the pixel depth;  the result has artifacts. <br><br><h3>  Repeated convolution (repeated convolution) [Rokita] </h3>  The method is designed for quick use in interactive applications.  It works on hardware devices where it is possible to efficiently implement a convolution operation with a 3x3 pixel core.  Convolution is performed several times, thereby achieving a large amount of blur.  Performance drops with increasing blur radius.  There is a limitation on the PSF: it must be Gaussian. <br><br><h3>  GPU depth of field [Scheueremann and Tatarchuk] </h3>  Depth of field can be considered on the GPU.  One of the methods proposed Scheueremann and Tatarchuk. <br>  Taking into account the pixel depth, according to the laws of optics, we determine the size of the scattering spot, and within the spot we select samples, which form the color of the pixel as a result.  In order to optimize the memory, in areas of the image where the CoC has a large radius, pixels are taken not from the input image, but reduced in several times.  To reduce the number of intensity artifacts, the depth of the pixels is also taken into account.  The method has artifacts of non-continuity of depth. <br><br><h3>  Integrated matrix (summed area table) [Hensley] </h3>  As an alternative to sampling within CoC, the averaged color of the image pixel area can be found using the integral matrix (SAT).  In this case, the computation speed is high and does not fall with an increase in the blur radius; moreover, there is no need to generate an image of lower resolution.  Initially, the method was intended for smoothing textures, but was further adapted for depth of field, including on the GPU.  The method has almost all types of artifacts. <br><br><h3>  The pyramidal method [Kraus and Strengert] </h3>  The scene is divided into layers, depending on the depth.  Pixels that are close to the boundary of the layers do not belong to the closest layer, but partly to several layers: thus eliminating sampling artifacts at the boundaries of the layers.  Then extrapolate the values ‚Äã‚Äãof pixels that are missing in the layers (those that are covered by objects in the foreground).  After that, each layer is blurred <a href="http://www.jvrb.org/past-issues/6.2009/1821/">by the pyramid method</a> , to eliminate artifacts, the weight of the point is used.  The resulting layers are mixed taking into account the transparency of the layers.  The method is faster than layered methods using FFT, but imposes restrictions on the PSF used. <br><img src="https://habrastorage.org/storage2/f46/c22/dd6/f46c22dd6edf99b9f169f607e33fc943.jpg" alt="Pyramidal blur"><br>  <font color="#aaa">The image was blurred using the pyramid method (picture Magnus Strengert).</font> <br><br><h3>  Separable Blur [Zhou] </h3>  In the same way, as in the methods of classical blur, which does not take into account depth (box blur, gaussian blur), separable PSF can be used in the calculation of the depth of field.  First, the image is blurred horizontally, then vertically - as a result, we get a speed that depends not on the spot area, not on the sharpness, but on its diameter.  The method is implementable on a GPU and can be applied in real time.  The idea of ‚Äã‚Äãusing separable functions is illustrated in the figure: <br><img src="https://habrastorage.org/storage2/f01/d2f/740/f01d2f740f2ee930c8401dd78936f34e.png" alt="Separable blur"><br>  <font color="#aaa">When separable blur performance depends not on the area of ‚Äã‚Äãthe PSF, but on its diameter.</font> <br>  It is worth noting that in another work Barsky emphasizes that the correct blur, taking into account the depth, cannot be separable: when using this method, artifacts are possible in some cases. <br><br><h3>  Simulated heat diffusion [Barsky, Kosloff, Bertalmio, Kass] </h3>  Heat dissipation is a physical process in which blurring can also be observed (although it is not related to optics).  If the temperature is unevenly distributed in a heat conductor, then we will observe a blur over time.  Differential equations describing the effect of such a blur can be used to simulate the depth of field.  Even for fairly large blur radii, the method can be applied to the GPU in real time. <br><img src="https://habrastorage.org/storage2/fd7/8a7/88b/fd78a788b1581f1d3d443f3c1e845812.jpg" alt="Position map"><br>  <font color="#aaa">The position map used instead of the depth map in this method contains information about the three dimensions of the point, and not only about the depth (Barsky image).</font> <br><br><h3>  Generalized and semantic depth of field </h3>  So far, we have described methods that simulate depth of field as it does in nature.  However, blurring may not be the same as we used to observe it.  In computer graphics, we are not limited to physically feasible lens models, so the blur area can be set arbitrarily ‚Äî for example, we can select several people from the crowd.  The method can be implemented as a variation of the heat dissipation simulation method, using laws other than physical laws as a blurring map. <br><img src="https://habrastorage.org/storage2/973/282/317/973282317e9f2026fd2b7eb8e2f76961.jpg" alt="Generalized DoF"><br>  <font color="#aaa">Physically incorrect blurring (picture by Kosloff and Barsky)</font> <br><br><h2>  Light fields </h2>  The light fields were originally described as a method that describes the image of a scene from different points, regardless of the complexity of the scene.  The standard way of encoding light fields is two-plane parametrization (two-plane parametrization).  Two parallel planes are selected;  each beam is described by a point on both planes.  The result is a four-dimensional data structure.  With the obtained data, you can make manipulations, such as changing the focusing plane or depth of field. <br><br>  It can be said that in the cameras the light field (between the planes of the lens and the matrix) is integrated in a natural way: we do not distinguish from which point of the lens the light beam comes.  However, if we take this into account, we can interactively, having the described data structure, manage the depth of field after taking the sensor readings. <br><br>  In addition, we can focus on different parts of the image, applying the fast Fourier transform in four-dimensional space. <br><br>  In images generated on a computer, it is easy to get the light field data by rendering the scene from different angles. <br><br>  There are cameras (physical) that can record light fields.  Microlenses are located in front of the sensor, separating the light coming from different directions.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, unlike the classical camera, the light is not summed at one point, but is distributed depending on the direction. </font><font style="vertical-align: inherit;">According to the sensor, at the processing stage, you can select an object in focus and the size of the blur. </font></font><br><br><img src="https://habrastorage.org/storage2/119/d3a/0af/119d3a0af2b3ae5141760d372d8c0949.jpg" alt="Light field"><br> <font color="#aaa"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Light field: a small part of the RAW image from the Lytro sensor. </font><font style="vertical-align: inherit;">We see the microlysis located in front of the matrix.</font></font></font> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spotted (dappled) photo </font></font></h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method described above requires a lot of matrix dots to encode a single pixel, therefore, it has a low resolution. </font><font style="vertical-align: inherit;">Indeed, the resolution of this camera is about 800 pixels on a larger side with an 11MPix matrix. </font><font style="vertical-align: inherit;">The problem can be solved by using sensors with very high resolution (but this will lead to a rise in the cost of sensors and prohibitively large data structure size). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spotted photography offers an alternative way to get a light field, bypassing the matrix size limit. </font><font style="vertical-align: inherit;">Instead of a large number of microlens, a translucent mask is used, changing the light according to a certain law. </font><font style="vertical-align: inherit;">Applying the inverse Fourier transform, you can get the original light field.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Defocus magnification </font></font></h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would be nice to be able to apply the effect of depth of field in a ‚Äúnormal‚Äù photo, without a light field (where, unlike the render, there is no depth map). This method assumes the definition of blur and its increase (the method assumes that there is already a blur in the photo, but not enough - for example, the photo was taken on a soap box where, due to the size of the matrix, it is impossible to achieve a large blur radius). The more blur already present in the image, the more blur will be applied additionally.</font></font><br><br><h3>  Autofocus </h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using depth of field in virtual reality applications and video games, as well as in photography, autofocus is necessary, that is, the problem of determining the depth, the pixels on which are in focus. In the center of the image, an area is highlighted, samples from this area are involved in determining the depth of focus. Both the weighted average depth and the intrinsic importance known to the objects depicted are taken into account (say, you can focus the ‚Äúlook‚Äù on one of the characters, but not on the wooden box or wall) - this is called the semantic weight of the object. It is also necessary to take into account the process of accommodation of the gaze (the focus changes smoothly in time), for this, for example, a low-pass filter is used.</font></font><br><br><h2>  Conclusion </h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We considered most of the most common methods used to achieve the effect of depth of field in modern computer graphics. </font><font style="vertical-align: inherit;">Some of them work with 3D objects, some are post-processing methods. </font><font style="vertical-align: inherit;">We also described the main characteristics that must be met by the right methods. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Currently, the problem of effectively achieving photo-realistic depth of field is still open. </font><font style="vertical-align: inherit;">In addition, the problem of recreating a depth map from a photograph (determining the distance to an object) is also open.</font></font><br><br><h2>  Links </h2><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links to read</font></font></b> <div class="spoiler_text"> <a href="http://www.cs.berkeley.edu/~barsky/vis.sci.pubs.html">  Brian A.Barsky</a> <br> <a href="http://onlinelibrary.wiley.com/doi/10.1111/j.1467-8659.2007.00935.x/full">Accurate Depth of Field Simulation in Real Time (Tianshu Zhou, Jim X. Chen, Mark Pullen)</a> ‚Äî     DoF <br> <a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2007/EECS-2007-19.pdf">An Algorithm for Rendering Generalized Depth of Field Effects Based on Simulated Heat Diffusion (Todd Jerome Kosloff, Brian A. Barsky)</a> ‚Äî      <br> <a href="http://graphics.berkeley.edu/papers/Barsky-IOA-2003-07/Barsky-IOA-2003-07.pdf">Investigating Occlusion and DiscretizationProblems in Image Space Blurring T echniques (Brian A. Barsky, Michael J. Tobias, Daniel R. Horn, Derrick P. Chu)</a> ‚Äî     <br> <a href="http://www.jvrb.org/past-issues/6.2009/1821/">Quasi-Convolution Pyramidal Blurring (Martin Kraus)</a> ‚Äî   <br> <a href="http://groups.csail.mit.edu/graphics/classes/CompPhoto06/html/lecturenotes/22_DepthDefocus_6.pdf">Focus and Depth of Field (Fr√©do Durand, Bill Freeman)</a> ‚Äî   ,     : cheat sheet.      . </div></div><br><h2>  From translator </h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This and other works of Brian A. Barsky (University of Berkeley) can be read </font></font><a href="http://www.cs.berkeley.edu/~barsky/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on his website</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wherever there are some terms and well-known names of algorithms, I left them in brackets in English, did not translate the names. </font><font style="vertical-align: inherit;">If I translate somewhere incorrectly - write in a personal one, I will correct it (I studied all the terminology in English, so I could be wrong with the translation). </font><font style="vertical-align: inherit;">In [square brackets] after the names of the methods are the names of those who worked on them. </font><font style="vertical-align: inherit;">For the sake of clarity and interest, I supplemented the publication with examples and some pictures.</font></font></div><p>Source: <a href="https://habr.com/ru/post/146136/">https://habr.com/ru/post/146136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146127/index.html">Samsung Galaxy Note: There is little or testing the battery at 4700 mAh</a></li>
<li><a href="../146128/index.html">Dolphin Browser acquires its own engine</a></li>
<li><a href="../146130/index.html">Protect gitlab and gitolite from password and key picking</a></li>
<li><a href="../146133/index.html">iRobot has equipped its robots with a remote control</a></li>
<li><a href="../146135/index.html">Gooseberry is an interesting alternative to the Raspberry Pi</a></li>
<li><a href="../146137/index.html">My bike Entity FrameWork, Auto Migration, With Save Data</a></li>
<li><a href="../146139/index.html">Smart Case: update your smart cover?</a></li>
<li><a href="../146140/index.html">Soft integrals</a></li>
<li><a href="../146141/index.html">Media queries and the media view-mode is REC now</a></li>
<li><a href="../146142/index.html">PHDays Online HackQuest 2012 Completed</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>