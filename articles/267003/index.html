<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reinforced.Typings - more details</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello again. 
 What about what, and I'm again about Reinforced.Typings - my library for generating TypeScript glue-code from C # -series, a brief intr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reinforced.Typings - more details</h1><div class="post__text post__text-html js-mediator-article">  Hello again. <br>  What about what, and I'm again about Reinforced.Typings - my library for generating TypeScript glue-code from C # -series, a brief introduction to which I did in a <a href="http://habrahabr.ru/post/266899/">previous post</a> .  After that, he immediately received a number of questions and comments (not only on Habrahabr, by the way - many of those interested simply were not registered on it).  For this, of course, many thanks to all, but based on the analyzed information, I realized that one brief post is not enough to describe how and what is realized.  It turns out that people ask questions, ‚Äúbut is this supported?‚Äù And everyone has to explain the same thing time after time.  So in this article I will make a small cheatsheet for attributes, fluent-configuration and tell you about additional features.  In general, you are welcome.  Beware, longrid and background information! <br><a name="habracut"></a><br><br><h4>  In the previous series </h4><br>  When I first talked about Reinforced.Typings, I casually mentioned that there are different attributes and they have a lot of all sorts of different custom properties, there are some code generators and something about the TypeScript assembly process.  Everything is somehow messy, superficially, without details.  Let's break it down.  I am as concise as possible, but I‚Äôll tell you in detail about the various configuration options, the build script, how it all works together, and what can be fashioned from all this. <br>  In general, this article is a kind of manual / tutorial / cheatsheet for Reinforced.Typings, because I still do not have the time and resource to write full documentation in English.  Of course, not everything is so sad - I already gathered my courage and wrote a whole plan of documentation.  However, the ‚Äúfather of Russian democracy‚Äù was not enough for a larger (+ article on Habrahabr).  So let's go. <br>  PS: It is worth noting that I still counted a little and in the time that has passed since the last article was written, I finished some of the features in the library, fixed the bugs (so far without them).  Therefore, the presented material is relevant from version 1.0.7. <br><br><h4>  How does it generally work? </h4><br>  You are relaxed, satisfied, <strike>you have warm feet</strike> and you write in C # and ASP.NET MVC using TypeScript.  You install Reinforced.Typings from NuGet with the command 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="bash hljs">PM &gt; Install-Package Reinforced.Typings</code> </pre> <br>  Reinforced.Typings is immediately integrated into the build process of your application, starting at every build of the project.  This moment is controlled from the Reinforced.Typings.settings.xml file, which is added to the root of your project ‚Äî I call this the ‚Äúbuild configuration‚Äù.  Having started, Reinforced.Typings does its dark work by loading the build of your project and climbing into it through Reflection.  The desired TypeScript glue-code (for example, TypeScript-interfaces corresponding to your server TransferObjects / View-models, transmitted to the client) is generated based on two possible factors: <br><ul><li>  <b>Attribute configuration</b> - that is, types are exported and their members are marked with special attributes (their list and properties will be given below) </li><li>  <b>Fluent configurations</b> - when the method specified in the build config is called to find out how and what you want to generate.  This configuration option will also be covered further. </li></ul><br>  Attribute and fluent configuration can be combined - this is not forbidden.  They basically provide equal opportunities, but differ in flexibility. <br>  In general, all the secret knowledge necessary to use Reinforced.Typings, is to navigate the parameters of its configuration.  And there are only 3 setting points mentioned above - the assembly configuration (Reinforced.Typings.settings.xml), the attribute and fluent configuration.  The build configuration determines the global parameters of the whole process, such as the files to which the generated code will be written, whether to export documentation, which assemblies to plug in, etc.  Attribute and fluent configurations determine which code to generate and for which types. <br><br><h4>  Assembly configuration </h4><br>  Reinforced.Typings generates your taipings each time you rebuild a project.  As stated above, it is embedded in the project building process.  This is done through the <a href="https://docs.nuget.org/Create/Creating-and-Publishing-a-Package">mechanism of embedding .targets and .props files from the package</a> that appeared in version NuGet 2.5. <br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  The generator itself is in the rtcli.exe tool, which is launched using the included RtCli MSBuild.  In short, everything is in the best tradition of calling custom tools during the build.  In principle, nothing stops you from brazenly pulling out rtcli.exe and Reinforced.Typings.dll from the / tools directory of the package itself and using it at your discretion (as well as the RtCli task, which lies in /build/Reinforced.Typings.Integrate.dll) , but let's be objective - very few people will really do it. <br></div></div><br>  Some parameters for starting the generator are in the Reinforced.Typings.settings.xml file, which is a piece of MSBuild script that connects to the .targets file of the package itself.  Reinforced.Typings.settings.xml is added to the root of your project when the package is installed.  By default it looks <a href="">like this</a> .  I would not argue that it is well documented (mainly because of the brokenness of my English), so I‚Äôm including a cheatsheet describing configuration parameters: <br><div class="spoiler">  <b class="spoiler_title">Parameters in Reinforced.Typings.settings.xml</b> <div class="spoiler_text">  <b>RtTargetFile (string)</b> <br>  Full path to the file to which all generated taypings will be written.  In it (as in all other parameters), you can use MSBuild variables, including those specific to Microsoft.Common.CurrentVersion.targets.  This parameter is key and mandatory when you just need to throw tapping for your project into one file, but it is not used if the function of splitting the generated code into many files is enabled (see below).  Do not forget to add this file to your project by hand! <br><br>  <b>RtConfigurationMethod (string)</b> <br>  Specifies the full name of the method that will be called to build the fluent configuration.  For example, My.Assembly.Configuration.ConfigureTypings.  The assembly does not need to be specified - Reinforced.Typings itself will find this method either in the assembly of the project itself, or in its references.  The method must be static and accept a single parameter of type Reinforce.Typings.Fluent.ConfigurationBuilder (the name of the parameter is not important).  It is worth noting that you still have the ability to use attributes, even if you are using a fluent configuration.  However, keep in mind that if there is both a fluent and attribute configuration for the same member, then fluent will be preferred. <br><br>  <b>RtWriteWarningComment (true / false)</b> <br>  Controls writing to the output file of the warning message that the file was generated automatically.  If this parameter is set to true, then the header of each generated file will display the title "// This code was generated by a Reinforced.Typings tool." Blah blah blah.  To be honest, I do not know who this parameter might be useful, but it is. <br><br>  <b>RtExportPureTypings (true / false)</b> <br>  Causes RT to generate TypeScript tiping (.d.ts) instead of the usual TypeScript.  Enabling this configuration option causes the library to justify its name (although disabled by default).  And the thing is that the syntax .d.ts and .ts are slightly different.  Hence the need for the existence of this parameter. <br><br>  <b>RtDivideTypesAmongFiles (true / false)</b> <br>  When this parameter is false, all generated tayping will be written to one file specified in the parameter RtTargetFile.  This is not always convenient, because it can lead, for example, to monstrous merdzham when using SCM.  If you set this parameter to true, then the generated TypeScript will be scattered across different files (class-per-file).  This will ignore the RtTargetFile.  Just do not forget to add the generated files to your project by hand as they appear! <br>  You can configure what and where to put using the [TsFile] / fluent-call attribute .ExportTo.  It is worth noting that RT itself will understand perfectly with the addition of /// &lt;reference ...&gt; directives to the adjacent types used in this case.  But in case of difficulty, you can always help him with the help of the attribute [TsAddTypeReference] / fluent-call .AddReference <br><br>  <b>RtTargetDirectory (string)</b> <br>  Used in conjunction with RtDivideTypesAmongFiles to specify the directory in which all generated files will be dumped.  Be sure to specify this parameter if you are using RtDivideTypesAmongFiles. <br><br>  <b>RtRootNamespace (string)</b> <br>  It is also used in conjunction with RtDivideTypesAmongFiles.  The fact is that through Reflection it is impossible to determine the root namespace of the assembly.  And without this, it will not be possible to correctly spread the generated files to directories. <br><br>  <b>RtBypassTypeScriptCompilation (true / false)</b> <br>  TypeScript is built first when building a project.  Sometimes there is a situation that you have generated taipings, and they have made the TypeScript code of your project uncollectible.  And in order to fix it, you need to rebuild the project and regenerate the taipings, but you cannot do this, because the project is not going to because the typing of scripts is not going to happen.  To get out of this vicious circle allows setting RtBypassTypeScriptCompilation to true.  This setting disables the typing of the scripts before building the project and assembles them after assembling the project, which gives the .dll of your project to calmly assemble, and RT to generate fresh taipings from it.  Please remember to return this parameter to false when the problem is resolved.  Otherwise, there may be problems with publishing the collected javascript. <br><br>  <b>RtCamelCaseForMethods (true / false)</b> (implemented by <a href="https://habrahabr.ru/users/tremor/" class="user_link">Tremor</a> feature request) <br>  Forces the conversion of all method names into camelCase (instead of the traditional .NET PascalCase).  Used by aesthetes from javascript.  Also camelCase-ing can be controlled separately for each method by using the ShouldBeCamelCased property of the TsFunction attribute. <br><br>  <b>RtCamelCaseForProperties (true / false)</b> (implemented <a href="https://habrahabr.ru/users/tremor/" class="user_link">Tremor</a> feature request) <br>  Same as RtCamelCaseForMethods, just for properties.  ShouldBeCamelCased is also found in TsProperty. <br><br>  <b>RtGenerateDocumentation (true / false)</b> <br>  When set to true, as well as enabling documentation generation in XML in the settings of your project, Reinforced.Typings will pull out the path to the file with XMLDOC during the build process and convert it to jsdoc, which will add to the generated files.  In this approach, everything is fine, except that by default, after the XML documentation is included in the export project, the compiler starts filling you up with vorning for undocumented public classes / class members.  Not that it somehow interfered technically, but visually infuriates. <br><br>  <b>RtDisable (true / false)</b> <br>  Disables Reinforced.Typings.  As long as this parameter is true, the procedure for generating taipings will not be called.  However, RtBypassTypeScriptCompilation will still be active. <br><br>  <b>Item Group RtAdditionalAssembly</b> <br>  You can drop additional assemblies into this Item-group, which Reinforced.Typings should take into account when exporting (read: export taipings to and from them too).  RT has full paths to the References of your project, so you can include in the RtAdditionalAssembly simply the name of the assembly (everything before .dll). <br></div></div><br><br><h4>  Attributes </h4><br>  One assembly configuration for successful export is not enough.  You also have to specify RT what exactly you want to see in the generated TypeScript files.  This can be done, for example, by hanging the corresponding attributes over the exported types (classes, interfaces, enums) and their members.  This is what I call the attribute configuration.  There is also a fluent configuration, but I will talk about it a little later, because it is completely based on the attribute and largely repeats it, and according to this, it will be more pedagogical to tell first about the attribute configuration. <br>  All attributes of Reinforced.Typings are, oddly enough, in the Reinforced.Typings.Attributes namespace, which can confuse a newbie (sarcasm).  All attributes can be inherited.  All properties are overloaded.  As one of the available techniques of work - you can inherit from any of them and make your attribute so as not to drag a pack of parameters with you each time. <br>  Below I give a cheatsheet for all available attributes.  The expression ‚Äúrequired attribute‚Äù in it means that if you do not put this attribute, then the corresponding entity will not be exported to TypeScript. <br><br><table><tbody><tr><th>  Attribute Name </th><th>  Required? </th><th>  Result in taiping </th><th>  Exported (patient) </th></tr><tr><td>  TsInterface </td><td>  Yes </td><td>  TypeScript interface </td><td>  Class, interface, structure </td></tr><tr><td>  TsClass </td><td>  Yes </td><td>  TypeScript class </td><td>  Class structure </td></tr><tr><td>  TsProperty </td><td>  Not </td><td>  Interface / class field </td><td>  Property, field (class / structure) </td></tr><tr><td>  TsFunction </td><td>  Not </td><td>  Interface / class method (in the case of a class, the body is exported as return null; if the method is non-void and as empty in the case of void) </td><td>  Property, field (class / structure) </td></tr><tr><td>  TsEnum </td><td>  Yes </td><td>  TypeScript enumeration </td><td>  enum obviously </td></tr><tr><td>  TsValue </td><td>  Not </td><td>  One of the TypeScript enumeration values </td><td>  Enum value, not obvious </td></tr><tr><td>  TsParameter </td><td>  Not </td><td>  Parameter (formal argument) of the TypeScript method </td><td>  The parameter of the method, oddly enough </td></tr><tr><td>  TsGeneric </td><td>  Not </td><td>  Type parameter of the TypeScript method / class / whatever </td><td>  Type parameter </td></tr><tr><td>  TsIgnore </td><td>  Not </td><td>  Patient will not be exported to TypeScript </td><td>  Property, constructor (!), Field, method, parameter </td></tr></tbody></table><br><div class="spoiler">  <b class="spoiler_title">A little about the export of designers</b> <div class="spoiler_text">  Separately, I want to mention the attribute TsBaseParam.  RT can export classes as well as their constructors.  In the case when you inherit classes from each other and explicitly call the ancestor's constructor in the successor's constructor using: base () - no information about this can be obtained via Reflection.  Therefore, for the correct export of such cases, you can put the TsBaseParam attribute above the constructor.  It has one constructor and it takes as input a string array in which you can write any TypeScript expressions.  This will all be written in TypeScript super (...).  In practice, I have little idea of ‚Äã‚Äãthe usefulness of this attribute, but it is.  There is an opinion that this attribute exists just to show how cool Reinforced.Typings are. <br><br>  As for the rest, if you enable the export of constructors via the corresponding attribute attribute [TsClass], then they will be exported correctly.  That is, no special attributes for designers are provided. <br></div></div><br><br><h4>  Attribute properties </h4><br>  There are a lot of properties, so I turned their list into a spoiler so as not to litter the article.  There, in the list of properties, I specify the name of the property, in parentheses the value of the default property and describe what it controls.  This is mostly background information that is duplicated in XMLDOC, in English only.  By this - open carefully. <br><br><div class="spoiler">  <b class="spoiler_title">Footcloth text</b> <div class="spoiler_text"><h5>  TsInterface </h5><br><ul><li>  <b>AutoI (true)</b> - whether to automatically put the letter I in front of the patient's name (if there is none) </li><li>  <b>AutoExportMethods (true)</b> - whether to export all patient methods automatically.  If not, you will put [TsFunction] on the methods yourself. </li><li>  <b>AutoExportProperties (true)</b> - the same as above, but for propertey and [TsProperty] </li><li>  <b>IncludeNamespace (true)</b> - whether to put the patient in the module when exporting </li><li>  <b>Name (null)</b> - overrides the patient's name </li><li>  <b>Namespace (null)</b> - overrides the patient's namespace </li></ul><br><h5>  TsClass </h5><br><ul><li>  <b>AutoExportProperties</b> , <b>AutoExportMethods</b> , <b>IncludeNamespace</b> , <b>Name</b> , <b>Namespace</b> - similar to TsInterface properties.  A plus: </li><li>  <b>AutoExportFields (true)</b> - the same as AutoExportProperties, but for fields </li><li>  <b>DefaultMethodCodeGenerator (null)</b> - allows you to override the code generator for all exported class methods at once </li></ul><br><h5>  TsProperty </h5><br><ul><li>  <b>Type (null, type name is substituted)</b> - overrides the patient type name in TypeScript.  Like a string.  Well, that is, you can write anything at all.  It helps when the property type is not displayed in TS (you get any), or you need to make a reference to the non-exported type.  For example - on jQuery </li><li>  <b>StrongType (null, type name is substituted)</b> - the same as Type, but you can specify .NET type.  Convenient for delegates, for example - wrote StrongType = typeof (Func &lt;int, bool&gt;) and order, no need to steam with tons of parentheses </li><li>  <b>Name (null)</b> - overrides the patient's name </li><li>  <b>ForceNullable (false)</b> - says to force to make the field nullable.  Well, that is, field: boolean turn into field?: Boolean </li><li>  <b>ShouldBeCamelCased (false)</b> - whether the property name should be converted to camelCase (the <a href="https://habrahabr.ru/users/tremor/" class="user_link">Tremor</a> feature is implemented) </li></ul><br><h5>  TsFunction </h5><br><ul><li>  <b>Type</b> , <b>StrongType</b> - similar to TsProperty properties, but overrides the <u>return type of the method</u> </li><li>  <b>Name (null)</b> - overrides the patient's name </li><li>  <b>ShouldBeCamelCased (false)</b> - whether the method name should be converted to camelCase (the <a href="https://habrahabr.ru/users/tremor/" class="user_link">Tremor</a> feature is implemented) </li></ul><br><h5>  TsEnum </h5><br><ul><li>  <b>IncludeNamespace</b> , <b>Name</b> , <b>Namespace</b> - similar to TsInterface properties.  More parameters have not. </li></ul><br><h5>  TsValue </h5><br><ul><li>  <b>Name</b> - overrides the patient's name (of a specific enum value, that is) </li></ul><br><h5>  TsParameter </h5><br><ul><li>  <b>Type</b> , <b>StrongType</b> - similar to TsProperty properties, but override <u>method argument type</u> </li><li>  <b>Name (null)</b> - overrides the patient's name </li><li>  <b>DefaultValue (null)</b> - indicates the default value.  To be substituted as parameter: boolean <i>= false</i> , for example.  Carefully, here you can shoot yourself in the foot. </li><li>  <b>ShouldBeCamelCased (false)</b> - whether the parameter name should be converted to camelCase (the <a href="https://habrahabr.ru/users/tremor/" class="user_link">Tremor</a> feature is implemented) </li></ul><br><h5>  TsGeneric </h5><br><ul><li>  <b>Type</b> , <b>StrongType</b> - similar to TsProperty properties, but override <u>type parameter type</u> </li></ul><br><h5>  TsBaseParam </h5><br><ul><li>  <b>Values</b> - an array of strings representing a TypeScript expression.  Their contents will be used to generate a call to super (...) when exporting a TypeScript class </li></ul><br><h5>  TsAddTypeReference </h5><br><ul><li>  <b>RawPath</b> - the path to the file that will be written in the directive /// &lt;reference ...&gt;, which will be added to the file with the exported type </li><li>  <b>Type</b> - type, path to the file containing which will be added in the directive /// &lt;reference ...&gt; to the file with the exported type </li></ul><br></div></div><br>  It is worth noting that attributes have a small inheritance hierarchy, so some properties are in several attributes and do about the same thing (say, Name, overrides the name of the exported class / interface, but also works for method or property parameters). <br><br><h4>  Export TypeScript code to multiple files </h4><br>  This feature is enabled when RtDivideTypesAmongFiles is set to true in the build config.  By default, with no additional configuration, RT scatters all your classes according to the good old tradition of OO languages ‚Äã‚Äã- the class is in a separate file, and even put in a subdirectory according to Namespaces (in order not to generate extra directories in this connection, it is recommended to use build configuration parameter RtRootNamespace).  There is also one nuance - the studio does not always see that any of the types used in the .ts file lies in the adjacent file and underlines with red how much in vain.  To avoid such a situation, add the directive /// &lt;reference path = "..."&gt; to all .ts files.   ‚Äî         RT  ,       /,   ,    . .   .    <strike>MasterCard</strike>  TsAddTypeReference.       ,       ,     TypeScript-   . <br><br><div class="spoiler"> <b class="spoiler_title">   </b> <div class="spoiler_text"><ul><li> <b>TsAddTypeReference</b> ‚Äî      ///&lt;reference ...&gt;  ,        .    , ,  Type   -       Reflection   .         ( [TsAddTypeReference(typeof(AnotherExportedType))]).  RT             .      ( [TsAddTypeReference("../../jquery.d.ts")]),       .     ,   enum-.    . </li><li> <b>TsFile</b> ‚Äî         .      RtDivideTypesAmongFiles      true.       RtTargetDirectory </li><li> <b>TsReference</b> ‚Äî       ,     .       (  )    ///&lt;reference ...&gt;   .    -  . ,         .    , ,    jQuery.     , ,     [assembly: TsReference("~/Scripts/typings/jquery.d.ts")].       . </li></ul><br><br></div></div><br><br><h4> CodeGenerator </h4><br>      TsAttributeBase,      ‚Äî CodeGeneratorType  Type.  What it is?            .  ‚Äî   ,     Reinforced.Typings.Generators.ITsCodeGenerator&lt;&gt;, : <br><ul><li> System.Type      (  TsEnum, TsClass, TsInterface) </li><li> System.Reflection.PropertyInfo     property (  TsProperty) </li><li> System.Reflection.FieldInfo      (  TsField) </li><li> System.Reflection.MethodInfo      (  TsFunction) </li><li> System.Reflection.ParameterInfo       (  TsParameter) </li></ul><br> ITsCodeGenerator&lt;&gt;     (Settings),     auto-property     ‚Äî Generate,    : <br><ul><li> TElement,     ‚Äî ,     TypeScript ‚Äî  </li><li> TypeResolver ‚Äî ,       ResolveTypeName,    .   TypeScript-friendly  ,      . </li><li> WriterWrapper ‚Äî    TextWrapper-,       </li><li>       Settings   Generate  , , ,  (    )     </li></ul><br>  RT      , , enum-,  ,   property ‚Äî       Reinforced.Typings.Generators     .  ,          ITsCodeGenerator&lt;&gt;. <br>     ,       ,   CodeGeneratorType    typeof   .    ,   .       CodeGeneratorType = typeof(string),  IntelliSense    -  . ,      fluent- ( .WithCodeGenerator&lt;&gt;),          . <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"> ...,    ,    Reinforced.Typings.Generators.MethodCodeGenerator,    ActionInvokeGenerator,   glue-code    MVC WebAPI   promise.     ,      TypeScript  [TsClass(AutoExportMethods = false)],    ‚Äî  [TsFunction(CodeGeneratorType = typeof(ActionInvokeGenerator))].          .         . <br></div></div><br><br><h4> Fluent- </h4><br>        . ,  ,         namespace-,              ,         .   ,        ,        .      ,   1.0.5    fluent-.         2  : <br><ol><li>   ,           Reinforced.Typings.Fluent.ConfigurationBuilder. ,  : <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Reinforced.Typings.Fluent; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">TestProject.App_Start</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TypingsConfiguration</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureTypings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ConfigurationBuilder builder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    fluent- } } }</span></span></code> </pre><br></li><li>      fluent-.  For example: <br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RtConfigurationMethod</span></span></span><span class="hljs-tag">&gt;</span></span>TestProject.App_Start.TypingsConfiguration.ConfigureTypings<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RtConfigurationMethod</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br></li></ol><br>  Everything.           (:   )    .  fluent-              ( - <a href="https://habrahabr.ru/users/tremor/" class="user_link">Tremor</a> ,      ),       .    ,   ,     ,                . <br><br>   ,        ConfigurationBuilder- (   ),     ,      XMLDOC.      fluent-,       : <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="hljs javascript">using Reinforced.Typings.Fluent; namespace TestProject.App_Start { public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypingsConfiguration</span></span></span><span class="hljs-class"> </span></span>{ public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ConfigureTypings(ConfigurationBuilder builder) { builder.ExportAsInterface&lt;ILoginInformation&gt;() .WithPublicProperties() .WithProperty(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.Email).Type&lt;int&gt;(); builder.ExportAsInterface&lt;ILoginPage&gt;() .WithPublicProperties() .WithPublicMethods() .WithMethod(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.FillIn(Ts.Parameter&lt;ILoginInformation&gt;(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">o</span></span></span><span class="hljs-function"> =&gt;</span></span> o.Type&lt;string&gt;()))) .Returns&lt;string&gt;(); builder.ExportAsInterface&lt;ILoginPage&gt;() .WithMethod(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">c</span></span></span><span class="hljs-function"> =&gt;</span></span> c.AddOrders(Ts.Parameter&lt;OrdersColelction&gt;())); builder.ExportAsInterfaces( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (ILoginPage), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> (ILoginInformation), <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(IOrder) }, c =&gt; c.ExportTo(<span class="hljs-string"><span class="hljs-string">"login.ts"</span></span>).WithAllMethods(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">m</span></span></span><span class="hljs-function"> =&gt;</span></span> m.CamelCase())); } } }</code> </pre><br></div></div><br>  ,         . ,     . <br>  : TsBaseParam  TsGeneric     .      fluent-    .           fluent-    .  ‚Äî      . <br>  :      Ts.Parameter   TryLookupDocumentationForAssembly. <br> Ts.Parameter ‚Äî    ,       fluent-   .          ,      <br><pre> <code class="hljs pgsql">builder.ExportAsInterface&lt;MyClass&gt;() .WithMethod(m =&gt; m.MyMethod( Ts.Parameter&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(p =&gt; p.OverrideName("apple").<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>&lt;string&gt;()) )) .<span class="hljs-keyword"><span class="hljs-keyword">Returns</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;();</code> </pre><br>    TypeScript- <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> IMyClass { MyMethod(apple:string):any; } <span class="hljs-comment"><span class="hljs-comment">/*    class MyClass { public int MyMethod(int a) { return 0; } } */</span></span></code> </pre><br>   ,    . <br> TryLookupDocumentationForAssembly ‚Äî    ConfigurationBuilder-,   RT    xml-       .   ,       (        ,    ).       ,        . <br> .   . <br><br><h4>  Conclusion </h4><br>    , ,  ,     -               .       ,              github.     ‚Äî     . <br>  ,    -   feedback-.        ‚Äî    issues <a href="https://github.com/reinforced/Reinforced.Typings"> github </a> .  pull-      ‚Äî   ,   fulltime-  . <br> NuGet-   <a href="http://nuget.org/packages/Reinforced.Typings/"> ,   </a> . </div><p>Source: <a href="https://habr.com/ru/post/267003/">https://habr.com/ru/post/267003/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../266993/index.html">Cleaning Dropbox backup storage by cron</a></li>
<li><a href="../266995/index.html">Home server for work and not only. The organization of the workplace of a lazy engineer</a></li>
<li><a href="../266997/index.html">The digest of interesting materials from the world of Drupal # 13</a></li>
<li><a href="../266999/index.html">Encapsulation of interfaces. We make API in C ++ convenient and understandable.</a></li>
<li><a href="../267001/index.html">Adaptive design alone is not enough: we need adaptive performance.</a></li>
<li><a href="../267007/index.html">How I ran a poster for Jewish events</a></li>
<li><a href="../267009/index.html">Publishing logs in Elasticsearch - life without regular expressions and without logstash</a></li>
<li><a href="../267011/index.html">RailsClub 2015: Interview with Ivan Nemytchenko</a></li>
<li><a href="../267013/index.html">Secure WiFi in Yandex Browser. About protection for those who have not had time to HTTPS</a></li>
<li><a href="../267015/index.html">Scheme Introduction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>