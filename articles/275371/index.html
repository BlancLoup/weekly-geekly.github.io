<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Atmel Software Framework (ASF): how does it work?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some theory 
 Atmel Software Framework (ASF) is a software library that contains a wide range of embedded code for Atmel microcontrollers of all famil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Atmel Software Framework (ASF): how does it work?</h1><div class="post__text post__text-html js-mediator-article"><h4>  Some theory </h4><br>  Atmel Software Framework (ASF) is a software library that contains a wide range of embedded code for Atmel microcontrollers of all families: megaAVR, AVR XMEGA, AVR UC3 and SAM. <br>  Main advantages: <br><ul><li>  Simplified use and development of microcontrollers, as the library is written at high and medium levels of abstraction; </li><li>  ASF is designed for use at any design stage; </li><li>  ASF is integrated into Atmel Studio with a graphical user interface, but can also be used with IAR and GCC compilers; </li><li>  ASF is free. </li></ul><br><br><img src="https://habrastorage.org/files/587/3b5/a88/5873b5a88d2748429beebea2c62df0ff.png"><br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">A little about Atmel Studio</b> <div class="spoiler_text">  Atmel Studio is a free development environment for Atmel microcontrollers, the successor of AVR Studio.  The visual shell is taken from Microsoft Visual Studio.  GCC is still used as a compiler. <br></div></div><br>  As you can see from the figure above, ASF consists of several layers of abstraction: <br><ul><li>  PCB (Board) </li><li>  Drivers (Drivers) </li><li>  Components </li><li>  Services (Services) </li><li>  application (Applications). </li></ul><br>  The ASF uses three component blocks: <br><ul><li>  <b>Module</b> : a software module that does not contain an <b>int main (void)</b> function (for example, a USART module, a USB stack).  ASF modules are layers: drivers, components, and services.  The ASF module is configured statically and / or dynamically. </li><li>  <b>Application / example</b> : software code in ASF that can be compiled, wired into the microcontroller and executed.  ASF applications consist of layers: drivers, components, services, application.  For ASF applications, only static configuration is available. </li><li>  <b>Printed circuit board</b> : an abstract layer for each Atmel debug whale supported by ASF.  Usually one microcontroller corresponds to one whale.  There is also a special user board <i>‚Äúuser board‚Äù</i> , which is an empty abstraction layer for creating an application based on a user board. </li></ul><br>  For each project, the directory tree (see figure below) consists of: <br><ol><li>  Folders for the selected Atmel MK family (in the ‚Äúsam0‚Äù picture) </li><li>  Folders with a common code (in the ‚Äúcommon‚Äù and ‚Äúcommon2‚Äù picture) </li><li>  Folders with third-party software (in the ‚Äúthirdparty‚Äù picture). </li></ol><br><img src="https://habrastorage.org/files/905/904/d21/905904d217504b7daec366411f36aab2.png"><br>  In each of these folders, the organization of subfolders corresponds to levels of abstraction (applications, services, components, drivers, cards). <br><br><h4>  The main stages of working with ASF </h4><br>  Step by step writing code using ASF in Atmel Studio looks like this: <br><ol><li>  Download ASF (using the extension manager, done once). </li><li>  Choose a sample project or create your own (on the Atmel Studio start page). </li><li>  Add required modules (ASF Wizard). </li><li>  Configure modules (xxxx_conf.h files). </li><li>  Write the logic of the work (the actual application code). </li></ol><br>  Next, we analyze each of the stages in more detail. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  ASF download </h5><br>  Extensions for Atmel Studio (including the ASF library) are downloaded using Extension Manager.  To install the required extension: <br><ol><li>  Open Extention Manager ( <b>Tools -&gt; Extension Manager</b> ) </li><li>  Enter keywords in the search field </li><li>  Download the installation file (to do this, you must be a registered user at <a href="http://www.atmel.com/">atmel.com</a> ) </li><li>  Install the application </li></ol><br>  Updating already installed applications is also carried out through the Extention Manager. <br><img src="https://habrastorage.org/files/7d8/e25/bc3/7d8e25bc352b439b8bafb609f49b4915.png"><br><br><h4>  Project creation </h4><br>  When you start Atmel Studio, you are offered the choice to create a <i>new project</i> , create <i>an example project</i> or open an <i>existing project</i> . <br>  There are many examples of projects, and it is most convenient to start studying Atmel Studio, ASF and Atmel microcontrollers from them.  To select the desired project, enter the family of microcontrollers, a debugging board, or a keyword in the appropriate field. <br>  After selecting a project, specify the folder for placement and name (if you want it to differ from the default name). <br>  When creating a new project, its type is selected.  The number of available project types depends on the installed extension modules.  The figure below shows that <abbr title="Atmel Touch Button Solution">Qtouch</abbr> projects are <abbr title="Atmel Touch Button Solution">available</abbr> , which can only be created after installing Qtouch Library and Qtouch Composer. <br><img src="https://habrastorage.org/files/a3a/f66/551/a3af665514b94290b0617d2e439a30ee.png"><br><br><h4>  ASF Wizard </h4><br>  If you have opened a ready-made example or created your own project and you need to add a new peripheral module (for example, UART) or a library (for example, FATFS), help ASF Wizard (menu <b>Project -&gt; ASF wizard</b> or icon <img src="https://habrastorage.org/files/39a/c90/dde/39ac90dde7b94f10a85e3d66af9cc33f.png">  ).  In it you can find modules by keyword and by type (driver, component, service).  If necessary, you can configure how they will work: by interruption ( <i>callback</i> in Atmel terminology) or polled ( <i>polled</i> ), how to be clocked or what role to play (master, host, mass storage, etc. depending on the type of peripherals or library ). <br><img src="https://habrastorage.org/files/8f6/7d9/c89/8f67d9c894b7482295a2c2803da742d6.png"><br><br><h5>  Module configuration </h5><br>  After adding a module to a project, the corresponding file with the name of the <b>conf_xxxx.h</b> type appears in the directory tree in the <b>config</b> folder.  It contains general library module settings. <br>  The configuration of the corresponding peripherals is carried out in 4 stages: <br><ol><li>  Read the default parameters using the appropriate function. </li><li>  Change some parameters if required. </li><li>  Write new parameters. </li><li>  Allow peripherals to work. </li></ol><br>  Consider the procedure for adding a new periphery to a project using an example. <br><br><h4>  Code writing </h4><br>  After adding the necessary modules, setting them up and turning on, let's start writing the code. <br><br><h5>  Example </h5><br>  Suppose we want to learn how to flash the LEDs on the <a href="http://www.atmel.com/ru/ru/tools/ATSAMD21-XPRO.aspx">SAM D21 Xplained Pro Evaluation Kit</a> . <br>  Consider in detail how to do this in Atmel Studio. <br>  Launch Atmel Studio and press the button <b>New Example Project</b> : <br><img src="https://habrastorage.org/files/ba2/64b/d7e/ba264bd7eef642b08daed8605f1522ec.png"><br>  Download and install the latest version of ASF, if this has not been done before (see above how to do it). <br>  Create a new example project (see picture). <br>  Select the <i>samd</i> controller <i>family</i> , enter the <i>led</i> keyword in the search.  We see a list of available projects. <br><img src="https://habrastorage.org/files/d3b/a06/9e0/d3ba069e07124c668f44303490949522.png"><br>  We select from them the necessary. <br>  Enter the new project name and select the location. <br><img src="https://habrastorage.org/files/3b5/f52/d92/3b5f52d9224242b7adf56798dd373e3f.png"><br>  Done!  Click "OK".  Now we have an example project that can be compiled and poured into the debug board. <br>  Now we change the code.  Let our LEDs light up on a timer.  To launch the ASF Wizard, enter the keyword <i>timer</i> in the search, select the <i>callback</i> mode, then click the <b>Add</b> and <b>Apply</b> buttons. <br><img src="https://habrastorage.org/files/b89/ed4/e1d/b89ed4e1d7a647ada55e4431067723bc.png"><br>  We configure the timer.  To do this, we declare globally the structure that will store the timer parameters: <br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tc_module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tc_instance_tc0</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  Now you need to set the timer.  Add a function: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure_tc0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tc_config</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">config_tc</span></span></span><span class="hljs-class">;</span></span> tc_get_config_defaults(&amp;config_tc); config_tc.wave_generation = TC_WAVE_GENERATION_MATCH_FREQ; config_tc.counter_16_bit.compare_capture_channel[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">1000</span></span>; config_tc.clock_prescaler=TC_CLOCK_PRESCALER_DIV1024; <span class="hljs-comment"><span class="hljs-comment">// config_tc.oneshot=true; tc_init(&amp;tc_instance_tc0, TC3, &amp;config_tc); tc_enable(&amp;tc_instance_tc0); }</span></span></code> </pre><br>  Explanation of the function: <br><ol><li>  <b>struct tc_config config_tc is</b> an auxiliary structure that stores the timer settings </li><li>  <b>tc_get_config_defaults (&amp; config_tc)</b> read the default settings (fill in the structure).  To see which settings are actually set by default, right-click on the function and select <i>‚Äúgoto implementation‚Äù</i> in the drop-down menu.  To find out the name of the function that records the default settings, type the name of the periphery and the word "get" through the underscore, and auto-complete will prompt the full name. </li><li>  We change the settings we need.  In this case, it is a prescaler, the mode of operation and the contents of the comparison register. </li><li>  <b>tc_init (&amp; tc_instance_tc0, TC3, &amp; config_tc)</b> Write the changed data into the structure and associate the program structure with the hardware timer (TC3). </li><li>  <b>tc_enable (&amp; tc_instance_tc0) Allow</b> timer operation. </li></ol><br>  Now we set up the interrupts and write the code that will be executed on the interrupt.  To do this, we write functions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure_tc0_callbacks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ tc_register_callback(&amp;tc_instance_tc0,tc0_callback,TC_CALLBACK_CC_CHANNEL0); tc_enable_callback(&amp;tc_instance_tc0, TC_CALLBACK_CC_CHANNEL0); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tc0_callback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct tc_module *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> module_inst)</span></span></span><span class="hljs-function"> </span></span>{ port_pin_toggle_output_level(LED_0_PIN); }</code> </pre><br>  The first function sets what interrupt handler is called (tc_register_callback (&amp; ‚Äã‚Äãtc_instance_tc0, tc0_callback, TC_CALLBACK_CC_CHANNEL0);) and allows this call (tc_enable_callback (&amp; ‚Äã‚Äãtc_instance_tc0, TC_CALLBACK_CC_CHECH).  The second function and this is what is executed in the interrupt handler (callback). <br>  Compile, run, ready! <br><br>  Atmel Studio together with the Atmel Software Framework are good tools for initial acquaintance with the periphery of Atmel microcontrollers, significantly reducing the time to master a new family of microcontrollers due to the large number of examples and convenient development environment. <br><br><h4>  ASF + IAR </h4><br>  ASF can be used with IAR.  In this case, the <a href="http://www.atmel.com/ru/ru/tools/avrsoftwareframework.aspx%3Ftab%3Doverview">stand-alone version of ASF</a> is downloaded and is connected to the project in IAR manually, the paths to the required library files are indicated in the <b>Options-C / C ++ Compiler -&gt; Preprocessor</b> menu. </div><p>Source: <a href="https://habr.com/ru/post/275371/">https://habr.com/ru/post/275371/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275353/index.html">HTML5 analog clock with JavaScript logic</a></li>
<li><a href="../275355/index.html">Anonymous Father Frost 2015-2016 - Post boasting New Year's gifts</a></li>
<li><a href="../275359/index.html">Office lighting control over Wi-Fi. Part 1: Atmel WINC1500 Wi-Fi Module</a></li>
<li><a href="../275361/index.html">Office lighting control over Wi-Fi. Part 2: Q-touch sensor technology</a></li>
<li><a href="../275369/index.html">USB bootloader on the microcontroller: firmware update from a flash drive</a></li>
<li><a href="../275373/index.html">1-Wire slave on MK. Part 1: Iron</a></li>
<li><a href="../275375/index.html">Clocking Atmel microcontrollers SAMD20 / 21</a></li>
<li><a href="../275377/index.html">1-Wire slave on MK. Part 2: Implementing in code</a></li>
<li><a href="../275379/index.html">Dialog and Atmel have announced a merger. Comments of the official distributor in Russia</a></li>
<li><a href="../275381/index.html">Remote firmware update microcontroller</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>