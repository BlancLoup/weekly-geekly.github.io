<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Getting to know Go, part 2: writing a grabber of images with a balancer and perversions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The task 
 Recently I told you how I performed a secret mission and, with the help of Go, I downloaded a dump of quotations from the ‚Äúvoid‚Äù . The time...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Getting to know Go, part 2: writing a grabber of images with a balancer and perversions</h1><div class="post__text post__text-html js-mediator-article"><h4>  The task </h4><br>  Recently I told you how I performed a secret mission and, <a href="http://habrahabr.ru/post/197598/">with the help of Go, I downloaded a dump of quotations from the ‚Äúvoid‚Äù</a> .  The time has come to fight again, this time it concerns Atata, and not only because it rhymes with emptiness. <br><br>  For those who missed - the <a href="http://tmtm.ru/projects.html">Thematic Media</a> (yes, yes, the hosts of Habra) launched the Respect project (a sort of glamorous image board / tumblr with one section), with smart banners lured the girls and programmers there and began to wait, apparently hoping that grow together.  It didn‚Äôt grow together, and after a while, Respect was mutated into <a href="http://atata.com/hubs">Atatu</a> , which already had the functionality to create custom <s>board</s> threads, hubs to merge thematic threads, and so on.  For a while, the project was developing, but the Girls left, there were programmers left, and there were far fewer of them.  Now this place is almost abandoned, there are plague winds, abandoned trains, darkness and only the rare cries of several surviving old-timers who occasionally cut through the cold in the night. <br><br>  And okay, atat with her, with this atat.  But there is a lot of great content in the form of pictures, one thread with something worth it!  Therefore, it is not surprising that the following task from headquarters was as follows: <br>  <b>‚ÄúUrgently save all images from stream <s># 949</s> <a href="http://home.atata.com/streams"># 291</a> for posterity.</b>  <b>ps.</b>  <b>Perverted. "</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Well, well, there is a task - you need to work.  In fact, we already have a certain coffee champion in perverse structures, but on Go you can also figure something out!  After 9 hours of work in Paint, I had the following plan of attack: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/167/521/f9b/167521f9b392c45594e33f659165bdbb.png"><br><br>  The degree of perversion is amazing, the bosses will be pretty!  Consider what is here and how: <br><br>  <i>The ‚Äúgenerator‚Äù</i> will load the page code from the atms, pull out the URLs of the pictures and transfer them to the <i>‚ÄúBalancer‚Äù</i> , which scatters these URLs to a certain number of <i>‚ÄúWorkers‚Äù</i> (each of which has its own small line of tasks) ensuring that all workers are uniformly loaded .  Well, the "workers" upload pictures and delight the eye of the tender balancing balancer.  It looks redundant, but about the war!  Go: <a name="habracut"></a><br><br><h4>  Generator </h4><br>  This will be the simplest, in the cycle we load the pages, sort them out and feed the elongated urls of pictures into the channel (I talked superficially about channels, gorutins and some other things in the last article, so I will not repeat here). <br>  Atata is divided into sections (which are called "streams"), one page of each "stream" contains 20 posts.  The links are as follows: ‚Äú <a href="http://home.atata.com/streams/291%3Forder%3Ddate%26from%3D40">home.atata.com/streams/291?order=date&amp;from=40</a> ‚Äù, where <i>291</i> are the IDs of the stream, and <i>40</i> is the indentation in posts from the end (that is, the more the sooner).  The post template code we are interested in looks like this: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">figure</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">figcaption</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">figcaption</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'image'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">''</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'thumb'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">rel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">''</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">''</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">a</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">figure</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  We will go through the pages by increasing the " <i>from</i> " in the url, pull the links with the <i>image</i> class and give them to the channel.  But how long?  It turns out that on the last page of the stream there is an identification mark in the form of a hidden download button for the next batch of posts ( <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <h4> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> </h4> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <ul><li> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> </li> <li> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> </li> </ul> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <h4> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> </h4> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <pre> <code class="hljs lua"><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go <span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> // : <span class="hljs-string"><span class="hljs-string">"github.com/opesun/goquery"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> ) const ( //      : ENDMESSAGE = <span class="hljs-string"><span class="hljs-string">"TooLateToDieYoung"</span></span> ) //          func generator(out chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, stream, start int) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> pos := start; ; pos += <span class="hljs-number"><span class="hljs-number">20</span></span> { // : x, err := goquery.ParseUrl(<span class="hljs-string"><span class="hljs-string">"http://home.atata.com/streams/"</span></span> + strconv.Itoa(stream) + <span class="hljs-string"><span class="hljs-string">"?order=date&amp;from="</span></span> + strconv.Itoa(pos)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { //     : <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, url := range x.Find(<span class="hljs-string"><span class="hljs-string">"figure a.image"</span></span>).Attrs(<span class="hljs-string"><span class="hljs-string">"href"</span></span>) { out &lt;- <span class="hljs-string"><span class="hljs-string">"http://atata.com/"</span></span> + url } //      -   .. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(x.Find(<span class="hljs-string"><span class="hljs-string">"li.last.hide"</span></span>)) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { out &lt;- ENDMESSAGE //..    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i><span class="hljs-string"><span class="hljs-string">" ,      -    ?"</span></span></i> <br> <br>    ,        .        PMFC (Poor Man<span class="hljs-string"><span class="hljs-string">'s Flow Control  "   ".  ,        (  ) ). </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><i><span class="hljs-string"><span class="hljs-string">"     ,        , ?"</span></span></i><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> !         - " "  "  ".      ?           ,   : </span></span><br><span class="hljs-string"><span class="hljs-string">     (     ) -          .     -       </span></span><b><span class="hljs-string"><span class="hljs-string"></span></span></b><span class="hljs-string"><span class="hljs-string">  (       -   ?). </span></span><br><span class="hljs-string"><span class="hljs-string">          .  "": </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><code class="go"><span class="hljs-string"><span class="hljs-string">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</span></span></code><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">    :     </span></span><i><span class="hljs-string"><span class="hljs-string">Worker</span></span></i><span class="hljs-string"><span class="hljs-string"> ,     </span></span><a href="http://golang.org/ref/spec"><span class="hljs-string"><span class="hljs-string">struct</span></span></a><span class="hljs-string"><span class="hljs-string"> -    record  . </span></span><br><span class="hljs-string"><span class="hljs-string"> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : </span></span><br><span class="hljs-string"><span class="hljs-string"> </span></span><br><span class="hljs-string"><span class="hljs-string">          -        -   -   .     " " ( </span></span><a href="http://golang.org/pkg/sync/"><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></a><span class="hljs-string"><span class="hljs-string"> )   </span></span><i><span class="hljs-string"><span class="hljs-string">sync</span></span></i><span class="hljs-string"><span class="hljs-string"> .    : </span></span><i><span class="hljs-string"><span class="hljs-string">WaitGroup</span></span></i><span class="hljs-string"><span class="hljs-string">   ,         ,    .           ,      . </span></span><br><span class="hljs-string"><span class="hljs-string">     ,          Worker'</span></span>a. <br> <br>   <span class="hljs-string"><span class="hljs-string">""</span></span>  <i>work</i> (      ,     <span class="hljs-string"><span class="hljs-string">""</span></span>,  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { url := &lt;-w.urls //   w.wg.Add(<span class="hljs-number"><span class="hljs-number">1</span></span>) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"sync"</span></span> )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       <span class="hljs-string"><span class="hljs-string">" </span></span><a href="http://golang.org/pkg/container/heap/"><span class="hljs-string"><span class="hljs-string">container/heap</span></span></a><span class="hljs-string"><span class="hljs-string"> "</span></span>,             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> main import (<span class="hljs-string"><span class="hljs-string">"fmt"</span></span>) //  <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Animal interface { Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Cat struct{} func (c Cat) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"!"</span></span> } <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Parrot struct { name <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> } func (p Parrot) Say() <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p.name + <span class="hljs-string"><span class="hljs-string">" !"</span></span> } func main() { kitty := Cat{} popka := Parrot{name: <span class="hljs-string"><span class="hljs-string">""</span></span>} animals := []Animal{kitty, popka} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> element Len() - <span class="hljs-number"><span class="hljs-number">1.</span></span> }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i><span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>/#Interface</a> ),  : <br> <br> <code class="go"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Interface interface { // Len is the number of elements <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the collection. Len() int // Less returns whether the element with index i should <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   <span class="hljs-string"><span class="hljs-string">""</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) } //  : func (p Pool) Swap(i, j int) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) &amp;&amp; j &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; j &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(old) item := old[n<span class="hljs-number"><span class="hljs-number">-1</span></span>] item.index = <span class="hljs-number"><span class="hljs-number">-1</span></span> *p = old[<span class="hljs-number"><span class="hljs-number">0</span></span> : n<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          <span class="hljs-string"><span class="hljs-string">""</span></span>    . <br>    <i><span class="hljs-string"><span class="hljs-string">"container/heap"</span></span></i>   : <br> <br> <code class="go">import ( <span class="hljs-string"><span class="hljs-string">"container/heap"</span></span> )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> Balancer struct { pool Pool // <span class="hljs-string"><span class="hljs-string">""</span></span>  done chan *Worker //      requests chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { b.requests = make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { b.requests &lt;- &lt;-<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, WORKERSCAP), index: <span class="hljs-number"><span class="hljs-number">0</span></span>, pending: <span class="hljs-number"><span class="hljs-number">0</span></span>, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  <span class="hljs-string"><span class="hljs-string">""</span></span>              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          <span class="hljs-string"><span class="hljs-string">"  "</span></span> ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> //  WORKERSCAP = <span class="hljs-number"><span class="hljs-number">5</span></span> //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := <span class="hljs-literal"><span class="hljs-literal">false</span></span> // ,     <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">select</span></span> { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //..     case url := &lt;-b.requests: //   ( flow controller) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { lastjobs = <span class="hljs-literal"><span class="hljs-literal">true</span></span> //    } case w := &lt;-b.done: // ,     b.completed(w) //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> lastjobs { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> w.pending == <span class="hljs-number"><span class="hljs-number">0</span></span> { //    .. heap.Remove(&amp;b.pool, w.index) //     } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(b.pool) == <span class="hljs-number"><span class="hljs-number">0</span></span> { //     //      quit &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  <span class="hljs-string"><span class="hljs-string">""</span></span>.. heap.Push(&amp;b.pool, w) //..     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending<span class="hljs-comment"><span class="hljs-comment">-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">           ,  ,  ,             .    :   ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">dispatch</span></span></i><span class="hljs-comment"><span class="hljs-comment">           ,  ,    ,    -       ? </span></span><br><span class="hljs-comment"><span class="hljs-comment">   ,  . -   download(),       : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -             -   (     )       (       ,     ): </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> -          .  , ,  </span></span><i><span class="hljs-comment"><span class="hljs-comment">os/signal</span></span></i><span class="hljs-comment"><span class="hljs-comment"> ,      ctrl-c   : </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">      ! </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">   </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><code class="go"><span class="hljs-comment"><span class="hljs-comment">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</span></span></code><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> .. (       ) </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> ..    .    ,  - !    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><s><span class="hljs-comment"><span class="hljs-comment">   time.Sleep      ,                .      ,         ""     .</span></span></s><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD.</span></span></b><span class="hljs-comment"><span class="hljs-comment">     -      ( 3 744 , 3.07Gb )    . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">          ,                 . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://pastebin.com/zx9MGpXe"><span class="hljs-comment"><span class="hljs-comment">    pastbin.com</span></span></a><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><b><span class="hljs-comment"><span class="hljs-comment">UPD2:</span></span></b><span class="hljs-comment"><span class="hljs-comment"> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">  ,    </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://vimeo.com/49718712"><span class="hljs-comment"><span class="hljs-comment">vimeo.com/49718712</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Rob Pike - 'Concurrency Is Not Parallelism' </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="https://sites.google.com/site/gopatterns/"><span class="hljs-comment"><span class="hljs-comment">sites.google.com/site/gopatterns</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - Go Language Patterns </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html"><span class="hljs-comment"><span class="hljs-comment">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</span></span></a><span class="hljs-comment"><span class="hljs-comment"> - GoLang Tutorials </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><a href="http://talks.golang.org/"><span class="hljs-comment"><span class="hljs-comment">talks.golang.org</span></span></a><span class="hljs-comment"><span class="hljs-comment"> -      Go </span></span><br><span class="hljs-comment"><span class="hljs-comment"> </span></span><br><span class="hljs-comment"><span class="hljs-comment">    , !</span></span></code> </pre> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> <h4> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> </h4> <code><code class="go">),      .                 .  ,  ,         ,        . <br> <br>  ,     ,    <b>goquery</b> (http://github.com/opesun/goquery). ,   : <br> <br> // atatagrab project main.go package main import ( "fmt" // : "github.com/opesun/goquery" "strconv" ) const ( //      : ENDMESSAGE = "TooLateToDieYoung" ) //          func generator(out chan string, stream, start int) { for pos := start; ; pos += 20 { // : x, err := goquery.ParseUrl("http://home.atata.com/streams/" + strconv.Itoa(stream) + "?order=date&amp;from=" + strconv.Itoa(pos)) if err == nil { //     : for _, url := range x.Find("figure a.image").Attrs("href") { out &lt;- "http://atata.com/" + url } //      -   .. if len(x.Find("li.last.hide")) &gt; 0 { out &lt;- ENDMESSAGE //..    return } } } }</code> <br> <br>    <br>        ,        <br> ,       ,             (           ).    -     ,    ,     . ,  ,   ,  : <br> <br> <i>" ,      -    ?"</i> <br> <br>    ,        .        PMFC (Poor Man's Flow Control  "   ".  ,        (  ) ). <br> <br> <i>"     ,        , ?"</i> <br> <br> !         - " "  "  ".      ?           ,   : <br>     (     ) -          .     -       <b></b>  (       -   ?). <br>          .  "": <br> <br> <code class="go">// type Worker struct { urls chan string //    pending int // -   index int //    wg *sync.WaitGroup //    }</code> <br>    :     <i>Worker</i> ,     <a href="http://golang.org/ref/spec">struct</a> -    record  . <br> "   ?" -  ?    Go   :            .      ,      -    ,      ,       : <br> <br>          -        -   -   .     " " ( <a href="http://golang.org/pkg/sync/">WaitGroup</a> )   <i>sync</i> .    : <i>WaitGroup</i>   ,         ,    .           ,      . <br>     ,          Worker'a. <br> <br>   ""  <i>work</i> (      ,     "",  this.                 ): <br> <br> <code class="go">//        func (w *Worker) work(done chan *Worker) { for { url := &lt;-w.urls //   w.wg.Add(1) //    download(url) //  w.wg.Done() //     done &lt;- w //    } }</code> <br>      sync   : <br> <br> <code class="go">import ( "sync" )</code> <br>    :           <i>done</i> ,     <i>work()</i> .         ,           (     ). <br>  <i>download()</i>    -     ,   .    . <br> <br>   Worker Pool   ,   ,     ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585)">Wikipedia: ( )</a> ),            .       " <a href="http://golang.org/pkg/container/heap/">container/heap</a> ",             ( -   ). <br> <br>   :            -         , : <br> <br> <code class="go">package main import ("fmt") //  type Animal interface { Say() string } type Cat struct{} func (c Cat) Say() string { return "!" } type Parrot struct { name string } func (p Parrot) Say() string { return p.name + " !" } func main() { kitty := Cat{} popka := Parrot{name: ""} animals := []Animal{kitty, popka} for _, animal := range animals { fmt.Println(animal.Say()) } }</code> <br>   ,       <i>container.Heap</i> ( <a href="http://golang.org/pkg/container/heap/">http://golang.org/pkg/container/heap/#Interface</a> ) : <br> <br> <code class="go">type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. }</code> <br> ,  <i>Push</i>  <i>Pop</i>     <i>sort.Interface</i> ( <a href="http://golang.org/pkg/sort/">http://golang.org/pkg/sort/#Interface</a> ),  : <br> <br> <code class="go">type Interface interface { // Len is the number of elements in the collection. Len() int // Less returns whether the element with index i should sort // before the element with index j. Less(i, j int) bool // Swap swaps the elements with indexes i and j. Swap(i, j int) }</code> <br>        ,      : <br> <br> <code class="go">//   "": type Pool []*Worker //   -         : func (p Pool) Less(i, j int) bool { return p[i].pending &lt; p[j].pending } //    : func (p Pool) Len() int { return len(p) } //  : func (p Pool) Swap(i, j int) { if i &gt;= 0 &amp;&amp; i &lt; len(p) &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; len(p) { p[i], p[j] = p[j], p[i] p[i].index, p[j].index = i, j } } // : func (p *Pool) Push(x interface{}) { n := len(*p) worker := x.(*Worker) worker.index = n *p = append(*p, worker) } // : func (p *Pool) Pop() interface{} { old := *p n := len(old) item := old[n-1] item.index = -1 *p = old[0 : n-1] return item }</code> <br>    ,   interface{} -  <i> ,    </i> (        ,      interface{}).     <i>any</i> ,          .    : <a href="http://research.swtch.com/interfaces">http://research.swtch.com/interfaces</a> <br>   ,      heap.*   Pool,          ""    . <br>    <i>"container/heap"</i>   : <br> <br> <code class="go">import ( "container/heap" )</code> <br>    .     ,  ,    ,            : <br> <br> <code class="go">// type Balancer struct { pool Pool // ""  done chan *Worker //      requests chan string //     flowctrl chan bool //  PMFC queue int //     wg *sync.WaitGroup //    }</code> <br>         ,    <i>init()</i> : <br> <br> <code class="go">// .        func (b *Balancer) init(in chan string) { b.requests = make(chan string) b.flowctrl = make(chan bool) b.done = make(chan *Worker) b.wg = new(sync.WaitGroup) //  Flow Control: go func() { for { b.requests &lt;- &lt;-in //         &lt;-b.flowctrl //     } }() //    : heap.Init(&amp;b.pool) for i := 0; i &lt; WORKERS; i++ { w := &amp;Worker{ urls: make(chan string, WORKERSCAP), index: 0, pending: 0, wg: b.wg, } go w.work(b.done) //  heap.Push(&amp;b.pool, w) //     } }</code> <br>       -  ""              .    ,        -      -          ! <br>  ,     :  <i>make()</i>    ,     .   ,        -          "  " ;      ,      . <br> <br>  init()    WORKERS  WORKERSCAP       ,  : <br> <br> <code class="go">var ( WORKERS = 5 //  WORKERSCAP = 5 //    )</code> <br>      .  ,           ,     <i>(      ,  .      ,   .    ,       , )</i> : <br> <br> <code class="go">//          func (b *Balancer) balance(quit chan bool) { lastjobs := false // ,     for { select { //     : case &lt;-quit: //     b.wg.Wait() //    .. quit &lt;- true //..     case url := &lt;-b.requests: //   ( flow controller) if url != ENDMESSAGE { // -      ? b.dispatch(url) //  ,    } else { lastjobs = true //    } case w := &lt;-b.done: // ,     b.completed(w) //   if lastjobs { if w.pending == 0 { //    .. heap.Remove(&amp;b.pool, w.index) //     } if len(b.pool) == 0 { //     //      quit &lt;- true //        } } } } }</code> <br>   : <br> <br> <code class="go">//    func (b *Balancer) dispatch(url string) { w := heap.Pop(&amp;b.pool).(*Worker) //     .. w.urls &lt;- url //..   . w.pending++ //  "".. heap.Push(&amp;b.pool, w) //..     if b.queue++; b.queue &lt; WORKERS*WORKERSCAP { b.flowctrl &lt;- true } }</code> <br> ..    .    :         , ,  ,             . <br>     <i>completed</i>    ,    : <br> <br> <code class="go">//   func (b *Balancer) completed(w *Worker) { w.pending-- heap.Remove(&amp;b.pool, w.index) heap.Push(&amp;b.pool, w) if b.queue--; b.queue == WORKERS*WORKERSCAP-1 { b.flowctrl &lt;- true } }</code> <br>           ,  ,  ,             .    :   ,  <i>dispatch</i>           ,  ,    ,    -       ? <br>   ,  . -   download(),       : <br> <br> <code class="go">//  func download(url string) { fileName := IMGDIR + "/" + url[strings.LastIndex(url, "/")+1:] output, err := os.Create(fileName) defer output.Close() response, err := http.Get(url) if err != nil { fmt.Println("Error while downloading", url, "-", err) return } defer response.Body.Close() io.Copy(output, response.Body) }</code> <br> -             -   (     )       (       ,     ): <br> <br> <code class="go">//       : var ( WORKERS = 5 //  WORKERSCAP = 5 //    ATATASTREAM = 291 //id   ATATAPOS = 0 //     IMGDIR = "img" //    ) //   : func init() { flag.IntVar(&amp;WORKERS, "w", WORKERS, " ") flag.IntVar(&amp;ATATASTREAM, "s", ATATASTREAM, "id  ") flag.IntVar(&amp;ATATAPOS, "p", ATATAPOS, " ") flag.StringVar(&amp;IMGDIR, "d", IMGDIR, "  ") }</code> <br> -          .  , ,  <i>os/signal</i> ,      ctrl-c   : <br> <br> <code class="go">import ( "io" "os" "os/signal" "sync" "flag" "fmt" "container/heap" "strconv" "strings" "github.com/opesun/goquery" "net/http" )</code> <br>      ! <br> <br>   <br> <code class="go">func main() { //  flag.Parse() //   ,     if err := os.MkdirAll(IMGDIR, 666); err != nil { panic(err) } //    links := make(chan string) quit := make(chan bool) b := new(Balancer) b.init(links) //      keys keys := make(chan os.Signal, 1) signal.Notify(keys, os.Interrupt) //    go b.balance(quit) go generator(links, ATATASTREAM, ATATAPOS) fmt.Println("  ") //  : for { select { case &lt;-keys: //    : fmt.Println("CTRL-C:    ") quit &lt;- true //    case &lt;-quit: //      fmt.Println(" !") return } } }</code> <br> .. (       ) <br> <br> <img src="http://habrastorage.org/storage3/831/2e7/3a5/8312e73a5696b64cfb6b8f3e7f1b3e53.png"> <br> <br> ..    .    ,  - !    . <br> <br> <s>   time.Sleep      ,                .      ,         ""     .</s> <br> <b>UPD.</b>     -      ( 3 744 , 3.07Gb )    . <br> <br>          ,                 . <br> <br> <a href="http://pastebin.com/zx9MGpXe">    pastbin.com</a> <br> <br> PS        ,      #291 ()        ""     10   ,        (  "-p=200" )          . <br> <br> <b>UPD2:</b> PPS        ""   :      -   Go,     ,          .       , ,        -  +          .     ,              : ,                      . <br> <br>  ,    <br> <a href="http://vimeo.com/49718712">vimeo.com/49718712</a> - Rob Pike - 'Concurrency Is Not Parallelism' <br> <a href="https://sites.google.com/site/gopatterns/">sites.google.com/site/gopatterns</a> - Go Language Patterns <br> <a href="http://golangtutorials.blogspot.ru/2011/05/table-of-contents.html">golangtutorials.blogspot.ru/2011/05/table-of-contents.html</a> - GoLang Tutorials <br> <a href="http://talks.golang.org/">talks.golang.org</a> -      Go <br> <br>    , !</code> </div><p>Source: <a href="https://habr.com/ru/post/198150/">https://habr.com/ru/post/198150/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198138/index.html">A selection of useful CSS recipes, or what we do on bare Fridays.</a></li>
<li><a href="../198140/index.html">Python Meetup: Garbage Collector</a></li>
<li><a href="../198142/index.html">QtCreator: Qt cross-compiling from linux 64 to linux 32, win32, win64 and Mac OS X; upx, usb, dmg, etc</a></li>
<li><a href="../198144/index.html">How I stopped worrying and fell in love with Hyper-V Server</a></li>
<li><a href="../198148/index.html">FreeBSD auto configuration</a></li>
<li><a href="../198152/index.html">Bitcoin users may have discovered Ross Ulbricht‚Äôs personal wallet</a></li>
<li><a href="../198154/index.html">Localization of Node.js applications Part 2: Toolkit and Process</a></li>
<li><a href="../198158/index.html">Warp9 is another reactive js library. At this time composable and without leaks</a></li>
<li><a href="../198160/index.html">Google shares for the first time reached $ 1000</a></li>
<li><a href="../198162/index.html">Send Hyper-V Server 2012 R2 and Windows Server 2012 R2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>