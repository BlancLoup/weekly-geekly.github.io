<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SymmetricDS based PostgreSQL database replication</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will explain how to set up database replication for PostgreSQL. For the experiments, we will use the CentOS 5.3 Linux distribution, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SymmetricDS based PostgreSQL database replication</h1><div class="post__text post__text-html js-mediator-article">  In this article I will explain how to set up database replication for PostgreSQL.  For the experiments, we will use the CentOS 5.3 Linux distribution, although this is not critical.  we will use PostgreSQL 8.4.7 and SymmetricDS-2.2.2. <br><br><h6>  What is replication? </h6><br>  In fact, it is a mechanism for automatically synchronizing the contents of databases running on different servers.  As a result of replication, these databases contain absolutely identical data.  This is necessary, for example, in order to ensure the fault tolerance of the system (in case of the first database server crashes, the second one comes into operation), or to load balance the different servers can serve different clients. <br><br>  For replication, you need at least two database servers, so we prepare two identical servers with a PostgreSQL database on each.  The first will have an IP address of 10.0.2.20, the second will have 10.0.2.21, both will have a gateway 10.0.2.2. <br>  You can get by with a virtual machine, such as VirtualBox, create two virtual servers in it and run them on your own computer. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the above commands, the first character will be a # or $ sign, these signs mean that the command runs as root or as a regular user, respectively. <br>  So, what actions need to be taken: <a name="habracut"></a><br><br><h6>  Start setting </h6><br>  Enable the postgresql service, if it is not already enabled: <br> <code># chkconfig --level 3 postgresql on <br> # service postgresql start</code> <br> <br>  Now we need to create a database.  Create it "in the forehead" does not work: <br> <code># createdb mytest <br> psql: FATAL: user "root" does not exist <br></code> <br><br>  here you need to create a role in the postgres for the Linux user.  Create a superuser in the post-login with the login ‚Äúsa‚Äù and a Linux user with the same name, the password will be the same, ‚Äúsa‚Äù. <br> <code># adduser -m sa <br> <br> # su - postgres <br> $ createuser -d -s -P sa <br></code> <br>  Now you can create the ‚Äútest‚Äù table by initiating a command from under the user ‚Äúsa‚Äù: <br> <code># su - sa <br> $ createdb mytest <br></code> <br>  now you can use the psql utility: <br> <code>psql mytest</code> <br> <br>  Exit this utility by typing two characters <code>\q</code> <br><br><h6>  Installing SymmetricDS </h6><br>  Well, now it's time to get down to the most interesting part of the work.  Before continuing, make sure that we simultaneously have two servers with a working postgreSQL database server on each. <br>  Servers must ping each other because SymmetricDS uses the HTTP protocol for synchronization.  Ports 8080 and 9090 on servers should not be blocked by a firewall. <br><br>  OK.  SymmetricDS requires a java interpreter and JRE 1.6 itself, so install them on the servers, if this has not already been done: <br>  Download the jre-6u24-linux installer from java.com, install it (just run this file), <br>  set up a symbolic link (if it was not created for some reason): <br> <code># ln -s /usr/java/latest/bin/java /usr/bin/java</code> <br> <br>  and write the classpath on the command line - without them, the SymmetricDS will fail with an error that the class was not found. <br> <code>$ CLASSPATH=/usr/java/latest/lib; export CLASSPATH</code> <br> <br>  In order for sym (the main executable of the Symmetric DS) to work, you also need to specify the database server so that it listens on the external network interface (and not just on localhost) and that it launches Unix users to it.  This is done on each of our two servers: <br>  1) uncomment this line in /var/lib/pgsql/data/postgresql.conf: <br> <code>listen_addresses = '*'</code> <br> <br>  2) specify the trust method for all connections in /var/lib/pgsql/data/pg_hba.conf: <br> <code>local all all trust <br> host all all 127.0.0.1/32 trust <br> host all all ::1/128 trust</code> <br> <br>  3) To support session variables, add the line to the /var/lib/pgsql/data/postgresql.conf file: <br> <code>custom_variable_classes = 'symmetric'</code> <br> <br>  4) restart the database server: <br> <code># service postgresql restart <br></code> <br>  Check that it works, you can: <br> <code>$ psql mytest -U sa -h localhost</code> <br> <br>  This error message should not be: psql: FATAL: Ident authentication failed for user "sa". <br>  Instead, psql should open as usual. <br><br>  Now we download SymmetricDS-2.2.2 itself and unpack it on both servers: <br> <code>$ unzip symmetric-ds-2.2.2-server.zip <br> $ cd symmetric-ds-2.2.2/samples <br></code> <br><br><h6>  Configure SymmetricDS </h6><br>  We edit the root.properties and client.properties files that lie in this samples directory.  They need to uncomment the lines for postgresql, comment out or delete other options, and specify the username and password to the database (we have this sa). <br>  root.properties is needed only on the first node, client.properties - only on the second. <br>  Let's start in order. <br><br><h5>  Setting up SymmetricDS on the first server </h5><br>  Form the following root.properties file: <br><br>  root.properties <br><blockquote> <code># The class name for the JDBC Driver <br> db.driver=org.postgresql.Driver <br> <br> # The JDBC URL used to connect to the database <br> db.url=jdbc:postgresql://localhost/mytest <br> <br> # The user to login as who can create and update tables <br> db.user=sa <br> # The password for the user to login as <br> db.password=sa <br> registration.url=http://10.0.2.20:8080/sync <br> sync.url=http://10.0.2.20:8080/sync <br> # Do not change these for running the demo <br> group.id=corp <br> external.id=00000 <br> # Don't muddy the waters with purge logging <br> job.purge.period.time.ms=7200000</code> </blockquote> <br><br>  Create the initial database on the root node: <br> <code>$ psql postgres -c "CREATE database mytest;"</code> <br> <br>  For the purposes of this simple example, we will have in the database one table t2, which will be synchronized (replicated) in both directions.  Create this table. <br> <code>$ ../bin/sym -p root.properties --run-ddl create_sample.xml</code> <br> <br>  create_sample.xml file is used here <br><blockquote><pre> &lt;? xml version = "1.0"?&gt;
 &lt;! DOCTYPE database SYSTEM "http://db.apache.org/torque/dtd/database.dtd"&gt;

 &lt;database name = "mytest"&gt;
   &lt;table name = "t2"&gt;
      &lt;column name = "id" type = "INTEGER" required = "true" primaryKey = "true" autoIncrement = "true" /&gt;
      &lt;column name = "mydata" type = "VARCHAR" size = "64" required = "false" /&gt;
      &lt;column name = "intval" type = "DECIMAL" size = "10.2" required = "false" /&gt;
   &lt;/ table&gt;
 &lt;/ database&gt; </pre></blockquote><br><br>  You also need to create plpgsql handlers in the database - run this script: <br> <code>$ ./create_func.sh</code> <br> <br>  create_func.sh <br><blockquote> <code>#!/bin/sh <br> psql mytest -U sa -h localhost -c "CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler AS '\$libdir/plpgsql' LANGUAGE C;" <br> psql mytest -U sa -h localhost -c "CREATE FUNCTION plpgsql_validator(oid) RETURNS void AS '\$libdir/plpgsql' LANGUAGE C;" <br> psql mytest -U sa -h localhost -c "CREATE TRUSTED PROCEDURAL LANGUAGE plpgsql HANDLER plpgsql_call_handler VALIDATOR plpgsql_validator;"</code> </blockquote> <br><br>  Now you can initialize the SymmetricDS system on the root node: <br><br> <code>$ ../bin/sym -p root.properties --auto-create</code> <br> <br>  The output will be something like this: <br> <code>[sa@CENTOS1 samples]$ ../bin/sym -p root.properties --auto-create <br> Log output will be written to ../logs/symmetric.log <br> SymmetricLauncher - Option: name=properties, value={root.properties} <br> SymmetricLauncher - Option: name=auto-create, value={} <br> PlatformFactory - The name/version pair returned for the database, PostgreSQL8, <br> was not mapped to a known database platform. Defaulting to using just the database type of PostgreSql <br> PostgreSqlDbDialect - The DbDialect being used is org.jumpmind.symmetric.db.postgresql.PostgreSqlDbDialect <br> ConfigurationService - Initializing SymmetricDS database. <br> PostgreSqlDbDialect - There are SymmetricDS tables missing. They will be auto created. <br> PostgreSqlDbDialect - Starting auto update of SymmetricDS tables. <br> PostgreSqlDbDialect - Just installed sym_triggers_disabled <br> PostgreSqlDbDialect - Just installed sym_node_disabled <br> PostgreSqlDbDialect - Just installed sym_fn_sym_largeobject <br> ConfigurationService - Auto-configuring config channel. <br> ConfigurationService - Auto-configuring reload channel. <br> ConfigurationService - Done initializing SymmetricDS database.</code> <br> <br>  Everything worked out.  This script created as many as 26 tables for your work.  These tables start with sym_ and you can see their list by entering the command <br> <code>$ psql mytest -c "select tablename from pg_tables where tablename like 'sym%';"</code> <br> <br>  Further.  Configure symmetricDS by populating the newly created tables. <br> <code>$ ../bin/sym -p root.properties --run-sql insert_sample.sql</code> <br> <br>  The data to fill out are: <br><br>  insert_sample.sql <br><blockquote> <code>insert into t2(mydata, intval) values('sdsdsdsds', 102); <br> <br> -- <br> -- Nodes <br> -- <br> insert into sym_node_group (node_group_id, description) <br> values ('corp', 'Central Office'); <br> insert into sym_node_group (node_group_id, description) <br> values ('store', 'Store'); <br> <br> insert into sym_node_group_link (source_node_group_id, target_node_group_id, data_event_action) <br> values ('store', 'corp', 'P'); <br> insert into sym_node_group_link (source_node_group_id, target_node_group_id, data_event_action) <br> values ('corp', 'store', 'W'); <br> <br> insert into sym_node (node_id, node_group_id, external_id, sync_enabled) <br> values ('00000', 'corp', '00000', 1); <br> insert into sym_node_identity values ('00000'); <br> <br> -- <br> -- Channels <br> -- <br> insert into sym_channel <br> (channel_id, processing_order, max_batch_size, enabled, description) <br> values('channel_t2', 1, 100000, 1, 't2 data from register and back office'); <br> <br> -- <br> -- Triggers <br> -- <br> insert into sym_trigger <br> (trigger_id,source_table_name,channel_id,last_update_time,create_time) <br> values('trigger_t2','t2','channel_t2',current_timestamp,current_timestamp); <br> <br> -- Example of a "dead" trigger, which is used to only sync the table during initial load <br> insert into sym_trigger <br> (trigger_id,source_table_name,channel_id, sync_on_insert, sync_on_update, sync_on_delete, last_update_time,create_time) <br> values('t2_dead','t2','channel_t2',0,0,0,current_timestamp,current_timestamp); <br> <br> -- <br> -- Routers <br> -- <br> <br> -- In this example, both routers pass everything all the time. <br> <br> insert into sym_router <br> (router_id,source_node_group_id,target_node_group_id,create_time,last_update_time) <br> values('corp_store_identity', 'corp', 'store', current_timestamp, current_timestamp); <br> <br> insert into sym_router <br> (router_id,source_node_group_id,target_node_group_id,create_time,last_update_time) <br> values('store_corp_identity', 'store', 'corp', current_timestamp, current_timestamp); <br> <br> -- <br> -- Trigger Router Links <br> -- <br> <br> insert into sym_trigger_router <br> (trigger_id,router_id,initial_load_order,last_update_time,create_time) <br> values('trigger_t2','corp_store_identity',100,current_timestamp,current_timestamp); <br> <br> insert into sym_trigger_router <br> (trigger_id,router_id,initial_load_order,last_update_time,create_time) <br> values('trigger_t2','store_corp_identity', 200, current_timestamp, current_timestamp); <br> <br> -- Example of a "dead" trigger, which is used to only sync the table during initial load <br> insert into sym_trigger_router <br> (trigger_id,router_id,initial_load_order,last_update_time,create_time) <br> values('trouter_dead','corp_store_identity', 300, current_timestamp, current_timestamp);</code> </blockquote> <br><br><h6>  What does the above code mean? </h6><br>  In essence, we create a configuration for SymmetricDS ‚Äî triggers for changing values ‚Äã‚Äãin table fields.  Each time the source_table_name table is changed (in our case, this is table t2), which is listed in the SymmetricDS configuration in the sym_trigger table, the SymmetricDS code is triggered.  It determines which routes are associated with this particular trigger (see sym_trigger_router).  If only one route is specified, for example, from the first server to the second, then the changed data on the second server will not be delivered to the first.  In our case there are two channels, in both directions: from the first server to the second and from the second to the first (see sym_router). <br><br>  We start the replication server itself on the first server.  This command will not give up control, it will work and dump logs on the screen. <br> <code>$ ../bin/sym -p root.properties --port 8080 --server</code> <br> <br>  We allow registration on the first server (we start from another terminal window) <br> <code>$ ../bin/sym -p root.properties --open-registration "store,1"</code> <br> <br>  Everything.  Setting up the replication server on the root node is complete. <br><br><h6>  Setting up SymmetricDS on the second server </h6><br>  Go to the second server and make the settings there.  Create such a file in the symmetric-ds-2.2.2 / samples directory: <br><br>  client.properties <br><blockquote> <code># The class name for the JDBC Driver <br> db.driver=org.postgresql.Driver <br> <br> # The JDBC URL used to connect to the database <br> db.url=jdbc:postgresql://localhost/mytest <br> <br> # The user to login as who can create and update tables <br> db.user=sa <br> # The password for the user to login as <br> db.password=sa <br> # The HTTP URL of the root node to contact for registration <br> registration.url=http://10.0.2.20:8080/sync <br> # Do not change these for running the demo <br> group.id=store <br> external.id=1 <br> job.routing.period.time.ms=2000 <br> # This is how often the push job will be run. <br> job.push.period.time.ms=5000 <br> # This is how often the pull job will be run. <br> job.pull.period.time.ms=5000</code> </blockquote> <br><br>  We create the same database on the second server: <br> <code>$ psql postgres -c "CREATE database mytest;"</code> <br> <br>  and create the same triggers and functions in it: <br> <code>$ ../bin/sym -p client.properties --run-ddl create_sample.xml <br> $ ./create_func.sh <br></code> <br><br>  Run the replication process on the second server. <br> <code>$ ../bin/sym -p client.properties --port 9090 --server</code> <br> <br>  At this stage, our databases have not yet been replicated, replication has not begun.  Let's rate it.  go to the first server and type: <br> <code>$ psql mytest -c "select * from t2;"</code> <br> <br>  This command will bring us the contents of the table on the root node, there will be one record created by the insert_sample.sql script, which we run only on the root node. <br>  Go to the second server, type the same command there.  The table will be empty. <br><br>  Now the most basic thing: we throw an initial set of data on the client, entering this command from the first server, and thus we start replication! <br> <code>$ ../bin/sym -p root.properties --reload-node 1</code> <br> <br>  In a couple of seconds we will have the same contents on table t2 on the second server!  Hooray! <br><br>  If something went wrong with you, for example, you entered the wrong IP address of the server for registration, then the easiest thing to do is to kill our database (along with all 26 SymmetricDS tables) and start everything from the beginning.  To do this, call the command on both servers: <br> <code>$ psql postgres -c "drop databse mytest;"</code> <br> <br>  and start again from this line (look for it above :) <br> <code>$ psql postgres -c "CREATE database mytest;"</code> <br> <br><h6>  Real load simulation </h6><br>  Let's write a perl script to upload information to a table on the root server. <br>  To simulate the actual load, it will produce one hundred UPDATE per second, in a loop. <br><br>  test.pl <br><blockquote><pre> #! / usr / bin / perl

 use DBI;
 my $ dbh = DBI-&gt; connect ("DBI: Pg: dbname = mytest", "sa", "sa");

 for (my $ idval = 5000; $ idval &lt;9000; $ idval ++)
 {
   $ dbh-&gt; do ("insert into t2 (id, mydata, intval) values ‚Äã‚Äã($ idval, 'some data', $ idval)");
 }

 my $ newval = 3434;
 my $ interval = 0;
 for (my $ j = 0; $ j &lt;100000; $ j ++)
 {
  for (my $ idval = 5000; $ idval &lt;9000; $ idval ++)
  {
     $ newval ++;
     $ interval ++;
     $ dbh-&gt; do ("UPDATE t2 set intval = $ newval where id = $ idval");
     printf ("UPD [% 04d] id =% d val =% d \ r", $ j, $ idval, $ newval);
     if ($ interval == 100)
     {
          $ interval = 0;
         `ping localhost -w 1&gt; / dev / null 2&gt; &amp; 1`;
     }
  }
 }
 $ dbh-&gt; disconnect;

 print "\ nOK \ n"; </pre></blockquote><br><br>  By running this script on root node, the table will be constantly changing.  On the second server, we will be able to see how the changes are sent there, with some delay, for example, like this: <br> <code>$ psql mytest -c "select * from t2 where id=5000;"</code> <br> <br>  The intval value for this table row will lag behind what is printed by the script running on the first server. <br><br><h6>  Problems under high load </h6><br><br>  In this example, we, in fact, did not take into account the problems of high load on the database server.  When replicating, SymmetricDS keeps a record of all data sent to the remote database in its sym_data table.  This table contains a separate entry for each insert / update that runs on the root database.  Thus, with high traffic (say, hundreds of inserts per second), the size of the sym_data table starts to grow.  The growth of the table leads to an increase in replication overhead. <br><br>  To solve this problem, you need to configure the Purge Service in Symmetric DS.  The key parameters of this service that need to be specified in the root.properties file are: <br><br>  start.purge.job <br>  job.purge.period.time.ms (how often Purge Job will run) <br>  purge.retention.minutes (how long the history of changes already sent to the second database will be kept) <br><br>  The last two parameters directly affect the maximum number of entries in the sym_data table: it will be equal to purge.retention.minutes * insert / update number per minute. <br><br>  The PurgeService should automatically start along with other services, such as Push and Poll (which provide data synchronization in the databases).  But, if for some reason the Purge Service does not start, this leads to an excessive growth of the service tables SymmetricDS, so you need to start the Purge Service manually, preferably during periods of low load on the database server: <br><br> <code>../bin/sym ‚Äìp root.properties ‚ÄìX</code> <br> <br>  Successes. </div><p>Source: <a href="https://habr.com/ru/post/127282/">https://habr.com/ru/post/127282/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127273/index.html">Obtaining zero statistical information in the absence of source data</a></li>
<li><a href="../127274/index.html">Emulate network problems with WANem</a></li>
<li><a href="../127275/index.html">SCLOG: a bike with all the features of a programming language</a></li>
<li><a href="../127276/index.html">Language for working with ActionScript events</a></li>
<li><a href="../127281/index.html">Bypassing the integrated protection of PIC microcontrollers</a></li>
<li><a href="../127285/index.html">Keymaster.js: a simple micro-library for hot keys</a></li>
<li><a href="../127286/index.html">Analyzing system performance</a></li>
<li><a href="../127287/index.html">"Cloud" as an alternative to traditional hosting</a></li>
<li><a href="../127288/index.html">Visualization of intra-class relationships using GraphViz</a></li>
<li><a href="../127290/index.html">Let's work with MongoDb</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>