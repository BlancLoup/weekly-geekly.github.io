<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Caching event handlers and improving the performance of React applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we publish a translation of the material, the author of which, after analyzing the features of working with objects in JavaScript, offers React-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Caching event handlers and improving the performance of React applications</h1><div class="post__text post__text-html js-mediator-article">  Today we publish a translation of the material, the author of which, after analyzing the features of working with objects in JavaScript, offers React-developers a technique for accelerating applications.  In particular, we are talking about the fact that a variable, which, as they say, ‚Äúis assigned an object‚Äù, and which is often called simply ‚Äúan object‚Äù, in fact, does not store the object itself, but a link to it.  Functions in JavaScript are also objects, so the above is also true for them.  If you keep this in mind by designing React components and critically analyzing their code, you can improve their internal mechanisms and improve application performance. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/54f/6b5/80a/54f6b580affe2d9741da8207f93b4746.png"></div><br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Features of working with objects in JavaScript</font> </h2><br>  If you create a couple of functions that look exactly the same, and try to compare them, it turns out that they are, from the point of view of the system, different.  In order to verify this, you can run the following code: <br><br><pre><code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionOne = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionTwo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; functionOne === functionTwo; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  Now we will try to assign a variable to an already existing function, which is already assigned to another variable, and compare these two variables: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="hljs actionscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionThree = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ alert(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> functionFour = functionThree; functionThree === functionFour; <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre> <br>  As you can see, with this approach, the strict equality operator yields <code>true</code> . <br>  Objects, of course, behave in the same way: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object2 = {}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object1 === object2; <span class="hljs-comment"><span class="hljs-comment">// false object1 === object3; // true</span></span></code> </pre> <br>  Here we are talking about JavaScript, but if you have experience developing in other languages, then you may be familiar with the concept of pointers.  In the above code, every time an object is created, a section of system memory is allocated for it.  When we use a command like <code>object1 = {}</code> , this results in filling with some data a section of memory allocated specifically for <code>object1</code> . <br><br>  It is quite possible to imagine <code>object1</code> in the form of an address at which data structures related to an object are located in memory.  Running the <code>object2 = {}</code> command results in the allocation of another memory area specifically designed for <code>object2</code> .  Are <code>obect1</code> and <code>object2</code> in the same memory area?  No, each of them is allocated its own section.  That is why when we try to compare <code>object1</code> and <code>object2</code> we get <code>false</code> .  These objects may have an identical structure, but the addresses in the memory where they are located are different, and when comparing, the addresses are checked. <br><br>  By executing the command <code>object3 = object1</code> , we write the <code>object3</code> address of <code>object1</code> into the constant <code>object1</code> .  This is not a new object.  This constant is assigned the address of an existing object.  You can check it like this: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object1 = { x: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object3 = object1; object3.x = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; object1.x; <span class="hljs-comment"><span class="hljs-comment">// false</span></span></code> </pre> <br>  In this example, an object is created in memory and its address is written to the <code>object1</code> constant.  Then in the <code>object3</code> constant the same address is written.  Changing <code>object3</code> leads to a change in the object in memory.  This means that when accessing an object using any other link to it, for example, the one that is stored in <code>object1</code> , we will work with its modified version. <br><br><h2>  <font color="#3AC1EF">Functions, Objects and React</font> </h2><br>  Failure to understand the above mechanism by novice developers often leads to errors, and, perhaps, consideration of the features of working with objects is worthy of a separate article.  However, our current theme is the performance of React applications.  Even experienced developers can make mistakes in this area, who simply do not pay attention to how React applications are affected by the fact that JavaScript variables and constants store not the objects themselves, but only references to them. <br><br>  What does this have to do with React?  React has intelligent mechanisms for saving system resources aimed at improving application performance: if the properties and state of the component do not change, then what the <code>render</code> function displays will not change either.  Obviously, if the component remains the same, it does not need to be re-rendered.  If nothing changes, the <code>render</code> function will return the same as before, so there is no need to execute it.  This mechanism makes React fast.  Something is displayed only when necessary. <br><br>  React checks the properties and state of the components for equality using the standard JavaScript capabilities, that is, it simply compares them using the <code>==</code> operator.  React does not perform "shallow" or "deep" comparison of objects in order to determine their equality.  A ‚Äúshallow comparison‚Äù is a concept used to describe the comparison of each key-value pair of an object, as opposed to a comparison, in which only the addresses of objects in memory (references to them) are compared.  With a ‚Äúdeep comparison‚Äù of objects go even further, and if the value of the object properties being compared are also objects, the comparison of the key-value pairs of these objects is also performed.  This process is repeated for all objects nested in other objects.  React does nothing of the kind, performing only a check for equality of links. <br><br>  If you, for example, change the property of a certain component represented by an object of the form <code>{ x: 1 }</code> to another object that looks exactly the same, React will re-render the component, since these objects are in different memory areas.  If you recall the above example, then if you change the property of a component from <code>object1</code> to <code>object3</code> , React will not re-render such a component, since the <code>object1</code> and <code>object3</code> refer to the same object. <br><br>  Working with functions in JavaScript is organized in the same way.  If React encounters the same functions, the addresses of which differ, it will re-render.  If the ‚Äúnew function‚Äù is just a link to a function that has already been used, there will be no re-rendering. <br><br><h2>  <font color="#3AC1EF">Typical problem when working with components</font> </h2><br>  Here is one of the variants of the scenario of working with components, which, unfortunately, I constantly come across when checking someone else's code: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert('!')} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Before us is very simple component.  It is a button that, when clicked, displays a notification.  Next to the button displays instructions for its use, telling the user whether to press this button.  They control which instruction will be displayed by setting the <code>do</code> ( <code>do={true}</code> or <code>do={false}</code> ) <code>SomeComponent</code> component. <br><br>  Each time the <code>SomeComponent</code> component is re-rendered (when the value of the <code>do</code> property changes from <code>true</code> to <code>false</code> and vice versa), the <code>Button</code> element is rendered again.  The <code>onClick</code> handler, although it is always the same, is created anew each time the <code>render</code> function is called.  As a result, it turns out that every time a component is created in memory, a new function is created, since its creation is performed in the <code>render</code> function, the link to the new address in memory is passed to <code>&lt;Button /&gt;</code> , and the <code>Button</code> component is also rendered again, despite the fact that nothing has changed at all. <br><br>  Talk about how to fix it. <br><br><h2>  <font color="#3AC1EF">Solution to the problem</font> </h2><br>  If the function does not depend on the component (on the <code>this</code> context), then you can define it outside the component.  All instances of the component will use the same function reference, since in all cases it will be the same function.  Here's what it looks like: <br><br><pre> <code class="hljs scala">const createAlertBox = () =&gt; alert('!'); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  Unlike the previous example, <code>createAlertBox</code> , each time <code>render</code> called, will contain the same reference to the same area in memory.  As a result, <code>Button</code> will not be <code>Button</code> again. <br><br>  While the <code>Button</code> component is small and quickly rendered, the above-described problem associated with the internal declaration of functions can also be found in large, complex components that take a long time to complete.  This can significantly slow down the React application.  In this regard, it makes sense to follow the recommendations, according to which such functions should never be declared inside the <code>render</code> method. <br><br>  If the function depends on the component, that is, it cannot be defined outside its limits, the component method can be passed as an event handler: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ createAlertBox = () =&gt; {   alert(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.message); }; get instructions() {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.do) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Click</span></span> the button: ';   }   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'Do</span></span> <span class="hljs-type"><span class="hljs-type">NOT</span></span> click the button: '; } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;div&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.instructions}       &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.createAlertBox} /&gt;     &lt;/div&gt;   ); } }</code> </pre> <br>  In this case, in each instance of <code>SomeComponent</code> when you press a button, various messages will be displayed.  The event handler for a <code>Button</code> element must be unique to <code>SomeComponent</code> .  When passing the <code>cteateAlertBox</code> method, <code>cteateAlertBox</code> doesn‚Äôt matter whether <code>cteateAlertBox</code> will be re-rendered.  It doesn't matter if the <code>message</code> property has changed.  The address of the <code>createAlertBox</code> function <code>createAlertBox</code> not change, which means that the <code>Button</code> element should not be re-rendered.  This allows you to save system resources and improve the rendering speed of the application. <br><br>  All this is good.  But what if the functions are dynamic? <br><br><h2>  <font color="#3AC1EF">Solving a more complex problem</font> </h2><br>  <i>The author of this material asks to pay attention to the fact that he prepared the examples given in this section, taking the first thing that came to his mind, suitable to illustrate the reuse of functions.</i>  <i>These examples are intended to help the reader grasp the essence of the idea.</i>  <i>Although this section is recommended for reading to understand the essence of what is happening, the author advises to pay attention to the comments on the <a href="https://medium.com/%40Charles_Stover/cache-your-react-event-listeners-to-improve-performance-14f635a62e15">original article</a> , as some readers suggested there more advanced options for implementing the mechanisms considered here, which take into account the features of cache invalidation and the memory management mechanisms built into React.</i> <br><br>  So, the situation when in one component there are many unique, dynamic event handlers is extremely common, for example, something like this can be seen in the code where the <code>map</code> array method is used in the <code>render</code> method: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (     &lt;ul&gt;       {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span> onClick={() =&gt; alert(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</code> </pre> <br>  There will be displayed a different number of buttons and create a different number of event handlers, each of which is represented by a unique function, and, in advance, when creating <code>SomeComponent</code> , it is unknown what these functions will be.  How to solve this puzzle? <br><br>  Here memoization will help us, or, to put it simply, caching.  For each unique value, you need to create a function and put it in the cache.  If this unique value is encountered again, it will suffice to take from the cache its corresponding function, which was previously placed in the cache. <br><br>  Here is the implementation of this idea: <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SomeComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    SomeComponent        //   . clickHandlers = {}; //       //    . getClickHandler(key) {   //       ,  .   if (!Object.prototype.hasOwnProperty.call(this.clickHandlers, key)) {     this.clickHandlers[key] = () =&gt; alert(key);   }   return this.clickHandlers[key]; } render() {   return (     &lt;ul&gt;       {this.props.list.map(listItem =&gt;         &lt;li key={listItem.text}&gt;           &lt;Button onClick={this.getClickHandler(listItem.text)} /&gt;         &lt;/li&gt;       )}     &lt;/ul&gt;   ); } }</span></span></code> </pre> <br>  Each array element is processed by the <code>getClickHandler</code> method.  This method, when first called with a certain value, will create a function unique to this value, put it in the cache and return it.  All subsequent calls to this method with passing it the same value will result in it simply returning the function reference from the cache. <br><br>  As a result, re-rendering <code>SomeComponent</code> will not re-render the <code>Button</code> .  Similarly, adding items to the <code>list</code> property will result in the dynamic creation of event handlers for each button. <br><br>  You will need to be creative when creating unique identifiers for handlers if they are defined by more than one variable, but this is not much more complicated than the usual creation of a unique <code>key</code> property for each JSX object resulting from the <code>map</code> method. <br><br>  Here I would like to warn you about possible problems of using array indexes as identifiers.  The fact is that with this approach you may encounter errors if the order of the elements in the array changes or some of its elements are deleted.  So, for example, if at first this array looked like <code>[ 'soda', 'pizza' ]</code> , and then turned into <code>[ 'pizza' ]</code> , and you cached event handlers with the command like <code>listeners[0] = () =&gt; alert('soda')</code> , you will find that when a user clicks on a button to which a handler is assigned with ID 0, and which, according to the contents of the <code>[ 'pizza' ]</code> array, should display the message <code>pizza</code> , the message <code>soda</code> will be displayed.  For the same reason, it is not recommended to use array indices as properties that are keys. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In this article, we explored the features of the internal mechanisms of JavaScript, given that you can speed up the rendering of React-applications.  We hope the ideas presented here will be useful to you. <br><br>  <b>Dear readers!</b>  If you know any interesting ways to optimize React-applications, please share them. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/426053/">https://habr.com/ru/post/426053/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426039/index.html">Emergency launch of Soyuz MS-10 (crew rescued, broadcast over)</a></li>
<li><a href="../426041/index.html">Symbolic solution of linear differential equations and systems by the Laplace transform method using SymPy</a></li>
<li><a href="../426045/index.html">Special exceptions in .NET and how to prepare them</a></li>
<li><a href="../426047/index.html">10 great books for beginners in English</a></li>
<li><a href="../426051/index.html">Improving software debugging skills - some tips</a></li>
<li><a href="../426055/index.html">TensorFlow.js and clmtrackr.js: tracking the direction of the user's gaze in the browser</a></li>
<li><a href="../426059/index.html">Tutu PHP Meetup # 2: Video Speeches</a></li>
<li><a href="../426061/index.html">Microsoft joins the Open Invention Network and "distributes" licenses for 60,000 of its patents.</a></li>
<li><a href="../426063/index.html">HPE MSA Entry Level Innovation Arrays: A More Available Flash Array And Rich Decision Integration</a></li>
<li><a href="../426065/index.html">Smart TV, which itself determines the most interesting channel, or an unusual solution to sudoku for video content</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>