<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Application Coordinator in iOS applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Every year, many changes occur in the iOS platform, and third-party libraries regularly work on networking, data caching, UI rendering via JavaScript,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Application Coordinator in iOS applications</h1><div class="post__text post__text-html js-mediator-article">  Every year, many changes occur in the iOS platform, and third-party libraries regularly work on networking, data caching, UI rendering via JavaScript, and more.  In contrast to all these trends, <strong>Pavel Gurov</strong> spoke about the architectural solution, which will be relevant regardless of what technology you use now or will use in a couple of years. <br><br>  ApplicationCoordinator can be used to build navigation between screens, and at the same time solve a number of problems.  Under the cut demo and instructions for the fastest possible implementation of this approach. <br><br><img src="https://habrastorage.org/webt/xx/ok/ti/xxoktiysvlvnzl1zbhvivxccrry.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>About the speaker:</strong> Pavel Gurov is developing iOS applications in Avito. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2>  Navigation <br></h2><br><br><img src="https://habrastorage.org/webt/9d/dp/od/9ddpodzty4uclncm046g1ms9nvy.jpeg"><br><br>  Navigating between screens is a task that 100% of you face, no matter what you do - social network, taxi call or online bank.  This is what the application starts from when it comes to creating a prototype, when you don‚Äôt even know to the end what the screens will look like, what will be the animations, and whether there will be data caching.  Screens can be empty or static pictures, but the <strong>task of navigation appears in the application as soon as there are more than one of these screens</strong> .  That is almost immediately. <br><br><img src="https://habrastorage.org/webt/um/r-/qo/umr-qogrmhhn58yvlaseyxqyrre.jpeg"><br><br>  The most common methods for building the architecture of iOS applications: MVc, MVVm, and MVp, describe how to build a single screen module.  It also says that modules can know about each other, communicate with each other, etc.  But very little attention is paid to questions, how transitions between these modules are made, who decides on these transitions, and how data is transmitted. <br><br><h2>  UlStoryboard + segues <br></h2><br>  iOS out of the box provides several ways to show the following script screen: <br><br><ol><li>  The well-known <strong>UlStoryboard + segues</strong> , when we designate all transitions between screens in one meta file, and then call them.  Everything is very comfortable and great. </li><li>  Containers - such as UINavigationController.  UITabBarController, UIPageController or possibly self-written containers that can be used both programmatically and with StoryBoards. </li><li>  The present method (_: animated: completion :).  This is simply a method of the UIController class. </li></ol><br>  There are no problems in these tools themselves.  The problem is exactly how they are commonly used.  UINavigationController, performSegue, prepareForSegue, the presentViewController method is all property methods of the UIViewController class.  Apple suggests using these tools within UIViewController itself. <br><br><img src="https://habrastorage.org/webt/gy/_n/vb/gy_nvb7uettqb7xdoillr3ud3m4.jpeg"><br><br>  Proof of this is the following. <br><br><img src="https://habrastorage.org/webt/hv/cq/6p/hvcq6prwv2si1cyrpqkiwchlwds.jpeg"><br><br>  These are comments that appear in your project if you create a new subclass of UIViewController using a standard template.  Written directly - if you use segues and you need to transfer data to the next screen, you must: get this ViewController from segue;  know what type it will be;  bring it to this type and transfer your data there. <br><br>  Such an approach to problems in building navigation. <br><br>  <strong>1. Hard connectedness of screens</strong> <br><br>  This means that screen 1 is aware of the existence of screen 2. Not only is it aware of its existence, it also potentially creates it, or takes it from the segue, knowing what type it is, and transmits some data to it. <br><br>  If we need, under some circumstances, to show instead of screen 2 screen 3, then we have to know about the new screen 3 in the same way to stitch it to screen controller 1. Everything becomes even more difficult if controllers 2 and 3 can be called from a few more places, from screen 1. It turns out that knowledge about screen 2 and 3 will have to be stitched in each of these places. <br><br>  To do this is another half of the trouble, the main problems will begin when changes to these transitions are required, or to support all of this. <br><br><img src="https://habrastorage.org/webt/nx/34/yw/nx34ywvotea8yovx9xuuaxp2lro.jpeg"><br><br>  <strong>2. Reorder Script Controllers</strong> <br><br>  This is also not so easy because of connectedness.  To swap two ViewControllers, it is not enough to go to the UlStoryboard and swap 2 pictures.  You will have to open the code of each of these screens, transfer it to the settings of the next one, change its places, which is not very convenient. <br><br><img src="https://habrastorage.org/webt/lz/_g/n6/lz_gn6x_emphixjobmg-cezayqa.jpeg"><br><br>  <strong>3. Script data transfer</strong> <br><br>  For example, when choosing something on screen 3, we need to update View on screen 1. Since we initially have nothing but ViewController, we‚Äôll have to somehow link these two ViewControllers - no matter how - through delegation or somehow still.  It will be even more difficult if, by the action on screen 3, it will be necessary to update not one screen, but several at once, for example, both the first and the second. <br><br><img src="https://habrastorage.org/webt/wy/gz/gr/wygzgrppqbr4dc6tszklinog714.jpeg"><br><br>  In this case, delegation will not manage, because delegation is a one-to-one relationship.  Someone will say, let's use the notification, someone - through a shared state.  All this makes it difficult to debug and track data flows in our application. <br><br>  As they say, it's better to see 1 time than to hear 100 times.  Let's look at a specific example from this Avito Services Pro application.  This application is for professionals in the service sector, in which it is convenient to track your orders, communicate with customers, look for new orders. <br><br>  Scenario - the choice of the city in editing the user profile. <br><br><img src="https://habrastorage.org/webt/0j/cd/zn/0jcdznc3-8b7fy9lliaairh1s_u.jpeg"><br><br>  Here is a profile editing screen, such is in many applications.  We are interested in the choice of the city. <br><br>  What's going on here? <br><br><ul><li>  The user clicks on the cell with the city, and the first screen decides that it‚Äôs time to add the following screen to the navigation stack.  This is a screen with a list of federal cities (Moscow and St. Petersburg) and a list of regions. </li><li>  If the user selects a federal city on the second screen, the second screen realizes that the script is completed, forwards the selected city to the first one, and the Navigation stack rolls back to the first screen.  The script is considered complete. </li><li>  If the user selects a region on the second screen, the second screen decides that a third screen should be prepared, in which we see a list of cities in this region.  If the user selects a city, then the city is sent to the first screen, rolls back the Navigation stack and the script is considered complete. </li></ul><br>  In this diagram, the problems of connectedness, which I mentioned earlier, are depicted as arrows between the ViewController.  We will get rid of these problems now. <br><br>  <strong>How do we do it?</strong> <br><br><ol><li>  We do <strong>not allow ourselves inside UIViewController to access containers</strong> , that is, self.navigationController, self.tabBarController, or any other custom containers that you made as a property extension.  Now we cannot take our container from the screen code and ask it to do something. <br><br><img src="https://habrastorage.org/webt/av/ci/0x/avci0xx4juu-sitqkcidwmo5woi.jpeg"><br></li><li>  <strong>We do not allow ourselves inside UIViewController to call the performSegue method</strong> and to write code in the prepareForSegue method that would take the next screen and configure it.  That is, we no longer work with segue (with transitions between screens) inside the UIViewController. <br><br><img src="https://habrastorage.org/webt/xp/lh/kq/xplhkqdhp61csbpdmvaulmonqra.jpeg"><br></li><li>  We also <strong>forbid any mention of other controllers inside our particular controller</strong> : no initializations, data transfers and all that. <br><br><img src="https://habrastorage.org/webt/cr/0_/j9/cr0_j999w13tkk8szf2wh1xbjsm.jpeg"><br></li></ol><br><br><h2>  Coordinator <br></h2><br>  Since we are removing all these responsibilities from the UIViewController, we need a new entity that will fulfill them.  Create a new class of objects, and call it the coordinator. <br><br><img src="https://habrastorage.org/webt/ta/ub/t6/taubt6cqzz4_lviz88jbgih3jf4.jpeg"><br><br>  The coordinator is just an ordinary object, to which we pass the NavigationController at the start and call the Start method.  Now do not think about how it is implemented, just see how in this case the scenario of choosing a city will change. <br><br>  Now it does not begin with the fact that we are preparing a transition to a specific NavigationController screen, but we call the Start method at the coordinator, passing it to it in the NavigationController initializer.  The coordinator understands that it‚Äôs time to launch the first screen in NavigationController, which he does. <br><br>  Further, when the user selects a cell with a city, this event is sent to the top of the coordinator.  That is, the screen itself does not know anything - after it, as they say, even the flood.  He sends this message to the coordinator, and then the coordinator responds to this with those (since he has a NavigationController), which sends him the next step - this is the choice of regions. <br><br>  Then the user clicks "Region" - the same picture - the screen itself does not solve anything, only informs the coordinator, which opens the next screen. <br><br>  When the user selects a specific city on the third screen, that city is also transmitted to the first screen through the coordinator.  That is, a message is sent to the coordinator that a city has been selected.  The coordinator sends this message to the first screen and rolls the Navigation stack to the first screen. <br><br>  Note that the <strong>controllers now do not communicate with each other</strong> , deciding who will be next, and not transmit any data to each other.  Moreover, they do not know anything about their surroundings. <br><br><img src="https://habrastorage.org/webt/uz/sy/uo/uzsyuorkw837chi1zn8s39hdkw0.jpeg"><br><br>  If you consider the application within the framework of a three-layer architecture, then the ViewController should ideally fit completely into the Presentation layer and carry as little of the application logic as possible. <br><br>  In this case, we use the coordinator to pull the transition logic to the layer above and remove this knowledge from the ViewController. <br><br><h2>  Demo <br></h2><br>  The presentation and demo <a href="https://github.com/pegurov/CoordinatorsDemo">project</a> is available on Github, below is a demonstration during the report. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/Pt9TGFzLVzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  This is the same scenario: profile editing and city selection. <br><br>  The first screen is the user edit screen.  It shows information about the current user: name and selected city.  There is a button "Select city".  When we click on it, we get to the screen with a list of cities.  If we choose a city there, then the first screen gets this city. <br><br>  Let's see now how it works in the code.  Let's start with the model. <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">City</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> city: <span class="hljs-type"><span class="hljs-type">City?</span></span> }</code> </pre> <br>  <strong>Models are</strong> simple: <br><br><ol><li>  Structure city, which has a field name, string; </li><li>  A user who also has a name and a city property. </li></ol><br>  Next - <strong>StoryBoard</strong> .  It starts with NavigationController.  In principle, here are the same screens that were in the simulator: a user editing screen with a label and a button and a screen with a list of cities, which shows a sign with cities. <br><br><h4>  User edit screen <br></h4><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditViewController: UIViewController, UpdateableWithUser { // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> - var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { didSet { updateView() } } // MARK: - Output - var onSelectCity: (() -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? @IBOutlet private weak var userLabel: UILabel? @IBAction private func selectCityTap(_ sender: UIButton) { onSelectCity?() } override func viewWillAppear(_ animated: <span class="hljs-type"><span class="hljs-type">Bool</span></span>) { super.viewWillAppear(animated) updateView() } private func updateView() { userLabel?.text = "User: \(user?.name ?? ""), \n" + "City: \(user?.city?.name ?? "")" } }</code> </pre><br>  Here there is a property User - this is the user that is transmitted outside - the user we will edit.  Set user here causes the didSet block to be called, which causes the local updateView () method to be called.  All that this method does is simply place the user information into the label, that is, it shows its name and the name of the city in which this user lives. <br><br>  The same thing happens in the viewWillAppear () method. <br><br>  The most interesting place is the handler of clicking on the select button of the city selectCityTap ().  <strong>Here the controller itself does not solve anything</strong> : it does not create any controllers, it does not cause any segue.  All he does is callback calls ‚Äî this is the second property of our ViewController.  The onSelectCity callback has no parameters.  When the user presses a button, this causes the callback to be called. <br><br><h4>  City Selection Screen <br></h4><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> CitiesViewController: UITableViewController { // MARK: - Output - var onCitySelected: ((City) -&gt; <span class="hljs-type"><span class="hljs-type">Void</span></span>)? // MARK: - Private variables - private let cities: [City] = [City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Moscow"), City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Ulyanovsk"), City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "New York"), City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Tokyo")] // MARK: - <span class="hljs-keyword"><span class="hljs-keyword">Table</span></span> - override func tableView(_ tableView: UITableView, numberOfRowsInSection section: <span class="hljs-type"><span class="hljs-type">Int</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cities.count } override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: "cell", <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: indexPath) cell.textLabel?.text = cities[indexPath.<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>].name <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> cell } override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { onCitySelected?(cities[indexPath.<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>]) } }</code> </pre><br>  This screen is a UITableViewController.  The list of cities here is fixed, but it can come from somewhere else.  Further (// MARK: - Table -) a rather trivial table code that shows a list of cities in cells. <br><br>  The most interesting place here is the didSelectRowAt IndexPath handler, a well-known method.  Here again the screen itself does not solve anything.  What happens next after a city is selected?  It simply calls a callback with the only parameter "city". <br><br>  This is where the code for the screens themselves ends.  As we see, they know nothing about their surroundings. <br><br><h4>  Coordinator <br></h4><br>  We turn to the link between these screens. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit protocol UpdateableWithUser: <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> { var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> } } final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UserEditCoordinator { // MARK: - Properties private var <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span> { didSet { updateInterfaces() } } private weak var navigationController: UINavigationController? // MARK: - Init init(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>, navigationController: UINavigationController) { self.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> self.navigationController = navigationController } func <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() { showUserEditScreen() } // MARK: - Private implementation private func showUserEditScreen() { let controller = UIStoryboard.makeUserEditController() controller.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> controller.onSelectCity = { [weak self] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.showCitiesScreen() } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>) } private func showCitiesScreen() { let controller = UIStoryboard.makeCitiesController() controller.onCitySelected = { [weak self] city <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.city = city _ = self?.navigationController?.popViewController(animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } navigationController?.pushViewController(controller, animated: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) } private func updateInterfaces() { navigationController?.viewControllers.<span class="hljs-keyword"><span class="hljs-keyword">forEach</span></span> { (<span class="hljs-meta"><span class="hljs-meta">$0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UpdateableWithUser)?.<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> } } }</code> </pre><br>  The coordinator has two properties: <br><br><ol><li>  User - the user we will edit; </li><li>  NavigationController to which you want to transfer at start. </li></ol><br>  There is a simple init () that fills these properties. <br><br>  Next is the start () method, which causes the <strong>ShowUserEditScreen ()</strong> method to be <strong>called</strong> .  Let us dwell on it in more detail.  This method gets the controller from the UIStoryboard, transfers it to our local user.  Then it puts down the onSelectCity callback and pushes this controller to the Navigation stack. <br><br>  After the user presses the button, the onSelectCity callback is triggered, and this causes the following private method <strong>ShowCitiesScreen () to be</strong> called. <br><br>  In fact, he does almost the same thing - picks up a slightly different controller from the UIStoryboard, puts on it onCitySelected a callback and pushes it into the Navigation stack - that's all that happens.  When the user selects a specific city, this callback is triggered, the coordinator updates the field ‚Äúcity‚Äù of our local user and rolls the Navigation stack to the first screen. <br><br>  Since User is a structure, updating the "city" field causes the didSet block to be called, and the private method <strong>updateInterfaces ()</strong> is called accordingly.  This method traverses the entire Navigation stack and tries to deploy each ViewController as the UpdateableWithUser protocol.  This is the simplest protocol that has only one property - user.  If it succeeds, then he passes it to the updated user.  Thus it turns out that our selected user on the second screen automatically prokakyvaetsya on the first screen. <br><br>  Everything is clear with the coordinator, and the only thing left to show here is the entry point to our application.  This is where it all starts.  In this case, this is the didFinishLaunchingWithOptions method of our AppDelegate. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> UIKit @UIApplicationMain <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppDelegate: UIResponder, UIApplicationDelegate { var <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>: UIWindow? var coordinator: UserEditCoordinator! func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>]?) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { guard let navigationController = <span class="hljs-keyword"><span class="hljs-keyword">window</span></span>?.rootViewController <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? UINavigationController <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } let <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Pavel Gurov", city: City(<span class="hljs-type"><span class="hljs-type">name</span></span>: "Moscow")) coordinator = UserEditCoordinator(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">user</span></span>, navigationController: navigationController) coordinator.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> } }</code> </pre><br>  Here, navigationController comes from the UIStoryboard, a User is created, which we will edit, with a name and a specific city.  Then our coordinator is created with User and navigationController.  It calls the start () method.  The coordinator is transferred to the local property - that‚Äôs basically all.  The scheme is quite simple. <br><br><h4>  Inputs and outputs <br></h4><br>  There are several points that I would like to dwell upon.  You probably noticed that the property in userEditViewController is marked with a comment as Input, and the callbacks of these controllers are marked as Output. <br><br><img src="https://habrastorage.org/webt/xs/_v/kr/xs_vkrwlnwgvdyneeeijb2xsrm0.jpeg"><br><br>  <strong>An input</strong> is any data that may change over time, as well as some ViewController methods that can be called outside.  For example, in UserEditViewController this property User - the User itself or its City parameter can change. <br><br>  <strong>An exit</strong> is any event that the controller wants to communicate to the outside world.  In UserEditViewController, this is a click on the onSelectCity button, and on the city selection screen, this is a click on a cell with a specific city.  The main idea here is, I repeat, that the controller knows nothing and does nothing about these events.  He delegates to decide what to do, to someone else. <br><br>  In Objective-C, I didn‚Äôt like to write saving callbacks because of their terrible syntax.  But with Swift, this is much easier.  Using callbacks in this case is an alternative to the well-known delegation pattern in iOS.  Only here, instead of designating methods in the protocol and saying that the coordinator conforms to this protocol, and then somewhere to write these methods separately, we can immediately very conveniently create an entity in one place, put a callback on it and do it all. <br><br>  True, with this approach, unlike delegation, there is a hard connection between the coordinator's essence and the screen, because the coordinator knows that there is a specific essence of the screen. <br><br>  You can get rid of this in the same way as in delegation using protocols. <br><br><img src="https://habrastorage.org/webt/a-/nm/aa/a-nmaaf8uwdvujtzcvhjmfz0k2c.jpeg"><br><br>  To avoid connectedness, we can <strong>close the</strong> <strong>controller's</strong> <strong>Input and</strong> <strong>Output protocol</strong> . <br><br>  Above is the CitiesOutput protocol, which has exactly one requirement - the presence of an onCitySelected callback.  On the left - an analogue of this scheme on Swift.  Our controller conforms to this protocol, defining the necessary callback.  We do this so that the coordinator does not know about the existence of the class CitiesViewController.  But at some point he will need to configure the output of this controller.  In order to turn all this, we add a factory to the coordinator. <br><br><img src="https://habrastorage.org/webt/vx/hl/0v/vxhl0vp5g0pybl5_6pbasirpfby.jpeg"><br><br>  The factory has a cityOutput () method.  It turns out that our coordinator does not create a controller and does not receive it from somewhere.  A factory is thrown to it, which returns an object closed by a protocol in the method, and he does not know what class this object is. <br><br>  Now the most important thing - why bother to do it all?  <strong>Why do we need to build another additional level, when there were no problems anyway?</strong> <br><br>  One can imagine such a situation: the manager will come to us and ask to do A / B testing of the fact that instead of the list of cities we would have a choice of a city on the map.  If in our application the choice of a city was not in one place, but in different coordinators, in different scenarios, we would have to sew up a flag in each place, throw it out, and raise either one or the other ViewController using this flag.  This is not very convenient. <br><br>  We want to remove this knowledge from the coordinator.  Therefore, it could be done in one place.  In the factory itself, we would make the parameter by which the factory returns a closed protocol, either one controller or another.  Both of them would have a onCitySelected callback, and the coordinator would, in principle, not care which of these screens to work with ‚Äî a map or a list. <br><br><h2>  Composition VS Inheritance <br></h2><br>  The next point that I wanted to dwell on is composition against inheritance. <br><br><img src="https://habrastorage.org/webt/l5/9m/qg/l59mqgla1anz9rqv3sla16adtiw.jpeg"><br><br><ol><li>  The first method, as our coordinator can do, is <strong>to make a composition</strong> when the NavigationController is passed to it outside and stored locally as a property.  It‚Äôs like a composition - we added NavigationController as a property to it. </li><li>  On the other hand, there is an opinion that everything is there in the UI Kit, and we don‚Äôt need to reinvent the wheel.  You can simply take and <strong>inherit UI</strong> <strong>NavigationController</strong> . </li></ol><br>  Each option has its pros and cons, but personally it seems to me that the <strong>composition in this case is more suitable</strong> than inheritance.  Inheritance in general, in principle, less flexible scheme.  If we need, for example, to change Navigation to, say, a UIPageController, then in the first case we can simply close them with a general protocol, such as ‚ÄúShow the next screen‚Äù and conveniently substitute the container we need. <br><br>  From my point of view, the most important argument is that you hide from the end user in the composition all the methods that he does not need.  It turns out that he has less chance to stumble.  You leave <strong>only the</strong> <strong>API that is needed</strong> , for example, the Start method - and that's it.  It does not have the ability to call the PushViewController method, PopViewController, that is, to somehow interfere in the activities of the coordinator himself.  All methods of the parent class are hidden. <br><br><h2>  Storyboards <br></h2><br>  I believe that they deserve special attention along with segues.  Personally, <strong>I support</strong> <strong>segues</strong> , as they allow you to visually quickly familiarize yourself with the script.  When a new developer comes, he does not need to climb the code, Storyboards help with this.  Even if you make an interface with the code, you can leave blank the ViewController, and impose an interface with the code, but leave at least the transitions and the whole point.  The whole essence of Storyboards is in the transitions themselves, and not in the UI layout. <br><br>  Fortunately, the <strong>approach with the coordinators does not limit the choice of tools</strong> .  We can safely use coordinators along with segues.  But it must be remembered that now we cannot work with segues inside a UIViewController. <br><br><img src="https://habrastorage.org/webt/hp/sl/qp/hpslqpf2-het-coms7wczezguo8.jpeg"><br><br>  Therefore, we must in our class override the onPrepareForSegue method.  Instead of doing something inside the controller, we will delegate these tasks to the coordinator again, through a callback.  The onPrepareForSegue method is called, you do not do anything yourself - you do not know what the segue is, what the destination controller is, it doesn‚Äôt matter to you.  You just throw it all into a callback, and the coordinator will figure it out.  He has this knowledge, you do not need this knowledge. <br><br>  In order to make everything easier, you can do it in a certain Base class, so as not to override it in each individual controller.  In this case, the coordinator will be more convenient to work with your segues. <br><br>  Another thing I find comfortable with a Storyboard is to stick to the rule that <strong>one</strong> <strong>Storyboard is equal to one coordinator</strong> .  Then you can greatly simplify everything, make one class at all - the StoryboardCoordinator, and generate the RootType parameter in it, make the initial Navigation controller in the Storyboard and wrap the entire script in it. <br><br><img src="https://habrastorage.org/webt/sm/v2/wz/smv2wzspn7ykrajsui8npmfvcls.jpeg"><br><br>  As you can see, here the coordinator has 2 property: navigationController;  rootViewController of our RootType generic type.  During initialization, we give it not a specific navigationController, but a Storyboard, from which our root Navigation and its first controller fall.  Thus, we will not even need to call any Start methods.  That is, you created a coordinator, he immediately has Navigation, and immediately there is Root.  You can either show the Navigation modally, or take the Root and launch into the existing navigation and continue working. <br><br>  Our UserEditCoordinator in this case would simply be typealias, substituting the type of its RootViewController in a generic parameter. <br><br><h2>  Data transfer back to the script <br></h2><br>  Let's talk about solving the last problem, which I identified at the beginning.  This is the transfer of data back to the script. <br><br><img src="https://habrastorage.org/webt/i6/i9/el/i6i9el9jdxqnjqp2pe80epk27iy.jpeg"><br><br>  Consider the same scenario of choosing a city, but now it will be possible to choose not one city, but several.  In order to show the user that he has selected several cities within one region, we will show a small number next to the region name on the screen with a list of regions, showing the number of cities selected in this region. <br><br>  It turns out that the action on one controller (on the third) should lead to a change in the appearance of several others at once.  That is, in the first one we have to show in the cell with the city, and in the second we must update all the figures from the selected regions. <br><br>  The coordinator simplifies this task by transferring data back to the script ‚Äî this is now as easy as transferring data forward to the script. <br><br>  What's going on here?  The user selects a city.  This message is sent to the coordinator.  The coordinator, as I showed in the demo, is passed through the entire navigation stack and sends updated data to all interested parties.  Accordingly, the ViewController can update its View with this data. <br><br><h2>  Refactoring existing code <br></h2><br>  How to refactor existing code if you want to implement this approach in an existing application, where is MVc, MVVm or MVp? <br><br><img src="https://habrastorage.org/webt/dd/_h/ss/dd_hssepys-qb1ybs9tg6qhnlqo.jpeg"><br><br>  You have a pack of ViewController.  The first thing to do is to divide them into scenarios in which they participate.  In our example there are 3 scenarios: authorization, profile editing, tape. <br><br><img src="https://habrastorage.org/webt/nb/gy/yq/nbgyyqm1qsj1jb_nasqr5wdtdnk.jpeg"><br><br>  Every script we now wrap inside our coordinator.  We should be able to, in fact, start these scenarios from anywhere in our application.  There must be flexibility in this - the <strong>coordinator must be completely self-sufficient</strong> . <br><br>  This approach in the development provides additional convenience.  It lies in the fact that if you are currently working with a specific scenario, you do not need to repeat it every time you start it.  You can quickly start it when you start it, edit something in it, and then remove this temporary start. <br><br>  After we have decided on our coordinators, we need to determine which scenario could lead to the start of another, and from these scenarios make a tree. <br><br><img src="https://habrastorage.org/webt/ya/y0/dn/yay0dneeqirzezm667lwklnkux0.jpeg"><br><br>  In our case, the tree is simple: the LoginCoordinator can start the profile editing coordinator.  Here, almost everything falls into place, but a very important detail remains - our scheme lacks an entry point. <br><br><img src="https://habrastorage.org/webt/38/-0/no/38-0nolfpsqej62yytkzqp-ux6s.jpeg"><br><br>  This entry point will be a special coordinator - <strong>ApplicationCoordinator</strong> .  It is created and started by <strong>AppDelegate</strong> , and then it already controls the logic at the application level, that is, by which coordinator starts right now. <br><br>  We just looked at a very similar scheme, only ViewController instead of coordinators was on it, and we made sure that ViewController did not know anything about each other and did not pass data to each other.  With the coordinators, in principle, you can do the same.  We can mark at them a certain Input (Start method) and Output (onFinish callback).  <strong>Focal points become independent, reusable, and easy to test</strong> .  Coordinators no longer know about each other and communicate, for example, only with ApplicationCoordinator. <br><br>  You need to be careful, because if your application has a lot of these scenarios, then ApplicationCoordinator can turn into a huge god object, it will know about all existing scenarios - this is also not very cool.  Here one must already look ‚Äî perhaps, to split the coordinators into sub-coordinators, that is, to think up such an architecture so that these objects do not grow to incredible sizes.  <strong>Although size is not always a reason for refactoring</strong> . <br><br><h3>  Where to start <br></h3><br>  I advise starting from the bottom up - first implement the individual scenarios. <br><br><img src="https://habrastorage.org/webt/rw/tw/al/rwtwalrny6uxjzbpfhcjzxybzse.jpeg"><br><br>  As a temporary solution, they can be started inside the UIViewController.  That is, as long as you do not have Root or other coordinators, you can make one coordinator and, as a temporary solution, start it from UIViewController, saving it locally in property (as above is nextCoordinator).  When an event occurs, you, as I showed in the demo, create a local property, put a coordinator there and call the Start method on it.  Everything is very simple. <br><br>  Then, when all these coordinators have already been done, the start of one inside the other looks exactly the same.  You have a local property or an array of dependencies of the coordinator type, you put all this in there so that it does not run away, and call the Start method. <br><br><h2>  Total <br></h2><br><ul><li>  <strong>Independent screens and scripts</strong> that do not know anything about each other do not communicate with each other.  We tried to achieve this. <br></li><li>  <strong>Easily change the order of</strong> screens in the application without changing the screen codes.  If everything is done as needed, the only thing that should change in the application when the script changes is not the screen code, but the coordinator code. <br></li><li>  <strong>It simplifies the transfer of data between screens</strong> and other tasks that involve the connection between screens. <br></li><li>      ‚Äî    ,       <strong>  </strong>     . <br></li></ul><br><blockquote> AppsConf 2018  8  9  ‚Äî  !   <a href="https://appsconf.ru/2018/schedule.html"></a> ( <a href="https://habr.com/company/oleg-bunin/blog/423295/"></a>  )  <a href="https://conf.ontico.ru/conference/join/ac2018.html"></a> .      ‚Äî iOS  Android,      ,       ,     ,      . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/423299/">https://habr.com/ru/post/423299/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423287/index.html">Google completes successful inbox experiment</a></li>
<li><a href="../423291/index.html">The Russians set a record: 110 pirated films per person</a></li>
<li><a href="../423293/index.html">How not to shoot yourself in the foot of the state machine</a></li>
<li><a href="../423295/index.html">The most useful mobile development conference</a></li>
<li><a href="../423297/index.html">From Android developer to DevOps</a></li>
<li><a href="../423301/index.html">Selective IP ban on cloudy Windows Server 2012 via RDP</a></li>
<li><a href="../423303/index.html">AI, practical course. Emotion Based Musical Transformation</a></li>
<li><a href="../423305/index.html">Ruin the performance</a></li>
<li><a href="../423307/index.html">GitHub Pull Requests in Visual Studio Code</a></li>
<li><a href="../423309/index.html">DBMS transactions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>