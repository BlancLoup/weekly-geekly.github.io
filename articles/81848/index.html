<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Specification Testing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I wrote about various types of testing and the fact that integration testing is convenient to produce using specifications. In this article ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Specification Testing</h1><div class="post__text post__text-html js-mediator-article">  Recently, I wrote about <a href="http://habrahabr.ru/blogs/testing/81226/">various types of testing</a> and the fact that integration testing is convenient to produce using specifications.  In this article I will show exactly how this testing happens. <br><br>  The specification is a text file describing what to test in the test data.  It indicates what results the program should receive.  The test code finds the real, calculated on the live code results.  And the test engine performs verification of the specification and the calculated results. <br><br>  This approach allows you to declaratively create tests.  Specifications are easy to read and supplement when requirements change.  The test code is compact.  It is easy to maintain and expand. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The article describes the principles of the engine for testing specifications and provides examples of use.  The engine itself is attached to the article.  It can be considered a small library for integration testing. <br><a name="habracut"></a><br><h1>  Library code </h1><br>  Source code - <a href="">stalker98.narod.ru/TestBySpecification.rar</a> <br><br>  The code is commented in detail, so if after reading the article some points remain unclear, the details can be viewed in the implementation.  By and large, the library consists of only 4 classes, which is not much.  The testing engine is in Utils.Common.Tests. <br><br>  For testing, I use the 2008 studio test framework, but can be transferred to NUnit.  To do this, you need to correct the test call in Test.Domain.Documents.DocumentTester.cs and Test.Domain.Polygons.PolygonTester.cs. <br><br><h1>  Subject area for examples </h1><br>  Let the task is to write a document converter from one format to another.  The conversion is tricky, with a lot of mathematical calculations.  The most difficult part of the transformation is the processing of geometric shapes described in the documents.  The customer handed over a set of standard documents that he needs to translate into another format. <br><br>  The development is still far away.  Already written code is covered by unit-tests, each of which tests its module in isolation from the rest of the program.  But there comes a time when it is required to make sure that the written code will work on real data.  Classes of the program in this case should be used together, without isolation from each other.  It is necessary to conduct integration testing. <br><br>  The testing approach is the same - for each sample document sent by the customer, we will create a specification, where we write down the significant results that our program will receive when converting.  From the sent documents we will choose various figures and also we will write for them the specifications.  In the specifications of the figures we will write down the results that our program should come to when processing a particular figure. <br><br><h1>  Specification file </h1><br>  The specification is a text file that describes what to test in the test data.  The file consists of: <ul><li>  Comments at the beginning of the file.  Comments can consist of any characters except $. </li><li>  Checked properties.  The name of each property begins with a $ character.  The end of the property value is determined either by the beginning of the next property, or by the end of the file. </li></ul>  Example (specification file Parallelogram.spec): <br><table border="1"><tbody><tr><td><code><font color="black">4      3 <br> +------+ <br> /      / <br> +------+ <br> 1      2 <br> <br> $Vertices = (0;0) (3;0) (4;1) (1;1) <br> <br> $VerticeCount = 4 <br> $IsRhombus = false <br> $HasSelfIntersections = false</font></code> </td> </tr></tbody></table><br><h1>  Test code </h1><br>  To check the compliance of properties from the specification and real (calculated) property values, you need to know how to find these real property values.  For this, a heir of the Specification class is created and get accessors for properties are written in it, with the same names as in the specification: <br><br> <code><font color="black"><font color="#0000FF">public</font> <font color="#0000FF">class</font> <font color="#2B91AF">PolygonSpecification</font> : <font color="#2B91AF">Specification</font> <br> { <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///    </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000FF">private</font> <font color="#0000FF">int</font> VerticeCount <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> Polygon.Vertices.Count( ); } <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///    </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> IsRhombus <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> Polygon.IsRhombus; } <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///    </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000FF">private</font> <font color="#0000FF">bool</font> HasSelfIntersections <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> Polygon.SelfIntersections.Any( ); } <br> } <br> <br> <font color="#008000">// ...      </font> <br> }</font></code> <br> <br>  Property type must match the name.  For example, properties that begin with Is, Has, or Are are considered by the library as Boolean flags.  And properties ending in Count are integers.  The mechanism of matching the name of a property to its type will be described below. <br><br>  As you can see, the test code is minimized. <br><br><h1>  Challenge tests </h1><br> <code><font color="black">[ <font color="#2B91AF">TestClass</font> ( )] <br> <font color="#0000FF">public</font> <font color="#0000FF">class</font> <font color="#2B91AF">PolygonTester</font> : <font color="#2B91AF">Engine</font> &lt; <font color="#2B91AF">PolygonSpecification</font> &gt; <br> { <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///     PolygonSpecification</font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> [ <font color="#2B91AF">TestMethod</font> ( )] <br> <font color="#0000FF">public</font> <font color="#0000FF">void</font> Polygon_AllSpecifications( ) <br> { <br> <font color="#2B91AF">Assert</font> .IsTrue( TestSpecifications( ), FailedSpecInfo ); <br> } <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///    </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> [ <font color="#2B91AF">TestMethod</font> ( )] <br> <font color="#0000FF">public</font> <font color="#0000FF">void</font> Polygon_DebugSpecification( ) <br> { <br> <font color="#2B91AF">Assert</font> .IsTrue( TestSpecification( <font color="#A31515">""</font> ), FailedSpecInfo ); <br> } <br> }</font></code> <br> <br>  Launch testing in the studio Ctrl + R, A: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/99c/9fc/fb3/99c9fcfb309b2371673f2bc500961ce5.png"><br><br><h1>  Test output </h1><br>  When testing, a log of operations is conducted (it is also a test output).  What specifications and properties have been written to the log, what the test result is, how long the testing took.  If a property has not been tested, this is indicated separately.  Test output can be viewed by clicking on the test in the Test Results window. <br><br>  I wrote 5 more specifications for various shapes.  When testing, it turned out that the IsRhombus property (a boolean flag - whether the figure is a diamond) in the specifications does not match the value that is in the program.  Obviously, an error was made in the method that determines whether the figure is a diamond.  The log looks like this: <br><table border="1"><tbody><tr><td> <code><font color="black">   PolygonTester <br> -----------------------------------------------/  <br> 00:00:00.000 [] HasSelfIntersections <br> 00:00:00.000 [] IsRhombus <br> 00:00:00.000 [] VerticeCount <br> -----------------------------------------------/  <br> 00:00:00.000 [] HasSelfIntersections <br> 00:00:00.000 [] IsRhombus <br> 00:00:00.000 [] VerticeCount <br> -----------------------------------------------/  <br> 00:00:00.000 [] HasSelfIntersections <br> 00:00:00.000 [] IsRhombus <br> -----------------------------------------------/  <br> 00:00:00.000 [] HasSelfIntersections <br> 00:00:00.000 [] IsRhombus <br> -----------------------------------------------/  <br> 00:00:00.000 [] HasSelfIntersections <br> 00:00:00.000 [] IsRhombus <br> 00:00:00.000 [] VerticeCount <br> -----------------------------------------------/  <br> 00:00:00.000 [] HasSelfIntersections <br> 00:00:00.000 [] IsRhombus <br> 00:00:00.000 [] VerticeCount <br> =============================================== <br>   : 3/6 <br>  : 16 <br>  : 00:00:00.0029297 <br> ----------------------------------------------- <br>      : <br> <br>  [1]: <br> IsRhombus: Specified = False, Actual = True <br> <br>  [1]: <br> IsRhombus: Specified = False, Actual = True <br> <br>  [1]: <br> IsRhombus: Specified = False, Actual = True</font></code> </td> </tr></tbody></table>  For an example, I took some simple checks, so everywhere in the computation time it is 00: 00: 00.000.  In real projects, time will be more significant. <br><br><h1>  The mechanism for determining properties </h1><br>  The attentive reader at the moment should not understand two questions - where do the test data come from and what to do if you need to test something other than the equality of two bool or int.  On both questions the answer lies in the mechanism for determining properties. <br><br>  Each property belongs to one specific type.  Moreover, the type here means more than just the .NET type.  It is rather .NET type plus behavior when testing.  The behavior is described by a special object - the property descriptor PropertyDescriptor &lt;T&gt;.  The descriptor defines the convention adopted for property names, the conversion from string to property value and vice versa, as well as the criterion that determines whether the property passed the test or not. <br><br>  I will cite as an example the library descriptor for Boolean flags: <br><br> <code><font color="black"><font color="#0000FF">protected</font> <font color="#2B91AF">PropertyDescriptor</font> &lt; <font color="#0000FF">bool</font> &gt; FlagProperty = <font color="#0000FF">new</font> <font color="#2B91AF">PropertyDescriptor</font> &lt; <font color="#0000FF">bool</font> &gt; <br> { <br> NamePattern = <font color="#A31515">@"(Is|Has|Are)\w+"</font> , <br> Convert = ( <font color="#0000FF">value</font> ) =&gt; <font color="#0000FF">bool</font> .Parse( <font color="#0000FF">value</font> ), <br> Verify = ( specified, actual ) =&gt; specified == actual, <br> };</font></code> <br> <br>  The descriptor specifies the regular expression <b>NamePattern</b> , which specifies a convention for naming properties to which the descriptor applies.  In this case, these are all properties with names that begin with Is, Has, or Are.  <b>Convert</b> sets the function to convert from string to property value.  <b>Verify</b> defines the criteria for passing the test.  In this case, it is a simple test for equality.  That is, if a Boolean value in the specification is equal to the calculated value, then it is considered that the property passed the test.  If Verify is omitted, the property will be read, but will not be tested.  There is also a <b>Translate</b> , which translates the value of a property into a string.  If you do not specify it, then ToString () will be used when outputting to the log. <br><br>  In addition to the boolean flags descriptor, the library has a predefined integer counter descriptor (properties that end with a Count).  It is very similar to the handle parsed above, so I will not bore the reader with his analysis. <br><br><h1>  Specification extension new type </h1><br>  Up to this point I have shown examples on the specifications of the figures.  But we still have document specifications.  Let us imagine the following situation: at the preliminary demonstration of our system, it turned out that the program incorrectly parses the documents.  Instead of Cyrillic, squares are displayed.  To avoid such errors from now on, we will write a test.  Let us complement the specification of the document where the error was found with a line listing the section names: <br><table border="1"><tbody><tr><td> <code><font color="black">$SectionNames = , , </font></code> </td> </tr></tbody></table>  In the test code we add the property of the same name: <br><br> <code><font color="black"><font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///   </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000FF">private</font> <font color="#2B91AF">IEnumerable</font> &lt; <font color="#0000FF">string</font> &gt; SectionNames <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> Document.Sections.Select( s =&gt; s.Name ); } <br> }</font></code> <br> <br>  We could start testing, but it will crash with an error.  The library does not know how to handle this type of property.  None of the well-known library descriptors is appropriate - the name of the property does not match either the flag or the counter.  You need to create a new descriptor.  We will declare it in the test code - this will be enough for the library to find it: <br><br> <code><font color="black"><font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///    </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000FF">protected</font> <font color="#2B91AF">PropertyDescriptor</font> &lt; <font color="#2B91AF">IEnumerable</font> &lt; <font color="#0000FF">string</font> &gt;&gt; SectionNamesProperty = <font color="#0000FF">new</font> <font color="#2B91AF">PropertyDescriptor</font> &lt; <font color="#2B91AF">IEnumerable</font> &lt; <font color="#0000FF">string</font> &gt;&gt; <br> { <br> NamePattern = <font color="#A31515">@"SectionNames"</font> , <br> Convert = ( text ) =&gt; text.Split( <font color="#A31515">','</font> ).Select( n =&gt; n.Trim( ) ), <br> Verify = ( specified, actual ) =&gt; <br> specified.Count( ) == actual.Count( ) &amp;&amp; <br> specified.Intersect( actual ).Count( ) == actual.Count( ), <br> Translate = ( <font color="#0000FF">value</font> ) =&gt; <font color="#0000FF">string</font> .Format( <font color="#A31515">"[{0}]: {1}"</font> , <br> <font color="#0000FF">value</font> .Count( ), <br> <font color="#0000FF">string</font> .Join( <font color="#A31515">", "</font> , <font color="#0000FF">value</font> .ToArray( ) ) ), <br> };</font></code> <br> <br>  The above descriptor is applicable to a property called SectionNames.  Convert separates the line read from the specification by commas and removes the extreme spaces.  Verify determines that a property passes validation when two collections of strings are equivalent ‚Äî each element from the first collection is present in the second collection and vice versa.  Translate is needed so that in case of failure of the check, a meaningful inscription appears in the log, and not the name of an anonymous type.  Translate creates a string that indicates the number of elements in the collection and lists their values ‚Äã‚Äãseparated by commas. <br><br>  The handle is typed, so that when it is filled in, IntelliScense will suggest the types of arguments, and the compiler will check the correctness of the operations. <br><br>  If you later need to add a property with the same behavior, then in the NamePattern descriptor you can change to @ "\ w + Names".  And then all properties ending in Names will use this descriptor. <br><br><h1>  Read test data </h1><br>  Test data can be located anywhere - the library does not impose any restrictions.  However, in practice, it turned out to be convenient to use two test data storage locations - in the specification itself, or in a separate file.  In both cases, the files are stored in the test project DLL as Embedded Resource.  This allows: <ul><li>  Include integration tests along with all data in the version control system. </li><li>  Always have on hand specifications and test data when working in a studio. </li></ul>  I will illustrate both approaches. <br><br><h3>  1) Test data is sewn into specification </h3><br>  Convenient for testing objects for which initialization does not need a lot of data.  A descriptor is declared in the specification class in which the Verify method is not specified.  The value of the property is taken from the dictionary of the read properties of the SpecifiedProperties specification: <br><br> <code><font color="black"><font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///   ,   </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#2B91AF">PropertyDescriptor</font> &lt; <font color="#2B91AF">IEnumerable</font> &lt; <font color="#2B91AF">Vector</font> &gt;&gt; VerticesProperty = <font color="#0000FF">new</font> <font color="#2B91AF">PropertyDescriptor</font> &lt; <font color="#2B91AF">IEnumerable</font> &lt; <font color="#2B91AF">Vector</font> &gt;&gt; <br> { <br> NamePattern = <font color="#A31515">"Vertices"</font> , <br> Convert = ( text ) =&gt; <font color="#2B91AF">Polygon</font> .ParseVertices( text ), <br> }; <br> <br> <font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///  </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000FF">public</font> <font color="#2B91AF">Polygon</font> Polygon <br> { <br> <font color="#0000FF">get</font> { <font color="#0000FF">return</font> <font color="#0000FF">new</font> <font color="#2B91AF">Polygon</font> ( ( <font color="#2B91AF">IEnumerable</font> &lt; <font color="#2B91AF">Vector</font> &gt;) SpecifiedProperties[ <font color="#A31515">"Vertices"</font> ] ); } <br> }</font></code> <br> <br><h3>  2) Test files in external file </h3><br>  Suitable for cases where there is a lot of data, or when the test data is a document.  It is convenient to accept the agreement whereby the names of the specification and test data files are the same.  In this case, the test data lie in the adjacent, relative to the specifications, directory.  Then the reading will be as follows: <br><br> <code><font color="black"><font color="#008000">/// &lt;summary&gt;</font> <br> <font color="#008000">///  </font> <br> <font color="#008000">/// &lt;/summary&gt;</font> <br> <font color="#0000FF">public</font> <font color="#2B91AF">Document</font> Document <br> { <br> <font color="#0000FF">get</font> <br> { <br> <font color="#0000FF">var</font> assembly = <font color="#2B91AF">Assembly</font> .GetExecutingAssembly( ); <br> <font color="#0000FF">var</font> resourceName = <font color="#0000FF">string</font> .Format( <br> <font color="#A31515">"{0}.Documents.Data.{1}.txt"</font> , <br> assembly.GetName( ).Name, Name ); <br> <font color="#0000FF">var</font> stream = assembly.GetManifestResourceStream( resourceName ); <br> <font color="#0000FF">var</font> text = <font color="#0000FF">new</font> <font color="#2B91AF">StreamReader</font> ( stream ).ReadToEnd( ); <br> <br> <font color="#0000FF">return</font> <font color="#2B91AF">Document</font> .CreateFromText( text ); <br> } <br> }</font></code> <br> <br><h1>  Accepted Agreements </h1><br>  The testing engine relies on the following conventions: <ul><li>  For each type of specification, a separate folder is created in the test project. </li><li>  In this folder, an inheritor from the Specification class is created. </li><li>  Specification files are added to the Specs subfolder as Embedded Resource. </li><li>  The specification of the file extension must be .spec </li><li>  Specifications are searched for in the same build from which the testing was launched.  But if required, the assembly can be specified explicitly in Engine.Assembly. </li></ul>  Conveniently next to the test code we put the code that starts the testing, and the legend - which properties can be checked in the specification. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/95b/9d0/1cd/95b9d01cd1c6c5dde889d6aaa8ec6bc4.png"><br><br>  For the case of storing test data in separate files, the structure will be as follows (data, as well as specifications, are stored in an assembly as Embedded Resource): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d7e/d33/2a7/d7ed332a7671ed92a5b6a3ff2e4684d5.png"><br><br>  In specifications: <ul><li>  Property names must match the calculated properties in the test code. </li><li>  Each read property must correspond to exactly one descriptor. </li><li>  The test code should not have an assumption in which order the properties are tested.  Tests should not affect each other. </li></ul>  If some agreement is violated (for example, for a property from the specification, the property of the same name was not found in the test code), a corresponding exception will be raised in the engine during execution. <br><br><h1>  Conclusion </h1><br>  I applied the above approach to integration testing in my latest project and was pleased with the results.  Tests based on specifications are easier to read and maintain compared to similar tests implemented as unit tests. <br><br>  In fact, specifications are files written in Mini DSL (Domain Specific Language).  The library is the engine of this language and will define the API for interacting with the code under test.  In the general purpose language (C #), testing by specification can also be written, but readability will suffer from this and the costs of supporting tests will increase. <br><br>  I think in the future I will add to the library the ability to indicate how long a particular property has the right to calculate.  Then it will be possible to limit the time allotted for testing and check the SLA (System Level Agreements) agreements. </div><p>Source: <a href="https://habr.com/ru/post/81848/">https://habr.com/ru/post/81848/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../81835/index.html">Handy.CMS 3.1 build 2003</a></li>
<li><a href="../81840/index.html">The art of killing dragons</a></li>
<li><a href="../81842/index.html">Recovery of the OS after the ransomware virus</a></li>
<li><a href="../81845/index.html">Implementing ToString () in C ++</a></li>
<li><a href="../81846/index.html">Great Firewall of All Belarus</a></li>
<li><a href="../81849/index.html">Jobs - "This will be the most important thing I've ever done"</a></li>
<li><a href="../81853/index.html">FunGraph.ru - a little humor, the language of statistics</a></li>
<li><a href="../81854/index.html">Simplify Polyline with Douglas-Pecker</a></li>
<li><a href="../81856/index.html">18 Most Expected Computer Concepts</a></li>
<li><a href="../81858/index.html">Access: Order Allow, Deny or Deny, Allow ???</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>