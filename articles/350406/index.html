<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Own data in the system crash dump of Windows</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="By the nature of my activity (Windows Kernel), I regularly have to parse BSOD dumps. There are not single cases when the end-user successfully writes ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Own data in the system crash dump of Windows</h1><div class="post__text post__text-html js-mediator-article"><p>  By the nature of my activity (Windows Kernel), I regularly have to parse BSOD dumps.  There are not single cases when the end-user successfully writes only mini-dumps, in which only the value of the processor registers and the drop stack are stored.  There is simply no other way to debug the client machine.  But what if the stack does not have our driver, and the customer insists that the crashes started after installing the product and ended after the driver of this product was turned off?  In my case, a good solution was to keep a small log of the latest events in a circular buffer.  It remains only to save this cyclic buffer in the dump. </p><br><p>  Under the cut, I'll tell you how to add data from the driver to the dump.  And then extract them using <a href="https://githomelab.ru/pykd/pykd">pykd</a> . <br><img src="https://habrastorage.org/webt/fu/by/1z/fuby1zvtkqrktwahmde8uvvguoo.png" alt="pykd"></p><a name="habracut"></a><br><p>  Beginning with Windows XP SP1 and 2003 Server, the system provides drivers with the ability to add their own data to the kernel dump: <strong>Secondary Callback Data</strong> .  In order for the system to request this data from the driver, you need to register your callback function by calling <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nf-wdm-keregisterbugcheckreasoncallback">KeRegisterBugCheckReasonCallback</a> .  When registering, you need to specify the address of the function that will be called when the kernel <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nc-wdm-kbugcheck_reason_callback_routine">crashes</a> and, in our case ( <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/nc-wdm-kbugcheck_reason_callback_routine">BugCheckSecondaryDumpDataCallback</a> ), provide data that you need to supplement the system dump.  The specified callback function will be called twice: </p><br><ol><li>  The first time the system calls the driver to determine the size of the buffer.  Already at this stage in the input data of the OS indicates the maximum data size ( <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/wdm/ns-wdm-_kbugcheck_secondary_dump_data">KBUGCHECK_SECONDARY_DUMP_DATA</a> .MaximumAllowed), which can be stored in data.  This size depends on the type of system dump that will be generated.  In Windows XP, with the Mini-dump entry setting set, the system provides 4096 bytes (one page of memory). </li><li>  The second time the system requests the data itself. </li></ol><br><p>  Due to the fact that the callback function is called when the kernel of the operating system crashes, serious restrictions are imposed on the function code: do not use memory allocation (everything is allocated in advance), do not access Paged memory (page paging is impossible), do not use mechanisms synchronization (risk of deadlocks).  More details can be found in the article MSDN <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/writing-a-bug-check-callback-routine">Writing Bug Check Callback Routine</a> . </p><br><p>  Strangely enough, there is no example of using the <strong>KeRegisterBugCheckReasonCallback</strong> function in the <a href="https://github.com/Microsoft/Windows-driver-samples">collection of WDK examples</a> .  But the example was found in the open source Microsoft KMDF source code (Kernel-Mode Driver Framework) - <a href="">fxbugcheckcallback.cpp</a> : </p><br><div class="spoiler">  <b class="spoiler_title">Handler Registration: FxInitializeBugCheckDriverInfo function chunks</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The KeRegisterBugCheckReasonCallback exists for xp sp1 and above. So // check whether this function is defined on the current OS and register // for the bugcheck callback only if this function is defined. // RtlInitUnicodeString(&amp;funcName, L"KeRegisterBugCheckReasonCallback"); funcPtr = (PFN_KE_REGISTER_BUGCHECK_REASON_CALLBACK) MmGetSystemRoutineAddress(&amp;funcName); if (NULL == funcPtr) { goto Done; }</span></span></code> </pre> <br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// // Initialize the callback record. // KeInitializeCallbackRecord(callbackRecord); // // Register the bugcheck callback. // funcPtr(callbackRecord, FxpLibraryBugCheckCallback, KbCallbackSecondaryDumpData, (PUCHAR)WdfLdrType); ASSERT(callbackRecord-&gt;CallbackRoutine != NULL);</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Handler implementation: FxpLibraryBugCheckCallback function</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FxpLibraryBugCheckCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( __in KBUGCHECK_CALLBACK_REASON Reason, __in PKBUGCHECK_REASON_CALLBACK_RECORD </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* Record */</span></span></span></span><span class="hljs-function"><span class="hljs-params">, __inout PVOID ReasonSpecificData, __in ULONG ReasonSpecificLength )</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*++ Routine Description: Global (framework-library) BugCheck callback routine for WDF Arguments: Reason - Must be KbCallbackSecondaryData Record - Supplies the bugcheck record previously registered ReasonSpecificData - Pointer to KBUGCHECK_SECONDARY_DUMP_DATA ReasonSpecificLength - Sizeof(ReasonSpecificData) Return Value: None Notes: When a bugcheck happens the kernel bugcheck processor will make two passes of all registered BugCheckCallbackRecord routines. The first pass, called the "sizing pass" essentially queries all the callbacks to collect the total size of the secondary dump data. In the second pass the actual data is captured to the dump. --*/</span></span></span><span class="hljs-function"> </span></span>{ PKBUGCHECK_SECONDARY_DUMP_DATA dumpData; ULONG dumpSize; UNREFERENCED_PARAMETER(Reason); UNREFERENCED_PARAMETER(ReasonSpecificLength); ASSERT(ReasonSpecificLength &gt;= <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(KBUGCHECK_SECONDARY_DUMP_DATA)); ASSERT(Reason == KbCallbackSecondaryDumpData); dumpData = (PKBUGCHECK_SECONDARY_DUMP_DATA) ReasonSpecificData; dumpSize = FxLibraryGlobals.BugCheckDriverInfoIndex * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(FX_DUMP_DRIVER_INFO_ENTRY); <span class="hljs-comment"><span class="hljs-comment">// // See if the bugcheck driver info is more than can fit in the dump // if (dumpData-&gt;MaximumAllowed &lt; dumpSize) { dumpSize = EXP_ALIGN_DOWN_ON_BOUNDARY( dumpData-&gt;MaximumAllowed, sizeof(FX_DUMP_DRIVER_INFO_ENTRY)); } if (0 == dumpSize) { goto Done; } // // Ok, provide the info about the bugcheck data. // dumpData-&gt;OutBuffer = FxLibraryGlobals.BugCheckDriverInfo; dumpData-&gt;OutBufferLength = dumpSize; dumpData-&gt;Guid = WdfDumpGuid2; Done:; }</span></span></code> </pre> </div></div><br><p>  As a demonstration, it is this data that we will extract from the dump.  The data is an array of structures <a href="">FX_DUMP_DRIVER_INFO_ENTRY</a> , each structure has in its fields the version and the name of the driver.  The key to the data in the dump is the GUID specified when writing, in our case it is <a href="">{F87E4A4C-C5A1-4d2f-BFF0-D5DE63A5E4C3}</a> . </p><br><p>  To view the data stored in the dump there is a command debugger. <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-enumtag--enumerate-secondary-callback-data-">Enumtag</a> .  As a result of the command, we will see a raw memory dump.  Here is an example of the data we are interested in: </p><br><pre> <code class="hljs xml">1: kd&gt; .enumtag {65755A40-F146-43EA-8C9136B85728FD35} - 0x0 bytes <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">...</span></span></span><span class="hljs-tag">&gt;</span></span> {F87E4A4C-C5A1-4D2F-BFF0D5DE63A5E4C3} - 0x508 bytes 00 00 00 00 00 00 00 00 01 00 00 00 0D 00 00 00 ................ 00 00 00 00 57 64 66 30 31 30 30 30 00 00 00 00 ....Wdf01000.... 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 90 AC 55 00 00 E0 FF FF ..........U..... 01 00 00 00 0B 00 00 00 00 00 00 00 61 63 70 69 ............acpi 65 78 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ex.............. 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 30 81 F6 00 00 E0 FF FF 01 00 00 00 0B 00 00 00 0............... 00 00 00 00 6D 73 69 73 61 64 72 76 00 00 00 00 ....msisadrv.... 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ 00 00 00 00 00 00 00 00 A0 D3 EB 00 00 E0 FF FF ................ 01 00 00 00 0B 00 00 00 00 00 00 00 76 64 72 76 ............vdrv <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">...</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Working with this format is possible, but not convenient.  <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/reading-bug-check-callback-data">Microsoft offers to write your extension to the debugger</a> : </p><br><blockquote>  It is recommended that you use your own debugger extension. </blockquote><p>  But I am one of the developers of the <a href="https://githomelab.ru/pykd/pykd">pykd</a> project.  The pykd module can be a debugger extension that allows you to use Python to automate debugging.  Therefore, I will show how to extract and visualize data with it.  At once I will make a reservation that the transfer and retrieval of the Secondary Callback Data was added in the latest (at the time of writing) release - 0.3.3.3.  Therefore, if you have an older version already installed, you need to upgrade pykd ( <a href="https://githomelab.ru/pykd/pykd/wikis/Last%2520Release">Last Release</a> ). </p><br><p>  As a test dump, I will use the file used for pykd unit tests - <a href="">win8_x64_mem.cab</a> </p><br><p>  Actually, the whole script is reading and formatting data: </p><br><div class="spoiler">  <b class="spoiler_title">kmdf_tagged.py</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> os <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pykd <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> struct <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_command</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(command)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pykd.getDebugOptions() &amp; pykd.debugOptions.PreferDml: pykd.dprint( <span class="hljs-string"><span class="hljs-string">'&lt;exec cmd="{}"&gt;{}&lt;/exec&gt;'</span></span>.format(command, command), dml = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: pykd.dprint( command ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> buff = bytearray( pykd.loadTaggedBuffer(<span class="hljs-string"><span class="hljs-string">"F87E4A4C-C5A1-4d2f-BFF0-D5DE63A5E4C3"</span></span>) ) entry_type = pykd.typeInfo(<span class="hljs-string"><span class="hljs-string">"Wdf01000!_FX_DUMP_DRIVER_INFO_ENTRY"</span></span>) _struct = struct.Struct( <span class="hljs-string"><span class="hljs-string">"&lt;{}III"</span></span>.format(<span class="hljs-string"><span class="hljs-string">"Q"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pykd.is64bitSystem() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"L"</span></span>) ) name_offset = entry_type.fieldOffset(<span class="hljs-string"><span class="hljs-string">"DriverName"</span></span>) name_size = entry_type.DriverName.size() entry_size = entry_type.size() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(buff) % entry_size: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> RuntimeError( <span class="hljs-string"><span class="hljs-string">"The buffer size ({}) is not a multiple of entry size ({})"</span></span>.format(len(buff), entry_size) ) print(<span class="hljs-string"><span class="hljs-string">"[FxLibraryGlobals.BugCheckDriverInfo]"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> len(buff): ptr, mj, mn, build = _struct.unpack_from(buff) name = str(buff[name_offset : name_offset + name_size]).strip(<span class="hljs-string"><span class="hljs-string">"\0"</span></span>) command = <span class="hljs-string"><span class="hljs-string">"!drvobj {} 7"</span></span>.format(name) print_command( command ) pykd.dprint( <span class="hljs-string"><span class="hljs-string">" "</span></span> * (<span class="hljs-number"><span class="hljs-number">24</span></span> - len(name)) ) pykd.dprint( <span class="hljs-string"><span class="hljs-string">" {:12} "</span></span>.format(<span class="hljs-string"><span class="hljs-string">"({}.{}.{})"</span></span>.format(mj, mn, build)) ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ptr: command = <span class="hljs-string"><span class="hljs-string">"dx ((Wdf01000!{})0x{:x})"</span></span>.format(entry_type.FxDriverGlobals.name(), ptr) print_command( command ) pykd.dprintln( <span class="hljs-string"><span class="hljs-string">""</span></span> ) buff = buff[entry_size:] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(sys.argv) == <span class="hljs-number"><span class="hljs-number">1</span></span>: parse() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> file_name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:]: print(file_name) dump_id = pykd.loadDump(file_name) parse() pykd.closeDump(dump_id)</code> </pre> </div></div><br><p>  The contents of the skipt, in my opinion, is quite simple (parse function): </p><br><ul><li>  By calling pykd.loadTaggedBuffer, we read the contents of the saved data, specifying the GUID as a string argument. </li><li>  Using information from the debugging symbols (creating an instance of the pykd.typeInfo object), we get the offset to the driver name (name_offset), the driver name buffer size (name_size), and the size of a single structure FX_DUMP_DRIVER_INFO_ENTRY (entry_size). </li><li>  For each structure FX_DUMP_DRIVER_INFO_ENTRY in the read buffer, use the standard <a href="https://docs.python.org/2/library/struct.html">python module struct to</a> unpack the structure fields containing a pointer to the global driver object and version.  And then we get the name of the driver, converting it into a string, discarding 0-characters.  And we print the received data using <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-markup-language-commands">DML</a> , if the current environment allows using this markup language (the print_command function). </li></ul><br><p>  Execute the script in the WinDbg debugger: <br><img src="https://habrastorage.org/webt/zg/xf/qq/zgxfqqykw69pka2lhftnajiolow.png" alt="windbg_output"></p><br><p>  If you look at the contents of the script after the parse function, you will notice that the script can take an argument.  The kmdf_tagged.py script is written to demonstrate how to work offline (outside the debugger) if it is given a command line argument.  Each argument passed to the script treats as a path in the dump file, loads this dump and extracts target data from it.  In particular, the script can in a batch mode process the dump files: </p><br><pre> <code class="hljs delphi">~&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> /R .\dumps %i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-comment"><span class="hljs-comment">(*.*)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> @python.exe kmdf_tagged.py %i ~\dumps\win8_x64_mem.cab [FxLibraryGlobals.BugCheckDriverInfo] !drvobj Wdf01000 <span class="hljs-number"><span class="hljs-number">7</span></span> (<span class="hljs-number"><span class="hljs-number">1.13</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) !drvobj acpiex <span class="hljs-number"><span class="hljs-number">7</span></span> (<span class="hljs-number"><span class="hljs-number">1.11</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) dx ((Wdf01000!_FX_DRIVER_GLOBALS*)<span class="hljs-number"><span class="hljs-number">0</span></span>xffffe0000055ac90) &lt;...&gt; !drvobj PEAUTH <span class="hljs-number"><span class="hljs-number">7</span></span> (<span class="hljs-number"><span class="hljs-number">1.7</span></span>.<span class="hljs-number"><span class="hljs-number">6001</span></span>) dx ((Wdf01000!_FX_DRIVER_GLOBALS*)<span class="hljs-number"><span class="hljs-number">0</span></span>xffffe000022081c0) ~\dumps\win8_x64_mem2.cab [FxLibraryGlobals.BugCheckDriverInfo] !drvobj Wdf01000 <span class="hljs-number"><span class="hljs-number">7</span></span> (<span class="hljs-number"><span class="hljs-number">1.13</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) !drvobj acpiex <span class="hljs-number"><span class="hljs-number">7</span></span> (<span class="hljs-number"><span class="hljs-number">1.11</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>) dx ((Wdf01000!_FX_DRIVER_GLOBALS*)<span class="hljs-number"><span class="hljs-number">0</span></span>xffffe0000055ac90) &lt;...&gt; !drvobj PEAUTH <span class="hljs-number"><span class="hljs-number">7</span></span> (<span class="hljs-number"><span class="hljs-number">1.7</span></span>.<span class="hljs-number"><span class="hljs-number">6001</span></span>) dx ((Wdf01000!_FX_DRIVER_GLOBALS*)<span class="hljs-number"><span class="hljs-number">0</span></span>xffffe000022081c0)</code> </pre><br><p>  I hope that my experience (and the contents of this article) will be useful to someone.  And the number of BSODs, the cause of which remains a mystery, will tend to 0. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350406/">https://habr.com/ru/post/350406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350392/index.html">Cuckoo 2.0. We collect the best open source platform for analyzing malicious files</a></li>
<li><a href="../350394/index.html">Network Device Detection</a></li>
<li><a href="../350396/index.html">Implement fast 2D shadows in Unity using 1D shadow mapping</a></li>
<li><a href="../350398/index.html">Native dependency inversion in TypeScript and React</a></li>
<li><a href="../350402/index.html">The most appropriate ways to learn new software</a></li>
<li><a href="../350408/index.html">Digitalization and reality. Should I change something?</a></li>
<li><a href="../350410/index.html">How to make the best sites in Russia</a></li>
<li><a href="../350412/index.html">Duke Nukem Forever, which was not</a></li>
<li><a href="../350414/index.html">Technologies of unmanned vehicles. Yandex lecture</a></li>
<li><a href="../350416/index.html">NRF51822: we are friends of BLE and RTOS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>