<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How signals and slots work in Qt (part 1)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Qt is well known for its signal and slot mechanisms. But how does this work? In this post, we explore the insides of QObject and QMetaObject and revea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How signals and slots work in Qt (part 1)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/f24/054/8b6/f240548b6171eda32a27b5ffde6e5483.png"><br><br>  Qt is well known for its signal and slot mechanisms.  But how does this work?  In this post, we explore the insides of <b>QObject</b> and <b>QMetaObject</b> and reveal their work behind the scenes.  I will give examples of Qt5 code, sometimes edited for brevity and adding formatting. <br><a name="habracut"></a><br><h5>  Signals and Slots </h5><br>  To begin with, let's remember how the signals and slots look, looking at the official <a href="http://qt-project.org/doc/qt-4.8/signalsandslots.html">example</a> .  The header file looks like this: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> QObject { Q_OBJECT <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m_value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_value; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> slots: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value)</span></span></span></span>; signals: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valueChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newValue)</span></span></span></span>; };</code> </pre> <br>  Somewhere, in the .cpp file, we implement <i>setValue ()</i> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Counter::setValue(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> value) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value != m_value) { m_value = value; <span class="hljs-function"><span class="hljs-function">emit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">valueChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value)</span></span></span></span>; } }</code> </pre><br>  Then, we can use the Counter object in this way: <br><br><pre> <code class="cpp hljs">Counter a, b; QObject::connect(&amp;a, SIGNAL(valueChanged(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)), &amp;b, SLOT(setValue(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>))); a.setValue(<span class="hljs-number"><span class="hljs-number">12</span></span>); <span class="hljs-comment"><span class="hljs-comment">// a.value() == 12, b.value() == 12</span></span></code> </pre><br>  This is the original synaxis, which has hardly changed since the beginning of Qt in 1992.  But even if the base API was not changed, the implementation changed several times.  Under the hood, new features were added and other things were happening.  There is no magic here and I will show how it works. <br><br><h5>  MOC or Meta-Object Compiler </h5><br>  Signals and slots, as well as the Qt property system, are based on the capabilities of self-analysis of objects during program execution.  Self-analysis means the ability to list the methods and properties of an object and to have all the information about them, in particular, about the types of their arguments.  <b>QtScript</b> and <b>QML</b> would hardly have been possible without this. <br><br>  C ++ does not provide native support for introspection, so Qt comes with the tool it provides.  This tool is called <b>MOC</b> .  This is a code generator (but not a preprocessor, as some people think). <br><br>  It parses the header files and generates an additional C ++ file that is compiled with the rest of the program.  This generated C ++ file contains all the information necessary for self-analysis. <br>  Qt is sometimes criticized by language purists, as it is an additional code generator.  I will allow Qt documentation <a href="http://qt-project.org/doc/qt-4.8/templates.html">to respond</a> to this criticism.  There is nothing wrong with the code generator and the <b>MOC</b> is an excellent helper. <br><br><h5>  Magic Macros </h5><br>  Can you notice keywords that are not C ++ keywords?  <i>signals</i> , <i>slots</i> , <b>Q_OBJECT</b> , <i>emit</i> , <b>SIGNAL</b> , <b>SLOT</b> .  They are known as the Qt extension for C ++.  These are actually simple macros that are defined in qobjectdefs.h. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> signals public #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> slots </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* nothing */</span></span></span></span></code> </pre><br>  True, signals and slots are simple functions: the compiler treats them like any other function.  Macros still serve a specific purpose: the <b>MOC</b> sees them.  The signals were in the protected section in Qt4 and earlier.  But in Qt5, they are already open to support the new <a href="http://woboq.com/blog/new-signals-slots-syntax-in-qt5.html">syntax</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Q_OBJECT \ public: \ static const QMetaObject staticMetaObject; \ virtual const QMetaObject *metaObject() const; \ virtual void *qt_metacast(const char *); \ virtual int qt_metacall(QMetaObject::Call, int, void **); \ QT_TR_FUNCTIONS </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> \ private: \ Q_DECL_HIDDEN static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **);</span></span></code> </pre><br>  <b>Q_OBJECT</b> defines a bunch of functions and a static <b>QMetaObject</b> .  These functions are implemented in the <b>MOC</b> generated file. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> emit </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* nothing */</span></span></span></span></code> </pre><br>  <i>emit</i> is an empty macro.  He does not even parse the <b>MOC</b> .  In other words, <i>emit is</i> optional and means nothing (except for the developer‚Äôs hint). <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Q_CORE_EXPORT </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qFlagLocation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *method)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QT_NO_DEBUG # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QLOCATION </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\0"</span></span></span><span class="hljs-meta"> __FILE__ </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">":"</span></span></span><span class="hljs-meta"> QTOSTRING(__LINE__) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SLOT(a) qFlagLocation(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1"</span></span></span><span class="hljs-meta">#a QLOCATION) # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIGNAL(a) qFlagLocation(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"2"</span></span></span><span class="hljs-meta">#a QLOCATION) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SLOT(a) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"1"</span></span></span><span class="hljs-meta">#a # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SIGNAL(a) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"2"</span></span></span><span class="hljs-meta">#a #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br>  These macros are simply used by the preprocessor to convert the parameter to a string and add code at the beginning.  In debug mode, we also supplement the line with the file location with a warning if the connection to the signal does not work.  This was added in Qt 4.5 for compatibility.  In order to find out which rows contain information about a row, we use <i>qFlagLocation</i> , which registers the address of a row in a table, with two inclusions. <br><br>  We now turn to the code generated by the <b>MOC</b> . <br><br><h5>  QMetaObject </h5><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObject Counter::staticMetaObject = { { &amp;QObject::staticMetaObject, qt_meta_stringdata_Counter.data, qt_meta_data_Counter, qt_static_metacall, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> } }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObject *Counter::metaObject() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> QObject::d_ptr-&gt;metaObject ? QObject::d_ptr-&gt;dynamicMetaObject() : &amp;staticMetaObject; }</code> </pre><br>  Here we see the implementation of <i>Counter :: metaObject ()</i> and <i>Counter :: staticMetaObject</i> .  They are declared in the <b>Q_OBJECT</b> macro.  QObject :: d_ptr-&gt; metaObject is used only for dynamic metaobjects ( <b>QML</b> objects), therefore, in general, the virtual function <i>metaObject ()</i> simply returns the class's staticMetaObject.  staticMetaObject is built with read-only data.  <b>QMetaObject is</b> defined in qobjectdefs.h as: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QMetaObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ...     ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Call { InvokeMetaMethod, ReadProperty, WriteProperty, <span class="hljs-comment"><span class="hljs-comment">/*...*/</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   const QMetaObject *superdata; const QByteArrayData *stringdata; const uint *data; typedef void (*StaticMetacallFunction)(QObject *, QMetaObject::Call, int, void **); StaticMetacallFunction static_metacall; const QMetaObject **relatedMetaObjects; void *extradata; //     } d; };</span></span></code> </pre><br>  d indirectly symbolizes that all members must be hidden, but they are not hidden in order to preserve the POD and the possibility of static initialization. <br><br>  <b>QMetaObject is</b> initialized using a metaobject of the superdata parent class (QObject :: staticMetaObject in this case).  stringdata and data are initialized with some data, which will be discussed later.  static_metacall is a pointer to a function, initialized by Counter :: qt_static_metacall. <br><br><h5>  Introspection tables </h5><br>  First, let's look at the basic data of a <b>QMetaObject</b> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint qt_meta_data_Counter[] = { <span class="hljs-comment"><span class="hljs-comment">// content: 7, // revision 0, // classname 0, 0, // classinfo 2, 14, // methods 0, 0, // properties 0, 0, // enums/sets 0, 0, // constructors 0, // flags 1, // signalCount // signals: name, argc, parameters, tag, flags 1, 1, 24, 2, 0x05, // slots: name, argc, parameters, tag, flags 4, 1, 27, 2, 0x0a, // signals: parameters QMetaType::Void, QMetaType::Int, 3, // slots: parameters QMetaType::Void, QMetaType::Int, 5, 0 // eod };</span></span></code> </pre><br>  The first 13 int constitute the header.  It provides two columns, the first column is the number, and the second is the array index where the description begins.  In the current case, we have two methods, and the description of the methods begins with index 14. <br>  The description of the method consists of 5 int.  The first is the name, the index in the string table (we will look at it in detail later).  The second integer is the number of parameters, followed by an index, where we can find their description.  Now we will ignore the tag and flags.  For each function, <b>MOC</b> also saves the return type of each parameter, their type, and the name index. <br><br><h5>  Row table </h5><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">qt_meta_stringdata_Counter_t</span></span></span><span class="hljs-class"> {</span></span> QByteArrayData data[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> stringdata[<span class="hljs-number"><span class="hljs-number">47</span></span>]; }; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QT_MOC_LITERAL(idx, ofs, len) \ Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \ offsetof(qt_meta_stringdata_Counter_t, stringdata) + ofs \ - idx * sizeof(QByteArrayData) \ ) static const qt_meta_stringdata_Counter_t qt_meta_stringdata_Counter = { { QT_MOC_LITERAL(0, 0, 7), QT_MOC_LITERAL(1, 8, 12), QT_MOC_LITERAL(2, 21, 0), QT_MOC_LITERAL(3, 22, 8), QT_MOC_LITERAL(4, 31, 8), QT_MOC_LITERAL(5, 40, 5) }, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">Counter\0valueChanged\0\0newValue\0setValue\0</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">value\0</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta"> }; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> QT_MOC_LITERAL</span></span></code> </pre><br>  Basically, it is a static QByteArray array (created by the <b>QT_MOC_LITERAL</b> macro), which refers to a specific index in the row below. <br><br><h5>  Signals </h5><br>  <b>MOC</b> also implements signals.  They are functions that simply create an array of pointers to arguments and pass them to <i>QMetaObject :: activate</i> .  The first element of the array is the return value.  In our example, this is 0, because the return value is void.  The third argument passed to the function to activate is the signal index (0 in this case). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// SIGNAL 0 void Counter::valueChanged(int _t1) { void *_a[] = { 0, const_cast&lt;void*&gt;(reinterpret_cast&lt;const void*&gt;(&amp;_t1)) }; QMetaObject::activate(this, &amp;staticMetaObject, 0, _a); }</span></span></code> </pre><br><h5>  Slot call </h5><br>  It is also possible to call a slot by its index using the qt_static_metacall function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Counter::qt_static_metacall(QObject *_o, QMetaObject::Call _c, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _id, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **_a) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_c == QMetaObject::InvokeMetaMethod) { Counter *<span class="hljs-keyword"><span class="hljs-keyword">_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Counter *&gt;(_o); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (_id) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">_t</span></span>-&gt;valueChanged((*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(*)&gt;(_a[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">_t</span></span>-&gt;setValue((*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>(*)&gt;(_a[<span class="hljs-number"><span class="hljs-number">1</span></span>]))); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: ; } ... } ... }</code> </pre><br><br>  Array of pointers to arguments in the same format as in signals.  _a [0] is not touched, because everywhere void returns here. <br><br><h5>  Index Note </h5><br>  For each <b>QMetaObject</b> , signals, slots, and other called object methods, indices starting from 0 are given. They are ordered in such a way that signals come first, then slots, and then other methods.  These indices inside are called relative indices.  They do not include parent indexes.  But in general, we don‚Äôt want to know a more global index that does not belong to a particular class, but includes all other methods in the inheritance chain.  Therefore, we simply add the offset to the relative index and get the absolute index.  This index, used in the public API, is returned by functions of the form QMetaObject :: indexOf {Signal, Slot, Method}. <br><br>  The join mechanism uses an array indexed for signals.  But all slots occupy a place in this array and usually there are more slots than signals.  So, with Qt 4.6, a new internal index for signals appears, which includes only the indices used for signals.  If you are developing with Qt, you only need to know about the absolute index for the methods.  But while you are viewing <b>QObject</b> source code, you should know the difference between these three indices. <br><br><h5>  How the connection works </h5><br>  The first thing that Qt does when connecting is looking for signal and slot indices.  Qt will look at the metaobject row tables for the corresponding indexes.  Then, a QObjectPrivate :: Connection object is created and added to the internal lists. <br><br>  What information is needed to store each connection?  We need a way to quickly access the connection for a given signal index.  Since there can be several slots attached to the same signal, we need to have a list of attached slots for each signal.  Each connection must contain a recipient object and a slot index.  We also want the connections to be automatically deleted when the recipient is deleted, so each recipient object needs to know who is connected to it so that it can delete the connection. <br><br>  Here is the QObjectPrivate :: Connection defined in qobject_p.h: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QObjectPrivate</span></span></span><span class="hljs-class">:</span></span>:Connection { QObject *sender; QObject *receiver; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { StaticMetaCallFunction callFunction; QtPrivate::QSlotObjectBase *slotObj; }; <span class="hljs-comment"><span class="hljs-comment">//      ConnectionList Connection *nextConnectionList; //    Connection *next; Connection **prev; QAtomicPointer&lt;const int&gt; argumentTypes; QAtomicInt ref_; ushort method_offset; ushort method_relative; uint signal_index : 27; //    ( QObjectPrivate::signalIndex()) ushort connectionType : 3; // 0 == auto, 1 == direct, 2 == queued, 4 == blocking ushort isSlotObject : 1; ushort ownArgumentTypes : 1; Connection() : nextConnectionList(0), ref_(2), ownArgumentTypes(true) { // ref_ 2        QMetaObject::Connection } ~Connection(); int method() const { return method_offset + method_relative; } void ref() { ref_.ref(); } void deref() { if (!ref_.deref()) { Q_ASSERT(!receiver); delete this; } } };</span></span></code> </pre><br>  Each object has an array of connections: this is an array that links each signal to QObjectPrivate :: Connection lists.  Each object also has reverse lists of connections of objects connected for automatic deletion.  This is a doubly linked list. <br><img src="https://habrastorage.org/getpro/habr/post_images/0ab/6de/c98/0ab6dec98c237b788b7ea2e97d2e99fc.png"><br>  Linked lists are used to enable the quick addition and removal of objects.  They are implemented with the presence of pointers to the next / previous node inside QObjectPrivate :: Connection.  Note that the prev pointer from senderList is a pointer to a pointer.  This is because we really do not point to the previous node, but rather to the next, in the previous node.  This pointer is used only when the connection is destroyed.  This allows not to have a special case for the first element. <br><img src="https://habrastorage.org/getpro/habr/post_images/7fd/fc7/d78/7fdfc7d785c3b39d6764b4f152d0c4fa.png"><br><h5>  Signal emission </h5><br>  When we call the signal, we saw that it calls the code generated by the <b>MOC</b> , which already calls <i>QMetaObject :: activate</i> .  Here is the implementation (with notes) of this method in qobject.cpp: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QMetaObject::activate(QObject *sender, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QMetaObject *m, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_signal_index, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **argv) { <span class="hljs-comment"><span class="hljs-comment">/*      ,     */</span></span> activate(sender, QMetaObjectPrivate::signalOffset(m), local_signal_index, argv); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QMetaObject::activate(QObject *sender, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signalOffset, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> local_signal_index, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **argv) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> signal_index = signalOffset + local_signal_index; <span class="hljs-comment"><span class="hljs-comment">/*      64 ,   0,  ,            ,          */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!sender-&gt;d_func()-&gt;isSignalConnected(signal_index)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      /* ‚Ä¶     QML ,   ... */ /*  ,      connectionLists  */ QMutexLocker locker(signalSlotLock(sender)); /*  connectionList   ( ) */ QObjectConnectionListVector *connectionLists = sender-&gt;d_func()-&gt;connectionLists; const QObjectPrivate::ConnectionList *list = &amp;connectionLists-&gt;at(signal_index); QObjectPrivate::Connection *c = list-&gt;first; if (!c) continue; //    last,  ,       ,    QObjectPrivate::Connection *last = list-&gt;last; /* ,    */ do { if (!c-&gt;receiver) continue; QObject * const receiver = c-&gt;receiver; const bool receiverInSameThread = QThread::currentThreadId() == receiver-&gt;d_func()-&gt;threadData-&gt;threadId; //       ,      if ((c-&gt;connectionType == Qt::AutoConnection &amp;&amp; !receiverInSameThread) || (c-&gt;connectionType == Qt::QueuedConnection)) { /*       */ queued_activate(sender, signal_index, c, argv); continue; } else if (c-&gt;connectionType == Qt::BlockingQueuedConnection) { /* ...  ... */ continue; } /*  ,   sender()   ,     */ QConnectionSenderSwitcher sw; if (receiverInSameThread) sw.switchSender(receiver, sender, signal_index); const QObjectPrivate::StaticMetaCallFunction callFunction = c-&gt;callFunction; const int method_relative = c-&gt;method_relative; if (c-&gt;isSlotObject) { /* ‚Ä¶  ‚Ä¶  Qt5      ... */ } else if (callFunction &amp;&amp; c-&gt;method_offset &lt;= receiver-&gt;metaObject()-&gt;methodOffset()) { /*    callFunction (  qt_static_metacall,  MOC),    */ /*   ,   metodOffset  (    ) */ locker.unlock(); //          callFunction(receiver, QMetaObject::InvokeMetaMethod, method_relative, argv); locker.relock(); } else { /*      */ const int method = method_relative + c-&gt;method_offset; locker.unlock(); metacall(receiver, QMetaObject::InvokeMetaMethod, method, argv); locker.relock(); } // ,        if (connectionLists-&gt;orphaned) break; } while (c != last &amp;&amp; (c = c-&gt;nextConnectionList) != 0); }</span></span></code> </pre><br>  <b>UPD</b> : translation of the second part <a href="http://habrahabr.ru/post/215181/">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/214379/">https://habr.com/ru/post/214379/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../214363/index.html">Introducing Nokia Imaging SDK 1.1 with support for Windows 8.1 and Windows RT 8.1</a></li>
<li><a href="../214367/index.html">Dykstra from Tim from Stanford</a></li>
<li><a href="../214371/index.html">Contract programming in PHP</a></li>
<li><a href="../214373/index.html">Starry Sky on Canvas. Constellations</a></li>
<li><a href="../214377/index.html">Iron in the service of the algorithm (continued)</a></li>
<li><a href="../214385/index.html">Results Tizen App Chellange</a></li>
<li><a href="../214387/index.html">My smart home on .NET</a></li>
<li><a href="../214389/index.html">‚ÄúTo wash or not to wash?‚Äù Or how we launch our mobile application</a></li>
<li><a href="../214393/index.html">Exchange Server 2013 Service Pack 1: New Features</a></li>
<li><a href="../214395/index.html">New models Siklu licensed range of 70 GHz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>