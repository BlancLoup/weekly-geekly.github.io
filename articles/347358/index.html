<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unit tests. Quick start - effective result (with examples in C ++)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Instead of intro 
 Hello! Today I would like to talk about how simple and happy to write test code. The fact is that in our company we constantly moni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unit tests. Quick start - effective result (with examples in C ++)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/tt/3t/nb/tt3tnbrfrleifqxck8acjiccck4.jpeg"><br><br><h2>  Instead of intro </h2><br>  Hello!  Today I would like to talk about how simple and happy to write test code.  The fact is that in our company we constantly monitor and greatly appreciate the quality of our products.  No wonder - after all, millions of people work with them every day, and for us it‚Äôs simply unacceptable to let down our users.  Just imagine, the deadline for submission of reports has come, and you carefully and with pleasure, using the <a href="https://sbis.ru/">VLSI</a> user interface carefully designed by us, prepared the documents, rechecked every tsifik once again, and again made sure that there would be no meetings with polite tax people.  And here, with a slight click of the mouse, click on the cherished button ‚ÄúSend‚Äù and then BACH!  the application crashes, documents are destroyed, the monitor burns with a hot flame, and it seems that people in uniform are already knocking hard at the door, demanding that reports be submitted.  Something like this can happen: <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/lr/f9/lh/lrf9lhm31bdxlfr7l-6xaajpah4.jpeg"><br><br>  Fuh ... Well, I agree, with the monitor, probably, still got excited;) But the situation that has arisen may leave the user of our product not in the most benign state of mind. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, since we at Tenzor value the morale of our clients, it is very important for us that the products we have developed are comprehensively tested - in our company, this is largely ensured by almost 300 testers who control the quality of our products.  However, we are trying to control quality at all stages of development.  Therefore, in the development process, we try to use automated unit testing, not to mention integration, load and acceptance tests. <br><br>  However, today from our experience of interviews it can be noted that not everyone has the skills to create test code.  Therefore, we want to tell ‚Äúon the fingers‚Äù about the principles of creating test code, and also show how you can create unit tests that are easy to maintain and upgrade. <br><br>  The following material was largely <a href="https://www.youtube.com/watch%3Fv%3D0kDgcvyAIsU">presented</a> at the C ++ Russia conference, so you can read it, listen to it and even see it. <br><br><h2>  Characteristics of good unit tests </h2><br>  One of the first tasks to be faced with when writing any automatically executed test is handling external dependencies.  By <b>external dependency</b> we mean entities with which the code under test interacts, but over which it does not have complete control.  These uncontrolled external dependencies include operations that require interaction with the hard disk, database, network connection, random number generator, and others. <br><br>  I must say that automated testing can be done at different levels of the system, but we will consider issues related specifically to unit tests. <br><br>  For a clearer understanding of the principles underlying the examples below, the code has been simplified (for example, <i>const</i> qualifiers are omitted).  The test samples themselves are implemented using the <a href="https://github.com/google/googletest"><i>GoogleTest</i></a> library. <br><br>  One of the most important differences between the integration test and the unit test is that the unit test has complete control over all external dependencies.  This allows to achieve the fact that a single unit test has the following properties: <br><br><ul><li>  we repeat - as a result of launching a test at the output always produces the same value (always brings the system to the same state); </li><li>  stable - at whatever time of the day or night the test runs, it either always passes or it does not pass; </li><li>  isolated - the order of launching all existing unit tests, as well as actions performed inside the tests, do not affect the result of the execution of a single unit test. </li></ul><br>  All this leads to the fact that the launch of multiple unit tests with the described properties can be automated and carried out, in fact, with the press of a single button. <br><br>  A good unit test runs fast.  Because if there are a lot of tests in the project, and the run of each of them will be long, then the run of all the tests will take considerable time.  This can lead to the fact that with changes in the code, the run of all unit tests will be performed less frequently, because of this, the time it takes for the system to respond to changes will increase, which means that the time it detects an introduced error will increase. <br><br>  It is said that with some applications, testing everything is much easier, but we, mere mortals, who do not possess such a <a href="https://www.youtube.com/watch%3Fv%3D_0P6EuEkUKg">high-speed spinner</a> , are not so sweet.  So we will understand further. <br><br><img src="https://habrastorage.org/webt/_5/qy/8q/_5qy8qvemudl_qzhlzglugzrfwo.jpeg"><br><br><h2>  Unit testing.  Where it all begins </h2><br>  Writing any unit test begins with the selection of its name.  One of the recommended approaches to the name of a unit test is to form its name in three parts: <br><br>  - name of the working unit under test <br>  - test script <br>  - Expected Result <br><br>  Thus, we can receive, for example, such names: <i>Sum_ByDefault_ReturnsZero</i> , <i>Sum_WhenCalled_CallsTheLogger</i> .  They are read as a complete sentence, and this increases the simplicity of working with tests.  To understand what is being tested, it is enough, without understanding the logic of the code, just to read the names of the tests. <br><br>  But in some cases you still need to understand the logic of the test code.  To simplify this work, the unit test structure can be formed from three parts: <br><br>  - part of <b>Arrange</b> - here is the creation and initialization of the objects required for the test <br>  - part of the <b>Act</b> - actually conducting the test action <br>  - part of <b>Assert</b> - here we compare the obtained result with the reference <br><br>  In order to increase the readability of tests, it is recommended to separate these parts from each other with a blank line.  This will orient those who read your code and help you quickly find the part of the test that interests them the most. <br><br>  When covering the logic of code operation with unit tests, each module of the code under test should perform one of the following actions.  So, you can test: <br><br>  - return result <br>  - system state change <br>  - interaction between objects <br><br>  In the first two cases, we are faced with the <b>task of separation</b> .  It consists in not introducing the code into the means of testing, over which we do not have complete control.  In the latter case, the <b>recognition problem</b> has to be <b>solved</b> .  It consists in gaining access to values ‚Äã‚Äãthat are inaccessible for the code under test: for example, when control is required of receiving logs by a remote web server. <br><br>  To write the code under test, you need to be able to implement and apply fake objects for the intended purpose. <br><br>  There are several approaches to the classification of fake objects. We will consider one of the basic ones, which corresponds to the tasks solved in the process of creating test code. <br><br>  It identifies two classes of fake objects: <b>stub objects</b> and <b>mock objects</b> .  They are designed to solve different problems: a stub-object - to solve the problem of separation, and a mock-object - to solve the problem of recognition.  The biggest difference is that when using a stub-object <b>assert</b> (the operation of comparing the obtained result with the reference one) is performed between the test and the tested code, and the use of a mock-object implies its analysis, which shows whether the test passed or not. <br><br>  If the logic of work can be tested on the basis of an analysis of the return value or a change in the state of the system, then do so.  As practice shows, unit tests that use mock objects are more difficult to create and maintain than tests that use stub objects. <br><br>  Consider the principles on the example of working with legacy ( <i>legacy</i> ) code.  Suppose we have a class <i>EntryAnalyzer</i> , presented in Fig.  1, and we want to cover with unit tests its public <i>Analyze</i> method.  This is due to the fact that we plan to change this class, or we want to document its behavior in this way. <br><br>  To cover the code with tests, we define its external dependencies.  In our case, these dependencies are two: working with a database and working with a network connection, which is conducted in the classes of <i>WebService</i> and <i>DatabaseManager,</i> respectively. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EntryAnalyzer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Analyze</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::stringename )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ename.size() &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> ) { webService.LogError( <span class="hljs-string"><span class="hljs-string">"Error: "</span></span>+ ename ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-literal"><span class="hljs-literal">false</span></span>== dbManager.IsValid( ename ) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: DatabaseManager dbManager; WebService webService; };</code> </pre> <br>  <i>Fig.1.</i>  <i>Code of class under test that is not suitable for covering by unit tests.</i> <br><br>  Thus, for the class <i>EntryAnalyzer,</i> they are external dependencies.  Potentially, between testing <i>dbManager.IsValid</i> and the final instruction ‚Äúreturn true‚Äù there may be a code that requires testing.  When writing tests, we can get access to it only after we get rid of the existing external dependencies.  To simplify further presentation, such additional code is not given. <br><br>  Now consider ways to break external dependencies.  The structure of these classes is shown in Fig.  2 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WebService</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> msg )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ,     */</span></span> } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DatabaseManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ename )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ,      */</span></span> } };</code> </pre> <br>  <i>Fig.2.</i>  <i>Class structure for working with network connection and database</i> <i><br></i> <br>  To write test code, it is very important to be able to develop, relying on contracts, and not on specific implementations.  In our case, the contract of the original class is the determination of whether the cell name ( <i>entry</i> ) is valid or not. <br><br>  In C ++, this contract can be documented as an abstract class that contains the virtual method <i>IsValid</i> , the body of which is not required to be defined.  Now you can create two classes that implement this contract: the first will interact with the database and be used in the ‚Äúcombat‚Äù (production) version of our program, and the second will be isolated from uncontrolled dependencies and will be used directly for testing.  The described scheme is shown in Fig.  3 <br><br><img src="https://habrastorage.org/webt/yw/x1/3s/ywx13sj-3r-zhqvd8ogrn5ly62y.png"><br>  <i>Fig.3.</i>  <i>Introducing an interface to break the dependency on database interaction</i> <i><br></i> <br>  An example of code allowing to break the dependency, in our case from the database, is presented in Fig.  four. <br><br><img src="https://habrastorage.org/webt/hp/o5/fn/hpo5fnanil0dvdqkhhvgagjpslq.png"><br>  <i>Fig.4.</i>  <i>An example of classes that allow for breaking a dependency on a database</i> <i><br></i> <br>  In the above code, you should pay attention to the <i>override</i> specifier for methods that implement the functionality specified in the interface.  This increases the reliability of the generated code, as it clearly indicates to the compiler that the signatures of these two functions must match. <br><br>  You should also pay attention to the declaration of the abstract class virtual.  If this looks surprising and unexpected, then you can round up the book by <a href="http//www.aristeia.com/books.html">S. Myers ‚ÄúEffective use of C ++‚Äù</a> and read it avidly, with special attention given to rule No. 7 there;). <br><br><div class="spoiler">  <b class="spoiler_title">Spoiler for especially impatient</b> <div class="spoiler_text">  This is necessary to avoid memory leaks when a derived class object is destroyed via a pointer to the base class. <br></div></div><br><h2>  Break dependencies using stub objects </h2><br>  Consider the steps that are needed to test our class <i>EntryAnalyzer</i> .  As mentioned above, the implementation of tests using stub objects is somewhat simpler than using mock objects.  Therefore, we first consider how to break the dependency on the database. <br><br>  <b>Method 1. Parameterization of the constructor</b> <br><br>  First, we get rid of the hard-coded usage of the <i>DatabaseManager</i> class.  To do this, go to work with a pointer, such as <i>IDatabaseManager</i> .  To preserve the performance of a class, we also need to define a ‚Äúdefault‚Äù constructor, in which we indicate the need to use a ‚Äúcombat‚Äù implementation.  The made changes and the received modified class are presented on fig.  five. <br><br><img src="https://habrastorage.org/webt/kn/b0/vi/knb0viurte87thci1ewnmie3ndm.png"><br>  <i>Fig.5.</i>  <i>The class after refactoring, which allows you to break the dependency on the database</i> <br><br>  To implement dependencies, add another class constructor, but now with an argument.  This argument just will determine which interface implementation should be used.  The constructor that will be used to test the class is shown in Fig.  6 <br><br><img src="https://habrastorage.org/webt/xa/wh/ol/xawholhg50rhwpbvbf7ktqyqtue.png"><br>  <i>Fig.6.</i>  <i>Constructor used for dependency injection</i> <br><br>  Now our class looks like this (the constructor used to test the class is circled in green): <br><br><img src="https://habrastorage.org/webt/5o/cl/es/5oclesnprbkvjnehgesgj8vqs4w.png"><br>  <i>Fig.7.</i>  <i>Class refactoring to allow database dependency to break</i> <br><br>  Now we can write the following test, which demonstrates the result of processing a valid cell name (see Figure 8): <br><br><pre> <code class="cpp hljs">TEST_F( EntryAnalyzerTest, Analyze_ValidEntryName_ReturnsTrue ) { <span class="hljs-function"><span class="hljs-function">EntryAnalyzer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::make_unique&lt;FakeDatabaseManager&gt;( </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ) )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ea.Analyze( <span class="hljs-string"><span class="hljs-string">"valid_entry_name"</span></span> ); ASSERT_EQ( result, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FakeDatabaseManager</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IDatabaseManager { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WillBeValid; FakeDatabaseManager( <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> will_be_valid ) : WillBeValid( will_be_valid ) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ename )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WillBeValid; } };</code> </pre> <br>  <i>Fig.8.</i>  <i>An example of a test that does not interact with a real database.</i> <br><br>  Changing the value of the constructor parameter of a fake object affects the result of the execution of the <i>IsValid</i> function.  In addition, it allows you to reuse the fake-object in tests that require both affirmative and negative results of accessing the database. <br>  Consider the second way to parameterize the constructor.  In this case, we need the use of <b>factories</b> - objects that are responsible for creating other objects. <br><br>  First, we will do the same steps to replace the hard-coded use of the <i>DatabaseManager</i> class - let's move on to using a pointer to an object that implements the required interface.  But now in the ‚Äúdefault‚Äù constructor we will assign the responsibility for creating the required objects to the factory. <br><br>  The resulting implementation is shown in Fig.  9. <br><br><img src="https://habrastorage.org/webt/te/ne/ud/teneud8x85e1ckkj3f1otbese1g.png"><br>  <i>Fig.</i>  <i>9. Class refactoring to use factories to create an object interacting with a database.</i> <i><br></i> <br>  Given the factory class entered, the test itself can now be written as follows: <br><br><pre> <code class="cpp hljs">TEST_F( EntryAnalyzerTest, Analyze_ValidEntryName_ReturnsTrue ) { DbMngFactory::SetManager( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;FakeDatabaseManager&gt;( <span class="hljs-literal"><span class="hljs-literal">true</span></span> ) ); EntryAnalyzer ea; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ea.Analyze( <span class="hljs-string"><span class="hljs-string">"valid_entry_name"</span></span> ); ASSERT_EQ( result, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DbMngFactory</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IDatabaseManager&gt; Create() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> == pDbMng ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;DatabaseManager&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( pDbMng ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">unique_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;IDatabaseManager&gt; &amp;&amp;p_mng )</span></span></span><span class="hljs-function"> </span></span>{ pDbMng = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( p_mng ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;IDatabaseManager&gt; pDbMng; };</code> </pre> <br>  <i>Fig.10.</i>  <i>Another example of a test that does not interact with a real database.</i> <i><br></i> <br>  An important difference of this approach from the previously considered one is the use of the same constructor for creating objects both for the ‚Äúcombat‚Äù and for the test code.  The factory takes all the care to create the required objects.  This allows you to delineate the responsibility areas of classes.  Of course, a person who will deal with your code will need some time to understand the relationships between these classes.  However, in perspective, this approach allows for a more flexible code adapted for long-term support. <br><br>  <b>Method 2. "Select and override"</b> <br><br>  Consider another approach to breaking the database dependency - ‚ÄúExtract and override‚Äù.  Perhaps its use will seem simpler and will not cause such emotions: <br><br><img src="https://habrastorage.org/webt/45/ys/gt/45ysgttf-qmm7ggdjd7wyxzn37o.jpeg"><br><br>  Its main idea is to localize the dependencies of the ‚Äúcombat‚Äù class in one or several functions, and then redefine them in the heir class.  Consider in practice this approach. <br><br>  Let's start with the localization of dependencies.  In our case, the dependency is to refer to the <i>IsValid</i> method of the <i>DatabaseManager</i> class.  We can isolate this dependence in a separate function.  Please note that changes should be made as carefully as possible.  The reason is that there are no tests with the help of which you can make sure that these changes will not break the existing work logic.  In order for the changes we make to be the safest, you must try to preserve the signatures of functions as much as possible.  Thus, we will move the code containing external dependency into a separate method (see Fig. 11). <br><br><img src="https://habrastorage.org/webt/cl/9d/j_/cl9dj_r8-gfcxt4_trnmqxstc9u.png"><br>  <i>Fig.11.</i>  <i>Delivering code containing external dependency to a separate method</i> <br><br>  How can we test our class in this case?  Everything is simple - let's declare the selected function virtual, inherit from the original class a new class in which we will override the function of the base class containing the dependency.  So we got a class that is free from external dependencies - and now it can be safely entered into test tools to cover the tests.  In fig.  12 shows one of the ways to implement such a test class. <br><br><img src="https://habrastorage.org/webt/kl/xl/zk/klxlzkll_tqik6upfmydyrfkrpm.png"><br>  <i>Fig.12.</i>  <i>Implementing the Select and Override Method to Break the Dependency</i> <i><br></i> <br>  The test itself can now be written as follows: <br><br><pre> <code class="cpp hljs">TEST_F( EntryAnalyzerTest, Analyze_ValidEntryName_ReturnsTrue) { TestingEntryAnalyzer ea; ea.WillBeValid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ea.Analyze( <span class="hljs-string"><span class="hljs-string">"valid_entry_name"</span></span> ); ASSERT_EQ( result, <span class="hljs-literal"><span class="hljs-literal">true</span></span> ); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestingEntryAnalyzer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EntryAnalyzer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> WillBeValid; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ename )</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WillBeValid; } };</code> </pre> <br>  <i>Fig.13.</i>  <i>And another example of a test that does not interact with a real database.</i> <br><br>  The described approach is one of the easiest to implement, and it is useful to have it in the arsenal of your skills. <br><br><h2>  Break dependencies using mock objects </h2><br>  Now we can break database dependencies using stub objects.  But we still have an unprocessed dependence on a remote web server.  With the help of a mock object, we can break this dependency. <br><br>  What do you need to do for this?  Here we can use a combination of the already considered methods.  First, we localize our dependency in one of the functions, which we then declare virtual.  Do not forget while saving function signatures!  Now select the interface defining the contract of the <i>WebService</i> class and instead of using the class explicitly, we will use the pointer <i>unique_ptr of the</i> required type.  And we will create a class-successor in which this virtual function will be redefined.  The class obtained after refactoring is shown in fig.  14. <br><br><img src="https://habrastorage.org/webt/n8/uc/iu/n8uciuc7rxvb923dnwiclk0moja.png"><br>  <i>Fig.14.</i>  <i>Class after refactoring, prepared to break the dependence on network interaction</i> <br><br>  Let's enter into the heir class a pointer <i>shared_ptr</i> to the object that implements the selected interface.  All we have to do is use the constructor parameterization method to implement the dependency.  Now our class, which can now be tested, looks like this: <br><br><img src="https://habrastorage.org/webt/xq/pk/xs/xqpkxsjsyva22tjswynkq7_lmcs.png"><br>  <i>Fig.15.</i>  <i>Test class that allows for discontinuity depending on network interaction</i> <br><br>  And now we can write the following test: <br><br><pre> <code class="cpp hljs">TEST_F( EntryAnalyzerTest, Analyze_TooShortEntryName_LogsErrorToWebServer ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;FakeWebService&gt; p_web_service = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;FakeWebService&gt;(); <span class="hljs-function"><span class="hljs-function">TestingEntryAnalyzer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ea</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( p_web_service )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = ea.Analyze( <span class="hljs-string"><span class="hljs-string">"e"</span></span> ); ASSERT_EQ( p_web_service-&gt;lastError, <span class="hljs-string"><span class="hljs-string">"Error: e"</span></span> ); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestingEntryAnalyzer</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EntryAnalyzer { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TestingEntryAnalyzer( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IWebService&gt; p_service ) : pWebService( p_service ) { } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> err )</span></span></span><span class="hljs-function"> override </span></span>{ pWebService-&gt;LogError( err ); } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;IWebService&gt; pWebService; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FakeWebService</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IWebService { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> error )</span></span></span><span class="hljs-function"> override </span></span>{ lastError = error; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> lastError; };</code> </pre> <br>  <i>Fig.16.</i>  <i>An example of a test that does not interact with a network connection.</i> <br><br>  Thus, by introducing a dependency using the parameterization of the constructor, based on the analysis of the state of the mock object we can find out which messages the remote web service will receive. <br><br><h2>  Recommendations for creating tests that are easy to maintain and upgrade </h2><br>  Consider now the approaches to the construction of unit tests, which are easy to maintain and upgrade.  Perhaps, in many respects, this is again due to distrust of oneself. <br><br><img src="https://habrastorage.org/webt/7s/i3/6d/7si36d3bsm5pmfsbnxu_qznj9gu.jpeg"><br><br>  The first recommendation is that one test should test only one result of the work.  In this case, if the test fails, then you can immediately say unequivocally how much of the logic of the "combat" code did not pass the test.  If in one test there are several asserts, then without re-running the test and subsequent additional analysis it is hard to say exactly where the logic was broken. <br><br>  The second recommendation is that only public class methods should be tested.  This is due to the fact that public methods, in fact, define a class contract - that is, the functionality that it undertakes to perform.  However, the specific implementation of its implementation remains at its discretion.  Thus, in the course of the project development, the way of performing one or another action can be changed, which may require changing the logic of the work of the private class methods.  As a result, this may lead to the failure of a number of tests written for private methods, although the public contract of the class itself is not violated.  If testing of the private method is nevertheless required, it is recommended to find a public method for the class that uses it and write the test for it. <br><br>  However, sometimes the tests do not pass, and you have to figure out what went wrong.  In this case, a rather unpleasant situation may arise if an error is contained in the test itself.  As a rule, first of all, we begin to look for the causes of non-passage precisely in the logic of the tested "battle" code, and not the test itself.  In this case, a lot of time can be spent on finding the cause of non-passage.  In order to avoid this, we must strive to ensure that the test code itself is as simple as possible - avoid using any branching operators in the test ( <i>switch</i> , <i>if</i> , <i>for</i> , <i>while</i> , etc.).  If it is necessary to test branching in a ‚Äúcombat‚Äù code, then it is better to write two separate tests for each of the branches.  Thus, a typical unit test can be represented as a sequence of method calls with a further assert. <br><br>  Now consider the following situation: there is a class for which a large number of tests are written, for example, 100. Inside each of them, you need to create a test object, for which the designer needs one argument.  However, with the development of the project, the situation has changed - and now one argument is not enough, and two are needed.  Changing the number of constructor parameters will result in all 100 tests not being successfully compiled, and in order to put them in order, you will have to make changes to all 100 sites. <br><br>  To avoid this situation, let us follow the rule well known to all of us: ‚ÄúAvoid code duplication‚Äù.  This can be achieved by using factory methods in tests to create test objects.  In this case, if the signature of the constructor of the object under test is changed, it will be sufficient to make an appropriate edit only in one place of the test project. <br><br>  This can significantly reduce the time spent on maintaining existing tests in working condition.  And this may be especially important in a situation where once again we will have to tighten all deadlines from all sides. <br><br><img src="https://habrastorage.org/webt/qs/_v/mg/qs_vmgci7uo3rjgidxmrlukhv6g.jpeg"><br><br><h2>  Became interesting?  You can dive deeper. </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For further and more detailed immersion in the subject of unit testing, I advise </font></font><a href="http://artofunittesting.com/toc/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roy Osherove‚Äôs book The Art of Unit</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Testing </font><font style="vertical-align: inherit;">. In addition, quite often there is also a situation when you need to make changes to an existing code that is not covered by tests. One of the safest approaches is to first create a kind of ‚Äúsafety net‚Äù - cover it with tests, and then make the required changes. Such an approach is very well described in the book of </font></font><a href="https://www.r7krecon.com/legacy-code"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M. Fithers ‚ÄúEffective work with inherited code‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . So mastering the approaches described by the authors can bring us, as developers, into the arsenal very important and useful skills.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you for your time! </font><font style="vertical-align: inherit;">I am glad if any of the above will be useful and timely. </font><font style="vertical-align: inherit;">I am pleased to try to answer questions in the comments, if any. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Author: Victor Yastrebov </font></font><a href="https://habrahabr.ru/users/vyastrebov/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vyastrebov</font></font></a></b> </div><p>Source: <a href="https://habr.com/ru/post/347358/">https://habr.com/ru/post/347358/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347346/index.html">How to use all the features of mobile OS in React Native</a></li>
<li><a href="../347348/index.html">LittleFS is a compact and economical file system for ARM microcontrollers comprising mbed os. Fast start</a></li>
<li><a href="../347350/index.html">Style Tips. How to write a readable React code</a></li>
<li><a href="../347352/index.html">Interaction of C # and C ++ cross-platform</a></li>
<li><a href="../347354/index.html">Learn OpenGL. Lesson 4.5 - Framebuffer</a></li>
<li><a href="../347360/index.html">How we built the data infrastructure in Wish</a></li>
<li><a href="../347362/index.html">Avito in the Russian-speaking PostgreSQL community: open 2018, remember 2017</a></li>
<li><a href="../347364/index.html">The book "Angular and TypeScript. Website building for professionals ¬ª</a></li>
<li><a href="../347366/index.html">The third invasion of the Martians</a></li>
<li><a href="../347368/index.html">Call Tracing Anatomy: Setup Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>