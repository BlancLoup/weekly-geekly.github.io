<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Programming with PyUSB 1.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator : 
 This is a translation of the Programming with PyUSB 1.0 manual. 
 This tutorial was written by the PyUSB developers, but quick...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Programming with PyUSB 1.0</h1><div class="post__text post__text-html js-mediator-article">  <i><b>From the translator</b> :</i> <i><br></i>  <i>This is a translation of the <a href="">Programming with PyUSB 1.0 manual.</a></i> <i><br></i>  <i>This tutorial was written by the PyUSB developers, but quickly running through the commits, I believe that the main author of the tutorial is <a href="https://github.com/walac">walac</a> .</i> <br><br><h2>  let me introduce myself </h2><br>  <b>PyUSB 1.0</b> is a <a href="http://www.python.org/">Python</a> library that provides easy access to <a href="http://www.usb.org/">USB</a> .  PyUSB provides various functions: <br><br><ul><li>  <i><b>100% written in Python:</b></i> <br>  Unlike versions 0.x, which were written in C, version 1.0 is written in Python.  This allows Python programmers with no C experience to better understand how PyUSB works. </li><li>  <i><b>Platform Neutrality:</b></i> <br>  Version 1.0 includes a front-end backend scheme.  It isolates the API from system-specific implementation details.  The <u>IBackend</u> interface connects these two layers.  PyUSB comes with built-in backends for libusb 0.1, libusb 1.0, and OpenUSB.  You can write your own backend if you want. </li><li>  <i><b>Portability:</b></i> <br>  PyUSB should run on any platform with Python&gt; = 2.4, <a href="http://docs.python.org/library/ctypes.html">ctypes</a> and at least one of the supported built-in backends. </li><li>  <i><b>Simplicity:</b></i> <br>  Interacting with a <a href="http://www.usb.org/">USB</a> device has never been easier!  USB is a complex protocol, and PyUSB has good presets for the most common configurations. </li><li>  <i><b>Isochronous transfer support:</b></i> <br>  PyUSB supports isochronous transfers if the underlying backend supports them. </li></ul><br>  Although PyUSB makes USB programming less painful, this tutorial assumes that you have minimal knowledge of the USB protocol.  If you don‚Äôt know anything about USB, I recommend you Jan Axelson <b>‚Äôs excellent ‚ÄúPerfect USB‚Äù</b> book by Jan Axelson. <br><a name="habracut"></a><br><h2>  Enough talk, let's write code! </h2><br><h3>  Who is who </h3><br>  First, let's describe the PyUSB modules.  All PyUSB modules are under <u>usb</u> , with subsequent modules: <br><table><tbody><tr><th>  Module </th><th>  Description </th></tr><tr><td>  core </td><td>  The main USB module. </td></tr><tr><td>  util </td><td>  Secondary functions. </td></tr><tr><td>  control </td><td>  Standard management queries. </td></tr><tr><td>  legacy </td><td>  0.x. Compatibility Layer </td></tr><tr><td>  backend </td><td>  Subpackage containing embedded backends. </td></tr></tbody></table><br>  For example, to import a <u>core</u> module, enter the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core &gt;&gt;&gt; dev = usb.core.find()</code> </pre> <br><h3>  Well, let's start </h3><br>  The following is a simple program that sends the string 'test' to the first data source found (endpoint OUT): <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.util <span class="hljs-comment"><span class="hljs-comment">#    dev = usb.core.find(idVendor=0xfffe, idProduct=0x0001) #   ? if dev is None: raise ValueError('Device not found') #   .  ,   #    dev.set_configuration() #    cfg = dev.get_active_configuration() intf = cfg[(0,0)] ep = usb.util.find_descriptor( intf, #     custom_match = \ lambda e: \ usb.util.endpoint_direction(e.bEndpointAddress) == \ usb.util.ENDPOINT_OUT) assert ep is not None #   ep.write('test')</span></span></code> </pre><br>  The first two lines import PyUSB package modules.  <u>usb.core</u> is the main module, and <u>usb.util</u> contains auxiliary functions.  The following command searches our device and returns an instance of the object if it finds one.  If not, <u>None is</u> returned.  Next, we set the configuration we will use.  Note: the absence of arguments means that the desired configuration was set as default.  As you will see, many of the PyUSB functions have default settings for most common devices.  In this case, the first found configuration is put. <br><br>  Then, we look for the end point we‚Äôre interested in.  We are looking for it inside the first interface that we have.  After we found this point, we send data to it. <br><br>  If we know the address of the end point in advance, we can simply call the device object's <u>write</u> function: <br><br><pre> <code class="python hljs">dev.write(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'test'</span></span>)</code> </pre><br>  Here we write the string 'test' at the control point under address <i>1</i> .  All these functions will be disassembled better in the following sections. <br><br><h3>  What's wrong? </h3><br>  Each function in PyUSB raises an exception in case of an error.  In addition to <a href="http://docs.python.org/library/exceptions.html">standard Python exceptions</a> , PyUSB defines <u>usb.core.USBError</u> for USB-related errors. <br><br>  You can also use the PyUSB log functions.  It uses the <a href="http://docs.python.org/library/logging.html">logging</a> module.  To use it, define the <u>PYUSB_DEBUG</u> environment <u>variable</u> with one of the following logging levels: <u>critical</u> , <u>error</u> , <u>warning</u> , <u>info</u> or <u>debug</u> . <br><br>  By default, messages are sent to <a href="http://docs.python.org/library/sys.html">sys.stderr</a> .  If you want, you can redirect log messages to a file by defining the environment variable <u>PYUSB_LOG_FILENAME</u> .  If its value is the correct path to the file, messages will be written there, otherwise they will be sent to <u>sys.stderr</u> . <br><br><h3>  Where are you? </h3><br>  The <u>find ()</u> function in the <u>core</u> module is used to find and number the devices attached to the system.  For example, let's say that our device has a vendor ID with a value of 0xfffe and a product ID equal to 0x0001.  If we need to find this device we will do this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core dev = usb.core.find(idVendor=<span class="hljs-number"><span class="hljs-number">0xfffe</span></span>, idProduct=<span class="hljs-number"><span class="hljs-number">0x0001</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dev <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> ValueError(<span class="hljs-string"><span class="hljs-string">'Our device is not connected'</span></span>)</code> </pre><br>  That's it, the function will return the <u>usb.core.Device</u> object that represents our device.  If the device is not found, it will return <u>None</u> .  In fact, you can use any field of the Device <a href="http://www.beyondlogic.org/usbnutshell/usb5.htm">Descriptor</a> class you want.  For example, what if we want to know if there is a USB printer connected to the system?  It is very easy: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#      ,   if usb.core.find(bDeviceClass=7) is None: raise ValueError('No printer found')</span></span></code> </pre><br>  7 is the code for the printer class in accordance with the USB specification.  Oh, wait, what if I want to number all the available printers?  No problem: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#     ... printers = usb.core.find(find_all=True, bDeviceClass=7) # Python 2, Python 3,     import sys sys.stdout.write('There are ' + len(printers) + ' in the system\n.')</span></span></code> </pre><br>  What happened?  Well, time for a little explanation ... <u>find</u> has a parameter called <u>find_all</u> and by default is False.  When it is false <a name="orig1"></a>  <a href="https://habr.com/ru/post/430528/">[1]</a> , <u>find</u> will return the first device that fits the specified criteria (let's talk about this soon).  If you pass a <i>true</i> value to the parameter, <u>find</u> instead will return a list of all devices matching the criteria.  That's all!  Simple, isn't it? <br><br>  Are we done?  Not!  I haven't told everything yet: many devices actually put their class information in the Interface <a href="http://www.beyondlogic.org/usbnutshell/usb5.htm">Descriptor</a> instead of the Device <a href="http://www.beyondlogic.org/usbnutshell/usb5.htm">Descriptor</a> .  So, in order to truly find all printers connected to the system, we will need to iterate through all configurations, as well as all interfaces, and check whether one of the interfaces has a bInterfaceClass value of 7. If you are a <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B5%25D0%25BD%25D1%258C">programmer</a> like me, you may ask yourself: Is there any easier way to do this?  Answer: yes, he is.  First, let's look at the ready code for finding all connected printers: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.util <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">find_class</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, class_)</span></span></span><span class="hljs-function">:</span></span> self._class = class_ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__call__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, device)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#  ,   if device.bDeviceClass == self._class: return True # ,   ,   # ,     for cfg in device: # find_descriptor:  ? intf = usb.util.find_descriptor( cfg, bInterfaceClass=self._class ) if intf is not None: return True return False printers = usb.core.find(find_all=1, custom_match=find_class(7))</span></span></code> </pre><br>  The <u>custom_match</u> parameter accepts any callable object that receives a device object.  It must return a true value for a suitable device and a false value for an unsuitable one.  You can also combine <u>custom_match</u> with device fields if you want: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#   ,    : printers = usb.core.find(find_all=1, custom_match=find_class(7), idVendor=0xfffe)</span></span></code> </pre><br>  Here we are interested in 0xfffe supplier printers. <br><br><h3>  describe yourself </h3><br>  Ok, we found our device, but before interacting with it, we would like to know more about it.  Well, you know, configurations, interfaces, endpoints, types of data streams ... <br>  If you have a device, you can access any field in the device descriptor as object properties: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>dev.bLength &gt;&gt;&gt; dev.bNumConfigurations &gt;&gt;&gt; dev.bDeviceClass &gt;&gt;&gt; <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre><br>  To access the available configurations in the device, you can iterate the device: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cfg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dev: sys.stdout.write(str(cfg.bConfigurationValue) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br>  In the same way, you can iterate a configuration for accessing interfaces, and also iterate interfaces for accessing their control points.  Each object type has fields of the corresponding descriptor as attributes.  Take a look at an example: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> cfg <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> dev: sys.stdout.write(str(cfg.bConfigurationValue) + <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> intf <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> cfg: sys.stdout.write(<span class="hljs-string"><span class="hljs-string">'\t'</span></span> + \ str(intf.bInterfaceNumber) + \ <span class="hljs-string"><span class="hljs-string">','</span></span> + \ str(intf.bAlternateSetting) + \ <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ep <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> intf: sys.stdout.write(<span class="hljs-string"><span class="hljs-string">'\t\t'</span></span> + \ str(ep.bEndpointAddress) + \ <span class="hljs-string"><span class="hljs-string">'\n'</span></span>)</code> </pre><br>  You can also use indexes for random access to handles, like this: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-comment"><span class="hljs-comment">#      &gt;&gt;&gt; cfg = dev[1] &gt;&gt;&gt; #      &gt;&gt;&gt; intf = cfg[(0,0)] &gt;&gt;&gt; #    &gt;&gt;&gt; ep = intf[2]</span></span></code> </pre><br>  As you can see the indices are counted from 0. But wait!  There is something strange about how I access the interface ... Yes, you are right, the index for the Configuration takes a series of two values, of which the first is the Interface index and the second is the alternative setting.  In general, to get access to the first interface, but with the second setting, we write <u>cfg [(0,1)]</u> . <br><br>  Now is the time to learn a powerful way to search for handles - a useful <u>find_descriptor</u> function.  We have already seen it in the printer search example.  <u>find_descriptor</u> works almost as well as <u>find</u> , with two exceptions: <br><br><ul><li>  <u>find_descriptor</u> receives as its first parameter the initial form you will be looking for. </li><li>  It has no <u>backend</u> parameter. <a name="orig2"></a>  <a href="https://habr.com/ru/post/430528/">[2]</a> . </li></ul><br>  For example, if we have a <u>cfg</u> configuration descriptor, and we want to find all the alternative settings for interface 1, we will do this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.util alt = usb.util.find_descriptor(cfg, find_all=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>, bInterfaceNumber=<span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre><br>  Note that <u>find_descriptor</u> is in the <u>usb.util</u> module.  It also accepts the <u>custom_match</u> parameter described earlier. <br><br>  <b>We deal with multiple identical devices.</b> <br><br>  Sometimes you can have two identical devices connected to a computer.  How can you distinguish them?  <u>Device</u> objects come with two additional attributes that are not part of the USB specification, but are very useful: the <u>bus</u> and <u>address</u> attributes.  First of all, it should be said that these attributes come from the backend, and the backend may not support them - in this case they are set to <u>None</u> .  However, these attributes represent the device bus number and address and, as you might have guessed, can be used to distinguish between two devices with the same values ‚Äã‚Äãfor the <u>idVendor</u> and <u>idProduct attributes</u> . <br><br><h3>  How should i work? </h3><br>  Once connected, USB devices must be configured using several standard queries.  When I began to study the <a href="http://www.usb.org/">USB</a> specification, I was discouraged by dexryptors, configurations, interfaces, alternative settings, transfer types and all that ... And worst of all, you can‚Äôt just ignore them: the device doesn't work without configuration, even if it is one!  PyUSB is trying to make your life as simple as possible.  For example, after receiving your device object, first of all, before interacting with it, you need to send a <u>set_configuration</u> request.  The configuration parameter for this request that interests you is <u>bConfigurationValue</u> .  Most devices have no more than one configuration, and tracking configuration values ‚Äã‚Äãfor use is annoying (although most of the code I saw was simply hardcoded for this).  Therefore, in PyUSB, you can simply send a <u>set_configuration</u> request <u>with</u> no arguments.  In this case, it will install the first found configuration (if your device has only one, you don‚Äôt have to worry about the configuration value at all).  For example, imagine that you have a device with one configuration decryptor, and its bConfigurationValue field is 5 <a name="orig3"></a>  <a href="https://habr.com/ru/post/430528/">[3]</a> , subsequent requests will work the same way: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>dev.set_configuration(<span class="hljs-number"><span class="hljs-number">5</span></span>) <span class="hljs-comment"><span class="hljs-comment">#  &gt;&gt;&gt; dev.set_configuration() #  ,   5 -  #  &gt;&gt;&gt; cfg = util.find_descriptor(dev, bConfigurationValue=5) &gt;&gt;&gt; cfg.set() #  &gt;&gt;&gt; cfg = util.find_descriptor(dev, bConfigurationValue=5) &gt;&gt;&gt; dev.set_configuration(cfg)</span></span></code> </pre><br>  Wow  You can use the <u>Configuration</u> object as a parameter for <u>set_configuration</u> !  Yes, he also has a <u>set</u> method for configuring himself into the current configuration. <br><br>  Another option that you need or will not need to configure is the option to change interfaces.  Each device can have only one activated configuration at a time, and each configuration can have more than one interface, and you can use all interfaces at the same time.  You better understand this concept if you think of the interface as a logical device.  For example, let's imagine a multifunctional printer, which is both a printer and a scanner at the same time.  In order not to complicate (or at least make it as simple as possible), let's assume that it has only one configuration.  Since  we have a printer and a scanner; the configuration has 2 interfaces: one for the printer and one for the scanner.  A device with more than one interface is called a composite device.  When you connect your multifunction printer to your computer, the Operating System will load two different drivers: one for each ‚Äúlogical‚Äù peripheral device that you have <a name="orig4"></a>  <a href="https://habr.com/ru/post/430528/">[4]</a> . <br><br>  What about alternative interface settings?  Good thing you asked.  The interface has one or more alternative settings.  An interface with only one alternative setting is considered as having no alternative settings. <a name="orig5"></a>  <a href="https://habr.com/ru/post/430528/">[5]</a> .  Alternative settings for interfaces as a configuration for devices, that is, for each interface you can have only one active alternative setting.  For example, the USB specification says that a device cannot have an isochronous checkpoint in its main alternative setting. <a name="orig6"></a>  <a href="https://habr.com/ru/post/430528/">[6]</a> , so the streaming device should have at least two alternative settings, with the second setting having an isochronous checkpoint.  But, unlike configurations, interfaces with only one alternative setting do not need to be configured. <a name="orig7"></a>  <a href="https://habr.com/ru/post/430528/">[7]</a> .  You select an alternative interface setting using the <u>set_interface_altsetting</u> function: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>dev.set_interface_altsetting(interface = <span class="hljs-number"><span class="hljs-number">0</span></span>, alternate_setting = <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br>  <b>A warning</b> <br><br>  The USB specification says that the device is allowed to return an error in case it receives a SET_INTERFACE request to an interface that does not have additional alternative settings.  So, if you are not sure that the interface has more than one alternative setting or that it accepts a SET_INTERFACE request, the most secure method will be to call <u>set_interface_altsetting</u> inside a try-except block like this: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: dev.set_interface_altsetting(...) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> USBError: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  You can also use the <u>Interface</u> object as a function parameter; the <u>interface</u> and <u>alternate_setting</u> parameters are automatically inherited from the <u>bInterfaceNumber</u> and <u>bAlternateSetting fields</u> .  Example: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>intf = find_descriptor(...) &gt;&gt;&gt; dev.set_interface_altsetting(intf) &gt;&gt;&gt; intf.set_altsetting() <span class="hljs-comment"><span class="hljs-comment"># !       </span></span></code> </pre><br>  <b>A warning</b> <br><br>  The <u>Interface</u> object must belong to the active configuration descriptor. <br><br><h3>  Talk to me honey </h3><br>  And now it's time for us to understand how to interact with USB devices.  USB has four types of data streams: bulk transfer, interrupt transfer, isochronous transfer, and control transfer.  I do not plan to explain the purpose of each stream and the differences between them.  Therefore, I assume that you have at least basic knowledge of USB data streams. <br><br>  The control data stream is the only stream whose structure is described in the specification; the others simply send and receive raw data from a USB point of view.  Therefore, you have different functions for working with control flows, and the remaining flows are processed by the same functions. <br><br>  You can access the control data stream using the <u>ctrl_transfer</u> method.  It is used for both outgoing (OUT) and incoming (IN) streams.  The flow direction is determined by the <u>bmRequestType</u> parameter. <br><br>  The <u>ctrl_transfer</u> parameters almost coincide with the structure of the control request.  The following is an example of how to organize the control data flow. <a name="orig8"></a>  <a href="https://habr.com/ru/post/430528/">[8]</a> : <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>msg = <span class="hljs-string"><span class="hljs-string">'test'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> dev.ctrl_transfer(<span class="hljs-number"><span class="hljs-number">0x40</span></span>, CTRL_LOOPBACK_WRITE, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, msg) == len(msg) &gt;&gt;&gt; ret = dev.ctrl_transfer(<span class="hljs-number"><span class="hljs-number">0xC0</span></span>, CTRL_LOOPBACK_READ, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, len(msg)) &gt;&gt;&gt; sret = <span class="hljs-string"><span class="hljs-string">''</span></span>.join([chr(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ret]) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sret == msg</code> </pre><br>  In this example, it is assumed that our device includes two user control requests that act as a loopback pipe.  What you write with the message <u>CTRL_LOOPBACK_WRITE</u> , you can read with the message <u>CTRL_LOOPBACK_READ</u> . <br><br>  The first four parameters ‚Äî <u>bmRequestType</u> , <u>bmRequest</u> , <u>wValue,</u> and <u>wIndex</u> ‚Äî are the fields of the standard control flow structure.  The fifth parameter is either the data to be sent for the outgoing data stream or the number of read data in the incoming stream.  The transferred data can be any type of sequence that can be submitted as a parameter to the input of the <u>__init__</u> method for an <a href="http://docs.python.org/library/array.html">array</a> .  If there is no data to be sent, the parameter must be <u>None</u> (or 0 in the case of an incoming data stream).  There is one more optional parameter specifying the operation timeout.  If you do not pass it, the default timeout will be used (more on this later).  In an outgoing data stream, the return value is the number of bytes actually sent to the device.  In the incoming stream, the return value is an <a href="http://docs.python.org/library/array.html">array</a> with read data. <br><br>  For other threads, you can use the <u>write</u> and <u>read</u> methods, respectively, to write and read data.  You do not need to worry about the type of flow - it is automatically determined by the address of the control point.  Here is our loopback example, provided we have a loopback pipe at checkpoint 1: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>msg = <span class="hljs-string"><span class="hljs-string">'test'</span></span> &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> len(dev.write(<span class="hljs-number"><span class="hljs-number">1</span></span>, msg, <span class="hljs-number"><span class="hljs-number">100</span></span>)) == len(msg) &gt;&gt;&gt; ret = dev.read(<span class="hljs-number"><span class="hljs-number">0x81</span></span>, len(msg), <span class="hljs-number"><span class="hljs-number">100</span></span>) &gt;&gt;&gt; sret = <span class="hljs-string"><span class="hljs-string">''</span></span>.join([chr(x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ret]) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> sret == msg</code> </pre><br>  The first and third parameters are the same for both methods ‚Äî this is the control point address and timeout, respectively.  The second parameter is the data to be sent (write) or the number of bytes to read (read).  The returned data will be either an instance of an <a href="http://docs.python.org/library/array.html">array</a> object for the <u>read</u> method, or the number of bytes written for the <u>write</u> method. <br><br>  With beta 2 versions instead of the number of bytes, you can pass to <u>read</u> or <u>ctrl_transfer</u> an <a href="http://docs.python.org/library/array.html">array</a> object into which data will be read.  In this case, the number of bytes to read will be the length of the array multiplied by the value of <u>array.itemsize</u> . <br><br>  In <u>ctrl_transfer</u> , the <u>timeout</u> parameter is optional.  When <u>timeout is</u> omitted, the <u>Device.default_timeout</u> property is <u>used</u> as an operational timeout. <br><br><h3>  Control yourself </h3><br>  In addition to the data <u>stream</u> functions, the <u>usb.control</u> module provides functions that include standard USB control requests, and the <u>usb.util</u> module has a convenient <u>get_string</u> function that <u>delivers</u> string descriptors. <br><br><h2>  Additional topics </h2><br><h3>  Every great abstraction stands for a great realization. </h3><br>  There used to be only <a href="http://www.libusb.info/">libusb</a> .  Then libusb 1.0 came and we had libusb 0.1 and 1.0.  After that we created <a href="https://sourceforge.net/p/openusb/wiki/Home/">OpenUSB</a> and now we live in the <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B0%25D0%25B2%25D0%25B8%25D0%25BB%25D0%25BE%25D0%25BD%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25B0%25D1%2588%25D0%25BD%25D1%258F">Tower of Babel of</a> USB libraries <a name="orig9"></a>  <a href="https://habr.com/ru/post/430528/">[9]</a> .  How does PyUSB handle this?  Well, PyUSB is a democratic library, you can choose which library you want.  In fact, you can write your own USB library from scratch and tell PyUSB to use it. <br><br>  The <u>find</u> function has one more parameter which I did not tell you about.  This is the <u>backend</u> parameter.  If you do not pass it, one of the built-in backends will be used.  A backend is an object inherited from <u>usb.backend.IBackend</u> , responsible for introducing OS-specific USB junk.  As you might guess, the built-in libusb 0.1, libusb 1.0 and OpenUSB are backends. <br><br>  You can write your own backend and use it.  Just inherit from <u>iBackend</u> and enable the necessary methods.  You may need to look in the <u>usb.backend</u> documentation to see how this is done. <br><br><h3>  Do not be selfish </h3><br>  Python has what we call <i>automatic memory management</i> .  This means that the virtual machine will decide when to unload objects from memory.  Under the hood, PyUSB manages all the low-level resources you need to work with (interface approval, device adjustments, etc.) and most users don‚Äôt have to worry about it.  But, due to the uncertain nature of the automatic destruction of objects by Python, users cannot predict when resources will be released.  Some applications need to allocate and free resources deterministically.  For such applications, the <u>usb.util</u> module provides functions for interacting with resource management. <br><br>  If you want to request and release interfaces manually, you can use the functions <u>claim_interface</u> and <u>release_interface</u> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">claim_interface</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will request the specified interface if the device has not yet done so. If the device has already requested an interface, it does nothing. Also </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">release_interface</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will release the specified interface if requested. If the interface is not requested, it does nothing. You can use manual interface query to solve the </font><a href="http://libusb.sourceforge.net/api-1.0/caveats.html"><font style="vertical-align: inherit;">configuration problem</font></a><font style="vertical-align: inherit;"> described in the </font></font><a href="http://www.libusb.info/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libusb</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> documentation </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If you want to release all the resources allocated by the device object (including the requested interfaces), you can use the </font><u><font style="vertical-align: inherit;">dispose_resources</font></u><font style="vertical-align: inherit;"> function</font></font><a href="http://libusb.sourceforge.net/api-1.0/caveats.html"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><u><font style="vertical-align: inherit;"></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It frees all allocated resources and places the device object (but not the device hardware itself) into the state in which it was returned after using the </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Manual Definition of Libraries </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, the backend is a wrapper over a shared library that implements the USB access API. By default, the backend uses the </font></font><a href="http://docs.python.org/library/ctypes.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ctypes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font></font><a href="http://docs.python.org/3/library/ctypes.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">find_library ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . On Linux and other Unix-like operating </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">systems</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><u><font style="vertical-align: inherit;">find_library</font></u><font style="vertical-align: inherit;"> attempts to run external programs (such as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ sbin / ldconfig</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objdump</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in order to find the library file. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In systems where these programs are missing and / or the library cache is disabled, this feature cannot be used. To overcome the limitations, PyUSB allows you to submit the find_library () user-defined function to the backend. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of such a scenario would be:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.core &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> usb.backend.libusb1 &gt;&gt;&gt; &gt;&gt;&gt; backend = usb.backend.libusb1.get_backend(find_library=<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-string"><span class="hljs-string">"/usr/lib/libusb-1.0.so"</span></span>) &gt;&gt;&gt; dev = usb.core.find(..., backend=backend)</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Note that find_library is an argument to the get_backend () function, in which you supply the function that is responsible for finding the right backend library. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Old school rules </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you are writing an application using the old PyUSB APIs (0.this-there), you can ask yourself if you need to update your code to use the new API. </font><font style="vertical-align: inherit;">Well, you should do it, but it is not necessary. </font><font style="vertical-align: inherit;">PyUSB 1.0 comes with the </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usb.legacy</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compatibility </font><u><font style="vertical-align: inherit;">module</font></u><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It includes the old API based on the new API. </font><font style="vertical-align: inherit;">‚ÄúWell, should I just replace my </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">import usb</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> line </font><font style="vertical-align: inherit;">with </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">import usb.legacy as usb</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to make my application work?‚Äù, You ask. </font><font style="vertical-align: inherit;">The answer is yes, it will work, but it is not necessary. </font><font style="vertical-align: inherit;">If you start your application unchanged it will work, because the </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">import usb</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> line </font><font style="vertical-align: inherit;">imports all public symbols from </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usb.legacy</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If you encounter a problem - most likely you have found a bug.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Help me please </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need help, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not send me an e-mail</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , for this there is a mailing list. </font><font style="vertical-align: inherit;">Subscription instructions can be found on the </font></font><a href="http://pyusb.github.io/pyusb/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PyUSB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> website </font><font style="vertical-align: inherit;">.</font></font><br><br><a name="prim"></a> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When I write True or False (with a capital letter), I mean the corresponding meanings of the Python language. And when I say true (true) or false (false), I mean any Python expression that is regarded as true or false. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(This similarity occurred in the original and helps to understand the concepts of true and false in translation. - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Approx. Per.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> See specific backend documentation. </font></font><br><br> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The USB specification does not impose any particular value on the configuration value. The same is true for interface numbers and alternative settings. </font></font><br><br> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[4]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In fact, everything is a little more complicated, but this is just an explanation for us enough. </font></font><br><br> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[5]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I know it sounds weird.</font></font><br><br> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[6]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is because if there is no bandwidth for isochronous data streams during device configuration, it can be successfully numbered. </font></font><br><br> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[7]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This does not happen for configuration, because the device is allowed to be in an unconfigured state. </font></font><br><br> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[8]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In PyUSB, the control data flows refer to checkpoint 0. Very, very rarely, a device has an alternative control checkpoint (I have never met such a device). </font></font><br><br> <a href="https://habr.com/ru/post/430528/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[9]</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is just a joke, do not take it seriously. </font><font style="vertical-align: inherit;">Great choice is better than no choice.</font></font></div><p>Source: <a href="https://habr.com/ru/post/430528/">https://habr.com/ru/post/430528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430518/index.html">How to render a frame Middle Earth: Shadow of Mordor</a></li>
<li><a href="../430520/index.html">Meet Spring Data MongoDB</a></li>
<li><a href="../430522/index.html">Do you need a corporate culture in IT? Confession brand manager of the Krasnodar studio Plarium</a></li>
<li><a href="../430524/index.html">Neural Network Architecture</a></li>
<li><a href="../430526/index.html">Slot machines: where did they come from in the USSR and how are they arranged</a></li>
<li><a href="../430530/index.html">Mock server to automate mobile testing</a></li>
<li><a href="../430532/index.html">Security in iOS applications</a></li>
<li><a href="../430534/index.html">Creating a template for Zabbix using DVR Trassir SDK as an example</a></li>
<li><a href="../430536/index.html">Designing window functions that sum up to a unit with a given level of overlap</a></li>
<li><a href="../430538/index.html">Do you read Scaladoc for ‚Äúobvious‚Äù collection methods? Or why laziness is not always good.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>