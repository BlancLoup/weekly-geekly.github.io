<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Once again about Oracle standby</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagine a situation where our project, using Oracle as a DBMS, suddenly (or hopefully expected) became critical for a business (respectively, there wa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Once again about Oracle standby</h1><div class="post__text post__text-html js-mediator-article"> Imagine a situation where our project, using Oracle as a DBMS, suddenly (or hopefully expected) became critical for a business (respectively, there was a willingness to allocate funds to ensure the reliability of the system). <br>  Up to this point, we completely managed with daily or even weekly backup (‚Äúhot‚Äù or ‚Äúcold‚Äù copying, or maybe just exporting data) and we were satisfied with the system recovery time of about a day (we assume that we have a couple of terabytes of data). <br>  And it turned out that we are given no more than an hour to restore the system, and we cannot lose any data. <br>  So, everything indicates that we will have to raise a standby server. <br>  In principle, most of what is said in this article is described in <b>"Oracle Data Guard Concepts and Administartion"</b> , as well as in a heap of places on the web, but for the most part these are instructions containing a sequence of commands, without much descriptions of their meaning and, most importantly, without recommendations on what to do if something goes wrong. <br>  I will try to describe the process of deploying a physical standby base in as much detail as possible indicating those rakes that I have ever come across. <br>  An indication of problems that I have not accidentally discovered, as well as any clarifications and additions are greatly appreciated. <br><a name="habracut"></a><br>  In the following, when examples of commands and queries will be given in the text, I will use the following notation: <br>  <b>$</b> - the command is entered in the command line of the operating system under the user oracle. <br>  <b>SQL&gt;</b> - the command is entered in sqlplus.  In this article, wherever it is not defined explicitly, it is implied that sqlplus is running in administrative mode ( <b>sqlplus / as sysdba</b> ), and the base instance is set via the $ ORACLE_SID variable. <br>  <b>RMAN&gt;</b> - the command is entered into rman.  Here also, unless something else is explicitly defined, it is assumed that rman is started with the <b>rman target /</b> command, and the base instance is set via the $ ORACLE_SID variable. <br><br>  Before we begin, it is worthwhile to say a little about those Oracle database organization principles that we will need to understand the mechanism of backup and recovery of data in Oracle DBMS. <br><br>  An Oracle DB instance contains the following file types: <br>  Control files - contain service information about the database itself.  Without them, data files cannot be opened and therefore access to database information cannot be opened. <br>  Data files (Data files) - contain database information. <br>  Operational logs (Redo logs) - contain information about all changes that have occurred in the database.  This information can be used to restore the state of the base in case of failures. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are other files that are not formally included in the database, but are important for the success of the database. <br>  Parameters file - used to describe the starting configuration of an instance. <br>  Password file - allows users to remotely connect to the database to perform administrative tasks. <br>  Archive journals - contain the history of the operational log files created by the instance (their offline copies).  These files allow you to restore the database.  Using them and database reserves, you can recover a lost data file. <br><br>  The main idea when creating a standby instance is to keep the backup database up to date by performing transactions stored in operational or archive logs of the main database (such a mechanism for Oracle is called Data Guard). <br>  Hence the first requirement for our main database - it must be run in <b>archivelog mode</b> . <br>  The second requirement is the presence of a password file.  This will allow you to remotely connect to our database in administrative mode. <br>  The third requirement is the <b>force logging</b> mode.  This mode is needed to force transactions to be recorded in redo logs even for operations performed with the NOLOGGING option.  The absence of this mode can lead to the fact that on a standby base, some data files will be damaged, because  during the "knurling" of archived logs, it will not be possible to get data from them about the transactions performed with the NOLOGGING option. <br>  It should also be noted that if you use Oracle below 11g, then it is necessary that the servers for the main base and for standby have the same platform.  That is, if your main database runs on a Linux server, then the standby server cannot be running Windows. <br><br>  All the examples in this article will be focused on unix-systems, however, their difference from the case of Windows-based systems, basically, consists only in the way of writing paths to files. <br>  We also do not forget that the data exchange between the main and standby servers will take place via SQL-Net, therefore it is necessary that connections to the corresponding port (as a rule, 1521 tcp) be opened in both directions. <br><br>  We assume that our database is called <b>test</b> .  We will adjust the configuration of the main and standby base in such a way that at any moment we can switch their roles to places (switchover).  We plan that our system will use Data Guard protection mode, which is called MAXIMUM PERFORMANCE. <br><br>  So let's go. <br>  To begin with, we check the compliance of our database with the necessary requirements. <br><br>  1. We look, in what mode our main database works: <br><br> <code>SQL&gt; select name, open_mode, log_mode from v$database; <br> <br> NAME OPEN_MODE LOG_MODE <br> --------- ---------- ------------ <br> TEST READ WRITE ARCHIVELOG</code> <br> <br>  If you do not see the ARCHIVELOG value in the LOG_MODE field, execute the following commands: <br><br> <code>SQL&gt; shutdown immediate; <br> SQL&gt; startup mount; <br> SQL&gt; alter database archivelog; <br> SQL&gt; alter database open;</code> <br> <br>  2. Check the presence of the password file: <br><br>  SQL&gt; select * from v $ pwfile_users; <br><br> <code>USERNAME SYSDB SYSOP <br> ------------------------------ ----- ----- <br> SYS TRUE TRUE</code> <br> <br>  If you do not see this result, create the necessary file: <br><br> <code>$ orapwd file=$ORACLE_HOME/dbs/orapw$ORACLE_SID password=xxxxxxxx force=y</code> <br> <br>  Instead of 'xxxxxxxx', you must insert the current SYS user password. <br><br>  3. Enable the <b>force logging</b> mode: <br><br> <code>SQL&gt; alter database force logging;</code> <br> <br>  Moving on to configuring our system.  To begin, we will perform the necessary settings on the main base.  We will save all the data in the <b>/ data / backup</b> directory. <br><br>  Create <b>standby redo logs</b> .  They are only needed on a standby base for recording data stored in redo logs on the main base.  We will need them on the main base when we switch it to standby mode and at the same time use real-time apply redo.  The standby redo logs files should be the same size as the online redo logs.  You can see the size of online redo logs with the command: <br><br> <code>SQL&gt; select bytes from v$log; <br> <br> BYTES <br> ---------- <br> 52428800 <br> 52428800 <br> 52428800</code> <br> <br>  We look, what groups for redo logs are in our database: <br><br> <code>SQL&gt; select group# from v$logfile; <br> <br> GROUP# <br> ---------- <br> 1 <br> 2 <br> 3</code> <br> <br>  Create standby redo logs: <br><br> <code>SQL&gt; alter database add standby logfile group 4 '/oradata/test/stnbylog01.log' size 50m; <br> Database altered. <br> <br> SQL&gt; alter database add standby logfile group 5 '/oradata/test/stnbylog02.log' size 50m; <br> Database altered. <br> <br> SQL&gt; alter database add standby logfile group 6 '/oradata/test/stnbylog03.log' size 50m; <br> Database altered.</code> <br> <br>  Create a file with the parameters of our instance (pfile).  We will take into account that our main base can be switched to standby mode, and this requires setting parameters that will be used only in standby mode. <br><br> <code>SQL&gt; create pfile='/data/backup/pfilePROD.ora' from spfile;</code> <br> <br>  We need to add some parameters to the resulting file if they are not there: <br><br>  <b>db_name = 'test'</b> is the name of our database (the same for the main and standby instance). <br>  <b>db_unique_name = 'testprod'</b> - and this is a unique name for each instance, it will not change when changing roles from standby to production. <br>  l <b>og_archive_config = 'dg_config = (testprod, teststan)'</b> - we define the names of the instances between which the exchange of logs will take place. <br>  <b>log_archive_dest_1 = 'SERVICE = teststan LGWR ASYNC VALID_FOR = (ONLINE_LOGFILES, PRIMARY_ROLE) db_unique_name =' teststan '</b> - when the instance is the main base (PRIMARY_ROLE), we will transfer archive logs to a standby server using the LGWR process.  The ASYNC parameter indicates that the data generated by the transaction need not be received on standby before the completion of the transaction ‚Äî this will not cause the main database to stop if there is no connection to standby. <br>  <b>log_archive_dest_2 = 'LOCATION = / oradata / test / archive VALID_FOR = (ALL_LOGFILES, ALL_ROLES) db_unique_name = testprod'</b> - here we specify the directory where the archive logs will be saved locally (for the main database) or where the logs coming from the main database will be saved (for standby base). <br>  l <b>og_archive_dest_state_1 = ENABLE</b> - <b>enable the</b> recording of archive logs in log_archive_dest_1.  Until we have created a standby database, this parameter can be set to the DEFER value, if we do not want to see unnecessary messages about the inaccessibility of the standby database in the alert_log. <br>  <b>log_archive_dest_state_2 = ENABLE</b> - <b>enable the</b> recording of archive logs in log_archive_dest_2. <br>  <b>fal_client = 'testprod'</b> - this parameter specifies that when the instance goes into standby mode, it will be the client for receiving the archive logs (fetch archive log). <br>  <b>fal_server = 'teststan'</b> - determines the FAL (fetch archive log) server from which the archive logs will be transferred.  The <b>fal_client</b> and <b>fal_server parameters</b> work only when the database is running in standby mode. <br>  <b>standby_file_management = 'AUTO'</b> - we set the automatic file management mode in standby mode.  With this parameter value, all the created or deleted files of the main database will be automatically created or deleted on the standby base. <br><br>  If we still want to place our standby database in directories other than those in which the main database is located, we will need additional parameters: <br><br>  <b>db_file_name_convert = '/ oradata_new / test', '/ oradata / test'</b> - this parameter indicates that in the names of the data files that will be created in the standby database (i.e. when our main instance starts operating in standby mode), you need to change paths with '/ oradata_new / test' to '/ oradata / test'. <br>  <b>log_file_name_convert = '/ oradata_new / test / archive', '/ oradata / test / archive'</b> - this parameter indicates that in the names of the log files that will be created in the standby database, you need to change the paths from '/ oradata_new / test / archive' to '/ oradata / test / archive'. <br><br>  As a result, the parameter file for the main database, among other things, should have the following entries: <br><br> <code>#         PRIMARY  STANDBY <br> db_name='test' <br> db_unique_name='testprod' <br> log_archive_config='dg_config=(testprod,teststan)' <br> log_archive_dest_1='SERVICE=teststan LGWR ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) db_unique_name='teststan' log_archive_dest_2='LOCATION=/oradata/test/archive VALID_FOR=(ALL_LOGFILES,ALL_ROLES) db_unique_name=testprod' <br> log_archive_dest_state_1=ENABLE <br> log_archive_dest_state_2=ENABLE <br> #          STANDBY <br> fal_client='testprod' <br> fal_server='teststan' <br> standby_file_management='AUTO'</code> <br> <br>  If there is such an opportunity, we restart the main database with new parameters and create a new <b>spfile</b> based on the <b>pfile</b> we have <b>revised</b> : <br><br> <code>SQL&gt; shutdown immediate; <br> SQL&gt; startup nomount pfile='/data/backup/pfilePROD.ora'; <br> SQL&gt; create spfile from pfile='/data/backup/pfilePROD.ora'; <br> SQL&gt; shutdown immediate; <br> SQL&gt; startup;</code> <br> <br>  If we are unable to stop the main database during our manipulations, we will have to make changes to the current configuration using ALTER SYSTEM. <br>  Here we must <b>bear</b> in mind that we will not be able to change <b>db_unique_name</b> on a working base.  Therefore, we will have to use the current name in the configuration.  You can view it using the command: <br><br> <code>SQL&gt; show parameter db_unique_name <br> NAME TYPE VALUE <br> ------------------------------------ ----------- -------------------------- <br> db_unique_name string test</code> <br> <br>  Set the necessary parameters: <br><br> <code>SQL&gt; alter system set log_archive_config='dg_config=(test,teststan)'; <br> System altered.</code> <br> <br>  We set the places for recording archive logs.  On a working base, we will not be able to correct the parameter <b>log_archive_dest_1</b> , if it is set.  Therefore, we only add the direction of copying to the standby base: <br><br> <code>SQL&gt; alter system set log_archive_dest_2='SERVICE=teststan LGWR ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) db_unique_name=teststan'; <br> System altered. <br> <br> SQL&gt; alter system set log_archive_dest_state_2=ENABLE; <br> System altered. <br> <br> SQL&gt; alter system set FAL_SERVER=teststan; <br> System altered. <br> <br> SQL&gt; alter system set FAL_CLIENT=test; <br> System altered. <br> <br> SQL&gt; alter system set standby_file_management='AUTO'; <br> System altered.</code> <br> <br>  Add to tnsnames.ora a record about the standby database: <br><br> <code>TESTSTAN = <br> (DESCRIPTION = <br> (ADDRESS_LIST = <br> (ADDRESS = (PROTOCOL = TCP)(HOST = standbysrv)(PORT = 1521)) <br> ) <br> (CONNECT_DATA = <br> (SERVICE_NAME = teststan) <br> ) <br> )</code> <br> <br>  It's time to create backups (if there are none).  For this we will use the rman utility. <br>  It is necessary that the place where the backup is located, from which we will deploy the standby base, was exactly the same as the place where we saved this backup.  Those.  if we add the backup to the '/ data / backup' directory, then when restoring the database on the standby-server, rman will search for the backup data in the same directory.  To solve this problem, there are two obvious ways: copy the backup data from the main server to standby in the exact same directory created there, or use a network resource for backup, which is equally mounted on both servers. <br><br>  Run rman on the main server: <br> <code>$ rman target /</code> <br> <br>  An interesting point for the case when Oracle is installed on Linux.  If you have the PolyglotMan (RosettaMan) package installed, then when you try to <br> <code>$ rman target /</code> <br>  an error may occur: <br> <code>rman: can't open target</code> <br>  This situation occurs if the path to the <b>rman</b> executable file of this package - (for example, / usr / X11R6 / bin / rman) in the $ PATH environment variable is located earlier than the path to the Oracle <b>rman</b> .  Those.  we are trying to run rman from the PolyglotMan package and pass as a parameter the target file, which, naturally, it cannot open. <br><br>  Create a control file for standby database: <br><br> <code>RMAN&gt; backup current controlfile for standby format '/data/backup/standbycontrol.ctl';</code> <br> <br>  We create a backup of our main database and archives: <br><br> <code>RMAN&gt; run <br> 2&gt; { <br> 3&gt; allocate channel c1 device type disk format '/data/backup/%u'; <br> 4&gt; backup database plus archivelog; <br> 5&gt; }</code> <br> <br>  Here we may face trouble if, for some reason, we do not have a complete set of archival journals (for example, they have been deleted).  Then rman will give the error: <br><br> <code>RMAN-20242: Specification does not match any archivelog in the recovery catalog</code> <br> <br>  To remedy the situation, it is necessary to check and change the statuses of the archive logs in the rman repository.  To do this, run the following command: <br><br> <code>RMAN&gt; change archivelog all crosscheck;</code> <br> <br>  If the backup was successful, copy the contents of the <b>/ data / backup /</b> directory to the standby server (if we did not use the network share for the backup) and proceed to creating an instance on the standby server. <br><br>  First we need to install Oracle on a standby server without creating an instance of the database.  To facilitate the future life, the path to $ ORACLE_HOME on a standby server should be the same as on the main one.  We also install all the patches that were installed on the main server to fully match the versions of Oracle. <br>  We create a configuration of listener-and net service names. <br>  Since we will use rman running on the combat server to deploy a copy of the main database on the standby server, and we will have the nomby base instance in standby mode, we need to explicitly set the service in listener.ora, otherwise all attempts to connect from rman to future standby how to auxiliary will be blocked. <br>  As a result, <b>listener.ora</b> should look something like this: <br><br> <code>SID_LIST_LISTENER = <br> (SID_LIST = <br> (SID_DESC = <br> (SID_NAME = PLSExtProc) <br> (ORACLE_HOME = /oracle) <br> (PROGRAM = extproc) <br> ) <br> (SID_DESC = <br> (GLOBAL_DBNAME = teststan) <br> (ORACLE_HOME = /oracle) <br> (SID_NAME = test) <br> ) <br> ) <br> <br> LISTENER = <br> (DESCRIPTION_LIST = <br> (DESCRIPTION = <br> (ADDRESS = (PROTOCOL = TCP)(HOST = standbysrv)(PORT = 1521)) <br> (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC0)) <br> ) <br> )</code> <br> <br>  It should be noted that the SID_NAME parameter in this case is case sensitive, since  listener will look for a password file named orapw $ SID_NAME. <br><br>  By the way, now is the time to copy the password file ($ ORACLE_HOME / dbs / orapw $ ORACLE_SID) from the main server to standby. <br><br>  We should also register our main and standby database in <b>tnsnames.ora</b> : <br><br> <code>TEST = <br> (DESCRIPTION = <br> (ADDRESS_LIST = <br> (ADDRESS = (PROTOCOL = TCP)(HOST = standbysrv)(PORT = 1521)) <br> ) <br> (CONNECT_DATA = <br> (SERVICE_NAME = teststan) <br> ) <br> ) <br> <br> TESTPROD = <br> (DESCRIPTION = <br> (ADDRESS_LIST = <br> (ADDRESS = (PROTOCOL = TCP)(HOST = productionsrv)(PORT = 1521)) <br> ) <br> (CONNECT_DATA = <br> (SID = test) <br> ) <br> )</code> <br> <br>  Because  it is understood that the applications ‚Äúknow‚Äù our base under the name <b>test</b> , then for the standby base we set the SID test. <br><br>  Do not forget to restart the <b>listener</b> : <br><br> <code>$ORACLE_HOME/bin/lsnrctl stop <br> $ORACLE_HOME/bin/lsnrctl start</code> <br> <br>  Now we create a directory structure for our database.  Here it is important not to forget that you need to create all the directories for storing data files and logs, as well as the directories <b>adump</b> , <b>bdump</b> , <b>cdump</b> , <b>dpdump</b> , <b>udump</b> , usually located in $ ORACLE_HOME / admin / $ ORACLE_SID. <br>  If you do not want to save the base database directory structure on standby, you need to create directories according to the values ‚Äã‚Äãof the <b>db_file_name_convert</b> and <b>log_file_name_convert</b> parameters. <br><br>  We also need to create a file of parameters for standby based on the parameters files of the main base.  To do this, we will overwrite the <b>pfilePROD.ora</b> file on the standby server, renaming it to <b>pfileSTAN.ora</b> , and make the necessary corrections to the part we edited earlier: <br><br> <code>#         PRIMARY  STANDBY <br> db_name='test' <br> db_unique_name='teststan' <br> log_archive_config='dg_config=(testprod,teststan)' <br> log_archive_dest_1='SERVICE=testprod LGWR ASYNC VALID_FOR=(ONLINE_LOGFILES,PRIMARY_ROLE) db_unique_name='testprod' log_archive_dest_2='LOCATION=/oradata/test/archive VALID_FOR=(ALL_LOGFILES,ALL_ROLES) db_unique_name=teststan' <br> log_archive_dest_state_1=ENABLE <br> log_archive_dest_state_2=ENABLE <br> #          STANDBY <br> fal_client='teststan' <br> fal_server='testprod' <br> standby_file_management='AUTO'</code> <br> <br>  When placing the standby base in other directories, we also add the necessary parameters: <br><br> <code>db_file_name_convert='/oradata/test','/oradata_new/test' <br> log_file_name_convert='/oradata/test/archive','/oradata_new/test/archive'</code> <br> <br>  It's time to start a standby copy of the database: <br><br> <code>SQL&gt; startup nomount pfile='/data/backup/pfileSTAN.ora'; <br> SQL&gt; create spfile from pfile='/data/backup/pfileSTAN.ora'; <br> SQL&gt; shutdown immediate; <br> SQL&gt; startup nomount;</code> <br> <br>  We expand standby base from backup.  To do this, go to the main server and run <b>rman</b> . <br><br>  Connect to the future standby database and perform duplication (we remember that the data backup and control file are in the directory that is visible from the main server and standby as <b>/ data / backup</b> ): <br><br> <code>RMAN&gt; connect auxiliary sys@teststan <br> RMAN&gt; duplicate target database for standby nofilenamecheck dorecover;</code> <br> <br>  We need the <b>nofilenamecheck</b> parameter so that <b>rman</b> does not <b>swear</b> at duplicate file names (if we use the same directory structure on the main and standby servers). <br><br>  If everything went well, then we put the system into automatic mode of applying transactions on a standby base. <br><br>  Switch the log file and look at the last number of the archive log on the main database: <br><br> <code>SQL&gt; alter system switch logfile; <br> System altered. <br> <br> SQL&gt; select max(sequence#) from v$archived_log; <br> <br> MAX(SEQUENCE#) <br> -------------- <br> 205</code> <br> <br>  Now go to the standby server. <br><br>  Check the status of the database: <br><br> <code>SQL&gt; select name,open_mode,log_mode from v$database; <br> <br> NAME OPEN_MODE LOG_MODE <br> --------- ---------- ------------ <br> TEST MOUNTED ARCHIVELOG <br> SQL&gt; select recovery_mode from v$archive_dest_status; <br> <br> RECOVERY_MODE <br> ----------------------- <br> IDLE <br> IDLE <br> IDLE <br> IDLE <br> IDLE <br> IDLE <br> IDLE <br> IDLE <br> IDLE <br> IDLE <br> IDLE <br> <br> 11 rows selected. <br> <br> SQL&gt; select max(sequence#) from v$log_history; <br> <br> MAX(SEQUENCE#) <br> -------------- <br> 202</code> <br> <br>  We see that the last applied log on standby is lagging behind the main base, and also that ARCH processes do not work. <br><br>  Check for standby redo logs: <br><br> <code>SQL&gt; select * from v$standby_log;</code> <br> <br>  If not, create: <br><br> <code>SQL&gt; alter database add standby logfile group 4 '/oradata/test/stnbylog01.log' size 50m; <br> Database altered. <br> <br> SQL&gt; alter database add standby logfile group 5 '/oradata/test/stnbylog02.log' size 50m; <br> Database altered. <br> <br> SQL&gt; alter database add standby logfile group 6 '/oradata/test/stnbylog03.log' size 50m; <br> Database altered. <br></code> <br><br>  We transfer our standby base to the Real-time apply redo mode: <br><br> <code>SQL&gt; alter database recover managed standby database using current logfile disconnect;</code> <br> <br>  Look what happened: <br><br> <code>SQL&gt; select recovery_mode from v$archive_dest_status; <br> <br> RECOVERY_MODE <br> ----------------------- <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> MANAGED REAL TIME APPLY <br> <br> 11 rows selected. <br> <br> SQL&gt; select max(sequence#) from v$log_history; <br> <br> MAX(SEQUENCE#) <br> -------------- <br> 205</code> <br> <br>  As you can see, everything works. <br><br>  If we do not want to use Real-time apply redo mode, but want to wait until the formation of the next archive log on the main server is completed and it will be transferred to standby for applying the transactions stored in it, then we need to transfer our standby base to redo apply mode by command : <br><br> <code>SQL&gt; alter database recover managed standby database disconnect;</code> <br> <br>  If something went wrong, then to solve the problem, first of all you need to stop the "rolling" of the logs: <br><br> <code>SQL&gt; alter database recover managed standby database cancel;</code> <br> <br>  It is possible that during the duplication process not all archive logs were transferred to the standby server.  Then they must be manually copied to the standby server (in our case to the / oradata / test / archive directory), and manually rolled: <br><br> <code>SQL&gt; recover standby database;</code> <br> <br>  and then again start the Real-time mode, apply redo: <br><br> <code>SQL&gt; alter database recover managed standby database using current logfile disconnect;</code> <br> <br>  The processes of switching roles between instances (switchover) and transferring a standby base to primary mode in the event of a failure of the main base (failover) have many of their pitfalls, so this is a topic for a separate article. </div><p>Source: <a href="https://habr.com/ru/post/120495/">https://habr.com/ru/post/120495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120483/index.html">Optimize with Optimus</a></li>
<li><a href="../120484/index.html">International Summer School of Programming Sevastopol</a></li>
<li><a href="../120488/index.html">Samsung speeds up memory</a></li>
<li><a href="../120489/index.html">Inside Paymentwall</a></li>
<li><a href="../120490/index.html">From rags to princes or the experience of painting a laptop</a></li>
<li><a href="../120496/index.html">Review of the laptop ThinkPad X220 with IPS matrix</a></li>
<li><a href="../120497/index.html">schema.org is a collection of HTML markup recipes for efficiently indexing a site from Google, Yahoo! and Microsoft</a></li>
<li><a href="../120498/index.html">AeroFS alpha testing</a></li>
<li><a href="../120503/index.html">Hairdresser, licensed Creative Commons - a cure for RW</a></li>
<li><a href="../120504/index.html">RVM - detail</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>