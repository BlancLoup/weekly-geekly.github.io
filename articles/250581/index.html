<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RefluxJS - an alternative look at Flux architecture from Facebook</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: looking at ReactJS and inspired by its simplicity, I began to look for a library that would provide the same simple data exchange...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RefluxJS - an alternative look at Flux architecture from Facebook</h1><div class="post__text post__text-html js-mediator-article">  From the translator: looking at <a href="http://facebook.github.io/react/">ReactJS</a> and inspired by its simplicity, I began to look for a library that would provide the same simple data exchange within my application.  Stumbled upon <a href="https://facebook.github.io/flux/">Flux</a> , saw <a href="https://facebook.github.io/flux/docs/todo-list.html">code samples</a> and went to look for an alternative.  I came across RefluxJS, immediately fell in love and went to translate the official dock.  It was written just in the style of the article, so first of all I decided to share it with the Chabrasoobschestvom.  The translation is somewhat free.  In some places, if it seemed to me that something needs additional clarification or an example, I was not shy. <br><br>  In the translation below, the term “event” is sometimes used as a translation for the term Action from Reflux, and sometimes the term “action” is used, depending on the context.  I could not find a better translation.  If you have options, look forward to suggestions in the comments. <br><br><h4>  Overview </h4><br> <a href="https://www.npmjs.org/package/reflux"><img src="http://img.shields.io/npm/v/reflux.svg" alt="image"></a> <a href="https://www.npmjs.org/package/reflux"><img src="http://img.shields.io/npm/dm/reflux.svg" alt="image"></a> <a href="http://bower.io/search/%3Fq%3Dreflux"><img src="http://img.shields.io/bower/v/reflux.svg" alt="image"></a> <a href="http://bower.io/search/%3Fq%3Dreflux"><img src="http://img.shields.io/bower/v/reflux.svg" alt="image"></a> <a href="https://travis-ci.org/spoike/refluxjs"><img src="http://img.shields.io/travis/spoike/refluxjs/master.svg" alt="image"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      RefluxJS is a simple library that provides a unidirectional data stream in your application that uses the <a href="http://facebook.github.io/react/blog/2014/05/06/flux.html">Flux</a> concept from Facebook. <br><a name="habracut"></a><br>  You can read a review of the Flux architecture <a href="http://facebook.github.io/react/docs/flux-overview.html">here</a> , and in this article an alternative option will be described, to a greater extent using the functional programming capabilities, with a departure from the MVC architecture towards a unidirectional data flow. <br><br><pre><code class="dos hljs">╔═════════╗ ╔════════╗ ╔═════════════════╗ ║ Actions ║──────&gt;║ Stores ║──────&gt;║ View Components ║ ╚═════════╝ ╚════════╝ ╚═════════════════╝ ^ │ └──────────────────────────────────────┘</code> </pre> <br>  The pattern consists of actions (actions) and data warehouses (stores).  The actions initiate the movement of data through events through the repositories to the visual components.  If the user has done something, an appropriate event is generated using the action.  A data warehouse has been signed for this event.  It handles the event and, possibly, in turn generates some of its own. <br><br>  For example, the user has changed the list filtering in the application.  The filter component generates the "filter changed" event.  The repository responds to this by executing an ajax request with an updated filter and, in turn, informs everyone subscribing to it that the data set supplied by it has changed. <br><br><h4>  Content </h4><br><ul><li>  Comparing Reflux and Facebook Flux </li><li>  Examples </li><li>  Installation </li><li>  Using <br><ul><li>  Developments </li><li>  Storage </li><li>  Use with ReactJS components </li></ul></li><li>  Details </li><li>  Epilogue </li></ul><br><h4>  Comparing Reflux and Facebook Flux </h4><br>  The goal of the RefluxJS project is to more easily and quickly integrate the Flux architecture into your project both on the client side and on the server side.  However, there are some differences between how RefluxJS works and what the classic Flux architecture offers.  More information is in <a href="http://spoike.ghost.io/deconstructing-reactjss-flux/">this blog post</a> . <br><br><h5>  Similarities with Flux </h5><br>  Some RefluxJS concepts are similar to Flux: <br><ul><li>  There are action games </li><li>  There are data warehouses </li><li>  Data moves only in one direction. </li></ul><br><h5>  Differences from Flux </h5><br>  RefluxJS is an improved version of the Flux-concept, more dynamic and friendlier to functional reactive programming: <br><ul><li>  The dispatcher of events (dispatcher), which in Flux was a singleton, is not in RefluxJS.  Instead, each event (action) is its own dispatcher. </li><li>  Since actions can be subscribed to, stores can do this directly without using cumbersome switch statements to separate flies from cutlets. </li><li>  Repositories can subscribe to other repositories.  That is, it becomes possible to create storages that aggregate and process data in the map-reduce style. </li><li>  The waitFor () call was deleted.  Instead, data processing can be done sequentially or in parallel. <br><ul><li>  Repositories that aggregate data (see above) can subscribe to other repositories, processing messages sequentially </li><li>  You can use the join () method to wait for other events to be processed. </li></ul><br></li><li>  Special action factors are not needed at all, since RefluxJS action games are functions that transmit the necessary data to everyone who subscribes to them. </li></ul><br><h4>  Examples </h4><br>  Some examples can be found at the following addresses: <br><ul><li>  <a href="https://github.com/spoike/refluxjs-todo">An example of the development of draft lists of cases on RefluxJS</a> </li><li>  <a href="https://github.com/echenley/react-news">Clone of the project HackerNews for echenley authorship</a> </li><li>  <a href="https://github.com/limelights/todo-reflux">Another TODO project using limelights for the backend implementation</a> </li></ul><br><h4>  Installation </h4><br>  Currently RefluxJS can be installed using npm or using bower. <br><br><h5>  NPM </h5><br>  To install using npm, run the following command: <br><br><pre> <code class="bash hljs"> npm install reflux</code> </pre><br><br><h5>  Bower </h5><br>  To install using bower: <br><br><pre> <code class="bash hljs"> bower install reflux</code> </pre><br><h5>  ES5 </h5><br>  Like React, RefluxJS requires <i>es5-shim</i> for legacy browsers.  You can take it <a href="https://github.com/kriskowal/es5-shim">here.</a> <br><br><h4>  Using </h4><br>  A full example can be found <a href="">here</a> . <br><br><h5>  We create actions </h5><br>  Actions are created by calling `Reflux.createAction ()`.  As a parameter, you can pass a list of options. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> statusUpdate = Reflux.createAction(options);</code> </pre><br>  The action object is a <a href="http://en.wikipedia.org/wiki/Function_object">functor</a> , so you can call it by referring to the object as a function: <br><br><pre> <code class="javascript hljs">statusUpdate(data); <span class="hljs-comment"><span class="hljs-comment">//   statusUpdate,     data statusUpdate.triggerAsync(data); //  ,  </span></span></code> </pre><br>  If `options.sync` is set to true, the event will be triggered as a synchronous operation.  This setting can be changed at any time.  All following calls will use the set value. <br><br>  For convenient creation of a large number of actions, you can do this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Actions = Reflux.createActions([ <span class="hljs-string"><span class="hljs-string">"statusUpdate"</span></span>, <span class="hljs-string"><span class="hljs-string">"statusEdited"</span></span>, <span class="hljs-string"><span class="hljs-string">"statusAdded"</span></span> ]); <span class="hljs-comment"><span class="hljs-comment">//   Actions    ,      createActions(). //      Actions.statusUpdate();</span></span></code> </pre><br><h6>  Asynchronous work with actions </h6><br>  For events that can be handled asynchronously (for example, API calls) there are several different work options.  In the most general case, we consider the successful completion of processing and error.  To create different events in this version, you can use `options.children`. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   'load', 'load.completed'  'load.failed' var Actions = Reflux.createActions({ "load": {children: ["completed","failed"]} }); //      'load',   , //      ,   failed  completed Actions.load.listen( function() { //      . //      this someAsyncOperation() .then( this.completed ) .catch( this.failed ); });</span></span></code> </pre><br><br>  For the considered case there is a special option: `options.asyncResult`.  The following action definitions are equivalent: <br><br><pre> <code class="javascript hljs">createAction({ <span class="hljs-attr"><span class="hljs-attr">children</span></span>: [<span class="hljs-string"><span class="hljs-string">"progressed"</span></span>,<span class="hljs-string"><span class="hljs-string">"completed"</span></span>,<span class="hljs-string"><span class="hljs-string">"failed"</span></span>] }); createAction({ <span class="hljs-attr"><span class="hljs-attr">asyncResult</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">children</span></span>: [<span class="hljs-string"><span class="hljs-string">"progressed"</span></span>] });</code> </pre><br><br>  The following methods are available for automatically calling child actions `completed` and` failed`: <br><ul><li>  `promise` - As a parameter, it waits for the object of the promise and binds the call` completed` and `failed` to this promise using` then () `and` catch () `. </li><li>  `listenAndPromise` - As a parameter expects a function that returns a promise object.  It (the object of the promise that the function returned) will be called when the event occurs.  Accordingly, the `then ()` and `catch ()` promises are automatically called completed and failed </li></ul><br>  The following three definitions are equivalent: <br><br><pre> <code class="javascript hljs">asyncResultAction.listen( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arguments</span></span></span><span class="hljs-function">) </span></span>{ someAsyncOperation(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) .then(asyncResultAction.completed) .catch(asyncResultAction.failed); }); asyncResultAction.listen( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arguments</span></span></span><span class="hljs-function">) </span></span>{ asyncResultAction.promise( someAsyncOperation(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>) ); }); asyncResultAction.listenAndPromise( someAsyncOperation );</code> </pre><br><h6>  Asynchronous actions as promises </h6><br>  Asynchronous actions can be used as promises.  This is especially convenient for rendering on the server when you need to wait for the successful (or not) completion of some event before rendering. <br><br>  Suppose we have an action and a repository and we need to execute an API request: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     `completed` &amp; `failed` "" var makeRequest = Reflux.createAction({ asyncResult: true }); var RequestStore = Reflux.createStore({ init: function() { this.listenTo(makeRequest, 'onMakeRequest'); }, onMakeRequest: function(url) { // ,  `request` - - HTTP  request(url, function(response) { if (response.ok) { makeRequest.completed(response.body); } else { makeRequest.failed(response.error); } }) } });</span></span></code> </pre><br><br>  In this case, you can use promises on the server to either execute the request and either render something or return an error: <br><br><pre> <code class="javascript hljs">makeRequest(<span class="hljs-string"><span class="hljs-string">'/api/something'</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">body</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Render the response body }).catch(function(err) { // Handle the API error object });</span></span></code> </pre><br><h6>  Hooks available during event handling </h6><br>  There are several hooks available for each event. <br><br><ul><li>  `preEmit` - called before the action sends the event information to subscribers.  As arguments, the hook gets the arguments used when sending the event.  If the hook returns anything other than undefined, the return value will be used as parameters for the `shouldEmit` hook and will replace the data sent. </li><li>  `shouldEmit` - called after` preEmit`, but before the action sends the event information to subscribers.  By default, this handler returns true, which allows data to be sent.  You can override this behavior, for example, to check the arguments and decide whether the event should be sent in a chain or not. </li></ul><br><br>  Usage example: <br><br><pre> <code class="javascript hljs">Actions.statusUpdate.preEmit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }; Actions.statusUpdate.shouldEmit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> value &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; }; Actions.statusUpdate(<span class="hljs-number"><span class="hljs-number">0</span></span>); Actions.statusUpdate(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   : 1</span></span></code> </pre><br><br>  You can define hooks directly when declaring actions: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> action = Reflux.createAction({ <span class="hljs-attr"><span class="hljs-attr">preEmit</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{...}, <span class="hljs-attr"><span class="hljs-attr">shouldEmit</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{...} });</code> </pre><br><h6>  Reflux.ActionMethods </h6><br>  If you need to perform any method on the objects of all actions, for this you can extend the `Reflux.ActionMethods` object, which is automatically mixed into all actions when created. <br><br>  Usage example: <br><br><pre> <code class="javascript hljs">Reflux.ActionMethods.exampleMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }; Actions.statusUpdate.exampleMethod(<span class="hljs-string"><span class="hljs-string">'arg1'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// : 'arg1'</span></span></code> </pre><br><h6>  Creating repositories </h6><br>  Stores are created in much the same way as the <a href="https://facebook.github.io/react/">ReactJS</a> (`React.createClass`) component classes - by passing an object defining storage parameters to the` Reflux.createStore` method.  All event handlers can be initialized in the `init` method of the repository by calling the` `listenTo` 'own repository method. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var statusStore = Reflux.createStore({ //   init: function() { //    statusUpdate this.listenTo(statusUpdate, this.output); }, //    ,   output: function(flag) { var status = flag ? 'ONLINE' : 'OFFLINE'; //     ,     this.trigger(status); } });</span></span></code> </pre><br>  In the example above, when the action is called `statusUpdate`, the storage method` output` will be called with all the parameters passed during the sending.  For example, if an event was sent using the `statusUpdate (true)` call, the `true` flag will be passed to the` output` function.  After that, the repository itself will work as an action and transfer to its subscribers as `status` data. <br><br>  Since the repositories themselves are the initiators of sending events, they also have the `preEmit` and` shouldEmit` hooks. <br><br><h6>  Reflux.StoreMethods </h6><br>  If it is necessary to make a certain set of methods available at once in all storages, for this you can extend the object `Reflux.StoreMethods`, which is mixed into all storages when they are created. <br><br>  Usage example: <br><br><pre> <code class="javascript hljs">Reflux.StoreMethods.exampleMethod = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); }; statusStore.exampleMethod(<span class="hljs-string"><span class="hljs-string">'arg1'</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  : 'arg1'</span></span></code> </pre><br><h6>  Impurities (mixins) in storage </h6><br>  Just as you add objects to React components, you can add them to your repositories: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyMixin = { <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'bar!'</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Store = Reflux.createStore({ <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [MyMixin] }); Store.foo(); <span class="hljs-comment"><span class="hljs-comment">//  "bar!"  </span></span></code> </pre><br><br>  Impurity methods are available in the same way as the native methods declared in the repositories.  Therefore, `this` from any method will point to the repository instance: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> MyMixin = { <span class="hljs-attr"><span class="hljs-attr">mixinMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.foo); } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Store = Reflux.createStore({ <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [MyMixin], <span class="hljs-attr"><span class="hljs-attr">foo</span></span>: <span class="hljs-string"><span class="hljs-string">'bar!'</span></span>, <span class="hljs-attr"><span class="hljs-attr">storeMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.mixinMethod(); <span class="hljs-comment"><span class="hljs-comment">//  "bar!" } });</span></span></code> </pre><br><br>  Conveniently, if several impurities are mixed into the repository, which determine the same methods of the event life cycle (`init`,` preEmit`, `shouldEmit`), all these methods will be guaranteed to be invoked (as in ReactJS itself). <br><br><h6>  Convenient subscription to a large number of actions </h6><br>  Since the repository init method usually subscribes to all registered actions, the repositories have a `listenToMany` method that takes as an argument an object with all the events created.  Instead of the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actions = Reflux.createActions([<span class="hljs-string"><span class="hljs-string">"fireBall"</span></span>,<span class="hljs-string"><span class="hljs-string">"magicMissile"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Store = Reflux.createStore({ <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listenTo(actions.fireBall,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFireBall); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listenTo(actions.magicMissile,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onMagicMissile); }, <span class="hljs-attr"><span class="hljs-attr">onFireBall</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// whoooosh! }, onMagicMissile: function(){ // bzzzzapp! } });</span></span></code> </pre><br><br>  ... you can use this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actions = Reflux.createActions([<span class="hljs-string"><span class="hljs-string">"fireBall"</span></span>,<span class="hljs-string"><span class="hljs-string">"magicMissile"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Store = Reflux.createStore({ <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listenToMany(actions); }, <span class="hljs-attr"><span class="hljs-attr">onFireBall</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// whoooosh! }, onMagicMissile: function(){ // bzzzzapp! } });</span></span></code> </pre><br><br>  Such code will add handlers for all actions `actionName`, for which there is a corresponding storage method` onActionName` (or `actionName` if you prefer).  In the example above, if the `actions` object also contained an ʻiceShard` action, it would simply be ignored (since there is no corresponding handler for it). <br><br><h6>  The `listenables` property </h6><br>  To make it even more convenient for you, you can assign an object with actions to the `listenables` storage property, it will be automatically transferred to` listenToMany`.  Therefore, the example above can be simplified to this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actions = Reflux.createActions([<span class="hljs-string"><span class="hljs-string">"fireBall"</span></span>,<span class="hljs-string"><span class="hljs-string">"magicMissile"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Store = Reflux.createStore({ <span class="hljs-attr"><span class="hljs-attr">listenables</span></span>: actions, <span class="hljs-attr"><span class="hljs-attr">onFireBall</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// whoooosh! }, onMagicMissile: function(){ // bzzzzapp! } });</span></span></code> </pre><br><br>  The `listenables` property can be an array of similar objects.  In this case, each object will be passed to `listenToMany`. This allows you to conveniently do the following: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Store = Reflux.createStore({ <span class="hljs-attr"><span class="hljs-attr">listenables</span></span>: [<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./darkspells'</span></span>),<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./lightspells'</span></span>),{<span class="hljs-attr"><span class="hljs-attr">healthChange</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'./healthstore'</span></span>)}], <span class="hljs-comment"><span class="hljs-comment">//       });</span></span></code> </pre><br><h6>  Subscription to repositories (handling events sent by repositories) </h6><br>  In your component, you can subscribe to event handling from the repository like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     var statusStore = Reflux.createStore({ //   init: function() { //    statusUpdate this.listenTo(statusUpdate, this.output); }, //  output: function(flag) { var status = flag ? 'ONLINE' : 'OFFLINE'; //    this.trigger(status); } }); //   ,       function ConsoleComponent() { //    statusStore.listen(function(status) { console.log('status: ', status); }); };</span></span></code> </pre><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consoleComponent = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConsoleComponent();</code> </pre><br><br>  We send events along the chain using the `statusUpdate` action object as functions: <br><br><pre> <code class="javascript hljs">statusUpdate(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); statusUpdate(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre><br><br>  If you do everything as stated above, the output should be like this: <br><br><pre>  status: ONLINE
 status: OFFLINE </pre><br><br><h5>  An example of working with React components </h5><br>  Subscribing to actions in the React component can be done in the ` <a href="http://facebook.github.io/react/docs/component-specs.html">componentDidMount`</a> [lifecycle method] () method, and unsubscribed in the `componentWillUnmount` method like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Status = React.createClass({ <span class="hljs-attr"><span class="hljs-attr">initialize</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ }, <span class="hljs-attr"><span class="hljs-attr">onStatusChange</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">currentStatus</span></span>: status }); }, <span class="hljs-attr"><span class="hljs-attr">componentDidMount</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe = statusStore.listen(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onStatusChange); }, <span class="hljs-attr"><span class="hljs-attr">componentWillUnmount</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.unsubscribe(); }, <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   } });</span></span></code> </pre><br><h6>  Impurities for convenient operation inside React components </h6><br>  Since components need to constantly subscribe / unsubscribe from events at the right moments, for ease of use, you can use the <a href="http://facebook.github.io/react/docs/reusable-components.html">admixture</a> `Reflux.ListenerMixin`.  Using it, the example above can be rewritten as: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Status = React.createClass({ <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [Reflux.ListenerMixin], <span class="hljs-attr"><span class="hljs-attr">onStatusChange</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">currentStatus</span></span>: status }); }, <span class="hljs-attr"><span class="hljs-attr">componentDidMount</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.listenTo(statusStore, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onStatusChange); }, <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// render specifics } });</span></span></code> </pre><br><br>  This impurity makes the `listenTo 'method available for calling inside the component, which works in the same way as the repository method of the same name.  You can use the `listenToMany` method. <br><br><h6>  Using Reflux.listenTo </h6><br>  If you do not use any specific logic regarding `this.listenTo ()` inside `componentDidMount ()`, you can use the call `Reflux.listenTo ()` as an impurity.  In this case, `componentDidMount ()` will be automatically configured as required, and you will get an admixture of `ListenerMixin` in your component.  Thus, the example above can be rewritten as: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Status = React.createClass({ <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [Reflux.listenTo(statusStore,<span class="hljs-string"><span class="hljs-string">"onStatusChange"</span></span>)], <span class="hljs-attr"><span class="hljs-attr">onStatusChange</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">status</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">currentStatus</span></span>: status }); }, <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    `this.state.currentStatus` } });</span></span></code> </pre><br><br>  You can insert multiple calls of `Reflux.listenTo` inside the same` mixix` array. <br><br>  There is also `Reflux.listenToMany` which works in the same way, allowing you to use` listener.listenToMany`. <br><br><h6>  Using Reflux.connect </h6><br>  If all you need is to update the state of the component when you receive data from the repository, you can use the expression `Reflux.connect (listener, [stateKey])` as an admixture of the ReactJS component.  If you pass the optional `stateKey` key there, the state of the component will be automatically updated using` this.setState ({: data}) `.  If `stateKey` is not passed, a call will be made to` this.setState (data) `.  Here is an example above, rewritten to reflect new features: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Status = React.createClass({ <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [Reflux.connect(statusStore,<span class="hljs-string"><span class="hljs-string">"currentStatus"</span></span>)], <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// render using `this.state.currentStatus` } });</span></span></code> </pre><br><br><h6>  Using Reflux.connectFilter </h6><br><br>  `Reflux.connectFilter` can be used exactly the same as` Reflux.connect`.  Use `connectFilter` as an impurity in case you need to transfer only a part of the storage state to the component.  For example, a blog written using Reflux is likely to keep all publications in the repository.  And on the page of a separate post, you can use `Reflux.connectFilter` to filter posts. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> PostView = React.createClass({ <span class="hljs-attr"><span class="hljs-attr">mixins</span></span>: [Reflux.connectFilter(postStore,<span class="hljs-string"><span class="hljs-string">"post"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">posts</span></span></span><span class="hljs-function">) </span></span>{ posts.filter(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">post</span></span></span><span class="hljs-function">) </span></span>{ post.id === <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.id; }); })], <span class="hljs-attr"><span class="hljs-attr">render</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ,  `this.state.post` } });</span></span></code> </pre><br><h6>  Handling change events from other repositories </h6><br>  The repository can subscribe to changes in other repositories, allowing you to build data transfer chains between repositories to aggregate data without affecting other parts of the application.  A repository can subscribe to changes that occur in other repositories using the `listenTo` method, just as it does with action objects: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    ,   statusStore var statusHistoryStore = Reflux.createStore({ init: function() { //       this.listenTo(statusStore, this.output); this.history = []; }, //   output: function(statusString) { this.history.push({ date: new Date(), status: statusString }); //    this.trigger(this.history); } });</span></span></code> </pre><br><h4>  Additional features </h4><br><h5>  Using the alternative event management library </h5><br>  Don't like the `EventEmitter` provided by default?  You can switch to using any other, including the one built into Node like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//         Reflux.setEventEmitter(require('events').EventEmitter);</span></span></code> </pre><br><br><h5>  Using an alternative library of promises </h5><br>  Do not like the library that implements the functionality of promis, provided by default?  You can switch to using any other (for example, <a href="https://github.com/petkaantonov/bluebird/">Bluebird</a> like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//        Reflux.setPromise(require('bluebird'));</span></span></code> </pre><br><br>  Keep in mind that promises in RefluxJS are created by calling `new Promise (...)`.  If your library uses factories, use the `Reflux.setPromiseFactory ()` call. <br><br><h6>  Use of promis factory </h6><br>  Since most of the libraries for working with promises do not use constructors (`new Promise (...)`), there is no need to set up a factory. <br><br>  However, if you use something like `Q` or some other library that uses the factory method to create promises, use the` Reflux.setPromiseFactory` call to specify it. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       Reflux.setPromiseFactory(require('Q').Promise);</span></span></code> </pre><br><h5>   nextTick </h5><br>      ,   .    ,      `setTimeout` ( `nextTick`)  RefluxJS. <br><br>         (`setTimeout`, `nextTick`, `setImmediate`  ..)   . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// node.js env Reflux.nextTick(process.nextTick);</span></span></code> </pre><br><br>    ,     <a href="https://github.com/YuzuJS/setImmediate">`setImmediate`</a>  <a href="https://github.com/calvinmetcalf/macrotask">`macrotask`</a> <br><br><h5>        </h5><br>  Reflux API   `join`,     ,   .   ,    `waitFor`    Flux  Facebook. <br><br><h6>   </h6><br> ,   `join()`            .         ,        `join`. <br><br>    `join`,          : <br><br><ul><li> `joinLeading`:         .     </li><li> `joinTrailing`:         .     </li><li> `joinConcat`:     . </li><li> `joinStrict`:            . </li></ul><br><br>     : <br><br><pre> <code class="javascript hljs">joinXyz(...publisher, callback)</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As soon as `join ()` is executed, all restrictions related to it will be removed and it will be able to work again if the publishers send events to the chain again. </font></font><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using instance methods for event management </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All objects that use the listener API (repositories, React components that have mixed with `ListenerMixin`, or other components that use` ListenerMethods`) get access to four variants of the `join` method that we talked about above: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gainHeroBadgeStore = Reflux.createStore({ <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.joinTrailing(actions.disarmBomb, actions.saveHostage, actions.recoverData, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.triggerAsync); } }); actions.disarmBomb(<span class="hljs-string"><span class="hljs-string">"warehouse"</span></span>); actions.recoverData(<span class="hljs-string"><span class="hljs-string">"seedyletter"</span></span>); actions.disarmBomb(<span class="hljs-string"><span class="hljs-string">"docks"</span></span>); actions.saveHostage(<span class="hljs-string"><span class="hljs-string">"offices"</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">// `gainHeroBadgeStore`            `[["docks"],["offices",3],["seedyletter"]]`</span></span></code> </pre><br><br><h6><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Using static methods </font></font></h6><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the use of the `join` methods, and then sending events to the chain is common for the repository, all the join methods have their static equivalents in the` Reflux` object, which return the repository object subscribed to the specified events. </font><font style="vertical-align: inherit;">Using these methods, the example above can be rewritten as:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> gainHeroBadgeStore = Reflux.joinTrailing(actions.disarmBomb, actions.saveHostage, actions.recoverData);</code> </pre><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Send a default state using the listenTo method </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The `listenTo` function provided by the repository and` ListenerMixin` has a third parameter, which can be a function. </font><font style="vertical-align: inherit;">This function will be called at the time of registration of the handler with the result of calling `getInitialState` as parameters.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> exampleStore = Reflux.createStore({ <span class="hljs-attr"><span class="hljs-attr">init</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">getInitialState</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"-   "</span></span>; } }); <span class="hljs-comment"><span class="hljs-comment">//      this.listenTo(exampleStore, onChangeCallback, initialCallback) // initialCallback      "-   "</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remember the `listenToMany` method? </font><font style="vertical-align: inherit;">If you use it with other repositories, it also supports `getInitialState`. </font><font style="vertical-align: inherit;">The data returned by this method will be passed to the normal handler, or to the `this.onDefault` method if it exists.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Colophon </font></font></h4><br><ul><li> <a href="https://github.com/spoike/reflux/graphs/contributors"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List of contributors</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Project license: </font></font><a href="http://opensource.org/licenses/BSD-3-Clause"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BSD 3-Clause License</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Copyright 2014, Mikael Brassman.</font></font></li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detailed license information</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reflux uses </font></font><a href="https://github.com/3rd-Eden/EventEmitter3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eventemitter3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is currently distributed under the </font></font><a href="https://github.com/3rd-Eden/EventEmitter3/blob/master/LICENSE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MIT license.</font></font></a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/250581/">https://habr.com/ru/post/250581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../250569/index.html">Nice build frontend project</a></li>
<li><a href="../250571/index.html">RIG exploit kit exploit source code leaked to network</a></li>
<li><a href="../250573/index.html">[Homebrew] web honeypot do it yourself</a></li>
<li><a href="../250577/index.html">Rust 1.0: current state and final release schedule</a></li>
<li><a href="../250579/index.html">Got access to iPhone diagnostic console</a></li>
<li><a href="../250583/index.html">What version of java are you using?</a></li>
<li><a href="../250585/index.html">The challenge of 64 coins, two prisoners and one chessboard</a></li>
<li><a href="../250587/index.html">How to find out the location of a user, knowing only his email address</a></li>
<li><a href="../250589/index.html">Angular Light + Object.observe</a></li>
<li><a href="../250591/index.html">Pure-functional REST API on Finagle / Finch</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>