<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kotlin vs. Java: compile speed</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As all Android developers already know, Google recently announced Kotlin‚Äôs official support for Android. Many of the risks associated with using this ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kotlin vs. Java: compile speed</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/e24/90c/b71/e2490cb717ac4966990345d3ed00dd6b.png"></p><br><p>  As all Android developers already know, Google recently announced Kotlin‚Äôs official support for Android.  Many of the risks associated with using this wonderful language in Android projects have been removed.  But topical, especially for very large projects like Badoo, is the issue of assembly speed.  I was glad to discover that there are already studies on this topic in the network, and I want to share the translation of one of them. </p><br><p>  So, if you are translating an application from Java to Kotlin, will it compile longer? </p><a name="habracut"></a><br><p>  An earlier article <a href="https://medium.com/keepsafe-engineering/lessons-from-converting-an-app-to-100-kotlin-68984a05dcb6">discussed converting an Android application from Java entirely into Kotlin</a> .  The code on Kotlin turned out to be less, and it was easier to maintain than to Java, so I came to the conclusion that it was worth it.  But some developers don't want to try Kotlin, for fear that it might compile more slowly than Java.  And this concern is fair: no one wants to spend time converting the code if, as a result, the assembly will last longer.  So let's examine the duration of compilation of the <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.getkeepsafe.applock">App Lock</a> application before and after converting to Kotlin.  I will not compare the speed of Kotlin and Java line by line, but instead I will try to answer the question whether the conversion of the entire code base from one language to another will affect the overall build time. </p><br><h3 id="kak-ya-testiroval-dlitelnost-sborki">  How I tested the build duration </h3><br><p>  I wrote shell scripts for repeated launches of Gradle builds for different scripts.  All tests were performed sequentially ten times.  Before each new scenario, the project was cleared.  For scripts that use the <a href="https://docs.gradle.org/current/userguide/gradle_daemon.html">Gradle daemon</a> , the last one stopped before starting the benchmark. </p><br><p>  All benchmarks were performed on a machine with an Intel Core i7‚Äì6700 operating at 3.4 GHz, equipped with 32 GB DDR4 memory, and a Samsung 850 Pro SSD drive.  The source code was compiled using Gradle 2.14.1. </p><br><h4 id="testy">  Tests </h4><br><p>  I wanted to drive off benchmarks for several common usage scenarios: clean builds with / without the Gradle daemon, incremental builds without changing files, incremental builds with a modified file. </p><br><p>  The Java App Lock codebase contained 5491 methods and 12,371 lines of code.  After converting to Kotlin, the number of methods decreased to 4987, and the number of lines to 8564. During the conversion to the architecture, no major changes were made, so measuring the duration of the compilation before and after converting should give a clear idea of ‚Äã‚Äãthe difference in the length of assembly between Java and Kotlin . </p><br><h4 id="chistye-sborki-bez-demona-gradle">  Clean builds without the Gradle daemon </h4><br><p>  This is the worst scenario in terms of the build duration for both languages: running a clean build with a cold start.  For this test, I disabled the Gradle daemon. </p><br><p>  That's how much time it took all ten assemblies: </p><br><p><img src="https://habrastorage.org/web/4de/963/2ff/4de9632ffb114c8f9ddbd11d271cae3c.png"><br>  <em>Ten consecutive clean builds without a Gradle daemon</em> </p><br><p>  The average Java build duration is [figures corrected based on the author‚Äôs source data - approx.  translator] 24.5 seconds, Kotlin - 32.4 seconds: an increase of 32%.  Not the best start for Kotlin, but most people compile their code for other scenarios. </p><br><p>  More often than not, we compile the same code base several times as we make changes to it.  It is for this scenario that the Gradle daemon was developed, so let's turn it on and see what happens. </p><br><h4 id="chistye-sborki-s-vklyuchyonnym-demonom-gradle">  Clean builds with the Gradle daemon enabled </h4><br><p> One of the problems with <a href="https://ru.wikipedia.org/wiki/JIT-%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D0%25B8%25D0%25BB%25D1%258F%25D1%2586%25D0%25B8%25D1%258F">JIT compilers</a> like the JVM is that they spend time compiling the code executed in them, so that as it executes, the performance of the process increases.  But if you stop the JVM process, the performance gain is lost.  Every time you build Java code, you usually have to start and stop the JVM.  As a result, he does the same work every time.  To solve this problem, Gradle comes with a daemon that continues to function between builds and helps maintain the performance gains provided by JIT compilation.  You can enable the daemon using the <code>--daemon</code> command <code>--daemon</code> , entered on the command line, or by adding <code>org.gradle.daemon=true</code> to the <code>gradle.properties</code> file. </p><br><p>  Here is the result of running the same build series, but with the Gradle daemon enabled: </p><br><p><img src="https://habrastorage.org/web/e8f/b1b/401/e8fb1b4012d147f9a6989402e6fa5b25.png"><br>  <em>Ten consecutive builds with the Gradle daemon enabled</em> </p><br><p>  As you can see, the first run takes about the same time as in the script without a demon.  In subsequent builds, performance increases up to the fourth run.  In this scenario, it is more appropriate to estimate the average build duration after the third run, when the daemon has already warmed up.  In this case, the pure Java build takes an average of 14.1 seconds, and on Kotlin it takes 16.5 seconds: an increase of 13%. </p><br><p>  Kotlin is catching up with Java, but still lags behind.  However, regardless of the language used, the Gradle daemon reduces the build duration by more than 40%.  If you are not using it yet, then it's time to start. </p><br><p>  So, complete builds on Kotlin are slightly slower than on Java.  But usually we compile after making changes in just a few lines of code, so incremental assemblies should demonstrate different performance.  Let's find out if Kotlin can catch up with Java where it matters. </p><br><h4 id="inkrementalnye-sborki">  Incremental builds </h4><br><p>  Using incremental compilation is one of the most important features of the compiler to improve performance.  In a normal build, all project source files are recompiled, and in incremental one, it is monitored which files have changed since the previous build, and as a result, only these files and those that depend on them are recompiled.  This can have a very strong impact on the duration of the compilation, especially in large projects. <br>  Incremental assemblies appeared in <a href="https://blog.jetbrains.com/kotlin/2016/05/kotlin-1-0-2-is-here/">Kotlin 1.0.2</a> , you can enable them by adding <code>kotlin.incremental=true</code> to the <code>gradle.properties</code> file, or <a href="https://kotlinlang.org/docs/reference/using-gradle.html">via the command line</a> . </p><br><p>  So, how does the Kotlin compilation duration change compared to Java when using incremental compilation? </p><br><p>  Here are the benchmark results provided there are no changes in the files: </p><br><p><img src="https://habrastorage.org/web/619/611/d94/619611d945bd4fb99c174152a828f4ee.png"><br>  <em>Ten consecutive incremental builds without changing files</em> </p><br><p>  Now we will test the incremental compilation, provided that one source file is modified.  To do this, I changed the Java file and its Kotlin equivalent before each build.  In this benchmark, this is a file related to the user interface; other files do not depend on it: </p><br><p><img src="https://habrastorage.org/web/f21/e5c/778/f21e5c77868543c499317d92a567f69e.png"><br>  <em>Ten consecutive incremental builds with one separate modified file.</em> </p><br><p>  Finally, let's look at the results of incremental compilation with one modified source file, which is imported into many other project files: </p><br><p><img src="https://habrastorage.org/web/feb/5d6/f42/feb5d6f428144edcae9f0c05e9a21c73.png"><br>  <em>Ten consecutive incremental builds, subject to change of one key file</em> </p><br><p>  As you can see, the Gradle daemon still has to warm up for two or three runs, but after that both languages ‚Äã‚Äãbecome very close in performance.  In the absence of changes in the files, Java takes 4.6 seconds to warm up the build, while Kotlin takes 4.5 seconds.  If we change the file, but it is not used by other files, then Java takes 7 seconds to execute the heated build, and Kotlin takes 6.1 seconds.  Finally, if a modified file is imported into many other project files, then with a heated Gradle daemon, an incremental Java build takes 7.1 seconds, and for Kotlin it takes an average of 6 seconds. </p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  We measured performance under several different scenarios to see if Kotlin could compete with Java in terms of compilation duration.  With clean builds that are relatively rare, Java exceeds Kotlin by 10‚Äì15%.  But most often, developers perform partial assemblies, in which a large time gain is achieved through incremental compilation.  Thanks to the running Gradle daemon and the included incremental compilation, Kotlin is not inferior, or even slightly superior to Java.  An impressive result that I did not expect.  I express my respect for the Kotlin development team for creating a language that not only has excellent capabilities, but also compiles so quickly. </p><br><p>  If you have not tried Kotlin for fear of increasing the length of the compilation, then you can no longer worry: it compiles as fast as Java. </p><br><p>  The raw data I collected when running the benchmarks is <a href="https://gist.github.com/ajalt/31c4a45001bea4438f313c899fa961a8">here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329026/">https://habr.com/ru/post/329026/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329016/index.html">Creating a Match-3 game in Unity</a></li>
<li><a href="../329018/index.html">Why are women programmers much less than men? Infographic survey from "My Circle"</a></li>
<li><a href="../329020/index.html">Successful CIO in 2017: what is he?</a></li>
<li><a href="../329022/index.html">SSL implementation through SAML with an example</a></li>
<li><a href="../329024/index.html">Diagnostic Tools Plugin for Qt Creator</a></li>
<li><a href="../329028/index.html">Kotlin for Android: Now officially</a></li>
<li><a href="../329032/index.html">Client application architecture (structuring mechanisms)</a></li>
<li><a href="../329036/index.html">VMware vSphere 6 for technical writers</a></li>
<li><a href="../329038/index.html">June DevCon-School: AI, BlockChain, Azure Stack and 12 Master Classes</a></li>
<li><a href="../329042/index.html">How the GPL was tempered</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>