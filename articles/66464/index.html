<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>EHcache RESTful server, PHP and just experiments ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today we will continue to research various new and not very advanced technologies, their unusual application or just original things. Perhaps you reme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>EHcache RESTful server, PHP and just experiments ...</h1><div class="post__text post__text-html js-mediator-article"><img align="left" title="logo" src="http://abrdev.com/wp-content/uploads/2009/08/logo.png" alt="logo" width="316" height="88">  Today we will continue to research various new and not very advanced technologies, their unusual application or just original things.  Perhaps you remember, I once wrote about the <a href="http://habrahabr.ru/blogs/sfworld/25140/">distributed cache</a> project <a href="http://habrahabr.ru/blogs/sfworld/25140/">EHcache</a> for the Java platform.  Today it is time to continue this topic, but from a different perspective - as a separate RESTful server. <br><br><a name="habracut"></a><br>  First, mention <a href="http://ehcache.sourceforge.net/">EHcache</a> .  This is a high-performance and scalable caching system for Java, which is a mature and serious project.  Caching options are available both in RAM and disk cache, as well as combined strategies (there is also an option to ensure data integrity when the virtual machine or server reboots).  Scalability is implemented using asynchronous replication and cache clustering using <a href="http://www.jgroups.org/">JGroup</a> , JMS, RMI, you can also build distributed systems based on third-party products (Terracota).  I like the distribution most of all - individual settings for each cache (synchronous / asynchronous replication) paired with the ability to run several different instances within one JVM (or different).  Although it should be noted that EHCache stores data in the memory of the JVM process, respectively, some restrictions are imposed on its volume (on 32-bit systems), but nobody canceled the disk cache, and the serious servers are already 64-bit.  Known installations with 20 and more GB of data.  In addition, the utilization of multithreaded capabilities, competitive access and multi-core is well supported (although there is little to argue with, <a href="http://www.jboss.org/jbosscache">JBoss Cache</a> seems to be even better with this, as transactions and some other ‚Äúgoodies‚Äù are supported, but its API is rather difficult to understand, I didn‚Äôt have a chance to figure it out for me in two approaches, while EHcache was launched right away). <br><br>  The cache is very fast and overtakes other caching systems in online tests (however, in clusters of 4 machines, JBoss Cache shows a slightly better result, but this is a slightly different system), including the most popular Memcached.  I know, the comparison is a bit wrong, since EHcache is an in-process cache, while memcached is a separate daemon and works as an external network service (therefore, there are no such restrictions on the size of the cache).  At the same time, if we were to compare that ehcache is still preferable due to much greater flexibility and scalability, memory / disk combination and cache tweaking.  This is where the thought came to me ... is it possible to use EHcache instead of memcached (or together with), while remaining on the PHP platform I am used to?  Yes you can! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The thing is that the developer community, in addition to the cache itself, also implemented a caching REST server, which can be accessed through a REST interface or SOAP.  This solution was made based on the embedded version of the Sun GlassFish v3 Prelude server and is self-contained, including all the necessary components and dependencies.  The server is accessed using the HTTP protocol, using the GET / POST / PUT / DELETE / OPTIONS / HEAD methods, or via SOAP (also on top of HTTP) via XML.  All HTTP / 1.1 features are supported, including keep-alive as well as Last-Modified, ETag, that is, the server gives all the correct headers, so you can often use embedded caching on intermediate nodes during transmission or in the client itself.  An interesting point is the ability to work with several data formats, and to be precise, the ability to get an answer in XML or JSON format, for which it is enough to set the correct MIME-type header in the request. <br><br>  And so, we have the opportunity, literally in one click, to launch a caching server accessible via a simple and understandable protocol, and also to access it from any language or platform that supports HTTP requests.  Let's try! <br><br>  You can download the latest version of the server <a href="http://sourceforge.net/projects/ehcache/files/ehcache-server/">to SourceForge</a> , but I recommend downloading the latest version of the cache in parallel, and then updating the server files, since it uses the previous version of the cache.  We are interested in ehcache-standalone-server, which currently has version 0.7. <br><br>  The distribution kit already has scripts to run, read the README, or to launch, go to the lib directory and run it manually: <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">java -jar ./ehcache-standalone-server-0.7.jar 8080 ../war</font> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> <ol><li> <code><font color="black"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> java -jar ./ehcache-standalone-server-0.7.jar 8080 ../war <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></font></code> </li> </ol> <code><font color="gray"><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">java -jar ./ehcache-standalone-server-0.7.jar 8080 ../war</font> * This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br><br>  After specifying the main server file, there is the port number for which it will be available, as well as the path to the directory with the web application (war file).  In the console, after launching, you will see the connection progress, as well as information about running services and ports - for example, this way I will find out which port the JMX service is available for management.  Since the embedded version of the GlassFish server is used (this is both a web server and an application server), its settings and capabilities are few, but you can always deploy a full-fledged server, not necessarily even GlassFish, and then use only the EHcache server that is available and separately, without a web server. <br><br>  By default, the caches are available at the address <em>/ ehcache / rest</em> - by entering the browser or performing a GET request, we will receive an XML document describing all the current cache settings.  Initially, there are descriptions of several caches in the configuration file, for example, including a couple of distributed ones.  To get started, it's best to delete all the basic settings and create your own caches.  A simple cache, without replications, we will now do. <br><br>  All cache settings are concentrated in one xml file - <em>/war/WEB-INF/classes/ehcache.xml</em> , which we will edit.  Inside there are quite a lot of comments and descriptions of all options, so I will only briefly describe how to make a basic cache in order to continue the experiments. <br><br>  What these options mean: <br><ul><li>  <strong>name</strong> is the name of the cache that will be used for access (will be in the URL, so the same restrictions are imposed on the content, best of all - a short and clearly denoting the type of stored data).  Within one server there can be many caches with different names. </li><li>  <strong>maxElementsInMemory</strong> - the maximum number of elements that are placed in memory </li><li>  <strong>maxElementsOnDisk</strong> - the maximum number of items on the disk (0 - without restrictions) </li><li>  <strong>eternal</strong> - indicates that you can ignore the cache life settings, then the elements will always be in the cache until you manually delete them </li><li>  <strong>overflowToDisk</strong> - indicates whether items can be preempted to disk if the maximum number of objects in memory has been reached </li><li>  <strong>timeToIdleSeconds</strong> - the time from the last access to the object to the moment it is recognized as invalid (if it is not marked as eternal).  Optional parameter </li><li>  <strong>timeToLiveSeconds</strong> - item lifetime (from version 1.6, if I'm not mistaken, this option can be set for each individual cache object </li><li>  <strong>diskPersistent</strong> - indicates that the cache state is kept on the disk between restarts </li><li>  <strong>diskExpiryThreadIntervalSeconds</strong> - the frequency of starting the process of checking objects on a disk for expiration of a TTL (lifetime). </li><li>  <strong>diskSpoolBufferSizeMB</strong> - the volume of the pool that is allocated to the cache for buffering write to disk.  When the pool is full, the cache state command is called asynchronously. </li><li>  <strong>memoryStoreEvictionPolicy</strong> - indicates the strategy for determining which cache objects should be pushed to disk.  It can be LRU (Least Recently Used), by date of last use, FIFO (First In First Out, first added, first preempted) and LFU (Less Frequently Used, by frequency of use) </li></ul><br>  We are not discussing replication options yet - this is already an in-depth specificity, about which more competent specialists would better tell. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  <font color="#0000ff">&lt;</font> <font color="#800000">cache</font> <font color="#ff0000">name</font> <font color="#0000ff">= "testRestCache"</font> </li><li>  <font color="#ff0000">maxElementsInMemory</font> <font color="#0000ff">= "10000"</font> </li><li>  <font color="#ff0000">eternal</font> <font color="#0000ff">= "true"</font> </li><li>  <font color="#ff0000">timeToIdleSeconds</font> <font color="#0000ff">= "0"</font> </li><li>  <font color="#ff0000">timeToLiveSeconds</font> <font color="#0000ff">= "0"</font> </li><li>  <font color="#ff0000">overflowToDisk</font> <font color="#0000ff">= "true"</font> </li><li>  <font color="#ff0000">diskSpoolBufferSizeMB</font> <font color="#0000ff">= "4"</font> </li><li>  <font color="#ff0000">maxElementsOnDisk</font> <font color="#0000ff">= "1,000,000,000"</font> </li><li>  <font color="#ff0000">diskPersistent</font> <font color="#0000ff">= "true"</font> </li><li>  <font color="#ff0000">diskExpiryThreadIntervalSeconds</font> <font color="#0000ff">= "3600"</font> </li><li>  <font color="#ff0000">memoryStoreEvictionPolicy</font> <font color="#0000ff">= "LFU"</font> </li><li>  <font color="#0000ff">/&gt;</font> </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  And so, our cache is configured to keep in memory 10 thousand items, 1 billion on a disk, not to use the lifetime settings, to ensure constancy of data between reboots.  I chose the volume of the pool for disk recording to be rather small, and the time of checking for the life of disk elements is very large (but I think we need more, ideally - see if you can disable it altogether).  What exactly is this configuration for?  It is interesting for me to try to make a simple key-value database based on this cache (today it is a very popular topic), while at the same time providing myself with the possibility of a direct access to the cache from external services, as well as from inside PHP web application.  One caveat - even if you do not need a lifetime check and you need a constant cache, do not set the timeToIdle / timeToLive parameters to 0, otherwise the server may not start (or rather, the cache service, the server itself starts to issue a 404 error). <br><br>  To test, save the edited ehcache.xml file and restart the server.  Now open the URL in your browser: <em><a href="http://localhost/">localhost</a> : 8080 / ehcache / rest / testRestCache</em> - you should get an XML document with all cache settings, as well as current cache usage statistics (volume, amount of data, percentage of hits and misses) - this can be further analyzed programmatically to display in the desired form (for example, in the admin). <br><br>  In the future, I will consider only the REST part, to work through SOAP, you need to change the rest in the URL to soap, get a description of the services in the WSDL format, etc.  For performance, I just turned off everything that is unused, including caches and access that are not needed by the SOAP protocol.  Servlet settings are available in the web.xml file in the <em>/ war / WEB-INF directory</em> . <br><br>  Working with the cache consists in sending requests via the HTTP protocol and parsing the response.  In case of an error, the response will be in text / plain format, and the body of the request will contain the error text, the HTTP code will be 404 - for example, you will access a non-existing cache or element, then the response will be the string "Element not found: 333" (if requested an item with a key 333).  But this is true for those URLs that are serviced by the EHcache servlet, but if the error is in another part, you will receive a standard 404 error page from GlassFish, which is less adapted to automatic parsing. <br><br>  You can work both with the server in general (with the cache manager), and individually with each cache and element, for this simply add the URL line and use the desired method with parameters. <br><br>  For all cache (CacheManager-a): <br><ul><li>  <strong>OPTIONS</strong> - method returns description of available operations in WADL ( <em><a href="http://wadl.dev.java.net/">Web Application Description Language</a> )</em> format </li></ul><br><ul><li>  <strong>GET</strong> - returns in XML format a list of available caches on the server and their parameters.  This is a normal request through the browser, as we did above, for example: <em><a href="http://localhost/">localhost</a> : 8080 / ehcache / rest /</em> </li></ul><br><br><div style="text-align:center;"><img title="cache_manager_options" src="http://abrdev.com/wp-content/uploads/2009/08/cache_manager_options.png" alt="cache_manager_options" width="617" height="527"></div><br><br>  Further along the hierarchy, if you specify a specific cache name in the URL, you can perform the following operations on it: <br><ul><li>  <strong>OPTIONS</strong> - as above, returns a WADL description of available operations. </li><li>  <strong>HEAD</strong> - returns the same meta data describing cache parameters, but in the form of HTTP headers, and not in the response body (as in GET) </li><li>  <strong>GET</strong> - XML ‚Äã‚Äãdocument with cache parameters and its statistics. </li><li>  <strong>PUT</strong> - allows you to create a new cache (the name of which is transferred in the URL string) based on the default cache settings (specified in the configuration file). </li><li>  <strong>DELETE</strong> - deletes the cache specified in the URL.  It removes and does not clear (for this there is another command, oddly enough, among operations on cache elements), it seems, until the next reboot of the server (but I have not checked this moment yet). </li></ul><br>  At the cache element level, the following operations are supported: <br><ul><li>  <strong>OPTIONS</strong> - as above, returns a WADL description of available operations. </li><li>  <strong>HEAD</strong> - returns the contents of an element as a string in the HTTP header (there is ambiguity in the help here, since for other cases HEAD duplicates GET, for cache elements it is indicated that it returns metadata, and not a value). </li><li>  <strong>GET</strong> - returns directly the contents of the cache element in the response body. </li><li>  <strong>PUT</strong> - puts the data in the cache.  The data itself is transmitted in the request body, the object name is in the URL, and an additional parameter, the lifetime, can be transmitted in the HTTP header with the name ‚ÄúehcacheTimeToLiveSeconds‚Äù, take into account that if there is no parameter, the parameter from the cache description will be used, and - 0 (forever) ... 2147483647 (approximately 69 years). </li><li>  <strong>DELETE</strong> - deletes the specified item.  If you need to delete all cache items, use a mask *, it's a pity that other methods do not support this (that is, there is no multi-get at the REST level, although the cache itself supports it completely in JavaAPI). </li></ul><br>  When you save an item to the cache, you can specify its MIME type (from the list of supported), then when retrieving, we immediately get the necessary data.  Supported: <br><ul><li>  text / plain - plain text or arbitrary data. </li><li>  text / xml - XML ‚Äã‚Äãdocument, according to <a href="http://www.ietf.org/rfc/rfc3023.txt">RFC 3023</a> </li><li>  application / json - the most interesting, JSON-format (according to <a href="http://www.ietf.org/rfc/rfc4627.txt">RFC 4627</a> ) </li><li>  application / x-java-serialized-object - serialized Java object </li></ul><br>  Actually, that's all the description of the server itself, now the practical part is how to work with the server from a web application in PHP.  The original idea was to write a special Cache Backend for the <a href="http://framework.zend.com/">Zend Framework</a> , similar to the class for Memcached, but at first I decided to just experiment how this all works.  Perhaps I will write such a class if it will be interesting and useful for anyone other than me. <br><br>  We will use the Zend Framework for experiments, in particular, its classes for working with HTTP requests ( <a href="http.html">Zend_Http_Client</a> ) and the class for working with JSON ( <a href="http://framework.zend.com/manual/en/zend.json.html">Zend_Json</a> ). <br><br>  First you need to establish a connection to the server.  Zend_Http provides several possibilities for this, different adapters, but the Socket adapter was the fastest in tests, I would use Curl last, if the cache server is remote and cannot be reached by other means (for example, you need to use SSL, but This is a strange requirement for the cache, but in some cases this is necessary, the amendment - the socket can also use ssl). <br><br>  We describe the connection options, based on maximum performance, given that we will not do a single request within the page: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  $ _config = Array ( </li><li>  <font color="#A31515">'timeout'</font> =&gt; 5, </li><li>  <font color="#A31515">'maxredirects'</font> =&gt; 1, </li><li>  <font color="#A31515">'httpversion'</font> =&gt; 1.1, </li><li>  <font color="#A31515">'adapter'</font> =&gt; <font color="#A31515">'Zend_Http_Client_Adapter_Sockets'</font> , </li><li>  <font color="#A31515">'options'</font> =&gt; array ( </li><li>  <font color="#A31515">'persistent'</font> =&gt; <font color="#0000ff">true</font> </li><li>  ), </li><li>  <font color="#A31515">'keepalive'</font> =&gt; <font color="#0000ff">true</font> </li><li>  ); </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  Recall that our primary URL is as follows: <i>$ _url = 'http: // localhost: 8080 / ehcache / rest / testRestCache';</i> <br><br>  For the first example, we will try to put in the cache the contents of a large array, which will be $ _SERVER, while setting the JSON as the data type (we first convert the array to JSON before sending). <br><br><blockquote> <code><a href="http://localhost/"></a> <a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  <font color="#008000">// create connection object</font> </li><li>  $ ehcache_connect = <font color="#0000ff">new</font> Zend_Http_Client ( <font color="#A31515">'http: // localhost'</font> , $ _config); </li><li>  <font color="#008000">// name of our object in the cache, its unique id</font> </li><li>  $ _chache_item_name = <font color="#A31515">'testitem1'</font> ; </li><li>  <font color="#008000">// set the full path to the element</font> </li><li>  <font color="#008000">// localhost: 8080 / ehcache / rest / testRestCache / testitem1</font> </li><li>  $ ehcache_connect-&gt; setUri ($ _ url. <font color="#A31515">'/'</font> . $ _chache_item_name); </li><li>  <font color="#008000">// indicate that we use JSON</font> </li><li>  $ ehcache_connect-&gt; setHeaders ( <font color="#A31515">'Content-type'</font> , <font color="#A31515">'application / json'</font> ); </li><li>  <font color="#008000">// set the method</font> </li><li>  $ ehcache_connect-&gt; setMethod (Zend_Http_Client :: PUT); </li><li>  <font color="#008000">// add data with encoding in JSON</font> </li><li>  $ ehcache_connect-&gt; setRawData (Zend_Json :: encode ($ _ SERVER)); </li><li>  <font color="#008000">//Everything!</font>  <font color="#008000">Execute the request</font> </li><li>  $ response = $ ehcache_connect-&gt; request (); </li><li>  <font color="#008000">// we received the answer as an object of class Zend_Http_Response</font> </li><li>  <font color="#0000ff">if</font> ($ response-&gt; isSuccessful ()) </li><li>  { </li><li>  <font color="#008000">// everything is OK, the request is successful, the server returned the correct HTTP response with code 200</font> </li><li>  echo <font color="#A31515">'Request OK!'</font>  ; </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  { </li><li>  echo $ response-&gt; getMessage (); </li><li>  } </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  Now we‚Äôll get our array back, for that we don‚Äôt even have to change the URL, just change the request type, the rest is the same as in the previous code: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a></code> <ol><li>  <font color="#008000">// URL of our object</font> </li><li>  $ ehcache_connect-&gt; setUri ($ _ url. <font color="#A31515">'/'</font> . $ _chache_item_name); </li><li></li><li>  <font color="#008000">// Method</font> </li><li>  $ ehcache_connect-&gt; setMethod (Zend_Http_Client :: GET); </li><li></li><li>  <font color="#008000">// execute the query</font> </li><li>  $ _result = $ ehcache_connect-&gt; request (); </li><li></li><li>  <font color="#008000">// if everything is OK</font> </li><li>  <font color="#0000ff">if</font> ($ _result-&gt; isSuccessful ()) </li><li>  { </li><li>  <font color="#008000">// get the request body and decode it from JSON back to Array</font> </li><li>  $ _json_res = Zend_Json :: decode ($ _ result-&gt; getBody (), Zend_Json :: TYPE_ARRAY); </li><li></li><li>  <font color="#008000">// Display</font> </li><li>  Zend_Debug :: dump ($ _ json_res); </li><li>  } </li><li>  <font color="#0000ff">else</font> </li><li>  { </li><li>  echo $ response-&gt; getMessage (); </li><li>  } </li></ol>  <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font> </blockquote><br><br>  The remaining commands can be set in the same way.  The first thing that slightly limits is that Zend_Http does not support HEAD requests, but they usually duplicate others, so there is no great need for them.  The second disadvantage is that metadata about the cache or specific elements is sent in XML format, although it is possible to work with elements in JSON.  Statistics are given along with all the data, although it would be good to put it in a separate page.  The third disadvantage is that there are no developed possibilities for extracting and adding data.  You cannot immediately put in or request several elements (although there is a Java API itself).  But you can delete everything at once.  Well, security is not secured at all, so do not store confidential data accessible via HTTP to the outside. <br><br>  In conclusion, I will talk about the main idea of ‚Äã‚Äãthis study.  Since we can receive data directly in JSON, and the web server supports all HTTP features, the client application, for example, in AJAX, can easily interact with the cache by requesting data and receiving it in JSON, and the server side will asynchronously store new data when they are.  The client himself can first check if there is any data in the cache, and if not, he will directly contact the server side. <br><br>  It is also quite simple to implement cache sharding and load balancing.  By the way, then it is better to deploy a server based on the full version of GlassFish, since there are not some useful features in the embedded one, such as admin, gzip-compression traffic and load balancer.  You can also use the front end of nginx, which will balance the load between the servers, and they are replicated between themselves using Java tools in the background.  The HTTP protocol is simple and quite flexible, so we can implement any strategy for the behavior of a caching server, combining the capabilities of HTTP and the Java platform. <br><br>  <strong>PS</strong> A few words about performance.  Of course, my tests are far from real and cannot be reliable at all and in general mean something.  The average figure obtained on my machine (development notebook, 1.5 GB RAM / Celeron M 1.7 GHz, WinXP SP3) in the process of preparing the material - 0.020 - 0.025 sec.  on read / write operations (if you use cURL, then approximately twice as long).  Of course, it is interesting to test the variant with replication and load balancing, but this is a completely different level, but I would gladly take part and look at the results. <br><br>  <strong>PPS</strong> Answering the question - why is this all?  In some cases, it can replace other caching systems, the same memcached, as it provides more flexible cache settings, data constancy, various replication systems, it is well scaled and distributed, data can be obtained by the client system directly (AJAX).  At the same time, if you have a part of the backend working in Java, or even the whole, it will be much easier for it to put data there.  EHcache can also work as a highly scalable and reliable key-value database, providing exactly the replication and clustering of a serious level, unlike many new solutions, ehcache has a long history of development and optimization. <br><br>  It seems to me if you take only the servlet that provides the REST interface and put it on some fast and lightweight web server, for example, <a href="http://tjws.sourceforge.net/">Tjws</a> , adding a lightweight balancer, highlighting a separate JVM for each cache (deploying a two-node cluster to each physical server as a matter of fact) - we will get a much faster and easier system with excellent scalability.  And if you add your servlet, literally several lines, we can organize support for other protocols / formats - such a cacher would be very interesting with the ability to receive data through Thrift / Google ProtoBuff, given that clients for these protocols are on client machines (on JS and ActionScript).  The field for research is wide and interesting, right? <br></div><p>Source: <a href="https://habr.com/ru/post/66464/">https://habr.com/ru/post/66464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../66455/index.html">ServerSideJS: now easier than ever. Meet v8cgi!</a></li>
<li><a href="../66458/index.html">Mr bing</a></li>
<li><a href="../66459/index.html">Chart of the most common iron</a></li>
<li><a href="../66460/index.html">BBK PopcornTV NP101S Network Player Review</a></li>
<li><a href="../66463/index.html">Blocks / modules or how to organize it?</a></li>
<li><a href="../66466/index.html">Speech by Bill Gates in 1997 on MacWorld</a></li>
<li><a href="../66469/index.html">Privacy on Habr√©</a></li>
<li><a href="../66477/index.html">Russian language on Habr√©</a></li>
<li><a href="../66478/index.html">Twitter suffered because of the conflict between Russia and Georgia?</a></li>
<li><a href="../66479/index.html">Interface: analog versus digit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>