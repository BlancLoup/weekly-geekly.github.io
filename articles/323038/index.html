<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About ScalaCheck. Properties Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 3. Properties 


 In the previous parts, we already had time to get acquainted with the properties and test them in conjunction with the generato...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About ScalaCheck. Properties Part 3</h1><div class="post__text post__text-html js-mediator-article"><p>  <strong>Part 3. Properties</strong> </p><br><p>  In the previous parts, we already had time to get acquainted with the properties and test them in conjunction with the generators.  In this tutorial we will look at properties in more detail.  The article consists of two parts: the first is technical, it will tell about combinators of properties, as well as other features of the ScalaCheck library.  This section will focus on various testing techniques. </p><a name="habracut"></a><br><p>  <strong>Cycle structure</strong> </p><br><ul><li>  <a href="https://habrahabr.ru/post/319456/">Introduction</a> </li><li>  <a href="https://habrahabr.ru/post/320104/">Generators</a> </li><li>  <a href="https://habr.com/ru/post/323038/">Properties</a> </li><li>  Minimization and state testing </li><li>  Integration and Settings </li></ul><br><h1 id="kombinatory-svoystv">  Combinators properties </h1><br><h2 id="konstantnye-svoystva">  Constant properties </h2><br><p>  Scalacheck has <em>persistent</em> properties ‚Äî properties that always return the same result.  Examples of such properties are: </p><br><ul><li><code>Prop.undecided</code> </li> <li> <code>Prop.falsified</code> </li> <li> <code>Prop.proved</code> </li> <li> <code>Prop.passed</code> </li> <li> <code>Prop.exception(e: Throwable)</code> </li> </ul><br><p>  We are already familiar with the <code>Prop.passed</code> and <code>Prop.falsified</code> methods: <code>Prop.passed</code> corresponds to the successful passing of the <code>forAll</code> combinator test property, and <code>Prop.falsified</code> corresponds to the unsuccessful passing of at least one test for the <code>forAll</code> combinator <code>forAll</code> .  In addition to them: </p><br><ul><li>  <code>Prop.exception</code> returned if something inside your property ~ something jerks ~ an exception is fired; </li><li>  <code>Prop.proved</code> used in conjunction with <code>Prop.throws</code> and <code>Prop.exist</code> : the presence of at least one result, by definition, is nevertheless closer to the proof; </li><li>  <code>Prop.undecided</code> , says that the property could neither be disproved nor proved. </li></ul><br><h2 id="kombinacii-svoystv">  Combinations of properties </h2><br><p>  ScalaCheck allows you to nest <code>forAll</code> , <code>throws</code> and <code>exists</code> an arbitrary way.  <code>forAll</code> demonstrate this with the example of <code>forAll</code> : </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalacheck.Prop.forAll //     . val intsum = forAll { x: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; forAll { y: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; (x + y).isInstanceOf[<span class="hljs-type"><span class="hljs-type">Int</span></span>] } }</code> </pre> <br><h2 id="propthrows">  Prop.throws </h2><br><p>  A logical method that returns true only if during the execution of an expression a quite expected exception is thrown.  You can use properties as follows: </p><br><pre> <code class="hljs haskell"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalacheck.Prop //  : val p0 = Prop.throws(<span class="hljs-title"><span class="hljs-title">classOf</span></span>[<span class="hljs-type"><span class="hljs-type">ArithmeticException</span></span>])(3 / 0) p0.check // + OK, proved property.</code> </pre> <br><p>  However, there is little point in testing constants.  Check the Prop.throws when dividing an arbitrary integer by 0: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> p = <span class="hljs-type"><span class="hljs-type">Prop</span></span>.forAll { x: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">Prop</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">throws</span></span>(classOf[<span class="hljs-type"><span class="hljs-type">ArithmeticException</span></span>]) (x / <span class="hljs-number"><span class="hljs-number">0</span></span>) } p.check <span class="hljs-comment"><span class="hljs-comment">// + OK, passed 100 tests.</span></span></code> </pre> <br><h2 id="propforall">  Prop.forAll </h2><br><p>  Called logic as a <em>universal quantifier</em> , it is also the property we use most often.  The condition passed to <code>forAll</code> must either be a <code>Boolean</code> or be an instance of the class <code>Prop</code> . </p><br><blockquote>  It should be understood that when testing a given property, the library does not <br>  can validate all valid values.  Therefore, often <br>  It is satisfied with some number described in the settings. <br>  By default, this number is 100. You can change it manually. <br>  configuring a property.  You will learn more about the configuration in the following <br>  The following articles of the series. </blockquote><br><h2 id="propexists">  Prop.exists </h2><br><p>  It behaves exactly like a <em>quantifier of existence</em> .  The behavior is much the same as <code>forAll</code> , except that in the case of this combinator, the property counts if at least one element of the set of input data satisfies the given condition.  In practice, using <code>Prop.exist</code> is problematic in view of the fact that it can be quite difficult to find a case that satisfies a given condition: </p><br><pre> <code class="hljs haskell"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalacheck.Prop val p1 = Prop.exists { x: Int =&gt; (<span class="hljs-title"><span class="hljs-title">x</span></span> % 2 == 0) &amp;&amp; (<span class="hljs-title"><span class="hljs-title">x</span></span> &gt; 0) }</code> </pre> <br><p>  When calling <code>p1.check</code> ScalaCheck will display the following: </p><br><pre> <code class="hljs pgsql">scala&gt; p1.<span class="hljs-keyword"><span class="hljs-keyword">check</span></span> + OK, proved property. &gt; ARG_0: <span class="hljs-number"><span class="hljs-number">73115928</span></span></code> </pre> <br><p>  And now let's try to ask the ScalaCheck for the impossible: </p><br><pre> <code class="hljs pgsql">val p2 = Prop.<span class="hljs-keyword"><span class="hljs-keyword">exists</span></span>(posNum[<span class="hljs-type"><span class="hljs-type">Int</span></span>]) { x: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; (x % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br><p>  As soon as ScalaCheck finds the first element suiting us, it will report that the property is <em>proved</em> (proved), and not <em>tested</em> (passed). </p><br><pre> <code class="hljs pgsql">scala&gt; p2.<span class="hljs-keyword"><span class="hljs-keyword">check</span></span> ! Gave up <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> passed tests. <span class="hljs-number"><span class="hljs-number">501</span></span> tests were discarded.</code> </pre> <br><p>  Having <code>Prop.exists</code> definitely solves someone‚Äôs problems.  In my practice, this property was not used. </p><br><h2 id="imenovanie-svoystv">  Property naming </h2><br><p>  Naming is good practice for both generators and properties.  When naming properties, the same operators are used as for generators: a string or a symbol can be used as the property name.  Used operators <code>:|</code>  and <code>|:</code> </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">//  |: ,     . 'linked |: isLinkedProp //  :| ,     . isComplete :| "is complete property</span></span></code> </pre> <br><h1 id="logicheskie-operatory">  Logical operators </h1><br><p>  Properties are logical expressions.  In ScalaCheck, you can use logical operators for properties.  Inside <code>Prop</code> , the operators <code>&amp;&amp;</code> and <code>||</code> declared.  whose behavior is exactly the same as the <code>Boolean</code> class operators of the same name.  In addition to the operators mentioned above, there are synonyms with symbolic names: <code>Prop.all</code> and <code>Prop.atLeastOne</code> . </p><br><p>  Using logical operators allows you to collect complex properties of the more simple.  Moreover, you can also combine instances of <code>Prop</code> and variables of a logical type in one expression: to do this, you need to explicitly add <code>Prop.propBoolean</code> , since this is one of those cases when the Scala compiler cannot automatically perform type conversion.  If you want to perform the conversion explicitly, you can do the following: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// January has April showers and... val prop = Prop.propBoolean(2 + 2 == 5)</span></span></code> </pre> <br><p>  So, let's take an example for the list and <code>reversed</code> method: </p><br><pre> <code class="hljs cmake">//    ,   reversed. def elementsAreReversed(<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>[Int], reversed: <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>[Int]): Boolean = //    ,    ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.isEmpty) <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val lastIdx = <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.size - <span class="hljs-number"><span class="hljs-number">1</span></span> // ...        //   . <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.zipWithIndex.forall { case (element, index) =&gt; element == reversed(lastIdx - index) } }</code> </pre> <br><p>  This method remarkably describes the main property of the <code>reversed</code> method and is quite sufficient.  However, our task now is not a clear statement of the property, but a demonstration of the ScalaCheck capabilities.  Therefore, we pull a couple of properties by the ears, which are implicitly expressed in the <code>elementsAreReversed</code> : </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasSameSize = reversed.size == list.size <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hasAllElements = list.forall(reversed.contains)</code> </pre> <br><p>  These properties are boolean values.  Adding a label (if there is a <code>propBoolean</code> in scope) will automatically convert our variables to the type <code>Prop</code> .  Now let's describe our first composite property <em>and at the same time use the labels</em> : </p><br><pre> <code class="hljs cmake">val propReversed = forAll { <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>[Int] =&gt; val reversed = <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.reverse <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.isEmpty) //  ,   Prop.propBoolean   (<span class="hljs-keyword"><span class="hljs-keyword">list</span></span> == reversed) :| <span class="hljs-string"><span class="hljs-string">"     "</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { val hasSameSize = reversed.size == <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.size val hasAllElements = <span class="hljs-keyword"><span class="hljs-keyword">list</span></span>.forall(reversed.contains) hasSameSize :| <span class="hljs-string"><span class="hljs-string">"  "</span></span> &amp;&amp; hasAllElements :| <span class="hljs-string"><span class="hljs-string">"    "</span></span> &amp;&amp; (<span class="hljs-string"><span class="hljs-string">"    "</span></span> |: elementsAreReversed(<span class="hljs-keyword"><span class="hljs-keyword">list</span></span>, reversed)) } }</code> </pre> <br><h1 id="kogda-poluchili-ne-to-chto-hoteli">  When they got not what they wanted </h1><br><p>  In case of an error, would you like to see which of the values ‚Äã‚Äãwe have, and which of them we expected?  ScalaCheck gives you this opportunity: you just need to replace the trivial equality <code>==</code> with operators <code>?=</code> Or <code>=?</code>  .  As soon as you do this, ScalaCheck will remember both parts of the expression when executing this property, and in case the property turns out to be incorrect, you will be presented with both values: </p><br><pre> <code class="hljs vhdl">! Falsified <span class="hljs-keyword"><span class="hljs-keyword">after</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> passed tests. &gt; Labels <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> failing <span class="hljs-keyword"><span class="hljs-keyword">property</span></span>: Expected <span class="hljs-number"><span class="hljs-number">4</span></span> but got <span class="hljs-number"><span class="hljs-number">5</span></span> &gt; ARG_0: <span class="hljs-string"><span class="hljs-string">"</span></span></code> </pre> <br><p>  In order to use the operators <code>?=</code> And <code>=?</code>  , you need to add <code>Prop.AnyOperators</code> to the scope: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalacheck.Prop.{AnyOperators, forAll} val propConcat = forAll { <span class="hljs-attr"><span class="hljs-attr">s</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">String</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> =? <span class="hljs-number"><span class="hljs-number">5</span></span> }</code> </pre> <br><p>  <em>Actual</em> , is the value closer to the sign <code>?</code>  <em>Expected</em> to be the value closest to the equal sign. </p><br><p>  You can also integrate with ScalaTest and use the matchers that come with it to get readable error messages.  More on this will be discussed in the section "Integration and Settings". </p><br><h1 id="sobiraem-statistiku">  We collect statistics </h1><br><h2 id="classify">  classify </h2><br><p>  Even if all your tests are performed successfully and everything is fine, you may want to get the information that was used during the tests.  For example, if you have non-trivial preconditions for a method, and you definitely want to know how hard ScalaCheck selects input data.  So if you need statistics, <code>Prop.classify</code> at your service: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalacheck.Prop.{forAll, classify} val classifiedProperty = forAll { n: <span class="hljs-type"><span class="hljs-type">Double</span></span> =&gt; // classify     , //     . classify(n &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, "negative", "positive") { classify(n % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>, "even", "odd") { n == n } } }</code> </pre> <br><p>  You can add as many classifiers as you see fit, ScalaCheck will merge them together and present them in the form of distribution: </p><br><pre> <code class="hljs haskell">+ <span class="hljs-type"><span class="hljs-type">OK</span></span>, passed <span class="hljs-number"><span class="hljs-number">100</span></span> tests. &gt; <span class="hljs-type"><span class="hljs-type">Collected</span></span> test <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">: 33% odd, negative 31% even, negative 18% odd, positive 18% even, positive</span></span></code> </pre> <br><h2 id="collect">  collect </h2><br><p>  In addition to <code>classify</code> there is a more generalized method for collecting and statistics: the <code>Prop.collect</code> method collects any statistics you are interested in and groups it under the name that is most convenient for you: </p><br><pre> <code class="hljs lisp">collect(<span class="hljs-name"><span class="hljs-name">label</span></span>)(<span class="hljs-name"><span class="hljs-name">boolean</span></span> || prop)</code> </pre> <br><p>  By the way, the name can be of any type: <code>toString</code> will be called automatically.  Consider the simplest example: </p><br><pre> <code class="hljs pgsql">val moreLessAndZero = Prop.forAll { n: <span class="hljs-type"><span class="hljs-type">Int</span></span> =&gt; val label = { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-number"><span class="hljs-number">0</span></span> //   ,   toString. <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) "&gt; 0" <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> "&lt; 0" } collect(label)(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) //    . }</code> </pre> <br><p>  After calling the <code>check</code> method, we have: </p><br><pre> <code class="hljs haskell">+ <span class="hljs-type"><span class="hljs-type">OK</span></span>, passed <span class="hljs-number"><span class="hljs-number">100</span></span> tests. &gt; <span class="hljs-type"><span class="hljs-type">Collected</span></span> test <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">: 46% &lt; 0 45% &gt; 0 9% 0</span></span></code> </pre> <br><h1 id="etalonnaya-realizaciya">  Reference implementation </h1><br><p>  So imagine, you are writing the next list implementation.  Your implementation is definitely better than the others (at least the author is counting on it).  And now it's time to test your list. </p><br><blockquote>  There may be many reasons that can lead to the realization that <br>  what is already available in the standard library, and this is not necessarily a thirst for knowledge <br>  or self-development. </blockquote><p>  It would be very cool to test your list in some way using, for example, the class <code>ConcurrentHashMap</code> already implemented in JDK.  And you can do this: instead of creating a specification that contains a set of strict conditions and contracts, you can specify the specification implicitly, using the already known working implementation ( <a href="http://reference-implementation-ru/">reference</a> ).  This approach is widely used in testing.  In English-language sources, you can find it called <a href="http://reference-implementation-en/"><em>reference implementation</em></a> . </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalacheck.Prop.AnyOperators <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalacheck.Properties // ,        //     . def listsGen: Gen[(List, MyList)] = ??? <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> MyListSpec extends Propertes("My Awesome List") { property("size") = Prop.forAll(listsGen) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (list, myList) =&gt; list.size =? myList.size } property("is empty") = Prop.forAll(listsGen) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (list, myList) =&gt; list.isEmpty =? myList.isEmpty } }</code> </pre> <br><h1 id="simmetrichnye-svoystva">  Symmetric properties </h1><br><p>  Also referred to as <em>round-trip properties</em> .  It's easier not to think: we take a certain <em>reversible</em> function and apply it twice, thus testing it for reversibility: </p><br><pre> <code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">neg</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">Long</span></span>) = -a <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> negatedNegation = forAll { n: <span class="hljs-type"><span class="hljs-type">Long</span></span> =&gt; neg(neg(n)) == n }</code> </pre> <br><p>  This property does not fully describe the <code>neg</code> method, nor does it speak of its functionality.  However, it speaks of its reversibility. </p><br><p>  Perhaps this example, like the notorious <code>List.reverse</code> , which you can find in any of the ten tutorials, will seem primitive to you.  However, there are more complex systems for which this approach is applicable: parsers and coders of all sorts and colors.  For example, when using symmetric properties for testing parsers, you may find errors in very hard-to-reach places. </p><br><p>  The method below parses the text and creates an abstract syntax tree (AST) based on it, and the <code>prettyPrint</code> method converts this tree back into text: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ , -    , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ AST    . sealed trait AST = ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . def parse(s: String): AST = ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,   . val astGen: Gen[AST] = ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,  AST  .   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      : /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ScalaCheck    . def pretty(ast: AST): String = ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . val prop = forAll(astGen) { ast =&gt; parse(pretty(ast)) == ast }</span></span></code> </pre> <br><h1 id="v-zaklyuchenie">  Finally </h1><br><p>  In most ScalaCheck tutorials, you will immediately be introduced to properties and their contrived classification, and then they will tell you about the difficulty of isolating properties from already written code.  In part, this is true: without a proper workout, it is rather difficult to isolate properties that can be tested. </p><br><p>  However, in its humble experience of using ScalaCheck, the most difficult is still the compilation of generators.  This process requires more effort than writing properties: writing one property may require writing a dozen or so generators.  That is why I started the story with generators, which may have seemed strange to many. </p><br><p>  In the next section we will talk about minimization ( <em>shrinking</em> ), which is one of the strengths of property-oriented testing.  Hope you were interested.  Soon there will be the next article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/323038/">https://habr.com/ru/post/323038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323020/index.html">Trends and prospects for the mobile application market: let's talk about money</a></li>
<li><a href="../323026/index.html">MTH: hurry to share our achievements</a></li>
<li><a href="../323030/index.html">Pattern Recognition and Scientific Knowledge</a></li>
<li><a href="../323034/index.html">Poetic discourse with a taste of reverse engineering</a></li>
<li><a href="../323036/index.html">Making your own log (archive) of alarms in Citect</a></li>
<li><a href="../323040/index.html">JPoint 2017 Java Conference: Moscow, April 7-8 - Review reports</a></li>
<li><a href="../323042/index.html">Zabbix 3.X: monitoring Adaptec controllers on Windows Server (Hyper-V Core)</a></li>
<li><a href="../323044/index.html">How we reconstructed the courthouse in Smolensk: from laser scans of stucco molding under mold to release</a></li>
<li><a href="../323046/index.html">SharePoint 2013/2016 database maintenance</a></li>
<li><a href="../323048/index.html">1,500,000 installations in 3 months - Tap Tap Builder development history</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>