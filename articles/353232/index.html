<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Generation of site pages by means of service workers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="( C ) 

 From this article, you will learn how to create a page with a list of previously cached site materials right on your mobile device, in your b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Generation of site pages by means of service workers</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ha/th/pe/hathpepjsrk8_vzjexknojcs5_u.png"><br>  ( <a href="http://maximdenisov.ru/">C</a> ) <br><br>  From this article, you will learn how to create a page with a list of previously cached site materials right on your mobile device, in your browser, so that the conditional user stuck in the elevator will not get bored without the Internet.  As we approach the goal, we will touch on the following topics: <br><br><ul><li>  caching site pages for offline access; </li><li>  keeping records of offline pages, forwarding necessary data; </li><li>  monitoring network status, online or offline; </li><li>  communication service worker with the pages and tabs that he serves; </li><li> interception by the service worker of the request to open the address <code>/offline/</code> and generate a new page directly on the device, without a request to the server. </li></ul><br>  If the topic of <a href="https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API">service workers</a> and <a href="https://en.wikipedia.org/wiki/Progressive_Web_Apps">Progressive Web Apps</a> (PWA) is new for you, then you should get to know them better before reading this article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      My name is Pavel Rybin, I work in the front-end development of Mail.Ru Group Media projects.  This guide helped me write rakes, stuffed cones and pitfalls that I came across when implementing PWA for the mobile version of <a href="https://auto.mail.ru/">Auto Mail.Ru.</a> <br><br>  In the text there will be small code examples illustrating the story.  An enhanced demo version can be <a href="https://github.com/drfisher/sw-custom-page-demo">viewed on GitHub</a> . <br><a name="habracut"></a><br><h2>  Connecting a service worker </h2><br>  A service worker serving the entire site should be located at the root.  For example, have the address <code>/service-worker.js</code> .  In our case, this is required.  If you give a service worker file from the <code>/js/</code> directory, for example <code>/js/service-worker.js</code> , then it will be able to process only those network requests that start with <code>/js/</code> ... <br><br>  We connect a service worker from our website: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// app.js -     //      service worker if ('serviceWorker' in navigator) { window.addEventListener('load', registerServiceWorker); } function registerServiceWorker () { //     ,   //       navigator.serviceWorker.register('/service-worker.js') .then(registration =&gt; { if (!registration.active) { //    return; } // - ,    . //        . }); }</span></span></code> </pre><br>  In our example, the service worker's initialization code should contain a complete list of resources needed to correctly render the future page <code>/offline/</code> , all styles, images, etc. We pre- <a href="https://developer.mozilla.org/ru/docs/Web/API/Cache">cache them</a> with the <code>install</code> event, the first one in the chain of life cycle events. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// service-worker.js // ,    const dependencies = [ '/css/app.css', '/js/offline_page.js', '/img/logo.png', '/img/default_thumb.png' ]; //  , -    self.addEventListener('install', event =&gt; { //   ,    offline- const loadDependencies = self.caches.open('myApp') .then(cache =&gt; cache.addAll(dependencies)); // -      , //         event.waitUntil(loadDependencies); });</span></span></code> </pre><br>  Next <code>activate</code> event.  It is useful to us in order to clear the old cache and records in the database.  In our example, a simple <a href="https://github.com/jakearchibald/idb-keyval">idb-keyval</a> helper is used to work with <a href="https://github.com/jakearchibald/idb-keyval">IndexedDB</a> .  He and his more advanced <a href="https://github.com/jakearchibald/idb">idb</a> brother are convenient wrappers that allow to work with the morally outdated <a href="https://developer.mozilla.org/ru/docs/IndexedDB">API IndexedDB</a> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// service-worker.js import { clear } from 'idb-keyval'; // ,    const dependencies = [/* ... */]; //  self.addEventListener('activate', event =&gt; { //    IndexedDB const promiseClearIDB = clear(); //    const promiseClearCache = self.caches.open(cacheName) .then((cache) =&gt; cache.keys() .then((cacheKeys) =&gt; Promise.all(cacheKeys.map((request) =&gt; { //  ,     , //    const canDelete = !dependencies.includes(request.url); return canDelete ? cache.delete(request, {ignoreVary: true}) : Promise.resolve(); })))); const promiseClearAll = Promise.all([promiseClearIDB, promiseClearCache]) .catch(err =&gt; console.error(error)); //   - , //      IndexedDB event.waitUntil(promiseClearAll); });</span></span></code> </pre><br>  After activation, the service worker is ready to go.  It will be able to process network requests and receive messages from all pages of our site that were opened <b>after</b> its activation.  Just add the appropriate event handlers.  This is where we will catch the page request <code>/offline/</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// service-worker.js //     self.addEventListener('fetch', event =&gt; { const { request } = event; const url = new URL(request.url); if (url.origin !== self.location.origin) { //  ,     return fetch(request).catch(err =&gt; console.log(err)); } // ,     /offline/ const isOfflineListRequested = /^\/offline\//.test(url.pathname); const response = isOfflineListRequested //   response   //  ,   ? createOfflineListResponse() //   . //         //   , -  " ", // -     .. : fetchWithOneOrAnotherCacheStrategy(event.request); event.respondWith(response); });</span></span></code> </pre><br>  <b>What are ‚Äúcaching strategies‚Äù and why are they needed?</b> <br><br>  The resources we download play a different role on the page.  This could be a logo image or some kind of shared JS library, which most likely will never change.  This can be JSON with comments that are updated every five minutes. <br><br>  Files and documents involved in the construction of the page, in its life cycle, depending on the purpose can be divided into groups: <br><br><ul><li>  can be cached "forever"; </li><li>  cannot be cached for long; </li><li>  can be cached, but update when appropriate; </li><li>  and so on, limit this list only to your imagination and business objectives. </li></ul><br>  If you implement filtering of such groups by address, file type, anything, then you can apply your own logic for the mutual operation of network requests and the local cache to each of them.  You can <a href="">see</a> several examples of different caching strategies <a href="">in the sample repository</a> . <br><br>  Now we have already implemented support for offline mode for cached pages.  They will open when activated in the phone mode "in the plane."  Now you need to collect them all in one place, on a separate page. <br><br><h2>  Offline registration of pages </h2><br>  To draw a page of the list of materials available for viewing offline, you must first create this list, and then, each time you open a new page, update it.  The logic for registering pages will be as follows: <br><br><ul><li>  When you open the page, we will form a data object that describes this page (address, title, preview address for output in the list). </li><li>  After generating the data, send it to the service worker via <code>postMessage</code> . </li><li>  The service worker will receive the data and add it to the general list. </li></ul><br>  The script that collects data about the page will be executed on it, being part of the page.  So comfortable.  This will allow to forward necessary information, for example, through the <code>head</code> block and receive it from the layout.  Or in any other suitable way for you. <br><br>  Let's use <a href="http://ogp.me/">Open Graph microdata</a> .  Today it is difficult to imagine a site without it.  In addition, it can be used to transfer all the necessary information in our case: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">property</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"og:title"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Homer Simpson"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">property</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"og:url"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://example.com/homer.html"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">meta</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">property</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"og:image"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://example.com/homer.png"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  <b>Why transfer the page address through layout?</b>  <b>Why not get it in JS through the location object?</b> <br><br>  Today, most sites use for analytics all sorts of get-parameters, marking, for example, the source of traffic.  The result is that the addresses <code>/homer.html</code> , <code>/homer.html?utm_source=vk</code> and <code>/homer.html?utm_source=email</code> actually lead to the same page, which means they must be registered in the list once.  Here the ‚Äúcanonical‚Äù address transmitted via <code>og:url</code> will help us, it will always be the same.  Most likely you already have all the necessary og-markup, you can check its completeness with the help of <a href="https://chrome.google.com/webstore/detail/open-graph-preview/ehaigphokkgebnmdiicabhjhddkaekgh">Google Chrome extension</a> . <br><br>  So, let's teach the page to tell the service worker that it is loaded.  We will finalize the <code>registerServiceWorker</code> function (see above). <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// app.js -     function registerServiceWorker () { navigator.serviceWorker.register('/service-worker.js') .then(registration =&gt; { if (!registration.active) { //    return; } // - ,     // ,       registerPageAsCached(); }); } /** *    ,    */ function registerPageAsCached () { //  getPageInfoFromHtml    , // ,       : // url - ""   // title -   // thumb -    const page = getPageInfoFromHtml(); //   - postMessage({ action: 'registerPage', page }); } /** *    service worker * @param {object} message */ function postMessage (message) { const {controller} = navigator.serviceWorker; if (controller) { controller.postMessage(message); } }</span></span></code> </pre><br>  Note: in the message, in addition to the page data, we pass an <code>action</code> field describing the type of the message.  This will allow us in the future to transmit different data for different purposes. <br><br>  Someone will ask, how do we know that the page is cached? <br><br>  All requests from our site go through one of the caching strategies that we entered into the work earlier, which means we accept that everything displayed in the browser passed through the cache. <br><br>  Get data from the page in the service worker: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// service-worker.js import {get, set} from 'idb-keyval'; /* *     */ self.addEventListener('message', event =&gt; { const {data = {}} = event; const {page} = data; //    , // ,  action switch (data.action) { case 'registerPage': addToOfflineList(page); break; } }); /** *  ,    * @param {object} pageInfo * @return {Promise} */ export function addToOfflineList (pageInfo) { //   ,   , //    offline  if (pageInfo.thumb) { fetchWithOneOrAnotherCacheStrategy(pageInfo.thumb); } //      IndexedDB return get('cachedPages') .then((pages = {}) =&gt; set('cachedPages', { ...pages, [pageInfo.url]: pageInfo })); }</span></span></code> </pre><br>  Page registered. <br><br>  In this example, we used the page title, address, and image for the page description, but the list of data can be expanded.  For example, it makes sense to specify the timestamp of the last update.  This will allow you to sort articles by download date, as well as remove old materials from the cache. <br><br><h2>  Monitoring network connectivity status </h2><br>  While the page is open, we will teach it to monitor the status of the network, or rather, the availability of our server.  When the server stops responding, a corresponding message appears with a link to <code>/offline/</code> , which we will do later.  Also, for convenience, we will highlight the available links directly on the page. <br><br>  You can make inaccessible materials dull by visually highlighting cached ones: <br><br><img src="https://habrastorage.org/webt/rv/p7/vq/rvp7vqt11gmx0cx-owudwluamyw.gif" width="375" height="666"><br><br>  And on the contrary, it is possible to select articles stored in the cache with a special icon, as was done on <a href="https://auto.mail.ru/">Auto Mail.Ru</a> : <br><br><img src="https://habrastorage.org/webt/-2/rr/82/-2rr821h-73wg-zitbwwdh-c7wi.png" width="385" height="677"><br><br>  In the script that runs on the page, we will create a <code>ping</code> function that will periodically be called at a specified interval and send a message to the service worker. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// app.js -     const PING_INTERVAL = 10000; // 10  function registerServiceWorker () { navigator.serviceWorker.register('/service-worker.js') .then(registration =&gt; { if (!registration.active) { //    return; } // - ,     registerPageAsCached(); // .  //   ping(); }); } /** *     ( ) */ function ping() { postMessage({ action: 'ping', }); setTimeout(ping, PING_INTERVAL); } /** *    service worker * @param {object} message */ function postMessage (message) { const {controller} = navigator.serviceWorker; if (controller) { controller.postMessage(message); } }</span></span></code> </pre><br>  On the side of the service worker, we will receive a message, check the server availability and send back a report.  For verification, you can request any URL, it is better if it will be some kind of static, for example, a traditional pixel. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// service-worker.js import {get} from 'idb-keyval'; /* *     */ self.addEventListener('message', event =&gt; { const {data = {}} = event; const {page} = data; //    , // ,  action switch (data.action) { case 'ping': ping(); break; } }); /** *    */ export function ping () { fetch('/ping.gif').then( () =&gt; pingHandler(true), () =&gt; pingHandler(false) ); } /** *       *      * @param {boolean} isOnline */ function pingHandler (isOnline) { postMessage({ action: 'ping', online: isOnline, }); } /** *       , *  - * @param {object} message */ function postMessage (message) { //         self.clients.matchAll().then(clients =&gt; { //       //    const offlinePagesPromise = message.online ? Promise.resolve() : get('cachedPages'); offlinePagesPromise.then(offlinePages =&gt; { if (offlinePages) { message.offlinePages = offlinePages; } clients.forEach(client =&gt; { //   ,   if (client) { client.postMessage(message); } }); }); }); }</span></span></code> </pre><br>  In the browser, several tabs with our site can be opened at once.  Each will call its own <code>ping</code> method.  Therefore, it is better not to load a pixel from the page, but through a service worker who can control the frequency of network check requests, for example, through the <a href="https://habrahabr.ru/post/60957/">throttle micro pattern</a> .  Also, the knowledge of the status can be useful to the service worker himself. <br><br>  The page, having received the report, performs the necessary manipulations with its contents: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// app.js -     let isOnline = true; function registerServiceWorker () { navigator.serviceWorker.register('/service-worker.js') .then(registration =&gt; { if (!registration.active) { //    return; } //     - serviceWorker.addEventListener('message', handleMessage); registerPageAsCached(); // .  ping(); // .  }); } /** *    service worker- * @param {MessageEvent} e */ function handleMessage (e) { const {data} = e; if (data.action === 'ping' &amp;&amp; isOnline !== data.online) { isOnline = data.online; toggleNetworkState(data); } } /** *   /  * @param {object} params */ function toggleNetworkState (params) { const {online, offlinePages = {}} = params; //   , //        "" document.body.classList.toggle('offline', !online); //       if (!online) { Array.from(document.links).forEach(link =&gt; { const href = link.getAttribute('href'); const isCached = !!offlinePages[href] || href === '/offline/'; link.classList.toggle('cached', isCached); }); } }</span></span></code> </pre><br><h2>  Creating a page / offline / service worker </h2><br>  So, we got to the main, to create a page inside the service worker without contacting the server.  We will need a template that draws HTML, and data about cached pages. <br><br>  I used a simple <a href="https://pugjs.org/api/getting-started.html">pug</a> template engine in the <a href="https://github.com/drfisher/sw-custom-page-demo">demo version</a> .  However, you can use any other one up to the ‚Äúserver renderer‚Äù for an isomorphic React application. <br><br>  My template looks like this: <br><br><pre> <code class="hljs pgsql">html(lang="en") head title Available offline link(rel="stylesheet" href="/css/app.css") body section.layout <span class="hljs-keyword"><span class="hljs-keyword">header</span></span>.layout__header a.layout__header__logo(href="/") h1 You can <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> it offline ul.articles-list <span class="hljs-keyword"><span class="hljs-keyword">each</span></span> page <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> pages li.articles-list__item a(href=page.url) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> page.thumb img.avatar(src=page.thumb alt="") <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> img.avatar(src="/img/default_thumb.png" alt="") span=page.title</code> </pre><br>  In the service worker, in the <code>fetch</code> event handler, select the request to <code>/offline/</code> and return the newly created page to the unsuspecting browser: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// service-worker.js import {get} from 'idb-keyval'; const template = require('offlinePage.pug'); //     self.addEventListener('fetch', event =&gt; { const { request } = event; const url = new URL(request.url); if (url.origin !== self.location.origin) { //  ,     return fetch(request).catch(err =&gt; console.log(err)); } // ,     /offline/ const isOfflineListRequested = /^\/offline\//.test(url.pathname); const response = isOfflineListRequested //  ! //   response   //  ,   ? createOfflineListResponse() //   : fetchWithOneOrAnotherCacheStrategy(event.request); event.respondWith(response); }); /** *   response    , *   * @return {Promise&lt;Response&gt;} */ function createOfflineListResponse () { //      return get('cachedPages') .then((pagesList = {}) =&gt; { //       const html = template({ pages: Object.values(pagesList) }); //      const blob = new Blob([html], { type: 'text/html; charset=utf-8' }); return new Response(blob, { status: 200, statusText: 'OK' }); }).catch(err =&gt; console.error(err)); }</span></span></code> </pre><br>  Result: <br><br><img src="https://habrastorage.org/webt/2h/d6/tr/2hd6trzx_kwgfld-cjbyb0tkvaw.jpeg" width="385" height="616"><br><br><h2>  At last </h2><br>  In order not to inflate this manual, some topics had to be omitted.  However, they are extremely important.  The most important is clearing the cache.  This should be done regularly and independently, otherwise the space provided by the browser will end. <br><br>  It makes sense to keep the resources that are required regularly in the cache: CSS, JS, images of interface elements.  For the rest, you should come up with some "rule of swelling."  For example, delete everything that was not requested for more than three (five, ten, year?) Days. <br><br>  For easier debugging, detailed logging of each of the steps is useful.  To do this, you can create your own utility <code>log</code> , which inside is able to turn on / off the flag from the environment, and display information through it.  Unlike the pages, the service worker continues to live between their reloads and closing, so I recommend turning on the <code>Preserve log</code> checkbox in the developer‚Äôs tools console. <br><br>  Thank you for reading this line.  Write questions, ideas and insights from personal experience in the comments.  If it turns out that the topic is in demand (I have fears that it is too narrow), I will continue it. <br><br><h3>  useful links </h3><br><ul><li>  <a href="https://github.com/drfisher/sw-custom-page-demo">Demo version of the tutorial on GitHub</a> </li><li>  <a href="https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API">Service Worker API</a> </li><li>  <a href="https://developer.mozilla.org/ru/docs/Web/API/Cache">Cache</a> </li><li>  <a href="https://developer.mozilla.org/ru/docs/IndexedDB">IndexedDB</a> </li><li>  Utilities for working with IndexedDB: <a href="https://github.com/jakearchibald/idb">idb</a> and <a href="https://github.com/jakearchibald/idb-keyval">idb-keyval</a> </li><li>  <a href="https://chrome.google.com/webstore/detail/open-graph-preview/ehaigphokkgebnmdiicabhjhddkaekgh">Expansion</a> for checking open graph markup </li><li>  <a href="https://habrahabr.ru/post/60957/">JS Optimization Micropatters</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/353232/">https://habr.com/ru/post/353232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353218/index.html">Online Hackathon: creating apps for SharePoint Online</a></li>
<li><a href="../353220/index.html">Ethical hacking: how to make money, not problems with the law</a></li>
<li><a href="../353226/index.html">Fourth: Redmadrobot developers winter internship</a></li>
<li><a href="../353228/index.html">Startup day (January-March 2018)</a></li>
<li><a href="../353230/index.html">From JavaScript to Rust and back: the story about wasm-bindgen</a></li>
<li><a href="../353234/index.html">Flask Mega-Tutorial, Part XIX: Deploying Based on Docker Containers</a></li>
<li><a href="../353236/index.html">The history of gaming analytics platforms</a></li>
<li><a href="../353238/index.html">Docker. Start</a></li>
<li><a href="../353246/index.html">We invite you to a lecture evening on game design on April 18th at VSBI</a></li>
<li><a href="../353248/index.html">Reachability of the lower limit of the execution time of a commit distributed fault-tolerant transactions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>