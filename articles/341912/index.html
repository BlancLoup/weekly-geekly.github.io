<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PHP OPCache is to blame?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I started my career as a developer, I was very surprised to read the phrase attributed to Phil Carlton: ‚ÄúThere are only two difficulties in compu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PHP OPCache is to blame?</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/nm/fl/2n/nmfl2nmh9rnc2whse6ddpblof38.jpeg"></p><br><p>  When I started my career as a developer, I was very surprised to read the phrase attributed to Phil Carlton: <em>‚ÄúThere are only two difficulties in computer science: <strong>cache invalidation</strong> and <strong>naming</strong></em> . <em>‚Äù</em>  I was incredulous of this because I did not understand the essence of the phrase.  But a little later, I began to understand. </p><br><p>  I want to talk about the problem that we encountered not so long ago in our production-infrastructure.  Immediately after successful deployment, when updating pages modified by a new release, for a while the new code was not displayed.  In fact, this is not uncommon for web applications written in PHP.  We faced the same before, and after the transition to a new production-environment, the problem became more noticeable.  Therefore, we decided to investigate. </p><a name="habracut"></a><br><h2 id="nasha-procedura-deploya">  Our Deploy Procedure </h2><br><p>  Our technology is mostly written in <strong>PHP</strong> , and also uses the <strong>symfony</strong> and <strong>Zend</strong> frameworks.  To send the code in production, we use the internal project <strong>shark-do</strong> , its author is the leader of the <a href="https://luca.bo/">Luca</a> team. </p><br><p>  Shark-do philosophy </p><br><blockquote>  "If you can do this, then you can do it in bash." </blockquote><p>  The project is a bash script that can identify a task and execute it according to an algorithm.  Each project has its own algorithm for managing different stages, for example, deleting unnecessary files, generating configuration files, etc. </p><br><p> For example, more than five times a day, I use the <code>shark-do deploy collaboratori</code> command to launch deployment tasks for the collaboratori project I'm working on.  Typically, the deployment consists of the following steps: </p><br><ol><li>  The last commit is extracted from the master branch. </li><li>  Folders are configured, unnecessary files are deleted, release creation begins. </li><li>  Parameters are set, installation of the linker is launched, resources are downloaded and added. </li><li>  A release archive is created, then it is moved to the bastion machine and unpacked. </li><li>  To launch a rollback release using the REST API of our infrastructure, the Ansible procedure is called. </li><li>  The system switches to the new release, the old releases are cleared and removed from the bastion vehicle. </li><li>  The new release is marked in New Relic, and in our Slack-channel there is a notification about the end of the deployment task. </li></ol><br><p>  Consider the fifth step.  <a href="http://docs.ansible.com/ansible/latest/playbooks.html">Ansible script</a> responds: </p><br><ul><li>  for copying a new release from the <a href="https://ru.wikipedia.org/wiki/Bastion_host">host bastion</a> to all target machines (front end, batch, etc.); </li><li>  for setting all folders and permissions; </li><li>  for warming up the cache and switching the release. </li></ul><br><p>  Each deployment procedure consists of many necessary operations, but the turning point is a change in the current project folder: this is done using the symlink transfer from the previous release folder to the new one.  The current project folder is the root location of the documents for a specific web application. </p><br><p>  For example: </p><br><pre> <code class="hljs coffeescript">ln -sf <span class="hljs-regexp"><span class="hljs-regexp">/var/www/</span></span>{APP_NAME}<span class="hljs-regexp"><span class="hljs-regexp">/releases/</span></span>@YYYYMMDDHHIISS <span class="hljs-regexp"><span class="hljs-regexp">/var/www/</span></span>{APP_NAME}/current</code> </pre> <br><p>  The option <code>-s</code> used to create a symbolic link, and <code>-f</code> - to force the creation of such a link, if the target object already exists.  <code>{APP_NAME}</code> - the name of the project. </p><br><p>  We use the standard PHP deployment strategy.  The releases of one application are stored on production servers, and the current version is accessed by a symbolic link.  This allows you to deploy <strong>atomic and secure</strong> , without affecting the working traffic. </p><br><p>  Finally, behind the carousel (round-robin) policy we have 15 front-end servers (more than two times more than before).  Question: what happens after the release switch? </p><br><h2 id="vo-vsyom-vinovat-php-opcache-">  PHP OPCache (?) Is to blame </h2><br><p>  Some reservations: we will not delve into the flow of PHP scripts, and discuss the main things to make it easier for you to understand my reasoning about the problem.  We will also consider only PHP 7. </p><br><p>  Sometimes it is useful to remember how PHP code is executed.  When you run the script, our source code goes through four phases: </p><br><p><img src="https://habrastorage.org/webt/no/uf/eu/noufeuzy6lmjsfewdeovfdghon8.png"></p><br><p>  The first phase is controlled by the <strong>PHP lexical analyzer</strong> .  It is responsible for matching the keywords of a language like <code>function</code> , <code>return</code> and <code>static</code> with individual parts, which are usually called <em>tokens</em> .  Each token is often complemented by the metadata needed for the next phase. </p><br><p>  The second phase is controlled <strong>by the PHP parser</strong> .  He is responsible for analyzing one or more tokens, as well as for comparing them with patterns of language structures.  For example, <code>$foo + 5</code> recognized as a binary "addition" operation, and the variable <code>$foo</code> and the number <code>5</code> recognized as operands.  The parser recursively builds an <a href="https://wiki.php.net/rfc/abstract_syntax_tree">abstract syntax tree (AST)</a> .  Usually the operation of the lexical analyzer and parser is considered one task. </p><br><p>  The third phase is <strong>compiling</strong> .  AST is converted to an ordered sequence of opcode instructions.  Each opcode can be considered a low-level operation of the <strong>Zend virtual machine</strong> .  A full list of supported opcodes can be found <a href="">here</a> . </p><br><p>  Finally, the last phase is <strong>execution</strong> .  Zend VM performs every task described in opcodes and generates a result. </p><br><p>  The first three phases (lexical analyzer, parser and compiler) are combined into a ‚Äúpipeline‚Äù.  And the third phase takes much more time and consumes more resources (memory and processor).  To reduce the weight of the compilation phase, in PHP 5.5 they introduced <a href="http://php.net/manual/en/book.opcache.php">the Zend OPCache extension</a> .  It caches the compile-phase output (opcodes) in shared memory (shm, mmap, etc.), so that each PHP script is compiled only once, and different queries can be executed without a compile phase.  If in an environment not intended for development, the code rarely changes, then the execution speed of PHP increases at least twice. </p><br><p>  The OPCache extension is also responsible for optimizing opcodes, but this is already beyond the scope of the article. </p><br><p>  In connection with the foregoing, it is logical to assume that OPCache is to blame for the strange behavior that we encountered in our production-environment.  To test this assumption, I made a simple demo environment from the Docker container, PHP 7.0 and Apache 2.4.  The full code can be downloaded <a href="https://github.com/salvatorecordiano/facile-it-realpath_cache">from here</a> . </p><br><p>  To simplify the work, I wrote several scripts: </p><br><ul><li>  <code>start.sh</code> launches the Docker container in the correct configuration. </li><li>  <code>release-switcher.sh</code> every 10 seconds loads a symbolic link to the current release. </li><li>  <code>release-watcher.sh</code> sends an HTTP request every second, checking the current release served by Apache. </li></ul><br><p>  You can simply clone the GitHub repository, and everything is ready to check, if you already have Docker installed. </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">git</span></span> clone https://github.com/salvatorecordiano/facile-it-realpath_cache cd facile-it-realpath_cache docker pull salvatorecordiano/realpath_cache</code> </pre> <br><p>  To reproduce the problem with the cache, you need to run these commands in parallel in three different command lines: </p><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> the container <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> production <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span> ./<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>.sh production # <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> switching the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">release</span></span> ./<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>-switcher.sh # <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> watching the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> web <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> response ./<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>-watcher.sh</code> </pre> <br><p>  Result of performance: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/PNjyi42VwP4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Execution with production configuration.</em> </p><br><p>  The problem with the cache repeated: after switching the release, we do not see the correct code after executing the HTTP request. </p><br><p>  Now turn off OPCache and repeat the test. </p><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> the container <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> production <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> opcache disabled ./<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>.sh production-<span class="hljs-keyword"><span class="hljs-keyword">no</span></span>-opcache # <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> switching the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> <span class="hljs-keyword"><span class="hljs-keyword">release</span></span> ./<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>-switcher.sh # <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> watching the <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> web <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> response ./<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>-watcher.sh</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/WB78eE0kwUo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Execution with production-no-opcache configuration.</em> </p><br><p>  Surprisingly, the problem remained, so the assumption was wrong: <strong>OPCache was not at fault.</strong> </p><br><h2 id="realpath_cache-nastoyaschiy-vinovnik">  realpath_cache: the real culprit </h2><br><p>  Perhaps, when using the <code>include/require</code> function or PHP autoload, you need to remember about <strong>realpath_cache</strong> .  The real path cache allows <strong>you</strong> to <strong>cache path permissions for files and folders</strong> in order to spend less time searching the disk and improve performance.  This is very useful when working with many third-party libraries or frameworks like Symfony, Zend and Laravel, because they use a huge number of files. </p><br><p>  The caching mechanism appeared in PHP 5.1.0.  Today, this feature is not mentioned in official documents, except for the functions <code>realpath_cache_get()</code> , <code>realpath_cache_size()</code> , <code>clearstatcache()</code> and <code>php.ini</code> parameters <code>realpath_cache_size</code> and <code>realpath_cache_ttl</code> .  From external sources, I was able to find only the <a href="http://blog.jpauli.tech/2014/06/30/realpath-cache.html">old post</a> written by Julien Paulie in 2014.  Poly, a well-known PHP developer, explains how the path resolution mechanism works. </p><br><p>  When we access a file, PHP tries to resolve its path using <code>stat()</code> , the Unix system call: it returns the file attributes (permissions, extension, and other metadata) for the <strong>inode</strong> .  In the Unix world, an inode is a data structure used to describe a file system object, such as a file or directory.  PHP puts the result of a system call into a data structure called <code>realpath_cache_bucket</code> , with the exception of such things as permissions and owners.  So if you try to access the same file a second time, then when searching in a bucket in memory (bucket lookup), we will be saved from another slow system call.  If you want to learn more, check out the <a href="">PHP source code</a> . </p><br><p>  The <code>realpath_cache_get</code> function appeared in PHP 5.3.2.  It allows you to get an array consisting of the cache of real paths.  In each element of the array, the key is the resolved path, and the value is another array with data like <code>key</code> , <code>is_dir</code> , <code>realpath</code> , <code>expires</code> . </p><br><p>  Next comes the output <code>print_r(realpath_cache_get())</code> ;  in our test Docker environment: </p><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [key] =&gt; <span class="hljs-number"><span class="hljs-number">1438560323331296433</span></span> [is_dir] =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> [realpath] =&gt; /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html [expires] =&gt; <span class="hljs-number"><span class="hljs-number">1504549899</span></span> ) [/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [key] =&gt; <span class="hljs-number"><span class="hljs-number">1.5408950988325E+19</span></span> [is_dir] =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> [realpath] =&gt; /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www [expires] =&gt; <span class="hljs-number"><span class="hljs-number">1504549899</span></span> ) [/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [key] =&gt; <span class="hljs-number"><span class="hljs-number">1.6710127960665E+19</span></span> [is_dir] =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> [realpath] =&gt; /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> [expires] =&gt; <span class="hljs-number"><span class="hljs-number">1504549899</span></span> ) [/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/release1] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [key] =&gt; <span class="hljs-number"><span class="hljs-number">7631224517412515240</span></span> [is_dir] =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> [realpath] =&gt; /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/release1 [expires] =&gt; <span class="hljs-number"><span class="hljs-number">1504549899</span></span> ) [/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/current] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [key] =&gt; <span class="hljs-number"><span class="hljs-number">1.7062595747834E+19</span></span> [is_dir] =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> [realpath] =&gt; /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/release1 [expires] =&gt; <span class="hljs-number"><span class="hljs-number">1504549899</span></span> ) [/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/current/index.php] =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span> ( [key] =&gt; <span class="hljs-number"><span class="hljs-number">6899135167081162414</span></span> [is_dir] =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span> [realpath] =&gt; /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/release1/index.php [expires] =&gt; <span class="hljs-number"><span class="hljs-number">1504549899</span></span> ) )</code> </pre> <br><p>  Here: </p><br><ul><li>  <code>key</code> is a floating point number, it is a hash of the path. </li><li>  <code>is_dir</code> - boolean value, true if the allowed path is a directory;  otherwise, false. </li><li>  <code>realpath</code> is a <code>realpath</code> path, a string. </li><li>  <code>expires</code> is an integer, denotes the time, the path cache will be invalid.  This value is strictly associated with the <code>realpath_cache_ttl</code> parameter. </li></ul><br><p>  In the previous example, we had six paths, but all of them are related to the resolution of the path <code>/var/www/current/index.php</code> .  PHP created six cache keys to allow only one path.  So the path is divided into parts, each of which is alternately resolved.  In our case, the ‚Äúreal‚Äù path is <code>/var/www/html/release1/index.php</code> , because <code>/var/www/current</code> is a symbolic link to the <code>/var/www/html/release1</code> . </p><br><p>  The post by Julien Pauli also states: </p><br><blockquote>  "The cache of this path is tied to the process and does not fit into the common memory." </blockquote><p>  This means that the <strong>cache must expire for each process</strong> .  If we use <strong>PHP-FPM</strong> to clean the entire web server, then we will have to wait for the cache to become obsolete for each worker in the pool.  This helps to understand what happens during testing using the <code>production-no-opcache</code> .  Even if you disable OPCache after receiving a symbolic link, PHP will leisurely notify all processes of obsolescent paths. </p><br><p>  In our real production-environment, we had to take into account that we have 15 front-end servers on which many web applications are hosted.  On each server there is one PHP-FPM pool, each of which consists of 35 workers and one master process.  This explains why ‚Äústrange behavior‚Äù has become more noticeable in the new environment.  You can <strong>adjust the effect of the present path cache</strong> on our web application by using the parameters <code>realpath_cache_size</code> and <code>realpath_cache_ttl</code> : the first determines the size of the bucket that PHP will use.  This is an integer, and increasing it is useful for web applications that work with a huge number of files.  The second parameter <code>realpath_cache_ttl</code> , as already mentioned, is the duration of caching information about the real path (in seconds). </p><br><p>  Now everything is clear, you can re-enable OPCache and disable the cache of this path by adjusting its size and lifetime: </p><br><pre> <code class="hljs">realpath_cache_size=0k realpath_cache_ttl=-1</code> </pre> <br><p>  Run the test again: </p><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> the container <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> production <span class="hljs-keyword"><span class="hljs-keyword">configuration</span></span>, opcache enabled <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> realpath_cache disabled ./<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>.sh production-<span class="hljs-keyword"><span class="hljs-keyword">no</span></span>-realpath-<span class="hljs-keyword"><span class="hljs-keyword">cache</span></span> # start switching the current release ./release-switcher.sh # start watching the current web server response ./release-watcher.sh</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/Qry6cvUmf3c" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>Execution with the configuration production-no-realpath-cache.</em> </p><br><p>  I want to note that our latest configuration is <strong>strongly discouraged from being</strong> used in a production-based environment, because PHP is forced to allow each path encountered, which is bad for performance. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  I wanted to talk about solving a mysterious cache problem, learning about OPCache and the cache of the current path, as well as about their differences.  The script described at the beginning of the article was invented, but, for example, if the request starts with one version of the code, then tries to access other files during execution, and they were updated, moved or deleted in subsequent versions of the code, then real problems may arise.  In the worst case, it is necessary to ensure compatibility of two consecutive releases, but under the conditions described this is very difficult to achieve. </p><br><p>  It is necessary to implement <strong>an atomic deployment strategy</strong> (in the strict sense).  For example, you can use containers or a new isolated PHP-FPM memory pool for each deployed release.  In the latter case, you need to at least double the amount of memory so that you can keep more simultaneously running FPM-pools. </p><br><p>  You can also use an apache module called <code>mod_realdoc</code> to support atomic deployments.  It was written by Rasmus Lerdorf ( <strong>Rasmus Lerdorf</strong> ).  The trick is implemented in this module: at the beginning of the request, the real path is called via the symbolic link <code>DOCUMENT_ROOT</code> , while the absolute path for the entire request is set as the real document root.  Therefore, queries that begin before a symbolic link change will be executed in relation to the previous symbolic target object.  The main drawback of the module is that you need to use the <strong>Apache Multi-Processing Module (MPM).</strong>  This prefork implements a non-threaded server using forking based.  The server spawns new processes and keeps them to service requests.  This is the best MPM to isolate each request, so if there is a problem with one request, other requests will not be affected.  But when the server is under heavy load, MPM is more likely to hurt, because it uses one process per request, and as a result, there will not be enough resources for simultaneous requests, they will have to wait until the server process becomes free.  The same results as with <code>mod_realdoc</code> can be achieved at the PHP level in the front controller of the application, if you define the main root folder in <code>realpath(__FILE__)</code> . </p><br><p>  If before PHP you use <strong>nginx</strong> , then you are lucky!  To avoid updating symbolic links when executing queries, you need to force nginx to resolve symbolic links and assign them to <code>DOCUMENT_ROOT</code> .  It is enough to change a few lines of code in the server blocks: </p><br><pre> <code class="hljs mel"># <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> configuration fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT $document_root; # configuration with real path resolution fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT $realpath_root;</code> </pre> <br><p>  As a result, nginx will resolve symbolic links, hiding them from PHP. </p><br><p>  These are just some of the ways to deal with the cache problems of the present path.  There is no universal, "correct" way.  You will have to find your ideal solution depending on your requirements and infrastructure. </p><br><h2 id="ssylki">  Links </h2><br><ul><li>  <a href="http://blog.jpauli.tech/2014/06/30/realpath-cache.html">realpath_cache</a> </li><li>  <a href="https://codeascraft.com/2013/07/01/atomic-deploys-at-etsy/">Atomic deploys at Etsy</a> </li><li>  <a href="https://github.com/etsy/mod_realdoc">mod_realdoc</a> </li><li>  <a href="https://www.sitepoint.com/understanding-opcache/">Understanding OpCache</a> </li><li>  <a href="https://secure.php.net/opcache">PHP OPCache</a> </li><li>  <a href="https://www.slideshare.net/asgrim1/climbing-the-abstract-syntax-tree-phpday-2017">Climbing the Abstract Syntax Tree</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/341912/">https://habr.com/ru/post/341912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341902/index.html">Distributed registries and information security: from which protects the blockchain</a></li>
<li><a href="../341904/index.html">Design classes in games: not just RPG</a></li>
<li><a href="../341906/index.html">We select the supplier of IT solutions and keep the sanity</a></li>
<li><a href="../341908/index.html">Free YouTube broadcast Mobius 2017 Moscow</a></li>
<li><a href="../341910/index.html">Free YouTube-broadcast of DotNext 2017 Moscow: Performance .NET, AI, microservices and some F #</a></li>
<li><a href="../341914/index.html">What are ghost buttons and why should you be afraid of them?</a></li>
<li><a href="../341916/index.html">A bit about VPN: protocols for remote access</a></li>
<li><a href="../341918/index.html">Internet content blocking: about messengers and social networks</a></li>
<li><a href="../341920/index.html">IBM Research announced a 50-qubit quantum computer</a></li>
<li><a href="../341922/index.html">Immersion in oil: a new approach to immersion cooling</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>