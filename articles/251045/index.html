<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using Global Illumination in its own shaders in Unity 5</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! Unity 5 provides us with a global illumination system (Global Illumination, GI) out of the box, which allows you to get a really nice pictur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using Global Illumination in its own shaders in Unity 5</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/590/7c9/fb1/5907c9fb1bd0488a94d335eda2eab11e.png" alt="image" align="right"><br>  Hi, Habr!  Unity 5 provides us with a global illumination system (Global Illumination, GI) out of the box, which allows you to get a really nice picture in real time, which the developers demonstrated in their acclaimed video clip <a href="https://unity3d.com/ru/pages/the-blacksmith">The Blacksmith</a> .  Along with the system of global illumination, the universal material Standard transformed into a category of obsolete all former materials.  Despite the coolness of the standard material (and he, no less, is based on a physical model), I wondered if it was possible to connect the global illumination system to its own surface shader.  What came out of it, as well as what I had to face in the process, read under the cut. <br><a name="habracut"></a><br><br><h4>  What is good about Unity 5 global coverage? </h4><br>  In the system of global illumination in Unity 5, I was primarily attracted not by the ambient lighting simulation, but by the built-in reflections.  The developers have added a new mechanism to the engine, which is called <a href="http://docs.unity3d.com/ru/current/Manual/class-ReflectionProbe.html">Reflection Probes</a> .  The principle of its operation is quite simple: on the stage we place special markers (probes) in the right places, which retain reflections around themselves in cubic textures.  When moving between markers, a pair of the most significant is selected, and the reflections obtained from both are mixed.  Reflections can be calculated in real time, at the time of the activation of the marker, or generally controlled by a script where you can implement, for example, timers.  Such systems are often implemented in games where reflections are constantly needed, in particular, to simulate automotive paint material.  Agree, I really do not want to reinvent the wheel when everything is already done in the engine. <br>  Simulating secondary lighting is also very cool and can increase the realism of your rendering.  In the real world, many materials re-reflect the light falling on them and become light sources themselves.  To calculate such a secondary (indirect) lighting in real time, modern computing power is not enough, but it can be pre-calculated for static objects and rarely recalculated for dynamic ones, which is realized in Unity 5. The calculated data is packed into textures, which are then used during rendering in real time.  These textures are called lightmaps or lightmaps. <br>  Unity 5 provides several mechanisms that influence global lighting: <br><ul><li>  Assigned to a light source of type Baked or Mixed.  Such a light source will work through lightmap and not affect dynamic objects (Baked type) or work for dynamic objects as a full-fledged light source (Mixed type). </li><li>  Creating light markers ( <a href="http://docs.unity3d.com/Manual/LightProbes.html">Light Probes</a> ).  Illumination markers are a three-dimensional graph, in the nodes of which the level of illumination created by various light sources is maintained.  When rendering in real time, the interpolated data on the graph grid is used to calculate the lighting. </li><li>  Technology <a href="http://docs.unity3d.com/Manual/LightmappingDirectional.html">Directional Lightmapping</a> .  When calculating indirect-illumination, all surfaces can be considered ideally flat, i.e., the light is equally reflective in all directions, and one can take into account the preferential direction of the reflections by using data from the normal map.  This is the essence of this technology.  Also supported is the Directional Specular mode, which allows you to take into account glare, which allows you to create a full secondary lighting. </li></ul><br>  All this has many parameters that allow to take into account the balance of performance and quality, which further raised the technology in my eyes.  However, exploring new features of the engine, I worked on a test scene with Standard material, which ultimately did not suit me, I wanted to connect my own surface shader to the global lighting system. <br><br><h4>  Creating a surface shader </h4><br>  The first surprise was waiting for me here: there is no information in the documentation for the engine on how to properly connect your own surface shader to the GI system.  Instead, the documentation is replete with notes like ‚Äúwe are switching to Standard material‚Äù and ‚Äúwhy your materials are worse than Standard‚Äù.  Fortunately, the source codes of all embedded shaders are in the public domain and are either in the CGIncludes folder, or you can download them from the official site.  According to the results of the study of the source, it turned out the following: <br><ul><li>  In order for your shader to interact with the GI system, you must override the function with the following signature: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> LightingYourModelName_GI(YourSurfaceOutput s, UnityGIInput data, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> UnityGI gi)</code> </pre> <br>  where <i>YourModelName</i> is the name of your lighting model, <i>YourSurfaceOutput</i> is the name of your data structure with surface parameters, <i>UnityGIInput</i> is the input data for calculating global illumination, <i>UnityGI</i> is the result of calculating global illumination. <br>  Inside this function, of course, it is necessary to calculate the global illumination, for which the built-in function serves <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> UnityGI UnityGlobalIllumination (UnityGIInput data, half occlusion, half oneMinusRoughness, half3 normalWorld, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> reflections)</code> </pre> <br>  This function is defined in the CGIncludes / UnityGlobalIllumination.cginc file.  The <i>occlusion</i> parameter is responsible for additional shading.  You can, for example, transfer the results of any variation of the <a href="https://ru.wikipedia.org/wiki/Ambient_occlusion">Ambient Occlusion</a> algorithm to it.  The <i>oneMinusRoughness</i> parameter defines something like the glossiness of the material.  This parameter is used when calculating reflections; the less glossiness, the less clear reflections we will receive.  The Boolean parameter <i>reflections</i> allows you to turn off the reflection calculation, the purpose of the other parameters is obvious. <br>  As a result, I got the following function: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">inline</span></span> void <span class="hljs-type"><span class="hljs-type">LightingUniversal_GI</span></span>(<span class="hljs-type"><span class="hljs-type">SurfaceOutputUniversal</span></span> s, <span class="hljs-type"><span class="hljs-type">UnityGIInput</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">, inout </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UnityGI</span></span></span><span class="hljs-class"> gi) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gi</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UnityGlobalIllumination</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, 1.0 /* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">occlusion</span></span></span><span class="hljs-class"> */, 1.0 - </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Roughness</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">normalize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Normal</span></span></span><span class="hljs-class">)); }</span></span></code> </pre><br></li><li>  The function containing the lighting model has changed somewhat from previous versions of Unity.  Now she has a signature <br><br><pre> <code class="hljs lisp">inline fixed4 LightingYourModelName(<span class="hljs-name"><span class="hljs-name">YourSurfaceOutput</span></span> s, half3 viewDir, UnityGI gi)</code> </pre> <br>  Parameters <i>atten</i> and <i>lightDir</i> (someone familiar from previous versions of the engine) gave way to the structure of UnityGI.  This structure can contain up to 3 light sources ( <i>light</i> , <i>light2</i> and <i>light3</i> ), as well as data on secondary lighting in the <i>indirect</i> parameter.  Secondary illumination is divided into two components: <i>diffuse</i> - diffused light from secondary light sources and <i>specular</i> - specular component (reflections are transmitted through it).  To better understand how to apply all this data, consider the following pseudocode: <br><br><pre> <code class="hljs smalltalk">inline fixed4 <span class="hljs-type"><span class="hljs-type">LightingYourModelName</span></span>(<span class="hljs-type"><span class="hljs-type">YourSurfaceOutput</span></span> s, half3 viewDir, <span class="hljs-type"><span class="hljs-type">UnityGI</span></span> gi) { //       gi.light <span class="hljs-symbol"><span class="hljs-symbol">#if</span></span> defined(<span class="hljs-type"><span class="hljs-type">DIRLIGHTMAP_SEPARATE</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> <span class="hljs-type"><span class="hljs-type">LIGHTMAP_ON</span></span> //           gi.light2 <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> <span class="hljs-type"><span class="hljs-type">DYNAMICLIGHTMAP_ON</span></span> //           gi.light3 <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> <span class="hljs-symbol"><span class="hljs-symbol">#ifdef</span></span> <span class="hljs-type"><span class="hljs-type">UNITY_LIGHT_FUNCTION_APPLY_INDIRECT</span></span> //    indirect- <span class="hljs-symbol"><span class="hljs-symbol">#endif</span></span> }</code> </pre><br>  It is easy to see that the function describing the lighting model contains several blocks under the conditional compilation directives.  Shaders in Unity are built according to a popular paradigm called √ºber shaders.  According to this paradigm, the most common shader is written (ideally, the only one), the blocks of code in which turn into conditional compilation.  The shader is compiled according to the needs of the material.  As a result, one source - a set of compiled options.  So, returning to our function, the <i>gi.light</i> light <i>source</i> should always be used, since it contains the parameters of the main light source for a given shader pass.  The remaining two light sources can only be used in Directional Lightmapping mode with the glare (Directional Specular) turned on.  The <i>gi.light2</i> light <i>source</i> will be active only if a static lightmap is used, and the <i>gi.light3</i> source will work under dynamic light mapping conditions.  At the end of the function, under the directive <i>UNITY_LIGHT_FUNCTION_APPLY_INDIRECT</i> , secondary lighting is applied. <br>  I also want to note a curious story that happened with the <i>viewDir</i> parameter.  As some probably know, in the function describing the lighting model, the <i>viewDir</i> parameter can be omitted if you do not need it.  This allows the shader code generator to form a slightly more optimal code.  However, if you plan to use reflections from the GI system, the <i>viewDir</i> parameter in the function signature will have to be left even if you do not need it.  The point is that the built-in function <i>UnityGlobalIllumination</i> uses the direction of gaze to calculate the reflection vector.  If the code generator does not detect the <i>viewDir</i> function in the signature, it optimizes the code and the reflections will stop working. </li></ul><br>  I used the Cook-Torrance lighting model as the basis for my surface shader, which you can read about <a href="http://www.gamedev.ru/code/articles/Cook-Torrance">here</a> or <a href="http://habrahabr.ru/company/mailru/blog/248873/">here</a> .  Under the spoiler you will find the full code of the resulting shader.  Now let's look at what we did. <br><br><div class="spoiler">  <b class="spoiler_title">Full surface shader code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">Shader "ShadersLabs/Universal" { Properties { _MainColor("Color", Color) = (<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) _MainTex("Albedo", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "white" {} _NormalMap("Normal", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "bump" {} _EmissionMap("Emission (RGB), Specular (A)", <span class="hljs-number"><span class="hljs-number">2</span></span>D) = "black" {} _Roughness("Roughness", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.1</span></span> _ReflectionPower("Reflection Power", Range(<span class="hljs-number"><span class="hljs-number">0.01</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)) = <span class="hljs-number"><span class="hljs-number">3</span></span> _Metallic ("Metallic", Range(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)) = <span class="hljs-number"><span class="hljs-number">0.0</span></span> } SubShader { Tags { "RenderType"="Opaque" } LOD <span class="hljs-number"><span class="hljs-number">200</span></span> CGPROGRAM #pragma surface surf Universal fullforwardshadows exclude_path:prepass exclude_path:<span class="hljs-keyword"><span class="hljs-keyword">deferred</span></span> #pragma target <span class="hljs-number"><span class="hljs-number">3.0</span></span> struct <span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> { half2 uv_MainTex; }; struct SurfaceOutputUniversal { fixed3 Albedo; fixed3 Normal; fixed3 Emission; fixed Specular; fixed Metallic; fixed Roughness; fixed ReflectionPower; fixed Alpha; }; sampler2D _MainTex; sampler2D _NormalMap; sampler2D _SpecularMap; sampler2D _EmissionMap; fixed4 _MainColor; fixed _Roughness; fixed _ReflectionPower; fixed _Metallic; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> fixed3 CalculateCookTorrance(SurfaceOutputUniversal s, half3 n, fixed vdn, half3 viewDir, UnityLight light) { half3 h = normalize(light.dir + viewDir); fixed ndl = saturate(dot(n, light.dir)); fixed ndh = saturate(dot(n, h)); fixed vdh = saturate(dot(viewDir, h)); fixed ndh2 = ndh * ndh; fixed sp2 = max(s.Roughness * s.Roughness, <span class="hljs-number"><span class="hljs-number">0.001</span></span>); fixed G = min(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span> * ndh * min(vdn, ndl) / vdh); fixed D = exp((ndh2 - <span class="hljs-number"><span class="hljs-number">1.0</span></span>)/(sp2 * ndh2)) / (<span class="hljs-number"><span class="hljs-number">4.0</span></span> * sp2 * ndh2 * ndh2); fixed F = <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span> * pow(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - vdh, s.ReflectionPower); fixed spec = saturate(G * D * F / (vdn * ndl)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> light.color * (s.Albedo * ndl + fixed3(s.Specular, s.Specular, s.Specular) * spec); } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> fixed3 CalculateIndirectSpecular(SurfaceOutputUniversal s, fixed vdn, half3 indirectSpec) { fixed rim = saturate(pow(<span class="hljs-number"><span class="hljs-number">1.0</span></span> - vdn, s.ReflectionPower)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> indirectSpec * rim * s.Metallic; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> fixed4 LightingUniversal(SurfaceOutputUniversal s, half3 viewDir, UnityGI gi) { half3 n = normalize(s.Normal); fixed vdn = saturate(dot(viewDir, n)); fixed4 c = fixed4(CalculateCookTorrance(s, n, vdn, viewDir, gi.light), s.Alpha); #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defined(DIRLIGHTMAP_SEPARATE) #ifdef LIGHTMAP_ON c.rgb += CalculateCookTorrance(s, n, vdn, viewDir, gi.light2); #endif #ifdef DYNAMICLIGHTMAP_ON c.rgb += CalculateCookTorrance(s, n, vdn, viewDir, gi.light3); #endif #endif #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT c.rgb += (s.Albedo * gi.indirect.diffuse + CalculateIndirectSpecular(s, vdn, gi.indirect.specular)); #endif <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> LightingUniversal_GI(SurfaceOutputUniversal s, UnityGIInput data, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> UnityGI gi) { gi = UnityGlobalIllumination(data, <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-comment"><span class="hljs-comment">/* occlusion */</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span> - s.Roughness, normalize(s.Normal)); } <span class="hljs-type"><span class="hljs-type">void</span></span> surf(<span class="hljs-keyword"><span class="hljs-keyword">Input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> SurfaceOutputUniversal o) { fixed4 c = _MainColor * tex2D(_MainTex, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex); fixed4 e = tex2D(_EmissionMap, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex); o.Albedo = c.rgb; o.Normal = normalize(UnpackNormal(tex2D(_NormalMap, <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span>.uv_MainTex))); o.Specular = ea; o.Emission = e.rgb; o.Metallic = _Metallic; o.Roughness = _Roughness; o.ReflectionPower = _ReflectionPower; o.Alpha = ca; } ENDCG } FallBack "Diffuse" }</code> </pre><br></div></div><br><h4>  results </h4><br>  On the scene were placed 3 balls, a plane and 2 light sources (directed, imitating the Sun, and a point type Mixed right in front of the balls).  A single Reflection Probe has also been added to create reflections. <br><br><img src="https://habrastorage.org/files/3fd/51e/5d0/3fd51e5d04b74198abc5d6ec91009cd8.png"><br><br>  As a result, we get the following picture (on the left, global illumination is off, on the right - on). <br><br><img src="https://habrastorage.org/files/dbe/a8a/0db/dbea8a0dba8f438ba2ac611e9319f330.png"><br><br>  The image below shows the contribution of reflections and re-reflected light, which are formed by a global illumination system. <br><br><img src="https://habrastorage.org/files/513/2b4/a7c/5132b4a7c0874b7fa9d9492e442ab775.png"><br><br>  If you replace the Directional Specular light mapping mode in favor of the Directional mode, the picture will become more boring, but this will allow you to gain some performance.  In addition, Directional Specular mode is not supported on older versions of the graphics API, for example, Open GL ES 2.0. <br><br><img src="https://habrastorage.org/files/782/559/031/7825590315174f29b6d80c607c304709.png"><br><br><h4>  A spoon of tar </h4><br>  The results, in general, I was satisfied.  However, the last outstanding question remained.  All that I implemented did not support <a href="http://www.gamedev.ru/terms/DeferredShading">deferred shading</a> .  Unity 5 provides such a lighting mode out of the box, and, for the sake of completeness, it would be cool to support it. <br>  Here I was waiting for the biggest disappointment.  In the current version of the engine (I used 5.1.3), you can override the function for writing data to the G-buffer ( <i>LightingYourModelName_Deferred</i> ), but the function that decodes the G-buffers cannot be redefined.  More precisely, there is a way that requires certain extra squats.  The documentation for the engine about this says the following: <br><blockquote>  ‚ÄúThe only lighting model available is Standard.  If you want to make it, it‚Äôs possible to modify your lighting passport shader. </blockquote><br>  Thus, the only theoretical way to achieve the desired is to modify the inner shader and put it in a certain place in the project.  The documentation does not provide any other more detailed instructions.  By the way, a simple copy to the right place did not bring me the result, the engine still used the internal source shader. <br>  The correct decision was suggested to me by Mr. <a href="https://habrahabr.ru/users/marked-one/" class="user_link">marked-one</a> , for which he was very grateful.  In order to force Unity to use your own shader to decode G-buffers, go to <i>Edit -&gt; Project Settings -&gt; Graphics</i> and for the <i>Built-in shader settings -&gt; Deferred</i> select Custom Shader from the list, then select your own shader.  After that, Unity is about using the exposed shader for the entire engine, including the editor. <br><br><h4>  findings </h4><br>  What I learned from this story for myself, the Unity developers have created a very good global lighting system.  It can and should be used if you do not use deferred lighting in your project (and if you do, then prepare to modify the internal shaders of Unity).  As an alternative, you can consider a full transition to the Standard material, to which the Unity developers, apparently, make a big bet.  This material works in all modes, however, I would not switch my project to it.  The price would be a loss of control over both the visual image of the game and its performance.  You will draw conclusions for yourself, but for my part, I hope that you enjoyed reading this post.  Love quality rendering, see you soon! </div><p>Source: <a href="https://habr.com/ru/post/251045/">https://habr.com/ru/post/251045/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251035/index.html">Learning JavaScript programming</a></li>
<li><a href="../251037/index.html">March 2-5: PRO online conference + Skills: 4 skills in 4 days</a></li>
<li><a href="../251039/index.html">WordPress 4.1.1 Released</a></li>
<li><a href="../251041/index.html">Transparent encryption: advantages and disadvantages</a></li>
<li><a href="../251043/index.html">Trends of e-marketing for 2015, research and list of top tools from the company Smart Insights</a></li>
<li><a href="../251047/index.html">iOS application - development, top App Store, Techcrunch and Facebook grant for $ 60,000 services</a></li>
<li><a href="../251049/index.html">Introduction to GStreamer: Initialization</a></li>
<li><a href="../251053/index.html">Remote debugging in Linux using the GDB-gdbserver bundle</a></li>
<li><a href="../251063/index.html">Optimized command system for microcontrollers</a></li>
<li><a href="../251065/index.html">/ ^ 777 $ / or / ^ 7 {3} $ / or number of luck</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>