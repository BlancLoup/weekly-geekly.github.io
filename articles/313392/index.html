<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Pattern Strategy JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Earlier I published a translation of an article with the same title. And under it, comrade aTei left a comment : 
 In my opinion, something is missing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Pattern Strategy JavaScript</h1><div class="post__text post__text-html js-mediator-article"><p>  Earlier I published a <a href="https://habrahabr.ru/post/191480/">translation of an</a> article with the same title.  And under it, comrade <a href="https://habrahabr.ru/users/atei/" class="user_link">aTei</a> left a <a href="https://habrahabr.ru/post/191480/">comment</a> : </p><br><blockquote>  In my opinion, something is missing in this article and in an article in Wikipedia - an example in the style ‚ÄúIt was bad - it became good‚Äù.  Immediately it turns out "good" and it is not clear enough that this is really good.  I would be grateful for this example. </blockquote><p>  So far no one has given an answer to it.  For 3 years I plucked up <del>  of experience </del>  courage and now, as a response to this comment, I want to write about the Strategy pattern on my own behalf. </p><br><p>  Crumbs of the theory are found somewhere in the text.  But most of the article is devoted to practical ways to use this pattern and options for its use to avoid. </p><a name="habracut"></a><br><p>  Given: write Logger, which allows: </p><br><ul><li> Write logs of 3 levels: <code>log</code> , <code>warn</code> and <code>error</code> </li><li>  Select destination for logs: console, page (selected for clarity) <br><ul><li>  Once </li><li>  Many times </li></ul></li><li>  Add new destinations without making changes to the Logger code.  For example, file, ftp, mysql, mongo, etc. </li><li>  Add number (number of calls) to the log entry </li><li>  Use multiple independent loggers </li></ul><br><p>  The second paragraph assumes a single "interface" that would not have to rewrite all the lines where the Logger call occurs for the sake of changing the destination. </p><br><hr><br><h1 id="alternativy">  Alternatives </h1><br><p>  First, I will give two options for the "solution" of intentionally avoiding signs of the Strategy. </p><br><h2 id="funkcionalnyy-podhod">  Functional approach </h2><br><p>  Let's try to do this with <abbr title="are deterministic and have no side effects">pure functions</abbr> : </p><br><p>  First, we need two functions that will perform the main work: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logToConsole = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lvl,count,msg</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>[lvl](<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${count++}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${msg}</span></span></span><span class="hljs-string">`</span></span>) || count; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logToDOM = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lvl,count,msg,node</span></span></span><span class="hljs-function">) =&gt;</span></span> (node.innerHTML += <span class="hljs-string"><span class="hljs-string">`&lt;div class="</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${lvl}</span></span></span><span class="hljs-string">"&gt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${count++}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${msg}</span></span></span><span class="hljs-string">&lt;/div&gt;`</span></span>) &amp;&amp; count;</code> </pre> <br><p>  Both of them perform their main function, and then return the new value of <code>count</code> . </p><br><p>  Secondly, we need some kind of a unified interface that unites them.  And this is where we encounter the first problem ... Since pure functions do not store states, cannot influence external variables, and do not have other side effects - we have practically no other options but to choose the destination within the main function.  For example: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Logger = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">options</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(options.destination){ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'console'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> logToConsole; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'dom'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> logToDOM.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>,[...args,options.node]); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">`type '</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${type}</span></span></span><span class="hljs-string">' is not availible`</span></span>); }; };</code> </pre> <br><p>  Now, having declared all the necessary variables in the client code, we can use our Logger: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log2console = {<span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'console'</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> log2dom = { <span class="hljs-attr"><span class="hljs-attr">destination</span></span>: <span class="hljs-string"><span class="hljs-string">'dom'</span></span> ,<span class="hljs-attr"><span class="hljs-attr">node</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>) }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> logdestination = log2console; logCount = Logger(logdestination)(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,logCount,<span class="hljs-string"><span class="hljs-string">'this goes to console'</span></span>); logdestination = log2dom; logCount = Logger(logdestination)(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,logCount,<span class="hljs-string"><span class="hljs-string">'this goes to dom'</span></span>);</code> </pre> <br><p>  I think the shortcomings of this approach are obvious.  But the most important is that it does not satisfy the third condition: <em>Add new destinations without making changes to the Logger code.</em>  After all, adding a new destination, we must make it to <code>switch(options.destination)</code> . </p><br><p>  Result.  <em>Turn on the DevTools console before switching to the Result tab</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="oop-podhod">  OOP approach </h2><br><p>  The previous time we were constrained by the inability to store states, which is why we demanded that the client code create and maintain the environment that our Logger needs to work.  In OOP style, we can hide all this "under the hood" - in the properties of instances or classes. </p><br><p>  Let's create an abstract class in which, for the convenience of working with our Logger, we will describe high-level methods: <code>log</code> , <code>warn</code> and <code>error</code> . </p><br><p>  In addition, we need the <code>count</code> property <em>(I made it the property of the <code>Logger</code> prototype and an object to be global, and the subclasses with instances inherit it from the prototype and not create our own copy. Do we not need different counters for different destinations?)</em> </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ log(msg) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.write(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,msg);} warn(msg) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.write(<span class="hljs-string"><span class="hljs-string">'warn'</span></span>,msg);} error(msg) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.write(<span class="hljs-string"><span class="hljs-string">'error'</span></span>,msg);} }; Logger.prototype.count = {value:<span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre> <br><p>  and 2 workhorses like last time: </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogToConsole</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ write(lvl, msg) {console[lvl](`${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count.value++}: ${msg}`);} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogToDOM</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ constructor(node) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.domNode = node; } write(lvl,msg) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.domNode.innerHTML += `&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"${lvl}"</span></span>&gt;${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count.value++}: ${msg}&lt;/div&gt;`;} };</code> </pre> <br><p>  Now we just have to redefine the Logger instance, creating it from different classes to change the destination: </p><br><pre> <code class="hljs pgsql">let logger = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LogToConsole; logger.log(<span class="hljs-string"><span class="hljs-string">'this goes to console'</span></span>); logger = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LogToDOM(document.querySelector(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>)); logger.log(<span class="hljs-string"><span class="hljs-string">'this goes to dom'</span></span>);</code> </pre> <br><p>  This option no longer has a lack of a functional approach - it allows you to write destination independently.  But, in turn, does not satisfy the last condition: <em>Use several independent Loggers.</em>  As it stores <code>count</code> in a static property of the class <code>Logger</code> .  So all instances will have one common <code>count</code> . </p><br><p>  Result.  <em>Turn on the DevTools console before switching to the Result tab</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="strategiya">  Strategy </h1><br><p>  In fact, I cheated by composing the conditions of the problem: Any solution that satisfies them all will implement the Strategy pattern in one form or another.  After all, its main idea is to organize the code in such a way as to isolate the implementation of any methods (usually ‚Äúinternal‚Äù) into a separate, absolutely independent entity.  In the way that </p><br><ul><li>  first, the creation of new variations of this entity did not affect the main code </li><li>  secondly, to support "hot" (plug-n-play) replacement of these entities already during the execution of the code. </li></ul><br><h2 id="strategiya-na-gryaznyh-funkciyah">  Strategy on dirty functions </h2><br><p>  If we abandon the purity of the <code>Logger</code> function and use the closure, we get the following solution: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Logger = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logDestination; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">destination,...args</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destination) logDestination = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lvl,msg</span></span></span><span class="hljs-function">) =&gt;</span></span> destination(lvl,logCount,msg,...args); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lvl,msg</span></span></span><span class="hljs-function">) =&gt;</span></span> logCount = logDestination(lvl,msg); }; };</code> </pre> <br><p>  The <code>logToConsole</code> and <code>logToDOM</code> remain the same.  It remains only to declare a copy of the Logger.  And to replace the destination - to transfer necessary to this instance. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> logger = Logger(); logger(logToConsole)(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,<span class="hljs-string"><span class="hljs-string">'this goes to console'</span></span>); logger(logToDOM,<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>)); logger()(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,<span class="hljs-string"><span class="hljs-string">'this goes to dom'</span></span>);</code> </pre> <br><p>  Result.  <em>Turn on the DevTools console before switching to the Result tab</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="strategiya-na-prototipah">  Prototype strategy </h2><br><p>  Under the last post, comrade <a href="https://habrahabr.ru/users/tenshi/" class="user_link">tenshi</a> suggested: </p><br><blockquote>  And what prevents to change LocalPassport to FaceBookPassport while working? </blockquote><p>  Than threw the idea for the next implementation.  Prototype inheritance is a surprisingly powerful and flexible thing.  And with the legalization of properties <code>.__proto__</code> - just magical.  We can change the class (prototype) from which our instance is inherited on-the-go. </p><br><p>  Let's use this fraud: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(destination) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (destination) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setDestination(destination); } setDestination(destination) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__proto__ = destination.prototype; }; log(msg) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.write(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,msg);} warn(msg) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.write(<span class="hljs-string"><span class="hljs-string">'warn'</span></span>,msg);} error(msg) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.write(<span class="hljs-string"><span class="hljs-string">'error'</span></span>,msg);} };</code> </pre> <br><p>  Yes, now we can honestly put <code>count</code> in every instance of Logger. </p><br><p>  <code>LogToConsole</code> will differ only by calling <code>this.count</code> instead of <code>this.count.value</code> .  But <code>LogToDom</code> will change significantly.  Now we can not use the <code>constructor</code> to set <code>.domNode</code> , because we will not create an instance of this class.  For this we will make the setter method <code>.setDomNode(node)</code> : </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LogToDOM</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ write(lvl,msg) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.domNode.innerHTML += `&lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"${lvl}"</span></span>&gt;${<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count++}: ${msg}&lt;/div&gt;`;} setDomNode(node) {<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.domNode = node;} };</code> </pre> <br><p>  Now, to change the destination, call the <code>setDestination</code> method <code>setDestination</code> which will replace the prototype of our instance: </p><br><pre> <code class="hljs pgsql">const logger = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Logger(); logger.setDestination(LogToConsole); logger.log(<span class="hljs-string"><span class="hljs-string">'this goes to console'</span></span>); logger.setDestination(LogToDOM); logger.setDomNode(document.querySelector(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>)); logger.log(<span class="hljs-string"><span class="hljs-string">'this goes to dom'</span></span>);</code> </pre> <br><p>  Result.  <em>Turn on the DevTools console before switching to the Result tab</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="strategiya-na-interfeysah">  Interface strategy </h2><br><p>  If you google "Pattern Strategy", then in any of the articles you will find mention of interfaces.  And it so happened that in any * other language: the interface is a specific syntactic construct with specific unique functionality.  Unlike JS ... It seems to me that it was for this reason that this pattern was so hard for me at the time.  <em>(Yes, who am I kidding? Until now, how does it work?)</em> </p><br><p>  If it is simple: <strong>The interface</strong> allows you to "oblige" the implementation <em>(implementation) to</em> have specific methods.  Regardless of how these methods are implemented.  For example, in the class <code></code> , the interface is declared <code></code> with methods to <code></code> and <code></code> .  And a specific instance of <code></code> can use different implementations of this interface: <code></code> , <code></code> , <code></code> .  And even change them from time to time.  So with the "included" implementation of <code></code> , our <code></code> using the method to <code></code> interface <code></code> - will say <em>"Hello"</em> .  And when <code></code> turned on, the same action prompts him to say <em>'Hello'</em> . </p><br><p>  I could not refrain from giving an example of this pattern in its ‚Äúclassic‚Äù form using interfaces.  Why sketched a small library that implements the concept of interfaces in JS - <a href="https://github.com/titulus/js-interface">js-interface</a> <a href="https://www.npmjs.com/package/js-interface">npm</a> </p><br><div class="spoiler">  <b class="spoiler_title">Very brief educational program according to the syntax that will be used in the example:</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">const MyInterface = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> jsInterface([<span class="hljs-string"><span class="hljs-string">'doFirst'</span></span>,<span class="hljs-string"><span class="hljs-string">'doSecond'</span></span>]); //     .doFirst(..)  .doSecond(..) MyInterface(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>,<span class="hljs-string"><span class="hljs-string">'prop'</span></span>); //   .prop  . //  <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.prop) -&gt; [<span class="hljs-string"><span class="hljs-string">'doFirst'</span></span>,<span class="hljs-string"><span class="hljs-string">'doSecond'</span></span>] * <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.prop = implementation; // /   . // implementation    .    - ,    doFirst  doSecond .</code> </pre> </div></div><br><p>  This approach will be very close to the previous one.  In the <code>Logger</code> code, only the strings associated with the <code>destination</code> replaced with the one with jsInterface, and the <code>write</code> method is transferred to the <code>loginterface</code> property: </p><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Logger</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.count = <span class="hljs-number"><span class="hljs-number">0</span></span>; jsInterface([<span class="hljs-string"><span class="hljs-string">'write'</span></span>])(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>,<span class="hljs-string"><span class="hljs-string">'loginterface'</span></span>); } log(msg) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loginterface.write(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,msg); } warn(msg) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loginterface.write(<span class="hljs-string"><span class="hljs-string">'warn'</span></span>,msg); } error(msg) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.loginterface.write(<span class="hljs-string"><span class="hljs-string">'error'</span></span>,msg); } };</code> </pre> <br><p>  I will explain the code above.  In the constructor, we declare an instance of <code>new Logger</code> <del>  property </del>  interface <code>loginterface</code> with <code>write</code> method. </p><br><p>  <code>LogToConsole</code> does not need to store any data for itself, so <code>log2console</code> make it a simple <code>log2console</code> object with the <code>write</code> method: </p><br><pre> <code class="hljs markdown">const log2console = { write:function(lvl,msg) {console[<span class="hljs-string"><span class="hljs-string">lvl</span></span>](<span class="hljs-link"><span class="hljs-link">`${this.count++}: ${msg}`</span></span>);} };</code> </pre> <br><p>  But <code>LogToDOM</code> needs to store the <code>node</code> .  True, it can now be wrapped in a closure and not clutter up the Logger instance with unnecessary properties and methods. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LogToDOM</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">node</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.write = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">lvl,msg</span></span></span><span class="hljs-function">) </span></span>{node.innerHTML += <span class="hljs-string"><span class="hljs-string">`&lt;div class="</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${lvl}</span></span></span><span class="hljs-string">"&gt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.count++}</span></span></span><span class="hljs-string">: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${msg}</span></span></span><span class="hljs-string">&lt;/div&gt;`</span></span>;} };</code> </pre> <br><p>  The use is also very similar to the previous version.  Unless it is not necessary to cause additional <code>setDomNode</code> . </p><br><pre> <code class="hljs pgsql">const logger = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Logger(); logger.loginterface = log2console; logger.log(<span class="hljs-string"><span class="hljs-string">'this goes to console'</span></span>); logger.loginterface = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LogToDOM(document.querySelector(<span class="hljs-string"><span class="hljs-string">'#log'</span></span>)); logger.log(<span class="hljs-string"><span class="hljs-string">'this goes to dom'</span></span>);</code> </pre> <br><p>  You've probably noticed this oddity: After </p><br><pre> <code class="hljs">logger.loginterface = log2console;</code> </pre> <br><p>  must be beaten <code>this.count</code> .  after all: </p><br><pre> <code class="hljs erlang-repl">logger.log(<span class="hljs-string"><span class="hljs-string">'bla bla'</span></span>) -&gt; -&gt; this.loginterface.write(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,<span class="hljs-string"><span class="hljs-string">'bla bla'</span></span>) -&gt; -&gt; log2console.write(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,<span class="hljs-string"><span class="hljs-string">'bla bla'</span></span>) this.count === log2console.count</code> </pre> <br><p>  But this is also the "magic" of interfaces.  Implementations are not "independent" objects - they only provide the code of their methods for using "real" objects for which this interface is declared.  So the chain of transformations will be as follows: </p><br><pre> <code class="hljs erlang-repl">logger.log(<span class="hljs-string"><span class="hljs-string">'bla bla'</span></span>) -&gt; -&gt; this.loginterface.write(<span class="hljs-string"><span class="hljs-string">'log'</span></span>,<span class="hljs-string"><span class="hljs-string">'bla bla'</span></span>) -&gt; -&gt; log2console.write.apply(logger,[<span class="hljs-string"><span class="hljs-string">'log'</span></span>,<span class="hljs-string"><span class="hljs-string">'bla bla'</span></span>]) this.count === logger.count</code> </pre> <br><p>  Result.  <em>Turn on the DevTools console before switching to the Result tab</em> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="itog">  Total </h1><br><p>  <em>Strategy</em> is one of the basic patterns.  This, which is often implemented intuitively, without consciously following the commandments of any textbook. </p><br><p>  I won't say for other languages, but JS is pretty darn flexible!  This, like other patterns, is not embedded in the syntax - implement it as it is convenient and where it is convenient. </p><br><p>  Of course, the 3 described above are not all possible implementations of this pattern.  I am more than sure that you, the reader, can do the same in a dozen other ways.  So I urge you to note exactly the idea of ‚Äã‚Äãthe Strategy, and not my pathetic attempts to implement it. </p><br><hr><br><p>  <em>* I love very much</em> <del>  <em>extrapolate</em> </del>  <em>exaggerate</em> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/313392/">https://habr.com/ru/post/313392/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../313380/index.html">learnopengl. Lesson 1.5 - Shaders</a></li>
<li><a href="../313382/index.html">Virtual server with video card</a></li>
<li><a href="../313384/index.html">Dribbble review number 2 - the most interesting interface designs for the last 2 weeks</a></li>
<li><a href="../313386/index.html">The digest of interesting materials for the mobile developer # 176 (October 17-23)</a></li>
<li><a href="../313390/index.html">Interview with MapR's VP of Technology Strategy</a></li>
<li><a href="../313394/index.html">Eliminate Where Expressions Duplication in an Application</a></li>
<li><a href="../313396/index.html">Why is it too late to "make money" in business literature</a></li>
<li><a href="../313398/index.html">10 arguments against email migration to Microsoft cloud</a></li>
<li><a href="../313400/index.html">Hacker dossier: Boris Florikik aka Tron, creator of the first Cryptophone</a></li>
<li><a href="../313402/index.html">The digest of fresh materials from the world of the frontend for the last week No. 233 (October 17‚Äì23, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>