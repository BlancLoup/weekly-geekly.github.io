<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exceptions for hardcore. Features of Executing Processing in Dynamically Hosted Code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Modern versions of the operating system impose restrictions on the executable code associated with security requirements. Under such conditions, the u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exceptions for hardcore. Features of Executing Processing in Dynamically Hosted Code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/468/c42/ce5/468c42ce5d2408e7cd330694bbf862cf.jpg" alt="image"><br><br>  Modern versions of the operating system impose restrictions on the executable code associated with security requirements.  Under such conditions, the use of an exclusion mechanism in an injected code or, say, in a manually projected image can be a nontrivial task if you are not aware of certain nuances.  This article will focus on the internal structure of the user-mode exception manager of the Windows OS for x86 / x64 / IA64 platforms, and will also consider options for implementing the circumvention of system constraints. <br><a name="habracut"></a><br><h4>  <b>__ try</b> </h4><br>  Suppose that in your practice a problem arose that requires the implementation of full-fledged exception handling in the code implemented in a foreign process, or you make another PE-packer / cryptor, which should ensure that the exceptions in the unpacked image work.  Anyway, it all comes down to the fact that the code that uses exceptions is executed outside the image projected by the system loader, which will be the main reason for the difficulties.  As a demonstration of the problem, consider a simple code example that copies its own image to a new area within the current AP process: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">exceptions_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ __try { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *i = <span class="hljs-number"><span class="hljs-number">0</span></span>; *i = <span class="hljs-number"><span class="hljs-number">0</span></span>; } __except (EXCEPTION_EXECUTE_HANDLER) { <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> MessageBoxA(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> exceptions_test(); <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> PVOID ImageBase = GetModuleHandle(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); DWORD SizeOfImage = RtlImageNtHeader(ImageBase)-&gt;OptionalHeader.SizeOfImage; PVOID NewImage = VirtualAlloc(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE); <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(NewImage, ImageBase, SizeOfImage); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ULONG_PTR Delta = (ULONG_PTR) NewImage - ImageBase; RelocateImage(NewImage, Delta); <span class="hljs-comment"><span class="hljs-comment">/*  exceptions_test    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*new_exceptions_test)() = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*)()) ((ULONG_PTR) &amp;exceptions_test + Delta); new_exceptions_test(); }</code> </pre> <br>  In the procedure exceptions_test, an attempt to access the null pointer is wrapped in the MSVC extension try-except, instead of the exception filter, a stub returning EXCEPTION_EXECUTE_HANDLER, which should immediately lead to the execution of the code in the except block.  When you first call exceptions_test, it works as expected: the exception is intercepted, the message box is displayed.  But after copying the code to a new location and calling the copy of exceptions_test, the exception is no longer processed, and the application simply ‚Äúcrashes‚Äù with the message about the unhandled exception that is specific to the OS version.  The specific reason for this behavior will depend on the platform on which the test was conducted, and to determine it, it will be necessary to deal with the mechanism for dispatching exceptions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/139/d06/409/139d064093934f67a016427be945b8de.png"><br>  Raw exception <br><br><h4>  <b>Scheduling exceptions</b> </h4><br>  Regardless of the platform and type of exception, dispatching for user-mode always starts from the KiUserExceptionDispatcher point in the ntdll module, which is controlled from the KiDispatchException core dispatcher (if the exception was raised from user-mode and was not handled by the debugger).  In the example above, control is transferred to the dispatcher for both cases of an exception (during the execution of exceptions_test and its copy at a new address), you can verify this by setting a breakpoint to ntdll! KiUserExceptionDispatcher.  The KiUserExceptionDispatcher code is very simple and looks something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">VOID NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KiUserExceptionDispatcher</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(EXCEPTION_RECORD *ExceptionRecord, CONTEXT *Context)</span></span></span><span class="hljs-function"> </span></span>{ NTSTATUS Status; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (RtlDispatchException(ExceptionRecord, Context)) { <span class="hljs-comment"><span class="hljs-comment">/*  ,    */</span></span> Status = NtContinue(Context, FALSE); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*   ,         */</span></span> Status = NtRaiseException(ExceptionRecord, Context, FALSE); } ... RtlRaiseException(&amp;NestedException); }</code> </pre><br>  where EXCEPTION_RECORD is the structure with information about the exception, and CONTEXT is the structure of the stream context state at the time of the exception.  Both structures are documented in MSDN, however, you are probably already familiar with them.  Pointers to this data are passed to ntdll! RtlDispatchException, where the actual dispatching takes place, and in 32-bit and 64-bit systems the mechanics of exception handling is different. <br><br><h4>  <b>x86</b> </h4><br>  The main mechanism for the x86 platform is Structured Exception Handling (SEH), based on a single-linked list of exception handlers located on the stack and always accessible from NT_TIB.ExceptionList.  The basics of this mechanism have been repeatedly described in a variety of works (see the sidebar ‚ÄúUseful Materials‚Äù), so we will not repeat, but only focus on those points that intersect with our task. <br><br><img src="https://habrastorage.org/files/08f/d26/5d4/08fd265d4e5a484d9618b4fee8d62b86.png"><br>  SEH chain dump <br><br>  The fact is that in SEH all elements of the handler list must be on the stack, which means that they are potentially subject to rewriting when the buffer in the stack overflows.  That was exploited with success by the creators of the exploits: the pointer to the handler was overwritten by the address needed to execute the shell-code, while the pointer was also rewritten to the next list item, which led to a violation of the handler chain.  To increase the resilience of attacks against programs using SEH, Microsoft developed mechanisms such as SafeSEH (a table with addresses of "safe" handlers, located in the IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG PE file), SEHOP (simple check of the integrity of the chain of frames), and also integrated the corresponding system policy DEP checks performed during the dispatching process of an exception. <br><br>  Simplified pseudo-code for the main dispatching procedure RtlDispatchException for the x86 version of the ntdll.dll library in Windows 8.1 can be represented (with some assumptions) as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlDispatchException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// NT 6.3.9600 { /*   Vectored Exception Handlers */ if (RtlpCallVectoredHandlers(exception, 1)) return 1; ExceptionRegistration = RtlpGetRegistrationHead(); /* ECV (SEHOP) */ if (!DisableExceptionChainValidation &amp;&amp; !RtlpIsValidExceptionChain(ExceptionRegistration, ...)) { if (_RtlpProcessECVPolicy != 2) goto final; else RtlReportException(); } /*   ,     */ while (ExceptionRegistration != EXCEPTION_CHAIN_END) { /*    */ if (!STACK_LIMITS(ExceptionRegistration)) { ExceptionRecord-&gt;ExceptionFlags |= EXCEPTION_STACK_INVALID; goto final; } /*   */ if (!RtlIsValidHandler(ExceptionRegistration, ProcessFlags)) goto final; /*    */ RtlpExecuteHandlerForException(..., ExceptionRegistration-&gt;Handler); ... ExceptionRegistration = ExceptionRegistration-&gt;Next; } ... final: /*   Vectored Continue Handlers */ RtlpCallVectoredHandlers(exception, 1); }</span></span></span></span></code> </pre><br>  From the presented pseudo-code, it can be concluded that in order to successfully transfer control to the SEH handler, the following conditions must be met when dispatching an exception: <br><br><ol><li>  The chain of SEH-frames must be correct (end with the ntdll! FinalExceptionHandler handler).  Verification is performed with SEHOP enabled for the process. </li><li>  The SEH frame must be on the stack. </li><li>  The SEH frame must contain a pointer to a valid handler. </li></ol><br><blockquote><h4>  INFO </h4><br>  For Vectored Exception Handling, no checks are performed in the manager, which makes VEH a suitable tool when there is no need to bother with SEH support in the program. </blockquote><br><img src="https://habrastorage.org/files/29a/269/37a/29a26937a76740d8a51fa164d2b7fde2.png"><br>  Call stack for exception filter <br><br>  If everything is very clear with the first two points and no additional actions are required to perform them, then we will examine the procedure for checking the handler for ‚Äúvalidity‚Äù in more detail.  Handler checks are performed with the ntdll! RtlIsValidHandler function, whose pseudo code for Vista SP1 was first introduced to the general public back in 2008 at the Black Hat conference in the States.  Even though he contained some inaccuracies, this did not prevent him from roaming as a copy-paste from one resource to another for several years.  Since then, the code of this function has not undergone significant changes, and the analysis of its version for Windows 8.1 allowed us to compile the following pseudo-code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RtlIsValidHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">// NT 6.3.9600 { if (/* Handler    */) { if (DllCharacteristics&amp;IMAGE_DLLCHARACTERISTICS_NO_SEH) goto InvalidHandler; if (/*   .Net ,  ILonly  */) goto InvalidHandler; if (/*   SafeSEH */) { if (/*    LdrpInvertedFunctionTable (  ),      */) { if (/* Handler    SafeSEH */) return TRUE; else goto InvalidHandler; } return TRUE; } else { if (/* ExecuteDispatchEnable  ImageDispatchEnable    ExecuteOptions  */) return TRUE; if (/* Handler      */) { if (ExecuteDispatchEnable) return TRUE; } else if (ImageDispatchEnable) return TRUE; } InvalidHandler: RtlInvalidHandlerDetected(...); return FALSE; }</span></span></span></span></code> </pre><br>  In the above pseudocode, the order of checking conditions is changed (in the original, some conditions are checked twice, some are checked in nested functions).  After analyzing the pseudo-code, we can conclude that for successful validation, one of the sets of conditions under which the handler belongs must be fulfilled: <br><br><ul><li>  image without SafeSEH, without flag NO_SEH, without flag ILonly; </li><li>  image with SafeSEH, without flag NO_SEH, without flag ILonly, the image must be registered in LdrpInvertedFunctionTable (not required if an exception occurred at the time of the process initialization); </li><li>  non-executable memory, the ExecuteDispatchEnable (ExecuteOptions) flag must be set (will work only if the No Execute is disabled for the process); </li><li>  executable memory area, ImageDispatchEnable flag must be set. </li></ul><br>  At the same time, a memory area is considered to be the case if the flag MEM_IMAGE is set for it in attributes of the region (attributes are obtained by the NtQueryVirtualMemory function), and the content corresponds to the PE structure.  Process flags are obtained by the NtQueryInformationProces function from KPROCESS.KEXECUTE_OPTIONS.  Based on the information received, at least three ways can be distinguished for the implementation of support for exceptions in dynamically allocated code on the x86 platform: <br><br><ol><li>  Setting / changing the ImageDispatchEnable flag for the process. </li><li>  Replacing the type of memory region with MEM_IMAGE (for a PE image without SafeSEH). </li><li>  Implementing your own exception manager bypassing all checks. </li></ol><br>  Each of these options will be discussed in detail below.  We should also mention SafeSEH support, which may be necessary if you write, for example, a regular legal PE packer or protector.  To implement it, you will have to take care of manually adding the record of the mapped image (with a pointer to SafeSEH) to the global table ntdll! LdrpInvertedFunctionTable, while functions that work with this table directly are not exported by the library ntdll.dll and look for them manually a little: in old OS, they still require a pointer to the table itself.  Having found the pointer in any way, you will also have to take care of blocking access to the table for safe changes.  An alternative would be to unpack the file into one of the sections of the unpacker and transfer the SafeSEH table from the unpacked file to the main image.  Unfortunately, a detailed review of these and other techniques is beyond the scope of this article, here options are considered that do not imply the support of SafeSEH (by the way, this table can always be simply reset). <br><br><h4>  Substitution ExecuteOptions process </h4><br>  ExecuteOptions (KEXECUTE_OPTIONS) is the part of the KPROCESS kernel structure that contains the DEP settings for the process.  The structure has the form: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KEXECUTE_OPTIONS</span></span></span><span class="hljs-class"> {</span></span> UCHAR ExecuteDisable : <span class="hljs-number"><span class="hljs-number">1</span></span>; UCHAR ExecuteEnable : <span class="hljs-number"><span class="hljs-number">1</span></span>; UCHAR DisableThunkEmulation : <span class="hljs-number"><span class="hljs-number">1</span></span>; UCHAR Permanent : <span class="hljs-number"><span class="hljs-number">1</span></span>; UCHAR ExecuteDispatchEnable : <span class="hljs-number"><span class="hljs-number">1</span></span>; UCHAR ImageDispatchEnable : <span class="hljs-number"><span class="hljs-number">1</span></span>; UCHAR Spare : <span class="hljs-number"><span class="hljs-number">2</span></span>; } KEXECUTE_OPTIONS, PKEXECUTE_OPTIONS;</code> </pre><br><img src="https://habrastorage.org/files/5c1/6c1/464/5c16c14642a54cc9aaa6350872f4107f.png"><br>  Process ExecuteOptions with DEP Enabled <br><br>  The values ‚Äã‚Äãof these settings (flags) at the user level are obtained by the NtQueryInformationProcess function with the information class parameter equal to 0x22 (ProcessExecuteFlags).  Flags are set in the same way with the NtSetInformationProcess function.  Starting with Vista SP1, for processes with DEP enabled, the Permanent flag is set by default, which prohibits making changes to settings after the process is initialized.  A fragment of the KeSetExecuteOptions procedure called in kernel mode from NtSetInformationProcess confirms this: <br><br><pre> <code class="bash hljs">@PermanentCheck: ; KeSetExecuteOptions +2Fh mov al, [edi+6Ch] ; current KEXECUTE_OPTIONS mov byte ptr [ebp+arg_0+3], al <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> al, 8 ; <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Permanent jnz short @Fail ;  0C0000022h (STATUS_ACCESS_DENIED)</code> </pre><br>  Thus, being in user-mode, ExecuteOptions with activated DEP will not be able to change.  But the only option is to simply ‚Äútrick‚Äù RtlIsValidHandler by setting the hook to NtQueryInformationProcess, where the flags will be replaced with the ones you need.  Installing such an interception will make the exceptions in the code located outside the modules loaded by the system workable.  Sample interceptor code: <br><br><pre> <code class="cpp hljs">NTSTATUS __<span class="hljs-function"><span class="hljs-function">stdcall </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xNtQueryInformationProcess</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE ProcessHandle, INT ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength)</span></span></span><span class="hljs-function"> </span></span>{ NTSTATUS Status = org_NtQueryInformationProcess(ProcessHandle, ProcessInformationClass, ProcessInformation, ProcessInformationLength, ReturnLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Status &amp;&amp; ProcessInformationClass == <span class="hljs-number"><span class="hljs-number">0x22</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ProcessExecuteFlags */</span></span> *(PDWORD)ProcessInformation |= <span class="hljs-number"><span class="hljs-number">0x20</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* ImageDispatchEnable */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status; }</code> </pre><br><h4>  Memory attribute swapping </h4><br>  An alternative option for changing the process flags is to replace the attributes of the memory region in which the handler is located.  As already noted, RtlIsValidHandler checks the type of allocated memory area, and, if it matches MEM_IMAGE, the area is considered to be.  It is impossible to assign MEM_IMAGE to the selected VirtualAlloc area, this type can only be set to display the section (NtCreateSection) for which the correct file handle is specified.  Just as with the ExecuteOptions substitution, you will need interception, this time the NtQueryVirtualMemory functions: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS NTAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xNtQueryVirtualMemory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HANDLE ProcessHandle, PVOID BaseAddress, INT MemoryInformationClass, PMEMORY_BASIC_INFORMATION MemInformation, ULONG Length, PULONG ResultLength)</span></span></span><span class="hljs-function"> </span></span>{ NTSTATUS Status = org_NtQueryVirtualMemory(ProcessHandle, BaseAddress, MemoryInformationClass, Buffer, Length, ResultLength); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Status &amp;&amp; !MemoryInformationClass) <span class="hljs-comment"><span class="hljs-comment">/* MemoryBasicInformation */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>((UINT_PTR)MemInformation-&gt;AllocationBase == g_ImageBase) MemInformation-&gt;Type = MEM_IMAGE; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Status; }</code> </pre><br>  The method is suitable for exceptions when injecting a PE image entirely or for manually mapped images.  In addition, this option is somewhat more preferable than the previous one, if only because it does not reduce the security of the process by partially disabling DEP (you don‚Äôt need additional malware?).  As a bonus, this method allows you to pass an internal check of the handler in modern versions of CRT using try-except and try-finally constructs (these constructs can also be used without CRT, for more details see the corresponding box).  The CRT check is performed by the __ValidateEH3RN function, called from _except_handler3, it assumes the specified MEM_IMAGE type for the region, as well as the correct PE structure. <br><br><h4>  Own exception manager </h4><br>  If the hook installation options are unsuitable for any reason or simply do not like, you can go further and completely replace the dispatching of SEH with your own code by implementing all the necessary logic of the SEH controller inside the vector handler.  From the above pseudo-code RtlDispatchException, it is clear that VEH is called before the processing of the SEH chain begins.  Nothing prevents to take control over the exception by the vector handler and decide for yourself what to do with it and what handlers to call for it.  The VEH handler is installed with just one line: <br><br><pre> <code class="cpp hljs">AddVectoredExceptionHandler(<span class="hljs-number"><span class="hljs-number">0</span></span>, (PVECTORED_EXCEPTION_HANDLER) &amp;VectoredSEH);</code> </pre><br>  where VectoredSEH is a handler, which is actually an SEH dispatcher.  The complete call chain for this handler will look like this: KiUserExceptionDispatcher -&gt; RtlDispatchException -&gt; RtlpCallVectoredHandlers -&gt; VectoredSEH.  In this case, the control of the calling function may not be returned, but you can call NtContinue or NtRaiseException yourself, depending on the success of the dispatch.  The complete source code for the SEH implementation via VEH can be found in the materials attached to the article, or on <a href="https://github.com/Teq2/SEH-Over-VEH">GitHub</a> .  The implementation code is fully working, and the dispatch logic corresponds to the system one. <br><br><img src="https://habrastorage.org/files/343/253/154/34325315419b4ea8b33374ff678c6fd3.png"><br>  SEH dispatcher inside the vector handler <br><br><h4>  <b>x64 and IA64</b> </h4><br>  In 64-bit versions of Windows, the x64 and Itanium platforms use a completely different way to handle exceptions than the x86 versions.  The method is based on tables containing all the information necessary for dispatching an exception, including offsets of the beginning and end of the code block for which the exception is processed.  Therefore, in the code compiled for these platforms, there are no operations to install and remove a handler for each try-except block.  The static exception table is located in the Exception Directory of the PE file and is an array of elements of the RUNTIME_FUNCTION structures, which look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RUNTIME_FUNCTION</span></span></span><span class="hljs-class"> {</span></span> ULONG BeginAddress; ULONG EndAddress; ULONG UnwindData; } RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;</code> </pre><br>  Pleasant moment: support for exceptions for dynamic code is implemented at the system level.  If the code is in a memory area that is not an image, or there is no exception table generated by the compiler in this image, then the information for exception handling is taken from dynamic exception tables (DynamicFunctionTable).  The pointer to the list is stored in ntdll! RtlpDynamicFunctionTable, several functions for working with the list are exported from ntdll.dll.  A cursory analysis of the listings of these functions allowed us to obtain the following structure of the elements of the DynamicFunctionTable list: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicFunctionTable</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* +0h */</span></span> PVOID Next; PVOID Prev; <span class="hljs-comment"><span class="hljs-comment">//       /* +10h */ PRUNTIME_FUNCTION Table;//   ,      ID|0x03 PVOID TimeCookie; // ZwQuerySystemTime /* +20h */ PVOID RegionStart; //   BaseAddress DWORD RegionLength; //   ()  /* +30h */ DWORD64 BaseAddress; PGET_RUNTIME_FUNCTION_CALLBACK Callback; /* +40h */ PVOID Context; //     DWORD64 CallbackDll; //   +58h,  DLL  /* +50h */ DWORD Type; // 1 ‚Äî table, 2 ‚Äî callback DWORD EntryCount; WCHAR DllName[1]; };</span></span></code> </pre><br><img src="https://habrastorage.org/files/29b/300/8b1/29b3008b1a1f430a9a61e674a700ad62.png"><br>  RUNTIME_FUNCTION search algorithm <br><br>  Elements are added by the RtlAddFunctionTable and RtlInstallFunctionTableCallback functions, removed by the RtlDeleteFunctionTable.  All of these features are well documented in MSDN and are very easy to use.  An example of adding a dynamic table for a newly-mapped image <br><br><pre> <code class="cpp hljs">ULONG Size, Length; <span class="hljs-comment"><span class="hljs-comment">/*  ,  ,    */</span></span> PRUNTIME_FUNCTION Table = (PRUNTIME_FUNCTION) RtlImageDirectoryEntryToData(NewImage, TRUE, IMAGE_DIRECTORY_ENTRY_EXCEPTION, &amp;Size); Length = Size/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(PRUNTIME_FUNCTION); <span class="hljs-comment"><span class="hljs-comment">/*      DynamicFunctionTable */</span></span> RtlAddFunctionTable(Table, Length, (UINT_PTR)NewImage);</code> </pre><br>  That's all, no hooks or own exception controllers, no bypass of system checks.  It is only worth noting that the DynamicFunctionTable is global for the process, so if the code for which the record is added has worked and should be deleted, then the corresponding record from the table should also be removed.  Instead of adding a table, you can set a callback for a specific address range in the UA, which will receive control every time a RUNTIME_FUNCTION entry is required for code from this area.  The version with the installation of the callback, see the source code attached to the article. <br><br><img src="https://habrastorage.org/files/b11/fa3/0d4/b11fa30d44f640d1ba9f13fa4782bf5a.png"><br>  Exception processed <br><br><h4>  <b>__finally</b> </h4><br>  Low-level programming under Windows using the native API does not impose exceptions as an error handling method, and developers of ‚Äúspecific software‚Äù are often either simply ignored or limited to installing an unhandled exception filter or simply using VEH.  Nevertheless, exceptions still remain a powerful mechanism by which you can extract the greater the gain, the more complex the architecture of your program.  And thanks to the methods discussed in the article, you will be able to enjoy exceptions even in the most extraordinary conditions. <br><br><blockquote><h4>  Useful materials </h4><br><ul><li>  SEH mate for x86 in three parts: <a href="http://www.wasm.ru/wault/article/show/Win32SEHPietrek1">"SEH from the inside"</a> </li><li>  Hardware for exceptions for x64: <a href="http://www.osronline.com/article.cfm%3Farticle%3D469">"Exceptional Behavior - x64"</a> </li><li>  Microsoft Official Documentation: <a href="https://msdn.microsoft.com/en-us/library/1eyas8tf.aspx">Exception Handling (x64)</a> </li></ul><br>  Also I recommend to get Windows Research Kernel (the main part of the NT5.2 kernel sources).  WRK is distributed to universities and academic organizations, but not for me to teach you how and where to look for such things. </blockquote><br><blockquote><h4>  Try-except and try-finally constructs without CRT </h4><br>  If you are going to use constructions of blocks of exceptions and finalization, then you should take care of the presence in the program of a procedure that the compiler substitutes for the real handler: for x86 projects this is __except_handler3, and for x64 it is __C_specific_handler.  In these procedures, our own dispatching is performed: the search and calling of the necessary handlers, as well as the promotion of the stack.  There is no special need to write them yourself, for the x86 project you can simply connect expsup3.lib from the old DDK (ntdll.lib from the DDK also contains necessary functions), for x64 it is still easier: __C_specific_handler is exported by the 64-bit version of ntdll.dll, just use the correct lib file. </blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/404/79a/e32/40479ae325c224b6ebd0868509f26d3d.jpg" alt="image"><br><br>  <i>First published in Hacker Magazine # 195.</i> <i><br></i>  <i>Posted by: Teq</i> <br><br>  Subscribe to "Hacker" <br><ul><li>  <a href="https://xakep.ru/wp-admin/profile.php%3Fpage%3Dpaywall_subscribes">Site materials</a> </li><li>  <a href="http://bit.ly/habr_subscribe_paper">Paper version</a> </li><li>  <a href="http://bit.ly/xakep_on_ipad">Hacker on iOS / iPad</a> </li><li>  <a href="http://bit.ly/habr_android">"Hacker" on Android</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/260577/">https://habr.com/ru/post/260577/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260569/index.html">Jii: Active Record for Node.js with API from Yii 2</a></li>
<li><a href="../26057/index.html">Tennis of the future. Photo</a></li>
<li><a href="../260571/index.html">ECMAScript 2015 Specification Approved</a></li>
<li><a href="../260573/index.html">New io.js features that you may not be using</a></li>
<li><a href="../260575/index.html">Comparing the HP 3PAR 10000 with the new high-end HP 3PAR 20000 system</a></li>
<li><a href="../260579/index.html">How to identify a person in a photo using PHP</a></li>
<li><a href="../26058/index.html">Anton Nosik and Steve Ballmer, ReMIX</a></li>
<li><a href="../260581/index.html">What programming languages ‚Äã‚Äãand why are used in finance</a></li>
<li><a href="../260583/index.html">When 3D Printers Were Big: Chronicle of Master Keith Lab</a></li>
<li><a href="../260585/index.html">Where does mobility lead? Key objectives of the organization in implementing the mobility strategy</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>