<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learning to write a kernel module (Netfilter) or Transparent Proxy for HTTPS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is aimed at readers who are starting or just want to start programming Linux kernel modules and network applications. It can also help to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learning to write a kernel module (Netfilter) or Transparent Proxy for HTTPS</h1><div class="post__text post__text-html js-mediator-article">  This article is aimed at readers who are starting or just want to start programming Linux kernel modules and network applications.  It can also help to deal with transparent proxying of HTTPS traffic. <br><br>  A small table of contents so that you can assess whether to read further: <br><ol><li>  How does the proxy server.  Formulation of the problem. </li><li>  Client is a server application using non-blocking sockets. </li><li>  Writing a kernel module using the Netfilter library. </li><li>  Interaction with kernel module from user space (Netlink) </li></ol><br>  PS For those who just want to look at a transparent proxy server for HTTP and HTTPS, just <a href="http://www.google.ru/">set up a transparent proxy server for HTTP</a> , for example, Squid with a transparent port 3128, and <a href="">download the Shifter source archive</a> .  Compile (make) and, after successful compilation, execute ./Start with root rights.  If necessary, you can correct the settings in shifter.h before compiling. <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  Like all beginners in the field of IT wanted to dig a little bit in the core.  Here and the area for experiments appeared by itself.  If you look at Google, you can see that if no one has problems with a transparent proxy server for HTTP, then in the case of HTTPS some people are sure that there is no transparent proxy for the HTTPS protocol.  And it will never be.  All this served the appearance of this article. <br>  To begin, consider some aspects of the proxy server that we need.  When the browser directly accesses the HTTP server, it creates the following typical request: <br><pre><code class="html hljs xml">GET / HTTP/1.1 Host: www.google.ru ‚Ä¶</code> </pre> <br>  When we specify a proxy server in the browser settings, the browser starts to connect to the proxy server, and sends it a request with the full address: <br><pre> <code class="html hljs xml">GET http://www.google.ru/ HTTP/1.1 Host: www.google.ru ‚Ä¶</code> </pre><br>  If the proxy server receives a request with an incomplete address, as in the first case, it may not know to whom this request is intended and will return an error. <br>  I will say a few words about HTTPS.  The browser establishes a tcp connection and, using the SSL protocol: exchanges certificates and transmits encrypted HTTP traffic.  Since the SSL protocol is designed to ensure that no one can read the transmitted data in the middle, the proxy server cannot, as in the case of HTTP, find out with whom it should establish a connection.  To transmit data over HTTPS through a proxy server, the browser must inform the proxy server with whom it wants to connect using the HTTP method CONNECT: <br><pre> <code class="html hljs xml">CONNECT mail.google.com:443 HTTP/1.1 Host: mail.google.com ‚Ä¶</code> </pre><br>  To which the proxy server must respond that the connection is successfully established: <br><pre> <code class="html hljs xml">HTTP/1.0 200 Connection established</code> </pre><br>  As a result, the browser receives a direct tcp connection through a proxy server, in which it can transmit absolutely any data.  A proxy server is engaged only in the exact transfer of data from the tcp connection established with the browser to the tcp connection established with the specified host in the CONNECT method, and, accordingly, the reverse transfer. <br>  When transparent proxying is used, i.e.  If the browser does not even suspect the existence of a proxy server, then the browser will not prepare its data so beautifully.  And the proxy server will have to think about it. <br>  Schematically take a look at the transparent proxy for HTTP: <br><img src="https://habrastorage.org/storage2/8ca/a21/65f/8caa2165f4d0e759ebb736ef4a2f4d24.png"><br>  Here, of course, there are inaccuracies, for example, a proxy, receiving a packet to its port 3128, does not pass it on to Google, but creates a new connection with Google, but, in general, the interaction scheme is approximately the same.  In this scheme, it is clear that NAT is starting to send packets to the proxy server, which are not intended for it, and it needs to know who it is to send them.  In the case of HTTP traffic, some proxy servers incorrectly begin to use information from the HOST field of the HTTP request header, violating the specification.  Most often, of course, HOST contains exactly the name of the host to which the request is addressed, but, in general, HOST can contain anything.  For HTTPS, this solution is not suitable at all.  To find out who the packet is addressed to, it immediately suggests a solution in which the proxy server would look in NAT and look at who the data were intended for and then there would be no problem.  That's actually what we do. <br>  Unfortunately, iptables itself is not useful, but the basic principles of its operation will be well understood.  Schematically it will look like this: <br><img src="https://habrastorage.org/storage2/a7b/3cd/ce9/a7b3cdce9b1515e88df749b0c6f0777d.png"><br>  For the intended purposes, it will be enough to write a tiny kernel module (Module Shifter) and implement a small software layer (Shifter) in the user space to interact with our module, which will prepare the data for the proxy server. <br><br><h4>  Client - server application (Shifter) </h4><br>  Let's write a small client-server application, which I called Shifter.  Shifter will hang on its port and when someone establishes a tcp connection with it, it will create a tcp connection with the proxy server and send it a CONNECT (HTTP) method, and then it will only deal with the exact transfer of data between these two connections.  If the client or proxy closes the connection with it, it will close this pair of sockets. <br>  To send a CONNECT method, you need the ip address of the remote node with which the client actually wanted to establish a connection.  To obtain this information, the Shifter will communicate with the kernel module (Module Shifter) using the Netlink library.  This will be discussed in the last part of this article. <br>  With this application, we will prepare a proxy server for receiving data (HTTPS) from a client that does not know anything about the proxy server.  Since there are many resources where it is written in detail about sockets, here I will only provide a link to a <a href="http://paste.ubuntu.com/818687/">part of the Shifter source code with detailed comments</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Kernel module shifter </h4><br>  In order to find out what a kernel module is, you can read, for example, <a href="http://habrahabr.ru/blogs/nix/117654/">Working with kernel modules in Linux</a> .  Let's start writing the module.  First you need to perform initialization of the module, which will occur once, when the module will be loaded into the kernel.  You should also perform a correct shutdown of the module in order not to leave any unnecessary traces of the past presence when the module is unloaded from the kernel.  For these purposes, the library <i>&lt;linux / module.h&gt;: &lt;linux / init.h&gt;</i> has two macros <b>module_init</b> and <b>module_exit</b> , which take the name of the function for this purpose as a parameter.  There are also <b>MODULE_AUTHOR</b> , <b>MODULE_DESCRIPTION</b> , <b>MODULE_LICENSE macros</b> to perpetuate your name :) There is also a very useful <b>int printk</b> output function <b>(const char * fmt, ...)</b> in the <i>&lt;linux \ kernel.h&gt; library: &lt;linux \ printk.h&gt;</i> .  It is not much different from the usual <i>printf (..)</i> .  Since the module is located in the kernel, and is not running in the console, the messages are respectively output to the logs (you can use the <b>dmesg command</b> to view).  Messages can be displayed in various types: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_EMERG </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;0&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* system is unusable */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_ALERT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;1&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* action must be taken immediately */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_CRIT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;2&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* critical conditions */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_ERR </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;3&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* error conditions */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_WARNING </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;4&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* warning conditions */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_NOTICE </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;5&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* normal but significant condition */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_INFO </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;6&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* informational */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_DEBUG </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;7&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* debug-level messages */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KERN_DEFAULT </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&lt;d&gt;"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Use the default kernel loglevel */</span></span></span></span></code> </pre><br>  Now we have all the information to write the frame of our first module: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; MODULE_AUTHOR("Denis Dolgikh &lt;sindo@sibmail.com&gt;"); MODULE_DESCRIPTION("Module for the demonstration"); MODULE_LICENSE("GPL"); int Init(void) { printk(KERN_INFO "Init my module\n"); printk("Hello, World!\n"); return 0; } void Exit(void) { printk(KERN_INFO "Exit my module\n"); } module_init(Init); module_exit(Exit);</span></span></span></span></code> </pre><br>  I'll tell you a little more about how to compile and run all this.  I have to say that I have Ubuntu 11.10 (x86) Kernel 3.0 installed. <br>  The system has a directory <i>/ lib / modules / [kernel version] /</i> it contains modules for the corresponding kernel version.  Also there is a <b>build</b> - this is a symbolic link to the headers of the kernel libraries (kernel-headers), which are located in the <i>/ usr / src / linux-headers- [kernel version] /</i> directory.  If you do not already have kernel headers, then you need to download them ( <i>sudo apt-get install linux-headers- [kernel version]</i> ).  To find out the version of the current kernel you are working in, you can issue the <i>uname ‚Äìr</i> command.  If you use a library with a version different from the version of the current kernel, then such a compiled module may work fine, or it may not start at best.  It all depends on what changes have occurred in the kernel, and what you use in the function module. <br>  To compile the module, write the <b>Makefile</b> .  Let's create two goals: <i>all</i> (build the module) and <i>clean</i> (clean the project), for writing we will use the goals already written for us: <i>modules</i> and <i>clean</i> in the <i>Makefile</i> from the <i>kernel-headers</i> . <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#        # module_test.o ‚Äì ,       module_test. obj-m += module_test.o #  Makefile  kernel-headers   -, #     /lib/modules/[ ]/build #     modules      obj-m # M=$(PWD)   ,      all: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules clean: make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean</span></span></code> </pre><br>  Now we can easily compile the module using the <b>make command</b> and clean the <i>make clean</i> project.  As a result, we get a ready-made module <i>module_test.ko</i> , which can be immediately loaded into the kernel using the <b>insmod</b> command <b>./module_test.ko</b> .  There is another option for loading a module into the kernel - with the <b>modprobe module_test command</b> .  To do this, put the module <i>module_test.ko</i> in the directory <i>/ lib / modules / [current kernel version] / [any directory] /</i> and do not forget to run <b>depmod</b> , since  This command creates a list of module dependencies in <i>/ lib / modules /</i> .  Even if the module has no dependencies, <i>modprobe</i> will not see the added module without <i>depmod</i> .  The main differences between <i>insmod</i> and <i>modprobe are</i> as follows: <i>modprobe</i> automatically loads all modules on which it depends upon loading a module, but <i>insmod</i> can load a module from any directory.  Remove module from kernel: <b>rmmod module_test</b> .  View information about the module: <b>modinfo module_test</b> or <i>modinfo ./module_test.ko</i> . <br><br><h5>  Netfilter library </h5><br>  And so back to the proxy for https.  Our task is to make the module view the network packets before DNAT (iptables) processes them.  The <i>Netfilter library</i> will help us for this <i>.</i>  (For a more detailed understanding, I recommend further reading about Netfilter in other sources, at least <a href="http://ru.wikipedia.org/wiki/Netfilter">on Wikipedia</a> ) Consider what the path of a network package looks like in the kernel: <br><img src="https://habrastorage.org/storage2/993/799/6d6/9937996d654e2716806c772a6b1a618f.png"><br>  More details can be <a href="">found here</a> . <br>  Netfilter <i>&lt;linux / netfilter.h&gt;</i> provides 5 hook functions that give access to a network package in 5 different places: <ol><li>  <b>NF_INET_PRE_ROUTING</b> - the function catches absolutely all input packets, before the packets have already passed simple checks (packets are not lost, IP checksum is OK, etc.); <br>  The packet then goes through routing, which decides whether the packet is for a different interface or local process.  Routing may drop a packet if it is not routable. </li><li>  <b>NF_INET_LOCAL_IN</b> - called if the package is intended for a local process, before sending the package to it; </li><li>  <b>NF_INET_FORWARD</b> - when a packet is routed from one interface to another; </li><li>  <b>NF_INET_LOCAL_OUT</b> - trap for packages that create local processes; </li><li>  <b>NF_INET_POST_ROUTING</b> is the final point before sending the packet to the network card driver. </li></ol><br>  The kernel module can register its function in any of these 5 places.  When registering, the module must indicate the priority of its function in this place.  In the library <i>&lt;linux / netfilter_ipv4.h&gt;</i> you can find priority for various standard tasks: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> nf_ip_hook_priorities { NF_IP_PRI_FIRST = INT_MIN, NF_IP_PRI_CONNTRACK_DEFRAG = <span class="hljs-number"><span class="hljs-number">-400</span></span>, NF_IP_PRI_RAW = <span class="hljs-number"><span class="hljs-number">-300</span></span>, NF_IP_PRI_SELINUX_FIRST = <span class="hljs-number"><span class="hljs-number">-225</span></span>, NF_IP_PRI_CONNTRACK = <span class="hljs-number"><span class="hljs-number">-200</span></span>, NF_IP_PRI_MANGLE = <span class="hljs-number"><span class="hljs-number">-150</span></span>, NF_IP_PRI_NAT_DST = <span class="hljs-number"><span class="hljs-number">-100</span></span>, NF_IP_PRI_FILTER = <span class="hljs-number"><span class="hljs-number">0</span></span>, NF_IP_PRI_SECURITY = <span class="hljs-number"><span class="hljs-number">50</span></span>, NF_IP_PRI_NAT_SRC = <span class="hljs-number"><span class="hljs-number">100</span></span>, NF_IP_PRI_SELINUX_LAST = <span class="hljs-number"><span class="hljs-number">225</span></span>, NF_IP_PRI_CONNTRACK_CONFIRM = INT_MAX, NF_IP_PRI_LAST = INT_MAX, };</code> </pre><br>  The list shows that DNAT has a priority of -100, so any priority &lt;-100 is suitable for our purpose.  If the priority of the function is&gt; -100, then it will receive packets with the already changed IP address of the destination (recipient). <br>  Each registered function in any of the 5 points must return one of the following values, which determines the further fate of the packet passed to it: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NF_DROP 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* discarded the packet */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NF_ACCEPT 1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* the packet passes, continue iterations */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NF_STOLEN 2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* gone away */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NF_QUEUE 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* inject the packet into a different queue (the target queue number is in the high 16 bits of the verdict) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NF_REPEAT 4 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* iterate the same cycle once more */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NF_STOP 5 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* accept, but don't continue iterations */</span></span></span></span></code> </pre><br>  In my free translation it will sound like this: <ul><li>  <b>NF_DROP</b> - remove this package </li><li>  <b>NF_ACCEPT</b> - the packet goes on, the iterations continue </li><li>  <b>NF_STOLEN</b> - drop this package (the kernel will no longer process it, the module must free up the memory allocated for this package) </li><li>  <b>NF_QUEUE</b> - put a package in a queue (usually for processing a package in user space) </li><li>  <b>NF_REPEAT</b> - repeat iteration (repeated function call with the same package) </li><li>  <b>NF_STOP</b> - skip package further, but do not continue iterations </li></ul>  <nobr>In this</nobr> case, iteration is the transition of a packet from a function to a function, since  At one point many functions can be registered, which in turn can be divided by priorities. <br><br>  With the theory figured out, now we continue to write the module.  When a module is loaded into the kernel, you need to register the function, call it <i>Hook_Func</i> , which will scan all incoming packets, and upon completion, you must unregister this function, otherwise the kernel will try to call a non-existent function. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; #include &lt;linux/netfilter.h&gt; #include &lt;linux/netfilter_ipv4.h&gt; /*       ip  */ struct nf_hook_ops bundle; int Init(void) { printk(KERN_INFO "Start module Shifter\n"); /*     hook  */ /*   ,     */ bundle.hook = Hook_Func; /*    ,  hook */ bundle.owner = THIS_MODULE; /*    */ bundle.pf = PF_INET; /* ,       */ bundle.hooknum = NF_INET_PRE_ROUTING; /*       */ bundle.priority = NF_IP_PRI_FIRST; /*  */ nf_register_hook(&amp;bundle); return 0; } void Exit(void) { /*    hook  */ nf_unregister_hook(&amp;bundle); printk(KERN_INFO "End module Shifter\n"); } module_init(Init); module_exit(Exit);</span></span></span></span></code> </pre><br>  Now all we have to do is write the function <i>Hook_Func</i> .  It should have the following prototype: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Hook_Func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint hooknum, struct sk_buff *skb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct net_device *in, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct net_device *out, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*okfn)(struct sk_buff *) )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*    firewall */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    ()     :) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NF_DROP; }</code> </pre><br>  Consider its parameters: <ul><li>  <b>uint hooknum</b> contains one of the following values: <i>{NF_INET_PRE_ROUTING = 0, NF_INET_LOCAL_IN = 1, NF_INET_FORWARD = 2, NF_INET_LOCAL_OUT = 3, NF_INET_POST_ROUTING = 4}</i> .  This parameter is needed to find out from which place the function was called, since  You can register the same function in several places. </li><li>  <b>struct sk_buff * skb</b> pointer to package structure. </li><li>  <b>const struct net_device * in</b> input interface information.  If this is an outgoing packet, then the parameter is NULL. </li><li>  <b>const struct net_device * out</b> information about the output interface.  If it is an incoming packet, then the parameter is NULL. </li><li>  <b>int (* okfn) (struct sk_buff *)</b> is a callback function that is called with the package when all iterations return a positive response. </li></ul><br>  Now more about the pointer to the packet <i>struct sk_buff * skb</i> . <blockquote>  <a href="http://www.hackzona.ru/hz.php%3Fname%3DNews%26file%3Darticle%26sid%3D3605">sk_buff</a> is a buffer for working with packages.  As soon as a package arrives or it becomes necessary to send it, sk_buff is created, where the package is placed, as well as related information, where, where, for what ... Throughout the entire journey of the package, sk_buff is used in the network stack.  As soon as the packet is sent, or the data is transmitted to the user, the structure is destroyed, thereby freeing memory. </blockquote>  <a href="http://paste.ubuntu.com/842915/">The sk_buff structure is described in &lt;linux / skbuff.h&gt;</a> , and various functions are described there for pleasant work with it. <br>  When working with tcp, you can use two more structures - this is a <a href="http://paste.ubuntu.com/825024/">struct iphdr and a struct tcphdr</a> . <br>  As the name implies, these structures are designed to work with the <a href="http://ru.wikipedia.org/wiki/IP">IP header</a> and, accordingly, with the <a href="http://ru.wikipedia.org/wiki/TCP">TCP header</a> .  To get pointers to these structures from <i>skb_buff,</i> you can use two functions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skb_network_header</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct sk_buff *skb)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">skb_transport_header</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct sk_buff *skb)</span></span></span></span>;</code> </pre><br>  In this place I would like to appeal to the reader.  It remains unclear to me exactly who should set the <i>transport_header</i> pointer in the <i>sk_buff</i> structure, since  at the <i>NF_INET_PRE_ROUTING</i> and <i>NF_INET_LOCAL_IN points</i> (with any priorities) I could not get a structure on the tcp header using <i>skb_transport_header</i> , although it worked perfectly at the other points.  I had to manually specify the offset for <i>transport_header</i> from the pointer <i>sk_buff-&gt; data</i> , using the <i>void skb_set_transport_header (skb, offset)</i> . <br>  The <b>sk_buff-&gt; data</b> pointer is a pointer to the package contents, i.e.  points to the memory area after the Ethernet protocol, for example, immediately to the IP header structure, and then it can be followed by the TCP header structure or your own protocol. <br>  Since pointers to data in the package itself are used everywhere, it is possible not only to read various fields, but also to change them.  However, it must be remembered that when changing, for example, the IP address of the sender or recipient, it is necessary to recalculate the checksum in the IP packet header. <br>  And so, our function will save the destination IP address only when it sees the IP-TCP packet going to port 443 (HTTPS) and containing the <i>SYN</i> flag, which says that the client wants to establish a TCP connection for the HTTPS protocol.  And delete when packets containing <i>FIN</i> or <i>RST</i> flags appear that say that the tcp connection is broken and we do not need this IP address anymore. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/skbuff.h&gt; #include &lt;linux/ip.h&gt; #include &lt;linux/tcp.h&gt; #define uchar unsigned char #define ushort unsigned short #define uint unsigned int /* Hook_Func - ,       */ /*  IP  ,  : */ /* -  tcp  */ /* -   443  (HTTPS) */ /* -   SYN ( tcp ) */ uint Hook_Func(uint hooknum, struct sk_buff *skb, const struct net_device *in, const struct net_device *out, int (*okfn)(struct sk_buff *) ) { /*      ip   */ struct iphdr *ip; /*      tcp   */ struct tcphdr *tcp; /*    IP  */ if (skb-&gt;protocol == htons(ETH_P_IP)) { /*      IP */ ip = (struct iphdr *)skb_network_header(skb); /*    IP  4   TCP  */ if (ip-&gt;version == 4 &amp;&amp; ip-&gt;protocol == IPPROTO_TCP) { /*        TCP  */ /* ip-&gt;ihl -  IP   32-  */ skb_set_transport_header(skb, ip-&gt;ihl * 4); /*      TCP */ tcp = (struct tcphdr *)skb_transport_header(skb); /*     443  (HTTPS) */ if (tcp-&gt;dest == htons(443)) { /*    SYN,   IP   */ if (tcp-&gt;syn) AddTable((uint)ip-&gt;saddr, (ushort)tcp-&gt;source, (uint)ip-&gt;daddr); /*    FIN  RST,    IP   */ if (tcp-&gt;fin || tcp-&gt;rst) DelTable((uint)ip-&gt;saddr, (ushort)tcp-&gt;source, (uint)ip-&gt;daddr); } } } /*     */ return NF_ACCEPT; }</span></span></span></span></code> </pre><br>  There are two functions <b>AddTable</b> and <b>DelTable</b> , which should save and delete the recipient's IP address from memory, for each IP and port of the sender.  This is necessary so that the client-server Shifter can communicate with the Shifter module and use the <b>ReadTable</b> function to find out by the client's IP and port what IP address he really wanted to contact.  I didn‚Äôt think much about the data type to save the IP and used the usual static array using the elementary hash function.  The hash function ( <b>KeyHash</b> ) receives at the input ip and the port of the sender and returns the index of the array where the ip destination address is stored.  It is written taking into account the fact that the client is behind the nat and has a subnet with a mask of 255.255.255.0, so I use only the last byte of the sender's ip, and this byte is also superimposed by 3 bits on two bytes of the port.  As a result, I managed to compress the array to a size of 0x1FFFFF (~ 8 MB).  Of course, you need to take into account that now, after loading into the kernel, this module will take at least 8 MB of memory, and this may be too much for some embedded systems.  And we don‚Äôt forget about the collision :) But for my demo, it all pays off with simplicity and, in addition, <i>DelTable is</i> completely empty. <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*     IP   */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MaxTable 0x1FFFFF uint Table[MaxTable]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* KeyHash -     */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    IP    */</span></span></span><span class="hljs-meta"> uint KeyHash(uint src_IP, ushort src_Port) { return (uint)(((src_IP &amp; 0xFF000000) &gt;&gt; 11) ^ (uint)src_Port) % MaxTable; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* AddTable -  IP     */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     IP    */</span></span></span><span class="hljs-meta"> void AddTable(uint src_IP, ushort src_Port, uint dst_IP) { Table[KeyHash(src_IP, src_Port)] = dst_IP; } void DelTable(uint src_IP, ushort src_Port, uint dst_IP) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*         IP  */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-meta"> } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* ReadTable -  IP   */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    IP    */</span></span></span><span class="hljs-meta"> uint ReadTable(uint src_IP, ushort src_Port) { return Table[KeyHash(src_IP, src_Port)]; }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> That‚Äôs the end of the article, and the only thing left is to connect the client-server Shifter with the core module Shifter. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interaction with kernel module from user space (Netlink) </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now our goal is to create one socket in the Shifter and in the Shifter module and connect them together. </font><font style="vertical-align: inherit;">The exchange protocol between the module and the Shifter server will be simple. </font><font style="vertical-align: inherit;">Shifter will send 4 bytes of client IP and 2 bytes of client port, and the module will respond with 4 bytes of IP destination, taken from its table. </font><font style="vertical-align: inherit;">To do this, use the library Netlink. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I want to note that the header </font></font><u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;linux / netlink.h&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for user applications is </font></font></u> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/usr/include/linux/netlink.h </font></font></i> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and for kernel modules is </font></font></u> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ usr / src / linux-headers- [kernel version] / include / linux / netlink. h </font></font></i> <u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">has many differences</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Netlink in user space </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With regard to netlink from the user space in the network a lot of information, for example, here: </font></font><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 3549 - Linux Netlink as a protocol for IP services </font></font></a> <br> <a href="http://www.programmersclub.ru/%25D0%25A0%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25B0-%25D1%2581-netlink-%25D0%25B2-linux-%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D1%258C-1/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Working with NetLink on Linux.</font></font></a>  <a href="http://www.programmersclub.ru/%25D0%25A0%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25B0-%25D1%2581-netlink-%25D0%25B2-linux-%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D1%258C-1/">Part 1</a> <br> <a href="http://habrahabr.ru/blogs/nix/121254/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A simple monitor of Linux network interfaces, using netlink.</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Therefore, here I will tell only what we need to ensure the exchange of information between the kernel module and user-space programs. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netlink socket is created by the usual function: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int socket (PF_NETLINK, socket_type, netlink_family);</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Where as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">socket_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be used as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOCK_RAW</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOCK_DGRAM</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; nevertheless, the netlink protocol does not draw the line between datagram and raw sockets. And </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">netlink_family</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selects a kernel module or netlink group for communication. The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;linux / netlink.h&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , you can </font></font><a href="http://paste.ubuntu.com/840198/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">view the complete list of families</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netlink messages are a stream of bytes with one or more </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlmsghdr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> headers </font><font style="vertical-align: inherit;">(netlink message header). To access byte streams, only </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NLMSG_ *</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> macros should be used </font><font style="vertical-align: inherit;">. I also want to note that the netlink protocol does not provide guaranteed message delivery. If there is a shortage of memory or other errors, the protocol may drop packets. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider </font></font><a href="http://paste.ubuntu.com/836140/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the sockaddr_nl, nlmsghdr (&lt;linux / netlink.h&gt;), iovec and msghdr (&lt;sys / socket.h&gt;) structures</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that we will work with: </font></font><br><img src="https://habrastorage.org/storage2/496/a98/a9d/496a98a9d087cd0c9ec6ec23d7b6dd63.png"><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct sockaddr_nl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - describes the netlink addresses for user programs and kernel modules. The structure is used to describe the sender or recipient of the data.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sockaddr_nl</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sa_family_t</span></span> nl_family; <span class="hljs-comment"><span class="hljs-comment">/*   AF_NETLINK */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> nl_pad; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> __u32 nl_pid; <span class="hljs-comment"><span class="hljs-comment">/*     0,    ,     */</span></span> __u32 nl_groups; <span class="hljs-comment"><span class="hljs-comment">/* netlink  32 multicast-. nl_groups    ,         ,      */</span></span> };</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct nlmsghdr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the netlink message header and immediately after the structure the sent / received data is located in the memory, to access it, use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NLMSG_DATA (struct nlmsghdr *)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> macro.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nlmsghdr</span></span></span><span class="hljs-class"> {</span></span> __u32 nlmsg_len; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> __u16 nlmsg_type; <span class="hljs-comment"><span class="hljs-comment">/*   () */</span></span> __u16 nlmsg_flags; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> __u32 nlmsg_seq; <span class="hljs-comment"><span class="hljs-comment">/*   (      ) */</span></span> __u32 nlmsg_pid; <span class="hljs-comment"><span class="hljs-comment">/*   (PID),   */</span></span> };</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct iovec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - located in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">msghdr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it will contain a pointer to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlmsghdr</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iovec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * iov_base; <span class="hljs-comment"><span class="hljs-comment">/*    (  nlmsghdr) */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> iov_len; <span class="hljs-comment"><span class="hljs-comment">/*  ()  */</span></span> };</code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct msghdr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - contains a pointer to the address ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sockaddr_nl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and data ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iovec</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msghdr</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * msg_name; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socklen_t</span></span> msg_namelen; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iovec</span></span></span><span class="hljs-class"> * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_iov</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> msg_iovlen; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * msg_control; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> msg_controllen; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> msg_flags; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Consider some Netlink macros: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NLMSG_ALIGN</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rounds the size of the netlink message to the nearest larger value aligned along the boundary. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NLMSG_LENGTH</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Accepts the size of the data field as a parameter and returns the size-aligned value for writing the nlmsghdr header to the nlmsg_len field. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NLMSG_SPACE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Returns the size of the memory (in bytes) that the nlmsghdr structure will take plus the data of the specified length len (in bytes) in the netlink packet. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NLMSG_DATA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct nlmsghdr *nlh)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Returns a pointer to the data associated with the nlmsghdr header passed. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct nlmsghdr *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NLMSG_NEXT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct nlmsghdr *nlh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Returns the next part of a multi-part message. </font><font style="vertical-align: inherit;">The macro accepts the following nlmsghdr header in a message consisting of many parts. </font><font style="vertical-align: inherit;">The calling application should check for the NLMSG_DONE flag in the current nlmsghdr header ‚Äî the function does not return NULL when the message processing is completed. </font><font style="vertical-align: inherit;">The second parameter sets the size of the rest of the message buffer. </font><font style="vertical-align: inherit;">The macro reduces this value by the size of the message header.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NLMSG_OK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct nlmsghdr *nlh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Returns the value TRUE (1) if the message was not truncated and it was successfully disassembled. </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NLMSG_PAYLOAD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct nlmsghdr *nlh, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span></span>;</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Returns the size of the data associated with the nlmsghdr header. </font></font><br><br> <a href="http://paste.ubuntu.com/842612/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Part of the source code of the server Shifter with Netlink.</font></font></a> <br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Netlink Kernel Space </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using the netlink library in kernel modules, there are some differences, for example, the </font></font><a href="http://paste.ubuntu.com/836140/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlmsghdr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><a href="http://paste.ubuntu.com/836140/"><font style="vertical-align: inherit;">from &lt;linux / netlink.h&gt;</font></a><font style="vertical-align: inherit;"> remains the same, but is already wrapped in the well-known </font></font><a href="http://paste.ubuntu.com/842915/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sk_buff</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And instead of the usual functions for working with sockets, we will use a new set of functions.</font></font> Consider some of them. <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In a module, a socket is not represented as an </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> type </font><font style="vertical-align: inherit;">, but as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a sock structure</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;net / sock.h&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="http://paste.ubuntu.com/841349/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">struct sock</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a very big one I will not describe it, besides its description is not needed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a netlink socket, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;linux / netlink.h&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> has the function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">netlink_kernel_create</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It not only creates a netlink socket, but also registers a function that will be called whenever data arrives.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">struct sock *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">netlink_kernel_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( struct net *net, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> unit, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> groups, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*input)(struct sk_buff *skb), struct mutex *cb_mutex, struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To close the netlink socket and remove the "registration function" use: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">netlink_kernel_release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct sock *sk)</span></span></span></span>;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We also need </font></font><a href="http://paste.ubuntu.com/841454/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">functions from &lt;net / netlink.h&gt;</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , there you can find functions with an amazing description. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will simply translate some of the necessary functions:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** * nlmsg_new ‚Äì     netlink  * @payload:    * @flags:     * *  NLMSG_DEFAULT_SIZE,      */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> struct sk_buff *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlmsg_new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> payload, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">gfp_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> alloc_skb(nlmsg_total_size(payload), flags); } <span class="hljs-comment"><span class="hljs-comment">/** * nlmsg_put -    NetLink  skb  * @skb:     netlink  * @pid:   * @seq:    * @type:   * @payload:    ( ) * @flags:   * *  NULL,   skb    , *        netlink , *    netlink  */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> struct nlmsghdr *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlmsg_put</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct sk_buff *skb, u32 pid, u32 seq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> payload, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/** * nlmsg_unicast ‚Äì   netlink  * @sk: netlink  * @skb:    netlink  * @pid: netlink    */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlmsg_unicast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct sock *sk, struct sk_buff *skb, u32 pid)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/** * nlmsg_data ‚Äì      * @nlh:  netlink  */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlmsg_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct nlmsghdr *nlh)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) nlh + NLMSG_HDRLEN; }</code> </pre><br> <a href="http://paste.ubuntu.com/842613/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It remains to add Module Shifter.</font></font></a> <br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In conclusion, in order to redirect packets to the proxy server, it is enough to add a rule to iptables on the gateway: </font></font><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#   nat   (-A)   PREROUTING #   tcp    443    443  iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 443</span></span></code> </pre><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Download Shifter source archive</font></font></a> <br><h5>  The end. </h5><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Used and useful literature </font></font></h4><br> <a href="http://www.netfilter.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NetFilter.org </font></font></a> <br> <a href="http://www.hackzona.ru/hz.php%3Fname%3DNews%26file%3Darticle%26sid%3D3605"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux, Kernel, Firewall </font></font></a> <br> <a href="http://www.linuxjournal.com/node/7356/print"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kernel Korner - </font></font></a> <br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linking Netlink as a protocol for IP services </font></font></a> <br> <a href="http://www.programmersclub.ru/%25D0%25A0%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25B0-%25D1%2581-netlink-%25D0%25B2-linux-%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D1%258C-1/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Working with NetLink on Linux.</font></font></a>  <a href="http://www.programmersclub.ru/%25D0%25A0%25D0%25B0%25D0%25B1%25D0%25BE%25D1%2582%25D0%25B0-%25D1%2581-netlink-%25D0%25B2-linux-%25D0%25A7%25D0%25B0%25D1%2581%25D1%2582%25D1%258C-1/">Part 1</a> <br> <a href="http://www.protocols.ru/modules.php%3Fname%3DNews%26file%3Darticle%26sid%3D67"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux netlink protocol</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/138328/">https://habr.com/ru/post/138328/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138320/index.html">UWDC-2012: Ural conference of web developers or where to spend the weekend</a></li>
<li><a href="../138322/index.html">Course for those who are not afraid of UNIX and C</a></li>
<li><a href="../138323/index.html">Javascript Parser Extension for VisualStudio</a></li>
<li><a href="../138324/index.html">mysqlcheck and optimize InnoDB tables</a></li>
<li><a href="../138325/index.html">Weather for Windows Phone 7. Working with XML</a></li>
<li><a href="../138329/index.html">Distrowatch has a new Russian-Ukrainian distribution: Ubuntu DesktopPack</a></li>
<li><a href="../138330/index.html">Piwik 1.7</a></li>
<li><a href="../138331/index.html">Thoughts on screenshots via javascript</a></li>
<li><a href="../138332/index.html">Google has replaced YouTube video rating buttons.</a></li>
<li><a href="../138333/index.html">Java Day 2012. Impressions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>