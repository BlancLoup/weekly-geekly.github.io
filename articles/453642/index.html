<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Smart parser of the number written in words</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 


 Good afternoon, dear readers. In this article, I will talk about how to parse a number written in Russian. 


 Smart this parser makes th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Smart parser of the number written in words</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/x_/al/d2/x_ald2dbs-mrb8gyk1v9z7fzk9w.png"><br><br><h1>  Prologue </h1><br><p>  Good afternoon, dear readers.  In this article, I will talk about how to parse a number written in Russian. </p><br><p>  Smart this parser makes the ability to extract numbers from text with errors made as a result of incorrect input or as a result of optical text recognition from the image (OCR). </p><br><p>  For the lazy: <br>  Link to github project: <a href="">link</a> . </p><br><a name="habracut"></a><br><h1>  From algorithm to result </h1><br><p>  In this section, the algorithms used will be described.  Careful, many letters! </p><br><h2>  Formulation of the problem </h2><br><p>  At work, I need to recognize the text from a printed document, photographed by the camera of a smartphone / tablet.  Because of the non-disclosure agreement, I cannot give an example of a photograph, but the point is that there is a table in the document in which certain indicators are written in numbers and words, and these data must be read.  Text parsing in words is required as an additional validation tool to ensure that the number is recognized correctly.  But, as you know, OCR does not guarantee accurate text recognition.  For example, the number twenty, written in words, can be recognized as ‚Äútwenty‚Äù or even as ‚Äútwo-fold‚Äù.  It is necessary to take this into account and extract the maximum amount of information, estimating the magnitude of the possible error. </p><br><p>  <b>Note.</b>  For text recognition, I use tesseract 4. For .NET there is no ready-made NuGet package of the fourth version, so I created one from a branch of the main project, who could be useful: <a href="https://www.nuget.org/packages/Genesis.Tesseract4/">Genesis.Tesseract4</a> . </p><br><br><h2>  Basic number parsing algorithm </h2><br><p>  Let's start with a simple one, namely with the text recognition algorithm written in words, so far without errors.  If you are interested in smart parsing, you can skip this section. </p><br><p>  I am not particularly strong in Google, so I did not immediately find a ready-made algorithm for solving this problem.  However, this is even better, because  the algorithm, invented by himself, gives more room for coding.  And the task itself turned out to be interesting. </p><br><p>  So, take a small number, for example, "one hundred twenty three."  It consists of three words ( <i>tokens</i> ), each of which corresponds to a number, all these numbers are summed up: </p><br> <code>"  " =  +  +  = 100 + 20 + 3 = 123</code> <br> <br><p>  So far, everything is simple, but let's dig deeper, for example, consider the number "two hundred and twelve thousand one hundred and five." </p><br> <code>"    " = ( + ) √ó  + ( + ) = 212 * 1.000 + 105 = 212.105.</code> <br> <br><p>  As you can see, when there are thousands in the number (as well as millions and other degrees of thousands), the number is divided into parts consisting of a local small number, in the example above - 212, and a multiplier (1000).  There may be several such fragments, but they all go in descending order of a multiplier, for example, a thousand cannot be followed by a million or another thousand.  This is also true for parts of a small number, so hundreds cannot follow hundreds, and tens after tens, therefore the one hundred five hundred record is incorrect.  The characteristic relating two tokens to one type is called a <i>level</i> , for example, one hundred and three hundred tokens have one level, and it is more than the fifty level token. </p><br><p>  From these arguments, the idea of ‚Äã‚Äãthe algorithm is born.  Let's write out all the possible tokens ( <i>samples</i> ), each of which will be assigned a number, as well as two parameters - the level and the sign of the multiplier. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token </th><th>  Number </th><th>  Level </th><th>  Factor? </th></tr><tr><td>  zero <br></td><td>  0 <br></td><td>  one <br></td><td>  not <br></td></tr><tr><td>  one / one <br></td><td>  one <br></td><td>  one <br></td><td>  not <br></td></tr><tr><td>  two / two <br></td><td>  2 <br></td><td>  one <br></td><td>  not <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  one <br></td><td>  not <br></td></tr><tr><td>  nineteen <br></td><td>  nineteen <br></td><td>  one <br></td><td>  not <br></td></tr><tr><td>  twenty <br></td><td>  20 <br></td><td>  2 <br></td><td>  not <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  2 <br></td><td>  not <br></td></tr><tr><td>  ninety <br></td><td>  90 <br></td><td>  2 <br></td><td>  not <br></td></tr><tr><td>  hundred <br></td><td>  100 <br></td><td>  3 <br></td><td>  not <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  3 <br></td><td>  not <br></td></tr><tr><td>  nine hundreds <br></td><td>  900 <br></td><td>  3 <br></td><td>  not <br></td></tr><tr><td>  thousand / thousand / thousand <br></td><td>  1,000 <br></td><td>  four <br></td><td>  Yes <br></td></tr><tr><td>  million / million / million <br></td><td>  1,000,000 <br></td><td>  five <br></td><td>  Yes <br></td></tr><tr><td>  ... <br></td><td>  ... <br></td><td>  ... <br></td><td>  Yes <br></td></tr><tr><td>  quadrillion / quadrillion / quadrillion <br></td><td>  1,000,000,000,000,000 <br></td><td>  eight <br></td><td>  Yes <br></td></tr></tbody></table></div><br><p>  In fact, you can add any other tokens to this table, including for foreign languages, just do not forget that in some countries a long rather than a short <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D1%258B_%25D0%25BD%25D0%25B0%25D0%25B8%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F_%25D1%2587%25D0%25B8%25D1%2581%25D0%25B5%25D0%25BB">system for naming numbers is used</a> . </p><br><p>  Now let's move on to parsing.  Let's get four values: </p><br><ol><li>  <i>Global level</i> (globalLevel).  Indicates which level was at the last multiplier.  Initially not defined and necessary for control.  If we encounter a token-factor that has a level greater than or equal to the global one, then this is a mistake. </li><li>  <i>Global value</i> (globalValue).  Total adder, where the result of multiplying the local number and the multiplier is added. </li><li>  <i>Local level</i> (localLevel).  Indicates what level the last token was.  Initially undefined, works similarly to the global level, but is reset after detecting a multiplier. </li><li>  <i>Local value</i> (localValue).  Non-multiplier tokens, i.e.  numbers up to 999. </li></ol><br><p>  The algorithm is as follows: </p><br><ol><li>  We divide the string into tokens using the regular "\ s +". </li><li>  We take another token, we get information about it from the sample. </li><li>  If this is a multiplier: <br><ul><li>  If the global level is set, then we make sure that it is greater than or equal to the token level.  If not - this is an error, the number is incorrect. </li><li>  Set the global level to the current token level. </li><li>  Multiply the value of the token by the local value and add the result to the global value. </li><li>  Clear local value and level. </li></ul></li><li>  If it is not a multiplier: <br><ul><li>  If the local level is set, then we make sure that it is greater than or equal to the token level.  If not - this is an error, the number is incorrect. </li><li>  Set the local level to the current token level. </li><li>  We add to the local value the value of the token. </li></ul></li><li>  We return the result as the sum of global and local values. </li></ol><br><p>  Example of work for the number ‚Äútwo million two hundred twelve thousand one hundred eighty five‚Äù. </p><br><div class="scrollable-table"><table><tbody><tr><th>  Token <br></th><th>  globalLevel <br></th><th>  globalValue <br></th><th>  localLevel <br></th><th>  localValue <br></th></tr><tr><td></td><td>  - <br></td><td>  - <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  two <br></td><td>  - <br></td><td>  - <br></td><td>  one <br></td><td>  2 <br></td></tr><tr><td>  million <br></td><td>  five <br></td><td>  2,000,000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  two hundred <br></td><td>  five <br></td><td>  2,000,000 <br></td><td>  3 <br></td><td>  200 <br></td></tr><tr><td>  twelve <br></td><td>  five <br></td><td>  2,000,000 <br></td><td>  one <br></td><td>  212 <br></td></tr><tr><td>  thousand <br></td><td>  four <br></td><td>  2.212.000 <br></td><td>  - <br></td><td>  - <br></td></tr><tr><td>  hundred <br></td><td>  four <br></td><td>  2.212.000 <br></td><td>  3 <br></td><td>  100 <br></td></tr><tr><td>  eighty <br></td><td>  four <br></td><td>  2.212.000 <br></td><td>  2 <br></td><td>  180 <br></td></tr><tr><td>  five <br></td><td>  four <br></td><td>  2.212.000 <br></td><td>  one <br></td><td>  185 <br></td></tr></tbody></table></div><p>  The result will be 2.212.185. </p><br><h2>  Smart parsing </h2><br><p>  This algorithm can be used to implement other comparisons, and not just for parsing numbers, for this reason I will try to describe it in as much detail as possible. </p><br><p>  With parsing correctly recorded numbers sorted out.  Now let's think about what errors can occur if the number of the resulting OCR is incorrect.  I do not consider other options, but you can modify the algorithm for a specific task. </p><br><p>  I identified three types of errors encountered in the process: </p><br><ol><li>  Replacing characters with others with similar outlines.  For example, the letter "u" for some reason is replaced by "p", and "n" by "i" and vice versa.  When using the third version of tesseract, it is possible to replace the letter ‚Äúo‚Äù with a zero.  These errors, offhand, are the most common, and require tuning for a specific recognition library.  So, the principles of operation of tesseract versions 3 and 4 have cardinal differences, therefore the errors will be different there. <br></li><li>  Merge tokens.  Words can merge together (the reverse has not yet met).  In combination with the first error, it spawns demonic phrases like ‚Äúdvupatipodin.‚Äù  Let's try to irritate such monsters. <br></li><li>  Noise - left characters and phrases in the text.  Unfortunately, there is little that can be done at the moment, but the prospect is when collecting enough weighty statistics. <br></li></ol><br><p>  At the same time, the parsing algorithm itself described above almost does not change, the main difference is in splitting a string into tokens. </p><br><p>  But let's start with collecting small statistics on the use of letters in tokens.  Of the 33 letters of the Russian language, when writing non-negative integers, only 20 are used, let's call them <i>good letters</i> : </p><br> <code></code> <br> <br><p>  The remaining 13, respectively, will be called <i>bad letters</i> .  The maximum size of the token is 12 characters (13 when counting up to quadrillion).  Substrings longer than this value must be split. </p><br><p>  To match strings and tokens, I decided to use <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B0%25D1%2581%25D1%2581%25D1%2582%25D0%25BE%25D1%258F%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259B%25D0%25B5%25D0%25B2%25D0%25B5%25D0%25BD%25D1%2588%25D1%2582%25D0%25B5%25D0%25B9%25D0%25BD%25D0%25B0">the Wagner-Fisher algorithm</a> , although I called it the name of Levenshteyn in code.  I do not need the pre-prescription, so I implemented the economical version of the algorithm.  I must admit that the implementation of this algorithm turned out to be more difficult than the parser itself. </p><br><p>  A small educational program: Levenshtein distance is a special case of the Wagner-Fisher algorithm, when the cost of inserting, deleting and replacing characters is static.  In our problem it is not.  Obviously, if in the substring we meet a bad letter, then it must be replaced with a good one, but it is extremely undesirable to replace the good with the bad.  Generally speaking, it is impossible, but the situation depends on the specific task. </p><br><p>  To describe the cost of inserting, deleting and replacing characters, I created the following table: a <a href="https://docs.google.com/spreadsheets/d/11xt0z02Q4BqG6McHkpGqqqQ2G78uCRxBt1coHpEUg7Y/edit">link to a table with weights</a> .  While it is filled with the method of three P (floor, finger, ceiling), but if you fill it with data based on OCR statistics, you can significantly improve the quality of number recognition.  The library code contains the resource file NumeralLevenshteinData.txt, into which you can insert data from a similar table using Ctrl + A, Ctrl + C and Ctrl + V. </p><br><p>  If the text contains a non-tabular symbol, for example, zero, then the cost of inserting it equals the maximum value from the table, and the cost of deletion and replacement - to the minimum, so the algorithm is more likely to replace zero with the letter ‚Äúo‚Äù, and if you use the third version of tesseract it makes sense to add a zero to the table and set the minimum price for replacing it with the letter ‚Äúo‚Äù. </p><br><p>  So, we have prepared the data for the Wagner-Fisher algorithm; let's make changes to the algorithm for splitting a string into tokens.  To do this, we will subject each token to additional analysis, but before that we expand the information on the token with the following characteristics: </p><br><ul><li>  <i>Error level</i>  A real number from 0 (no error) to 1 (the token is incorrect), meaning how well the token was matched to the sample. <br></li><li>  <i>Sign of using a token</i> .  When parsing a line with interspersing garbage, some tokens will be discarded, for them this feature will not be displayed.  In this case, the total error value will be calculated as the arithmetic average of the errors of the used tokens. <br></li></ul><br><p>  Algorithm for analyzing tokens: </p><br><ol><li>  We are trying to find the token in the table as it is.  If we find everything is fine, we return it. </li><li>  If not, we make a list of possible options: </li><li><p>  We are trying to match the token with the sample using the Wagner-Fisher algorithm.  This variant consists of a single token (associated sample) and its error is equal to the best distance divided by the sample length. </p><br>  <b>Example: the</b> ‚Äúzero‚Äù token is matched with the ‚Äúzero‚Äù sample, while the distance is equal to 0.5, since  the cost of replacing a bad letter ‚Äúy‚Äù with a good ‚Äúo‚Äù is 0.5.  The total error for this token will be 0.5 / 4 = 0.125. <br></li><li><p>  If the substring is large enough (I have 6 characters), try to divide it into two parts with at least 3 characters each.  For a string of 6 characters will be the only option of division: 3 + 3 characters.  For a string of 7 characters, there are already two options, 3 + 4 and 4 + 3, and so on.  For each of the options, we recursively call the same function of the analysis of tokens, put the obtained variants into the list. </p><br><p>  In order not to die in recursion, we determine the maximum level of falling through.  In addition, the options obtained as a result of the division artificially worsen by a certain amount (optional, default 0.1), so that the direct comparison option is more valuable.  This operation had to be added, because  substrings of type ‚Äútwo-fold‚Äù were successfully divided into tokens ‚Äútwo‚Äù and ‚Äúfive‚Äù, and not resulted in ‚Äútwenty‚Äù.  Alas, these are the features of the Russian language. </p><br><p>  <b>Example: the</b> ‚Äútwo-way‚Äù token has a direct comparison with the sample ‚Äútwenty‚Äù, an error is 0.25.  In addition, the best division is ‚Äútwo‚Äù + ‚Äúfive‚Äù costing 0.25 (replacing ‚Äúa‚Äù with ‚ÄúI‚Äù), artificially deteriorated to 0.35, with the result that the token ‚Äútwenty‚Äù is preferred. </p><br></li><li>  After compiling all the options, choose the best by the minimum amount of errors of the tokens participating in it.  The result is returned. </li></ol><br><p>  In addition, a check of tokens is entered into the main number generation algorithm so that their error does not exceed a certain value (optional, default 0.67).  With this, we screen out potential garbage, although not very successfully. </p><br><h2>  Algorithm in a nutshell for those who were too lazy to read the text above </h2><br><p>  We divide the incoming string representing the number in words into substrings using the regular \ s +, then we try to match each of the substrings with sample tokens or break them into smaller substrings, choosing the best results.  As a result, we obtain a set of tokens by which we generate a number, and the error value is taken as the arithmetic average of the errors among the tokens used during the generation. </p><br><h2>  Sharpening the algorithm for a specific task </h2><br><p>  In my task, the numbers are non-negative and relatively small, so I will exclude unnecessary tokens from the "million" and above.  For the test, dear readers, I, on the contrary, added additional tokens-slang, which allowed parsing lines like ‚Äúfive pieces‚Äù, ‚Äúmower two hundred‚Äù and even ‚Äúthree stolnik and two gold pieces‚Äù.  It's funny, but it didn't even require changes in the algorithm. </p><br><h2>  Further improvement </h2><br><p>  The existing algorithm has some flaws: </p><br><ol><li>  <b>Control of cases</b>  The lines ‚Äútwo thousand‚Äù and ‚Äútwo thousand‚Äù will be recognized as 2000 with zero error. In my task, case control is not required, it is even harmful, but if you need such a function, this is solved by introducing an additional flag to the token responsible for the case of the next token . <br></li><li>  <b>Negative numbers.</b>  Introduced an additional token "minus" with special processing.  Nothing complicated, but do not forget that the letter ‚Äúy‚Äù is bad and does not occur in numerals, you will need to change its weight characteristics or hope that it will not change in the OCR process. <br></li><li>  <b>Fractional numbers.</b>  It is solved by replacing the long type with double and introducing ‚Äútenths,‚Äù ‚Äúhundredths‚Äù, etc. tokens ... Don't forget to revise the weights of letters. <br></li><li>  <b>Recognition of numbers entered by users.</b>  Because  When typing text manually, we most often make mistakes related to perevodovka ciBolov, this operation should be added to the Wagner-Fisher algorithm. <br></li><li>  <b>Support for other languages.</b>  We introduce new tokens, expand the weights table. <br></li><li>  <b>Handling trash.</b>  In some documents there is a seal on the data, the quality of the image can be bad, the cell can be tritely empty.  In this case, the line gets garbage that you need to somehow clean.  The best I can offer at the moment is to pre-process the document before OCR.  I was greatly helped by removing the lines of the table and filling them with a color close to the color of the free space of the cell.  This did not solve all the problems, but improved the quality of text recognition from documents where the table had curvatures due to the bruise of the document or the crooked photographer.  Ideally, you should turn the cell itself and recognize it separately, if you, of course, have a table at all. <br></li></ol><br><h1>  So what is the result? </h1><br><p>  The project has an example of a console application running through the samples.txt file with examples for the parser.  Here is a screenshot of the results: </p><br><img src="https://habrastorage.org/webt/fq/ed/ac/fqedacgduf7tewa8tvg-tn6zv3s.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  I charge you with evaluating the result, but as for me, it is not bad.  The magnitude of the error for real recognition examples does not exceed 0.25, although I have not yet chased away the entire set of available documents, probably not everything will be so smooth there. </p><br><p>  As for the last section, I was always wondering how much this is ‚Äúdofiga‚Äù.  Also, the program gave itself quite an adequate answer, how many should I take for the road (I do not use, but still) and even accurately determined the meaning of the old Russian word ‚Äúdarkness‚Äù.  And yes, one more measure was not included in the conclusion, which education did not allow to add, but the program considers that it is equal to a thousand =) </p><br><h1>  A few words about the library </h1><br><p>  Initially, my plans did not include the creation of a library, I decided to issue it exclusively for Habr.  I tried to put the code in order, but if you use it, fork or copy, because  most likely you will not need jargon and other tokens included in the examples. </p><br><p>  The library itself is written under .NET Standart 2.0 and C # 7.x, and the algorithms are easily translated into other languages. </p><br><p>  In case of a possible library extension, I will add the composition of the important components of the number parser in words (namespace Genesis.CV.NumberUtils): </p><br><ul><li>  RussianNumber.cs - directly parser </li><li>  RussianNumber.Data.cs - file with description of tokens </li><li>  RussianNumber.ToString.cs - convert text to text in words </li><li>  RussianNumberParserOptions.cs - parser options </li><li>  NumeralLevenshtein.cs - implementation of the Wagner-Fisher algorithm </li><li>  NumeralLevenshteinData.txt - resource, data of weights of letters </li></ul><br><p>  Using: </p><br><ul><li>  RussianNumber.ToString (value) - convert numbers to text </li><li>  RussianNumber.Parse (value, [options]) - convert text to number </li></ul><br><h1>  Conclusion </h1><br><p>  I really hope that the article did not seem boring to you, despite the abundance of text.  Recently, I have a lot of topics related to computer vision, which have something to say, so I would like to know the opinion about this format of articles.  What should I add or, on the contrary, delete?  What is more interesting for you, the readers, the algorithms themselves or code fragments? </p><br><p>  Like this article?  See others: </p><br><ul><li>  <a href="https://habr.com/ru/post/413113/">Class serialization on JavaScript with support for circular references</a> <br></li><li>  <a href="https://habr.com/ru/post/251765/">Filling text templates with model-based data.</a>  <a href="https://habr.com/ru/post/251765/">Implementing on .NET using dynamic functions in bytecode (IL)</a> <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/453642/">https://habr.com/ru/post/453642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453610/index.html">How to sell SD-WAN business</a></li>
<li><a href="../453614/index.html">Local (offline) npm repository</a></li>
<li><a href="../453622/index.html">G-Shield chip programmer: writing digital certificates to chips during production</a></li>
<li><a href="../453626/index.html">Adventures in a separate stream. Yandex report</a></li>
<li><a href="../453634/index.html">School of Systems Analysis Alfa-Bank</a></li>
<li><a href="../453644/index.html">Interview - 10 questions about Swift. Part 3</a></li>
<li><a href="../453652/index.html">LogRock: Testing through logging</a></li>
<li><a href="../453656/index.html">Static web: back to basics?</a></li>
<li><a href="../453660/index.html">Intel showed a new i9-9900KS processor with a turbo-frequency of 5 GHz per core</a></li>
<li><a href="../453662/index.html">Mars - more ice around the North Pole, but deep</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>