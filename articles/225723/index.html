<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to use Tomita-parser in your projects. Practical course</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, my name is Natalya, I work in Yandex as a developer in the fact extraction team. In the spring, we talked about what a Tomita-parser is and why it...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to use Tomita-parser in your projects. Practical course</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi, my name is Natalya, I work in Yandex as a developer in the fact extraction team.  In the spring, we <a href="http://habrahabr.ru/company/yandex/blog/219311/">talked</a> about what a Tomita-parser is and why it is used in Yandex.  And this fall, the source of the parser will be posted in open access. <br><br>  In the previous post, we promised to tell you how to use the parser and the syntax of its internal language.  This is what my today's story is about. </p><br><br><p> <a href="http://habrahabr.ru/company/yandex/blog/225723/"><img src="https://habrastorage.org/getpro/habr/post_images/992/ac9/cee/992ac9cee7c82cc5c39f9d02c190cfaa.png" width="640"></a> </p>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  After reading this post, you will learn how dictionaries and grammars are compiled for Tomita, as well as how to extract facts from natural language texts with their help.  The same information is available in the format of a small <a href="http://api.yandex.ru/tomita/doc/video/">video course</a> . <br><a name="habracut"></a><br></p><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  A grammar is a set of rules that describe a string of words in a text.  For example, if we have the sentence ‚ÄúI like that you are not sick of me,‚Äù it can be described using the chain [first person pronoun, singular], [present tense verb and third person], [comma], [union] etc. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e26/3f8/1ad/e263f81ad9582498830017e581c0c4fa.png" width="640"></p><br><br><p> Grammar is written in a special formal language.  Structurally, the rule is divided by the symbol <code>-&gt;</code> into the left and right parts.  On the left side there is one non-thermal, and the right consists of both terminals and non-terminals.  The terminal in this context is a certain object that has a specific, immutable value.  The set of terminals is the alphabet of the Tomit language, from which all the other words are built.  The terminals in Tomit are the 'lemmas' - words in the initial form, written in single quotes, parts of speech ( <code>Noun, Verb, Adj</code> ...), punctuation marks ( <code>Comma, Punct, Hyphen</code> ...) and some other special characters ( <code>Percent, Dollar</code> ...).  There are about twenty total terminals in Tomit, a complete list is presented in our documentation.  Non-terminals are made up of terminals, and if we draw an analogy with natural languages, they are something like words.  For example, the nonterminal NounPhrase, consisting of two terminals <code>Adj</code> and <code>Noun</code> , means a chain of two words: first an adjective, then a noun. </p><br><br><p>  To compose our first grammar, you need to create a file with the extension .cxx, let's call it first_grammar.  You can save it in the same place where the parser binary itself is located.  In the first line of the grammar file you need to specify the encoding: </p><br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#encoding </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"utf8"</span></span></span></span></code> </pre> <br><p>  Then you can write the rules.  In our first grammar there will be two: </p><br><br><pre> <code class="hljs erlang-repl">PP -&gt; Prep Noun; S -&gt; Verb PP;</code> </pre><br><p>  The first rule describes the nonterminal <code>PP</code> - a prepositional group consisting of a preposition and a noun ( <code>Prep Noun</code> ).  The second rule is a verb with a prepositional group ( <code>Verb PP</code> ).  In this case, the non-terminal <code>S</code> is root, because it is never mentioned on the right side of the rule.  Such a non-terminal is called a treetop.  It describes the entire chain that we want to extract from the text. </p><br><br><p>  Our first grammar is ready, but before you run the parser, you need to do a few more manipulations.  The fact is that grammar interacts with the parser not directly, but through the root dictionary - an entity that collects information about all the created grammars, dictionaries, additional files, etc.  Those.  The root dictionary is a kind of aggregator of everything that is created within the project.  Dictionaries for Tomita-Parser are written using syntax similar to Google Protobuf (using a modified version of the Protobuf compiler, with support for inheritance).  Files are usually given the extension .gzt.  Create the root dictionary dic.gzt and in the beginning also specify the encoding: </p><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">encoding</span></span> "utf8";</code> </pre> <br><p>  After that, we import into the root dictionary files containing the base types used in dictionaries and grammars.  For convenience, these files are stored in the parser's binary, and we can import them directly, without setting the path to them: </p><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "base.proto"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "article_base.proto";</code> </pre> <br><p>  Next we create an article.  A dictionary entry describes how to highlight a string of words in a text.  Grammar is one of the possible ways.  You can select a chain using the list of keywords built into the algorithm's parser (the name and date chains).  Other methods can be added at the source level of the parser (for example, the statistical named entity recognizer).  The article consists of type, title and content.  What types of articles are and what they are for, I will discuss below when we talk more about dictionaries.  For now, we'll use the basic type of <code>TAuxDicArticle</code> .  The name of the article must be unique, it is indicated in quotes after the type.  Further, in curly brackets are listed the keys - the content of the article.  In our case, the only key contains a reference to the grammar written by us.  First, we specify the syntax of the file to which we refer (in the case of a file with a grammar it is always <code>tomita</code> ) and the path to this file, then in the <code>type</code> field - the type of the key (it must be indicated if the key contains a link to the grammar). </p><br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">TAuxDicArticle</span></span> <span class="hljs-string"><span class="hljs-string">"_"</span></span> { key = {<span class="hljs-string"><span class="hljs-string">"tomita:first_grammar.cxx"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CUSTOM</span></span></span><span class="hljs-class">} }</span></span></code> </pre><br><p>  To tell the parser where we get the source text, where we write the result, what grammars we run, what facts we extract, as well as other necessary information, we create a single configuration file with the .proto extension.  Create a config.proto file in the parser folder.  As usual, at the beginning we specify the encoding and proceed to the description of our configuration. </p><br><br><p>  The only required parameter of the configuration file is the path to the root dictionary, which is written in the Dictionary field.  All other parameters are optional.  Information about the input file is in the <code>Input</code> field.  In addition to text files, Tomit can also input a folder, an archive or stdin.  The <code>Output</code> field records where and in what format (text, xml or protobuf) the extracted facts should be saved.  We will send the <a href="https://yadi.sk/d/zPCcCqh8TYZWS">input.txt</a> file to the <a href="https://yadi.sk/d/zPCcCqh8TYZWS">input</a> .  The <code>Articles</code> field lists the grammars we want to run.  Please note that here we indicate not the grammar file itself, but the title of the article from the dictionary, which contains a link to this file: as we have said, the parser interacts with all project files indirectly through the root dictionary. </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">encoding</span></span> <span class="hljs-string"><span class="hljs-string">"utf8"</span></span>; <span class="hljs-section"><span class="hljs-section">TTextMinerConfig</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">Dictionary</span></span> = <span class="hljs-string"><span class="hljs-string">"dic.gzt"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">Input</span></span> = {<span class="hljs-attribute"><span class="hljs-attribute">File</span></span> = <span class="hljs-string"><span class="hljs-string">"input.txt"</span></span>} Output = {<span class="hljs-attribute"><span class="hljs-attribute">File</span></span> = <span class="hljs-string"><span class="hljs-string">"output.txt"</span></span> Format = text} Articles = [ { <span class="hljs-attribute"><span class="hljs-attribute">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"_"</span></span> } ] }</code> </pre><br><p>  Now that the configuration file is ready, we have to put the text file for analysis next to the binary (you can use our test file or take your own) and you can proceed to launch the grammar.  In the terminal, go to the folder where our parser is located.  The parser starts with a single argument ‚Äî the name of the configuration file.  Accordingly, in * NIX-systems, the command to start will look like this: </p><br><br><pre> <code class="hljs lua">./tomitaparser <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>.proto</code> </pre> <br><p>  The results can be found in the file output.txt.  However, we will not see any extracted facts there, because in our grammar there are only rules for identifying chains, and in order for the selected chains to turn into structured facts, we must add an interpretation procedure.  We will talk about it below.  However, we can see the selected chains already at this stage, for this we need to add another parameter to the configuration file - debug output: </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">PrettyOutput</span></span> = <span class="hljs-string"><span class="hljs-string">"pretty.html"</span></span></code> </pre> <br><p>  Thanks to this parameter, the results of the parser will be recorded in an html-file with a more visual representation.  Now, if we restart the grammar and open the pretty.html file that appeared in the folder, we will see that we have extracted all the chains we described in the grammar ‚Äî the verbs, followed by a noun with the preposition: </p><br><br><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><table border="1"><tbody><tr><td>  to go on the slats </td></tr><tr><td>  stop near dukhan </td></tr><tr><td>  stay overnight </td></tr><tr><td>  walk up to him </td></tr><tr><td>  go to Stavropol </td></tr><tr><td>  move with </td></tr><tr><td>  take on vodka </td></tr><tr><td>  come on line </td></tr><tr><td>  do against the highlanders </td></tr><tr><td>  reckon in the third </td></tr><tr><td>  follow the day </td></tr><tr><td>  to be in the south </td></tr><tr><td>  go to the mountain </td></tr><tr><td>  look back on the valley </td></tr><tr><td>  demand vodka </td></tr><tr><td>  look at the captain </td></tr><tr><td>  bump into a cow </td></tr><tr><td>  shelter by the fire </td></tr><tr><td>  be in Chechnya </td></tr><tr><td>  step back </td></tr><tr><td>  pull out of the suitcase </td></tr><tr><td>  regret </td></tr><tr><td>  go out in front </td></tr><tr><td>  put on trial </td></tr><tr><td>  to be visiting </td></tr><tr><td>  stand in a fortress </td></tr><tr><td>  settle in a fortress </td></tr><tr><td>  walk on a boar </td></tr><tr><td>  burst out laughing </td></tr><tr><td>  be in it </td></tr><tr><td>  be on money </td></tr><tr><td>  clap </td></tr><tr><td>  look at this </td></tr><tr><td>  run after the owner </td></tr><tr><td>  to become in the hut </td></tr><tr><td>  go on the air </td></tr><tr><td>  go to the mountains </td></tr><tr><td>  Wade along fence </td></tr><tr><td>  to be behind the Terek </td></tr><tr><td>  ride with abreks </td></tr><tr><td>  jump over stumps </td></tr><tr><td>  follow the tracks </td></tr><tr><td>  hang on the front </td></tr><tr><td>  fly into the ravine </td></tr><tr><td>  kill to death </td></tr><tr><td>  drag on the steppe </td></tr><tr><td>  run along the shore </td></tr><tr><td>  fly from under the hooves </td></tr><tr><td>  shine in the dark </td></tr><tr><td>  zazvenet about chain mail </td></tr><tr><td>  hit the fence </td></tr><tr><td>  rush into the stable </td></tr><tr><td>  grab your guns </td></tr><tr><td>  spin among the crowd </td></tr><tr><td>  put in a stranger </td></tr><tr><td>  talk about something else </td></tr><tr><td>  come from love </td></tr><tr><td>  jump in the village </td></tr><tr><td>  leave the fortress </td></tr><tr><td>  change in the face </td></tr><tr><td>  jump over a gun </td></tr><tr><td>  gallop on dashing </td></tr><tr><td>  snatch from cover </td></tr><tr><td>  fall to the ground </td></tr><tr><td>  come to the fortress </td></tr><tr><td>  ride on it </td></tr><tr><td>  go to the village </td></tr><tr><td>  go to him </td></tr><tr><td>  stand at a dead end </td></tr><tr><td>  stand at a dead end </td></tr><tr><td>  sit in the corner </td></tr><tr><td>  wither in captivity </td></tr><tr><td>  look out the window </td></tr><tr><td>  sit on a stove bench </td></tr><tr><td>  go to him </td></tr><tr><td>  hit hands </td></tr><tr><td>  to be able to crack </td></tr><tr><td>  dream in a dream </td></tr><tr><td>  wait by the road </td></tr><tr><td>  be at dusk </td></tr><tr><td>  dive from the bush </td></tr><tr><td>  see from the hillock </td></tr><tr><td>  chomp in the snow </td></tr><tr><td>  get out of the hut </td></tr><tr><td>  go out as </td></tr><tr><td>  to set off </td></tr><tr><td>  to get exhausted </td></tr><tr><td>  lead to heaven </td></tr><tr><td>  disappear into the cloud </td></tr><tr><td>  rest on top </td></tr><tr><td>  crunch under your feet </td></tr><tr><td>  surging into the head </td></tr><tr><td>  fall away from the heart </td></tr><tr><td>  climb the Good Mountain </td></tr><tr><td>  get off the shelf </td></tr><tr><td>  descend from Hood Mountain </td></tr><tr><td>  come from the word </td></tr><tr><td>  fall under your feet </td></tr><tr><td>  turn into ice </td></tr><tr><td>  hide in the fog </td></tr><tr><td>  beat the bars </td></tr><tr><td>  stop in the weather </td></tr><tr><td>  give vodka </td></tr><tr><td>  play out on the cheeks </td></tr><tr><td>  announce death </td></tr><tr><td>  wash for the boars </td></tr><tr><td>  go beyond the serf </td></tr><tr><td>  walk around the room </td></tr><tr><td>  sit on the bed </td></tr><tr><td>  drag in the mountains </td></tr><tr><td>  fall on the bed </td></tr><tr><td>  be in September </td></tr><tr><td>  walk along the serf </td></tr><tr><td>  sit on the sod </td></tr><tr><td>  to be from the shaft </td></tr><tr><td>  sit on the corner </td></tr><tr><td>  stand still </td></tr><tr><td>  stand on stirrups </td></tr><tr><td>  come back from hunting </td></tr><tr><td>  to be behind the river </td></tr><tr><td>  bet </td></tr><tr><td>  change to this </td></tr><tr><td>  carry on the hunt </td></tr><tr><td>  yearn for home </td></tr><tr><td>  put in that </td></tr><tr><td>  leave custody </td></tr><tr><td>  go to America </td></tr><tr><td>  die on the road </td></tr><tr><td>  to be in the capital </td></tr><tr><td>  to come from drinking </td></tr><tr><td>  to be a wonder </td></tr><tr><td>  dart through the reeds </td></tr><tr><td>  go to the reeds </td></tr><tr><td>  get together </td></tr><tr><td>  specify in the field </td></tr><tr><td>  tear from the saddle </td></tr><tr><td>  compare with Pechorin </td></tr><tr><td>  stick with a gun </td></tr><tr><td>  fall on your knees </td></tr><tr><td>  to hold on hands </td></tr><tr><td>  climb a cliff </td></tr><tr><td>  jump off the horses </td></tr><tr><td>  pour out of the wound </td></tr><tr><td>  be memoryless </td></tr><tr><td>  put him </td></tr><tr><td>  send for a doctor </td></tr><tr><td>  get out of the fortress </td></tr><tr><td>  sit on a rock </td></tr><tr><td>  drag in the bushes </td></tr><tr><td>  jump on horse </td></tr><tr><td>  sit by the bed </td></tr><tr><td>  turn to the wall </td></tr><tr><td>  want to go to the mountains </td></tr><tr><td>  meet soul </td></tr><tr><td>  will be in paradise </td></tr><tr><td>  come to the idea </td></tr><tr><td>  die in that </td></tr><tr><td>  kneel down </td></tr><tr><td>  go to serf </td></tr><tr><td>  die with grief </td></tr><tr><td>  sit on the ground </td></tr><tr><td>  run over the skin </td></tr><tr><td>  to bury behind the fortress </td></tr><tr><td>  go to Georgia </td></tr><tr><td>  return to Russia </td></tr><tr><td>  part with maxim </td></tr></tbody></table></div></div><br><br><p>  The parser tries to normalize the extracted chains, leading the main word of the chain (the first by default) to the initial form. </p><br><br><p>  The next step is the introduction of an interpretation procedure, i.e.  conversion of extracted chains into facts. </p><br><br><p>  First we need to create a structure of the fact that we want to extract, i.e.  describe what fields it consists of.  To do this, create a new fact_types.proto file.  Again, we will import the files with the basic types, and then proceed to the description of the fact.  After the word message, the name of the fact, the colon and the base type of the fact from which the type of our fact is inherited is written.  Next, in curly brackets, we list the fields of our fact.  In our case, the field is one, it is required (required), the text (string) is called <code>Field1</code> and we assign it the identifier 1. </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">import</span></span> <span class="hljs-string"><span class="hljs-string">"base.proto"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">import</span></span> <span class="hljs-string"><span class="hljs-string">"facttypes_base.proto"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Fact: NFactType.TFact { <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> string Field1 = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><p>  Now we need to import the file we created into the root dictionary (dic.gzt): </p><br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "fact_types.proto";</code> </pre><br><p>  Let us turn to grammar, in which the interpretation procedure takes place.  Suppose we want to extract the following fact from the text: verbs that control nouns with a preposition.  To do this, we write <code>interp</code> in the rule after the verb marker, and then in parentheses the name of the fact and the period in which we want to put the extracted chain. </p><br><br><pre> <code class="hljs lisp"> S -&gt; Verb interp (<span class="hljs-name"><span class="hljs-name">Fact</span></span>.Field1) PP<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Interpretation can occur anywhere in the grammar, but the fact is removed only if the interpreted character gets into the root non-terminal. </p><br><br><p>  The last detail needed to run is to specify in the configuration file which facts we want to extract when starting the parser.  The syntax in this case is the same as when specifying the launched grammars: all necessary facts are listed in the <code>Facts</code> field of the square brackets.  In our case, there is only one fact so far: </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Facts</span></span> = [ { <span class="hljs-attribute"><span class="hljs-attribute">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"Fact"</span></span> } ]</code> </pre><br><p>  Now you can run the parser again. </p><br><br><p></p><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><table border="1"><tbody><tr><td>  go </td></tr><tr><td>  stay </td></tr><tr><td>  stay </td></tr><tr><td>  come up </td></tr><tr><td>  go </td></tr><tr><td>  move </td></tr><tr><td>  to take </td></tr><tr><td>  come </td></tr><tr><td>  put it on </td></tr><tr><td>  be considered </td></tr><tr><td>  follow </td></tr><tr><td>  to happen </td></tr><tr><td>  go </td></tr><tr><td>  look back </td></tr><tr><td>  require </td></tr><tr><td>  look </td></tr><tr><td>  to stumble </td></tr><tr><td>  take shelter </td></tr><tr><td>  be </td></tr><tr><td>  move away </td></tr><tr><td>  pull out </td></tr><tr><td>  regret </td></tr><tr><td>  go out </td></tr><tr><td>  give away </td></tr><tr><td>  be </td></tr><tr><td>  stand </td></tr><tr><td>  settle </td></tr><tr><td>  walk </td></tr><tr><td>  to tear </td></tr><tr><td>  be </td></tr><tr><td>  be </td></tr><tr><td>  clap </td></tr><tr><td>  to look </td></tr><tr><td>  run </td></tr><tr><td>  become </td></tr><tr><td>  go out </td></tr><tr><td>  lie down </td></tr><tr><td>  Wade through </td></tr><tr><td>  be </td></tr><tr><td>  ride </td></tr><tr><td>  jump </td></tr><tr><td>  to run </td></tr><tr><td>  hang </td></tr><tr><td>  fly </td></tr><tr><td>  to be killed </td></tr><tr><td>  to reach out </td></tr><tr><td>  run </td></tr><tr><td>  fly </td></tr><tr><td>  shine </td></tr><tr><td>  to ring </td></tr><tr><td>  hit </td></tr><tr><td>  rush </td></tr><tr><td>  grapple </td></tr><tr><td>  spin </td></tr><tr><td>  put it on </td></tr><tr><td>  to speak </td></tr><tr><td>  to happen </td></tr><tr><td>  to jump </td></tr><tr><td>  move out </td></tr><tr><td>  to change </td></tr><tr><td>  jump over </td></tr><tr><td>  to ride </td></tr><tr><td>  snatch </td></tr><tr><td>  to tumble down </td></tr><tr><td>  to come </td></tr><tr><td>  ride off </td></tr><tr><td>  go </td></tr><tr><td>  to go </td></tr><tr><td>  become </td></tr><tr><td>  become </td></tr><tr><td>  sit </td></tr><tr><td>  to fade away </td></tr><tr><td>  look in </td></tr><tr><td>  sit </td></tr><tr><td>  come in </td></tr><tr><td>  bump </td></tr><tr><td>  be able to </td></tr><tr><td>  to dream </td></tr><tr><td>  to wait </td></tr><tr><td>  be </td></tr><tr><td>  dive </td></tr><tr><td>  see </td></tr><tr><td>  chill out </td></tr><tr><td>  go out </td></tr><tr><td>  go out </td></tr><tr><td>  to move </td></tr><tr><td>  get out </td></tr><tr><td>  to lead </td></tr><tr><td>  disappear </td></tr><tr><td>  relax </td></tr><tr><td>  crunch </td></tr><tr><td>  surging </td></tr><tr><td>  fall away </td></tr><tr><td>  climb </td></tr><tr><td>  get off </td></tr><tr><td>  to go down </td></tr><tr><td>  take place </td></tr><tr><td>  fall through </td></tr><tr><td>  turn into </td></tr><tr><td>  to hide </td></tr><tr><td>  to fight </td></tr><tr><td>  stop </td></tr><tr><td>  to give </td></tr><tr><td>  play out </td></tr><tr><td>  to announce </td></tr><tr><td>  undermine </td></tr><tr><td>  go out </td></tr><tr><td>  walk </td></tr><tr><td>  sit </td></tr><tr><td>  to drag off </td></tr><tr><td>  to fall </td></tr><tr><td>  be </td></tr><tr><td>  walk around </td></tr><tr><td>  sit down </td></tr><tr><td>  be </td></tr><tr><td>  sit </td></tr><tr><td>  stand </td></tr><tr><td>  get up </td></tr><tr><td>  return </td></tr><tr><td>  be </td></tr><tr><td>  to fight </td></tr><tr><td>  to change </td></tr><tr><td>  spend </td></tr><tr><td>  to yearn </td></tr><tr><td>  put it on </td></tr><tr><td>  go out </td></tr><tr><td>  to go </td></tr><tr><td>  die </td></tr><tr><td>  to happen </td></tr><tr><td>  take place </td></tr><tr><td>  be </td></tr><tr><td>  dart </td></tr><tr><td>  get away </td></tr><tr><td>  get together </td></tr><tr><td>  indicate </td></tr><tr><td>  tear </td></tr><tr><td>  compare </td></tr><tr><td>  attach themselves </td></tr><tr><td>  to fall </td></tr><tr><td>  Keep </td></tr><tr><td>  climb </td></tr><tr><td>  jump off </td></tr><tr><td>  pour </td></tr><tr><td>  be </td></tr><tr><td>  to plant </td></tr><tr><td>  send </td></tr><tr><td>  go out </td></tr><tr><td>  sit down </td></tr><tr><td>  to drag </td></tr><tr><td>  jump </td></tr><tr><td>  sit </td></tr><tr><td>  turn away </td></tr><tr><td>  want </td></tr><tr><td>  to meet </td></tr><tr><td>  will be </td></tr><tr><td>  to come </td></tr><tr><td>  die </td></tr><tr><td>  become </td></tr><tr><td>  to go </td></tr><tr><td>  die </td></tr><tr><td>  sit down </td></tr><tr><td>  run through </td></tr><tr><td>  bury </td></tr><tr><td>  to leave </td></tr><tr><td>  come back </td></tr><tr><td>  breake down </td></tr></tbody></table></div></div><br><h4>  Additional grammar features </h4><br>  Now we will set ourselves a more difficult task: we will try to write a grammar with which we can extract street names from the text.  We will search for text descriptors (the words street, highway, avenue, etc.) and analyze the chains that stand next to them.  Chains must begin with a capital letter and be located to the left or right of the descriptor.  Let's create a new file with the grammar of address.cxx and save it in the folder with our project.  Immediately add an article with our new grammar to the root dictionary: <br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">TAuxDicArticle</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> { key = {<span class="hljs-string"><span class="hljs-string">"tomita:address.cxx"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CUSTOM</span></span></span><span class="hljs-class">} }</span></span></code> </pre><br><p>  Now we‚Äôll add to the fact_types.proto file a new <code>Street</code> fact that we want to extract.  It will consist of two fields: mandatory (street name) and optional (descriptor). </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Street: NFactType.TFact { <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> string StreetName = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">optional</span></span> string Descr = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br><p>  To go directly to writing grammar, you need to enter a few new concepts, which we have not touched before. </p><br><br><p>  The first concept is the operators.  They allow you to get a more convenient abbreviated grammar rule entry: <br></p><ul><li>  * - the symbol is repeated 0 or more times; </li><li>  + - the symbol is repeated 1 or more times; </li><li>  () - the character enters the rule 0 or 1 time; </li><li>  |  - operator "or". </li></ul><br>  Let's move on to writing grammar.  In the file address.cxx we will write two rules - in the first we will describe the StreetW non-terminal, which will contain the names of some street descriptors, and in the second - the <code>StreetSokr</code> non- <code>StreetSokr</code> with abbreviations. <br><br><pre> <code class="hljs erlang-repl">#encoding <span class="hljs-string"><span class="hljs-string">"utf8"</span></span> StreetW -&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">''</span></span>; StreetSokr -&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">'-'</span></span> | <span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">''</span></span>;</code> </pre><br><p>  Next, we will add a <code>StreetDescr</code> non- <code>StreetDescr</code> , which will combine the two previous ones: </p><br><br><pre> <code class="hljs erlang-repl">StreetDescr -&gt; StreetW | StreetSokr;</code> </pre><br><p>  Now we need to describe the chains, which, in case they stand next to the descriptor, can be street names.  To do this, we introduce two more concepts: restrictions and consistency markers. </p><br><br><p>  Litters clarify the properties of terminals and non-terminals, i.e.  impose restrictions on the set of chains, which describes the terminal or nonterminal.  They are written in angle brackets after terminals / non terminals and, in the case of non terminals, are applied to the syntactically main word of the group.  Litters can be varied in their structure.  Some are a unary operator, some have a field that can be filled with different values.  We list some litters that we will use in the future (a full list can be found in our documentation): </p><br><br><ul><li>  The morphological litter <code>gram</code> is a field that can be filled with any morphological category from the dictionary: part of speech, gender, number, case, time, mood, voice, face, etc.  <code>&lt;gram = ‚Äú, , ‚Äù&gt;</code> ; </li><li>  Graphematic labels - a group of litters that impose a restriction on the register of the extracted chain: <code>&lt;h-reg1&gt;, &lt;l-reg&gt;</code> ; </li><li>  Special litters - can reflect the position of the word in the sentence, the alphabet, etc .:,, <code><code>, , ; <br>     :   ,      : &lt;~fw&gt;, &lt;~lat&gt; . <br> <br></code></code> <code><code>, , ; <br>     :   ,      : &lt;~fw&gt;, &lt;~lat&gt;</code> . <br> <br></code> <p>  A little apart is the syntactic litter <code>.          ( ),     .       .</code> <code>.          ( ),     .       .</code> <br><br></p><p>  Litter matching is also written in angle brackets and means that the two grammatical categories must match for the two characters to which it is assigned.  Most often, the following approvals apply: </p><br><br><ul><li>  By type, number and case: <code>gnc-agr</code> ; </li><li>  By type and number: <code>gn-agr</code> ; </li><li>  According to the case: <code>c-agr</code> . </li></ul><br><p>  In the rule, it is necessary to write a matching identifier that indicates which symbol matches which symbol.  For example, in the following rule, the symbol A is consistent with B by gender, number and case, and from C by number and case: </p><br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">S</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">A</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">gnc-agr</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">nc-agr</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[2]</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">B</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">gnc-agr</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">C</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">nc-agr</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[2]</span></span>&gt;;</code> </pre><br><p>  Let us return to our rule describing the names of streets.  Usually the street name is either an adjective, consistent with a descriptor (Moskovsky Prospect), or a nominal group, standing in the nominative or genitive case (Kuznetsky Most street or Red Cadets street).  We first describe the noun group.  The main element of this chain will be a word, in front of which an adjective agreed with it (Veshny Vod Street) can stand, and after that - one more word in the genitive case (Moscow Eighth Anniversary Street). </p><br><br><pre> <code class="hljs xml">StreetNameNoun -&gt; (Adj<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gnc-agr[1]</span></span></span><span class="hljs-tag">&gt;</span></span>) Word<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gnc-agr[1],rt</span></span></span><span class="hljs-tag">&gt;</span></span> (Word<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gram=""</span></span></span><span class="hljs-tag">&gt;</span></span>);</code> </pre><br><p>  Street names, expressed by adjectives, are described quite simply.  This is a sequence of adjectives, the first of which must necessarily come with a capital letter: </p><br><br><pre> <code class="hljs xml">StreetNameAdj -&gt; Adj<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h-reg1</span></span></span><span class="hljs-tag">&gt;</span></span> Adj*;</code> </pre><br><p>  In the root rules, we put together the descriptors and street names and add an interpretation.  We assume that the name of the street, expressed by the nominal group, comes after the street descriptor.  It must be with a capital letter and stand in the nominative or genitive case (the litters assigned to the <code>StreetNameNoun</code> non- <code>StreetNameNoun</code> will be applied to the main word of the chain).  The street descriptor is interpreted in the <code>Descr</code> field of the <code>Descr</code> fact, and the street name is interpreted in the <code>Descr</code> field. </p><br><br><pre> <code class="hljs cs">Street -&gt; <span class="hljs-function"><span class="hljs-function">StreetDescr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Street.Descr</span></span></span><span class="hljs-function">) StreetNameNoun&lt;gram</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span>, h-reg1&gt; interp (Street.StreetName); Street -&gt; <span class="hljs-function"><span class="hljs-function">StreetDescr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">interp</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Street.Descr</span></span></span><span class="hljs-function">) StreetNameNoun&lt;gram</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span>, h-reg1&gt; interp (Street.StreetName);</code> </pre><br><p>    ,  ,  Ãà   ,     ,   (1-  ). ,         ,         .           .        ,      ,     : <code>wff</code>    , <code>wfl</code> ‚Äî ,  <code>wfm</code> ‚Äî . </p><br><br><pre> <code class="hljs xml">S -&gt; A<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">wff=</span></span></span><span class="hljs-tag">/[</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">0-9</span></span></span><span class="hljs-tag">]+</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">.</span></span></span><span class="hljs-tag">?/&gt;</span></span>;</code> </pre><br><p> ,      ,     0  99,         ,    .  ,      ‚Äî      ‚Äî       <code>NumberW</code> . </p><br><br><pre> <code class="hljs erlang-repl">NumberW_1 -&gt; AnyWord&lt;wff=/[<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]?[<span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]-?(()|()|()|)/&gt;; NumberW_2 -&gt; AnyWord&lt;wff=/[<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]?[<span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]-?(()|()|()|)/&gt;; NumberW_3 -&gt; AnyWord&lt;wff=/[<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]?[<span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]-?(()|()|()|)/&gt;; NumberW -&gt; NumberW_1 | NumberW_2 | NumberW_3;</code> </pre><br><p>        ,            -,    . ,  ,      , ..    ,      .           .      <code>outgram</code> ,          .      : </p><br><br><pre> <code class="hljs erlang-repl">NumberW_1 -&gt; AnyWord&lt;wff=/[<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]?[<span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]-?(()|()|()|)/&gt; {outgram=<span class="hljs-string"><span class="hljs-string">",,"</span></span>}; NumberW_2 -&gt; AnyWord&lt;wff=/[<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]?[<span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]-?(()|()|()|)/&gt; {outgram=<span class="hljs-string"><span class="hljs-string">",,"</span></span>}; NumberW_3 -&gt; AnyWord&lt;wff=/[<span class="hljs-number"><span class="hljs-number">1</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]?[<span class="hljs-number"><span class="hljs-number">0</span></span>-<span class="hljs-number"><span class="hljs-number">9</span></span>]-?(()|()|()|)/&gt; {outgram=<span class="hljs-string"><span class="hljs-string">",,"</span></span>};</code> </pre><br><p>         <code>StreetNameAdj</code> :      <code>NumberW</code> ,     ,   . </p><br><br><pre> <code class="hljs xml">StreetNameAdj -&gt; NumberW<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gnc-agr[1]</span></span></span><span class="hljs-tag">&gt;</span></span> Adj<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gnc-agr[1]</span></span></span><span class="hljs-tag">&gt;</span></span>;</code> </pre><br><p> ,       <code>StreetNameAdj</code> .  ,  ,            ,   .  Ãà     , ..           . </p><br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">StreetNameAdj</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">gnc-agr</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">interp</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.StreetName</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">StreetW</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">gnc-agr</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">interp</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Descr</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">StreetNameAdj</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interp</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.StreetName</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">StreetSokr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interp</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Descr</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">StreetW</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">gnc-agr</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">interp</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Descr</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">StreetNameAdj</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">gnc-agr</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">interp</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.StreetName</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">StreetSokr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interp</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Descr</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">StreetNameAdj</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">interp</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">Street</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.StreetName</span></span>);</code> </pre><br><p>    .    ,         (   ).  ,        ,    , ,     .   ,       .           <code>not_norm</code> .  ,           ,       . </p><br><br><pre> <code class="hljs rust">Street -&gt; StreetDescr interp (Street.Descr) StreetNameNoun&lt;gram=<span class="hljs-string"><span class="hljs-string">""</span></span>, h-reg1&gt; interp (Street.StreetName::not_norm); Street -&gt; StreetDescr interp (Street.Descr) StreetNameNoun&lt;gram=<span class="hljs-string"><span class="hljs-string">""</span></span>, h-reg1&gt; interp (Street.StreetName::not_norm);</code> </pre><br><p>   ,          ,      address.cxx       <code>Street</code> .  ,     ,      <code>Input</code>  <a href="https://yadi.sk/d/QVCA3Nm8TYZZX">input1.txt</a> </p><br><br><pre> <code class="hljs pgsql">Input = {File = "input1.txt"} Output = {File = "output.txt" <span class="hljs-keyword"><span class="hljs-keyword">Format</span></span> = <span class="hljs-type"><span class="hljs-type">text</span></span>} Articles = [ { <span class="hljs-type"><span class="hljs-type">Name</span></span> = "" } ] Facts = [ { <span class="hljs-type"><span class="hljs-type">Name</span></span> = "Street" } ]</code> </pre><br><p>    ,    : </p><br><br><p></p><div class="spoiler">  <b class="spoiler_title">Result</b> <div class="spoiler_text"><table border="1"><tbody><tr><td colspan="10"> <font color="#0000FF"><b>Address</b></font> </td></tr><tr><th> <b>StreetName</b> </th><th> <b>Descr</b> </th></tr><tr><td> 1-  </td><td>  </td></tr><tr><td>   </td><td>  </td></tr><tr><td>  </td><td>  </td></tr><tr><td> 1-  </td><td>  </td></tr><tr><td>   </td><td>  </td></tr><tr><td>  </td><td>  </td></tr><tr><td>   </td><td>  </td></tr><tr><td>  </td><td>  sh </td></tr></tbody></table></div></div><br><br><h4>  Dictionaries </h4><br><p>     .  dic.gzt,       ‚Äî  ,     ,        , ..   .       .          . </p><br><br><p>       .      , Ãà  .         ‚Äî  ‚Äî       : </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">TAuxDicArticle</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">key</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span> | <span class="hljs-string"><span class="hljs-string">""</span></span>}</code> </pre><br><p>  ,   : </p><br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">TAuxDicArticle</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> { key = {<span class="hljs-string"><span class="hljs-string">"tomita:address.cxx"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CUSTOM</span></span></span><span class="hljs-class">}}</span></span></code> </pre><br><p> Ãà   .     ,     ,  Ãà  ‚Äî   .  ,    ,         ,   , ,    .. </p><br><br><pre> <code class="hljs objectivec">TAuxDicArticle <span class="hljs-string"><span class="hljs-string">""</span></span> { key = {   mainword=<span class="hljs-number"><span class="hljs-number">2</span></span> agr=gnc_agr} }</code> </pre><br><p>     ¬´¬ª    ‚Äî  ¬´ ¬ª,     ,        ,   .  ,         . </p><br><br><p>        ,          : </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">TAuxDicArticle</span></span> <span class="hljs-string"><span class="hljs-string">"-"</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">key</span></span> = <span class="hljs-string"><span class="hljs-string">"-"</span></span> key = <span class="hljs-string"><span class="hljs-string">""</span></span> key = <span class="hljs-string"><span class="hljs-string">""</span></span> lemma = <span class="hljs-string"><span class="hljs-string">"-"</span></span> }</code> </pre><br><p>        ,  ,      .      <code>kwtype</code> .  ,  ,    (),     , ..   ,     <code>kwtype</code> .    <code>kwset</code> ,         .        : </p><br><br><pre> <code class="hljs erlang-repl">Animals -&gt; Word &lt;kwtype=<span class="hljs-string"><span class="hljs-string">""</span></span>&gt;; Forest -&gt; Word &lt;kwset=[<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>]&gt;;</code> </pre><br><p>       ,    Ãà .    TAuxDicArticle, ,    ,        ,     .       kwtypes.proto.  ,       : </p><br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "base.proto"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "articles_base.proto"; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "kwtypes_base.proto";</code> </pre><br><p>  Ãà     .    .   <code>message</code> ,          ,    .    . </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">message</span></span> surname : TAuxDicArticle {}</code> </pre><br><p>        .   .gzt- surnames.gzt,       , Ãà   surname.    ,    kwtypes.proto,   ,     .       ,    ,      <code>TAuxDicArticle</code>       <code>surname</code> : </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">encoding</span></span> <span class="hljs-string"><span class="hljs-string">"utf8"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">import</span></span> <span class="hljs-string"><span class="hljs-string">"kwtypes.proto"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">surname</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">key</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> } surname <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">key</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> } surname <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">key</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> }</code> </pre><br><p>         ,   <code>import "surnames.gzt";</code>  .         <code>import "kwtypes.proto";</code>  . </p><br><br><p> ,       ,         ,      :    ¬´ -¬ª.     imeni.cxx.        ,  .     .          ,         <code>surname</code>   .       Ãà  ,        .            +   ‚Äú‚Äù (  ). </p><br><br><pre> <code class="hljs erlang-repl">#encoding <span class="hljs-string"><span class="hljs-string">"utf8"</span></span> Initial -&gt; Word&lt;wff=/[-]\./&gt;; Initials -&gt; Initial Initial; FIO -&gt; Initials Word&lt;kwtype=surname&gt;; Imeni -&gt;<span class="hljs-string"><span class="hljs-string">''</span></span>&lt;gram=<span class="hljs-string"><span class="hljs-string">", "</span></span>&gt; FIO;</code> </pre><br><p>  .           : </p><br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">TAuxDicArticle</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> { key = {<span class="hljs-string"><span class="hljs-string">"tomita:imeni.cxx"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CUSTOM</span></span></span><span class="hljs-class">} }</span></span></code> </pre><br><p>    config.proto   (    )  ,     ‚Äî     .  ,     imeni.cxx    <a href="https://yadi.sk/d/_MWL0-MpTYZcp">input2.txt</a> .    .        ,     pretty.html  ,    . </p><br><br><p>  ,         ,          .        :       <code>kwtype</code> ,   Ãà    ,   ,     <code>#include</code> .     <code>#include</code>   ‚Äî  ,         ,         .      <code>kwtype</code>   .        imeni.cxx   Ãà   ,     .    org.cxx.      . </p><br><br><pre> <code class="hljs erlang-repl">#encoding <span class="hljs-string"><span class="hljs-string">"utf8"</span></span> OrgDescr -&gt; <span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">''</span></span> | <span class="hljs-string"><span class="hljs-string">''</span></span>;</code> </pre><br><p>         ¬´ -¬ª.      <code>kwtype</code> ,      ¬´¬ª,    imeni.cxx.   ,    ,       <code>kwtype</code> ‚Äî      .      ‚Äî   . </p><br><br><p> ,     . </p><br><br><pre> <code class="hljs erlang-repl">Org_ -&gt; OrgDescr Word&lt;kwtype=<span class="hljs-string"><span class="hljs-string">""</span></span>&gt;; Org -&gt; Org_ interp (Org.Name);</code> </pre><br><p>       : </p><br><br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">TAuxDicArticle</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> { key = {<span class="hljs-string"><span class="hljs-string">"tomita:org.cxx"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class">=</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CUSTOM</span></span></span><span class="hljs-class">} }</span></span></code> </pre><br><p>        fact_types.proto: </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Org: NFactType.TFact { <span class="hljs-attribute"><span class="hljs-attribute">required</span></span> string Name = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br><p> , , Ãà    .      ,       ‚Äú‚Äù.      ,         ‚ÄúOrg‚Äù. </p><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Articles</span></span> = [ { <span class="hljs-attribute"><span class="hljs-attribute">Name</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> } ] Facts = [ { <span class="hljs-attribute"><span class="hljs-attribute">Name</span></span> = <span class="hljs-string"><span class="hljs-string">"Org"</span></span> } ]</code> </pre><br><p>         pretty.html.     ¬´  . . ¬ª. </p><br><br><p>         ?   ¬´  .. ¬ª      imeni.cxx.     ¬´ _..¬ª, ..   ,                  org.cxx. </p><br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/83a/7c0/50f/83a7c050f9b1db60ac22588d998b48df.jpg" width="640"></p><br><br><p>  ,     ,        (..   <code>kwtype</code> ):          ,       . </p><br><br><p>             <a href="https://yadi.sk/d/2RKdP5W6TYZRw"></a> .     ,    -,         <a href=""></a> . </p></li></ul></div><p>Source: <a href="https://habr.com/ru/post/225723/">https://habr.com/ru/post/225723/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../225705/index.html">K2: Kepler's Second Light</a></li>
<li><a href="../225707/index.html">Detained hackers who used stolen Apple IDs to block iDevice</a></li>
<li><a href="../225709/index.html">Mobile version of Habr: version 2.0</a></li>
<li><a href="../225715/index.html">Mobile banking development for RaiffeisenBank</a></li>
<li><a href="../225721/index.html">What nobody told you about z-index in the article ‚ÄúWhat nobody told you about z-index‚Äù</a></li>
<li><a href="../225727/index.html">Swift + CoreData + A bit of a file</a></li>
<li><a href="../225735/index.html">ZeptoLab and Codeforces join forces</a></li>
<li><a href="../225739/index.html">NASA Announces Mars Design Competition</a></li>
<li><a href="../225741/index.html">UK rewrites the rules of the road under the "robot"</a></li>
<li><a href="../225743/index.html">Qualifying round of the Russian Code Cup 2014: results and analysis of tasks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>