<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basic algorithms for finding the shortest paths in weighted graphs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Surely many of the game developers (or just people who are addicted to programming) will be interested to hear these four most important algorithms th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basic algorithms for finding the shortest paths in weighted graphs</h1><div class="post__text post__text-html js-mediator-article">  Surely many of the game developers (or just people who are addicted to programming) will be interested to hear these four most important algorithms that solve the problem of the shortest paths. <br><br>  We formulate the definitions and the problem. <br>  A graph will be called several points (vertices), some pairs of which are connected by segments (edges).  A graph is connected if from each vertex one can reach any other along these segments.  A cycle is a path along the edges of a graph starting and ending at the same vertex.  And another graph is called weighted, if each edge corresponds to some number (weight).  There cannot be two edges connecting the same vertices. <br>  Each of the algorithms will solve some problem about the shortest paths on the weighted connected.  The shortest path from one vertex to another is such a path along the edges that the sum of the weights of the edges along which we have passed will be minimal. <br>  For clarity, I will give an example of such a task in real life.  Suppose there are several cities and roads connecting these cities.  In addition, each road has a length.  You want to get from one city to another, traveling as little as possible. <br><a name="habracut"></a><br>  We assume that in the graph n vertices and m edges. <br>  Let's go from simple to complex. <br><br><h2>  Floyd-Worshel Algorithm </h2><br>  Finds the distance from each vertex to each for the number of operations of the order of <b>n ^ 3</b> .  Weights can be negative, but we can not have cycles with a negative sum of the weights of the ribs (otherwise we can walk on it as much as we please and reduce the amount each time, so it‚Äôs not interesting). <br>  In the array d [0 ... n - 1] [0 ... n - 1] at the i-th iteration we will store the answer to the original problem with the restriction that we will use vertices with the number strictly less than i - 1 (vertices are numbered from zero).  Let the i-th iteration go, and we want to update the array to i + 1-th.  To do this, for each pair of vertices, we simply try to take i - the 1st vertex as a transfer point, and if this improves the answer, then leave it as well.  In total, we will do n + 1 iteration, after its completion we will be able to use any one as a ‚Äúinterchange‚Äù, and array d will be the answer. <br>  n iterations over n iterations over n iterations, total order n ^ 3 operations. <br>  Pseudocode: <br><pre><code class="java hljs"> g <span class="hljs-comment"><span class="hljs-comment">// g[0 ... n - 1][0 ... n - 1] - ,     , g[i][j] = 2000000000,    i  j  d = g for i = 1 ... n + 1 for j = 0 ... n - 1 for k = 0 ... n - 1 if d[j][k] &gt; d[j][i - 1] + d[i - 1][k] d[j][k] = d[j][i - 1] + d[i - 1][k]  d</span></span></code> </pre> <br><h2>  Ford-Bellman algorithm </h2><br>  Finds the distance from one vertex (we give it the number 0) to all others for the number of operations of order <b>n * m</b> .  Similar to the previous algorithm, weights can be negative, but we cannot have cycles with a negative sum of edge weights. <br>  Let's create an array d [0 ... n - 1] in which at the i-th iteration we will store the answer to the original problem with the restriction that the path should include strictly less than i edges.  If there are no such paths to the vertex j, then d [j] = 2000000000 (this must be some unreachable constant, ‚Äúinfinity‚Äù).  At the very beginning of d, 2000000000 is filled. To update an array at the i-th iteration, you just need to go through each edge and try to improve the distance to the vertices it connects.  The shortest paths do not contain cycles, since all cycles are non-negative, and we can remove the cycle from the path, and the path length does not deteriorate (I would also like to note that this is how you can find negative cycles in the graph: you need to do another iteration and see whether the distance to any vertex has improved).  Therefore, the length of the shortest path is not greater than n - 1, which means that after the nth iteration, d will be the answer to the problem. <br>  n iterations with m iterations, total order n * m operations. <br>  Pseudocode: <br><pre> <code class="java hljs"> e <span class="hljs-comment"><span class="hljs-comment">// e[0 ... m - 1] - ,        (first, second - ,  , value -  ) for i = 0 ... n - 1 d[i] = 2000000000 d[0] = 0 for i = 1 ... n for j = 0 ... m - 1 if d[e[j].second] &gt; d[e[j].first] + e[j].value d[e[j].second] = d[e[j].first] + e[j].value if d[e[j].first] &gt; d[e[j].second] + e[j].value d[e[j].first] = d[e[j].second] + e[j].value  d</span></span></code> </pre><br><h2>  Dijkstra's Algorithm </h2><br>  Finds the distance from one vertex (give it the number 0) to all the others for the number of operations of order <b>n ^ 2</b> .  All weights are non-negative. <br>  At each iteration, some vertices will be marked, and some will not.  Let's get two arrays: mark [0 ... n - 1] - True, if the vertex is marked, False otherwise, d [0 ... n - 1] - the length of the shortest path that passes <i>only</i> along the marked vertices as "interchange" will be stored for each vertex .  Also supported is the invariant of the fact that for marked vertices the length indicated in d is the answer.  At first, only vertex 0 is marked, and g [i] is x, if 0 and i connects an edge with weight x, equals 2,000,000,000 if they are not joined by an edge, and equal to 0 if i = 0. <br>  At each iteration, we find a vertex, with the smallest value in d among unlabeled, let it be the vertex v.  Then d [v] is the answer for v.  We prove.  Suppose that the shortest path to v from 0 passes not only along labeled vertices as ‚Äúinterchange‚Äù, and it is shorter than d [v].  Take the first unmarked vertex on this path, we call it u.  The length of the covered part of the path (from 0 to u) is d [u].  len&gt; = d [u], where len is the shortest path length from 0 to v (since there are no negative edges), but we assume len is less than d [v].  Therefore, d [v]&gt; len&gt; = d [u].  But then v does not fit its description - it has not the smallest value d [v] among unlabeled ones.  Contradiction. <br>  Now boldly mark the vertex v and recalculate d.  We do this until all the vertices become marked, and d is not the answer to the problem. <br>  n iterations of n iterations (to search for a vertex v), a total of order n ^ 2 operations. <br>  Pseudocode: <br><pre> <code class="java hljs"> g <span class="hljs-comment"><span class="hljs-comment">// g[0 ... n - 1][0 ... n - 1] - ,     , g[i][j] = 2000000000,    i  j  d = g d[0] = 0 mark[0] = True for i = 1 ... n - 1 mark[i] = False for i = 1 ... n - 1 v = -1 for i = 0 ... n - 1 if (not mark[i]) and ((v == -1) or (d[v] &gt; d[i])) v = i mark[v] = True for i = 0 ... n - 1 if d[i] &gt; d[v] + g[v][i] d[i] = d[v] + g[v][i]  d</span></span></code> </pre><br><h2>  Dijkstra's Algorithm for Sparse Graphs </h2><br>  It does the same thing as the Dijkstra algorithm, but for the number of operations of the order of <b>m * log (n)</b> .  It should be noted that m can be of the order of n ^ 2, that is, this variation of the Dijkstra algorithm is not always faster than the classical one, but only for small m. <br>  What do we need in Dijkstra's algorithm?  We need to be able to find the minimum vertex by the value of d and be able to update the value of d at some vertex.  In the classical implementation, we use a simple array, we can find the minimum vertex with respect to d in the order of n operations, and we can update it in 1 operation.  We use the <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B2%25D0%25BE%25D0%25B8%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BA%25D1%2583%25D1%2587%25D0%25B0">binary heap</a> (in many object-oriented languages, it is embedded).  The heap supports operations: add an element to the heap (for the order of log (n) operations), find the minimum element (for 1 operation), remove the minimal element (for the order of log (n) operations), where n is the number of elements in the heap. <br>  Create an array d [0 ... n - 1] (its value is the same as before) and a bunch of q.  In the heap, we will store pairs from the vertex number v and d [v] (pairs must be compared with d [v]).  Also in the heap may be dummy items.  This happens because the d [v] value is updated, but we cannot change it on the heap.  Therefore, there can be several elements in the heap with the same vertex number, but with different d values ‚Äã‚Äã(but there will be no more than m vertices in the heap, I guarantee it).  When we take the minimum value on the heap, we need to check whether this element is dummy.  To do this, it is enough to compare the value of d in the heap and its real value.  And to write the graph instead of a binary array, we use an array of lists. <br>  m times we add an element to the heap, we get about m * log (n) operations. <br>  Pseudocode: <br><pre> <code class="java hljs"> g <span class="hljs-comment"><span class="hljs-comment">// g[0 ... n - 1] -  ,  i-   : first - ,   i-  , second -    d[0] = 0 for i = 0 ... n - 1 d[i] = 2000000000 for i in g[0] // python style d[i.first] = i.second q.add(pair(i.second, i.first)) for i = 1 ... n - 1 v = -1 while (v = -1) or (d[v] != val) v = q.top.second val = q.top.first q.removeTop mark[v] = true for i in g[v] if d[i.first] &gt; d[v] + i.second d[i.first] = d[v] + i.second q.add(pair(d[i.first], i.first))  d</span></span></code> </pre></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/119158/">https://habr.com/ru/post/119158/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../119152/index.html">Game Civilization World: multiplayer up to 200 people</a></li>
<li><a href="../119153/index.html">dotPeek - a new, free decompiler from JetBrains</a></li>
<li><a href="../119155/index.html">Students may be placed for 30 years for posting fake coupon codes for 4chan and Zoklet</a></li>
<li><a href="../119156/index.html">Google Doodle 4</a></li>
<li><a href="../119157/index.html">The word "Startup" became abusive</a></li>
<li><a href="../119160/index.html">Google Chromebook from Samsung and Acer</a></li>
<li><a href="../119163/index.html">Kinect virtual fitting room for Topshop</a></li>
<li><a href="../119164/index.html">Fooled, demons!</a></li>
<li><a href="../119165/index.html">Checklist in preparing the presentation</a></li>
<li><a href="../119167/index.html">Study SEO Almanac 2010</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>