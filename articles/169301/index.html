<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Static class members. Do not let them ruin your code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have long wanted to write on this topic. The first push was served by the article Mi≈°ko Hevery " Static Methods are Death to Testability ". I wrote ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Static class members. Do not let them ruin your code</h1><div class="post__text post__text-html js-mediator-article">  I have long wanted to write on this topic.  The first push was served by the article Mi≈°ko Hevery " <a href="http://misko.hevery.com/2008/12/15/static-methods-are-death-to-testability/">Static Methods are Death to Testability</a> ".  I wrote a response article, but never published it.  But recently I saw something that could be called ‚ÄúClass-Oriented Programming‚Äù.  This refreshed my interest in the subject and here is the result. <br><br>  ‚ÄúClass-Oriented Programming‚Äù is when classes are used that consist only of static methods and properties, and an instance of the class is never created.  In this article I will say that: <br><ul><li>  it does not give any advantages over procedural programming </li><li>  do not give up objects </li><li>  the presence of static class members! = death tests </li></ul><br>  Although this article is about PHP, the concepts apply to other languages. <br><a name="habracut"></a><br><br><h4>  Dependencies </h4><br>  Usually, the code depends on another code.  For example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="php hljs">$foo = substr($bar, <span class="hljs-number"><span class="hljs-number">42</span></span>);</code> </pre> <br>  This code depends on the <code>$bar</code> variable and the <code>substr</code> function.  <code>$bar</code> is just a local variable, defined a little higher in the same file and in the same scope.  <code>substr</code> is a PHP core function.  Everything is simple here. <br><br>  Now, such an example: <br><br><pre> <code class="php hljs">$foo = normalizer_normalize($bar);</code> </pre><br>  <a href="http://php.net/manual/en/normalizer.normalize.php">normalizer_normalize</a> is an Intl package feature that has been integrated into PHP since version 5.3 and can be installed separately for older versions.  Here is a little more complicated - the performance of the code depends on the availability of a specific package. <br><br>  Now, this option: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Database::fetchAll(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM `foo` WHERE `bar` = 'baz'"</span></span>); } }</code> </pre><br>  This is a typical example of class-oriented programming.  <code>Foo</code> is tied to the <code>Database</code> .  And we assume that the <code>Database</code> class has already been initialized and the connection to the database (DB) has already been established.  Presumably, the use of this code will be as follows: <br><br><pre> <code class="php hljs">Database::connect(<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>); $bar = Foo::bar();</code> </pre><br>  <code>Foo::bar</code> implicitly depends on the availability of the <code>Database</code> and its internal state.  You cannot use <code>Foo</code> without <code>Database</code> , and <code>Database</code> supposedly requires connecting to a database.  How can you be sure that the connection to the database is already established when the call to <code>Database::fetchAll</code> ?  One way looks like this: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Database</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $connection; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$connection) { $credentials = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'config/database.php'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::$connection = some_database_adapter($credentials[<span class="hljs-string"><span class="hljs-string">'host'</span></span>], $credentials[<span class="hljs-string"><span class="hljs-string">'user'</span></span>], $credentials[<span class="hljs-string"><span class="hljs-string">'password'</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>::connect(); <span class="hljs-comment"><span class="hljs-comment">//  self::$connection... // here be dragons... return $data; } }</span></span></code> </pre><br>  When you call <code>Database::fetchAll</code> , we check the existence of the connection by calling the <code>connect</code> method, which, if necessary, retrieves the connection parameters from the config.  This means that <code>Database</code> depends on the file <code>config/database.php</code> .  If this file does not exist, it cannot function.  We go further.  The <code>Database</code> class is bound to a single database.  If you need to transfer other connection parameters, it will be at least not easy.  Kom is growing.  <code>Foo</code> not only dependent on the availability of the <code>Database</code> , but also depends on its state.  <code>Database</code> depends on a specific file in a specific folder.  Those.  implicitly, the <code>Foo</code> class depends on the file in the folder, although it is not visible from its code.  Moreover, there are a lot of dependencies on the global state.  Each piece depends on another piece, which must be in the desired state and nowhere is this clearly indicated. <br><br><h4>  Something familiar... </h4><br>  Doesn't that sound like a procedural approach?  Let's try to rewrite this example in a procedural style: <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $database_connection; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$database_connection) { $credentials = <span class="hljs-keyword"><span class="hljs-keyword">include</span></span> <span class="hljs-string"><span class="hljs-string">'config/database.php'</span></span>; $database_connection = some_database_adapter($credentials[<span class="hljs-string"><span class="hljs-string">'host'</span></span>], $credentials[<span class="hljs-string"><span class="hljs-string">'user'</span></span>], $credentials[<span class="hljs-string"><span class="hljs-string">'password'</span></span>]); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">database_fetch_all</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> $database_connection; database_connect(); <span class="hljs-comment"><span class="hljs-comment">//  $database_connection... // ... return $data; } function foo_bar() { return database_fetch_all("SELECT * FROM `foo` WHERE `bar` = 'baz'"); }</span></span></code> </pre><br>  Find the 10 differences ... <br>  Hint: the only difference is the visibility of <code>Database::$connection</code> and <code>$database_connection</code> . <br><br>  In a class-oriented example, the connection is available only for the <code>Database</code> class itself, and in the procedural code this variable is global.  The code has the same dependencies, connections, problems and works the same.  There is almost no difference between <code>$database_connection</code> and <code>Database::$connection</code> - it's just a different syntax for the same, both variables have a global state.  The easy touch of the namespace, thanks to the use of classes, is certainly better than nothing, but does not seriously change anything. <br><br>  Class-oriented programming is like buying a car, in order to sit in it, periodically open and close doors, jump on the seats, accidentally causing the airbags to activate, but never turn the ignition key and not budge.  This is a complete misunderstanding of the essence. <br><br><h4>  Turn the ignition key </h4><br>  Now, let's try OOP.  Let's start with the implementation of <code>Foo</code> : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $database; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Database $database)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;database = $database; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;database-&gt;fetchAll(<span class="hljs-string"><span class="hljs-string">"SELECT * FROM `foo` WHERE `bar` = 'baz'"</span></span>); } }</code> </pre><br>  Now <code>Foo</code> does not depend on a specific <code>Database</code> .  When creating an instance of <code>Foo</code> , you need to pass some object that has the characteristics of a <code>Database</code> .  This can be either a <code>Database</code> instance or its descendant.  So we can use another implementation of the <code>Database</code> , which can get data from somewhere else.  Or has a caching layer.  Or it is a stub for tests, and not a real connection to the database.  Now we need to create a <code>Database</code> instance, this means that we can use several different connections to different databases, with different parameters.  Let's implement the <code>Database</code> : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Database</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $connection; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($host, $user, $password)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection = some_database_adapter($host, $user, $password); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>(<span class="hljs-string"><span class="hljs-string">"Couldn't connect to database"</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetchAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($query)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  $this-&gt;connection ... // ... return $data; } }</span></span></code> </pre><br>  Notice how much simpler the implementation has become.  In <code>Database::fetchAll</code> do not need to check the status of the connection.  To call <code>Database::fetchAll</code> , you need to create an instance of the class.  To create an instance of a class, you need to pass the connection parameters to the constructor.  If the connection parameters are not valid or the connection cannot be established for other reasons, an exception will be thrown and the object will not be created.  This all means that when you call <code>Database::fetchAll</code> , you are guaranteed to have a database connection.  This means that <code>Foo</code> only needs to specify in the constructor that it needs a <code>Database $database</code> and it will have a connection to the database. <br><br>  Without an instance of <code>Foo</code> , you cannot call <code>Foo::bar</code> .  Without a <code>Database</code> instance, you cannot create an instance of <code>Foo</code> .  Without valid connection parameters, you will not create a <code>Database</code> instance. <br><br>  You simply can not use the code if at least one condition is not satisfied. <br><br>  Compare this with a class-oriented code: you can call <code>Foo::bar</code> at any time, but an error will occur if the <code>Database</code> class is not ready.  <code>Database::fetchAll</code> can call <code>Database::fetchAll</code> at any time, but an error will occur if there are problems with the <code>config/database.php</code> file.  <code>Database::connect</code> sets a global state on which all other operations depend, but this dependency is not guaranteed. <br><br><h4>  Injection </h4><br>  Let's look at this from the side of the code that uses <code>Foo</code> .  Procedural example: <br><br><pre> <code class="php hljs">$bar = foo_bar();</code> </pre><br>  You can write this line anywhere and it will be executed.  Its behavior depends on the global state of the connection to the database.  Although the code is not obvious.  Add error handling: <br><br><pre> <code class="php hljs">$bar = foo_bar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$bar) { <span class="hljs-comment"><span class="hljs-comment">// -    $bar,  ! } else { //  ,   }</span></span></code> </pre><br>  Due to the implicit dependencies of <code>foo_bar</code> , in case of an error, it will be hard to understand exactly what has broken. <br><br>  For comparison, here is a class-oriented implementation: <br><br><pre> <code class="php hljs">$bar = Foo::bar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$bar) { <span class="hljs-comment"><span class="hljs-comment">// -    $bar,  ! } else { //  ,   }</span></span></code> </pre><br>  No difference.  Error handling is identical, i.e.  it's also hard to find the source of the problems.  This is all because calling a static method is just a function call that is no different from any other function call. <br><br>  Now OOP: <br><br><pre> <code class="php hljs">$foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo; $bar = $foo-&gt;bar();</code> </pre><br>  PHP will fall with a fatal error when it comes to <code>new Foo</code> .  We indicated that <code>Foo</code> needs a <code>Database</code> instance, but did not pass it. <br><br><pre> <code class="php hljs">$db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Database; $foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo($db); $bar = $foo-&gt;bar();</code> </pre><br>  PHP will fall again, because  we did not pass the database connection parameters that we specified in the <code>Database::__construct</code> . <br><br><pre> <code class="php hljs">$db = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Database(<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-string"><span class="hljs-string">'user'</span></span>, <span class="hljs-string"><span class="hljs-string">'password'</span></span>); $foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo($db); $bar = $foo-&gt;bar();</code> </pre><br>  Now we have satisfied all the dependencies that we promised, everything is ready for launch. <br><br>  But let's imagine that the connection parameters to the database are incorrect or we have some problems with the database and the connection cannot be established.  In this case, an exception will be thrown when <code>new Database(...)</code> executed.  The following lines simply will not be executed.  So, we don‚Äôt need to check the error after calling <code>$foo-&gt;bar()</code> (of course, you can check what you returned).  If something goes wrong with any of the dependencies, the code will not be executed.  And the thrown exception will contain information useful for debugging. <br><br>  The object-oriented approach may seem more complicated.  In our example, a procedural or class-oriented code is just one line, which calls <code>foo_bar</code> or <code>Foo::bar</code> , while the object-oriented approach takes three lines.  It is important to capture the essence.  We did not initialize the database in the procedural code, although we need to do this anyway.  The procedural approach requires error handling after the fact and at every point in the process.  Error handling is very confusing, because  It is difficult to track which of the implicit dependencies caused the error.  Hardcode hides dependencies.  The sources of error are not obvious.  It is not obvious what your code depends on for its normal functioning. <br><br>  The object-oriented approach makes all dependencies obvious and obvious.  <code>Foo</code> needs a <code>Database</code> instance, and <code>Database</code> instance needs connection parameters. <br><br>  In a procedural approach, responsibility falls on functions.  Call the method <code>Foo::bar</code> - now it must return the result to us.  This method, in turn, delegates the <code>Database::fetchAll</code> .  Now all the responsibility is on him and he is trying to connect to the database and return some data.  And if something goes wrong at any point ... who knows what will be returned to you and from where. <br><br>  The object-oriented approach shifts part of the responsibility to the calling code and that is its strength.  Want to call <code>Foo::bar</code> ?  OK, then give it a DB connection.  What is the connection?  It doesn't matter if it was a <code>Database</code> instance.  This is the power of dependency injection.  It makes the necessary dependencies explicit. <br><br>  In the procedural code, you create a lot of hard dependencies and tie up different parts of the code with steel wire.  It all depends on everything.  You create a solid piece of software.  I do not want to say that it will not work.  I want to say that this is a very rigid structure, which is very difficult to disassemble.  For small applications this may work well.  For big ones, this turns into a horror of intricacies, which is impossible to test, extend and debug: <br><br><img src="https://habrastorage.org/storage2/c68/eb9/2f8/c68eb92f829e24d806123411314e876f.png"><br><br>  In object-oriented code with dependency injection, you create many small blocks, each of which is independent.  Each block has a well-defined interface that other blocks can use.  Each unit knows what it needs from others so that everything works.  In procedural and class-oriented code, you associate <code>Foo</code> with the <code>Database</code> immediately while writing the code.  In the object-oriented code, you indicate that <code>Foo</code> needs some <code>Database</code> , but leave room for maneuver, as it may be.  When you want to use <code>Foo</code> , you will need to associate a specific instance of <code>Foo</code> with a specific <code>Database</code> instance: <br><br><img src="https://habrastorage.org/storage2/e6f/2d5/544/e6f2d55449e15e0028d97426c671c6b9.png"><br><br>  The class-oriented approach looks deceptively simple, but firmly nails the code with nails of dependencies.  The object-oriented approach leaves everything flexible and isolated until it is used, which may look more complicated, but it is more manageable. <br><br><h4>  Static members </h4><br>  Why do we need static properties and methods?  They are useful for static data.  For example, the data on which the instance depends, but which never change.  Fully hypothetical example: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Database</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> $types = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'int'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'internalType'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Integer'</span></span>, <span class="hljs-string"><span class="hljs-string">'precision'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, ...), <span class="hljs-string"><span class="hljs-string">'string'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'internalType'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'String'</span></span>, <span class="hljs-string"><span class="hljs-string">'encoding'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>, ...), ... ) }</code> </pre><br>  Imagine that this class must associate data types from the database with internal types.  For this you need a type map.  This map is always the same for all <code>Database</code> instances and is used in several <code>Database</code> methods.  Why not make the map a static property?  Data never changes, but only reads.  And it will save some memory, because  data common to all <code>Database</code> instances.  Since  data access occurs only inside the class, it will not create any external dependencies.  Static properties should never be accessible from the outside, because  these are just global variables.  And we have already seen what this leads to ... <br><br>  Static properties can also be useful to cache some data that is identical for all instances.  Static properties exist, for the most part, as an optimization technique; they should not be viewed as a programming philosophy.  And static methods are useful as helper methods and alternative constructors. <br><br>  The problem with static methods is that they create a hard dependency.  When you call <code>Foo::bar()</code> , this line of code becomes associated with a specific class <code>Foo</code> .  This can lead to problems. <br><br>  The use of static methods is permissible under the following circumstances: <br><br><ol><li>  Dependence is guaranteed to exist.  If the call is internal or the dependency is part of the environment.  For example: <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Database</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($host, $user, $password)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;connection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDO(...); } ... }</code> </pre><br>  Here <code>Database</code> depends on a specific class - <code>PDO</code> .  But <code>PDO</code> is part of the platform, this is the database class provided by PHP.  In any case, to work with the database will have to use some kind of API. <br><br></li><li>  Method for internal use.  An example from the <a href="https://github.com/deceze/BloomFilter">implementation of the Bloom filter</a> : <br><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BloomFilter</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($m, $k)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getK</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($m, $n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ceil(($m / $n) * log(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } ... }</code> </pre><br>  This little helper function simply provides a wrapper for a particular algorithm that helps calculate a good number for the <code>$k</code> argument used in the constructor.  Since  it must be called before creating an instance of the class, it must be static.  This algorithm has no external dependencies and is unlikely to be replaced.  It is used like this: <br><br><pre> <code class="php hljs">$m = <span class="hljs-number"><span class="hljs-number">10000</span></span>; $n = <span class="hljs-number"><span class="hljs-number">2000</span></span>; $b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BloomFilter($m, BloomFilter::getK($m, $n));</code> </pre><br>  This does not create any additional dependencies.  The class depends on itself. <br><br></li><li>  Alternative constructor.  A good example is the <code>DateTime</code> class built into PHP.  An instance of it can be created in two different ways: <br><br><pre> <code class="php hljs">$date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DateTime(<span class="hljs-string"><span class="hljs-string">'2012-11-04'</span></span>); $date = DateTime::createFromFormat(<span class="hljs-string"><span class="hljs-string">'dm-Y'</span></span>, <span class="hljs-string"><span class="hljs-string">'04-11-2012'</span></span>);</code> </pre><br>  In both cases, the result will be a <code>DateTime</code> instance and in both cases the code is tied to the <code>DateTime</code> class anyway.  The static <code>DateTime::createFromFormat</code> is an alternative object constructor that returns the same as <code>new DateTime</code> , but using additional functionality.  Where you can write <code>new Class</code> , you can write <code>Class::method()</code> .  No new dependencies arise. <br></li></ol><br>  The remaining uses of static methods affect the binding and may form implicit dependencies. <br><br><h4>  Word of abstraction </h4><br>  Why all this fuss with addictions?  Ability to abstract!  As your product grows, its complexity grows.  And abstraction is the key to managing complexity. <br><br>  For example, you have an <code>Application</code> class that represents your application.  It communicates with the <code>User</code> class, which is the representation of the user.  Which receives data from <code>Database</code> .  The <code>Database</code> class needs a <code>DatabaseDriver</code> .  <code>DatabaseDriver</code> needs connection options.  And so on.  If you simply call <code>Application::start()</code> statically, which causes <code>User::getData()</code> statically, which causes a database statically, and so on, in the hope that each layer will deal with its dependencies, you can get a terrible mess if something goes not this way.  It is impossible to guess whether the call to <code>Application::start()</code> will work, because it is not at all obvious how the internal dependencies will behave.  Even worse, the only way to influence the behavior of <code>Application::start()</code> is to change the source code of this class and the code of the classes it calls and the code of the classes that call those classes ... in the house that Jack built. <br><br>  The most effective approach to creating complex applications is to create separate parts that can be relied upon.  Parts that you can stop thinking in which you can be sure.  For example, when calling static <code>Database::fetchAll(...)</code> , there are no guarantees that the connection to the database is already established or will be established. <br><br><pre> <code class="php hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Database $database)</span></span></span><span class="hljs-function"> </span></span>{ ... }</code> </pre><br>  If the code inside this function is executed, it means that the <code>Database</code> instance was successfully transferred, which means that the <code>Database</code> object instance was successfully created.  If the <code>Database</code> class is designed correctly, then you can be sure that the presence of an instance of this class means the ability to perform queries to the database.  If there is no class instance, the function body will not be executed.  This means that the function should not care about the state of the database; the <code>Database</code> class will do it itself.  This approach allows you to forget about dependencies and concentrate on solving problems. <br><br>  Without the ability not to think about the dependencies and dependencies of these dependencies, it is almost impossible to write at least some complicated application.  <code>Database</code> can be a small wrapper class or a giant multi-layered monster with a bunch of dependencies, it can start as a small wrapper and mutate into a giant monster with time, you can inherit the <code>Database</code> class and pass a descendant to the function, it's all not important for your <code>function (Database $database)</code> , until the public <code>Database</code> interface is changed.  If your classes are properly separated from the rest of the application using dependency injection, you can test each of them using stubs instead of their dependencies.  When you have tested a class enough to make sure that it works as it should, you can get rid of your head out of it, just knowing that you need to use a <code>Database</code> instance to work with the database. <br><br>  Class-oriented programming is nonsense.  Learn to use OOP. </div><p>Source: <a href="https://habr.com/ru/post/169301/">https://habr.com/ru/post/169301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../169283/index.html">Samsung 700G7C-T02 laptop video review</a></li>
<li><a href="../169287/index.html">Comparison Browser css3 & html5</a></li>
<li><a href="../169293/index.html">Overview of the inverter APSX-1250</a></li>
<li><a href="../169295/index.html">Translation SDL Game Framework Series. Part 6 - SDL Entities</a></li>
<li><a href="../169297/index.html">Linux at the sight of intruders</a></li>
<li><a href="../169303/index.html">Runetology (185): Andrey Soloviev, founder of Babyblog.ru</a></li>
<li><a href="../169305/index.html">LangPrism - web content crowdsourcing translation service</a></li>
<li><a href="../169307/index.html">It is cheaper for Australians to fly to the USA to buy software</a></li>
<li><a href="../169309/index.html">IT AS IS (competition results)</a></li>
<li><a href="../169311/index.html">Testing code performance on multiple versions of PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>