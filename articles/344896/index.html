<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We comprehend C deeper using assembler</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article was inspired by: We understand in C, studying assembler . The continuation did not work out, although the topic is interesting. Many woul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We comprehend C deeper using assembler</h1><div class="post__text post__text-html js-mediator-article">  This article was inspired by: We <a href="https://habrahabr.ru/post/183376/">understand in C, studying assembler</a> .  The continuation did not work out, although the topic is interesting.  Many would like to write code and understand how it works.  Therefore, I will launch a series of articles on how the C code looks after decompilation, simultaneously analyzing the basic code structures. <br><a name="habracut"></a><br>  From the reader will need at least a basic knowledge of the following things: <br><br><ul><li>  processor registers </li><li>  stack </li><li>  representation of numbers in the computer </li><li>  assembler and C syntax </li></ul><br>  But if you do not have them, and the topic is interesting to you, then all this can be quickly googled in the process of reading the article.  The article is not intended for novices at all, but I diligently chewed on many simple things so that newcomers could start from something. <br><br><h3>  What will we use? </h3><br><ol><li>  We need a C compiler that supports the modern standard.  You can use the online compiler on the site <a href="https://ideone.com/">ideone.com</a> . </li><li>  We also need a decompiler, again, you can use the online decompiler on <a href="https://godbolt.org/">godbolt.org</a> . </li><li>  You can also take a compiler for the assembler, which is on ideone at the link above. </li></ol><br>  Why do we have everything online?  Because it is convenient to resolve disputes due to different versions and operating systems.  There are a lot of compilers, there are also enough decompilers, I would not like to take into account the peculiarities of each in the discussion. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      With a more thorough approach to the study, it is better to use offline versions of compilers, you can take a bunch of current gcc, OllyDbg and NASM.  Differences should be minimal. <br><br><h3>  Simplest program </h3><br>  This article does not seek to repeat the one I quoted at the very beginning.  But you need to start from scratch, so some of the material will be forced to intersect.  Hope for understanding. <br><br>  The first thing you need to learn, the compiler, even when optimizing the zero level (-O0), can cut the code written by the programmer.  Therefore, the following code: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Nothing will differ from: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Therefore, it will be necessary to write in such a way that during decompilation we, nevertheless, will see the transformation of our code into something meaningful, so the examples may look at least strange. <br><br>  Second, we need compilation flags.  Two is enough: <b>-O0</b> and <b>-m32</b> .  By this we set the zero optimization level and 32-bit mode.  With optimizations, it should be obvious: we don‚Äôt want to see the interpretation of <i>our</i> code in asm, but not optimized.  With the regime should also be obvious: fewer registers - more attention to the point.  Although these flags, I will periodically change to go into the material. <br><br>  Thus, if you are using gcc, the compilation may look like this: <br><br>  gcc source.c -O0 -m32 -o source <br><br>  Accordingly, if you are using godbolt, then you need to specify these flags in the input line next to the compiler selection.  (I show the first examples on gcc 4.4.7, then change it to a later one) <br><br>  Now, you can see the first example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    1 return a; //     }</span></span></code> </pre><br>  So, the following code corresponds to this: <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp mov ebp, esp <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebx mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> mov eax, ebx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebx <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> ebp ret</code> </pre><br>  The first two lines correspond to the function prologue (or rather three, but the third one I want to clarify now), and we will analyze them in the article on functions.  Now just do not pay attention to them, the same applies to the last 3 lines.  If you don't know asm, let's see what these commands mean. <br><br>  Assembly instructions are: <br><br>  mnemonic dst, src <br>  i.e. <br><br>  instructions recipient source <br><br>  Here you need to make a reservation that the AT &amp; T syntax has a different order, and then we will come back to it, but now we are interested in a syntax similar to NASM. <br><br>  Let's start with the <b>mov</b> instruction.  This instruction moves from memory to registers or from registers to memory.  In our case, it moves the number 1 to the ebx register. <br><br>  Let's take a quick look at the registers: in the x86 architecture, there are eight 32-bit general purpose registers, which means that these registers can be used by the programmer (in our case, the compiler) when writing programs.  The ebp, esp, esi and edi registers will be used by the compiler in special cases, which we will discuss later, and the eax, ebx, ecx, and edx registers will be used by the compiler for all other needs. <br><br>  Thus, <b>mov ebx, 1</b> , directly corresponds to the string <b>register int a = 1;</b> <br><br>  And it means that the value 1 has been moved to the ebx register. <br><br>  And the line <b>mov eax, ebx</b> , will mean that the value from the ebx register will be moved to the eax register. <br><br>  There are two more lines <b>push ebx</b> and <b>pop ebx</b> .  If you are familiar with the concept of "stack", then you guess that the compiler first put ebx on the stack, thus remembered the old register value, and after the end of the program, returned the value from the stack back to the ebx register. <br><br>  Why does the compiler place the value 1 from the ebx register into eax?  This is due to the convention about calls to C functions.  There are several points there, all of them are not interested in us now.  It is important that the result is returned in eax, if possible.  Thus, it is clear why the unit eventually ends up in eax. <br><br>  But now the logical question is, why did you need ebx?  Why it was impossible to write immediately <b>mov eax, 1</b> ?  It's all about the level of optimization.  I told you: the compiler should not cut our code, and we did not write <b>return 1</b> , we used a register variable.  That is, the compiler first placed the value in the register, and then, following the agreement, returned the result.  Change the optimization level to any other, and you will see that the ebx register is really not needed. <br><br>  By the way, if you use godbolt, then you can hover over a line in C, and you will highlight the code corresponding to this line in asm, provided that this line is highlighted in color. <br><br><h3>  Stack </h3><br>  Let's complicate the example and stop using the register variables (do you use them infrequently?).  Let's see what this code will become: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   1 int b = a + 5; //  'a' 5    'b' return b; //    }</span></span></code> </pre><br>  ASM: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">push</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ebp</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">esp</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sub</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">esp</span></span>, 16 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 5 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">leave</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br>  Again, let's skip the top 3 lines and the bottom 2. Now we have a variable, <b>a</b> local one, so the memory is allocated to it on the stack.  Therefore, we see the following magic: <b>DWORD PTR [ebp-8]</b> , what does it mean?  DWORD PTR is a double word type variable.  The word is 16 bits.  The term became widespread in the era of 16-bit processors, then exactly 16 bits were placed in the register.  This amount of information began to be called the word (word).  That is, in our case, dword (double word) 2 * 16 = 32 bits = 4 bytes (normal int). <br><br>  The ebp register contains the address at the top of the stack for the current function (we will come back to this later), so it is shifted by 4 bytes so as not to overwrite the address itself and appends the value of our variable.  Only, in our case, it is offset by 8 bytes for the variable <b>a</b> .  But if you look at the code below, you will see that the variable <b>b</b> lies with an offset of 4 bytes.  Brackets mean address.  That is, this line works as follows: on the basis of the address stored in ebp, the compiler places the value 1 at the address ebp-8 of size 4 bytes.  Why is minus eight, not plus.  Because the parameters passed to this function would correspond to the plus, but again, we will discuss this later. <br><br>  The next line moves the value 1 to the eax register.  I think it does not need detailed explanations. <br><br>  Next we have a new <b>add</b> instruction, which adds (adds).  That is, 5 is added to the value in eax (1), now the value 6 is found in eax. <br><br>  After that, it is necessary to move the value 6 to the variable <b>b</b> , which is done by the next line (the variable b is on the stack at offset 4). <br><br>  Finally, we need to return the value of the variable b, therefore we need to move <br>  value in eax register ( <b>mov eax, DWORD PTR [ebp-4]</b> ). <br><br>  If everything is clear with the previous one, then it is possible to move on to the more complex. <br><br><h3>  Interesting and not so obvious things. </h3><br>  What happens if we write the following: int var = 2.5; <br><br>  Each of you, I think, will answer correctly, that in var there will be a value of 2. But what will happen to the fractional part?  It is discarded, ignored, will there be a type conversion?  Let's get a look: <br><br>  ASM: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> DWORD PTR [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  The compiler himself dropped the fractional part as superfluous. <br><br>  What happens if you write like this: int var = 2 + 3; <br><br>  ASM: <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> DWORD PTR [ebp-<span class="hljs-number"><span class="hljs-number">4</span></span>], <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  And we learn that the compiler itself is able to calculate constants.  And in this case: since 2 and 3 are constants, their sum can be calculated at the compilation stage.  Therefore, you can not bother with calculating such constants, the compiler can do the work for you.  For example, the translation into seconds from hours can be written as hours * 60 * 60. But rather, as an example, it is worthwhile to put operations on constants that are declared in the code. <br><br>  What happens if we write this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a * <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span></code> </pre><br>  Interesting, isn't it?  The compiler decided not to use the multiplication operation, but simply added two numbers, which is - multiply by 2. (I will not describe these lines in detail, you must understand them, based on the previous material) <br><br>  You may have heard that the multiplication operation takes longer than the addition operation.  It is for these reasons that the compiler optimizes such simple things. <br><br>  But let's complicate the task and write it like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a * <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  ASM <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span></code> </pre><br>  Do not be fooled by the use of the new register edx, it is no worse than eax or ebx.  It may take time, but you should see that the unit is in the edx register, then in the eax register, after which the value of eax is added to itself and then another unit is added from edx.  So we got 1 + 1 + 1. <br><br>  You know, infinitely, he will not do that, already at * 4, the compiler will produce the following: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span>, 1 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sal</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 2 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, 0</code> </pre><br>  So we have a new <b>sal</b> instruction, what does it do?  This is a binary left shift.  Equivalent to the following code in C: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  For those who do not really understand how this statement works: <br><br>  0001 is shifted to the left (or added to the right) by two zeros: 0100 (i.e. 4 in the 10th number system).  At its core, a shift to the left by 2 digits is a multiplication by 4. <br><br>  It's funny that if you multiply by 5, the compiler will make one sal and one add, you can test different numbers yourself. <br><br>  At 22, the compiler on godbolt.org gives up and uses multiplication, but before that number it tries to get out in a variety of ways.  Even subtraction uses and some more instructions that we have not yet discussed. <br><br>  Well, it was flowers, and what do you think about the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  If you expect subtraction, then alas - no.  The compiler will produce more sophisticated methods.  The ‚Äúdivision‚Äù operation is even slower than multiplication, so the compiler will also get out: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span>, 2 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-4]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">shr</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span>, 31 <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">edx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">sar</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mov</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">DWORD</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PTR</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[ebp-8]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">eax</span></span></code> </pre><br>  It should be noted that for this code I chose the compiler of a significantly later version (gcc 7.2), before that I cited gcc 4.4.7 as an example.  For early examples there were no significant differences, for this example they use different instructions in the fifth line of the code.  And the example generated by 7.2 is easier for me to explain to you now. <br><br>  It is worth noting that now the variable <b>a</b> is on the stack at offset 4, not 8, and immediately forget about this minor difference.  Key points begin with <b>mov edx, eax</b> .  But for now, skip the value of this line.  The <b>shr</b> instruction performs a binary right shift (i.e., a division by 2 if it were <b>shr edx, 1</b> ).  And here some will be able to think, and why, indeed, not to write <b>shr edx, 1</b> , is that what the code does in C?  But not everything is so simple. <br><br>  Let's make a small optimization and see what it affects.  In fact, we use integer division with our code.  Since the variable ‚Äúa‚Äù is an integer type and 2 is a constant of type int, the result cannot be obtained in any way fractional by the logic C.  And this is good, since dividing integers is faster and simpler, but we have signed numbers, which means that a negative number when dividing with the shr instruction may differ by one from the correct answer.  (This is all due to the fact that 0 fits in the middle of the range for sign types).  If we replace the sign division with unsigned: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a / <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Then we get the expected.  It is worth considering that godbolt will drop the unit in the shr instruction, and this will not compile into NASM, but it is implied.  Change 2 to 4 and you will see the second operand as 2. <br><br>  Now look at the previous code.  In it we see <b>sar eax</b> , which is the same as shr, only for signed numbers.  The rest of the code just takes this unit into account when we divide a negative number (or a negative number, although the code changes a little).  If you know how negative numbers are represented in a computer, it will not be difficult for you to guess why we shift rightward by 31 bits and add this value to the original number. <br><br>  With the division into large numbers, it is still easier.  There, the division is replaced by multiplication, the constant is calculated as the second operand.  If you are wondering how, you can break your head over it yourself, there is nothing difficult there.  You just need to understand how real numbers are represented in memory. <br><br><h3>  Conclusion </h3><br>  For the first article there is more than enough material.  It's time to round out and sum up.  We got acquainted with the basic syntax of the assembler, found that the compiler can take on the simplest optimization when calculating.  Saw a difference between register and stack variables.  And some other things.  It was an introductory article, I had to spend a lot of time on obvious things, but they are not obvious to everyone, in the future we will comprehend more subtleties of the C language. <br><br>  <a href="https://habrahabr.ru/post/345460/">Part 2</a> </div><p>Source: <a href="https://habr.com/ru/post/344896/">https://habr.com/ru/post/344896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344886/index.html">Dagger 2 for novice Android developers. Dagger 2. Part 2</a></li>
<li><a href="../344888/index.html">Convolution network in python. Part 3. Application of the model</a></li>
<li><a href="../344890/index.html">Function, script and event approximation</a></li>
<li><a href="../344892/index.html">Useful to the designer: free new items to optimize design processes. 2nd Edition</a></li>
<li><a href="../344894/index.html">Legal aspects of operations with cryptocurrencies for residents of the Russian Federation</a></li>
<li><a href="../344898/index.html">Tips for creating a modern Android application. Yandex lecture</a></li>
<li><a href="../344900/index.html">The digest of interesting materials for the mobile developer # 234 (December 11 - December 17)</a></li>
<li><a href="../344902/index.html">Simple implementation of Token for mobile application interaction with WebAPI</a></li>
<li><a href="../344908/index.html">Configure Nginx + PHP-FPM and HTTPS from Let's Encrypt on AWS EC2 with Ubuntu Server 16.04 LTS</a></li>
<li><a href="../344910/index.html">Modular grid layout from scratch: analysis, calculation and construction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>