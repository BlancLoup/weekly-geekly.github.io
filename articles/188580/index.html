<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why web applications on mobile platforms are slow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From translator  This is a translation of the article by Drew Crawford ‚ÄúWhy mobile web apps are slow, ‚Äù published on July 9, 2013. The article is very...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why web applications on mobile platforms are slow</h1><div class="post__text post__text-html js-mediator-article"><blockquote><h6>  From translator </h6>  This is a translation of the article by Drew Crawford <a href="http://sealedabstract.com/rants/why-mobile-web-apps-are-slow/">‚ÄúWhy mobile web apps are slow,</a> ‚Äù published on July 9, 2013. The article is very interesting, but big - mistakes are possible - please forgive and send comments to the PM. <br>  <u>As the sharp topic is touched upon, please note that the translator does not necessarily share the opinion of the author of the article</u> ! <br>  When translating the text slightly modified, since the direct translation is not always clear conveys the meaning.  To translate the term <i>‚Äúnative code‚Äù</i> , Anglicism <i>‚Äúnative code</i> <i>‚Äù</i> was used, which is clearer and shorter than <i>‚Äúplatform native code‚Äù</i> .  The term <i>‚Äúword processing‚Äù is</i> translated as <i>‚Äúlayout of the text‚Äù</i> , although this slightly narrows the original meaning.  The term managed code (‚Äúmanaged code‚Äù) has not been translated, as there is no successful translation (in the translator‚Äôs opinion).  The term ‚Äútermination‚Äù of an application means its compulsory termination by the operating system. <br>  The narrative in the article is from the first person: the author of the article. </blockquote><br><br><a name="habracut"></a><br>  The response to <a href="http://sealedabstract.com/rants/mobile-web-apps-are-slow/">my previous article</a> (claiming that web applications on mobile platforms are slow) was an unusually high amount of interesting discussions.  From the article, as from a spark, the flame of discussion, which flowed both in the web and in real life, flared up.  Unfortunately, this discussion is not so strongly based on the facts, as we would like. <br><br>  In this article, I'm going to give the actual evidence related to the problem under discussion, instead of playing the game <i>‚Äúwho shouts to whom</i> . <i>‚Äù</i>  You will see comparative tests, hear the opinions of experts, and even be able to read "sincere-how-to-confession" notes from subject magazines.  There are over 100 quotes in this article, and this is not a joke.  I do not guarantee that this article will convince you, moreover, I do not even guarantee that everything in it is absolutely authentic (this cannot be done in an article of this size), but I can guarantee that this is the most complete and objective approach to the problem Many iOS developers have already realized: that web applications on mobile platforms are slow and will work slowly in the foreseeable future. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I just want to warn you - the article is unrealistically large, more than 10,000 words.  So it was intended.  Last time I prefer informative articles to popular ones.  This article - a contribution to the piggy bank of meaningful articles - as an attempt to practice what I myself preached before: deep, evidence-based discussions should be encouraged as opposed to writing empty but witty comments. <br><br>  The article is written in dry language, because the topic under study has been sucked in different forms many times.  If you wanted to read the 30-second chatter on the subject of <i>"mobile web applications suck!" / "Hell!</i>  <i>No</i> , this article is not for you ( <i>from the translator: here in the original article there is a mass of references to similar English-language discussions</i> ).  On the other hand, as far as I know, there is no full, objective, demonstrative discussion of this problem on the web.  It may be a silly idea, but this article is an attempt to speak convincingly and substantively about a problem, 100% of which discussions usually come down to a holivor.  In my defense I can say that I believe that this is not because of the problem itself, but because of the unwillingness to improve the quality of discussion by its participants.  I believe that we will find out if this is so. <br><br>  So, if you are painfully trying to understand what your friends - native mobile application developers - persistently writing perverse, native applications stubbornly, are at the top of the web revolution, then bookmark the article, pour yourself coffee, free the morning, find a comfortable chair ready. <br><br><h4>  SHORT REVIEW </h4><br>  <a href="http://sealedabstract.com/rants/mobile-web-apps-are-slow/">My previous article</a> , based on SunSpider performance tests, argued that, for the time being, web applications on mobile platforms are slow: <br><blockquote>  ‚ÄúIf by 'web application' is meant a 'page with a couple of buttons', then cozy performance tests, like SunSpider, will fit perfectly.  But lightweight photo editing, lightweight text layout, data storage on the user's side and animation between screens in a web application running on ARM architecture should be done for one reason only: if your life is in mortal danger. ‚Äù </blockquote><br>  You should read that article, but, in any case, here are the test results: <br><img src="https://habrastorage.org/getpro/habr/comment_images/353/b40/f8f/353b40f8fcbb9389caeb3d67e2c713ad.png" alt="image"><br>  There are three significant categories of objections to this schedule: <br>  1. The fact that JS is slower than native code is not new: everyone has known this since the days of CS1 and the discussions of compiled, JIT and interpreted languages.  The only question is - is it too slow for JS to work for your specific task - and synthetic tests do not provide an answer to this question. <br>  2. Yes, JS is slower and it interferes, but it gets faster and sooner or later it will become so fast that it pulls your task (see point 1), so it's time to start investing in JS. <br>  3. I write server code in Python / PHP / Ruby and have no idea what you are talking about.  I know that my servers are faster than your mobile phones, but I‚Äôm confidently holding X, 000 users using an interpreted programming language, but you can‚Äôt figure out how to satisfy one in the JIT-language? <br><br>  I have a transcendental goal - I want to refute all these three statements in this article!  Yes, JS is so slow that it becomes unusable;  no, it will not become much faster in the coming years;  No, your server programming experience in scripting languages ‚Äã‚Äãcannot be adequately transferred to mobile platforms. <br><br>  As a rule, in such articles, ‚Äúthey didn‚Äôt notice the elephant,‚Äù that is, no one tried to really measure how slower the JS was or suggested a useful, suitable way to do it (you know ... slow compared to what?).  In this article, I will cite not one, but as many as three ways to measure performance equivalence with respect to JS performance.  So, I‚Äôll not just talk in the language ‚Äúblah blah JS slows down‚Äù, but I‚Äôll give measuring comparisons to several tasks that you actually encounter as developers, so you can calculate for yourself whether there is enough performance for your specific task. <br><br><h4>  OK, BUT HOW HOW TO MEASURELY measure JAVASCRIPT PERFORMANCE WITH RESPECT TO THE NATIVE CODE? </h4><br>  Good question.  To answer it, I chose a <a href="http://benchmarksgame.alioth.debian.org/u32/program.php%3Ftest%3Dspectralnorm%26lang%3Dv8%26id%3D2">random performance test</a> from The Benchmarks Game.  Then I found an old C program that does the same thing (the old one, since the new ones contain all sorts of x86 optimizations).  Then I measured the performance of Nitro ( <i>from the translator: JS-engine Safari</i> ) in relation to LLVM on my correct iPhone 4S.  All code is available on <a href="https://github.com/drewcrawford/bench">GitHub</a> . <br><br>  Yes, this is all very random code.  But in real life, the code is no less random.  Want to make a better experiment - a flag in your hands.  I conducted this experiment simply for the reason that I did not find any other similar ones (comparing Nitro and LLVM). <br><br>  In any case, in this synthetic test, LLVM ( <i>from translator: that is, native code</i> ) is about 4.5 times faster than Nitro ( <i>from translator: JavaScript code</i> ). <br><img src="https://habrastorage.org/getpro/habr/post_images/9d3/8a2/424/9d38a24248d2d63eedce6ee2d61ba71e.png" alt="image"><br><br>  So, if you ask yourself the question ‚Äúhow much faster does my function execute natively, compared to execute it on Nitro JS,‚Äù then the answer is this: it works <b>about 5 times faster</b> .  This result roughly corresponds to the results of the Benchmarks Game, where x86 / GCC / V8 are compared.  <a href="http://benchmarksgame.alioth.debian.org/u32/benchmark.php%3Ftest%3Dall%26lang%3Dv8%26lang2%3Dgcc%26data%3Du32">They claim</a> that GCC / x86 runs on average <b>from two to nine times faster</b> than V8 / x86.  So the result I received does not fall out of the picture of the world, and it is true for the ARM architecture and for x86. <br><br><h4>  BUT DOWNTIME <s>640 KB OF MEMORY</s> 1/5 PERFORMANCE IS NOT ENOUGH FOR EVERYONE? </h4><br>  Quite enough on x86.  Well, really, well, how much resource-intensive to display a sign?  Not too much.  One problem: ARM is not x86. <br><br>  According to <a href="http://browser.primatelabs.com/geekbench2/compare/1952237/1952292">GeekBench</a> , the latest MacBook Pro is faster than the last iPhone <b>by an order of magnitude</b> .  Well, okay, on the plates is still enough.  We need 10% of performance.  Give me a sec!  You have not forgotten to divide these 10% by 5 more?  So, in the bottom line, we have <b>only 2% of the performance of the desktop</b> (I‚Äôm a little careless rounding the units, but for our reasoning there‚Äôs enough accuracy). <br><br>  Well, well, but how much resource-intensive is the text layout?  Didn't they do it on m68k?  Well, this question is easy to answer.  Maybe you do not remember, but the joint work with documents appeared in Google Docs not immediately.  They significantly rewrote the code and added this feature in April 2010.  Let's look at the performance of browsers back in 2010: <br><img src="https://habrastorage.org/getpro/habr/post_images/c13/fc0/a89/c13fc0a8941a7e34d20ff78f4af98cb3.png" alt="image"><br><br>  This chart clearly shows that the iPhone 4S cannot compete with browsers at the time point when Google added document collaboration.  Well, that is, IE8, he overtakes, congratulations! <br><br>  Let's look at another serious JS application: Google Wave.  Wave never worked in IE8 (according to <a href="http://googlewavedev.blogspot.com/2009/09/google-wave-in-internet-explorer.html">Google</a> ), because it was too slow. <br><img src="https://habrastorage.org/getpro/habr/post_images/b2c/ba0/5fe/b2cba05fe4fffd3a71a656084d972342.png" alt="image"><br><br>  Please note that the supported browsers were in 1000, and the one that issued 3800 was excluded because it is slow.  The iPhone produces 2400. And, like IE8, it is not sufficiently productive to launch Wave. <br><br>  For clarity: sharing documents on mobile devices is possible.  But not on JS.  The performance difference between the native and the web application is comparable to the performance difference between FireFox and IE8 and is too big for serious work. <br><br><h4>  BUT I HAVE SEEN THAT THE PERFORMANCE OF V8 / MODERN-JAVASCRIPT IS COMPARABLE WITH THE PERFORMANCE OF APPLICATION ON C? </h4><br>  Depends on what is considered "comparable".  If the C program runs in 10 ms, then the 50 ms JS program can be considered ‚Äúcomparable‚Äù.  But if the C-application takes 10 seconds, then 50 seconds JS application for most is already incomparable with it. <br><br><h4>  VIEW FROM THE HARDWARE </h4><br>  The lag 5 times is generally not scary on the x86 platform, because x86, to begin with, is an order of magnitude faster than ARM.  There is stock.  The solution is simple: increase ARM performance 10 times and - voila - we get desktop performance on a mobile device. <br><br>  The feasibility of this somehow revolves around your belief in Moore's Law, which is trying to speed up a chip that runs on an 80 g battery.  Not being a hardware engineer, I worked for a large semiconductor company and its employees told me that the current performance is the result of the <i>process</i> (here this one thing that is measured in nanometers).  The impressive performance growth of the iPhone 5 is largely due to a decrease in process technology ‚Äî from 45 nm to 32 nm ‚Äî by about a third.  To repeat this step, Apple will have to reduce the process technology to 22 nm. <br><br>  Just in case, we note that Intel's next-generation Atom processor (Bay Trail) - on the 22 nm process - does not yet exist.  And Intel had to invent a <a href="http://www.intel.com/content/www/us/en/energy/intel-22nm-3-d-tri-gate-transistor-technology.html">completely new type of transistor</a> , as the old one simply could not work at 22 nm.  Do you think they license this ARM technology?  Think again.  There are only plans for the construction of 22 nm factories and most of them are controlled by Intel. <br><br>  In fact, ARM will reduce the process technology to 28 nm in the next year or so (watch A7), and Intel is preparing for the transition to 22 nm (and maybe 20 nm) a little later.  At the hardware level, I am much more willing to believe that x86 will be inserted into a mobile phone before an ARM chip with comparable performance appears. <br><br>  Comments from a former Intel engineer: <br><blockquote>  I am a former engineer who worked on microprocessors for the mobile platform and later on Atoms.  My (incredibly biased) opinion: it will be easier to plug x86 into the phone, abandoning some of the functionality, than to increase the performance of ARM to x86, adding functionality to it from scratch. </blockquote><br>  Note from a robot engineer: <br><blockquote>  You are absolutely right when you say that there will be no significant increase in productivity, and that Intel will receive a more efficient mobile processor in only a few years.  In fact, mobile processors have come up against the limit that desktop processors have come up against when they have reached ~ 3 Ghz: a further increase in frequency entails a sharp increase in power consumption and this rule will also apply to the following processes, although they will slightly increase IPC ( by 10-20%).  Reaching this limit, desktop processors have become multi-core, but mobile systems-on-a-chip are multi-core, so there won't be an easy performance boost. </blockquote><br><br>  So, maybe Moore's Law is fulfilled, but on condition that the entire mobile ecosystem goes to x86.  It is not absolutely impossible - <a href="http://www.businessinsider.com/the-care-and-keeping-of-apples-super-secret-project-marklar-2012-6">they did this before</a> .  But at that time, sales amounted to about a <a href="http://switchtoamac.com/site/apple-reports-2006-fourth-quarter-earnings-mac-sales-rise-30-percent.html">million</a> devices per year, and now for one quarter, <a href="http://techcrunch.com/2012/03/07/tim-cook-talks-ios-device-stats-315-million-sold-62-million-in-q4-alone/">62 million are</a> sold.  This was done using virtualization, which emulated the old architecture <a href="http://guides.macrumors.com/Rosetta_Performance_Benchmarks">at 60% performance</a> , while modern hypothetical virtualization for optimized (O3) ARM code is <a href="http://www.cs.princeton.edu/~thhung/pubs/odes08.pdf">closer to 27%</a> . <br><br>  In order to believe that JS performance will cease to be a problem sooner or later, the easiest way is to follow a hardware path.  Either within five years, Intel will have a viable chip for the iPhone (which is likely) and Apple will switch to it (which is unlikely), or ARMs will catch up over the next decade (ask 10 engineers on this score and get 10 opinions).  But the decade is still a long time, in my opinion, for something that shoots. <br><br>  I'm afraid my knowledge of hardware ends here.  If you want to believe that ARM will catch up with x86 in 5 years, then the first step is to find someone who works for ARM or Intel and who agrees with you.  I consulted with many similar engineers and they all rejected this statement.  From which it follows that this is likely not to happen. <br><br><h4>  VIEW FROM SOFTWARE </h4><br>  Many competent programmers make the same mistake.  They speculate as follows: JavaScript has already become much faster than it was!  And it will be getting faster and faster! <br><br>  Package is correct.  JavaScript has greatly accelerated.  But we are currently at the peak of javascript performance.  Further acceleration is hardly possible. <br><br>  Cause?  To begin with, we note that most of the JS improvements in its history are in fact <b>related to the hardware</b> .  Jeff Atwood <a href="http://www.codinghorror.com/blog/2007/12/the-great-browser-javascript-showdown.html">writes</a> : <br><blockquote>  I found that javascript performance increased from 1996 to 2006 <b>100 times</b> .  Building Web 2.0 ‚Äúon the skeleton‚Äù of JavaScript was made possible mainly due to the increase in productivity, according to Moore's law. </blockquote><br>  If we associate the increase in JS performance with the increase in productivity of the hardware platform, then we should not expect a significant increase in software performance in the near future.  Do you want to or not, but if you believe that the speed of JS will increase, then it is most likely that this will happen because of the increase in hardware performance, since such are the trends. <br><br>  What about JIT ( <i>from translator: virtual machines that sped up JS execution</i> )?  V8, Nitro / SFX, TraceMonkey / IonMonkey, Chakra and so on?  Well, at the time of their appearance, they played a role, but still not as large as you would like to think.  V8 was released in September 2008.  I dug out a copy of Firefox 3.0.3 from about the same amount of time: <br><img src="https://habrastorage.org/getpro/habr/post_images/ec9/606/b7f/ec9606b7f762e79227289b3d943eec52.png" alt="image"><br>  You just do not get me wrong - a 9-fold increase in productivity is not a joke;  after all, something like this is the difference in power between ARM and x86.  However, the difference in performance between Chrome 8 and Chrome 26 is a gentle curve, because since 2008, nothing revolutionary has happened here.  The rest of the browser makers pulled up - somewhere a little slower, somewhere a little faster, but no one could seriously improve the speed of the code since then. <br><br><h4>  IS THE JAVASCRIPT PERFORMANCE GROWTH OBSERVED AT THE PRESENT TIME? </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/41f/0b1/049/41f0b10497ac005731264318b6602550.png" alt="image"><br>  Here is <a href="http://www.webkit.org/perf/sunspider-1.0/sunspider-1.0/results.html%3F%257B%2522v%2522:%2520%2522sunspider-1.0%2522,%2520%25223d-cube%2522:%255B21,15,14,19,26,15,21,36,16,14%255D,%25223d-morph%2522:%255B18,9,21,38,9,20,35,9,20,22%255D,%25223d-raytrace%2522:%255B11,8,8,8,10,11,11,11,11,12%255D,%2522access-binary-trees%2522:%255B2,1,1,2,1,1,2,2,1,1%255D,%2522access-fannkuch%2522:%255B11,11,11,11,10,11,11,10,11,12%255D,%2522access-nbody%2522:%255B11,33,9,10,9,10,10,10,11,10%255D,%2522access-nsieve%2522:%255B4,3,3,3,3,3,4,4,3,3%255D,%2522bitops-3bit-bits-in-byte%2522:%255B2,2,2,2,1,1,2,2,2,1%255D,%2522bitops-bits-in-byte%2522:%255B4,5,5,4,4,4,4,4,4,4%255D,%2522bitops-bitwise-and%2522:%255B7,8,7,8,7,7,8,7,8,8%255D,%2522bitops-nsieve-bits%2522:%255B7,8,7,7,7,9,7,8,7,7%255D,%2522controlflow-recursive%2522:%255B2,2,2,2,2,1,2,2,1,2%255D,%2522crypto-aes%2522:%255B4,5,5,6,7,8,7,7,7,6%255D,%2522crypto-md5%2522:%255B3,4,3,3,3,4,3,3,4,3%255D,%2522crypto-sha1%2522:%255B3,4,4,6,5,4,6,3,4,4%255D,%2522date-format-tofte%2522:%255B19,10,9,7,10,8,8,21,20,9%255D,%2522date-format-xparb%2522:%255B10,9,11,9,13,26,10,10,10,9%255D,%2522math-cordic%2522:%255B8,10,9,21,19,8,21,8,8,10%255D,%2522math-partial-sums%2522:%255B11,24,9,10,11,10,11,10,11,22%255D,%2522math-spectral-norm%2522:%255B3,3,4,3,4,4,4,4,4,4%255D,%2522regexp-dna%2522:%255B10,10,10,9,10,12,10,10,10,9%255D,%2522string-base64%2522:%255B5,4,5,28,4,5,15,5,4,5%255D,%2522string-fasta%2522:%255B10,32,10,10,32,10,11,12,35,29%255D,%2522string-tagcloud%2522:%255B19,19,32,19,20,30,18,44,18,19%255D,%2522string-unpack-code%2522:%255B33,24,23,25,24,23,25,25,24,23%255D,%2522string-validate-input%2522:%255B6,9,5,6,8,6,7,6,8,8%255D%257D">Chrome 8</a> on my Mac (the earliest one that still works, December 2010).  But <a href="http://www.webkit.org/perf/sunspider-1.0/sunspider-1.0/results.html%3F%257B%2522v%2522:%2520%2522sunspider-1.0%2522,%2520%25223d-cube%2522:%255B11,8,47,7,19,12,19,13,16,8%255D,%25223d-morph%2522:%255B7,7,8,7,43,7,41,14,7,7%255D,%25223d-raytrace%2522:%255B9,14,10,10,9,10,9,14,9,12%255D,%2522access-binary-trees%2522:%255B2,5,1,2,2,2,2,4,2,2%255D,%2522access-fannkuch%2522:%255B12,12,12,12,12,12,12,8,13,13%255D,%2522access-nbody%2522:%255B10,42,7,4,4,22,6,6,21,7%255D,%2522access-nsieve%2522:%255B2,2,2,8,2,3,2,2,33,4%255D,%2522bitops-3bit-bits-in-byte%2522:%255B2,2,1,2,1,1,1,1,1,1%255D,%2522bitops-bits-in-byte%2522:%255B5,4,5,4,4,4,4,4,4,4%255D,%2522bitops-bitwise-and%2522:%255B3,4,4,3,3,4,4,3,4,4%255D,%2522bitops-nsieve-bits%2522:%255B6,6,6,41,6,6,5,6,6,6%255D,%2522controlflow-recursive%2522:%255B2,2,3,2,3,2,3,2,3,3%255D,%2522crypto-aes%2522:%255B13,6,9,5,5,6,6,7,7,8%255D,%2522crypto-md5%2522:%255B6,8,5,5,4,5,5,5,6,5%255D,%2522crypto-sha1%2522:%255B10,5,5,5,6,6,5,6,6,6%255D,%2522date-format-tofte%2522:%255B47,9,9,9,11,8,8,8,9,10%255D,%2522date-format-xparb%2522:%255B10,10,9,12,15,14,14,10,14,11%255D,%2522math-cordic%2522:%255B3,3,4,3,4,4,3,3,3,7%255D,%2522math-partial-sums%2522:%255B11,13,9,8,17,12,18,9,12,11%255D,%2522math-spectral-norm%2522:%255B2,3,3,5,6,3,7,2,3,2%255D,%2522regexp-dna%2522:%255B8,8,12,8,40,7,31,9,7,13%255D,%2522string-base64%2522:%255B4,4,10,4,5,5,6,5,5,10%255D,%2522string-fasta%2522:%255B10,10,46,10,11,10,9,11,11,38%255D,%2522string-tagcloud%2522:%255B25,24,23,27,23,23,22,24,27,26%255D,%2522string-unpack-code%2522:%255B23,40,24,23,29,22,28,32,37,22%255D,%2522string-validate-input%2522:%255B14,12,14,7,7,18,8,7,37,14%255D%257D">Chrome 26</a> . <br><br>  Can you tell the difference?  Because there is none.  <b>Recently, nothing revolutionary has happened in the code that executes JavaScript</b> . <br>  If it seems to you that the web has accelerated in comparison with 2010, then this is most likely due to the fact that your computer is faster and has nothing to do with Chrome improvements. <br>  <b>NOTE</b> .  Some clever men noted that the SunSpider test is not suitable at the current time (without citing concrete evidence).  In the interest of truth, I launched Octane (an old Google performance test) on older versions of Chrome and saw some improvements: <br><img src="https://habrastorage.org/getpro/habr/post_images/39f/5b9/8bf/39f5b98bf71198cc62ef7198a9d78397.png" alt="image"><br>  In my opinion, the performance gain over this period is too small to claim that JS will catch up with the native code in a reasonable period of time.  Honestly, I went over a bit: JS performance grew over this period.  However, in my opinion, these figures still confirm my hypothesis: that JS will not catch up with the native code in a reasonable time.  You need to increase performance from 2 to 9 times to catch up with LLVM.  There are improvements, but they are insufficient.  <b>END OF COMMENTS.</b> <br><br>  In fact, the idea is to speed up JS with the help of JIT - 60 years and during this period all kinds of research and thousands of optimizations have been done for all conceivable programming languages.  But this came to an end, guys, we squeezed out of these ideas all that was possible.  The end of the film.  Maybe in the next 60 years we will come up with something new. <br><br><h4>  BUT SAFARI IS EVERYTHING WORKING FASTER THAN BEFORE </h4><br>  But if everything is as you say, why do we constantly hear about a significant increase in JS performance?  Every week someone talks about the next acceleration in the next performance test.  Apple claims that it has achieved a tremendous speed increase of 3.8 times on the JBench test: <br><img src="https://habrastorage.org/getpro/habr/post_images/e6b/1a5/3c9/e6b1a53c9e1a46884485b909693c0e6a.png" alt="image"><br>  Perhaps Apple is in the hands of the fact that this version of Safari is still under the <a href="http://en.wikipedia.org/wiki/Non-disclosure_agreement">NDA</a> agreement ( <i>from translator: non-disclosure</i> ), so no one else is able to publish independent measurements.  But let me draw some conclusions based solely on public information. <br>  I find it quite amusing that Apple‚Äôs JS performance in the JSBench test is much higher than the claimed performance in traditional tests such as SunSpider.  For JSBench <a href="http://sss.cs.purdue.edu/projects/dynjs/jsbench-oopsla-2011.pdf">are well-known personalities</a> , such as Brenden Eich (creator of JavaScript).  However, unlike traditional tests, JSBench does not use programs that multiply numbers or do something similar.  Instead, JSBench sucks up what Amazon, Facebook, and Twitter give out and builds its performance tests on this basis.  If you are writing a browser that most people use to go on Facebook, then of course having a test that mimics Facebook will be quite useful.  On the other hand, if you are writing a tabular application, a game or a graphic filter, it seems to me that the traditional performance test with its multiplications and calculations of md5 hashes will be much more adequate and useful than information about how fast Facebook analytics works. <br>  Another important fact is that the improvement in the SunSpider test (according to Apple) does not mean that everything else is automatically accelerated.  In a note representing Apple‚Äôs preferred performance test, Eich and others write: <br><blockquote>  This chart clearly shows that, according to the SunSpider test, the performance of FireFox has increased 13 times from version 1.5 to version 3.6.  However, if you look at the performance in the amazon test, here we see a moderate increase of 3 times.  Curiously, over the past two years, productivity growth in the amazon test is practically not observed.  I believe that many optimizations that worked perfectly in the SunSpider test do not play a role for the amazon test. </blockquote><br>  In this article, the creator of JavaScript and one of the top architects of Mozilla openly admits that over the past two years, nothing has happened to JavaScript in the Amazon test, moreover, nothing revolutionary has happened in the whole history.  This is an example of how the guys from the marketing department overestimate things a bit lately. <br>  (They keep insisting that the Amazon test helps predict the Amazon runtime better than the SunSpider test [hello KO!], So it's useful for browsers that people use to go to Amazon. But none of this will help you write a photo web application). <br>  In any case, based on publicly available information, I want to note that the assurances of Apple in the 3.8-th performance increase will not bring you any benefit.  I also have to say that, even with tests in hand, which refute Apple‚Äôs statement that Safari is ahead of Chrome, I would not have the right to publish them. <br>  Let's end this section with the conclusion that even if someone drew a graph on which his browser has become faster, it does not necessarily mean that JavaScript as a whole becomes faster. <br>  But there is a bigger problem. <br><br><h4>  DESIGNED NOT FOR HIGH PERFORMANCE </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/7a5/9ff/507/7a59ff507a289a4b3ff08e61a5308a6d.jpg" alt="image"><br>  ( <i>from the translator: the left book is called ‚ÄúJavaScript: good sides‚Äù, the right one is ‚ÄúJavaScript: a complete reference book‚Äù</i> ). <br><br>  To quote <a href="http://herbsutter.com/2012/04/02/reader-qa-when-will-better-jits-save-managed-code/">Herb Sutter</a> , a large size in the world of modern C ++: <br><blockquote>  This meme can no longer be destroyed - <i>‚Äújust wait for the next generation (JIT or regular) compilers, and the managed code will work on them relatively efficiently‚Äù</i> .  Yes, I'm waiting for improvements in the C # and Java compilers - and JIT, and NGEN-like static compilers.  But, no, they will not erase the performance difference with native code for two reasons.  First, JIT compilation is not a major issue.  The root cause of the lag is more fundamental: <b>managed platforms were deliberately designed to increase programmer productivity, even if this was at the expense of performance</b> .  In particular, the creators of managed platforms decided to spend resources on certain opportunities, even if they are not used by the application;  The main features of this feature are: always running garbage collection, virtual machine execution system and metadata.  But not only that, there are other examples: in managed languages, function calls are virtual by default, while in C ++, calls are inline by default ( <i>from the translator: that is, the function body is directly compiled into code instead of call / ret</i> ) and a spoon  inline-    . </blockquote><br> <a href="http://tirania.org/blog/archive/2012/Apr-04.html"> </a>  Miguel de Icaza   Mono,       ¬´,  JIT-¬ª.  He says: <br><blockquote>          managed  (.NET, Java  JavaScript).  managed       . </blockquote><br>   <a href="http://vimeo.com/61044810">Alex Gaynor</a> ,     JIT  Ruby       JIT  Python: <br><blockquote>   ,  .      -. ( <i> : ,              </i> )   ,   C-  -,    C   .     . -,     C ‚Äî    .   ,   Python, Ruby, JavaScript     ,       ‚Ä¶  ,   ‚Ä¶ </blockquote><br> <a href="https://gist.github.com/paulmillr/1208618">Google</a> , , ,  JavaScript      : <br><blockquote>  - ‚Äî    Google ‚Äî        ,          . </blockquote><br> ,  . <a href="http://catwell.info/"></a>       <a href="http://lambda-the-ultimate.org/node/3851"> </a> Brendan Eich. , ,    ,   JavaScript. <br><blockquote>   Mike  : <b> </b> . Lua  ,  JS.  ,      ,    ,     JIT- (   JS) </blockquote><br>   : <br><blockquote>     JS  Lua,  ,        (    ?),   ,     ,   . , ,         ,      . <b> JS   ,   Lua.</b>  :  Lua (    metatable)        JS. </blockquote><br> ,   ,  JS ( )    ( )  C,  ,     ,  .   - ,     ‚Äî     (    - ) ‚Äî .    ¬´  JIT-        C¬ª  ,    , : ¬´,       API¬ª. <br><br>     . <br><br><h4>      </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/1aa/216/c8d/1aa216c8df16a79a0dc2bf9191e37683.jpg" alt="image"><br>   ,   ,     ‚Äî      ,     ‚Äî     .  ‚Äî  . ,  ,      ,     ‚Äî    .  ,           . <b>  , , ,        .</b> <br>  2012 Apple      (  ,     John Gruber  <a href="http://daringfireball.net/linked/2011/09/19/the-unfamiliar"></a> ).      OSX.  ,  <a href="https://developer.apple.com/legacy/library/documentation/Cocoa/Conceptual/GarbageCollection/GarbageCollection.pdf"> </a> .        ¬´   ¬ª.      Ruby,  Python,  JavaScript,  Java,  C#,    ,   1990,   ,  ,  .  ,         ObjC. ,  ,  <i></i> .  - ,        <b> </b> .     <i></i> ? ,   Apple: <br><blockquote>   ,  ARC      ,        OSX (- Session 101, Platforms Kickoff, 2012, ~01:13:50) </blockquote><br>     ? <b>    .</b> ,   <b>- </b> .   ,    ,  <b> </b>   ¬´---¬ª?         Matz-       RubyConf.   <b></b> ? . <br>      -,         ‚Äî <b> - </b> .       ,  . <br> ,  : <b>       ‚Äî  ,   </b> ? ,  ARC ‚Äî     Apple    ,          ,   . ,        iOS. <br><br><h4> ARC     </h4><br> ,  ,  ARC ‚Äî   ,        Apple: <br><img src="https://habrastorage.org/getpro/habr/post_images/c59/d01/ab9/c59d01ab9b7a39fbb09417d0e72e450b.png" alt="image"><br> ( <i> : <br>    ARC: <br> ‚Äî  runtime  ; <br> ‚Äî  malloc, free,  . <br> ‚Äî  : <br> ‚Äî   ; <br> ‚Äî    ; <br> ‚Äî    . <br></i>  ) <br>    <a href="http://en.wikipedia.org/wiki/Reference_counting">   </a> .    ,     ,     ,      ,   ,  ,  . , . ARC ‚Äî   . <br>      ,          ( <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html"></a>  ,       )  <a href="https://www.google.com/search%3Fclient%3Dsafari%26rls%3Den%26q%3Dios%2B5%2Bgarbage%2Bcollection%26ie%3DUTF-8%26oe%3DUTF-8">    </a> ,   ‚Äî .  It is not true. ,  . <br><br><h4>     ,      </h4><br>    Apple  ARC  GC ( ),    : <br><blockquote>     ,      ,      iOS.       .  ,     .          .        ,      CPU     .  , GC       .   G,     retain/release   ,  ,  .        ,              .  ,   ,            (~Session 300, Developer Tools Kickoff, 2011, 00:47:49). </blockquote><br>    ?!  : <br> 1.         ; <br> 2. Windows Mobile, Android, MonoTouch       GC. <br>     . <br><br><h4>         ,      </h4><br> ,   .      N .  2013 .       . <br> <a href="http://www-cs.canisius.edu/~hertzm/gcmalloc-oopsla-2005.pdf"> </a> ,   . , <b>   </b> : <br><img src="https://habrastorage.org/getpro/habr/post_images/a42/2be/986/a422be986ec2534422117f7a09024046.png" alt="image"><br> <b>         - , <u>    </u></b> .  Y ‚Äî  ,    .  X ‚Äî  ¬´  ¬ª.   ? <b>    </b> . <br>  ,      : ¬´    6   ,     ,  ‚Äî  . <b>  ,    4   </b> ¬ª.     : <br><blockquote> ,       5   ,  ,         . ,     ,       .  3-    ,  ,   17% ,     ‚Äî  70% .      ,   . <b>  ,            .</b> </blockquote><br>     ()  : <br><blockquote> These graphs show that if an application has a reasonable amount of memory available (but not enough to fit the entire application), both direct memory managers are much faster than all garbage collectors.  For example, pseudoJBB with 63 MB of available memory and the Lea allocator complete the task in 25 seconds.  The same amount of GenMS memory takes 10 times longer (255 seconds).  Similar behavior is observed on all tests included in the set.  The most distinctive test is 213 javac: for 36 MB of memory with the Lea allocator, the total running time is 14 seconds, while the test time for GenMS is 211 seconds, which is 15 times longer. <br></blockquote><br>  The fundamental conclusion is that the performance of the garbage collector in an environment with a limited amount of memory is sharply reduced.  If you are programming on Python, Ruby or JavaScript on desktops, then most likely, <b>you are always on the right side of the graph</b> and in your entire life you will never encounter a slow garbage collector.  Go to the left side to understand what others are dealing with. <br><br><h4>  HOW MUCH MEMORY IS AVAILABLE APP ON IOS? </h4><br>  It is hard to say for sure.  The amount of physical memory on devices varies from 512 MB on iPhone 4 to 1 GB on iPhone 5. But most of this memory is used by the system and also for multitasking.  The only way to check is to run in real conditions.  Jan Ilavsky has <a href="https://github.com/split82/iOSMemoryBudgetTest">created an application for this purpose</a> , but it seems no one has yet published the results.  Up to this day. <br>  It is important to measure the memory in ‚Äúnormal‚Äù conditions, because if you do it right after loading, the results will be better, because there are no costs for pages opened in Safari and the like.  So I literally took my devices scattered around the apartment and drove the tests for them. <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/7f7/efd/d07/7f7efdd07b86dd4c0f55abff64cbe015.png" alt="image"></a> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/428/cae/031/428cae031f60c0f8707437d8c2664a5e.png" alt="image"></a> <br>  To see the details, click on the picture, but, strictly speaking, on the iPhone 4S, the application begins to receive warnings about a lack of memory, allocating about 40 MB, and is terminated at (approximately) 213 MB.  On the iPad 3, a warning of 400 MB and a termination of 550 MB.  Of course, these are my results - if the user listens to background music, then the memory may be much less, but this is at least some guide to start.  It seems a lot (213 MB should be enough for everyone, right?), But from a practical point of view, not enough.  For example, the iPhone 4S takes pictures of 3264 √ó 2448 pixels.  This is approximately 30 MB of data per snapshot.  This means receiving a warning when <b>there are only two snapshots in memory</b> and terminating an application that holds <b>7 snapshots in memory</b> .  Oh, you wanted to write a cycle on the photos in the album?  The application will be closed! <br>  It is important to emphasize that in practice very often the same snapshot is stored in several places in memory.  For example, if you take a picture from a camera, then 1) the screen of the camera is stored in memory, which displays what it sees 2) the picture that the camera took 3) the buffer in which you compress the JPEG image to save to disk 4) the version of the snapshot you want to show on the next screen 5) the version of the snapshot that you upload to some server. <br>  At some point, you will realize that using a 30 MB image buffer for displaying thumbnails is not a good idea and add 6) a buffer for the thumbnail to the next screen 7) a buffer in which the thumbnails are actually created in the background (since this is not possible in the main stream ‚Äî too slowly).  And then you suddenly realize that thumbnails are actually required of 5 different sizes and slowly begin to go crazy.  In short, even when working <b>with a single photo,</b> it is easy to exceed the available memory limit.  You may not believe me: <br><blockquote>  The worst idea with a limited amount of memory is to cache images.  When the image is copied to the output context or displayed on the screen, it is necessary to decode it into a bitmap.  4 bytes are allocated for each pixel in the bitmap, regardless of the image size.  This bitmap is ‚Äúsuspended‚Äù to the object with the original image and its lifetime coincides with the lifetime of the image object.  So, if you cache images that have been displayed on the screen at least once, then for each one you now store the associated bitmap.  Therefore, never put UIImages or CGImages into the cache, unless you have a very valid (and short) reason to do so.  - Session 318, iOS Performance In Depth, 2011 <br></blockquote><br>  Yes, you can even not believe them.  In fact, the size of the memory that your application allocates is the tip of the iceberg.  Seriously, here is the slide on which the iceberg itself is presented (Session 242, iOS App Performance - Memory, 2012): <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/edf/bf0/2f0/edfbf02f06a6292732e2769e5336d1aa.png" alt="image"></a> <br>  <i>(slide translation: NOT ONLY OBJECTS</i> <i><br></i>  <i>* heap memory</i> <i><br></i>  <i>- * + [NSObject] alloc] / malloc</i> <i><br></i>  <i>- * objects / buffers allocated by frameworks</i> <i><br></i>  <i>* another memory</i> <i><br></i>  <i>- * code and global variables (___TEXT, ___DATA)</i> <i><br></i>  <i>- * thread stacks</i> <i><br></i>  <i>- * image data</i> <i><br></i>  <i>- * CALayer buffer</i> <i><br></i>  <i>- * database caches</i> <i><br></i>  <i>* memory, outside your application</i> <i><br></i>  <i>)</i> <br>  And this candle burns from both ends.  It‚Äôs much harder to work with photos if you have only 213 MB, unlike the desktop.  And at the same time, the demand for photo applications is much higher, <b>since your desktop does not have a cool camera and it does not fit in your pocket</b> . <br>  Take another example.  For iPad 3, the display resolution is likely to exceed the resolution of your monitor (in terms of cinematography, this screen is in the range between 2K and 4K).  Each image frame takes 12 MB.  If you do not want to violate the memory limits, you can store approximately 45 frames of uncompressed video or animation in memory at the same time, which takes 1.5 seconds at 30 FPS, or .75 seconds with the system 60 FPS.  Randomly placed in the buffer a second full-screen animation?  The application will be closed.  And here you can also note <a href="http://stackoverflow.com/questions/9997882/detecting-the-airplay-latency">that the delay in AirPlay is 2 seconds</a> , so for any media application you are <b>guaranteed not enough memory</b> . <br>  And here again the same problem of multiple copies of the image arises.  For example, <a href="http://developer.apple.com/library/ios/">Apple claims</a> that ‚ÄúCALayer is associated with each UIView and the images of the layers remain in memory while CALayer is in the hierarchy of objects‚Äù.  This means that there may be many images in memory with an intermediate representation of your view hierarchy. <br>  There are also clipping rectangles and layer buffers.  This is a great architecture in terms of CPU savings, but its performance is achieved by allocating as much memory as possible.  iOS is <i>not designed in terms of saving memory, but in terms of high performance</i> .  Which is not very well combined with garbage collection. <br>  And again the candle burns from two ends.  We have not only a very limited environment for full-screen animation.  But the huge demand for high-quality video and animation, since this terrible, little-memorable environment is in fact the only form factor in which you can purchase a high-quality film display.  If you want to create programs for such permission on desktops, then first convince your users to spend <a href="http://www.cdw.com/shop/products/HP-ZR2740w-LED-monitor-27in-Smart-Buy/2501971.aspx">$ 700</a> only on the monitor.  Or they can buy an iPad for $ 500, and it already has a computer. <br><br><h4>  WILL THE NUMBER OF AVAILABLE MEMORY INCREASE? </h4><br>  Some clever people say to me - ‚ÄúOK, you convinced us that we won‚Äôt get a faster mobile CPU.  But the amount of memory will grow, right?  Grew up on desktops. ‚Äù <br>  The problem with this theory is that the ARM <b>memory is on the processor itself</b> .  This scheme is called <a href="http://en.wikipedia.org/wiki/Package_on_package">package on package (PoP)</a> <i>(from translator: chip on chip)</i> .  So the difficulties of increasing the memory volumes are in fact <i>similar to the</i> difficulties of overclocking the CPU, since they boil down to how to fit more transistors per chip.  Memory transistors can be slightly lighter, they are the same in size, but still difficult. <br>  If you <a href="http://www.ifixit.com/Teardown/Apple%2BA6%2BTeardown/10528/2">look at the A6 image on the iFixit website</a> , you will see that almost 100% of the area on the chip's surface is occupied by memory.  This means that <b>to increase memory, it is necessary to reduce the process technology or increase the chip</b> .  And if measured relative to technical process, then an increase in memory every time is associated with an increase in chip size: <br><img src="https://habrastorage.org/getpro/habr/post_images/84a/8ec/729/84a8ec729aec50b3fd2ffa8dcb508753.png" alt="image"><br>  Silicon is not an ideal material, so with the increase in size, there is an exponential increase in the cost of suitable chips.  And such chips are harder to cool and put in a mobile phone.  And they have the same problems as the CPU, because the memory is the top layer of the chip, into which more transistors have to be pushed. <br>  What I <b>don't know</b> is why manufacturers, in the face of these PoP problems, continue to use it.  I did not find an ARM engineer who would explain it to me.  Maybe someone will write a comment.  It may be worth refusing from PoP in favor of separate memory modules as on desktops.  But since this is not, then there is some reason not to do it. <br>  However, several engineers wrote to me. <br>  Former Intel engineer: <br><blockquote>  As for PoP.  This architecture greatly increases throughput and simplifies routing.  But I don‚Äôt do ARM and I don‚Äôt know everything. </blockquote><br>  Robotics engineer: <br><blockquote>  When PoP becomes lacking, ‚Äú3D‚Äù memory will be able to give ‚Äúenough memory for all‚Äù: memory chips stacked up with the ability to place more than 10 layers of 1 GB of memory in the same volume as now.  But: costs will increase, and the voltage and frequency will have to be reduced in order to meet the power limits. <br>  Mobile memory bandwidth will not grow as fast as it did before.  It is limited by the number of lines between the CPU and the memory.  Currently, most of the CPU peripheral connections are used for the memory bus.  The middle part of the CPU cannot be used for this due to technical limitations.  The next breakthrough should be expected from the integration of memory right inside the CPU: this will increase the bandwidth, there will be more CPU design freedom and the voltage will drop.  And perhaps a large fast cache will appear. </blockquote><br><h4>  BUT HOW, THEN MONO / ANDROID / WINDOWS MOBILE SUCCESSFULLY MANAGE WITH THIS? </h4><br>  There are two answers to this question.  The first follows from the schedule ( <i>from the translator: memory consumption by the garbage collector</i> ): if you have 6 times more memory than you need, then garbage collection is fast.  If, say, you are programming a text editor, then you can easily keep within 35 MB, which is 1/6 of the memory limit on which the application on the iPhone 4S is terminated.  So you can take Mono, write an editor, make sure that it works quickly and calculate that garbage collection is quite fast.  And you will be right. <br>  Yes, but the <a href="http://xamarin.com/apps/app/infinite_flight_app">flight simulator</a> is included with Xamarin.  It turns out that garbage collection works fine for large mobile applications?  <a href="http://conversations.nokia.com/2012/06/01/interview-with-matthieu-laban-infinite-flight-ceo/">Or not</a> ? <br><blockquote>  What problems did you encounter while developing this game?  ‚ÄúPerformance was a major issue and continues to be so on all platforms.  The first Windows Phone were rather slow and we had to spend a lot of time optimizing in order to achieve an acceptable FPS.  These optimizations affected both the simulation code and the 3D engine.  ‚ÄúNarrow neck‚Äù is garbage collection and GPU weakness. ‚Äù </blockquote><br>  Without the slightest hint of a question, developers cite garbage collection as one of the main performance bottlenecks.  If people in your development team do it, you <b>should consider</b> .  But maybe Xamarin is not a typical example.  <a href="http://www.war-worlds.com/blog/2012/06/on-android-garbage-collection-can-kill-you">Read</a> developers on Android: <br><blockquote>  Please note - applications run on my Galaxy Nexus - to name that language does not turn slow.  Look at the time spent rendering.  On the desktop, these images were created in a couple of hundred ms, while on a mobile device it was spent <b>two orders of magnitude more time</b> .  More than 6 seconds on ‚Äúinferno‚Äù ( <i>from translator: a planet with complex rendering</i> )?  Madness! .. During this time, the garbage collector will work 10-15 times. </blockquote><br>  <a href="http://nhenze.net/%3Fp%3D349">More</a> : <br><blockquote>  If you are going to be engaged in processing camera snapshots on Android devices for recognizing objects in real-time or for creating Augmented Reality, <b>you probably heard</b> about the problem of camera preview memory.  Whenever a Java application receives a preview image, a new buffer is allocated in memory.  When this buffer is released by the garbage collector, the system freezes for 100‚Äì200 ms.  Even worse, if the system is under load (I do image recognition - it eats away the entire CPU).  If you look at the sources of Android 1.6, you will see that this happens for the reason that the wrapper (which protects us from the native code) allocates a new memory buffer for each new frame.  <b>The built-in native code of this problem, of course, does not</b> . </blockquote><br>  Or we can read <a href="http://stackoverflow.com/questions/2484079/how-can-i-avoid-garbage-collection-delays-in-java-games-best-practices">Stack Overflow</a> : <br><blockquote>  I am engaged in improving the performance of an interactive Java game for Android.  From time to time there is a delay in garbage collection in the display or interaction.  It usually lasts less than a tenth of a second, but sometimes it can take 200 ms on slow devices ... If I suddenly need hashes in the internal loop, I know that I need to be careful or rewrite them myself instead of using the Java Collections framework because allow extra garbage collection. </blockquote><br>  Here is the most significant answer, 27 votes "for": <br><blockquote>  I was involved in Java mobile games ... The best way to avoid garbage collection (which will occur at an arbitrary point in time and kill the game's performance) is not to create objects in the main loop at all.  There is no other way ... <b>Only <s>hardcore</s> manual control of objects, alas</b> .  So do all the major high-performance games on mobile devices. </blockquote><br>  Listen to <a href="http://blog.crazybob.org/2011/12/truth-about-android-ios-ui-performance.html">Jon Perlow</a> from Facebook: <br><blockquote>  The garbage collector is a huge performance problem when developing "smooth" applications on Android.  In Facebook, one of the main problems is the fading of the UI stream during garbage collection.  When you process a large number of bitmaps, garbage collection occurs frequently and cannot be avoided.  One such collection results in the loss of several frames.  Even if the assembly blocks the main thread for only a few milliseconds, it may not allow the frame to be generated in the 16 ms allocated for it. </blockquote><br>  Read <a href="http://geekswithblogs.net/mikebmcl/archive/2010/07/30/wp7-xna-the-gc-and-you-and-silverlight-too.aspx">Microsoft MVP</a> : <br><blockquote>  Normally, your display code will be set at 33.33 ms ( <i>from translator: one frame</i> ), while maintaining an acceptable 30 FPS ... However, garbage collection takes time.  If you do not litter on the heap, the assembly will work quickly and will not be a problem.  But keeping the hip ‚Äúclean‚Äù enough to quickly process the garbage collector is a <b>complex programmer task that requires careful planning and rewriting of the code and still does not guarantee stable operation</b> (as a rule, a lot of things are stored in a complex game of hip) .  It is easier (if possible) to limit or, <b>in general, not to allocate memory during the game process</b> . </blockquote><br>  The best way to beat the garbage collector is <b>not to play at all</b> .  This statement (in a more mild form) <a href="http://developer.android.com/training/articles/perf-tips.html">is in the official Android documentation</a> : <br><blockquote>  Creating an object is not free.  A garbage collector that uses generations and pools for each stream can speed memory allocation, but memory allocation is always more expensive than memory allocation.  As you allocate more and more objects, you will encounter periodic garbage collection, which causes small interface delays.  The garbage collector, which appeared in Android 2.3, works better, but you still need to avoid unnecessary work.  So do not create objects that you do not need ... More precisely, you should not create temporary objects if this is not necessary.  Fewer objects, less assembly, which has a positive effect on usability. </blockquote><br>  Still not convinced.  Let's <a href="http://blogs.msdn.com/b/abhinaba/archive/2009/03/02/back-to-basics-generational-garbage-collection.aspx">ask the Garbage Collection Engineer</a> .  Which writes collectors.  And earns his bread by this.  In short, this is the guy who has <i>to</i> know all this <i>by work</i> . <br><blockquote>  However, with the advent of WP7, device capabilities in terms of CPU and memory performance have increased dramatically.  There were games and applications on Silverlight, occupying 100 MB of memory each.  As the available memory increases, the number of objects <b>has grown exponentially</b> .  According to the scheme (described above), the garbage collector must bypass each object and all its links in order to mark them (mark) and later to clean (sweep).  So the time spent on garbage collection has also increased significantly and has become dependent on the size of the ‚Äúreference network‚Äù of the application.  This has led to very long pauses in cases of large XNA games and SL applications, which leads to their long loading (since the assembly is working at this time) and jerking during the game / animation. </blockquote><br>  Still not convinced?  Chrome <a href="http://v8.googlecode.com/svn/branches/bleeding_edge/benchmarks/spinning-balls/index.html">has a test</a> that measures the performance of garbage collection.  Let's see how he copes ... <br><img src="https://habrastorage.org/getpro/habr/post_images/05b/a2d/bf3/05ba2dbf3ac872df05b3c9607aeb2bae.png" alt="image"><br>  We see a <b>considerable</b> number of stops spent on garbage collection.  Yes, this is a stress test, but still.  Are you really ready to wait 1 second when rendering a frame?  You are crazy. <br><br><h4>  LISTEN, QUOTE TOO MUCH, CAN'T ALL THEM READ THEM.  LET'S ALREADY CONCLUSION. </h4><br>  Here is the conclusion: on mobile devices, memory management is <b>not easy</b> .  iOS has developed a culture of manual control of most things, with the compiler doing simple things.  Android promotes improved garbage collection, which they themselves are trying hard not to use.  In any case, when writing applications for mobile devices it is necessary to break the head over memory management.  It is simply impossible to avoid. <br>  When JavaScript or Ruby or Python programmers hear about garbage collection, they think it is garbage collection as a magic wand.  They think "garbage collection gives me the opportunity not to think about memory management."  But on mobile devices there is no such ‚Äúmagic wand‚Äù. <b>        ,    ‚Äî   ,   </b> .     ¬´-¬ª       ,     ‚Äî   10   ,  . <br>   JavaScript   ,      . <a href="https://groups.google.com/forum/%3Ffromgroups%3D">   </a> : <br><blockquote>    -       ?   ‚Äî     . </blockquote><br> <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf"> ECMA</a>    ¬´ ¬ª (allocation),    ¬´¬ª ,      ¬´¬ª (host-defined). <br>   ECMA  6  <a href="http://wiki.ecmascript.org/doku.php%3Fid%3Dstrawman:gc_semantics%26s%3Dgarbage%2Bcollector">  </a> ,     (  ): <br><blockquote>      ,         ‚Ä¶  ,  ()      ,         . </blockquote><br>  ,       :      ,    ,    ,   .    <a href="http://xkcd.com/703/"> </a> . ,       : <br><blockquote>  ,     ,     ,  <u><b>    </b></u> .       ,       ,       . </blockquote><br> -:  JavaScript (   )   ,  <b>      ,     , </b> .   <b></b>   ,      ,       ,    . :   iOS        ,      . ,      ,   iOS   ,     .    ,     . <b> JavaScript   </b> .    ,      ,     .  ,      SunSpider   ,   CPU,    ,  <b>JavaScript       ¬´--¬ª,         </b> . <br>   ,          ,    -    ,    ,       ,    .  <i>   </i>   .  JavaScript <b>  , </b> . <br><br><h4>    ? </h4><br>     ‚Äî ¬´, JavaScript           .    .  -,    ,  JavaScript.  ,    - ?¬ª <br>  ,     ,     .   ,     ,         ‚Äî    <a href="http://www.rubymotion.com/">RubyMotion</a> . <br>   ,    Ruby.    ,        ‚Äî    (   ?).        ,    ARC.   <a href="http://joshsymonds.com/blog/2013/06/26/why-im-not-using-rubymotion-in-production/"> - </a> : <br><blockquote> :       ,    RM-3 ( <i> : <a href="http://hipbyte.myjetbrains.com/youtrack/issue/RM-3"> RubyMotion</a> ,      11  2013</i> )   -  ,      RubyMotion. </blockquote><br> Ben Sheldon <a href="https://groups.google.com/forum/"></a> : <br><blockquote>    .     ,    ( SIGSEGV  SIGBUS),    10-20% . </blockquote><br>     ,    : <br><blockquote>     RM-3       Laurent,  Watson. Watson ,  RM-3 ‚Äî     , Laurent ,     ,     .    ,   . </blockquote><br>   ,    : <br><blockquote>    ,      ,       ,  ,        .  ,              .          (   , ).    : instance_eval.      . </blockquote><br>  RubyMotion    ‚Äî <a href="http://hipbyte.myjetbrains.com/youtrack/issue/RM-32"> </a> .      .    ,    2  200 .    ,     .  . <br>    :        Ruby         ,     ,       .        ,       .    ,  ¬´    ,    (  )  ¬ª. <br>   ,   JavaScript,         ‚Äî .   ,       . <br>  Addition.   Rust: <br><blockquote>     Rust,           (zero-overhead memory safety).   GC-   "@-" (   "@ T"    T)    ,    ,       .      ,    ,         (  ).   , <b> ,    ,  JavaScript.</b> </blockquote><br><h4> ,   ASM.JS? </h4><br> ams.js  ,    JavaScript,    . ,  ¬´¬ª     API,   .   ,    ¬´ ¬ª. <br> Mozilla,   ,          .    . ,       Google: Dart  PNaCl.   <a href="http://code.google.com/p/v8/issues/detail%3Fid%3D2599"></a>   ,     V8 <a href="http://mrale.ph/blog/2013/03/28/why-asmjs-bothers-me.html">  </a> .   Apple,   WebKit <a href="https://lists.webkit.org/pipermail/webkit-dev/%2B%2522asm.js%2522%26ie%3DUTF-8%26oe%3DUTF-8"> </a> . IE?   . <br>   ,   ,      JavaScript   .     ‚Äî     JavaScript.   ,      .        C/C++       .        ,     . <br><br><h4>     ? </h4><br>      ¬´X ¬ª  ¬´X  ¬ª   ,      .    ,    ¬´¬ª   ,         .  ,           ,   <b>  </b> ,  <b></b>  <b> .</b> <br> <b>  ‚Äî  </b> ,   iPhone 4S Nitro   IE8,     .        . JS    ,      - ,   .       ,    . <br> <b>  ‚Äî  x86 C/C++</b> ,    -  iPhone 4S   C ,    50  ,    .      ARM    5  ‚Äî JavaScript.         -JavaScript ,     . <br> <b>  ‚Äî  Java, Ruby, Python, C#</b> ,    -  iPhone 4S  .  ,    ,    (  ARM)    ,     35     ,          .    ,     213 .            , . ,   ‚Äî       ,     . <br><br><h4>     </h4><br>    : <br> *  2013  JavaScript   ,                .: <br> ‚Äî   5    ; <br> ‚Äî    IE8; <br> ‚Äî  ,  x86 C/C++,   50 ; <br> ‚Äî  ,   Java/Ruby/Python/C#   10 ,      35         ; <br> *      ‚Äî       .    ,     ; <br> *           ,      API,      ; <br> *         .     ,     ; <br> *   ,    ‚Äî       ‚Äî     ; <br> * JavaScript      ,         ; <br> *       ,  ,      ; <br> *    asm.js,  , ,  C\C++,  -   JS. <br><br><h4>  <s></s>   </h4><br>  ,        ,           ,     ( ,   )  ,  ¬´        ¬ª  ¬´ ,    ,           ¬ª.    . <br>          ,       - : , , ,  .     ¬´   -    ¬ª.       ‚Äî   Facebook  HTML5     . <br>   ,      -      .    -   . </div><p>Source: <a href="https://habr.com/ru/post/188580/">https://habr.com/ru/post/188580/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../188570/index.html">Startup-gatherings: Aigul Mirzayanova held a master class on working with the audience in public speaking</a></li>
<li><a href="../188572/index.html">Facebook has enabled https for everyone</a></li>
<li><a href="../188574/index.html">Mobile Internet security inside and out</a></li>
<li><a href="../188576/index.html">Avaya Aura Communication Manager: Automatic Dialing</a></li>
<li><a href="../188578/index.html">XKeyscore is another secret program from the NSA of the USA, revealed by Snowden</a></li>
<li><a href="../188582/index.html">Limbo similar puzzle platformer - Monochroma</a></li>
<li><a href="../188586/index.html">The last day of the 21st century or the end of the oil toad?</a></li>
<li><a href="../188590/index.html">Roskomnadzor announced the introduction of the registry of sites with "pirated" movies</a></li>
<li><a href="../188592/index.html">Test automation of Android applications using Robotium and Spoon</a></li>
<li><a href="../188594/index.html">As I wrote fix widescreen permissions for FlatOut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>