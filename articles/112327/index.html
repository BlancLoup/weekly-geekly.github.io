<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The subtleties of regular expressions. Part 2: Returns and their quantity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1: metacharacters inside and outside character classes . 

 In this part, I would like to tell you about how the regular expression engines work,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The subtleties of regular expressions. Part 2: Returns and their quantity</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/blogs/regex/112016/">Part 1: metacharacters inside and outside character classes</a> . <br><br>  In this part, I would like to tell you about how the regular expression engines work, why some people think that regular expressions are very slow, and why the authors of many engines do not follow the POSIX standard. <br><a name="habracut"></a><br>  As in many problems, the problem of ‚Äúfinding a match in a string for a regular expression‚Äù exists in many approaches and principles for solving it.  The basic principles in this case are 2: matching the search, controlled by a regular expression, and matching by string.  Let's take a closer look at what each of these principles means. <br><br><h4>  String-driven matching </h4><br>  This type of regular expression engines is implemented using the so-called DKA ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">Deterministic State Machine</a> ).  The main advantage is the tremendous speed of finding matches (compared to another principle).  Naturally, this principle has a lot of flaws (otherwise it would not be interesting, right?). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First, the compilation time (meaning the compilation of a regular expression into the internal structures of the engine, and not the compilation of the source code of the program) can be extremely long (compared to another principle).  In fact, during compilation, a whole program of comparison of a specific pattern is created.  Since DFA is ‚Äúcontrolled‚Äù by a string, and we don‚Äôt know the string at compile time, the algorithm is created taking into account all possible strings.  For complex expressions, this is obviously not done so quickly. <br><br>  Secondly, DKA does not support very many convenient and necessary features to which we are used to regular expressions.  For example, saving brackets are not supported.  Of course, with the set that DKA has, it is impossible to do in more or less real situations.  Therefore, in its pure form, DKA is now almost not used anywhere.  But it is successfully used in the so-called "hybrid" engines, which in the simplest case, choose the engine that is most suitable for a particular regular expression. <br><br>  Thus, if you need to search in a huge amount of text and at the same time your regular expression is not too complicated, it is difficult to find anything better than DKA. <br><br>  So how does DKA work?  The engine is called ‚Äústring driven‚Äù because it works just like that.  The state machine reads the string in which to find matches, and makes comparisons of the string with the pattern.  At each moment in time, the algorithm ‚Äúknows‚Äù which parts of the pattern and lines coincide.  When the algorithm completely scans the entire line, it remains to select only the longest match that is closer to the beginning of the line and display it as an answer. <br><br>  For definiteness, we assume that we have a regular expression <code>^abc\w+e$</code> and two strings <code>abcde</code> and <code>abce</code> .  It is quite obvious that the expression matches the first line, but not the second. <br><br>  Let us consider how the search for a match occurs in the DFA mechanism.  For the first line has the following sequence: <br><br><ul><li>  The first character of the string ‚Äúa‚Äù matches the position with the metacharacter <code>^</code> .  Found 1 partial match. </li><li>  The first character of the string ‚Äúa‚Äù is the same as the second character of the pattern.  The algorithm continues to lead 1 partial match. </li><li>  The second character of the string ‚Äúb‚Äù is the same as the third character of the pattern.  The algorithm continues to lead 1 partial match. </li><li>  The third character of the string "c" is the same as the fourth character of the pattern.  The algorithm continues to lead 1 partial match. </li><li>  The fourth character of the string ‚Äúd‚Äù is the same as the fifth metacharacter <code>\w</code> pattern.  The quantifier requires that the metacharacter matches at least once.  The condition is fulfilled.  The algorithm continues to lead 1 partial match. </li><li>  The fifth character of the string ‚Äúe‚Äù is the same as the eighth character of the pattern.  The quantifier condition for the previous metacharacter is fulfilled, we can count the character ‚Äúe‚Äù as a match with the eighth character of the pattern, or as a match with the <code>\w</code> metacharacter.  The algorithm does both, and it continues to lead already 2 partial coincidences.  Remember this moment, in another principle there will be a very significant difference. </li><li>  The sixth character of the string is missing - matches the position with the <code>$</code> metacharacter.  Found 1 complete match, and the second partial does not meet expectations and is discarded. </li><li>  The line ended, return the result. </li></ul><br><br>  What will happen in the second case: <br><ul><li>  The beginning of the algorithm is exactly the same, immediately go to the fourth character of the string "e" </li><li>  The fourth character of the string ‚Äúe‚Äù is the same as the fifth metacharacter of the <code>\w</code> pattern.  The quantifier condition requires that at least one character match exists.  Therefore, "e" is captured by the <code>\w</code> metacharacter.  1 partial match </li><li>  The fifth character of the string is absent - there is no match with the symbol ‚Äúe‚Äù.  Obviously, the string does not match. </li><li>  The line has ended, there are no matches, we return the result. </li></ul><br><br>  What can we see in these two examples?  The algorithm doesn't care if we have a match or not.  It simply scans the string character by character and tries to match matches based on the pattern.  If at the end of the work we have several complete matches, then the result will be what is located closer to the left edge of the line and the longest. <br><br>  Actually, it becomes clear why the algorithm works so quickly.  Except in some cases, each character of the string is viewed only once.  It also becomes clear why a pattern is compiled for a long time - for complex patterns, many conditions and dependencies must be taken into account in order to correctly conduct partial matches. <br><br>  At the moment, the DKA engine is used in the grep utility as part of the engine selection mechanism and in the Tcl language as part of the hybrid engine, it‚Äôs probably used somewhere else, but I don‚Äôt know about it. <br><br><h4>  Regular expression driven matching </h4><br>  This type of regular expression engines is implemented using the so-called NCA ( <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BD%25D0%25B5%25D1%2587%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25B0%25D0%25B2%25D1%2582%25D0%25BE%25D0%25BC%25D0%25B0%25D1%2582">Nondeterministic Finite State Machine</a> ).  The main advantage is the support of a large number of functions (compared to another principle).  Naturally, this principle also has a lot of flaws. <br><br>  Firstly, the work time can be extremely long (compared to another principle).  Up to exponential asymptotics from the length of the input string.  Many popular engines even have protection against this by interrupting the search. <br><br>  Secondly, the NCA depends very much on how the regular expression is written.  If the DFA is absolutely all the same on the record form: the time and the search results will be exactly the same for any equivalent expressions, then for the NCA this is a whole problem.  One expression can give exponential asymptotics, and the other is almost linear.  Accordingly, the question of optimizing the pattern rises to its full height.  NCA is currently used in most regular expression engines. <br><br>  A key feature of the classic NCA is that it interrupts the search as soon as it finds the first complete match.  Those.  search results in some cases will be very different from DKA.  This is a feature of the algorithm. <br><br>  So why authors of engines do not hasten to follow POSIX?  The fact is that the semantics of DFA search is fixed in the standard.  Those.  Of course, it is not said literally that DFA should be used, but it is said about ‚Äúthe leftmost coincidence of the greatest length‚Äù.  But the NKA returns just the first, and not the greatest length.  And what to do?  In order to comply with the POSIX, they invented a modification of the algorithm, which is usually called the POSIX NCA.  And it works much longer than just an NCA.  Because in order to satisfy the standard, it is necessary to perform a brute-force search in general of all variants that a regular expression allows.  Next, I will explain why it is <i>much</i> longer. <br><br>  Compiled (the value is the same as for DCA) NCA is a sequential algorithm, instructions based on a pattern.  A key feature of NCAs is ‚Äúreturns.‚Äù  The search speed directly depends on their number. <br><br>  What returns are best explained by example.  Take the same two strings that were used in the DTA example, and the same regular expression. <br><br>  For the first line: <br><ul><li>  The first metacharacter of the pattern <code>^</code> - matches the position with the beginning of the line.  The return stack is empty. </li><li>  The second character of the pattern ‚Äúa‚Äù is the same as the first character of the string.  The return stack is empty. </li><li>  The third character of the pattern ‚Äúb‚Äù is the same as the second character of the string.  The return stack is empty. </li><li>  The fourth character of the ‚Äúc‚Äù pattern is the same as the third character of the string.  The return stack is empty. </li><li>  The fifth metacharacter of the string <code>\w</code> is the same as the fourth character of the string.  The quantifier requires at least one character, so there can be no return.  The return stack is empty. </li><li>  The fifth metacharacter of the string <code>\w</code> is the same as the fifth character of the string.  The quantifier requires at least one character that has already been captured.  At this point there may be a refund.  The return stack contains 1 item. <br>  At this intermediate stage, the NCA found as a coincidence the entire string ‚Äúabcde‚Äù, but had not yet completed the pattern.  The current position in the line is behind the ‚Äúe‚Äù symbol, although the ‚Äúe‚Äù symbol from the pattern itself has not yet coincided.  This is where the fun begins.  Watch your hands. </li><li>  The eighth character of the pattern ‚Äúe‚Äù - <i>does not</i> coincide in meaning with the sixth character of the string (it simply does not exist).  No match found.  Check the return stack - there is one record.  We carry out the return.  After the return, we are in the position ‚Äúbefore the character e‚Äù in the line and in the position ‚Äúbefore the character e‚Äù in the pattern.  The return stack is empty. <br>  When the NCA does not find a match, it checks the stack of returns.  When the return is executed, the position in the row is restored and the return is removed from the stack.  If the return stack is empty, but there is no match, then it is considered that there are no matches in this starting position in the string. <br></li><li>  The eighth character of the pattern ‚Äúe‚Äù is the same as the fifth character of the string.  The return stack is empty. </li><li>  The ninth metacharacter of the <code>$</code> pattern - coincides in position with the end of the line.  The return stack is empty. </li><li>  The pattern is over, there is a coincidence at the moment.  We return it. </li></ul><br><br>  What will happen in the second case: <br><ul><li>  The beginning of the algorithm is exactly the same; we immediately go to the eighth character of the ‚Äúe‚Äù pattern. </li><li>  The eighth character of the pattern ‚Äúe‚Äù <i>does not</i> coincide in meaning with the fifth character of the string (again, it simply does not exist).  No match found.  We check the return stack ‚Äî it is empty (empty because at the previous stage we didn‚Äôt add anything to the return stack, because the quantifier <code>+</code> requires at least one match).  Return cannot be performed.  The line did not match, we return the result. <br></li></ul><br><br>  For more understanding, I‚Äôll tell you that the <code>+</code> quantifier always captures as many characters of a string as it can.  Therefore, it is called the maximum.  This is a frequent error of beginners.  The pattern <code>\(.+\)</code> Will match in the line ‚Äúhere is the text (bracket) and then there is the text (another bracket) and here the text‚Äù with the part ‚Äú(bracket) and then there is the text (still bracket)‚Äù, and not with ‚Äú( bracket) ".  Just because at the processing stage <code>.+</code> whole line will be captured to the end, and as soon as we execute the returns, we will reach the ‚Äú)‚Äù symbol, so a complete match will be found right away.  Let's slightly change the regular expression: <code>\([^)]+\)</code> and now there is no problem in it that interfered with us.  But another one appeared (and how could it be without it).  Now, in the line ‚Äúhere is the text (bracket (and inside there is another bracket) well, and again the text) and then there is text‚Äù will be captured ‚Äú(bracket (and inside is another bracket)‚Äù, which is of course not correct. This will happen because at the capture stage, we will not reach the second closing bracket and immediately return the match found on the first one. I will not consider this example further, because in the general case the problem of balanced brackets cannot be solved only with the help of regular expressions. In .NET there is a special construct that allows you to solve the problem  balance checks (namely checks). <br><br>  Actually, I was a little bit mean when I described how exactly the algorithm works.  The fact is that it will work this way if the engine applies optimization (obviously, if the pattern starts with a <code>^</code> , then either it will match at the beginning of the line, or it will not match at all).  In fact, if we omit the optimization, the engine will perform exactly the same search starting with each next character of the line, if it does not find any complete matches in the previous step.  Those.  for the second line, 5 consecutive searches will be performed (starting before the ‚Äúa‚Äù symbol, then ‚Äúb‚Äù, ‚Äúc‚Äù, ‚Äúe‚Äù and the last one after the ‚Äúe‚Äù symbol), and only after that it will be possible to say that there are no matches.  DKA would deal with all cases in 1 pass.  But in the absence of a match, the NKA will need 5. <br><br>  The difference between the POSIX NCA engine will be that in the first case (when a match is found) the search would also not be stopped, but all 5 searches would be performed, as well as if there was no match, which of course is much longer. <br><br>  Now that we have considered the technique of performing returns, you can guess where the exponential search time is taken.  In some situations, the algorithm falls into the trap, creating a huge number of returns.  Consider, for example, the expression <code>(\w+)*a</code> .  If you apply it to the string "bbb", then what happens?  First, the first <code>+</code> quantifier captures the entire string and transfers control to the second quantifier.  Since there are no more characters in the string, go to the ‚Äúa‚Äù symbol of the pattern.  Which is not in the line, we perform a return by one character, re-take the newly released character into a new group, check ‚Äúa‚Äù, again there is no coincidence, return.  Further the meaning should be clear.  The algorithm will iterate over all possible line breaks to capture two quantifiers.  For the string ‚Äúbbb‚Äù these will be the options: ‚Äú[bbb]‚Äù, ‚Äú[bb] [b]‚Äù, ‚Äú[b] [bb]‚Äù, ‚Äú[b] [b] [b]‚Äù.  Where square brackets conditionally denote the captured group.  The number of partitions grows exponentially with the length of the string in this case. <br><br>  Another situation.  Imagine a 1 megabyte text and a view pattern <code>.*a</code>  What happens when you search?  At each stage, the entire megabyte line will be captured and successive returns will be performed until the ‚Äúa‚Äù character is found.  And if there is no such character in the string?  Then 1000001 searches will be done.  Which each time will capture the entire line from the current character to the end and return through it until it finds the character ‚Äúa‚Äù (which is not present).  In order to avoid this, it would be enough in this case to write <code>[^a]*a</code> .  But this is for this case.  In the general case (as in the example with brackets) this is not enough. <br><br>  About techniques for optimizing returns, you can write a lot more.  The next article I plan to devote to this. <br><br>  Based on the book by <a href="http://oreilly.com/catalog/9780596528126/">Jeffrey Friedl, Mastering Regular Expressions</a> . </div><p>Source: <a href="https://habr.com/ru/post/112327/">https://habr.com/ru/post/112327/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../112322/index.html">Books // Software Configuration Management Patterns</a></li>
<li><a href="../112323/index.html">Do not try to automatically update the Portable Virtual Box</a></li>
<li><a href="../112324/index.html">Sharp start. Thanks, habr!</a></li>
<li><a href="../112325/index.html">Html Agility Pack - convenient .NET HTML parser</a></li>
<li><a href="../112326/index.html">mflow - new social radio</a></li>
<li><a href="../112328/index.html">The second online conference mvcConf will be held on February 8</a></li>
<li><a href="../112329/index.html">Setup of FreeBSD for work of the Internet through Proxy server</a></li>
<li><a href="../112331/index.html">Microsoft has closed access to the source code utilities Sysinternals</a></li>
<li><a href="../112332/index.html">Manage Python packages with easy_install</a></li>
<li><a href="../112334/index.html">Cartographic capabilities of Samsung Bada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>