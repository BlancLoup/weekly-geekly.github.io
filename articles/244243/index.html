<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How do we measure the download speed of Yandex. Mail</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If your site loads slowly, you risk that people will not appreciate how beautiful it is, or how convenient it is. No one will like it when everything ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How do we measure the download speed of Yandex. Mail</h1><div class="post__text post__text-html js-mediator-article">  If your site loads slowly, you risk that people will not appreciate how beautiful it is, or how convenient it is.  No one will like it when everything slows down.  We regularly add new functionality to Yandex.Mail, sometimes we fix bugs, which means we constantly have new code and new logic.  All this directly affects the speed of the interface. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/244243/"><img src="https://habrastorage.org/files/7ac/393/255/7ac393255e9b4b9f9d7e4885133eed9d.jpg"></a> <br><br>  Yandex.Mail is opened every day by millions of people from different parts of the globe.  And no one should slow it down, so our work is not complete without various measurements.  In this post, we with <a href="https://habrahabr.ru/users/alexeimoisseev/" class="user_link">alexeimoisseev</a> and <a href="https://habrahabr.ru/users/kurau/" class="user_link">kurau</a> decided to talk about what metrics we have and what problems they solve.  Perhaps this is useful to you. <br><a name="habracut"></a><br><h3>  What is interesting to us </h3><br><ol><li>  The first time the interface is loaded. </li><li>  The time it takes to draw any block on the page (from a click before it appears in the DOM and is ready to interact with the user). </li><li>  The number of abnormally long page rendering and their causes (for example, abnormally long we consider any transition for more than two seconds). </li></ol><br>  We measure the time of the first page load with <a href="https://developer.mozilla.org/en-US/docs/Navigation_timing">NTA</a> .  NTA is used as follows.  The speed of the first load (that which the front-end can affect) is measured from <a href="http://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming.domLoading">PerformanceTiming.domLoading</a> until the moment of full rendering (this is not onload, but the actual time of the first drawing of letters).  I specifically emphasize this, as many measure speed from <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming.navigationStart">PerformanceTiming.navigationStart</a> .  A lot of time can pass between NavigationStart and domLoading, because it includes the time of redirects, dns lookup, connections, etc. And this metric is wrong.  For example, for the dns lookup and the connection time, the NOC and the administrators should be responsible, not the front-end developers.  Accordingly, it is very important, even in such metrics, to divide the area of ‚Äã‚Äãresponsibility. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Modern browsers, including IE9, have NTA support. <br><br>  But these measurements are not enough.  The user mail is loaded only once, and then he opens dozens of letters without reloading the page.  And it is important for us to know how quickly this happens. <br><br>  We make any changes to the page through a single module that allocates timers to different parts (preparation, data request from the server, template making, DOM update) and forwarding them to the consumer modules.  Timers are arranged through the usual Date.now ().  That is, when clicking on a link, we save the Date.now () value into a variable.  After updating the DOM, we again remember Date.now () and calculate the difference with the previous value. <br><br>  Interestingly, we did not immediately reach the separation of the update process at the stages and in the first versions we measured only the total execution time and the time of the request to the server.  Stages and detailed measurements appeared after an unsuccessful release, where we slowed down a lot and could not understand why.  Now the update module itself logs all its stages, and you can easily understand the reason for the slowdown: the server began to respond slower or JavaScript runs for too long. <br>  It looks like this: <br><br> <code>this.timings['look-ma-im-start'] = Date.now();</code> <br> <code>this.timings['look-ma-finish'] = Date.now();</code> <br> <br>  All timings are collected and calculated.  At stages, the difference between the ‚Äúend‚Äù and ‚Äústart‚Äù is not considered, and all calculations are made at the end: <br><br> <code>var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code> <br> <br>  And on the server such records arrive: <br><br> <code>serverResponse=50&amp;domUpdate=60&amp;yate=100</code> <br> <br><h3>  What we measure </h3><br>  Stages of the first boot: <br><ul><li>  training, </li><li>  static loading (HTTP request and parsing), </li><li>  execution of modules (declaration of models, types, etc.), </li><li>  initialization of base objects </li><li>  drawing, </li><li>  Execution of event handlers for the first drawing. </li></ul><br>  Stages rendering any page: <br><ul><li>  preparing for the request to the server </li><li>  request data from the server </li><li>  template making, </li><li>  DOM update, </li><li>  event handling at view, </li><li>  performing callback "after drawing". </li></ul><br>  It should be noted that for fairness, the ‚Äútotal execution time‚Äù is not the sum of all metrics, but is computed by a separate metric ‚Äústart‚Äù - ‚Äúend‚Äù.  This allows not to lose the upgrade stage.  Detailed metrics allow you to quickly find the problem and ideally should be approximately equal to the total execution time.  Full equality cannot be obtained due to Promise or setTimeout. <br><br>  <i>- Ok, now we have metrics and we can send them to the server.</i> <i><br></i>  <i>- What next?</i> <i><br></i>  <i>- And let's build a schedule!</i> <i><br></i>  <i>- What will we consider?</i> <br><br><h3>  And let's calculate the average </h3><br>  When I hear this phrase, I remember two jokes: <br><ul><li>  On average, a person has less than two hands. </li><li>  The deputy‚Äôs salary is 100,000 rubles, the doctor‚Äôs salary is 10,000 rubles.  The average salary is 55,000 rubles. </li></ul><br><br>  As you already understood, ‚Äúaverage‚Äù in the sense in which we most often understand it is nothing more than the arithmetic average.  In the more general case, it has a special name - ‚Äúexpectation‚Äù, which in the discrete case (we will consider it later) is just the arithmetic average.  In general, in statistics, ‚Äúaverage‚Äù refers to a whole family of measures of central tendency, each of which with a certain accuracy characterizes the localization of the distribution of data. <br><br>  In our situation, we are dealing with data in which there are emissions that strongly affect the arithmetic mean.  For clarity, we take the "real" data for the day and build a histogram.  Let me remind you that with a sufficiently large amount of data it becomes similar to the distribution density graph. <br><br><img src="https://habrastorage.org/files/1df/380/4e9/1df3804e974b4b698d289ea9c8e5fc1a.gif"><br><br>  Calculate the arithmetic average: <br><br><img src="https://habrastorage.org/files/192/c93/976/192c93976abb47ef880cdaa7894e629e.png"><br><br>  Horror.  I note that depending on the amount of emissions, this value will change.  This is clearly seen if we calculate, for example, the arithmetic average for 99% of users, discarding the ‚Äúlarge‚Äù ones: <br><br><img src="https://habrastorage.org/files/f36/985/37e/f3698537e86e452380f9f20b15b30889.png"><br><br>  The way to estimate a sample is not based on all data, and taking only a subset is often used in the case of data with outliers.  To do this, resort to special estimates of the central trend, based on the truncation of the data.  This group includes primarily the median (Md). <br><br>  <b>Median</b> <br><br>  As you know, the <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25B0%25D0%25BD%25D0%25B0_%2528%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25B8%25D1%2581%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0%2529">median</a> is the median, not the average value in the sample.  If we have numbers 1, 2, 2, 3, 8, 10, 20, then the median is 3, and the average is 6.5.  In general, the median perfectly shows how much the average user loads.  Even if you divide these groups into ‚Äúfast‚Äù and ‚Äúslow‚Äù, you will still get the correct value. <br><br>  Suppose we have a median of 1 s.  Is it good or bad?  And if we accelerate by 100 ms and make 0.9 s, then it will be what? <br><br><h3>  Ok, I sped up the rendering by 100ms. </h3><br>  In case of acceleration or deceleration, the median will, of course, change.  But she cannot tell how many users accelerated, and how much slowed down.  Browsers can be accelerated, computers can be updated, the code can be optimized, and as a result, you will have one little talking figure. <br><br>  To understand which group of users was affected by the changes, you can build the following graph: take the time intervals 0‚Äì100 ms, 100 ms ‚Äî 300 ms, 300 ms ‚Äî 1000 ms, 1000 ms ‚Äî infinity and consider how many percent of requests fit into each of them . <br><br><img src="https://habrastorage.org/files/cde/e6f/92e/cdee6f92e9fc459d961306aa4c153618.png"><br><br>  But even here a problem arises.  Every time we had to draw conclusions: it got a little better here and it got a little worse.  Is <strike>it</strike> possible <strike>to draw a conclusion right away?</strike>  simplify the schedule even more? <br><br><h3>  Honey, I took another schedule </h3><br>  When you learn how to count metrics and make graphs, everyone will have a desire to build them for EVERYTHING.  As a result, we get excellent 100,500 graphs, a bunch of scattered metrics, where everyone shows the boss what is more profitable for him.  Poorly?  Of course, bad!  If you have problems, it is not clear what to look at!  Hundreds of graphs - and all correct. <br><br>  The standard situation: the backend builds its graphs, the DBs are different, the frontend is third.  And where is the user?  In the end, we all work on it and the schedule should be built from it.  How to do it? <br><br><h4>  APDEX </h4><br>  <a href="https://en.wikipedia.org/wiki/Apdex">APDEX</a> is an integration metric that immediately says: good or bad.  The metric works very simply.  We select the time interval [0;  t], such that if the time the page was displayed fell into it, then the user is happy.  We take another interval, (t; 4t] (four times the first), and we believe that if the page is shown during this time, the user is generally satisfied with the speed of work, but not so happy. And we apply the formula: <br><br><blockquote>  (number of happy users + number of generally satisfied / 2) / (number of all users). </blockquote><br>  It turns out a value from zero to one, which, apparently, best shows whether mail works well or poorly. <br><br>  In the APDEX formula, unhappy or generally satisfied users influence the rating more than happy ones, which means it‚Äôs worth working with them.  Ideally, the unit should be obtained. <br><br>  In Yandex, APDEX is used quite widely.  He gained such popularity largely because his results can be processed automatically, since this is just one number.  On the contrary, in the case of graphics with multiple intervals, only good or bad can be determined by a person. <br><br>  At the same time, the use of APDEX does not cancel the construction of other graphs.  The same percentiles are needed and useful in case of analyzing problems, it will be clear from them what is happening.  Thus, it is an auxiliary schedule. <br><br><h3>  What is the correct schedule </h3><br>  The correct schedule is the one that shows the real user interaction with your site.  You can infinitely improve the backend and make it arbitrarily fast, but the user, by and large, does not care.  If the front end is slowing down, the backend will not help, and vice versa.  You should always go to the search for a problem from the end user. <br><br>  Take, for example, an abstract user from Ekaterinburg.  When we, long ago, began to introduce speed metrics, we found that the farther a user is from Moscow, the slower his mail is.  Why?  Everything is very simple: our DCs were then in the capital, and the speed of light has a finite value.  The signal must travel thousands of kilometers by wire.  A simple calculation shows that the distance of 2000 km the light will pass in about 7 ms.  In reality, it will take even more time, because the light does not travel in a vacuum or in a straight line, there are many routers along the way, etc. Thus, optimize, do not optimize, and each TCP packet will have a delay of tens of milliseconds.  Naturally, in such a situation it is not necessary to invest in code optimization, but in creating a <a href="http://habrahabr.ru/company/yandex/blog/176893/">CDN</a> , so that any user will be closer to us. <br><br><h3>  One more thing </h3><br>  Sometimes it turns out that you see smooth graphics, and users complain about the brakes.  It always means that you either have a measurement error, or you are not measuring it.  Metrics need to be stress tested to eliminate errors in the metrics themselves.  Moreover, stress testing should be performed not by the means of the metric itself, but from the outside. <br><br>  Slow backends, add loops, or respond with errors.  See how the metrics change at each stage: from the backend to the frontend and browser.  This is the only way you can make sure that you measure what you really need. <br><br>  For example, we in stress testing somehow reached the point that every second request responded with an error.  This allowed us to determine whether data is included in the metrics request or not. <br><br><h3>  Conclusion </h3><br>  It is very important that the optimization is not one-time or occasional.  Over the metrics of speed it is necessary to organize the process.  To begin, enough real-time graphs and testing of each release for speed.  Thus, we will remain honest with ourselves and will understand exactly where we are slow.  The streamlined process allows you to track releases in which changes in speed have occurred, which means we can definitely fix it.  Even if your team does not have time to purposefully and constantly engage in optimization, you can at least make sure that it does not get worse. </div><p>Source: <a href="https://habr.com/ru/post/244243/">https://habr.com/ru/post/244243/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../244231/index.html">Runet Prize 2014</a></li>
<li><a href="../244233/index.html">Router management: small joys of technical support</a></li>
<li><a href="../244237/index.html">Cost Effective Nutanix Solution</a></li>
<li><a href="../244239/index.html">Microsoft is branding the core of Windows 10</a></li>
<li><a href="../244241/index.html">Responsive images in practice (Part 3)</a></li>
<li><a href="../244245/index.html">Positive Hack Days V forum: open the doors of singularity</a></li>
<li><a href="../244247/index.html">How I document the development process.</a></li>
<li><a href="../244249/index.html">High CPU or how the Garbage Collector can kill performance</a></li>
<li><a href="../244251/index.html">Intel¬Æ System Studio 2015 - everything a software developer needs for embedded systems</a></li>
<li><a href="../244255/index.html">Facebook has updated the user agreement and is going to transfer data to third parties</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>