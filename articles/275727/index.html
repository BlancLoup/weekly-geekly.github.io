<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural generation of random gaming dungeons</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the post, the technique of generating random dungeons is considered in detail. The main generation algorithm, an example of which can be found here...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural generation of random gaming dungeons</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/5b0/d69/ca8/5b0d69ca8da486503d313162d6ad0147.png" alt="image"><br><br>  In the post, the technique of generating random dungeons is considered in detail.  The main generation algorithm, an example of which can be <a href="http://tinykeep.com/dungen/">found here</a> , is used by the developers of the game <a href="http://store.steampowered.com/app/278620/">TinyKeep</a> .  The original post from the developer <a href="https://www.reddit.com/r/gamedev/comments/1dlwc4/procedural_dungeon_generation_algorithm_explained/">was posted on reddit</a> . <br><br><h4>  The original description of the algorithm </h4><br>  1. First, I set the required number of rooms - for example, 150. Naturally, the number is arbitrary, and the larger it is, the more difficult the dungeon will be. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2. For each room, I create a rectangle with random widths and heights within a given radius.  The radius does not matter much, although it is reasonable to assume that it should be proportional to the number of rooms. <br><br>  Instead of evenly distributed random numbers (as generated by the Math.random generator in most languages), I use the <a href="https://en.wikipedia.org/wiki/Normal_distribution">normal Park-Miller distribution</a> .  As a result, the probability of small rooms exceeds the probability of large ones.  Why this is necessary, I will explain later. <br><br>  In addition, I check that the ratio of the length and width of the room is not too large.  We do not need both perfectly square rooms and very elongated ones. <br><br>  3. And here we have 150 random rooms located in a small space.  Most of them run into each other.  Now we carry out their separation according to the separation steering technology in order to separate the rectangles so that they do not overlap.  As a result, they do not intersect, but are close enough to each other. <br><br>  4. Fill the gaps with 1x1 cells.  As a result, we get a square lattice from rooms of various sizes. <br><br>  5. And here begins the main fun.  We determine which of the lattice cells are rooms ‚Äî these will be any cells with a width and height exceeding the given ones.  Due to the distribution of the Park-Miller, we get a relatively small number of rooms, between which there is quite a lot of free space.  But the remaining cells will also be useful to us. <br><br>  6. The next step is to link the rooms together.  To do this, we construct a graph containing the centers of all rooms using the <a href="http://en.wikipedia.org/wiki/Delaunay_triangulation">Delaunay triangulation</a> .  Now all rooms are interconnected by non-intersecting lines. <br><br>  7. Since we do not need all rooms to be connected to everyone, we build a <a href="http://en.wikipedia.org/wiki/Minimum_spanning_tree">minimum spanning tree</a> .  The result is a graph in which you can guaranteedly reach any room. <br><br>  8. The tree turns out neat, but boring - no closed moves to you.  Therefore, we randomly add back about 15% of the previously excluded edges of the graph.  The result is a graph where all the rooms are guaranteed to be reachable, with several closed turns. <br><br>  9. To turn it into corridors, for each edge, a series of straight lines (in the form of D) is built, running along the edges of the graph, connecting rooms.  Here we come in handy those cells that remained unused (those that have not turned into rooms).  All cells that overlap the L-shaped lines become corridors.  And because of the variety of cell sizes, the walls of the corridors will be uneven, which is good for a dungeon. <br><br>  And here is <a href="">an example of the result</a> ! <br><br>  Caution - under the cut many <s>monsters of</s> animated gifs! <br><a name="habracut"></a><br>  In a post on Gamasutra, user A Adonaac took it upon himself to describe some details in more detail.  In general, the operation of the algorithm is visually as follows: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/62c/6f0/fa0/62c6f0fa01bfbac3dee3564c06f994f2.gif" alt="image"><br><br><h4>  Creating rooms </h4><br>  First, you need to create several rooms with a certain height and width, randomly located inside a given circle.  The TKdev algorithm used the normal distribution for selecting room sizes, and it seems to me that this is a good idea - you have more parameters to play with.  Different types of dungeons can be achieved by choosing different ratios of height to width and standard deviations. <br><br>  One of the functions you might need is getRandomPointInCircle: <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomPointInCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius)</span></span></span><span class="hljs-function"> local t </span></span>= <span class="hljs-number"><span class="hljs-number">2</span></span>*math.pi*math.random() local u = math.random()+math.random() local r = nil <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> u &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> then r = <span class="hljs-number"><span class="hljs-number">2</span></span>-u <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> r = u end <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> radius*r*math.cos(t), radius*r*math.sin(t) end</code> </pre> <br><br>  Here her work is described in <a href="http://stackoverflow.com/questions/5837572/generate-a-random-point-within-a-circle-uniformly">more detail</a> .  After that, you can get something like the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c40/239/a0e/c40239a0e7b600673e0647df6d92012b.gif" alt="image"><br><br>  It is very important to note that since you are dealing with a grid of tiles, you will need to place all the rooms along one grid.  In the above gif, tiles have a size of 4 pixels, so all positions and sizes of rooms should be a multiple of 4th.  To do this, I wrapped the assignment of positions and heights with a width in the function, rounding the numbers to the size of the tile: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roundm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n, m)</span></span></span><span class="hljs-function"> return math.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">floor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(((n + m - </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">/m))*m end --      getRandomPointInCircle  : function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomPointInCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius)</span></span></span><span class="hljs-function"> ... return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roundm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius*r*math.cos(t)</span></span></span><span class="hljs-function">, tile_size), </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roundm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(radius*r*math.sin(t)</span></span></span><span class="hljs-function">, tile_size) end</span></span></code> </pre><br><br><h4>  We divide rooms </h4><br>  Let's move on to the separation.  We got a lot of overlapping rooms that need to be divided.  TKdev mentions the separation steering technology, but it seems to me more simple to use the physics engine.  After creating a set of rooms, you just need to assign the physical bodies to each room, run the simulation, and wait until everything calms down.  An example of a simulation is presented in the GIF. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2b2/685/545/2b26855453df39c5c3a3f6b332466875.gif" alt="image"><br><br>  Physical bodies are not attached to our lattice, but by assigning positions to rooms, we wrap them in roundm calls, resulting in rooms that do not overlap each other and are located on the lattice.  This process is represented on the gif.  Blue contours denote physical bodies.  There is a slight discrepancy between them and the real positions of the rooms due to constant rounding. <br><br><img src="http://i.imgur.com/eyTNcXE.gif" alt="image"><br><br>  You may encounter one of the problems that may arise if you specifically try to extend the rooms mainly along one of the axes.  Consider, for example, the game I'm working on: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fed/7bd/7d6/fed7bd7d62e0c5b30b719e1e7891fb3b.gif" alt="image"><br><br>  Since the battles take place horizontally, I need the rooms to be elongated in width, not height.  The problem is how the physics engine will allow two rooms to collide with each other. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/974/4e5/5ee/9744e55ee09a2995e8062f40ded901b2.gif" alt="image"><br><br>  In the picture we have a dungeon, stretched vertically, which is not very convenient.  To remedy the situation, you can initially set the location of the rooms so that they do not appear inside the circle, but inside a thin strip.  As a result, we get the desired ratio of the height and width of the dungeon. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/390/477/d45/390477d45c56dc9bf10e70ea6844b0f9.gif" alt="image"><br><br>  To randomly allocate rooms in the strip, let's change the getRandomPointInCircle function so that it places points in an ellipse, not a circle (in the presented gif I use the values ‚Äã‚Äãellipse_width = 400 and ellipse_height = 20): <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">function </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRandomPointInEllipse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ellipse_width, ellipse_height)</span></span></span><span class="hljs-function"> local t </span></span>= <span class="hljs-number"><span class="hljs-number">2</span></span>*math.pi*math.random() local u = math.random()+math.random() local r = nil <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> u &gt; <span class="hljs-number"><span class="hljs-number">1</span></span> then r = <span class="hljs-number"><span class="hljs-number">2</span></span>-u <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> r = <span class="hljs-function"><span class="hljs-function">u end return </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roundm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ellipse_width*r*math.cos(t)</span></span></span><span class="hljs-function">/2, tile_size), </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">roundm</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ellipse_height*r*math.sin(t)</span></span></span><span class="hljs-function">/2, tile_size) end</span></span></code> </pre><br><br><h4>  Basic rooms </h4><br>  In the next step, we define the rooms that will be the main ones.  In the TKdev algorithm, everything is simple - select those rooms whose height and width exceed the specified values.  On the next gif, I used the 1.25 * mean restriction - that is, if width_mean and height_mean are 24, then the main rooms will be rooms with a height and width greater than 30. <br><br><h4>  Delaunay triangulation and graph </h4><br>  Now we take the centers of the selected rooms and feed the data into the processing procedure.  You can write it yourself or take it ready - I was lucky, and I found it <a href="https://github.com/Yonaba/delaunay">ready, by Yonaba</a> .  It takes points and produces triangles. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ce/161/6ee/1ce1616ee02938aa4093bf459d675ab4.gif" alt="image"><br><br>  Having obtained triangles, one can construct a graph.  Hint: it is convenient to assign unique id to rooms, and work with them, rather than copying the room objects themselves. <br><br><h4>  Minimum spanning tree </h4><br>  After that we create a minimum spanning tree based on the graph.  It ensures that all rooms are attainable in principle, and at the same time each room is not connected immediately to all the others. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f56/ebd/011/f56ebd0115ffca797463a1b85270bbdf.gif" alt="image"><br><br>  After all, we don‚Äôt need both too many corridors and rooms that cannot be reached.  But at the same time it will be boring and a dungeon, in which there is only one correct way - therefore we will return a few edges from the Delone graph. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d69/d94/5ce/d69d945cec694ef931b5cc950864f780.gif" alt="image"><br><br>  This will add more paths and generate a bit of a closed circuit.  TKdev recommends returning 15% of the ribs, but personally it seemed to me more convenient to return 8-10%. <br><br><h4>  Corridors </h4><br>  To add corridors, we go around all the nodes of the graph and create lines connecting it with all neighboring nodes.  If the node is located approximately the same horizontally, create a horizontal line.  If vertical - vertical.  If the nodes are not located on the same horizontal or vertical, we create two lines that form an L-shaped form. <br><br>  I carried out such a check, finding the midpoint between the positions of the two nodes, and checking whether the coordinates of this point are at room level (horizontal or vertical).  If they are on a level, I draw one line.  If not, two, from room to point, and from point to another room. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/538/8e2/dce/5388e2dce210ebb77d52e6ee6a7c8cd2.png" alt="image"><br><br>  In this picture you can see examples of all cases.  Nodes 62 and 47 are connected by a horizontal line, nodes 60 and 125 are vertical, nodes 118 and 119 are L-shaped.  I note that in addition to the lines depicted in the picture, I create 2 additional lines drawn on each side, at a distance of tile_size, because I need corridors at least 3 cells wide. <br><br>  After this, we check which of the non-main rooms intersect with the constructed lines.  These rooms are added to our structure and become the backbone of the corridor system. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5d8/a2f/174/5d8a2f1749612a9efa1975470c5e74d1.png" alt="image"><br><br>  Depending on the uniformity and maximum size of the rooms, you can get very different dungeons as a result.  If you want to get more uniform corridors, you need to limit the standard deviation and introduce more checks on the size of the rooms and the ratio of their height and width. <br><br>  Finally, we add 1x1 cells to the cell lines, replacing the missing parts.  It is here that the additional lines added earlier may be useful so that the corridors are not too narrow. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5b0/d69/ca8/5b0d69ca8da486503d313162d6ad0147.png" alt="image"><br><br>  That's it guys! <br><br><img src="https://habrastorage.org/getpro/habr/post_images/459/3f1/2c2/4593f12c23d99c2af8366e98e8044588.gif" alt="image"><br><br>  As a result, I get a data structure in which there is: <br><br><ul><li>  list of rooms (each of which is a structure with a unique id, x / y position, and height / width) </li><li>  a graph in which each node indicates the id of the room, and the edges contain the distances between the rooms in the cells </li><li>  A 2d grid in which each cell can be empty, indicate the main room, point to a room belonging to the corridor system, or a narrow corridor cell </li></ul><br><br>  You can use these three structures to represent any required data set.  On their basis, it is already possible to work with the location of doors, enemies, things, etc. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c6/8b5/b67/6c68b5b6798d84361b6327d19a1b30a5.gif" alt="image"></div><p>Source: <a href="https://habr.com/ru/post/275727/">https://habr.com/ru/post/275727/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275715/index.html">"Naked conductor runs under the car." About online translation</a></li>
<li><a href="../275717/index.html">Using SikuliX in the background on Cloud9</a></li>
<li><a href="../275719/index.html">All you wanted to know about protection from XSS in SAP</a></li>
<li><a href="../275723/index.html">News about C ++ products and JetBrains C ++ Night in St. Petersburg</a></li>
<li><a href="../275725/index.html">The Qt project changes the license and opens the code for some modules.</a></li>
<li><a href="../275729/index.html">HTML / CSS / JavaScript Guide</a></li>
<li><a href="../275731/index.html">Sandelius method for random permutations</a></li>
<li><a href="../275733/index.html">Closing the tab with a double click and other improvements in the assembly Vivaldi 1.0.377.10</a></li>
<li><a href="../275735/index.html">Using WebP today</a></li>
<li><a href="../275737/index.html">Zabbix vs graphics</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>