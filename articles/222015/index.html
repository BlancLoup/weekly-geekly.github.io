<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Design and architecture in the OP. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Properties and laws. Scripts. Inversion of Control in Haskell. 

 Quite a bit of theory 
 In the last part, we made sure that it is very easy to get l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Design and architecture in the OP. Part 3</h1><div class="post__text post__text-html js-mediator-article">  <strong>Properties and laws.</strong>  <strong>Scripts.</strong>  <strong>Inversion of Control in Haskell.</strong> <br><br><h5>  Quite a bit of theory </h5><br>  In the <a href="http://habrahabr.ru/post/215161/">last</a> part, we made sure that it is very easy to get lost in a poorly designed code.  Fortunately, since ancient times, we know the principle of "divide and conquer" - it is widely used in the construction of architecture and design of large systems.  We know different embodiments of this principle, such as: separation into components, reduction of dependence between modules, interaction interfaces, abstraction from details, the allocation of specific languages.  This works well for imperative languages, and it must be assumed that it will work in functional languages, with the exception that the means of implementation will be different.  What? <br><a name="habracut"></a><br>  Consider the principle of Inversion of Control (a detailed description of this principle can be easily found on the web, for example, <a href="http://habrahabr.ru/post/116232/">here</a> and <a href="http://stackoverflow.com/questions/3058/what-is-inversion-of-control">here</a> ).  It helps reduce connectivity between parts of a program by inverting the flow of execution.  Literally, this means that we are introducing our code to a different place so that it will ever be called there;  at the same time, the embedded code is considered as a black box with an abstract interface.  Let us show that in any functional code both signs of IoC are combined - ‚Äúcode injection‚Äù and ‚Äúblack box‚Äù, for this we consider a simple example: <br><br><blockquote>  progression op <font color="#339933">=</font> <font>iterate</font> <font>(</font> `op` <font>2</font> <font>)</font> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      geometricProgression <font color="#339933">,</font> arithmeticalProgression <font color="#339933">::</font> <font color="#cccc00">Integer</font> <font color="#339933">-&gt;</font> <font>[</font> <font color="#cccc00">Integer</font> <font>]</font> <br>  geometricProgression <font color="#339933">=</font> progression <font>(</font> <font color="#339933">*</font> <font>)</font> <br>  arithmeticalProgression <font color="#339933">=</font> progression <font>(</font> <font color="#339933">+</font> <font>)</font> <br><br>  geometricals <font color="#339933">,</font> arithmeticals <font color="#339933">::</font> <font>[</font> <font color="#cccc00">Integer</font> <font>]</font> <br>  geometricals <font color="#339933">=</font> take <font color="#339933">$</font> 10 geometricProgression <font>1</font> <br>  arithmeticals <font color="#339933">=</font> take <font color="#339933">$</font> 10 arithmeticalProgression <font>1</font> </blockquote><br>  Here, other functions ((*), (+), `op` 2) are transferred to the input of one function (iterate, progression), that is, some code is being implemented.  And inside the receiving functions, this code is considered as a black box, for which only the type is known.  In the case of iterate, for example, the second argument must be of type Integer -&gt; Integer, and no matter how complicated its device will be.  Thus, inversion of control underlies functional programming;  in theory, higher-order functions allow us to construct an arbitrarily large application.  There is only one problem: this interpretation of IoC is too naive, and this leads, of course, to naive code.  Already in the example above, it can be seen that the code is a monolithic pyramid, and in a real application it would grow to gigantic sizes and would become completely unsupported. <br><br>  Let's look at IoC from the other side, that is, from the side of the ‚Äúhospitable‚Äù client code.  In it we get some kind of external artifact serving a specific purpose.  Outside, this artifact can be replaced by another, but for the receiving party, the substitution should be invisible.  This is the so-called <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8_%25D0%2591%25D0%25B0%25D1%2580%25D0%25B1%25D0%25B0%25D1%2580%25D1%258B_%25D0%259B%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B2">Liskov</a> substitution principle.  It serves as a guide in the PLO world and dictates that the artifacts have predictable behavior.  ‚ÄúIt prescribes‚Äù and not ‚Äúguarantees‚Äù, since such a guarantee cannot be given in OOP languages, any side effect can suddenly appear in any artifact that violates the principle.  Does this principle apply in functional languages?  Yes of course.  Moreover, provided that the code is clean, we will get stronger guarantees, especially if the language is with strict static typing. <br><br>  At the end of the article there is a brief description of different implementations of Inversion of Control in Haskell.  Some templates are almost complete analogues of those in the imperative world (for example, the monadic state injection is Dependency Injection), and some only slightly resemble IoC.  But they are all equally useful for good design. <br><br><h5>  Lot of practice </h5><br>  It's time to write some good code.  In this article we will continue to study the design of the game ‚ÄúThe Amoeba World‚Äù, - a whole era of it, outlined by <a href="https://github.com/graninas/The-Amoeba-World/commit/b08667a0fcf349ad56d33790f5a5ecde7ab52719">this</a> and <a href="https://github.com/graninas/The-Amoeba-World/commit/af5e9d4512d2ff907d983358cf8e000840f5a624">these</a> commits.  The epoch was saturated.  In addition to the completely rewritten game logic, tools such as <a href="http://habrahabr.ru/post/190442/">lenses</a> were tried, <a href="http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck2">QuickCheck</a> testing was introduced, a scripting language was invented, an interpreter was written, A * was integrated - a search algorithm in the world graph, and another specific antipattern was found .  In this article, our conversation will affect only the properties and scenarios, we will leave the rest for the following parts. <br><br>  <strong>Properties and Objects</strong> <br><br>  From past experience it became clear what the objects are in fact, what they consist of.  The main idea embodied in this design is as follows: an object is an entity composed of several properties.  The objects ‚ÄúKaryon‚Äù, ‚ÄúPlasma‚Äù, ‚ÄúBorder‚Äù and others were dissected, and the following set of properties was obtained: <br><br><ul><li>  Unique identificator </li><li>  Title </li><li>  Durability (maximum and current amount of HP) </li><li>  Owner (player) </li><li>  Layer (dungeon, earth, sky) </li><li>  Location (map) </li><li>  Age (maximum and current age) </li><li>  Battery (maximum and current amount of energy) </li><li>  Prohibition of movement (on a certain layer in this cell) </li><li>  Direction </li><li>  Motion </li><li>  Factory (the ability to create other objects) </li><li>  Self-destruction </li><li>  Collisions (with other objects) </li></ul><br>  A meticulous reader may see imperfections here, for example, for some reason the ‚Äúlayer‚Äù and ‚Äúlocation‚Äù are divided into two properties, although they seem to be about the same thing.  And what is the property of such a "collision"?  And the ‚ÄúFactory‚Äù?  And ‚ÄúAge‚Äù and ‚ÄúSelf-Destruction‚Äù?  And why does each object have a string name that will eat memory?  The claims are well-founded, and already in the next era, the list was once again revised, and in the same way: by highlighting properties from properties.  As a result, only six remained, the most important, ‚Äúruntime‚Äù and ‚Äústatic‚Äù, and the rest logically turned into external effects and actions ... <br><br>  For example, we will verbally describe a couple of real objects that could be on the game map: <br><br><blockquote>  Core: <br>  Name <font color="#339933">=</font> ‚ÄúKaryon‚Äù <br>  Location <font color="#339933">=</font> <font>(</font> <font>1</font> <font color="#339933">,</font> <font>1</font> <font color="#339933">,</font> <font>1</font> <font>)</font> <br>  Layer <font color="#339933">=</font> Earth <br>  Owner <font color="#339933">=</font> Player <font>1</font> <br>  Strength <font color="#339933">=</font> 100/100 <br>  Battery <font color="#339933">=</font> <font>300/2000</font> <br>  Factory <font color="#339933">=</font> Plasma Player <font>1</font> <br><br>  Plasma: <br>  Name <font color="#339933">=</font> ‚ÄúPlasma‚Äù <br>  Location <font color="#339933">=</font> <font>(</font> <font>2</font> <font color="#339933">,</font> <font>1</font> <font color="#339933">,</font> <font>1</font> <font>)</font> <br>  Layer <font color="#339933">=</font> Earth <br>  Owner <font color="#339933">=</font> Player <font>1</font> <br>  Strength <font color="#339933">=</font> <font>30/40</font> </blockquote><br>  Since the properties are finite, it was decided to make a wrapper for each type and place them all under one algebraic type ( <a href="">code</a> ): <br><br><blockquote>  <font color="#5d478b">- Object.hs:</font> <br>  <font>data</font> Property <font color="#339933">=</font> PNamed Named <br>  <font color="#339933">|</font>  PDurability <font>(</font> Resource Durability <font>)</font> <br>  <font color="#339933">|</font>  PBattery <font>(</font> Resource Energy <font>)</font> <br>  <font color="#339933">|</font>  POwnership Player <br>  <font color="#339933">|</font>  Player layer <br>  <font color="#339933">...</font> <br>  <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font color="#339933">,</font> <font color="#cccc00">Read</font> <font color="#339933">,</font> <font color="#cccc00">Eq</font> <font>)</font> </blockquote><br>  Define the type of an abstract object: <br><br><blockquote>  <font color="#5d478b">- Object.hs:</font> <br>  <font>type</font> PropertyKey <font color="#339933">=</font> <font color="#cccc00">Int</font> <br>  <font>type</font> PropertyMap <font color="#339933">=</font> M.  Map PropertyKey Property <br><br>  <font>data</font> Object <font color="#339933">=</font> Object <font>{</font> propertyMap <font color="#339933">::</font> PropertyMap <font>}</font> <br>  <font>deriving</font> <font>(</font> <font color="#cccc00">Show</font> <font color="#339933">,</font> <font color="#cccc00">Read</font> <font color="#339933">,</font> <font color="#cccc00">Eq</font> <font>)</font> </blockquote><br>  The first thought that suggests itself when seeing Property is that we returned to where we started, that is, to the God ADT problem (at that moment it was an Item type).  However, it is not.  The essential difference is in the level of abstraction that the Object type gives us.  We have something that can be called ‚Äúcombinatorial freedom‚Äù: a small amount of properties gives a combinatorial explosion of opportunities for the layout of new objects.  Some other properties are not planned - and if they appear, changes will not spread along the code, like a wave through dominoes.  We will see this when we talk about scenarios, but for now let's ask ourselves: how to create these very specific objects? <br><br>  The easiest way is to fill the property list and convert it to <a href="http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Map.html">Data.Map</a> : <br><br><blockquote>  <font color="#5d478b">- Objects.hs:</font> <br>  <font>import</font> object <br><br>  karyon <font color="#339933">=</font> Object <font color="#339933">$</font> M.  fromList <font>[</font> <font>(</font> <font>1</font> <font color="#339933">,</font> PObjectId <font>1</font> <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>4</font> <font color="#339933">,</font> PNamed ‚ÄúKaryon‚Äù <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>2</font> <font color="#339933">,</font> PDurability <font>(</font> Resource <font>100</font> <font>100</font> <font>)</font> <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>3</font> <font color="#339933">,</font> PBattery <font>(</font> Resource <font>300</font> <font>2000</font> <font>)</font> <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>10</font> <font color="#339933">,</font> POwnership Player1 <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>5</font> <font color="#339933">,</font> PDislocation <font>(</font> Point <font>1</font> <font>1</font> <font>1</font> <font>)</font> <font>)</font> <br>  <font color="#339933">...</font> <font>]</font> </blockquote><br>  ... but stop!  What is the logic behind PObjectId, Dislocation and Ownership?  After all, it makes sense to talk about them only for objects on the map!  On the other hand, there are common properties that define a class of objects and then do not change: PNamed and PLayer, PFabric and PPassRestriction (prohibition of movement).  In Karyon, the layer can only have the Ground, and the PNamed ‚ÄúPlasma‚Äù property can belong, respectively, only to the plasma.  Here we are faced with the problem that objects must be created when directly placed on the map, and at the same time you need to have templates with the original data.  The so-called ‚Äú <a href="http://www.haskell.org/haskellwiki/Smart_constructors">smart designers</a> ‚Äù are suitable as templates - functions that will create for us a ready-made object using ready-made patterns and a small set of input parameters.  This is what the smarter karyon function looks like: <br><br><blockquote>  <font color="#5d478b">- Objects.hs:</font> <br>  <font>import</font> object <br><br>  karyon pId player point <font color="#339933">=</font> Object <font color="#339933">$</font> M.  fromList <font>[</font> <font>(</font> <font>1</font> <font color="#339933">,</font> PObjectId pId <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>4</font> <font color="#339933">,</font> PNamed ‚ÄúKaryon‚Äù <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>2</font> <font color="#339933">,</font> PDurability <font>(</font> Resource <font>100</font> <font>100</font> <font>)</font> <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>3</font> <font color="#339933">,</font> PBattery <font>(</font> Resource <font>300</font> <font>2000</font> <font>)</font> <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>10</font> <font color="#339933">,</font> POwnership player <font>)</font> <br>  <font color="#339933">,</font> <font>(</font> <font>5</font> <font color="#339933">,</font> PDislocation point <font>)</font> <br>  <font color="#339933">...</font> <font>]</font> </blockquote><br>  This syntax can hardly be called elegant, too much ‚Äúnoise‚Äù and gestures.  Haskell is a laconic language, and we should strive for simplicity and functional minimalism, then the code will be more beautiful, clearer and more convenient.  Oh, how good it would be if the verbal description of the template, represented by several paragraphs above, could be transferred to the code ... Nothing is <a href="">impossible</a> ! <br><br><blockquote>  <font color="#5d478b">- Objects.hs</font> <br>  plasmaFabric <font color="#339933">::</font> Player <font color="#339933">-&gt;</font> Point <font color="#339933">-&gt;</font> Fabric <br>  plasmaFabric pl p <font color="#339933">=</font> makeObject <font color="#339933">$</font> <font>do</font> <br>  energyCost <font color="#339933">. =</font> <font>1</font> <br>  scheme <font color="#339933">. =</font> plasma pl p <br>  producing <font color="#339933">. =</font> True <br>  placementAlg <font color="#339933">. =</font> placeToNearestEmptyCell <br><br>  karyon <font color="#339933">::</font> Player <font color="#339933">-&gt;</font> Point <font color="#339933">-&gt;</font> Object <br>  karyon pl p <font color="#339933">=</font> makeObject <font color="#339933">$</font> <font>do</font> <br>  namedA <font color="#339933">| =</font> karyonName <br>  layerA <font color="#339933">| =</font> ground <br>  dislocationA <font color="#339933">| =</font> p <br>  batteryA <font color="#339933">| =</font> <font>(</font> <font>300</font> <font color="#339933">,</font> Just <font>2000</font> <font>)</font> <br>  durabilityA <font color="#339933">| =</font> <font>(</font> <font>100</font> <font color="#339933">,</font> Just <font>100</font> <font>)</font> <br>  ownershipA <font color="#339933">| =</font> pl <br>  fabricA <font color="#339933">| =</font> plasmaFabric pl p </blockquote><br>  The comprehensibility of the code depends on how much the reader‚Äôs knowledge and thinking coincided with the author‚Äôs knowledge and thinking.  Is this code clear?  It is clear what he does, but how does it work?  What, for example, do the operators ‚Äú. =‚Äù And ‚Äú| =‚Äù mean here?  How does the makeObject function work?  Why do some names have the letter ‚ÄúA‚Äù, and some don't have it?  And is that a monad, or what? .. <br><br>  The foggy answer to these correct questions is as follows: this code uses the internal language for the layout of objects.  Its design is based on the use of lenses in conjunction with the State monad.  Functions with ‚ÄúA‚Äù -postfixes are smart constructors (‚Äúaccessors‚Äù) of the properties themselves, knowing the sequence number of a particular property and able to validate values.  Functions without ‚ÄúA‚Äù are lenses.  The ‚Äú. =‚Äù Operator belongs to the lens library and allows you to set a value under the zoom inside the State monad.  The plasmaFabric function fills the Fabric ADT, and the karyon function fills the PropertyMap and Object.  In the second example, the accessors and data are transferred to the custom operator | =, for correctness, we will call it the ‚Äúfilling operator‚Äù.  The fill statement works inside the State monad.  He pulls out the current PropertyMap and places into it the property that has been validated by the accessor: <br><br><blockquote>  <font color="#5d478b">- Object.hs:</font> <br>  makeObject <font color="#339933">::</font> Default a <font color="#339933">=&gt;</font> State a <font>(</font> <font>)</font> <font color="#339933">-&gt;</font> a <br>  makeObject <font color="#339933">=</font> <font>flip</font> execState def <br><br>  <font>data</font> PAccessor a <font color="#339933">=</font> PAccessor <font>{</font> key <font color="#339933">::</font> PropertyKey <br>  <font color="#339933">,</font> constr <font color="#339933">::</font> a <font color="#339933">-&gt;</font> Property <font>}</font> <br><br>  <font color="#5d478b">- Operator fill properties:</font> <br>  <font>(</font> <font color="#339933">| =</font> <font>)</font> accessor v <font color="#339933">=</font> <font>do</font> <br>  props <font color="#339933">&lt;-</font> get <br>  <font>let</font> oldPropMap <font color="#339933">=</font> <font color="#339933">_</font> propertyMap props <br>  <font>let</font> newPropMap <font color="#339933">=</font> insertProperty <font>(</font> key accessor <font>)</font> <font>(</font> constr accessor v <font>)</font> oldPropMap <br>  put <font color="#339933">$</font> props <font>{</font> <font color="#339933">_</font> propertyMap <font color="#339933">=</font> newPropMap <font>}</font> <br><br>  <font color="#5d478b">- Accessor for the Named property:</font> <br>  isNamedValid <font>(</font> Named n <font>)</font> <font color="#339933">=</font> <font>not</font> <font color="#339933">.</font>  <font>null</font> <font color="#339933">$</font> n <br>  namedValidator n <font color="#339933">|</font>  isNamedValid n <font color="#339933">=</font> n <br>  <font color="#339933">|</font>  <font>otherwise</font> <font color="#339933">=</font> <font>error</font> <font color="#339933">$</font> <font>"Invalid named property:"</font> <font color="#339933">++</font> <font>show</font> n <br><br>  namedA <font color="#339933">=</font> PAccessor <font>0</font> <font color="#339933">$</font> PNamed <font color="#339933">.</font>  namedValidator </blockquote><br>  This design is not perfect.  Validation of properties looks very dangerous, as it can fall with an error in runtime.  We also do not monitor whether there is already such a property in the set - we just write a new one on top of it.  Both can be easily corrected by creating a stack of the Either and State monads and handling exceptions in a safe manner.  In this case, the code in the module with templates (Objects.hs) will change slightly.  There are many advantages, but there is one objection: as long as the object layout language is used only to create templates, and as long as they can be tested, the extra logic will only get in the way.  On the other hand, when this code goes into the script, security will become important. <br><br>  Our last question related to objects is this: what is the World data type now?  Here, no significant changes have occurred, the world is still the Map type: <br><br><blockquote>  <font>type</font> World <font color="#339933">=</font> M.  Map Point Object </blockquote><br>  The Data.Map structure suffers from performance.  A more suitable solution here is a two-dimensional array;  in Haskell, there are effective implementations of vectors, such as <a href="">vector</a> or <a href="">repa</a> .  When it becomes clear that the performance of the game is not high enough, it will be possible to return and revise the repository of the world, but for now the speed of development is more important. <br><br>  <strong>Scenarios</strong> <br><br>  Scenarios are the laws of the world.  Scenarios describe this or that phenomenon.  The phenomena in the world are local;  in one phenomenon only the necessary properties are involved in a certain part of the map.  For example, when a bomb explodes, we are interested in the strength of objects in a radius N, namely, we must reduce it by the amount of damage, and if the strength drops below 0, we need to remove objects from the map.  If we have a factory, we must first provide it with a resource, then get the product and place it somewhere nearby.  Durability is not important, but the resources, the factory itself and the empty space for the product are important. <br><br>  Scripts must be run against basic properties.  If there is an object on the map with the property ‚ÄúMovement‚Äù, then we will launch the movement scenario.  If the factory works, we will launch a scenario for the production of combat units.  Scripts are not allowed to change the current world;  they work alternately and accumulate results in the overall data structure.  It should be borne in mind that sometimes the work of some scenarios affects the work of others, up to a complete cancellation. <br><br>  We illustrate this with examples.  Suppose we have two factories that produce one tank for one unit.  In stock, we have only 1 resource unit.  The first scenario will work successfully, but the second should know that all resources have been spent and stop working.  Or another situation: two objects are moving in opposite directions.  When there is only one cell between them, what should happen?  Collision or inability to move one of the objects?  There can be a lot of similar nuances;  I would like the scripts to be complete, but remain extremely simple to read and write. <br><br>  We outline the requirements for the scripts subsystem: <br><ul><li>  reliability; </li><li>  focus on properties; </li><li>  sequence; </li><li>  simplicity; </li><li>  scripts can fail; </li><li>  speed; </li><li>  scripts can run other scripts; </li><li>  ... </li></ul><br>  In the game ‚ÄúThe Amoeba World‚Äù, the language Scenario DSL was designed, and its interpreter (code) was written.  Here‚Äôs what a piece of script looks like for the Fabric property (code): <br><br><blockquote>  <font color="#5d478b">- Scenario.hs:</font> <br>  createProduct <font color="#339933">::</font> Energy <font color="#339933">-&gt;</font> Object <font color="#339933">-&gt;</font> Eval Object <br>  createProduct eCost sch <font color="#339933">=</font> <font>do</font> <br>  pl <font color="#339933">&lt;-</font> <font>read</font> ownership <br>  d <font color="#339933">&lt;-</font> <font>read</font> dislocation <br>  withdrawEnergy pl eCost <br>  <font>return</font> <font color="#339933">$</font> adjust sch <font>[</font> ownership <font color="#339933">. ~</font> pl <font color="#339933">,</font> dislocation <font color="#339933">. ~</font> d <font>]</font> <br><br>  placeProduct prod plAlg <font color="#339933">=</font> <font>do</font> <br>  l <font color="#339933">&lt;-</font> withDefault ground <font color="#339933">$</font> getProperty layer prod <br>  obj <font color="#339933">&lt;-</font> getActedObject <br>  p <font color="#339933">&lt;-</font> evaluatePlacementAlg plAlg l obj <br>  save <font color="#339933">$</font> objectDislocation <font color="#339933">. ~</font> p <font color="#339933">$</font> prod <br><br>  produce f <font color="#339933">=</font> <font>do</font> <br>  prodObj <font color="#339933">&lt;-</font> createProduct <font>(</font> f <font color="#339933">^.</font> energyCost <font>)</font> <font>(</font> f <font color="#339933">^.</font> scheme <font>)</font> <br>  placeProduct prodObj <font>(</font> f <font color="#339933">^.</font> placementAlg <font>)</font> <br>  <font>return</font> <font>"Successfully produced."</font> <br><br>  producingScenario <font color="#339933">::</font> Eval <font color="#cccc00">String</font> <br>  producingScenario <font color="#339933">=</font> <font>do</font> <br>  f <font color="#339933">&lt;-</font> <font>read</font> fabric <br>  <font>if</font> f <font color="#339933">^.</font>  producing <br>  <font>then</font> produce f <br>  <font>else</font> <font>return</font> <font>"Producing paused."</font> </blockquote><br>  In the second part of the series of articles, namely in the section 'let-functions', we saw the code as cumbersome and incomprehensible.  Now we see the code is light, still incomprehensible, but in it a certain system is already visible.  Let's try to figure it out. <br><br>  Scenario DSL is divided into two parts: the language of the requests for game data and the execution environment.  At the heart of everything is the Eval type - a stack of the Either and State monads: <br><br><blockquote>  <font color="#5d478b">- Evaluation.hs:</font> <br>  <font>type</font> EvalType ctx res <font color="#339933">=</font> EitherT EvalError <font>(</font> State ctx <font>)</font> res <br>  <font>type</font> Eval res <font color="#339933">=</font> EvalType EvaluationContext res </blockquote><br>  The internal state monad allows you to store and change the execution context.  The current world, operational data, random generator - all of this lies in the context: <br><br><blockquote>  <font>data</font> DataContext <font color="#339933">=</font> DataContext <font>{</font> dataObjects <font color="#339933">::</font> Eval Objects <br>  <font color="#339933">,</font> dataObjectGraph <font color="#339933">::</font> Eval <font>(</font> NeighborsFunc <font color="#339933">-&gt;</font> ObjectGraph <font>)</font> <br>  <font color="#339933">,</font> dataObjectAt <font color="#339933">::</font> Point <font color="#339933">-&gt;</font> Eval <font>(</font> <font color="#cccc00">Maybe</font> Object <font>)</font> <font>}</font> <br><br>  <font>data</font> EvaluationContext <font color="#339933">=</font> EvaluationContext <font>{</font> ctxData <font color="#339933">::</font> DataContext <br>  <font color="#339933">,</font> ctxTransactionMap <font color="#339933">::</font> TransactionMap <br>  <font color="#339933">,</font> ctxActedObject <font color="#339933">::</font> <font color="#cccc00">Maybe</font> Object <br>  <font color="#339933">,</font> ctxNextRndNum <font color="#339933">::</font> Eval <font color="#cccc00">Int</font> <font>}</font> </blockquote><br>  The external Either monad allows you to safely handle execution errors.  The most common situation is when there are collisions, and some scenario should end in the middle of work.  In order for the state of the game to remain correct, you need to roll back all its changes, and if the script was called from another scenario, then you should somehow react to the problem.  Therefore, many functions have the Eval type, which hides the Either monad.  In fact, all functions with an Eval type are scripts.  Even interpreter functions (evalTransact, getTransactionObjects) and query language functions (single, find) work in this type and, in fact, are also scripts.  In other words, the Scenario DSL language is unified by the Eval type, which makes the code consistent and monad-composable. <br><br>  Since any function with the Eval type is a script, each of them can be launched and tested.  Scenario interpretation is just the execution of a monad stack: <br><br><blockquote>  <font color="#5d478b">- Evaluation.hs:</font> <br>  evaluate scenario <font color="#339933">=</font> evalState <font>(</font> runEitherT scenario <font>)</font> <br>  execute scenario <font color="#339933">=</font> execState <font>(</font> runEitherT scenario <font>)</font> <br>  run scenario <font color="#339933">=</font> runState <font>(</font> runEitherT scenario <font>)</font> </blockquote><br>  For game scenarios, there is one entry point - the mainScenario generic function: <br><br><blockquote>  <font color="#5d478b">- Scenario.hs:</font> <br>  mainScenario <font color="#339933">::</font> Eval <font>(</font> <font>)</font> <br>  mainScenario <font color="#339933">=</font> <font>do</font> <br>  forProperty fabric producingScenario <br>  forProperty moving movingScenario <br>  <font>return</font> <font>(</font> <font>)</font> <br><br>  <font color="#5d478b">- Somewhere in the main code - one tick of the whole game:</font> <br>  stepGame gameContext <font color="#339933">=</font> runScenario mainScenario gameContext </blockquote><br>  Similarly, separate scripts are launched, which means that you can enter modular and functional code testing.  Here, for example, the debugging code from the ScenarioTest.hs module, - if necessary, it can be transformed into a full-fledged QuickCheck or HUnit test: <br><br><blockquote>  main <font color="#339933">=</font> <font>do</font> <br>  <font>let</font> ctx <font color="#339933">=</font> testContext <font color="#339933">$</font> initialGame <font>1</font> <br>  <font>let</font> result <font color="#339933">=</font> execute <font>(</font> placeProduct <font>(</font> plasma player1 point1 <font>)</font> nearestEmptyCell <font>)</font> ctx <br>  <font>print</font> result </blockquote><br>  Now that we have learned some of the features of the Scenario DSL runtime, we prepare the following function: <br><br><blockquote>  withdrawEnergy pl cnt <font color="#339933">=</font> <font>do</font> <br>  obj <font color="#339933">&lt;-</font> singleActual <font color="#339933">$</font> named `is` karyonName <font color="#339933">~</font> &amp; <font color="#339933">~</font> ownership` is` pl <font color="#339933">~</font> &amp; <font color="#339933">~</font> batteryCharge `suchThat` <font>(</font> <font color="#339933">&gt; =</font> cnt <font>)</font> <br>  batRes <font color="#339933">&lt;-</font> getProperty battery obj <br>  save <font color="#339933">$</font> batteryCharge <font color="#339933">. ~</font> modifyResourceStock batRes cnt <font color="#339933">$</font> obj </blockquote><br>  This is also a scenario serving a specific purpose: for a pl player to remove cnt energy from the nucleus.  What needs to be done for this?  First of all, find an object on the map with such properties: Named == ‚ÄúKaryon‚Äù and Ownership == pl.  In the code above, we see the call to singleActual ‚Äî this function searches for an object by predicate.  Thanks to the query language, the verbal description is almost exactly translated into code: <br><br><blockquote>  named `is` karyonName <br>  <font color="#339933">~</font> &amp; <font color="#339933">~</font> ownership `is` pl <br>  <font color="#339933">~</font> &amp; <font color="#339933">~</font> batteryCharge `suchThat` <font>(</font> <font color="#339933">&gt; =</font> cnt <font>)</font> </blockquote><br>  It is not difficult to guess that the operator (~ &amp; ~) means ‚Äúand‚Äù, and the operator `is` specifies the equality of a certain property to a value.  The third condition of the predicate selects only those objects for which the battery is charged enough to extract more energy from there.  Of course, the energy may run out, and then the object will not be found, - in this case, the fail-line of the Either monad will begin, and the whole script will be canceled.  But if energy can be removed, then we seize and accumulate changes: <br><br><blockquote>  save <font color="#339933">$</font> batteryCharge <font color="#339933">. ~</font> modifyResourceStock batRes cnt <font color="#339933">$</font> obj </blockquote><br>  It is worth mentioning that the Scenario DSL actively uses lenses, which greatly reduces the code.  For example, instead of laconic (batteryCharge. ~ 10) we would have to do archaeological excavations along the chain: Object -&gt; PropertyMap -&gt; PBattery -&gt; Resource -&gt; change stock -&gt; save all back.  Although the idiomatic lens is in <a href="http://www.reddit.com/r/haskell/comments/23uzpg/lens_is_unidiomatic_haskell/">doubt</a> , this tool is very, very useful. <br><br>  Query language has many useful features.  You can search for many objects by predicate (the function query), you can search for a single object (single function), and if there are a lot of those, you can find the script.  There are also search strategies: look only for old data, look only for new, or all together, and let the client code itself understand.  In general, the Scenario DSL coped well with its function, and there were opportunities for its expansion.  And there was only one serious problem, which again had to revise the basis of the fundamentals - the design of the Object type.  The name of this problem ... <br><br>  <strong>Antipattern Lens + NoMonomorphismRestriction</strong> <br><br>  The reason for all the trouble lies in the data type PropertyMap and in the lenses for the properties: <br><br><blockquote>  property k l <font color="#339933">=</font> propertyMap <font color="#339933">.</font>  at k <font color="#339933">.</font>  traverse <font color="#339933">.</font>  l <br><br>  named <font color="#339933">=</font> property <font>(</font> key namedA <font>)</font> <font color="#339933">_</font> named <br>  durability <font color="#339933">=</font> property <font>(</font> key durabilityA <font>)</font> <font color="#339933">_</font> durability <br>  battery <font color="#339933">=</font> property <font>(</font> key batteryA <font>)</font> <font color="#339933">_</font> battery <br>  <font color="#339933">...</font> </blockquote><br>  The property function in all cases returns different lenses, which cannot be done when the monomorphism check is on.  Therefore, we had to include the extension of the NoMonomorphismRestriction language.  Unfortunately, because of this, type inference began to break down in the most unexpected places, and we had to look for workarounds.  Worse, the NoMonomorphismRestriction mode began to spread throughout the code.  He appeared everywhere where the lenses of the Object.hs module were used, and infested with a Tupcheker insanity.  In the end, the design of the Scenario DSL began to sag under the restrictions of the tick checker ‚Äî which led to several not very good solutions. <br><br>  The problem can be eradicated by abandoning the type PropertyMap.  Then in the type of Object will be all the properties - even those that are not needed for a particular object.  Perhaps there are other solutions, but in the next version of the design it was done this way: <br><br><blockquote>  <font>data</font> Object <font color="#339933">=</font> Object <font>{</font> <br>  <font color="#5d478b">- Properties:</font> <br>  objectId <font color="#339933">::</font> ObjectId <font color="#5d478b">- static property</font> <br>  <font color="#339933">,</font> objectType <font color="#339933">::</font> ObjectType <font color="#5d478b">- predefined property</font> <br><br>  <font color="#5d478b">- Runtime properties, resources:</font> <br>  <font color="#339933">,</font> ownership <font color="#339933">::</font> Player <font color="#5d478b">- runtime property ... or can be effect!</font> <br><br>  <font color="#339933">,</font> lifebound <font color="#339933">::</font> IntResource <font color="#5d478b">- runtime property</font> <br>  <font color="#339933">,</font> durability <font color="#339933">::</font> IntResource <font color="#5d478b">- runtime property</font> <br>  <font color="#339933">,</font> energy <font color="#339933">::</font> IntResource <font color="#5d478b">- runtime property</font> <br>  <font>}</font> </blockquote><br>  A blessing in disguise, as a result of the revision, other properties have become external effects and actions.  The design became more correct, although I had to throw away most of the developments on the Scenario DSL ... <br><br><h5>  Instead of conclusion </h5><br>  The new script engine is supposed to be based on different principles.  In particular, it is planned to make not an internal DSL, but an external one ‚Äî then it will be possible to write scripts in plain text files.  At the moment, the author is working on the Application and View layers, on finding the optimal model for using FRP.  In the following chapters, you will learn about the idea behind the FRP, and how you can use the reactive programming to unite the fragments of a large application. <br><br><h5>  Implements Inversion of Control in Haskell </h5><br>  <i>Disclaimer: The author did not have time to complete the research for this section.</i>  <i>Continuation will be in the following articles.</i> <br><br>  <strong>Monadic state injection (Monadic state injection)</strong> <br><br>  <b>What is</b> : Dependency injection (Dependency Injection). <br>  <b>What it is used for</b> : For abstracted work with the external state in the client code. <br>  <b>Description</b> : The external state is implemented through the State monad as a context.  Client code runs in the State monad with this context.  When accessing the context, the client code receives data from the external state. <br>  <b>Structure</b> : <br><blockquote>  We define the Context data type - it will contain the external state in the form of the State monad: <br><br><blockquote>  <font>data</font> Context <font color="#339933">=</font> Context <font>{</font> ctxNextId <font color="#339933">::</font> State Context <font color="#cccc00">Int</font> <font>}</font> </blockquote><br>  We define specific instances of the code being implemented.  The code can produce a constant result: <br><br><blockquote>  constantId <font color="#339933">::</font> State Context <font color="#cccc00">Int</font> <br>  constantId <font color="#339933">=</font> <font>return</font> <font>42</font> </blockquote><br>  Or it may produce different results for each challenge: <br><br><blockquote>  nextId <font color="#339933">::</font> <font color="#cccc00">Int</font> <font color="#339933">-&gt;</font> State Context <font color="#cccc00">Int</font> <br>  nextId prevId <font color="#339933">=</font> <font>do</font> <font>let</font> nId <font color="#339933">=</font> prevId <font color="#339933">+</font> <font>1</font> <br>  modify <font>(</font> \ ctx <font color="#339933">-&gt;</font> ctx <font>{</font> ctxNextId <font color="#339933">=</font> nextId nId <font>}</font> <font>)</font> <br>  <font>return</font> nId </blockquote><br>  Create client code in the State monad: <br><br><blockquote>  client <font color="#339933">=</font> <font>do</font> <br>  externalId <font color="#339933">&lt;-</font> get <font color="#339933">&gt;&gt; =</font> ctxNextId <br>  doStuff externalId <br>  <font>return</font> externalId </blockquote><br>  Run the client code, implementing a specific instance of the external state: <br><br><blockquote>  <font>print</font> <font color="#339933">$</font> evalState client <font>(</font> ContextId <font>)</font> <br>  <font>print</font> <font color="#339933">$</font> evalState client <font>(</font> Context <font>(</font> nextId <font>0</font> <font>)</font> <font>)</font> </blockquote><br>  <b>Full example</b> : <a href="https://gist.github.com/graninas/b4d62dffe6e95a2721a0">gist</a> <br>  <b>Example program output</b> : <br><blockquote>  Sequental ids: <br>  <font>[</font> <font>(</font> <font>1</font> <font color="#339933">,</font> <font>"GNVOERK"</font> <font>)</font> <font color="#339933">,</font> <font>(</font> <font>2</font> <font color="#339933">,</font> <font>"RIKTIG YOGLA"</font> <font>)</font> <font>]</font> <br>  Random ids: <br>  <font>[</font> <font>(</font> <font>59</font> <font color="#339933">,</font> <font>"GNVOERK"</font> <font>)</font> <font color="#339933">,</font> <font>(</font> <font>64</font> <font color="#339933">,</font> <font>"RIKTIG YOGLA"</font> <font>)</font> <font>]</font> </blockquote></blockquote><br>  <strong>Module Abstraction</strong> <br><br>  <b>What is</b> : Black box. <br>  <b>What it is used for</b> : Select the implementation of the algorithm in runtime. <br>  <b>Description</b> : There is a facade module in which several modules are connected that implement the same function.  According to a certain algorithm, one or another implementation is selected in the switch function of the facade module.  In the client code, the facade module is connected, and the required algorithm is used through the switch function. <br>  <b>Full example</b> : <a href="https://gist.github.com/graninas/e93e32aa1950a6f7b040">gist</a> </div><p>Source: <a href="https://habr.com/ru/post/222015/">https://habr.com/ru/post/222015/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221999/index.html">Conflicts when merging csproj files</a></li>
<li><a href="../222001/index.html">IconBIT Toucan Stick 4K Review: Top HDMI Stick on AllWinner A31</a></li>
<li><a href="../222005/index.html">Each environment has its own favicon</a></li>
<li><a href="../222007/index.html">Dependency Injection in C ++</a></li>
<li><a href="../222009/index.html">Reports and contests at NeoQUEST-2014</a></li>
<li><a href="../222021/index.html">Cross-platform mobile application: Navigation</a></li>
<li><a href="../222023/index.html">How are SSD drives born? Excursion to the process</a></li>
<li><a href="../222025/index.html">Kalashnikov: a legend or anti-brand?</a></li>
<li><a href="../222027/index.html">Will Runet survive to 2015?</a></li>
<li><a href="../222033/index.html">Really powerful and compact PC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>