<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Forecaster Class for Weather Station or Weather Predictor</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many beginners (and not only) Arduinschiki went through the creation of a device with a loud name - Weather Station, I am among them. 

 Many of the o...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Forecaster Class for Weather Station or Weather Predictor</h1><div class="post__text post__text-html js-mediator-article">  Many beginners (and not only) Arduinschiki went through the creation of a device with a loud name - Weather Station, I am among them. <br><br>  Many of the options that I studied are interesting from the point of view of the flight of the creator‚Äôs thoughts; I learned from many ideas about which I don‚Äôt hide.  In addition to capturing readings from my own sensors, visualizing them through various interfaces such as various Displays and Web pages, I was interested to use the weather forecast data for a while ahead. <br><a name="habracut"></a><br>  Here, in my opinion, there are two ways: I read the first one <a href="http://mcucpu.ru/index.php/pdevices/datchiki/39-pressure/118-prakticheskoe-ispolzovanie-datchikov-atmosfernogo-davleniya">in this article</a> , but I liked the opportunity to get a forecast from the Internet more.  I got the basic information about this <a href="http://wiki.amperka.ru/%25D0%25B4%25D0%25B8%25D1%2581%25D0%25BF%25D0%25BB%25D0%25B5%25D0%25B8-%25D0%25B8-%25D0%25B8%25D0%25BD%25D0%25B4%25D0%25B8%25D0%25BA%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D1%258B:8x8rgb">from an article on Amperk</a> and developed this idea further, the benefit of the <a href="http://openweathermap.org/">resource</a> offered in the article allows you to do this, completely free of charge. <br>  As a result, my version of the weather station received the Forecaster class, which is responsible for weather prediction.  This is the class in the context of a test project that I want to present to the public. <br><br>  Immediately make a reservation: <br>  1. I have a server part of the weather station built on the Arduino Mega 2560, so I do not experience a lack of memory in the project. <br>  2. I had to make some changes to the standard Ethernet library, the changes affected the number of sockets and the buffer memory allocated for them. <br>  The original version has 4 sockets 2kB for each socket, but I made 2 sockets 4kB each.  Buffer memory had to be increased due to the fact that when receiving weather forecast information from the server, the amount of information can reach 15-18kB (when a 3-hour forecast is received).  Those.  with a buffer size of 2kb - most of it was simply lost.  With 4kB buffer, it is possible to get a forecast for 2 days with a discreteness of 3 hours, which is not bad at all.  All library changes are documented directly in the code of the class itself.  If someone tells you how to solve this problem by hand, without touching the sockets, I will only be glad. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Sometimes, when receiving and analyzing a 3-hour forecast, it is possible to process a smaller number of elements (not 16, but only 3-6), I did not understand why this happens, perhaps Arduinka does not have time to select data from the buffer.  To demonstrate the work of the Predictor, I assembled a test project that I tested on 2 devices: <br>  1. Arduino Uno + Ethernet shield (w5100) <br>  2. iBoard <br>  Due to the lack of memory in these devices, I had to comment out some related functions.  Inside the class: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> FORECAST::GetForecastDays(FORECAST::_WeatherDay* wdp) <span class="hljs-comment"><span class="hljs-comment">//  4   int FORECAST::GetForecast(FORECAST::_WeatherPacket&amp; whr) //   </span></span></code> </pre> <br>  In the body of the main loop, the code that calls these functions is commented out.  Their work can be checked by commenting and removing comments from the corresponding sections of the code.  If the code is poured into the Mega2560, then the need for commenting will disappear and everything will work.  The project is built under IDE version 1.6.5.  (At 1.0.5r2 - also without problems). <br><br>  I also want to make a reservation, I am not an adept of C (C ++), so I often ask questions on the forums how to work with strings and the like.  In this regard, it is likely that some parts of the code are written strangely or not optimally, in short - healthy criticism is welcome. <br><br>  The city for which the requested forecast is registered in the class declarations: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> p_request3Hour[] PROGMEM = <span class="hljs-string"><span class="hljs-string">"GET /data/2.5/forecast?q=Krasnoyarsk&amp;mode=xml&amp;units=metric"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> p_request4Day[] PROGMEM = <span class="hljs-string"><span class="hljs-string">"GET /data/2.5/forecast/daily?q=Krasnoyarsk&amp;mode=xml&amp;units=metric&amp;cnt=4"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> p_requestToDay[] PROGMEM = <span class="hljs-string"><span class="hljs-string">"GET /data/2.5/weather?q=Krasnoyarsk&amp;mode=xml&amp;units=metric"</span></span>;</code> </pre><br>  Weather Prediction Class Announcement: <br><pre> <code class="cpp hljs">FORECAST frc; FORECAST::_WeatherPacket weather; <span class="hljs-comment"><span class="hljs-comment">//     FORECAST::_WeatherDay wPack1Day; //      4  (  ) FORECAST::_WeatherThreeHour wPack3Hour; // 3       2 </span></span></code> </pre><br>  Initialization: <br><pre> <code class="cpp hljs">frc.Init(client, <span class="hljs-number"><span class="hljs-number">7</span></span>); <span class="hljs-comment"><span class="hljs-comment">// client -  EthernetClient, 7 -   </span></span></code> </pre><br>  Request weather on the server: <br><pre> <code class="cpp hljs">frc.GetForecast(weather) <span class="hljs-comment"><span class="hljs-comment">// weather -     frc.GetForecast3Hour(&amp;wPack3Hour) //wPack3Hour -   16   3   frc.GetForecastDays(&amp;wPack1Day) //wPack1Day -   4     4 </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Description of structures with weather data</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   struct _WeatherPacket { int P; // int T; // int H; // int WS; //  (/) char WD[4]; // char Icon[4]; //    }; //      4   typedef struct OneDay { time_t Data; //   "20141010' int TD; //  int TN; //  byte H; // int P; // byte WS; //  char WD[4]; //  byte Cloud; //  % int RainVal; //  (*100), 0 -  , -  +  char Icon[4]; //Icon } wdPack; //    3   2   typedef struct ThreeHour { time_t Data; //     "2014-10-10 21:00' int T; // int TT; // Min  Max byte H; // int P; // byte WS; //  char WD[4]; // byte Cloud; //  % int RainVal; //  (*100), 0 -  , -  +  char Icon[4]; //Icon } whPack;</span></span></code> </pre><br></div></div><br>  Structures with meteorological data have a small length and therefore can be easily transferred via nRF24.  Naturally, 1 structure contains data for 1 day or 3 hours, and in order to transfer all the melons completely, a corresponding number of transmission sessions will be required.  For this, I created a special exchange protocol between the display and server modules.  Well, actually the source itself: <br><div class="spoiler">  <b class="spoiler_title">forecast.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> FORECAST_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> FORECAST_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Arduino.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Ethernet.h&gt; #include &lt;Time.h&gt; //      4   typedef struct OneDay { time_t Data; //   "20141010' int TD; //  int TN; //  byte H; // int P; // byte WS; //  char WD[4]; //  byte Cloud; //  % int RainVal; //  (*100), 0 -  , -  +  char Icon[4]; //Icon } wdPack; // = 23 byte //    3   2   typedef struct ThreeHour { time_t Data; //   "2014-10-10 21:00' int T; // int TT; // Min  Max byte H; // int P; // byte WS; //  char WD[4]; // byte Cloud; //  % int RainVal; //  (*100), 0 -  , -  +  char Icon[4]; //Icon } whPack; //=23 byte class FORECAST { private : EthernetClient client; void clearStr (char* str); void addChar (char ch, char* str); void SubStrA(int Num,String&amp; source, String&amp; str); void SubStrB(int Num,String&amp; source, String&amp; str); time_t _ConvertDate(char _Data[10]); time_t _ConvertDateTime(char DatTim[16]); char* GetWord(uint8_t numWord); String dataString; boolean tagFlag; boolean dataFlag; int tZone; long tDelay; public : FORECAST(); void Init (EthernetClient&amp; clnt,int timeZone); struct _WeatherPacket { int P; // int T; // int H; // int WS; //  char WD[4]; // char Icon[4]; //Icon }; typedef wdPack _WeatherDay[4]; typedef whPack _WeatherThreeHour[16]; int GetForecast(_WeatherPacket&amp; whr); int GetForecastDays(_WeatherDay *wdp); int GetForecast3Hour(_WeatherThreeHour *whp); int iPacket3H; time_t SunRise; time_t SunSet; boolean fDebug; }; #endif</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">forecast.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"forecast.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"math.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;math.h&gt; #include &lt;Time.h&gt; #include &lt;avr/pgmspace.h&gt; ////////////////////////////////////////////////////////////////////////// //     w5100    2 (4   2) //  XML    3    15-18 //           //  4 (  1   8,     ). ////////////////////////////////////////////////////////////////////////// //       w5100.h // MAX_SOCK_NUM 2 // SOCKETS = 2; // SMASK = 0x0FFF; // Tx buffer MASK // RMASK = 0x0FFF; // Rx buffer MASK // SSIZE = 4096; // Max Tx buffer size // RSIZE = 4096; // Max Rx buffer size ////////////////////////////////////////////////////////////////////////// //   w5100.cpp // TX_RX_MAX_BUF_SIZE 4096 // writeTMSR(0xAA); // writeRMSR(0xAA); ////////////////////////////////////////////////////////////////////////// //   Ethernet.h // MAX_SOCK_NUM 2 ////////////////////////////////////////////////////////////////////////// //   Ethernet.cpp // uint8_t EthernetClass::_state[MAX_SOCK_NUM] = { 0, 0 }; // uint16_t EthernetClass::_server_port[MAX_SOCK_NUM] = { 0 , 0 }; ////////////////////////////////////////////////////////////////////////// #include &lt;Ethernet.h&gt; /////////////////////////////////////////////////////////////////////////////////////////////// //    PROGMEM ,   .    504  RAM const char p_FCserver[] PROGMEM = "api.openweathermap.org"; const char p_APIID[] PROGMEM = "&amp;APPID="; //    API-,    ! const char p_request3Hour[] PROGMEM = "GET /data/2.5/forecast?q=Krasnoyarsk&amp;mode=xml&amp;units=metric"; const char p_request4Day[] PROGMEM = "GET /data/2.5/forecast/daily?q=Krasnoyarsk&amp;mode=xml&amp;units=metric&amp;cnt=4"; const char p_requestToDay[] PROGMEM = "GET /data/2.5/weather?q=Krasnoyarsk&amp;mode=xml&amp;units=metric"; const char p_ConnClose[] PROGMEM = "Connection: close"; const char p_HTTP[] PROGMEM = " HTTP/1.1"; PGM_P const string_table[] PROGMEM = {p_FCserver, p_APIID,p_request3Hour,p_request4Day,p_requestToDay,p_ConnClose,p_HTTP}; char words[80]; /////////////////////////////////////////////////////////////////////////////////////////////// #define MAX_STRING_LEN 100 char tagStr[MAX_STRING_LEN] = ""; char tmpStr[MAX_STRING_LEN] = ""; char endTag[3] = {'&lt;', '/', '\0'}; char inChar; //  FORECAST::FORECAST() { fDebug = false; } //       EthernetClient,    //         , ..      void FORECAST::Init(EthernetClient&amp; clnt, int timeZone) { client = clnt; tZone = timeZone; tDelay = 1000; } //  3   (2    3 ) int FORECAST::GetForecast3Hour(FORECAST::_WeatherThreeHour *whp) { int p1 = 0,p2 = 0; char TMP[20]; String temp = ""; float T; if (client.connected()) client.stop(); if (client.connect(GetWord(0), 80)) { temp = GetWord(2); //temp += GetWord(1); temp += GetWord(6); //if (fDebug) Serial.println(temp); client.println(temp); client.print("Host: "); client.println(GetWord(0)); client.println(GetWord(5)); client.println(); temp = ""; //    ,     -  while (!client.available()) { p1++; delay(50); if ( p1 &gt; tDelay ) { client.stop(); return 0; } } iPacket3H = 0; while (client.available()) { //----------------------------------------------------------- inChar = client.read(); if (inChar == '&lt;') //   { addChar(inChar, tmpStr); tagFlag = true; } else if (inChar == '&gt;') //   { addChar(inChar, tmpStr); if (tagFlag) //      { strncpy(tagStr, tmpStr, strlen(tmpStr)+1); } clearStr(tmpStr); tagFlag = false; } else if (inChar != 10) { if (tagFlag) { addChar(inChar, tmpStr); // Check for &lt;/XML&gt; end tag, ignore it if ( tagFlag &amp;&amp; strcmp(tmpStr, endTag) == 0 ) { clearStr(tmpStr); tagFlag = false; } } } //    -   if ((inChar == 10 ) || (inChar == '&gt;')) { dataString = tagStr; if( !strncmp(tagStr,"&lt;time from",10)) { //&lt;time from="2014-11-26T03:00:00" to="2014-11-26T06:00:00"&gt; //if (fDebug) Serial.println(tagStr); p1 = dataString.indexOf('"',1); p1++; p2 = dataString.indexOf('"',p1); temp = dataString.substring(p1,p2-3); temp.replace("T"," "); temp.toCharArray(TMP,temp.length()+1); (*whp)[iPacket3H].Data = _ConvertDateTime(TMP); } else if( !strncmp(tagStr,"&lt;symbol",7)) { // &lt;symbol number="600" name="light snow" var="13d"/&gt; p1 = dataString.indexOf("var"); SubStrA(p1,dataString,temp); temp.toCharArray((*whp)[iPacket3H].Icon,temp.length()+1); } else if( !strncmp(tagStr,"&lt;precipitation",14)) { // &lt;precipitation unit="3h" value="0.125" type="rain"&gt; //if (fDebug) Serial.println(tagStr); int sign; clearStr(TMP); if (dataString.indexOf("rain") &gt; 0) sign = 1; //  else if (dataString.indexOf("snow") &gt; 0 || dataString.indexOf("show") &gt; 0) sign = -1; //  //29.09.2015 -       snow  show else sign = 0; //   p1 = dataString.indexOf("value"); if (sign != 0) { SubStrA(p1,dataString,temp); temp.toCharArray(TMP,temp.length()+1); (*whp)[iPacket3H].RainVal = atof(TMP) * sign * 100; } else (*whp)[iPacket3H].RainVal = 0; } else if( !strncmp(tagStr,"&lt;windDirection",14)) { //&lt;windDirection deg="235" code="SW" name="Southwest"/&gt; p1 = dataString.indexOf("code"); SubStrA(p1,dataString,temp); temp.toCharArray((*whp)[iPacket3H].WD,temp.length()+1); } else if( !strncmp(tagStr,"&lt;windSpeed",10)) { //&lt;windSpeed mps="4.62" name="Gentle Breeze"/&gt; clearStr(TMP); SubStrA(1,dataString,temp); temp.toCharArray(TMP,temp.length()+1); T = atof(TMP); (*whp)[iPacket3H].WS = round(T); } else if( !strncmp(tagStr,"&lt;temperature",12)) { //&lt;temperature unit="celsius" value="-12.92" min="-17.91" max="-12.92"/&gt; clearStr(TMP); p1 = dataString.indexOf("value"); SubStrA(p1,dataString,temp); temp.toCharArray(TMP,temp.length()+1); T = atof(TMP); (*whp)[iPacket3H].T = round(T); if (T &lt; 0) p1 = dataString.indexOf("min"); else p1 = dataString.indexOf("max"); clearStr(TMP); SubStrA(p1,dataString,temp); temp.toCharArray(TMP,temp.length()+1); T = atof(TMP); (*whp)[iPacket3H].TT = round(T); } else if( !strncmp(tagStr,"&lt;pressure",9)) { //&lt;pressure unit="hPa" value="999.14"/&gt; p1 = dataString.indexOf("value"); SubStrA(p1,dataString,temp); (*whp)[iPacket3H].P = temp.toInt(); (*whp)[iPacket3H].P =((*whp)[iPacket3H].P * 0.75); // - 17 } else if( !strncmp(tagStr,"&lt;humidity",9)) { //&lt;humidity value="73" unit="%"/&gt; SubStrA(1,dataString,temp); (*whp)[iPacket3H].H = temp.toInt(); } else if( !strncmp(tagStr,"&lt;clouds",7)) { // &lt;clouds value="broken clouds" all="56" unit="%"/&gt; p1 = dataString.indexOf("all"); SubStrA(p1,dataString,temp); (*whp)[iPacket3H].Cloud = temp.toInt(); iPacket3H++; } clearStr(tmpStr); clearStr(tagStr); tagFlag = false; } //----------------------------------------------------------- if (iPacket3H==16) {break;} } client.stop(); return 1; } else {return 0;} } ///////////////////////////////////////////////  4  /////////////////////////////////////////////////////// /* int FORECAST::GetForecastDays(FORECAST::_WeatherDay* wdp) { int iPack=0,p=0; char TMP[20]; String temp; float T; if (client.connected()) client.stop(); if (client.connect(GetWord(0), 80)) { temp = GetWord(3); //temp += GetWord(1); temp += GetWord(6); if (fDebug) Serial.println(temp); client.println(temp); client.print("Host: "); client.println(GetWord(0)); client.println(GetWord(5)); client.println(); temp = ""; while (!client.available()) { p++; delay(50); if ( p &gt; tDelay ) { client.stop(); return 0; } } while (client.available()) { inChar = client.read(); if (inChar == '&lt;') //   { addChar(inChar, tmpStr); tagFlag = true; } else if (inChar == '&gt;') //   { addChar(inChar, tmpStr); if (tagFlag) //      { strncpy(tagStr, tmpStr, strlen(tmpStr)+1); } clearStr(tmpStr); tagFlag = false; } else if (inChar != 10) { if (tagFlag) { addChar(inChar, tmpStr); // Check for &lt;/XML&gt; end tag, ignore it if ( tagFlag &amp;&amp; strcmp(tmpStr, endTag) == 0 ) { clearStr(tmpStr); tagFlag = false; } } } //    -   if ((inChar == 10 ) || (inChar == '&gt;')) { dataString = tagStr; if( !strncmp(tagStr,"&lt;time day",9)) { //&lt;time day="2014-10-09"&gt; SubStrA(1,dataString,temp); //temp.toCharArray((*wdp)[iPack].Data,temp.length()+1); temp.toCharArray(TMP,temp.length()+1); (*wdp)[iPack].Data = _ConvertDate(TMP); //if (fDebug) Serial.println(temp); } else if( !strncmp(tagStr,"&lt;symbol",7)) { // &lt;symbol number="600" name="light snow" var="13d"/&gt; p = dataString.indexOf("var"); SubStrA(p,dataString,temp); temp.toCharArray((*wdp)[iPack].Icon,temp.length()+1); } else if( !strncmp(tagStr,"&lt;precipitation",14)) { // &lt;precipitation value="1.25" type="snow"/&gt; int sign; clearStr(TMP); if (dataString.indexOf("rain") &gt; 0) sign = 1; //  else if (dataString.indexOf("snow") &gt; 0 || dataString.indexOf("show") &gt; 0) sign = -1; //  else sign = 0; //   if (sign != 0) { p=1; SubStrA(p,dataString,temp); temp.toCharArray(TMP,temp.length()+1); (*wdp)[iPack].RainVal = atof(TMP) * sign * 100; } else (*wdp)[iPack].RainVal = 0; } else if( !strncmp(tagStr,"&lt;windDirection",14)) { //&lt;windDirection deg="235" code="SW" name="Southwest"/&gt; p = dataString.indexOf("code"); SubStrA(p,dataString,temp); temp.toCharArray((*wdp)[iPack].WD,temp.length()+1); } else if( !strncmp(tagStr,"&lt;windSpeed",10)) { //&lt;windSpeed mps="4.62" name="Gentle Breeze"/&gt; clearStr(TMP); SubStrA(1,dataString,temp); temp.toCharArray(TMP,temp.length()+1); T = atof(TMP); (*wdp)[iPack].WS = round(T); } else if( !strncmp(tagStr,"&lt;temperature",12)) { //&lt;temperature day="4.48" min="-1.12" max="4.48" night="-0.94" eve="-1.12" morn="2.26"/&gt; clearStr(TMP); SubStrA(1,dataString,temp); temp.toCharArray(TMP,temp.length()+1); T = atof(TMP); (*wdp)[iPack].TD = round(T); clearStr(TMP); p = dataString.indexOf("night"); SubStrA(p,dataString,temp); temp.toCharArray(TMP,temp.length()+1); T = atof(TMP); (*wdp)[iPack].TN = round(T); } else if( !strncmp(tagStr,"&lt;pressure",9)) { //&lt;pressure unit="hPa" value="999.14"/&gt; p = dataString.indexOf("value"); SubStrA(p,dataString,temp); (*wdp)[iPack].P = temp.toInt(); (*wdp)[iPack].P =((*wdp)[iPack].P * 0.75 - 17); } else if( !strncmp(tagStr,"&lt;humidity",9)) { //&lt;humidity value="73" unit="%"/&gt; SubStrA(1,dataString,temp); (*wdp)[iPack].H = temp.toInt(); } else if( !strncmp(tagStr,"&lt;clouds",7)) { // &lt;clouds value="broken clouds" all="56" unit="%"/&gt; p = dataString.indexOf("all"); SubStrA(p,dataString,temp); (*wdp)[iPack].Cloud = temp.toInt(); iPack++; } clearStr(tmpStr); clearStr(tagStr); tagFlag = false; } } //   client.stop(); return 1; } else {return 0;} } */ /////////////////////////////    ////////////////////////////////////////////////////////////// /* int FORECAST::GetForecast(FORECAST::_WeatherPacket&amp; whr) { int p1 = 0; char TMP[20]; String temp = ""; float T; int step = 0; if (client.connected()) client.stop(); if (client.connect(GetWord(0), 80)) { temp = GetWord(4); //temp += GetWord(1); temp += GetWord(6); if (fDebug) Serial.println(temp); client.println(temp); client.print("Host: "); client.println(GetWord(0)); client.println(GetWord(5)); client.println(); temp = ""; while (!client.available()) //     { p1++; delay(50); if ( p1 &gt; tDelay ) //    -   { client.stop(); return 0; } } while (client.available()) //  -   { // Read a char inChar = client.read(); //if (fDebug) Serial.print(inChar); if (inChar == '&lt;') { addChar(inChar, tmpStr); tagFlag = true; } else if (inChar == '&gt;') { addChar(inChar, tmpStr); if (tagFlag) { strncpy(tagStr, tmpStr, strlen(tmpStr)+1); } clearStr(tmpStr); tagFlag = false; dataFlag = true; } else if (inChar != 10) { if (tagFlag) { addChar(inChar, tmpStr); // Check for &lt;/XML&gt; end tag, ignore it if ( tagFlag &amp;&amp; strcmp(tmpStr, endTag) == 0 ) { clearStr(tmpStr); tagFlag = false; dataFlag = false; } } } // If a LF, process the line if ((inChar == 10 ) || (inChar == '&gt;')) { dataString = tagStr; if( !strncmp(tagStr,"&lt;sun",4)) { // &lt;sun rise="2014-10-14T00:18:33" set="2014-10-14T10:51:01"/&gt; SubStrA(1,dataString,temp); temp.replace("T"," "); temp.toCharArray(TMP,temp.length()+1); if (fDebug) {Serial.print("SunRise_w_");Serial.println(TMP);} SunRise = _ConvertDateTime(TMP); p1 = dataString.indexOf("set"); p1++; SubStrA(p1,dataString,temp); temp.replace("T"," "); temp.toCharArray(TMP,temp.length()+1); SunSet = _ConvertDateTime(TMP); step++; } else if( !strncmp(tagStr,"&lt;temperature",12)) { //&lt;temperature value="-9.86" min="-16" max="-6.3" unit="celsius"/&gt; clearStr(TMP); SubStrA(1,dataString,temp); temp.toCharArray(TMP,temp.length()+1); T = atof(TMP); whr.T = round(T); step++; if (fDebug) Serial.println(tagStr); } else if( !strncmp(tagStr,"&lt;humidity",9)) { //&lt;humidity value="65" unit="%"/&gt; SubStrA(1,dataString,temp); whr.H = temp.toInt(); step++; } else if( !strncmp(tagStr,"&lt;pressure",9) ) { //&lt;pressure value="1027" unit="hPa"/&gt; SubStrA(1,dataString,temp); // whr.P = round(temp.toInt() * 0.75 - 17); whr.P = temp.toInt() ; step++; if (fDebug) Serial.println(tagStr); } else if( !strncmp(tagStr,"&lt;speed",6) ) { //&lt;speed value="1.51" name=""/&gt; clearStr(TMP); SubStrA(1,dataString,temp); temp.toCharArray(TMP,temp.length()+1); T = atof(TMP); whr.WS = round(T); step++; if (fDebug) Serial.println(tagStr); } else if( !strncmp(tagStr,"&lt;direction",10) ) { //&lt;direction value="160.501" code="SSE" name="South-southeast"/&gt; p1 = dataString.indexOf("code"); SubStrB(p1,dataString,temp); temp.toCharArray(whr.WD,temp.length()+1); step++; if (fDebug) Serial.println(tagStr); } else if( !strncmp(tagStr,"&lt;weather",8) ) { //&lt;weather number="803" value="broken clouds" icon="04d"/&gt; p1 = dataString.indexOf("icon"); SubStrA(p1,dataString,temp); temp.toCharArray(whr.Icon,temp.length()+1); step++; if (fDebug) {Serial.println(tagStr);Serial.println("-------------------");} } clearStr(tmpStr); clearStr(tagStr); tagFlag = false; dataFlag = false; } } //   client.stop(); if (step &gt; 5) return 1; else return 0; } else {return 0;} } */ ////////////////////   //////////////////////////////////////////////////// void FORECAST::SubStrA(int Num,String&amp; source, String&amp; str) { int p1 = source.indexOf('"',Num); p1++; int p2 = source.indexOf('"',p1); str = source.substring(p1,p2); } //          void FORECAST::SubStrB(int Num,String&amp; source, String&amp; str) { int p1 = source.indexOf('"',Num); p1++; int p2 = source.indexOf('"',p1+1); if (p2 - p1 &lt; 1) str = "WNW"; else str = source.substring(p1,p2); } //Function to add a char to a string and check its length void FORECAST::addChar(char ch, char* str) { char const *tagMsg = "!=!"; if (strlen(str) &gt; MAX_STRING_LEN - 2) { if (tagFlag) { clearStr(tagStr); strcpy(tagStr,tagMsg); } // Clear the temp buffer and flags to stop current processing clearStr(tmpStr); tagFlag = false; } else { // Add char to string str[strlen(str)] = ch; } } // Function to clear a string void FORECAST::clearStr(char* str) { int len = strlen(str); for (int c = 0; c &lt; len; c++) { str[c] = 0; } } time_t FORECAST::_ConvertDate(char _Data[11]) { int Y, M, D; TimeElements te; sscanf ( _Data,"%i-%d-%d", &amp;Y, &amp;M, &amp;D); te.Year = Y -1900; te.Month = M; te.Day = D; te.Hour=0; te.Minute=0; te.Second=0; return makeTime(te); } time_t FORECAST::_ConvertDateTime(char _DateTime[17]) { int Y, M, D, hh, mm; TimeElements te; //   (    ) sscanf ( _DateTime,"%i-%d-%d %d:%d", &amp;Y, &amp;M, &amp;D, &amp;hh, &amp;mm ); //     TimeZone hh = hh + tZone; if (hh &gt; 24) { hh = hh - 24; if ( (M == 2 &amp;&amp; D == 28 &amp;&amp; Y%4 != 0)|| (M == 2 &amp;&amp; D == 29 &amp;&amp; Y%4 == 0) || ((M == 1 || M == 3 || M == 5 || M == 7 || M == 8 || M == 10 || M == 12) &amp;&amp; D == 31) || ((M == 4 || M == 6 || M == 9 || M == 11) &amp;&amp; D == 30) ) { M++; D = 1; if (M==13) {M=1;Y++;} } else D++; } te.Year = Y -1900; te.Month = M; te.Day = D; te.Hour = hh; te.Minute = mm; te.Second=0; return makeTime(te); } //    flash -   ‚Ññ char* FORECAST::GetWord(uint8_t numWord) { strcpy_P(words, (PGM_P)pgm_read_word(&amp;(string_table[numWord]))); return words; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Forecast.ino</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Time.h&gt; #include &lt;SPI.h&gt; #include &lt;Ethernet.h&gt; #include "forecast.h" /////////////////////////////////////////////////// byte mac[] = { 0xEA, 0xCD, 0xCE, 0x17, 0x19, 0x66 }; char server[] = "192.168.1.120"; //      EthernetClient client; ////////////////////////////////////////////////// //    FORECAST frc; FORECAST::_WeatherPacket weather; //     FORECAST::_WeatherDay wPack1Day; //      4  (  ) FORECAST::_WeatherThreeHour wPack3Hour; // 3       2  //   4   const unsigned long dInterval = 300000; unsigned long last_dForecast; //   3   const unsigned long hInterval = 300000; // unsigned long last_hForecast; //           const unsigned long wInterval = 200000; //~30 . unsigned long last_wForecast; ////////////////////////////////////// #define DEBUG_MODE 1 ////////////////////////////////////// void setup() { frc.fDebug = false; if (Ethernet.begin(mac) == 0) { while (1) { delay(1000); } } //    unsigned long now = millis(); frc.Init(client, 7); last_wForecast = now - wInterval + 2000; last_hForecast = now - hInterval + 15000; last_dForecast = now - dInterval + 25000; } void loop() { unsigned long now = millis(); /* if ( now - last_wForecast &gt; wInterval ) { if (frc.GetForecast(weather) == 1) //     { last_wForecast = now; } } */ if ( now - last_hForecast &gt; hInterval) { if (frc.GetForecast3Hour(&amp;wPack3Hour) == 1) //   2   3  { if ( frc.iPacket3H &gt; 2 ) //   ,   2 last_hForecast = millis(); else last_hForecast = millis() - hInterval + 30000; PrintForecast3H(); } } /* if ( now - last_dForecast &gt; dInterval) { if (frc.GetForecastDays(&amp;wPack1Day) == 1) //   4  { last_dForecast = millis(); PrintForecastDay(); } } */ } void ConvertDT(time_t tt, char dt[17]) { TimeElements t_e; int Y, M, D, hh, mm; breakTime(tt, t_e); Y = t_e.Year + 1900; M = t_e.Month; D = t_e.Day; hh = t_e.Hour; mm = t_e.Minute; sprintf(dt, "%i.%i.%i %i:%i", D, M, Y, hh, mm); } void PrintForecast3H() { char DT[17]; for (int i = 0; i &lt; frc.iPacket3H; i++) { ConvertDT(wPack3Hour[i].Data, DT); Serial.print("Data= "); Serial.print(DT); Serial.print("; "); Serial.print(wPack3Hour[i].RainVal / 100.0); Serial.print("; "); Serial.print(wPack3Hour[i].WS); Serial.print("; "); Serial.print(wPack3Hour[i].WD); Serial.print("; "); Serial.print(wPack3Hour[i].T); Serial.print("; "); Serial.print(wPack3Hour[i].TT); Serial.print("; "); Serial.print(wPack3Hour[i].H); Serial.print("; "); Serial.print(wPack3Hour[i].P); Serial.print("; "); Serial.println(wPack3Hour[i].Icon); } } /* void ConvertD(time_t tt, char dd[11]) { TimeElements t_e; int Y, M, D; breakTime(tt, t_e); Y = t_e.Year + 1900; M = t_e.Month; D = t_e.Day; sprintf(dd, "%i.%i.%i", D, M, Y); } void PrintForecastDay() { char D[11]; for (int i = 0; i &lt; 4; i++) { ConvertD(wPack1Day[i].Data, D); Serial.print("Data= "); Serial.print(D); Serial.print("; "); Serial.print(wPack1Day[i].RainVal / 100.0); Serial.print("; "); Serial.print(wPack1Day[i].WS); Serial.print("; "); Serial.print(wPack1Day[i].WD); Serial.print("; "); Serial.print(wPack1Day[i].TD); Serial.print("; "); Serial.print(wPack1Day[i].TN); Serial.print("; "); Serial.print(wPack1Day[i].P); Serial.print("; "); Serial.print(wPack1Day[i].H); Serial.print("; "); Serial.print(wPack1Day[i].Cloud); Serial.print("; "); Serial.println(wPack1Day[i].Icon); } } */</span></span></span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/357884/">https://habr.com/ru/post/357884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357862/index.html">How to make Push notifications in Safari browser on macOS</a></li>
<li><a href="../357864/index.html">Roskomnadzor will conduct an "experiment" on blocking Zello Internet radio in Russia</a></li>
<li><a href="../357866/index.html">Roskomnadzor continues to destroy the Internet: it's Google's turn</a></li>
<li><a href="../357880/index.html">Arduino programmable relay</a></li>
<li><a href="../357882/index.html">Laser link between two Arduino Morse code</a></li>
<li><a href="../357886/index.html">Arduino: TV viewing time limit using RFID RC522 and</a></li>
<li><a href="../357888/index.html">DMX-512 Channel Level Transmission Visualization</a></li>
<li><a href="../357890/index.html">We process lines on Arduino</a></li>
<li><a href="../357892/index.html">Based on "Processing lines on Arduino"</a></li>
<li><a href="../357894/index.html">Crazy hands: "Stern dispenser"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>