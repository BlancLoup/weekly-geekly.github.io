<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monorepositions: please do not</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: Hi, Habr! Yes, this is another article about the advantages and disadvantages of mono-repositories. I was going to write my artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monorepositions: please do not</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  From the translator: Hi, Habr!  Yes, this is another article about the advantages and disadvantages of mono-repositories.  I was going to write my article about how we use the mono-repository, how we switched from maven to bazel and what came of it.  But while I was thinking about it, a great article came out from the developer from Lyft, which I decided to translate for you.  I promise to publish my additions to the article, as well as the experience with bazel as a continuation. </blockquote>  We are in the New 2019, and I am set to another discussion about the benefits (or lack thereof) of storing the entire source code of the organization in the Mono-Compository.  For those of you who are not familiar with this approach, the idea is to store all the source code in a single repository of the version control system.  The alternative, of course, is to store the source code in several independent repositories, usually separated by the boundaries of services / applications / libraries. <br><br>  In this post I will call this approach "poly repository". <br><a name="habracut"></a><br>  Some of the IT giants use monographs, including Google, Facebook, Twitter, and others.  Of course, if such reputable companies use monorepositories, then the benefits of this approach should be enormous, and we should all do the same, right?  Not!  As stated in the title of the article: ‚ÄúPlease do not use a mono-repository!‚Äù Why?  Because <i>on a large scale, a mono-repository will solve all the same problems that the poly-repository also solves, but at the same time provoking you to a strong connection of your code and requiring incredible efforts to increase the scalability of your version control system</i> . <br><br>  Thus, in the medium and long term, the monorepository does not provide any organizational advantages, while it leaves the company's best engineers with a post-traumatic syndrome (manifested in the form of drooling and rambling about git performance). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: absolute; visibility: hidden; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i1550735240288408536="true"><p lang="en" dir="ltr">  I‚Äôve been ridiculous monorepos are.  2019 is off to an inauspicious start.  In the spirit of this, I bring you a poll. <br><br>  Who are the bigger zealots?  Supporters of: </p>  - Matt Klein (@ mattklein123) <a href="https://twitter.com/mattklein123/status/1080170131869712384%3Fref_src%3Dtwsrc%255Etfw">January 1, 2019</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  A short digression: what do I mean by "on a large scale"?  There is no definitive answer to this question, but because  I'm sure you ask me about it, let's say that it‚Äôs about 100 developers writing full-time code. <br><br><h2>  The theoretical advantages of a mono-pository and why they cannot be achieved without the tools that are used for poly-rhository (or false) </h2><br><h4>  Theoretical Advantage 1: Easier Collaboration and Code Sharing </h4><br>  Mono-repository advocates argue that when all code is in the same repository, the probability of code duplication is less, and the likelihood of different teams working together on a common infrastructure increases. <br><br>  Here is the bitter truth about even medium-sized mono-repositories (and it will sound constantly in this section): it becomes very inappropriate for a developer to keep the entire repository code on his workstation or search all codebases using tools like grep.  Therefore, any mono-repository that wants to scale should provide 2 things: <br><br>  1) something like a virtual file system that allows you to store locally only part of the code.  This can be achieved using a proprietary file system like <a href="https://www.perforce.com/">Perforce</a> , which supports this mode natively, using Google's internal <a href="https://ai.google/research/pubs/pub45424">G3</a> tool or Microsoft's <a href="https://en.wikipedia.org/wiki/Git_Virtual_File_System">GVFS</a> . <br><br>  2) complex tools as a service (as a service) for indexing / searching / viewing source code.  Since  none of the developers is going to keep all the source code on their workstation in a searchable state; it becomes critical to be able to conduct such a search across the entire code base. <br><br>  Assuming that the developer will only have access to a small portion of the source code at any one time, is there any difference between loading a part of a mono-repository or downloading several independent repositories?  <i>There is no difference</i> . <br><br>  In the context of indexing / searching / viewing and similar code, such a hypothetical tool can easily search and across multiple repositories and combine the result.  In fact, this is exactly how search on GitHub works, as well as more sophisticated search and indexing tools, such as <a href="https://sourcegraph.com/start">Sourcegraph</a> . <br><br>  Thus, from the point of view of collaboration on the code on a large scale, developers, in any case, are forced to work only with part of the code base and use higher-level tools.  It doesn't matter if the code is stored in a mono-repository or in several independent repositories, the problem is solved in the same way, and the <i>efficiency of conscientious work on the code depends only on the engineering culture, and not on the way the source codes are stored</i> . <br><br><h4>  Theoretical advantage 2: one build / no dependency management </h4><br>  The next argument, usually given by mono-supporters, is that storing all the code in a single monopository makes it unnecessary for you to manage dependencies, because  all code is collected at the same time.  It's a lie!  On a large scale, it is simply not possible to re-compile all source code and run all automated tests every time someone commits changes to the version control system (or more importantly and more often, on the CI server when a new branch or pull-request is created).  To solve this problem, all large mono-positoras use their complex build system (for example, <a href="https://bazel.build/">Bazel</a> / Blaze from Google or <a href="https://buckbuild.com/">Buck</a> from Facebook), which is designed to follow changes and their dependent blocks and build a dependency graph of the source code.  This graph allows you to organize effective caching of the results of the assembly and tests, so that only changes and their dependencies need to be reassembled and tested. <br><br>  Moreover, since  the assembled code should eventually be compacted, and, as you know, all software cannot be compiled at once, it is important that all assembly artifacts are controlled, so that artifacts are redefined as needed.  In essence, this means that even in the world of mono-repositories, several versions of code may exist at the same time in nature, and must be carefully monitored and coordinated. <br><br>  Proponents of monorepositions will also argue that even with the need to keep track of assemblies / dependencies, this still gives an undeniable advantage, since  a single commit describes the complete state of the whole world.  I would say that this advantage is rather controversial, given that the dependency graph already exists, and it looks like a rather trivial task to include the commit identifier for each independent repository as part of this graph, and in fact Bazel can easily work with several independent repositories as well as with one monorepository, abstracting the underlying level from the developer.  Moreover, it is easy to implement such automated refactoring tools that automatically update the versions of dependent libraries in several independent repositories at once, leveling the difference between the mono-repository and the poly-repository in this part (more on this later). <br><br>  The end result is that the realities of assembly / deployment on a large scale are for the most part the same for mono-repositories and poly-repositories.  <i>For tools there is no difference, it should not be for developers writing code</i> . <br><br><h4>  Theoretical advantage 3: code refactoring is a simple atomic commit </h4><br>  Finally, the last virtue that monorepository advocates mention is the fact that one repository makes code refactoring simpler due to the simplicity of the search, and the idea that a single commit can span the entire repository.  This is incorrect for several reasons: <br><br>  1) as described above, on a large scale, the developer will not be able to edit or search the entire code base on his local machine.  Thus, the idea that everyone can easily clone their entire repository and simply perform grep / replace is not so easy to implement in practice. <br><br>  2) even if we assume that using a complex virtual file system, a developer can clone and edit the entire code base, how often will this happen?  I‚Äôm not talking about fixing a bug in the implementation of a shared library, since this situation is handled in the same way in the case of a single repository and in the case of a poly repository (assuming a similar build / deployment system, as described above).  I'm talking about changing the library API, followed by many compilation errors in the places where this library is called.  In a very large code base, it is <i>almost impossible to make a change to the base API, which will be verified by all involved teams before merge conflicts force you to start the process over</i> .  The developer has 2 real possibilities: he can give up and come up with a workaround for a problem with the API (in practice it happens more often than we all would like), or he can stop the existing API, write a new API and then embark on a long path and painful update of all calls to the old API throughout the code base.  In any case, <i>it is absolutely the same process as in the poly repository</i> . <br><br>  3) in a service-oriented world, applications consist of many loosely coupled components that interact with each other using some type of well-described API.  Large organizations will sooner or later use IDL (Interface Description Language), such as Thrift or Protobuf, which allow you to make type-safe APIs and make backward-compatible changes.  As described in the previous section on assembly / deploe, the <i>code cannot be simultaneously locked</i> .  It can be deployed over a period of time: hours, days, or even months.  Therefore, developers are required to think about the backward compatibility of their changes.  This is the reality of modern software development, which many would like to ignore, but cannot.  Therefore, when it comes to services (as opposed to API libraries), developers should use one of the two approaches described above (do not change the API or go through the deprecation cycle) and <i>this is absolutely the same for both the mono-repository and the poly-repository</i> . <br><br>  Speaking of refactoring on a large code base, many large organizations come to develop their automated tools for automatic refactoring, such as <a href="https://github.com/facebookincubator/fastmod">fastmod</a> , recently released by Facebook.  As always, this tool could easily work with a single repository or several independent ones.  Lyft has a tool called ‚Äúrefactorator‚Äù that does exactly that.  It works like fastmod, but automates changes to several of our repositories, including creating pull-requests, tracking revisions, etc. <br><br><h2>  The unique shortcomings of monorepositions </h2><br>  In the previous section, I listed all the theoretical advantages that the mono-repository provides, and noted that in order to use them, it is required to create an incredibly complex toolkit that will not differ from the tools for poly-repositories.  In this section I will mention 2 unique shortcomings of mono-repositories. <br><br><h4>  Disadvantage 1: strong connectivity and open source software </h4><br>  Organizationally, a mono-repository provokes the creation of highly related and fragile software.  It gives developers the feeling that they can easily correct errors in abstractions, although in fact they cannot because of the unstable assembly / deployment process and human / organizational / cultural factors that arise when trying to make changes across the entire code base. <br><br>  The code structure in polyrepositories impersonates clear and transparent boundaries between teams / projects / abstractions / code owners and forces the developer to carefully consider the interaction interface.  This is an unobtrusive but very important advantage: it makes developers think on a larger scale and in a longer perspective.  Moreover, the use of poly-repositories does not mean that developers cannot go beyond the limits of the repository.  Whether this happens or not depends only on the developmental culture, and not on whether a mono-repository or poly-repository is used. <br><br>  Strong binding also has serious implications regarding the discovery of its source codes.  If a company wants to create or consume open source software, the use of poly-repositories is a must.  The distortions that occur when a company tries to lay out its open source project from its monopository (import / export of source codes, public / privat bug tracker, additional layers for abstracting the difference in standard libraries, etc.) do not lead to productive collaboration and community building, and create significant overhead. <br><br><h4>  Disadvantage 2: version control system scalability </h4><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: absolute; visibility: hidden; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;"></twitter-widget><blockquote class="twitter-tweet" data-lang="en_US" data-twitter-extracted-i1550735240288408536="true"><p lang="en" dir="ltr">  here I updated the XKCD comic for you <a href="http://t.co/pwPBIghTV3">pic.twitter.com/pwPBIghTV3</a> </p>  - monorepi (@monorepi) <a href="https://twitter.com/monorepi/status/542081644954259457%3Fref_src%3Dtwsrc%255Etfw">December 8, 2014</a> </blockquote><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br>  Scaling a version control system for hundreds of developers, hundreds of millions of lines of code, and a huge stream of commits is a monumental task.  The Twitter monorapository, created 5 years ago (based on git), was one of the most useless projects that I watched for my career.  Running a simplest command like <code>git status</code> took <i>minutes</i> .  If the local copy of the repository was too old, the update could take <i>hours</i> (at that time it was even a practice to send hard drives with a copy of the repository to remote employees with a fresh version of the code).  I‚Äôm not thinking about this to make fun of the Twitter developers, but to illustrate how difficult this problem is.  I can say that 5 years later, the performance of the Twitter mono-repository is still far from the one that the developers of the Tulling team would like to see, and this is not because they tried hard. <br><br>  Of course, in these 5 years some development took place in this area.  Microsoft's <a href="https://github.com/Microsoft/VFSForGit">Git VFS</a> , which is used to develop Windows, has led to the emergence of a real virtual file system for git, which I described above as a necessary condition for scaling a version control system (and with the purchase of Microsoft Github, it looks like this level of scaling will find its application in features that GiHub offers to its corporate clients).  And of course, Google and Facebook continue to invest huge resources in their internal systems so that they continue to function, although almost none of this is publicly available. <br><br>  <i>So why do we need to solve these problems at all with the scaling of the version control system, if, as described in the previous section, the toolkit requires exactly the same as for the polyrepository?</i>  There is no reasonable reason for this. <br><br><h2>  Conclusion </h2><br>  As often happens in software development, we look at the most successful software companies as an example and try to borrow their best practices without understanding what exactly led these companies to success.  Monorepositions, in my opinion, are a typical example of such a case.  Google, Facebook and Twitter have invested a huge amount of resources in their code storage systems only to come up with a solution that is essentially <i>no different from what is required for a poly repository, but provokes a strong binding and requires a huge investment in scaling the version control system.</i> . <br><br>  In fact, on a large scale, how does a company act with collaboration with code, collaboration, strong binding, etc.  <i>directly depends on engineering culture and leadership, and is irrelevant to whether a mono-repository or a polypository is used</i> .  Both solutions look the same to the developer.  So why use a mono-repository?  <b>Please do not!</b> </div><p>Source: <a href="https://habr.com/ru/post/435306/">https://habr.com/ru/post/435306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435294/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ346 (January 1 - 6, 2019)</a></li>
<li><a href="../435296/index.html">Hall of Fame Consumer Electronics: Stories of the Best Gadgets of the Last 50 Years, Part 3</a></li>
<li><a href="../435298/index.html">"Radar" Google Soli continues to evolve</a></li>
<li><a href="../435300/index.html">Subjective vision of an ideal programming language</a></li>
<li><a href="../435302/index.html">Prototype code. Lecture on FrontTalks</a></li>
<li><a href="../435308/index.html">Electronic books and their formats: we tell about PDF - its history, pluses and minuses</a></li>
<li><a href="../435310/index.html">Widevine L3 DRM protection hacked</a></li>
<li><a href="../435312/index.html">Electric Polestar 2 - the first electric car with native Android Android OS</a></li>
<li><a href="../435314/index.html">‚ÄúYou know what's best ‚Äî do it better‚Äù: a new podcast about the mix of work and the hobby of an editor / marketer</a></li>
<li><a href="../435316/index.html">Korean scientists have created a system for tracking road traffic from two laptops</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>