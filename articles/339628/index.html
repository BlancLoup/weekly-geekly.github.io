<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We unite Websockets, Lisp and functional programming</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We unite Websockets, Lisp and functional programming. But how? 


 With Clojure. 


 On Habr√© there are enough articles - examples of applications usi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We unite Websockets, Lisp and functional programming</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://monosnap.com/file/Azm5lfPJ1jj7EzNVhK3YZvILp0XCRT.png" alt="Alt text"></p><br><p>  We unite Websockets, Lisp and functional programming.  But how? </p><a name="habracut"></a><br><p>  With Clojure. </p><br><p>  On Habr√© there are enough articles - examples of applications using <br>  Web sockets ( <a href="https://ru.wikipedia.org/wiki/WebSocket">WebSocket</a> , <a href="https://tools.ietf.org/html/rfc6455">RFC</a> ) implemented using popular languages ‚Äã‚Äãand technologies.  Today I would like to show an example of a simple web application using less popular, but no less good, technologies and a small (~ 90kB JAR with zero dependencies and ~ 3k lines of (mostly Java) code) http / client library / server kit. </p><br><p>  A possible side effect is (not the goal) dispelling the myth of the complexity of writing modern applications using Lisp and functional programming. </p><br><p>  This article is not the answer to other technologies, and not their comparison.  This attempt at writing is dictated solely by my personal attachment to Clojure and by a long-standing desire to try writing. </p><br><p>  Meet the friendly company: </p><br><ul><li>  Starring <a href="https://ru.wikipedia.org/wiki/Clojure">Clojure</a> </li><li>  Genre: <strong>FP</strong> (Functional programming) </li><li>  Client / server: <a href="http-kit.org/index.html">http-kit</a> </li><li>  Toolkit: lein ( <a href="https://leiningen.org/">leiningen</a> ) - build tool, dependency manager. </li><li>  other </li></ul><br><p>  I would not like to make an excursion into Clojure and Lisp, the stack and the toolkit, I‚Äôd rather make short remarks and leave comments in the code, so let's start: </p><br><p><code>lein new ws-clojure-sample</code> </p> <br><p>  <em>Remark: leiningen allows you to use templates for creating a project, its structure and setting up start-up ‚Äúsettings‚Äù or connecting basic libraries.</em>  <em>For the lazy: you can create a project using one of these templates like this:</em> <em><br> <code>lein new compojure ws-clojure-sample</code> <br></em>  <em>where <a href="https://github.com/weavejester/compojure">compojure</a> is a library for routing (routing) working with Ring.</em>  <em>We will do it manually (our team also implements / uses a template called, default)</em> </p><br><p>  As a result, the project will be generated, having the following structure: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c88/cb0/53d/c88cb053db6ad5d1ffc86acbc17207cd.png" alt="Alt text" title="project structure"></p><br><p>  In the future, to build the project and manage dependencies, <em>leiningen is</em> guided by a file in the project project project root. </p><br><p>  At the moment, he took the following form with us: </p><br><h6 id="projectclj">  project.clj </h6><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">defproject</span></span> ws-clojure-sample <span class="hljs-string"><span class="hljs-string">"0.1.0-SNAPSHOT"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:description</span></span> <span class="hljs-string"><span class="hljs-string">"FIXME: write description"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:url</span></span> <span class="hljs-string"><span class="hljs-string">"http://example.com/FIXME"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:license</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"Eclipse Public License"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:url</span></span> <span class="hljs-string"><span class="hljs-string">"http://www.eclipse.org/legal/epl-v10.html"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:dependencies</span></span> [[org.clojure/clojure <span class="hljs-string"><span class="hljs-string">"1.8.0"</span></span>]])</code> </pre><br><p>  Let's immediately add the dependencies we need to the <em>dependencies</em> section </p><br><p>  <em>Remark: keyword (clojure keyword): dependencies.</em> </p><br><p>  and specify the entry point (namespace) in our application <em>: main</em> </p><br><div class="spoiler">  <b class="spoiler_title">project.clj</b> <div class="spoiler_text"><h6 id="projectclj-1">  project.clj </h6><br><pre> <code class="hljs ruby">(defproject ws-clojure-sample <span class="hljs-string"><span class="hljs-string">"0.1.0-SNAPSHOT"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:description</span></span> <span class="hljs-string"><span class="hljs-string">"FIXME: write description"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:url</span></span> <span class="hljs-string"><span class="hljs-string">"http://example.com/FIXME"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:license</span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:name</span></span> <span class="hljs-string"><span class="hljs-string">"Eclipse Public License"</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:url</span></span> <span class="hljs-string"><span class="hljs-string">"http://www.eclipse.org/legal/epl-v10.html"</span></span>} <span class="hljs-symbol"><span class="hljs-symbol">:dependencies</span></span> [[org.clojure/clojure <span class="hljs-string"><span class="hljs-string">"1.8.0"</span></span>] [http-kit <span class="hljs-string"><span class="hljs-string">"2.2.0"</span></span>] ;;  http-kit [compojure <span class="hljs-string"><span class="hljs-string">"1.6.0"</span></span>] ;;  compojure (/) [ring/ring-defaults <span class="hljs-string"><span class="hljs-string">"0.3.1"</span></span>] ;;   middleware   [org.clojure/data.json <span class="hljs-string"><span class="hljs-string">"0.2.6"</span></span>]] ;;     JSON <span class="hljs-symbol"><span class="hljs-symbol">:profiles</span></span> ;;    lein with-profile &lt; &gt; {<span class="hljs-symbol"><span class="hljs-symbol">:dev</span></span> ;;   {<span class="hljs-symbol"><span class="hljs-symbol">:dependencies</span></span> [[javax.servlet/servlet-api <span class="hljs-string"><span class="hljs-string">"2.5"</span></span>] ;;      ring/ring-core [ring/ring-devel <span class="hljs-string"><span class="hljs-string">"1.6.2"</span></span>]]}} ;;     <span class="hljs-symbol"><span class="hljs-symbol">:main</span></span> ws-clojure-sample.core) ;;       -main(   )</code> </pre> <br><p>  <em>Remark: middleware <a href="https://github.com/ring-clojure/ring-defaults">ring-defaults</a></em> </p></div></div><br><p>  Let's move, actually, to the entry point in the application.  Open the <em>core.clj</em> file </p><br><h6 id="coreclj">  core.clj </h6><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">ns</span></span> ws-clojure-sample.core) (<span class="hljs-name"><span class="hljs-name">defn</span></span> foo <span class="hljs-string"><span class="hljs-string">"I don't do a whole lot."</span></span> [x] (<span class="hljs-name"><span class="hljs-name">println</span></span> x <span class="hljs-string"><span class="hljs-string">"Hello, World!"</span></span>))</code> </pre> <br><p>  and replace the generated function <em>foo</em> with a more understandable and generally accepted -main.  Next, we import the components we need into the current namespace.  Actually, we need, first of all, a server, further routes, and our middleware.  In the role of the server we have the <strong>http-kit</strong> and its <em>run-server</em> function. </p><br><div class="spoiler">  <b class="spoiler_title">core.clj</b> <div class="spoiler_text"><h6 id="coreclj-1">  core.clj </h6><br><pre> <code class="hljs pgsql">(ns ws-clojure-sample.core (:require [org.httpkit.<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> :refer [run-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>]] ;; http-kit <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> [compojure.core :refer [defroutes <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> POST <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>]] ;; defroutes,   [compojure.route :refer [resources files <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">found</span></span>]] ;;   ,    <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">found</span></span> [ring.middleware.defaults :refer :<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>])) ;; middleware</code> </pre> <br><p>  <em>Remark: this code is a completely valid Clojure code, and at the same time data structures of the language itself.</em>  <em>This property of the language is called <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE%25D0%25BC%25D0%25BE%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25BD%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C"><strong>homoiconical</strong></a></em> <em><br></em>  <em>Reading, in my opinion, is also simple, and does not require special explanations.</em> </p></div></div><br><p>  The server, as an argument, must pass the handler function and server parameters to the function <br>  like that: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">run-server</span></span> &lt;(<span class="hljs-name"><span class="hljs-name">handler</span></span>)&gt; {<span class="hljs-symbol"><span class="hljs-symbol">:port</span></span> <span class="hljs-number"><span class="hljs-number">5000</span></span>})</code> </pre> <br><p>  This handler will be a function (actually a macro) of the router <em>defroutes to</em> which we will give a name, and which in turn will call, immediately depending on the route, the immediate handler.  And all this we can still wrap up and spice up our middleware. <br>  <em>Remark: middleware behaves like a query <strong>decorator</strong></em> . </p><br><div class="spoiler">  <b class="spoiler_title">core.clj</b> <div class="spoiler_text"><h6 id="coreclj-2">  core.clj </h6><br><pre> <code class="hljs pgsql">(ns ws-clojure-sample.core (:require [org.httpkit.<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> :refer [run-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span>]] ;; http-kit <span class="hljs-keyword"><span class="hljs-keyword">server</span></span> [compojure.core :refer [defroutes <span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> POST <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANY</span></span>]] ;; defroutes,   [compojure.route :refer [resources files <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">found</span></span>]] ;;   ,  <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">found</span></span> [ring.middleware.defaults :refer :<span class="hljs-keyword"><span class="hljs-keyword">all</span></span>])) ;; middleware (defroutes app-routes (<span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> "/" [] <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>-page) ;;        (<span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> "/ws" [] ws-<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) ;;   "" -. . (resources "/") ;;   (files "/static/") ;;       `<span class="hljs-built_in"><span class="hljs-built_in">public</span></span>` (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">found</span></span> "&lt;h3&gt;  &lt;/h3&gt;")) ;;  ,  <span class="hljs-number"><span class="hljs-number">404</span></span>) (defn -main "   " [] (run-<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> (wrap-defaults #<span class="hljs-string"><span class="hljs-string">'app-routes site-defaults) {:port 5000}))</span></span></code> </pre> </div></div><br><p>  So now we have an entry point to the application that starts the server that has the routing.  We lack here two functions of request handlers: </p><br><ul><li>  index-page </li><li>  ws-handler </li></ul><br><p>  Let's start with the <em>index-page</em> . </p><br><p>  To do this, in the <code>ws_clojure_sample</code> directory <code>ws_clojure_sample</code> create a <code>views</code> folder and in it an <code>index.clj</code> file.  We specify the resulting namespace, <br>  and create our <em>index-page header page</em> : </p><br><h6 id="viewsindexclj">  views / indexclj </h6><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">ns</span></span> ws-clojure-sample.views.index) (<span class="hljs-name"><span class="hljs-name">def</span></span> index-page <span class="hljs-string"><span class="hljs-string">""</span></span>)</code> </pre> <br><p><del>  On this one could finish </del>  .  In fact, here you can set a regular HTML page in a string.  But it is ugly.  What are the options?  It would be nice to use any template engine at all.  No problems.  For example, you can use <a href="https://github.com/yogthos/Selmer">Selmer</a> .  This is a fast template engine, inspired by the Django template engine.  In this case, the views will differ little from those in the <em>Django</em> project.  <em>Twig</em> fans, or <em>Blade,</em> too, will be familiar. </p><br><p>  I will go the other way, and choose Clojure.  I will write HTML on <em>Clojure</em> .  What does this mean - now we will see. </p><br><p>  For this we need a small (this applies to most <em>Clojure</em> libraries) <strong><em>hiccup</em></strong> library.  In the <code>project.clj</code> file in <code>:dependencies</code> add <code>[hiccup "1.0.5"]</code> . </p><br><p>  <em>Remark: by the way, the author of the <strong>compojure</strong> and <strong>hiccup libraries</strong> , and many other key libraries in the Clojure ecosystem, is the same, his name is James Reeves, for which he thanks a lot.</em> </p><br><p>  After we add the dependency to the project, we need to import its contents into the namespace of our view <code>src/ws_clojure_sample/views/index.clj</code> and write our HTML code.  In order to speed up the process, I immediately bring the contents of <code>views/index.clj</code> entirely <br>  (and you <del>  wonder what is it </del>  watch): </p><br><div class="spoiler">  <b class="spoiler_title">views / indexclj</b> <div class="spoiler_text"><h6 id="viewsindexclj-1">  views / indexclj </h6><br><pre> <code class="hljs pgsql">(ns ws-clojure-sample.views.<span class="hljs-keyword"><span class="hljs-keyword">index</span></span> (:use [hiccup.page :<span class="hljs-keyword"><span class="hljs-keyword">only</span></span> (html5 <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>-css <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>-js)])) ;;    hiccup     ;; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> page (def <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>-page (html5 [:head (<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>-css "https://unpkg.com/bootstrap@3.3.7/dist/css/bootstrap.min.css")] [:body {:style "padding-top: 50px;"} [:div.container [:div.form-<span class="hljs-keyword"><span class="hljs-keyword">group</span></span> [:<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>#message.form-control {:<span class="hljs-type"><span class="hljs-type">name</span></span> "message" :<span class="hljs-keyword"><span class="hljs-keyword">type</span></span> "text"}]] [:button.btn.btn-<span class="hljs-keyword"><span class="hljs-keyword">primary</span></span> {:<span class="hljs-type"><span class="hljs-type">name</span></span> "send-btn"} "Send"]] [:hr] [:div.container [:div#chat]] (<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>-js "js/ws-client.js") (<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>-js "https://unpkg.com/jquery@3.2.1/dist/jquery.min.js") (<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>-js "https://unpkg.com/bootstrap@3.3.7/dist/js/bootstrap.min.js")]))</code> </pre> </div></div><br><p>  Our presentation is ready, and I think does not need comments.  We created the usual <code>&lt;input name="message" type="text"/&gt;</code> and the <code>Send</code> button.  With this simple form we will send messages to <del>  chat </del>  channel.  It remains to remember to import the <code>index-page</code> into the <code>core</code> namespace.  To do this, go back to <code>src/ws_clojure_sample/core.clj</code> and <code>src/ws_clojure_sample/core.clj</code> directive <code>:require</code> line <code>[ws-clojure-sample.views.index :refer [index-page]]</code> . <br>  At the same time, let's write the main handler <code>ws-handler</code> , which we need to create next. </p><br><div class="spoiler">  <b class="spoiler_title">core.clj</b> <div class="spoiler_text"><h6 id="coreclj-3">  core.clj </h6><br><pre> <code class="hljs sql">... [ws-clojure-sample.views.index :refer [index-page]] ;;   index-page [ws-clojure-sample.handler :refer [ws-<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>]])) ;;   ws-<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> (defroutes app-routes (<span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> <span class="hljs-string"><span class="hljs-string">"/"</span></span> [] <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>-page) (<span class="hljs-keyword"><span class="hljs-keyword">GET</span></span> <span class="hljs-string"><span class="hljs-string">"/ws"</span></span> [] ws-<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) ;;  handler.clj</code> </pre> </div></div><br><p>  Most of the methods and abstractions for working with web sockets / long-polling / stream are provided by our <strong>http-kit</strong> server, possible examples and variations are easily found on the library's website.  In order not to make a fuss, I took one of such examples and simplified it a bit.  Create the <code>src/ws_clojure_sample/handler.clj</code> , set the namespace and import the <code>with-channel, on-receive, on-close</code> <em>methods</em> from the <em>htpp-kit</em> : </p><br><div class="spoiler">  <b class="spoiler_title">handler.clj</b> <div class="spoiler_text"><h6 id="handlerclj">  handler.clj </h6><br><pre> <code class="hljs pgsql">(ns ws-clojure-sample.<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> (:require [org.httpkit.<span class="hljs-keyword"><span class="hljs-keyword">server</span></span> :refer [<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-channel <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-receive <span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">close</span></span>]] ;;   http-kit [ws-clojure-sample.receiver :refer [receiver clients]])) ;;   ;;   (<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>) (defn ws-<span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> "Main WebSocket handler" [request] ;;   (<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-channel request channel ;;   (swap! clients assoc channel <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) ;;          clients    <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> (println channel "Connection established") (<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">close</span></span> channel (fn [status] (println "channel closed: " status))) ;;      (<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-receive channel (<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> receiver :chat)))) ;;      (  )</code> </pre> <br><ul><li> <code>swap! clients</code>  <code>swap! clients</code> - changes the state of the clients atom, writes there the channel identifier as the key and the flag as the value.  Let's set further. </li><li>  <code>with-channel</code> - gets channel </li><li>  <code>on-close</code> - Sets a handler when closing a channel </li><li>  <code>on-receive</code> - Installs the data handler from the channel <code>(get receiver :chat)</code> - this is what we will have to do. </li></ul></div></div><br><p>  Let's define a handler to receive data from the <code>on-receive</code> channel and our <code>clients</code> .  Create <code>src/ws_clojure_sample/receiver.clj</code> , as usual, we specify our namespace. </p><br><h6 id="receiverclj">  receiver.clj </h6><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">ns</span></span> ws-clojure-sample.receiver) (<span class="hljs-name"><span class="hljs-name">def</span></span> clients (<span class="hljs-name"><span class="hljs-name">atom</span></span> {})) <span class="hljs-comment"><span class="hljs-comment">;;  </span></span></code> </pre> <br><p>  Since we need a visual example, and there can be several handlers, first I will show by the example of a chat, and call it <code>chat-receiver</code> . </p><br><pre> <code class="hljs perl">(defn chat-receiver) [data] ;;   (     *input*) (dose<span class="hljs-string"><span class="hljs-string">q [client (keys @clients)]</span></span> ;;   (        alias client) (<span class="hljs-keyword"><span class="hljs-keyword">send</span></span>! client (json/<span class="hljs-keyword"><span class="hljs-keyword">write</span></span>-str {:key <span class="hljs-string"><span class="hljs-string">"chat"</span></span> :data data}))) ;;  json-   <span class="hljs-string"><span class="hljs-string">"chat"</span></span>   <span class="hljs-string"><span class="hljs-string">"data"</span></span>    </code> </pre> <br><p> <code>send!</code>  and <code>json/write-str</code> must be imported into the current namespace. </p><br><h6 id="receiverclj-1">  receiver.clj </h6><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">ns</span></span> ws-clojure-sample.receiver (<span class="hljs-symbol"><span class="hljs-symbol">:require</span></span> [clojure.data.json <span class="hljs-symbol"><span class="hljs-symbol">:as</span></span> json] [org.httpkit.server <span class="hljs-symbol"><span class="hljs-symbol">:refer</span></span> [send!]]))</code> </pre> <br><p>  What if we don't want a chat?  Or not just chat, but for example, to receive data from an external source and send it to sockets?  I came up with a keeper of handlers, well, oh, very complicated. </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> receiver {<span class="hljs-symbol"><span class="hljs-symbol">:chat</span></span> chat-receiver})</code> </pre> <br><p>  For example, I made such a "receiver" for sending and receiving data so that you can play not only with the chat, so we will add an example <code>data-receiver</code> to the handler keeper.  Let it be. </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> receiver {<span class="hljs-symbol"><span class="hljs-symbol">:chat</span></span> chat-receiver <span class="hljs-symbol"><span class="hljs-symbol">:data</span></span> data-receiver})</code> </pre> <br><p>  Just give his code: </p><br><div class="spoiler">  <b class="spoiler_title">data-receiver</b> <div class="spoiler_text"><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">def</span></span> urls [<span class="hljs-string"><span class="hljs-string">"https://now.httpbin.org"</span></span> <span class="hljs-string"><span class="hljs-string">"https://httpbin.org/ip"</span></span> <span class="hljs-string"><span class="hljs-string">"https://httpbin.org/stream/2"</span></span>]) (<span class="hljs-name"><span class="hljs-name">defn</span></span> data-receiver <span class="hljs-string"><span class="hljs-string">"Data receiver"</span></span> [data] (<span class="hljs-name"><span class="hljs-name">let</span></span> [responses (<span class="hljs-name"><span class="hljs-name">map</span></span> #(<span class="hljs-name"><span class="hljs-name">future</span></span> (<span class="hljs-name"><span class="hljs-name">slurp</span></span> %)) urls)] <span class="hljs-comment"><span class="hljs-comment">;;   (  )   urls (doall (map (fn [resp] ;;     (doseq [client (keys @clients)] ;;    - (send! client @resp))) responses)))) ;;      -</span></span></code> </pre> </div></div><br><p>  Now we can choose which of them to run when receiving data from the channel, and how the application will work, just by changing the key: </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">on-receive</span></span> channel (<span class="hljs-name"><span class="hljs-name">get</span></span> receiver <span class="hljs-symbol"><span class="hljs-symbol">:chat</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:data</span></span>)) <span class="hljs-comment"><span class="hljs-comment">;;     :data    ,    :chat   .</span></span></code> </pre> <br><p>  With server part everything. </p><br><p>  Remained client.  And on the client, in the presentation code, you suddenly noticed how I connected the file <code>ws-client.js</code> which lives in the <code>resources/public/js/ws-client.js</code> </p><br><pre> <code class="hljs lisp">(<span class="hljs-name"><span class="hljs-name">include-js</span></span> <span class="hljs-string"><span class="hljs-string">"js/ws-client.js"</span></span>)</code> </pre> <br><p>  It is he who is responsible for the client part.  Since this is plain javascript, I‚Äôll just provide the code. </p><br><p>  <em>Remark: I can not help but note that the client code, instead of javascript, could be written in Clojure.</em>  <em>More specifically, ClojureScript.</em>  <em>If you go further, you can do the frontend, for example, using <a href="https://reagent-project.github.io/">Reagent</a> .</em> </p><br><div class="spoiler">  <b class="spoiler_title">ws-client.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> msg = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'message'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> btn = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByName(<span class="hljs-string"><span class="hljs-string">'send-btn'</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> chat = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'chat'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> sendMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Sending...'</span></span>); socket.send(msg.value); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WebSocket(<span class="hljs-string"><span class="hljs-string">'ws://localhost:5000/ws?foo=clojure'</span></span>); msg.addEventListener(<span class="hljs-string"><span class="hljs-string">"keyup"</span></span>, (event) =&gt; { event.preventDefault(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.keyCode == <span class="hljs-number"><span class="hljs-number">13</span></span>) { sendMessage(); } }); btn.onclick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> sendMessage(); socket.onopen = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Connection established...'</span></span>); socket.onmessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> response = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(event.data); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.key == <span class="hljs-string"><span class="hljs-string">'chat'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'p'</span></span>); p.innerHTML = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().toLocaleString() + <span class="hljs-string"><span class="hljs-string">": "</span></span> + response.data; chat.appendChild(p); } } socket.onclose = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.wasClean) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Connection closed. Clean exit.'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${event.code}</span></span></span><span class="hljs-string">, Reason: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${event.reason}</span></span></span><span class="hljs-string">`</span></span>); } } socket.onerror = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`Error: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${event.message}</span></span></span><span class="hljs-string">`</span></span>); socket.close(); }</code> </pre> </div></div><br><p>  If you run this code from the project root using <em>leiningen</em> with the <code>lein run</code> command, <br>  the project should compile, and if you go to <a href="http://localhost:5000/">http: // localhost: 5000</a> , you can see <br>  the same <code>&lt;input&gt;</code> and the <code>Send</code> button.  If you open two such tabs and send a message in each, you can make sure that the simplest chat works.  When closing a tab, our <code>on-close</code> method works.  Similarly, you can play with the data.  They should simply be displayed in the browser in the console. </p><br><p>  The result was a simple, minimalist application (62 lines of code along with imports), giving an idea of ‚Äã‚Äãhow to write web applications in the modern Lisp dialect, while you can easily write asynchronous code, parallelize tasks and use light, modern, simple solutions web. <del>  And all this is done by my 62 poor lines of code! </del></p><br><div class="spoiler">  <b class="spoiler_title">Goodbye interesting fact</b> <div class="spoiler_text"><p>  <em>Good-bye is an interesting fact: I don‚Äôt know whether you paid attention, but when libraries were connected to a clojure project, most of them have ‚Äúlow‚Äù versioning, which is so unusual for good stable projects, for example <code>[ring/ring-defaults "0.3.1"]</code> or <code>[org.clojure/data.json "0.2.6"]</code> .</em>  <em>Moreover, both libraries are used almost everywhere.</em>  <em>But for the Clojure ecosystem, such versioning is quite commonplace.</em>  <em>This is primarily due to the high stability of the code written in Clojure.</em>  <em>Believe it, as they say, you want not.</em> </p></div></div><br><p>  And a little more about the http-kit: </p><br><p>  http-kit is not only a server, the library also provides the http-client API.  Both the client and the server are easy to use, minimalist, and at the same time they have good capabilities ( <a href="http-kit.html">600k concurrent HTTP connections, with Clojure &amp; http-kit</a> ). </p><br><p>  All application code <del>  the giant </del>  available on <a href="https://github.com/lensgolda/ws-clojure-sample">github</a> . </p><br><p>  If you have questions - write, I will try to answer to the best of my modest knowledge.  I accept comments, suggestions. </p><br><p>  Thanks for attention! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/339628/">https://habr.com/ru/post/339628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339616/index.html">At the bottom: what threatens underwater internet cables</a></li>
<li><a href="../339618/index.html">Aftertaste from Kotlin, part 3. Korutiny - we divide the processor time</a></li>
<li><a href="../339620/index.html">What to do if Instagram did not give access to the API? Addition</a></li>
<li><a href="../339624/index.html">10 famous logos drawn from memory</a></li>
<li><a href="../339626/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ283 (October 2 - 8, 2017)</a></li>
<li><a href="../339630/index.html">PHP Digest number 118 - the latest news, materials and tools (September 24 - October 9, 2017)</a></li>
<li><a href="../339636/index.html">Kali Linux: Types of Information Systems Checks</a></li>
<li><a href="../339638/index.html">Alice. How Yandex teaches artificial intelligence to talk to people</a></li>
<li><a href="../339640/index.html">ICO's birth defect: how tokens threaten the future of projects financed by them</a></li>
<li><a href="../339642/index.html">Search for files by tags in XMP / IPTC and operations with the found</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>