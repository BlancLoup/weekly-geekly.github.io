<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Windows runtime. CLR type system and interaction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the release of Windows 8, a new class library, Windows Runtime, has become available to developers. WinRT components can be used in Windows Store...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Windows runtime. CLR type system and interaction</h1><div class="post__text post__text-html js-mediator-article">  With the release of Windows 8, a new class library, Windows Runtime, has become available to developers.  WinRT components can be used in Windows Store and <a href="http://software.intel.com/ru-ru/articles/using-winrt-apis-from-desktop-applications">desktop applications</a> ;  in unmanaged C / C ++ code, in JavaScript, as well as in C # and Visual Basic. <br><br><h5>  Windows Runtime Metadata </h5><br>  Internally, WinRT components are COM (Component Object Model) components, which now use metadata to describe their APIs.  These metadata are stored in files with the * .winmd extension and represent an updated version of .NET metadata that is encoded in accordance with the rules of Section 2 (Metadata Definition and Semantics) of the <a href="http://www.ecma-international.org/publications/standards/Ecma-335.htm">ECMA-335</a> standard.  Since the usual .NET Framework assemblies are encoded using the same standard, it means that you can use familiar tools (such as <a href="http://msdn.microsoft.com/ru-ru/library/f7dy01k1(v%3Dvs.110).aspx">ildasm.exe</a> , the Object Browser) to view the contents of these files. <br>  For the most part, viewing the WinMD file using the <a href="http://msdn.microsoft.com/ru-ru/library/f7dy01k1(v%3Dvs.110).aspx">ildasm.exe</a> utility is very similar to viewing a standard managed assembly.  There are several differences that can be seen - first of all, that the WinMD files, in general, do not contain any Intermediate Language (IL) instructions.  Instead, these files describe the API provided by the Windows Runtime.  The implementation of these interfaces can be completely separated from their definition, and in essence, can be written in native code.  However, for developers of managed applications, the details of the WinRT API implementation are irrelevant, because managed code must see only the API definitions it calls.  Behind the scenes, the Common Language Runtime (CLR) and the Windows operating system connect API definitions and implementations for you. <br><a name="habracut"></a><br>  For example, in the Windows.Foundation.winmd metadata file (located in the% WinDir% \ System32 \ WinMetadata directory) you can find the following type of <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.foundation.collections.propertyset.aspx">Windows.Foundation.Collections.PropertySet</a> , whose constructor does not contain a body, because the type is implemented in the native code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/975/52e/7c397552ed27285f893c6d76ad5e65f1.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      However, the metadata that describes this type allows the CLR to get an instance of an implementation when calling a class constructor. <br>  When viewing the Windows Runtime metadata, you can also notice that the type and assembly definitions use the new WindowsRuntime keyword. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b8b/602/919/b8b602919fe94372b2458c98c3fd1792.png" alt="image"><br><br>  This keyword is context-sensitive and is interpreted differently depending on where it is applied.  For example, if a keyword marks a type definition (TypeDef), then this type is subject to the rules of the Windows Runtime type system and a call of this type should be treated as a call to the WinRT API. <br><br><h5>  CLR interaction with WinRT components </h5><br>  CRL supports interaction with COM components via <a href="http://msdn.microsoft.com/en-us/library/8bwh56xe(v%3Dvs.110).aspx">Callable Wrapper (RCW)</a> and <a href="http://msdn.microsoft.com/en-us/library/f07c8z1c(v%3Dvs.110).aspx">COM Callable Wrapper (CCW) wrappers</a> .  Thus, in the CLR, the reference to the WinRT object is a reference to the <a href="http://msdn.microsoft.com/en-us/library/8bwh56xe(v%3Dvs.110).aspx">RCW</a> , which in turn contains a reference to the WinRT object.  Accordingly, the managed code interacts with the <a href="http://msdn.microsoft.com/en-us/library/8bwh56xe(v%3Dvs.110).aspx">RCW</a> , which is essentially the interface between your code and the WinRT object. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce3/b2b/ea9/ce3b2bea9119e9dd451db603c8b6feed.png" alt="image"><br><br>  Similarly, in the Windows Runtime, a CLR object reference is a reference to a <a href="http://msdn.microsoft.com/en-us/library/f07c8z1c(v%3Dvs.110).aspx">CCW</a> , which in turn contains a reference to a CLR object.  The Windows Runtime then interacts with the <a href="http://msdn.microsoft.com/en-us/library/f07c8z1c(v%3Dvs.110).aspx">CCW</a> to access the functionality of the managed object. <br><br><h5>  WinRT types and managed code </h5><br>  Despite the fact that the Windows Runtime type system is similar to the CLR type system, you can notice that some of the types used in the API definitions do not match the types used in managed code.  In order for .NET developers to create applications using familiar technologies, the CLR hides some types of WinRT and provides access to them through others.  In general, there are three types of types in Windows Runtime and some of them look different in managed code: <br><ul><li>  <b>Basic data types</b> that are encoded in metadata using the same <a href="http://msdn.microsoft.com/ru-ru/library/ms232600(v%3Dvs.110).aspx">ELEMENT_TYPE</a> enumeration as in the managed assemblies.  The exception is <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.sbyte.aspx">SByte</a> , which is not supported in WinRT. </li><li>  <b>Projected types (mapped types)</b> , which are encoded in WinMD files as one type, but appear in managed code as their .NET equivalents.  For example, when the CLR reads the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/windows.foundation.uri.aspx">Windows.Foundation.Uri</a> type in the metadata, it uses the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.uri.aspx">System.Uri</a> type instead.  That is, the CLR hides the WinRT type and provides access to it through another type.  In addition, the CLR marshals the type between managed and unmanaged code, which allows you to transfer the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.uri.aspx">System.Uri</a> object to the Windows Runtime as <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/windows.foundation.uri.aspx">Windows.Foundation.Uri</a> .  A complete list of WinRT types that CLR projects on FCL types can be found <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh995050.aspx">here</a> . </li><li>  <b>All other types</b> .  The vast majority of WinRT API types are provided to .NET developers as is.  For example, if you use the <a href="http://msdn.microsoft.com/ru-RU/library/windows/apps/windows.ui.xaml.controls.button">Windows.UI.Xaml.Controls.Button</a> class, the CLR does not provide a special view or marshaling of this type.  Types for which the CLR provides extension methods are also included in this category.  For example, to use an object that implements the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/windows.storage.streams.iinputstream.aspx">Windows.Storage.IInputStream</a> WinRT interface, with a .NET Framework class that needs a type derived from <a href="http://msdn.microsoft.com/ru-ru/library/system.io.stream(v%3Dvs.110).aspx">System.IO.Stream</a> , you should use extension methods that are defined in the <a href="http://msdn.microsoft.com/en-us/library/system.io.windowsruntimestreamextensions(v%3Dvs.110).aspx">System.IO.WindowsRuntimeStreamExtensions</a> class of the System assembly. Runtime.WindowsRuntime.dll. </li></ul><br>  Interestingly, there is still a small category of types that appear in irrelevant places in the Windows metadata encodings.  These are the .NET Framework types, which are used simply to describe the WinRT types.  For example, the delegates of the Windows Runtime are encoded with the base <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.multicastdelegate.aspx">System.MulticastDelegate</a> type, but this does not mean that all the delegates of the Windows Runtime are derived from managed code.  Instead, the base type is simply used as a metadata marker to indicate that the type is a delegate type. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/56f/2ec/1e6/56f2ec1e6f54dbe393a004194b88e283.png" alt="image"><br><br><h5>  Projection Types </h5><br>  When the CLR projects (maps) WinRT types, it does two things: <br><ul><li>  The CLR defines the Windows Runtime type as private, not public.  This prevents the original type from being visible to the managed code.  Those.  in terms of managed code, the only type that exists is the .NET Framework type, which is the target of the mapping. </li><li>  All references to the source type are converted to references to the target .NET Framework type. </li></ul><br>  Thus, the CLR presents the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/br206631.aspx">IVector &lt;T&gt;</a> interface as an <a href="http://msdn.microsoft.com/ru-ru/library/5y536ey6(v%3Dvs.110).aspx">IList &lt;T&gt;</a> , the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/br206631.aspx">IVR</a> type definition of the CLR is considered as a type definition with a private scope, rather than a public one.  Similarly, the <a href="http://msdn.microsoft.com/ru-RU/library/windows/apps/windows.ui.xaml.controls.uielementcollection">Windows.UI.Xaml.Controls.UIElementCollection</a> type that implements the IVector &lt;UIElement&gt; has been updated by the CLR.  The <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/br206631.aspx">IVector &lt;T&gt;</a> interface implementation is redirected to the <a href="http://msdn.microsoft.com/ru-ru/library/5y536ey6(v%3Dvs.110).aspx">IList &lt;T&gt;</a> so that the <a href="http://msdn.microsoft.com/ru-RU/library/windows/apps/windows.ui.xaml.controls.uielementcollection">UIElementCollection</a> in the managed code implements the IList &lt;UIElement&gt; interface. <br>  Usually <a href="http://msdn.microsoft.com/ru-ru/library/f7dy01k1(v%3Dvs.110).aspx">ildasm.exe</a> shows the raw view of the WinMD file without including any redirects.  To view the contents of a WinMD file with redirections enabled, you must specify the / project parameter.  This option allows you to see how the CLR displays the metadata on disk. <br><br><h5>  Base type </h5><br>  The WinRT components do not have a common base class, but all Windows runtime classes must implement the <a href="http://msdn.microsoft.com/en-us/library/br205821(v%3Dvs.85).aspx">IInspectable</a> interface, which in turn inherits from the <a href="http://msdn.microsoft.com/en-us/library/ms680509(v%3Dvs.85).aspx">IUnknown</a> interface (which is not surprising).  However, for .NET developers, all WinRT types look like types derived from <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.object.aspx">System.Object</a> and, accordingly, inherit methods such as <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/bsc2ak47.aspx">Equals</a> , <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.object.gethashcode.aspx">GetHashCode</a> , etc.  This is made possible by the fact that the CLR marshals objects at runtime to convert types between WinRT and .NET views. <br><br><h5>  Structures </h5><br>  The WinRT structures, in contrast to the significant CLR types, can contain only open fields of one of the basic types or they can be another WinRT structure.  Thus, the following code will generate an error at compile time: <br><br><pre><code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> struct MyStruct { // <span class="hljs-string"><span class="hljs-string">'MyStruct'</span></span> contains non-<span class="hljs-built_in"><span class="hljs-built_in">public</span></span> field <span class="hljs-string"><span class="hljs-string">'MyStruct.i'</span></span>. // Windows Runtime structures can contain <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> fields. private Int32 i; //Windows Runtime structures can contain <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> fields. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> MyStruct(Int32 i) { this.i = i; } //Windows Runtime structures can contain <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> fields. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> MyFunc() { } }</code> </pre> <br>  In addition, WinRT structures cannot define constructors or contain helper methods.  However, some CLR structures, for convenience, project on their own, thereby providing developers with helper methods and constructors.  These include, for example, the structure of <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.foundation.point.aspx">Windows.Foundation.Point</a> , <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.foundation.size.aspx">Windows.Foundation.Size</a> and <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.foundation.rect.aspx">Windows.Foundation.Rect</a> . <br><br><h5>  Strings </h5><br>  The <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.string.aspx">System.String</a> type in WinRT is represented as <a href="http://msdn.microsoft.com/en-us/library/br205775(v%3Dvs.85).aspx">HSTRING</a> .  When you call a Windows runtime method, the CLR converts any .NET Framework string to <a href="http://msdn.microsoft.com/en-us/library/br205775(v%3Dvs.85).aspx">HSTRING</a> before calling the method.  Similarly, the CLR converts any strings returned from the runtime method to the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.string.aspx">System.String</a> type.  There is one more feature - the WinRT type system does not allow strings to be null.  Instead of null, use <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.string.empty.aspx">String.Empty</a> to pass in an empty string.  When trying to pass null as a string in the WinRT function, the CLR will throw an <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.argumentnullexception.aspx">ArgumentNullException</a> .  In the same way, you will never see that the WinRT function can return a null string; this can only be an empty string. <br><br><h5>  Null compatible types </h5><br>  The WinRT API uses the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/br225864.aspx">Windows.Foundation.IReference &lt;T&gt;</a> interface to define a null-compatible meaningful type, which the CLR projects onto its own <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/b3h38hb0.aspx">System.Nullable &lt;T&gt;</a> .  For example, if a method in the WinMD file has the following signature: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">IReference&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReference&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; i</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  then in managed code, this method will look like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-function">Nullable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Nullable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; i</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><br><h5>  Delegates </h5><br>  Only WinRT compatible types can be used as the parameter type or return value of a WinRT delegate.  Also, delegates with a global (public) scope cannot be declared as nested (in fact, these are general rules for the Windows runtime as a whole).  When you pass a delegate object to the Windows Runtime component, the object is wrapped in a <a href="http://msdn.microsoft.com/en-us/library/f07c8z1c(v%3Dvs.110).aspx">CCW</a> wrapper, which is not destroyed by the garbage collector until it is released by the component that uses it.  Another interesting fact is that the WinRT delegates do not have the BeginInvoke and EndInvoke methods. <br><br><h5>  Developments </h5><br>  WinRT components can define events using only WinRT delegate types.  There is a <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/br206577.aspx">Windows.Foundation.EventHandler &lt;T&gt;</a> delegate type that the CLR projects to the .NET Framework <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/db0etb8x.aspx">System.EventHandler &lt;TEventArgs&gt;</a> delegate type.  When you define a member event: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> EventHandler&lt;RoutedEventArgs&gt; MyEvent;</code> </pre><br>  then when compiling this line of code, the compiler turns it into the following instructions: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> EventRegistrationTokenTable&lt;EventHandler&lt;RoutedEventArgs&gt;&gt; MyEvent; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> EventRegistrationToken </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_MyEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventHandler&lt;RoutedEventArgs&gt; handler</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EventRegistrationTokenTable&lt;EventHandler&lt;RoutedEventArgs&gt;&gt; .GetOrCreateEventRegistrationTokenTable(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> MyEvent) .AddEventHandler(handler); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove_MyEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventRegistrationToken token</span></span></span><span class="hljs-function">)</span></span> { EventRegistrationTokenTable&lt;EventHandler&lt;RoutedEventArgs&gt;&gt; .GetOrCreateEventRegistrationTokenTable(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> MyEvent) .RemoveEventHandler(token); }</code> </pre><br>  As before, the compiler creates a private field and two accessor methods for registering and not subscribing to an event.  However, the type of the field and the content of these methods differ from what we are used to ( <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/b1eh4771.aspx">Delegate.Combine</a> and <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.delegate.remove.aspx">Delegate.Remove</a> ).  The field type is a generic <a href="http://msdn.microsoft.com/ru-ru/library/hh138412(v%3Dvs.110).aspx">EventRegistrationTokenTable &lt;T&gt;</a> class, whose type argument is the corresponding delegate type.  This class is responsible for storing the chain of delegates that represent event handlers.  When adding a new handler, the <a href="http://msdn.microsoft.com/ru-ru/library/system.runtime.interopservices.windowsruntime.eventregistrationtoken(v%3Dvs.110).aspx">EventRegistrationToken</a> token is <a href="http://msdn.microsoft.com/ru-ru/library/system.runtime.interopservices.windowsruntime.eventregistrationtoken(v%3Dvs.110).aspx">returned</a> , which can be used later to remove the event handler. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RaiseEvent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = EventRegistrationTokenTable&lt;EventHandler&lt;RoutedEventArgs&gt;&gt; .GetOrCreateEventRegistrationTokenTable(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> MyEvent) .InvocationList; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (list != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) list(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RoutedEventArgs()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myClass = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyClass(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> token = myClass.add_MyEvent(Handler); myClass.RaiseEvent(); myClass.remove_MyEvent(token); myClass.RaiseEvent(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs args</span></span></span><span class="hljs-function">)</span></span> { Debug.WriteLine(<span class="hljs-string"><span class="hljs-string">"event handling"</span></span>); }</code> </pre><br>  In order to raise an event, use the <a href="http://msdn.microsoft.com/ru-ru/library/hh138465(v%3Dvs.110).aspx">InvocationList</a> property, which returns a delegate whose call list includes all delegates added as event handlers. <br><br><h5>  Time and date </h5><br>  In WinRT, time and date are represented in UTC by the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/windows.foundation.datetime">Windows.Foundation.DateTime</a> structure.  The CLR projects this type on the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.datetimeoffset.aspx">System.DateTimeOffset</a> structure, not on <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.datetime.aspx">System.DateTime</a> .  It is worth noting that <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/windows.foundation.datetime">DateTime</a> does not contain information about the time zone.  Therefore, the date and time returned by the WinRT functions in UTC format, the CLR converts to local time.  Conversely, when the <a href="http://msdn.microsoft.com/ru-ru/library/windows/apps/system.datetimeoffset.aspx">DateTimeOffset</a> structure is transferred to the WinRT function, the date and time are converted to the UTC format. <br><br><h5>  Arrays </h5><br>  WinRT API supports only one-dimensional arrays.  Accordingly, the following code will cause a compile-time error: <br><pre> <code class="hljs pgsql">// Arrays <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Windows Runtime <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> signatures must be one dimensional. <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[,] MyFunc() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span>[<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>]; }</code> </pre><br>  In managed code, arrays are passed by reference, and changes to the elements of the array will be visible to any code that has a reference to an instance of this array.  However, for WinRT this is not always the case, because the contents of the array are marshaled only in the direction that the API defines in its signature using <a href="http://msdn.microsoft.com/ru-ru/library/system.runtime.interopservices.inattribute(v%3Dvs.110).aspx">System.Runtime.InteropServices.InAttribute</a> and <a href="http://msdn.microsoft.com/ru-ru/library/system.runtime.interopservices.outattribute(v%3Dvs.110).aspx">System.Runtime.InteropServices.OutAttribute</a> .  Both attributes apply to method parameters or return values ‚Äã‚Äãand determine the marshaling direction between managed and unmanaged memory at run time.  In the Windows Runtime, parameters can be either read only [InAttribute] or write only [OutAttribute] and cannot be marked for reading and writing at the same time [InAttribute], [OutAttribute].  This means that the contents of the array passed to the method, as well as the array itself, should be designed to be read or written.  So, the contents of the array, which is marked with the [InAttribute] attribute, are copied to the method being called, so all changes that the method applies to the array are not visible to the calling object.  Similarly, the contents of the array, which is marked with the [OutAttribute] attribute, are set by the called method and copied to the caller, so the called method should not make any assumptions about the contents of the original array. <br><br><h5>  Collections </h5><br>  When sending a collection, the CLR wraps the collection object in a <a href="http://msdn.microsoft.com/en-us/library/f07c8z1c(v%3Dvs.110).aspx">CCW</a> wrapper and passes the reference to it to the WinRT API.  In this case, calls through the wrapper intersect the interaction boundary, which negatively affects the performance.  However, unlike arrays, it is possible to perform operations without copying the elements. <br><br><h5>  Conclusion </h5><br>  Summing up, I note that due to changes in the CLR, developers of managed code can easily adapt to the new Windows Runtime API using familiar technologies.  In this article, I described far from all the details of the WinRT and CLR interaction.  However, this can serve as a basis for further study and a deeper understanding of the Windows Runtime. </div><p>Source: <a href="https://habr.com/ru/post/207088/">https://habr.com/ru/post/207088/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207078/index.html">Adopted standard on integrated SIM cards</a></li>
<li><a href="../207080/index.html">Panel sending outgoing faxes using Asterisk and Node.js</a></li>
<li><a href="../207082/index.html">Spanner NewSQL storage from Google</a></li>
<li><a href="../207084/index.html">Socialization TV</a></li>
<li><a href="../207086/index.html">How-to: Transparent NTLM authorization on the corporate portal</a></li>
<li><a href="../207094/index.html">The 3D printer should stand next to the ‚ÄúWhite Swan‚Äù, or about the national characteristics of trademarks.</a></li>
<li><a href="../207096/index.html">Quick selection of random values ‚Äã‚Äãfrom large MySQL tables by condition</a></li>
<li><a href="../207098/index.html">A passion for programming. Chapter 15. Practice, practice, practice</a></li>
<li><a href="../207100/index.html">We put Ubuntu on MacBook pro 11.3 (2013) or vice versa</a></li>
<li><a href="../207102/index.html">Object naming in Oracle. View from the outside"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>