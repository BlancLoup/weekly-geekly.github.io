<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We learn a pig on monoids to believe in yourself and fly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In one of the previous articles, I talked about how to build a program executor for a virtual stack machine using the approaches of functional and lan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We learn a pig on monoids to believe in yourself and fly</h1><div class="post__text post__text-html js-mediator-article"><p>  In <a href="https://habr.com/post/429530/">one</a> of the previous articles, I talked about how to build a program executor for a virtual stack machine using the approaches of functional and language-oriented programming.  The mathematical structure of the language suggested the basic structure for the implementation of its translator, based on the concept of semigroups and monoids.  This approach allowed us to build a beautiful and expandable implementation and thwart the applause, but the very first question from the audience made me get off the podium and climb into Emacs again. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/n2/ln/ne/n2lnneohm_d4rsc-qkw_n4cguyw.png" width="80%"></div><br><p>  I spent a simple test and made sure that on simple tasks using only the stack, the virtual machine works smartly, and when using the ‚Äúmemory‚Äù - an array with random access - big problems start.  How we managed to solve them without changing the basic principles of the program architecture and achieve a thousand-fold acceleration of the program‚Äôs work, and the article will be discussed. </p><a name="habracut"></a><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> * \ * \ * </script></p><br><p>  Haskell is a peculiar language with a special niche.  The main purpose of its creation and development was the need for lingua franca to express and test the ideas of functional programming.  This justifies its brightest features: laziness, utmost purity, emphasis on types and manipulations with them.  It was not designed for everyday development, not for industrial programming, not for widespread use.  The fact that it is really used to create large-scale projects in the network industry and in data processing is the goodwill of developers, proof of concept, if you will.  But so far, the most important, widely used and amazingly powerful product written in Haskell is ... the ghc compiler.  And it is completely justified in terms of its purpose - to be a tool for research in the field of computer science.  The principle proclaimed by Simon Peyton-Johnson: ‚ÄúAvoid success at all costs‚Äù requires the language in order to remain such an instrument.  Haskell is similar to a sterile chamber in the laboratory of a research center that develops semiconductor technology or nanomaterials.  It is terribly inconvenient to work in, and for everyday practice it too restricts freedom of action, but without these inconveniences, without uncompromising adherence to restrictions, it will not be possible to observe and study the subtle effects that will later become the basis of industrial development.  At the same time, in industry, sterility will already be needed only in the most necessary volume, and the results of these experiments will appear in our pockets in the form of gadgets.  We study stars and galaxies not because we expect to receive direct benefits from them, but because on the scale of these impractical objects, quantum and relativistic effects become observable and studied, so much so that later we can use this knowledge to develop something very utilitarian.  So Haskell with its "wrong" lines, impractical laziness of calculations, the rigidity of some type inference algorithms, with an extremely steep entry curve, finally, does not allow you to easily create a smart application on your knee or an operating system.  However, lenses, monads, combinatorial parsing, extensive use of monoids, methods of automatic proof of theorems, declarative functional package managers, linear and dependent types are coming out of this laboratory into the practical world.  It finds application in less sterile conditions in the languages ‚Äã‚Äãof Python, Scala, Kotlin, F #, Rust, and many others.  But I wouldn‚Äôt use any of these wonderful languages ‚Äã‚Äãto teach the principles of functional programming: I would take a student to the lab, show with bright and clean examples how it works, and then you can ‚Äúsee‚Äù these principles in action in the factory big and incomprehensible, but very fast machine.  Avoiding success at any cost is protection against attempts to shove a coffee maker into an electron microscope in order to popularize it.  And in competitions which language is cooler, Haskell will always be outside the usual nominations. </p><br><p>  However, the person is weak, and a demon lives in me too, which urges me to compare, evaluate and protect ‚Äúmy favorite language‚Äù in front of others.  So, having written an elegant implementation of a stack machine based on a monoidal composition, with the sole purpose of seeing whether this is my idea, I was immediately disappointed to find that the implementation works brilliantly, but terribly inefficient!  It‚Äôs as if I‚Äôm really going to use it for serious tasks, or to sell my stack machine on the same market where Python or Java virtual machines are offered.  But, damn it, in the article about the pig with which the whole conversation began, such tasty figures are given: hundreds of milliseconds for the piglet, seconds for Python ... and my beautiful monoid cannot do this task in an hour!  I have to succeed!  My microscope will make an espresso no worse than a coffee machine in the hallway of the institute!  The Crystal Palace can be accelerated and launched into space! </p><br><p>  But what are you ready to sacrifice, the mathematician asks me?  Clean and transparent palace architecture?  The flexibility and extensibility that homomorphisms provide from programs to other solutions?  The demon and the angel are both stubborn, and the wise Taoist, whom I also allow myself to live with, offered to take the path that suits both, and walk along it as long as possible.  However, not to identify the winner, but to know the path itself, find out how far it leads, and get a new experience.  And so I knew the vain sadness and joy of optimization. </p><br><p> Before we begin, let's add that <em>language</em> comparisons in terms of effectiveness are meaningless.  It is necessary to compare translators (interpreters or compilers), or the performance of a programmer using a language.  In the end, the statement that C programs are the fastest is easy to disprove by writing a full-fledged C interpreter on BASIC, for example.  So, we compare not Haskell and javascript, but the performance of the programs executed by the compiler compiled with <code>ghc</code> and the programs executed, say, in a particular browser.  All swine terminology comes from an inspirational <a href="https://habr.com/company/badoo/blog/428878/">article</a> about stack machines.  All Haskell code accompanying the article can be explored in the <a href="https://github.com/samsergey/monopig">repository</a> . </p><br><h3 id="vyhodim-iz-zony-komforta">  We leave from the comfort zone </h3><br><p>  The starting point will be the implementation of a monoidal stack machine in the form of <abbr title="Embedded domain-specific language">EDSL</abbr> - a small simple language that allows combining two dozen primitives to build programs for a virtual stack machine.  If he is in the second article, we <code>monopig</code> give him the name <code>monopig</code> .  Its basis is the fact that languages ‚Äã‚Äãfor stack machines form a <em>monoid</em> with a concatenation operation and an empty operation as a unit.  Accordingly, he himself is built in the form of a monoid transformation of the state of the machine.  The state includes the stack, vector memory (a structure that provides random access to the elements), an emergency stop flag, and a monoid battery for accumulating debug information.  This whole structure is transmitted along the chain of endomorphisms from operation to operation, carrying out the computational process.  From the structure that the programs constitute, an isomorphic structure <em>of the</em> program <em>codes</em> was constructed, and from it the homomorphisms into other useful structures representing the program requirements in terms of the number of arguments and memory.  The final stage of construction was the creation of transformation monoids in the Kleisley category, which allow you to load the calculations into an arbitrary monad.  So the machine has the possibility of input-output and ambiguous calculations.  With this implementation we will begin.  Its code can be found <a href="">here</a> . </p><br><p>  We will test the effectiveness of the program on the naive implementation of the sieve of Eratosthenes, which fills the memory (array) with zeros and ones, denoting primes by zero.  The procedural code of the algorithm is given in <code>javascript</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memSize = <span class="hljs-number"><span class="hljs-number">65536</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; memSize; i++) arr.push(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sieve</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n*n &lt; memSize) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!arr[n]) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k = n; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (k &lt; memSize) { k+=n; arr[k] = <span class="hljs-number"><span class="hljs-number">1</span></span>; } } n++; } }</code> </pre> <br><p>  The algorithm is immediately optimized.  There is no bad striding around already filled memory cells.  My mathematician angel did not agree to a <em>truly</em> naive version of the example in the <code>PorosenokVM</code> project, since this optimization is worth only five instructions of the stack language.  Here‚Äôs how the algorithm translates into <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve</span></span> = push <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;&gt; while (dup &lt;&gt; dup &lt;&gt; mul &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; get &lt;&gt; branch mempty fill &lt;&gt; inc) &lt;&gt; pop fill = dup &lt;&gt; dup &lt;&gt; add &lt;&gt; while (dup &lt;&gt; push memSize &lt;&gt; lt) (dup &lt;&gt; push <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&gt; swap &lt;&gt; put &lt;&gt; exch &lt;&gt; add) &lt;&gt; pop</code> </pre> <br><p>  But how can you write the equivalent implementation of this algorithm on the idiomatic Haskell, using the same types as in <code>monopig</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">sieve'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> sieve' km | k*k &lt; memSize = sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) $ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> m ! k == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> m | otherwise = m fill' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Vector</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> fill' knm | n &lt; memSize = fill' k (n+k) $ m // [(n,<span class="hljs-number"><span class="hljs-number">1</span></span>)] | otherwise = m</code> </pre> <br><p>  It uses the <code>Data.Vector</code> type and tools for working with it, not too ordinary for everyday work in Haskell.  Expression <code>m ! k</code>  <code>m ! k</code> returns the <code>k</code> -th element of the vector <code>m</code> , and <code>m // [(n,1)]</code> sets the element with the number <code>n</code> value 1. I write this here because I had to go after them in the certificate, while I work in Haskell almost every day.  The fact is that structures with random access in the functional implementation are inefficient and for this reason are not popular. </p><br><p>  According to the competition conditions given in the article about the pig, the algorithm is run 100 times.  And in order to get rid of a specific computer, let's compare the speeds of execution of these three programs, attributing them to the performance of the <code>javascript</code> program that was run in Chrome. </p><br><p><img src="https://habrastorage.org/webt/ir/hi/mj/irhimjjtdgec7vw1vduvivmzonm.png"></p><br><p>  Horror-horror !!!  Not only does <code>monopig</code> slow down godlessly, the native version isn't much better either!  Haskell, of course, cool, but not enough to give the program running in the browser?  As coaches teach us, you can't live like this anymore, it's time to leave the comfort zone that Haskell provides us with! </p><br><h3 id="preodolevaem-len">  Overcome laziness </h3><br><p>  Let's figure it out.  To do this, we compile the program on <code>monopig</code> with the <code>-rtsopts</code> flag to keep <code>-rtsopts</code> statistics and see what we should do to get rid of the Eratosthenes sieve once: </p><br><pre> <code class="plaintext hljs">$ ghc -O -rtsopts ./Monopig4.hs [1 of 1] Compiling Main ( Monopig4.hs, Monopig4.o ) Linking Monopig4 ... $ ./Monopig4 -RTS -sstderr "Ok" 68,243,040,608 bytes allocated in the heap 6,471,530,040 bytes copied during GC 2,950,952 bytes maximum residency (30667 sample(s)) 42,264 bytes maximum slop 15 MB total memory in use (7 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 99408 colls, 0 par 2.758s 2.718s 0.0000s 0.0015s Gen 1 30667 colls, 0 par 57.654s 57.777s 0.0019s 0.0133s INIT time 0.000s ( 0.000s elapsed) MUT time 29.008s ( 29.111s elapsed) GC time 60.411s ( 60.495s elapsed) &lt;--   ! EXIT time 0.000s ( 0.000s elapsed) Total time 89.423s ( 89.607s elapsed) %GC time 67.6% (67.5% elapsed) Alloc rate 2,352,591,525 bytes per MUT second Productivity 32.4% of total user, 32.4% of total elapsed</code> </pre> <br><p>  The last line tells us that the program was engaged in productive computing only a third of the time.  All the rest of the time, the garbage collector ran from memory and cleaned up after lazy calculations.  How many times have we been repeated in childhood that it is not good to be lazy!  Here, the main feature of Haskell has done us a disservice in trying to create several billion deferred vector and stack transformations. </p><br><p>  A mathematician angel raises his finger in this place and happily talks about the fact that since Alonzo Church, there is a theorem stating that the computing strategy does not affect their result, which means that we are free to choose from efficiency considerations.  It is quite easy to change calculations to strict ones - we put a mark <code>!</code>  in the declaration of the type of stack and memory and thereby make these fields strict. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">memory</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  We will not change anything else and immediately check the result: </p><br><pre> <code class="plaintext hljs">$ ./Monopig41 +RTS -sstderr "Ok" 68,244,819,008 bytes allocated in the heap 7,386,896 bytes copied during GC 528,088 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 16 MB total memory in use (14 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 129923 colls, 0 par 0.666s 0.654s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.001s 0.001s 0.0006s 0.0007s INIT time 0.000s ( 0.000s elapsed) MUT time 13.029s ( 13.048s elapsed) GC time 0.667s ( 0.655s elapsed) EXIT time 0.001s ( 0.001s elapsed) Total time 13.700s ( 13.704s elapsed) %GC time 4.9% (4.8% elapsed) Alloc rate 5,238,049,412 bytes per MUT second Productivity 95.1% of total user, 95.1% of total elapsed</code> </pre> <br><p>  Productivity has increased significantly.  The total memory costs are still impressive because of the immutability of the data, but most importantly, now that we have limited the laziness of the data, the garbage collector has the opportunity to be lazy, and only 5% of the total work remains.  Record a new entry in the rating. </p><br><p><img src="https://habrastorage.org/webt/6z/z4/6j/6zz46jgmso3w95efydonusy8pok.png"></p><br><p>  Well, well, rigorous calculations brought us closer in speed to the work of the Haskell native code, which shamefully slows down without any virtual machine.  This means that the overhead of using an immutable vector <em>substantially</em> exceeds the cost of maintaining the stack machine.  And that means it's time to say goodbye to the immutability of memory. </p><br><h3 id="vpuskaem-izmeneniya-v-zhizn">  Letting changes in life </h3><br><p>  The <code>Data.Vector</code> type <code>Data.Vector</code> good, but using it we spend a lot of time copying, in the name of keeping the computational process clean.  Replacing it with the type <code>Data.Vector.Unpacked</code> we at least save on the packaging structure, but this does not fundamentally change the picture.  The right decision would be to remove the memory from the state of the machine and provide access to the external vector using the Kleisley category.  In this case, along with pure vectors, you can use the so-called mutable (mutable) vectors <code>Data.Vector.Mutable</code> . </p><br><p>  We will connect the appropriate modules and think about how we deal with variable data in a pure functional program. </p><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Monad.Primitive <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> V <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Vector.Unboxed.Mutable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M</code> </pre> <br><p>  These dirty types are supposed to be isolated from the public.  They are contained in the monads of the <code>PrimMonad</code> class (these include <code>ST</code> or <code>IO</code> ), where clean programs carefully push the instructions to actions written in a crystal functional language on precious parchment.  Thus, the behavior of these unclean animals is determined by strictly orthodox scenarios and is not dangerous.  Not all programs for our machine use memory, so there is no need to condemn the whole architecture to dive into the <code>IO</code> monad.  Along with a pure subset of the <code>monopig</code> language <code>monopig</code> we will create four instructions that provide access to the memory and only they will have access to the dangerous territory. </p><br><p>  The type of clean machine becomes shorter: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stack</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Stack</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">status</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">journal</span></span></span><span class="hljs-class"> :: !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br><p>  The program designers and the programs themselves will hardly notice this change, but their types will change.  In addition, it makes sense to define several types of synonyms to simplify signatures. </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MVector</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PrimState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">m</span></span></span><span class="hljs-class">) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Code</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> a -&gt; m (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VM</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program'</span></span></span><span class="hljs-class"> ma = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Logger</span></span></span><span class="hljs-class"> ma -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Memory</span></span></span><span class="hljs-class"> m -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Program</span></span></span><span class="hljs-class"> ma</span></span></code> </pre> <br><p>  Constructors will have another argument representing memory access.  The executors will change significantly, especially those who are leading the journal of computations, because now they need to ask its state for changeable vector.  The full <a href="">code</a> can be seen and studied in the repository, and here I will give the most interesting thing: the implementation of the basic components for working with memory to show how this is done. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">geti</span></span> :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma geti i = programM (<span class="hljs-type"><span class="hljs-type">GETI</span></span> i) $ \mem -&gt; \s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mem i setStack (x:s) vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> puti :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma puti i = programM (<span class="hljs-type"><span class="hljs-type">PUTI</span></span> i) $ \mem -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (x:s) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> &lt;= i &amp;&amp; i &lt; memSize) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mem ix setStack s vm <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> err <span class="hljs-string"><span class="hljs-string">"index out of range"</span></span> _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> get :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma get = programM (<span class="hljs-type"><span class="hljs-type">GET</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:s) -&gt; \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.read mi setStack (x:s) vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected an element"</span></span> put :: <span class="hljs-type"><span class="hljs-type">PrimMonad</span></span> m =&gt; <span class="hljs-type"><span class="hljs-type">Program'</span></span> ma put = programM (<span class="hljs-type"><span class="hljs-type">PUT</span></span>) $ \m -&gt; \<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (i:x:s) -&gt; \vm -&gt; <span class="hljs-type"><span class="hljs-type">M</span></span>.write mix &gt;&gt; setStack s vm _ -&gt; err <span class="hljs-string"><span class="hljs-string">"expected two elemets"</span></span></code> </pre> <br><p>  The daemon optimizer suggested saving a little more on checking the permissible index values ‚Äã‚Äãin memory, because for the <code>puti</code> and <code>geti</code> indices are known at the program creation stage and incorrect values ‚Äã‚Äãcan be eliminated in advance.  Dynamically defined indexes for the <code>put</code> and <code>get</code> commands do not guarantee security and the angel mathematician did not allow them to make dangerous calls. </p><br><p>  All this fuss with memory deduction in a separate argument seems complicated.  But it very clearly shows the changeable data of their place - <em>they should be outside</em> .  I remind you that we are trying to take the pizza peddler to the sterile laboratory.  Pure functions know what to do with them, but these objects will never become first-class citizens, and cooking pizza right in the laboratory is not worth it. </p><br><p>  Let's check what we bought with these changes: </p><br><pre> <code class="plaintext hljs">$ ./Monopig5 +RTS -sstderr "Ok" 9,169,192,928 bytes allocated in the heap 2,006,680 bytes copied during GC 529,608 bytes maximum residency (2 sample(s)) 25,248 bytes maximum slop 2 MB total memory in use (0 MB lost due to fragmentation) Tot time (elapsed) Avg pause Max pause Gen 0 17693 colls, 0 par 0.094s 0.093s 0.0000s 0.0001s Gen 1 2 colls, 0 par 0.000s 0.000s 0.0002s 0.0003s INIT time 0.000s ( 0.000s elapsed) MUT time 7.228s ( 7.232s elapsed) GC time 0.094s ( 0.093s elapsed) EXIT time 0.000s ( 0.000s elapsed) Total time 7.325s ( 7.326s elapsed) %GC time 1.3% (1.3% elapsed) Alloc rate 1,268,570,828 bytes per MUT second Productivity 98.7% of total user, 98.7% of total elapsed</code> </pre> <br><p>  This is progress!  The memory usage was reduced eight times, the program execution speed increased 180 times, and the garbage collector was left almost completely out of work. </p><br><p><img src="https://habrastorage.org/webt/o7/cw/f8/o7cwf8ptddtz8x1gdy0lunionis.png"></p><br><p>  In the ranking appeared solution <em>monopig st.</em>  <em>mut.</em>  which is ten times slower than a native solution on <code>js</code> , but apart from it, a Haskell native solution using variable vectors.  Here is his code: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fill'</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) fill' knm | n &gt; memSize-k = return m | otherwise = <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeWrite mn <span class="hljs-number"><span class="hljs-number">1</span></span> &gt;&gt; fill' k (n+k) m sieve' :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> (<span class="hljs-type"><span class="hljs-type">Memory</span></span> <span class="hljs-type"><span class="hljs-type">IO</span></span>) sieve' km | k*k &lt; memSize = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> x &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.unsafeRead mk <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> fill' k (<span class="hljs-number"><span class="hljs-number">2</span></span>*k) m &gt;&gt;= sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sieve' (k+<span class="hljs-number"><span class="hljs-number">1</span></span>) m | otherwise = return m</code> </pre> <br><p>  It runs as follows </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">main</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> m &lt;- <span class="hljs-type"><span class="hljs-type">M</span></span>.replicate memSize <span class="hljs-number"><span class="hljs-number">0</span></span> stimes <span class="hljs-number"><span class="hljs-number">100</span></span> (sieve' <span class="hljs-number"><span class="hljs-number">2</span></span> m &gt;&gt; return ()) print <span class="hljs-string"><span class="hljs-string">"Ok"</span></span></code> </pre> <br><p>  And now Haskell finally shows that he is not a toy language.  You just need to use it wisely.  By the way, the above code uses the fact that the <code>IO ()</code> type forms a semigroup with the operation of sequential program execution <code>(&gt;&gt;)</code> , and with the help of <code>stimes</code> we repeated 100 times the calculation of the test problem. </p><br><p>  Now it‚Äôs clear why such a dislike for functional arrays occurs and why no one remembers how to work with them: as soon as a Haskell programmer seriously needs structures with random access, he reorients to changeable data and works in ST or IO monads. </p><br><p>  Derivation of a part of the teams into a special zone calls into question the legitimacy of isomorphism <em>code</em> <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.072ex" height="2.419ex" viewBox="0 -780.1 8642 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6C" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-65" x="2413" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-66" x="2880" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-74" x="3430" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-72" x="3792" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-69" x="4243" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-67" x="4589" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-68" x="5069" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-74" x="5646" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-61" x="6007" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-72" x="6537" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-72" x="6988" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6F" x="7440" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-77" x="7925" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-2"> \ longleftrightarrow </script>  <em>the program</em> .  After all, we cannot simultaneously convert code into pure and monadic programs, this is not allowed by the type system.  However, the type classes are flexible enough for this isomorphism to exist.  Homomorphism <em>code</em> <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.177ex" height="2.419ex" viewBox="0 -780.1 6965 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6C" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6F" x="548" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6E" x="1034" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-67" x="1634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-72" x="2115" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-69" x="2566" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-67" x="2912" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-68" x="3392" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-74" x="3969" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-61" x="4330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-72" x="4860" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-72" x="5311" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-6F" x="5763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMATHI-77" x="6248" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>l</mi><mi>o</mi><mi>n</mi><mi>g</mi><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>o</mi><mi>w</mi></math></span></span><script type="math/tex" id="MathJax-Element-3"> \ longrightarrow </script>  <em>the program is</em> now divided into several homomorphisms for different subsets of the language.  How exactly this is done can be seen in the full [code] () program. </p><br><h3 id="ne-ostanavlivaysya-na-dostignutom">  Don't stop there </h3><br><p>  A little more to change the productivity of the program will help exclude unnecessary function calls and embed their code directly using the <code>{-# INLINE #-}</code> pragma.  This method is not suitable for recursive functions, but it is great for basic components and setter functions.  It reduces the execution time of the test program by another 25% (see <a href="">Monopig51.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/0k/-l/hu/0k-lhu49_zsiihqoom7c5g0ize8.png"></p><br><p>  The next sensible step would be to get rid of logging tools when there is no need for them.  At the stage of the formation of the endomorphism representing the program, we use an external argument, which is determined at launch.  Smart constructors <code>program</code> and <code>programM</code> can be warned that the argument-logger may not be.  In this case, the converter code does not contain anything superfluous: only the functionality and checking the status of the machine. </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">program</span></span> code f = programM code (const f) programM code f (<span class="hljs-type"><span class="hljs-type">Just</span></span> logger) mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; logger mem code =&lt;&lt; f mem (stack vm) vm _ -&gt; return vm programM code f _ mem = <span class="hljs-type"><span class="hljs-type">Program</span></span> . ([code],) . <span class="hljs-type"><span class="hljs-type">ActionM</span></span> $ \vm -&gt; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> status vm <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Nothing</span></span> -&gt; f mem (stack vm) vm _ -&gt; return vm</code> </pre> <br><p>  Now executing functions must explicitly indicate the presence or absence of logging, not using the <code>none</code> stub, but using the type <code>Maybe (Logger ma)</code> .  Why should this work, because whether there is logging or not, program components will be recognized "at the last moment", just before execution?  Will not the unnecessary code be sewn at the stage of forming the composition of programs?  Haskell is a lazy language and here it plays into our hands.  It is exactly before the execution that the final code is generated that is optimized for a specific task.  This optimization has reduced the program execution time by another 40% (see <a href="">Monopig52.hs</a> ). </p><br><p><img src="https://habrastorage.org/webt/co/gd/vy/cogdvyw-zsyliuiwsmhxs5gadhe.png"></p><br><p>  This concludes the work on the acceleration of the monoidal pig.  He is already quite smartly worn, so that both the angel and the demon can calm down.  This, of course, is not C, we still use a clean list as a stack, but replacing it with an array will lead to a thorough rewinding of the code, and refusing to use elegant templates in the definitions of basic commands.  I also wanted to get by with minimal changes and, basically, at the level of types. </p><br><p>  Some problems remain when logging.  Simple counting the number of steps or using the stack works quite well (we made the journal field strict), but their pairing is already beginning to eat memory, you have to mess around with kicks using <code>seq</code> , which is pretty annoying.  But tell me, who will log the 14 billion steps, if you can debug the task on the first hundreds?  So I will not waste my time on acceleration for the sake of acceleration. </p><br><p>  It remains only to add that in the article about the piglet, as one of the methods for optimizing calculations, the following is given: selection of linear sections of code, <em>traces</em> , within which calculations can be made bypassing the main command dispatching cycle ( <code>switch</code> block).  In our case, the monoidal composition of the program components creates such traces either during the formation of the program from the EDSL components or when the <code>fromCode</code> homomorphism <code>fromCode</code> .  This method of optimization comes to us for free, so to speak, by construction. </p><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo><mtext>&amp;#xA0;</mtext><mo>&amp;#x2217;</mo></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.681ex" height="1.335ex" viewBox="0 -520.7 2445.9 574.6" role="img" focusable="false" style="vertical-align: -0.125ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMAIN-2217" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMAIN-2217" x="972" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/post/430956/&amp;xid=17259,15700023,15700186,15700190,15700248,15700253&amp;usg=ALkJrhiXmPJKGQbRz3khiFbsHLQyR9wXsg#MJMAIN-2217" x="1945" y="0"></use></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo><mtext>&nbsp;</mtext><mo>‚àó</mo></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-4"> * \ * \ * </script></p><br><p>  There are many elegant and fast solutions in the Haskell ecosystem, such as <code>Conduits</code> or <code>Pipes</code> streams, there are excellent replacements for the <code>String</code> type and nimble XML creators, such as blaze-html, and the <code>attoparsec</code> parser is a reference for combinatorial analysis for LL (‚àû) grammar.  All this is necessary for normal operation.  But even more necessary - research leading to these solutions.  Haskell was and remains a research tool that meets specific requirements not needed by the general public.  I saw in Kamchatka how the aces of a Mi-4 helicopter closed a box of matches onto the dispute, pushing the chassis wheel on it, hanging in the air.  This can be done, and it is cool, but not necessary. </p><br><p>  But, after all, it's cool !! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430956/">https://habr.com/ru/post/430956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430944/index.html">NASA has decided on the participants for its mini-lunar competition.</a></li>
<li><a href="../430948/index.html">Ministry of Communications proposes to tighten control over personal data</a></li>
<li><a href="../430950/index.html">Make Modern Build</a></li>
<li><a href="../430952/index.html">Electric cars and hybrid cars will have to make additional sounds: why is it necessary?</a></li>
<li><a href="../430954/index.html">Qt Everywhere: WebAssembly and WebGL streaming</a></li>
<li><a href="../430958/index.html">We start the container with unit tests in Azure DevOps (VSTS)</a></li>
<li><a href="../430960/index.html">Pro gamedev from the desktop exhibition</a></li>
<li><a href="../430962/index.html">Razor support in Visual Studio Code</a></li>
<li><a href="../430964/index.html">Declarative thinking</a></li>
<li><a href="../430966/index.html">General sprints in Atlassian Jira Software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>