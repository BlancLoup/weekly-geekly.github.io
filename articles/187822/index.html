<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Simple and scalable event subscription with WebSockets, STOMP, SockJS and Spring Framework 4.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first intermediate release of the Spring Framework 4.0 M1 provided server-side support for SockJS - the best and most complete alternative impleme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Simple and scalable event subscription with WebSockets, STOMP, SockJS and Spring Framework 4.0</h1><div class="post__text post__text-html js-mediator-article">  The first intermediate release of the Spring Framework 4.0 M1 provided server-side support for <a href="http://sockjs.org/">SockJS</a> - the best and most complete alternative implementation of WebSocket.  You will need this backup option in browsers that do not support WebSocket and in situations where a proxy <a href="http://www.infoq.com/articles/Web-Sockets-Proxy-Servers">interferes with</a> their use.  Simply put, SockJS allows you to build WebSocket-applications today, which, among other things, are able to transparently switch to backup capabilities. <br><br>  But even with backup options, problems remain.  A socket is a rather low-level abstraction and the vast majority of web applications today are not adapted for sockets.  This is why the WebSocket protocol defines a sub-protocol mechanism that, in essence, allows (and encourages) the use of higher-level protocols over WebSocket, just as we use HTTP over TCP. <br><br>  The second intermediate release of the Spring Framework 4.0 M2 allows the use of high-level messaging protocols over WebSocket.  To demonstrate this, we will analyze an example application. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Stock Portfolio app </h4><br>  This test application, <a href="https://github.com/rstoyanchev/spring-websocket-portfolio">available</a> on Github, allows users to download a portfolio of positions, buy and sell stocks;  sends price quotes and displays position updates.  This is a fairly simple application.  However, it covers a number of common tasks that may arise in browser-based messaging applications. <br><img src="https://habrastorage.org/getpro/habr/post_images/b76/aa9/bfc/b76aa9bfc0b2bcda9d57006aafa2986a.png"><br><br>  How exactly do we implement an application like this?  In HTTP and REST, we are used to relying on URLs and HTTP methods that express <i>what</i> needs to be done.  But there is only a socket and a bunch of messages.  How to tell who the message is and what it means? <br><img src="https://habrastorage.org/getpro/habr/post_images/984/2dc/75f/9842dc75fe5439377746068b829e5f89.png"><br><br>  The browser and server must agree on a common message format before this semantics can be expressed.  There are several protocols that can help.  We chose <a href="http://stomp.github.io/stomp-specification-1.2.html">STOMP</a> in this release due to its simplicity and <a href="http://stomp.github.io/implementations.html">broad support</a> . <br><br><h4>  Simple / Streaming Text-Oriented Messaging Protocol (STOMP) </h4><br>  STOMP is a very simple messaging protocol.  Frame based on HTTP pattern.  A frame consists of a command, optional headers and an optional body. <br><br>  For example, the Stock Portfolio application can send quotes, the client will send a SUBSCRIBE frame, where the destination header indicates what exactly it subscribes to: <br><pre><code class="html hljs xml">SUBSCRIBE id:sub-1 destination:/topic/price.stock.*</code> </pre> <br>  As soon as stock quotes become available, the server sends a MESSAGE frame with the appropriate destination and subscription ID, as well as the content-type header and body: <br><pre> <code class="html hljs xml">MESSAGE subscription:sub-1 message-id:wm2si1tj-4 content-type: application/json destination:/topic/stocks.PRICE.STOCK.NASDAQ.EMC {\"ticker\":\"EMC\",\"price\":24.19}</code> </pre><br>  To combine this all in the browser, we use <a href="https://github.com/jmesnil/stomp-websocket/">stomp.js</a> and <a href="http://github.com/sockjs/sockjs-client">the SockJS client</a> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> socket = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SockJS(<span class="hljs-string"><span class="hljs-string">'/spring-websocket-portfolio/portfolio'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = Stomp.over(socket); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onConnect = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ client.subscribe(<span class="hljs-string"><span class="hljs-string">"/topic/price.stock.*"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }); }; client.connect('guest', 'guest', onConnect);</span></span></code> </pre><br>  This is a serious advance!  We have a standard message format and customer support. <br><br>  Now we can move further - to the server side. <br><br><h4>  Message broker </h4><br>  Message-broker is a typical server solution, where messages are sent between traditional brokers such as RabbitMQ, ActiveMQ, etc.  Most, if not all, support STOMP over TCP, some - WebSocket, but RabbitMQ has advanced the furthest, and it also works with SockJS, among other things. <br><br>  Our architecture will look like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/708/a8c/13d/708a8c13d2a8fade3eb23ffbc863b445.png"><br><br>  This is a reliable and scalable solution, but perhaps not the most optimal for the task at hand.  Message-broker is commonly used within the enterprise.  Expose it directly to the network does not pull on the perfect solution. <br><br>  If we learned something from the REST approach, it is that we should not disclose the details of the implementation of our system, the database device or the domain model. <br><br>  In addition, as a Java developer, you probably want to customize permissions, validations, add application logic.  In the message-broker approach, the application server is behind the broker, which is significantly different from what most web developers are used to. <br><br>  That's why libraries like <a href="http://socket.io/">socket.io are popular</a> .  It is simple and it focuses on the needs of web applications.  On the other hand, we should not ignore the message-broker's ability to process messages, they are really good at it - a difficult dilemma.  Take the best of both. <br><br><h4>  + Message-broker application </h4><br>  Another approach is to make an application that processes incoming messages and acts as an intermediary between web clients and a broker.  Messages from clients to the broker can be sent through the application, the return message will also pass through the application to the client.  This allows the application to determine the <a href="http://stomp.github.io/stomp-specification-1.2.html">type of message</a> and the ‚Äúdestination‚Äù header, then decide to process it on its own or redirect it to the broker. <br><img src="https://habrastorage.org/getpro/habr/post_images/701/a24/807/701a24807f14c3c706d8857dfa9b5e9f.png"><br><br>  We chose this approach.  To illustrate it better here are some scenarios. <br><br>  Loading portfolio items <br><ul><li>  The client requests a portfolio of positions </li><li>  An application processes a request by loading and returning data for a subscription. </li><li>  Message-broker does not participate in this interaction. </li></ul><br>  Subscribe to stock quotes <br><ul><li>  Customer sends subscription request </li><li>  The application sends a message to the broker </li><li>  Message-broker sends the message to all subscribed customers. </li></ul><br>  Get stock quotes <br><ul><li>  QuoteService sends a stock quote message to a broker </li><li>  Message-broker sends the message to all subscribed customers. </li></ul><br>  Conducting transaction <br><ul><li>  Client sends trade request </li><li>  The application does not process it, all transactions go through TradeService </li><li>  Message-broker does not participate in this interaction. </li></ul><br>  Getting updated positions <br><ul><li>  TradeService sends a position update message to the broker's queue </li><li>  Message-broker sends item update to customer </li><li>  Sending messages to a specific user is discussed in detail below. </li></ul><br>  Strictly speaking, the use of a message broker is optional.  We offer a ‚Äúsimple‚Äù out-of-the-box alternative.  However, the use of a message broker is recommended for scalability and for deployment with multiple application servers. <br><br><h4>  Code snippets </h4><br>  Let's look at some examples of server and client code. <br><br>  This is a request for a portfolio of positions from <a href="">portfolio.js</a> : <br><pre> <code class="javascript hljs">stompClient.subscribe(<span class="hljs-string"><span class="hljs-string">"/app/positions"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">message</span></span></span><span class="hljs-function">) </span></span>{ self.portfolio().loadPositions(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(message.body)); });</code> </pre><br>  On the server side, the <a href="">PortfolioController</a> detects a request and returns a portfolio of positions, demonstrating the request-response interaction, which is very often used in web applications.  Because we use Spring Security to protect HTTP requests, including one initial, related to a handshake with WebSocket, as an argument to the method in the example below, the Spring Security user principal obtained from HttpServletRequest is passed: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortfolioController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @SubscribeEvent("/app/positions") public List&lt;PortfolioPosition&gt; getPortfolios(Principal principal) { String user = principal.getName(); Portfolio portfolio = this.portfolioService.findPortfolio(user); return portfolio.getPositions(); } }</span></span></code> </pre><br>  Here, portfolio.js sends a trade request: <br><pre> <code class="javascript hljs">stompClient.send(<span class="hljs-string"><span class="hljs-string">"/app/trade"</span></span>, {}, <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(trade));</code> </pre><br>  On the server side, the PortfolioController submits it for execution: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortfolioController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @MessageMapping(value="/app/trade") public void executeTrade(Trade trade, Principal principal) { trade.setUsername(principal.getName()); this.tradeService.executeTrade(trade); } }</span></span></code> </pre><br>  PortfolioController can also handle unexpected exceptions by sending a message to the user: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Controller</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PortfolioController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @MessageExceptionHandler @ReplyToUser(value="/queue/errors") public String handleException(Throwable exception) { return exception.getMessage(); } }</span></span></code> </pre><br>  What about sending messages to all subscribed customers?  So QuoteService sends quotas: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QuoteService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> MessageSendingOperations&lt;String&gt; messagingTemplate; <span class="hljs-meta"><span class="hljs-meta">@Scheduled</span></span>(fixedDelay=<span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendQuotes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Quote quote : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.quoteGenerator.generateQuotes()) { String destination = <span class="hljs-string"><span class="hljs-string">"/topic/price.stock."</span></span> + quote.getTicker(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.messagingTemplate.convertAndSend(destination, quote); } } }</code> </pre><br>  And so TradeService sends the update of positions after it has executed the transaction: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Service</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TradeService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... @Scheduled(fixedDelay=1500) public void sendTradeNotifications() { for (TradeResult tr : this.tradeResults) { String queue = "/queue/position-updates"; this.messagingTemplate.convertAndSendToUser(tr.user, queue, tr.position); } } }</span></span></code> </pre><br>  And just in case if you are interested ... yes, PortfolioController may contain Spring MVC methods (for example, <code>@RequestMapping</code> ), as suggested by the developer who previously built online games in this <a href="https://jira.springsource.org/browse/SPR-9356%3FfocusedCommentId%3D88191%26page%3Dcom.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel">ticker</a> : <br><div class="spoiler">  <b class="spoiler_title">Quote</b> <div class="spoiler_text"><blockquote>  Yes, having [message] mappings and spring mvc mappings consolidated would be nice.  There is no reason why they can't be unified. </blockquote></div></div><br>  And just like the QuoteService and TradeService, the Spring MVC methods of the controller can also post messages. <br><br><h4>  Messaging support in Spring applications </h4><br>  For a long time, <a href="http://www.springsource.org/spring-integration">Spring Integration</a> provides first-class abstractions for well-known <a href="http://www.eaipatterns.com/">Enterprise Integration</a> patterns, as well as lightweight messaging.  While working on this release, we realized that the latter was exactly what we needed to rely on. <br><br>  As a result, and I am pleased to announce this, we moved the Spring Integration type set to a new Spring Framework module, which is predictably called <a href="https://github.com/SpringSource/spring-framework/tree/master/spring-messaging/src/main/java/org/springframework/messaging">spring-messaging</a> .  In addition to basic abstractions, such as Message, MessageChannel, MessageHandler, etc., the module contains all the annotations and classes to support the new functions described in this post. <br><br>  Now, with this in mind, we can look at the diagram of the internal structure of the Stock Portfolio application: <br><img src="https://habrastorage.org/getpro/habr/post_images/cd8/946/7b8/cd89467b84b9a66610b751db2af461a7.png"><br><br>  StompWebSocketHandler puts incoming client messages on the dispatch channel.  This channel has 3 subscribers.  The first is responsible for the annotated methods, the second is the message sent to the STOMP broker, while the third processes the messages of individual users by converting the destination address into a queue of unique names to which the client has subscribed. <br><br>  By default, the application works with a ‚Äúsimple‚Äù broker provided for acquaintance.  As explained in the <a href="https://github.com/rstoyanchev/spring-websocket-portfolio">README</a> , you can choose between a ‚Äúsimple‚Äù and full-featured broker by activating and deactivating profiles. <br><img src="https://habrastorage.org/getpro/habr/post_images/19b/c99/18b/19bc9918b8d9068bcc2aa68e1397cbe9.png"><br><br>  Another possible configuration change is to move from the <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html">Executor</a> to the implementation of a MessageChannel based on <a href="https://github.com/reactor/reactor">Reactor</a> .  The Reactor project recently <a href="http://blog.springsource.org/2013/07/18/reactor-1-0-0-m1-a-foundation-for-asynchronous-fast-data-applications-on-the-jvm/">released the</a> first intermediate release and is also used to manage TCP connections between the application and the Message-broker. <br><br>  <a href="https://github.com/rstoyanchev/spring-websocket-portfolio/blob/master/src/main/java/org/springframework/samples/portfolio/config">Here</a> you can see the complete configuration of the application, which also includes the <a href="http://blog.springsource.org/2013/07/11/spring-security-java-config-preview-readability/">new</a> configuration of Spring Security.  You may also be interested to learn about the improved support for configs in <a href="http://blog.springsource.org/2013/07/18/javaconfig-support-in-the-spring-tool-suite/">STS</a> . <br><br><h4>  Send messages to individual users </h4><br>  It's easy to understand how you can send messages to all subscribed clients ‚Äî just send a message to the channel.  Slightly more complicated is the situation with sending a message to a specific client.  For example, you caught an exception and want to send an error message.  Or you received confirmation of the completion of the transaction and want to please the user. <br><br>  In traditional messaging applications, this task is usually solved by creating a time queue and setting the reply-to header in all messages that imply a reply.  It works, but looks rather cumbersome.  The client should not forget to put the necessary headers on all applicable messages and the server application may need to monitor them.  Sometimes this information may not be available (for example, if you use HTTP POST instead of messaging). <br><br>  To support this requirement, we send a unique queue suffix to each connected client.  A suffix can then be added to the identifier to create a unique queue name: <br><pre> <code class="javascript hljs">client.connect(<span class="hljs-string"><span class="hljs-string">'guest'</span></span>, <span class="hljs-string"><span class="hljs-string">'guest'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">frame</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> suffix = frame.headers[<span class="hljs-string"><span class="hljs-string">'queue-suffix'</span></span>]; client.subscribe(<span class="hljs-string"><span class="hljs-string">"/queue/error"</span></span> + suffix, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   }); client.subscribe("/queue/position-updates" + suffix, function(msg) { //    }); });</span></span></code> </pre><br>  Then on the server side, you can add the <code>@ReplyToUser</code> annotation to the method marked <code>@MessageExceptionHandler</code> (or any other message handling method) and send the return value as a message: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@MessageExceptionHandler</span></span> <span class="hljs-meta"><span class="hljs-meta">@ReplyToUser</span></span>(value=<span class="hljs-string"><span class="hljs-string">"/queue/errors"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handleException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable exception)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre><br>  All other classes, such as TradeService, can use messagingTemplate to achieve the same: <br><pre> <code class="java hljs">String user = <span class="hljs-string"><span class="hljs-string">"fabrice"</span></span>; String queue = <span class="hljs-string"><span class="hljs-string">"/queue/position-updates"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.messagingTemplate.convertAndSendToUser(user, queue, position);</code> </pre><br>  In both cases, inside we have the suffix of the user queue (through the configured <a href="">UserQueueSuffixResolver</a> ) in order to restore the correct queue name.  At the moment there is only one implementation of a simple resolver.  However, it is fairly easy to add a <a href="http://redis.io/">Redis-</a> based implementation that will support the function regardless of whether the user is connected or another application server. <br><br><h4>  findings </h4><br>  Hope this was a useful introduction to new functionality.  Instead of making the post even longer, I advise you to study the <a href="https://github.com/rstoyanchev/spring-websocket-portfolio">example</a> and try to apply it in the applications you write or intend to write.  This is an ideal time for feedback, because  how we plan release candidate in early September. </div><p>Source: <a href="https://habr.com/ru/post/187822/">https://habr.com/ru/post/187822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../187806/index.html">Canonical temporarily lowered prices for pre-order Ubuntu Edge</a></li>
<li><a href="../187808/index.html">AngularJS vs. Knockoutjs</a></li>
<li><a href="../187812/index.html">In August, it will be possible to purchase and rent textbooks on Google Play</a></li>
<li><a href="../187814/index.html">About RNA molecules</a></li>
<li><a href="../187820/index.html">Parsing NetFlow v.9 C # Packages</a></li>
<li><a href="../187826/index.html">Data recovery redis</a></li>
<li><a href="../187828/index.html">Proper understanding of gamification</a></li>
<li><a href="../187830/index.html">Tiny Thief - a cool mobile game made using Flash + Autodesk Scaleform Mobile SDK</a></li>
<li><a href="../187834/index.html">New for web designer for July 2013</a></li>
<li><a href="../187836/index.html">New Brief: Samsung Announced New Exynos 5 Octa Processor - Exynos 5420</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>