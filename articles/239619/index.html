<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Extended processor instructions in .NET or "C # Intrinsics"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In chess programs, ‚Äúbit boards‚Äù (bitboards 1 , 2 ) are widely used to represent pieces on the board. As well as for other games on the same 8 √ó 8 boar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Extended processor instructions in .NET or "C # Intrinsics"</h1><div class="post__text post__text-html js-mediator-article">  In chess programs, ‚Äúbit boards‚Äù (bitboards <a href="http://www.frayn.net/beowulf/theory.html">1</a> , <a href="http://chessprogramming.wikispaces.com/Bitboards">2</a> ) are widely used to represent pieces on the board.  As well as for other games on the same 8 √ó 8 board, and even for card games.  With bitboards often perform various operations, for example, to find the first bit set or count the number of bits set.  Many ‚Äútricky‚Äù <a href="https://chessprogramming.wikispaces.com/Bit-Twiddling">algorithms</a> have been invented for these operations, and on modern processors some of these operations are available in an <a href="https://chessprogramming.wikispaces.com/x86-64">extended set of instructions</a> .  For example, <b>popcnt</b> , available in SSE4.2 ABM.  There are also a couple of <b>bsf</b> / <b>bsr instructions</b> that have been available for a long time, but there is no access to them from the JIT compiler. <br>  Of course, all serious chess programs are written in C ++, but for prototyping any algorithms, I would like to use C #, because I know it better and I have less chance to shoot myself in the leg.  But the performance also does not want to lose just like that, in C / C ++ the instructions of interest to us are available so-called <a href="http://msdn.microsoft.com/en-us/library/hh977022.aspx">built</a> - <a href="http://msdn.microsoft.com/en-us/library/hh977022.aspx">in functions</a> .  I tried to make a similar decision for C #. <br><a name="habracut"></a><br>  There are <a href="http://blogs.msdn.com/b/clrcodegeneration/archive/2014/04/03/ryujit-ctp3-how-to-use-simd.aspx">ready-made</a> <a href="http://www.yeppp.info/index.html">libraries</a> for SIMD instructions, but not for bit manipulations. <br><br>  What to do?  We must somehow patch the existing code. <br>  Let us dwell on the fact that we use a 64-bit processor (on a 32-bit processor it‚Äôs not so fun to work with bitboards), and this processor is x86_64.  For incompatible architectures, you need to have fallbacks (implementation in C #).  Under such conditions, <b>bsf</b> / <b>bsr</b> will always be available, and <b>popcnt is</b> not available only on a rather ancient gland, but more on that later. <br>  The easiest option is to write a DLL in C ++ and export the functions we need from there.  But these ‚Äúfunctions‚Äù will consist of one instruction, and around them there will be some extra jumps that will arise during PInvoke. <br>  The second option: use <a href="http://architects.dzone.com/articles/performance-gains-using-simd">GetDelegateForFunctionPointer</a> , it is similar to the first, but does not require a separate native DLL. <br>  The third is to replace the already compiled method.  <a href="http://www.codeproject.com/Articles/37549/CLR-Injection-Runtime-Method-Replacer">Many</a> <a href="http://msdn.microsoft.com/en-us/magazine/cc163791.aspx">interesting</a> <a href="http://www.codeproject.com/Articles/26060/NET-Internals-and-Code-Injection">articles</a> have been written about this <a href="http://ntcore.com/files/netint_native.htm">.</a>  But then there are problems with the fact that it is a) difficult b) there are dependencies on the internals of runtime, and, therefore, of its version.  As a result, we get a cumbersome and unstable decision, this is not our way. <br>  The last option remains: patch the compiled JIT code. <br><br><h4>  <b><font color="#4F81BD">Implementation details</font></b> </h4><br>  First we need to make sure that the method is compiled: <a href="http://msdn.microsoft.com/en-us/library/0bt50792(v%3Dvs.110).aspx">RuntimeHelpers.PrepareMethod ()</a> .  And to get to the machine code, Microsoft carefully provided us with the <a href="http://msdn.microsoft.com/en-us/library/system.runtimemethodhandle.getfunctionpointer(v%3Dvs.110).aspx">RuntimeMethodHandle.GetFunctionPointer ()</a> method.  But according to this link, depending on the runtime, both the method itself and the springboard can be used.  Well, that the springboard is only one type - JMP.  We will take advantage of this: <br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>* GetMethodPtr(MethodInfo method) { RuntimeHelpers.PrepareMethod(method.MethodHandle); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = (<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>*)method.MethodHandle.GetFunctionPointer(); <span class="hljs-comment"><span class="hljs-comment">// skip all jumps while (*ptr == 0xE9) { var delta = *(int*)(ptr + 1) + 5; ptr += delta; } return ptr; }</span></span></code> </pre> <br>  So, we have received the address, we will try to write down something there.  It is necessary to take into account the Call-Convention, the benefit of x86_64 is <a href="http://en.wikipedia.org/wiki/X86_calling_conventions">one</a> (the first four arguments in RCX, RDX, R8, R9, the result in RAX): <br><pre> <code class="hljs markdown"> //bsr rax, rcx; ret <span class="hljs-emphasis"><span class="hljs-emphasis">*ptr++ = 0x48; *</span></span>ptr++ = 0x0F; <span class="hljs-emphasis"><span class="hljs-emphasis">*ptr++ = 0xBD; *</span></span>ptr++ = 0xC1; *ptr++ = 0xC3;</code> </pre><br>  We try ... Hurray, it works! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But now our version is no different in performance from PInvoke / GetDelegateForFunctionPointer: there is an extra call / jmp from the caller.  In addition, if our function-fallback compiler zayinlaynil, then the patch of this place will not help. <br>  Inline can be easily discarded using the <font color="#000000">[</font> <font color="#2B91AF">MethodImpl</font> <font color="#000000">(</font> <font color="#2B91AF"><a href="http://msdn.microsoft.com/en-us/library/system.runtime.compilerservices.methodimploptions(v%3Dvs.110).aspx">MethodImplOptions</a></font> <font color="#000000">.NoInlining)]</font> )] attribute. <br>  Also, as in C ++ - intrinsics, you must completely abandon call / jmp.  It is also quite easy to cope with this, although it will have to be a little dirty with the assembler.  We will patch the call site on the fly.  To do this, we need to replace our fallback code not just with the necessary instructions, but with a call to the ‚Äúpatcher‚Äù with the necessary parameters: at what address and what to replace. <br>  Let's start by defining the address: we have a return address in the stack (in dword ptr [rax]), usually the call to our method happens just before it.  If this is a call instruction (and usually it is), then we need to check the previous 5 bytes, and if it really was a call to the desired method, then replace them entirely with the opcode of our instruction.  The patcher method will look like this: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PatchCallSite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">* rsp, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ulong</span></span></span></span><span class="hljs-function"><span class="hljs-params"> code</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = rsp - <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-comment"><span class="hljs-comment">// check call opcode if (*ptr != 0xE8) { // throw ERROR } const ulong Mask5Bytes = (1uL &lt;&lt; 40) - 1; *(ulong*)ptr = *(ulong*)ptr &amp; ~Mask5Bytes | (code &amp; Mask5Bytes); }</span></span></code> </pre><br>  And we will call it manually from the assembler, as a result, our fallback method will be replaced with such a thing: <br><pre> <code class="hljs perl">bsr rax, rcx ;   nop ;   <span class="hljs-number"><span class="hljs-number">5</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> rax ;    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">sub</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsp</span></span></span><span class="hljs-function">, 0</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x20</span></span></span><span class="hljs-function"> </span></span>;   register spilling mov rcx, QWORD PTR [rsp+<span class="hljs-number"><span class="hljs-number">0x28</span></span>] ;   ‚Äî   ;        , ;   ¬´¬ª  <span class="hljs-number"><span class="hljs-number">0x20</span></span> + <span class="hljs-number"><span class="hljs-number">8</span></span>  mov rdx, QWORD PTR [rip-<span class="hljs-number"><span class="hljs-number">0x16</span></span>] ;   ‚Äî    ;       movabs rax, &lt;PatchCallSite&gt; call rax add rsp, <span class="hljs-number"><span class="hljs-number">0x20</span></span> ;    <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> rax ;     ret</code> </pre><br>  All this is done by the Patcher.PatchMethod function, which we will call for all the methods that need to be patched. <br>  Here is how it looks on a live example (from PerfTest): <br><img src="http://hsto.org/files/1b2/9d1/acf/1b29d1acfb82404f839bd1108a64fc84.png"><br>  <a href="">(if the picture is not visible)</a> <br><br>  and after the first pass: <br><img src="http://hsto.org/files/320/a0a/d33/320a0ad33ff7481ab2d5ec18f3c89ddd.png"><br>  <a href="">(if the picture is not visible)</a> <br><br>  Now there are trifles: JIT can zainlaynit something very strongly, or make tail-call optimization, then the return address will not really correspond to the call of our function.  Unfortunately, I could not find examples of such aggressive optimizations, but just in case this should also be checked.  Knowing the place where the call was made from, we can verify that he actually called.  Here, too, you need to jump over all the jmp-s, and check that they lead us to the right place.  And due to the fact that we placed the replacement instructions at the very beginning of the patch in an unchanged form, this is very easy to do: <br><pre> <code class="hljs lisp">// check call target var calltarget = ptr + *(<span class="hljs-name"><span class="hljs-name">int*</span></span>)(<span class="hljs-name"><span class="hljs-name">ptr</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) + <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-comment"><span class="hljs-comment">; while (*calltarget == 0xE9) { var delta = *(int*)(calltarget + 1) + 5; calltarget += delta; } code &amp;= Mask5Bytes; if ((*(ulong*)calltarget &amp; Mask5Bytes) != code) { // throw ERROR }</span></span></code> </pre><br>  We also don‚Äôt want to touch anything if we suddenly find ourselves on an unsupported architecture.  First, <font color="#000000">let's</font> check that it is generally 64-bit: ( <font color="#2B91AF">IntPtr</font> <font color="#000000">.Size == 8</font> ).  Next you need to make sure that it is x86_64.  I didn‚Äôt find anything better than comparing the prolog of any function with obviously correct instructions (see Patcher.VerifyPrologue in the code). <br><br>  Some instructions, such as <b>popcnt</b> , are not available on all processors.  If speed is important to you, then it is better not to use such processors at all, but it is advisable to leave a fallback for them in the library.  In the Intel manual it is written that you can check for the presence of the popcnt instruction by calling <b>cpuid</b> with eax = 01H and checking the ECX.POPCNT bit [Bit 23].  This is where stackoverflow-driven development comes to the rescue, where you can find a ready-made piece of code to call <a href="http://stackoverflow.com/questions/3216535/x86-x64-cpuid-in-c-sharp">cpuid from C #</a> . <br><br>  It remains only to wrap it all up beautifully: we make the attribute <font color="#000000">[</font> <font color="#2B91AF">ReplaceWith</font> <font color="#000000">(</font> <font color="#A31515">"F3 48 0F B8 C1"</font> <font color="#000000">, Cpiud1ECX = 1 &lt;&lt; 23)]</font> , which we glue to the Folback functions.  It contains the code with which the given intrinsic should be replaced, as well as the availability condition of the necessary instruction. <br><br><h4>  <b><font color="#4F81BD">Benchmarks</font></b> </h4><br>  The benchmarks are pretty primitive: we generate an array of pseudo-random numbers, then we drive it 100 million times each method.  To eliminate the influence of the cycle and other strapping, we first measure the time of the empty cycle.  The special case of ‚Äúrarefied‚Äù boards was tested separately: quite often the board contains up to 8 figures or labeled cells, and on such boards, the currently selected falback should work faster. <br>  I tried and tested on two processors that were at hand: the i7 notebook and the good old Q6600.  Here are the details of the tests. <br><div class="spoiler">  <b class="spoiler_title">i7-3667U</b> <div class="spoiler_text"><pre> Testing Rng ...
 78ms, sum = 369736839

 Testing BitScanForward ...
 123ms, sum = 99768073

 Testing FallBack.BitScanForward ...
 239ms, sum = 99768073

 Testing PopCnt64 ...
 106ms, sum = -1092098543

 Testing FallBack.PopCnt64 ...
 3143ms, sum = -1092098543

 Testing PopCnt32 ...
 106ms, sum = 1598980778

 Testing FallBack.PopCnt32 ...
 2139ms, sum = 1598980778

 Testing PopCnt64 on sparse data ...
 106ms, sum = 758117720

 Testing FallBack.PopCnt64 on sparse data ...
 952ms, sum = 758117720
</pre></div></div><br><div class="spoiler">  <b class="spoiler_title">Q6600</b> <div class="spoiler_text"><pre> Patch status: Ok
 Feature PopCnt is not supported by this CPU
 Feature PopCnt is not supported by this CPU

 Testing Rng ...
 92ms, sum = 369736839

 Testing BitScanForward ...
 154ms, sum = 99768073

 Testing FallBack.BitScanForward ...
 323ms, sum = 99768073

 Testing PopCnt64 ...
 3832ms, sum = -1092098543

 Testing FallBack.PopCnt64 ...
 3583ms, sum = -1092098543

 Testing PopCnt32 ...
 2414ms, sum = 1598980778

 Testing FallBack.PopCnt32 ...
 3249ms, sum = 1598980778

 Testing PopCnt64 on sparse data ...
 1662ms, sum = 758117720

 Testing FallBack.PopCnt64 on sparse data ...
 1076ms, sum = 758117720
</pre></div></div><br><br>  Summary table of results, the ‚Äúidle‚Äù cycle time has already been deducted here: <br><table><tbody><tr><td></td><th>  bsf </th><th>  bsf fallback </th><th>  popcnt64 </th><th>  popcnt64 fallback </th><th>  popcnt32 </th><th>  popcnt32 fallback </th><th>  sparse popcnt64 </th><th>  sparse popcnt64 fallback </th></tr><tr><th>  i7-3667U </th><td>  45ms </td><td>  161ms <br>  (~ 3.6x slower) </td><td>  28ms </td><td>  3065ms <br>  (~ 100x slower) </td><td>  28ms </td><td>  2061ms <br>  (~ 70x slower) </td><td>  28ms </td><td>  874ms <br>  (~ 30x slower) </td></tr><tr><th>  Q6600 </th><td>  62ms </td><td>  231ms <br>  (~ 3.7x slower) </td><td>  N / A </td><td>  3491ms </td><td>  N / A </td><td>  3157ms </td><td>  N / A </td><td>  984ms </td></tr></tbody></table><br>  As we can see, on the bsf / bsr instructions our fallback works quite fast, so the gain from intrinsic will be small, and even imperceptible compared to other parts of the algorithm.  But for popcnt it is already much better, if you have a Core i5 / i7, then it will accelerate tenfold. <br>  In relation to the final algorithm, I received an acceleration of only 15%, because  there is still a lot of code that not only counts bits.  As they say, <a href="http://en.wiktionary.org/wiki/your_mileage_may_vary">YMMV</a> , check on your code. <br><br><h4>  <b><font color="#4F81BD">Where to get</font></b> </h4><br>  Code can be taken on <img src="http://vkote.ru/i/2012.04.02/000a5f0b/github-icon.png">  <a href="https://github.com/omgtehlion/netintrinsics">githabe</a> . <br>  NuGet: Install-Package NetIntrinsics </div><p>Source: <a href="https://habr.com/ru/post/239619/">https://habr.com/ru/post/239619/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239607/index.html">Voice control web-player, or cross CMU Sphinx with Selenium WebDriver</a></li>
<li><a href="../239609/index.html">Play on your smartphone, as on the console - budget gamepad EXEQ Renegade</a></li>
<li><a href="../239611/index.html">Winter is coming: the right winter gloves for touchscreen lovers</a></li>
<li><a href="../239613/index.html">Link to API VKontakte added to Sypex Geo</a></li>
<li><a href="../239615/index.html">Share your success story and win an MSDN annual subscription!</a></li>
<li><a href="../239621/index.html">User intention: enhancing the digital campaign with user factors</a></li>
<li><a href="../239625/index.html">200 microcomputers in 3 hours, or small-scale production of microelectronics in Shenzhen (on the example of the VoCore project)</a></li>
<li><a href="../239627/index.html">Algorithmic trading on the stock market in Russia: trends and technologies</a></li>
<li><a href="../239629/index.html">Check Network Security Services Library</a></li>
<li><a href="../239633/index.html">We use MongoDB in a cloud backend of mobile applications</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>