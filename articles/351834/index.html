<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blockchain on Go. Part 5: Addresses</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 



1. Blockchain on Go. Part 1: Prototype 
2. Blockchain on Go. Part 2: Proof-of-Work 
3. Blockchain on Go. Part 3: Permanent Memory and Comm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blockchain on Go. Part 5: Addresses</h1><div class="post__text post__text-html js-mediator-article">  Content <br><br><ol><li>  <a href="https://habrahabr.ru/post/348672/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/348672/">Part 1: Prototype</a> </li><li>  <a href="https://habrahabr.ru/post/350804/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/350804/">Part 2: Proof-of-Work</a> </li><li>  <a href="https://habrahabr.ru/post/351296/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/351296/">Part 3: Permanent Memory and Command Line Interface</a> </li><li>  <a href="https://habrahabr.ru/post/351752/">Blockchain on Go.</a>  <a href="https://habrahabr.ru/post/351752/">Part 4: Transactions, Part 1</a> </li><li>  <b>Blockchain on Go.</b>  <b>Part 5: Addresses</b> </li><li>  Blockchain on Go.  Part 6: Transactions, Part 2 </li><li>  Blockchain on Go.  Part 7: Network </li></ol><br><h4>  Introduction </h4><br>  In the <a href="https://habrahabr.ru/post/351752/">previous article,</a> we started the implementation of transactions, as well as familiarized ourselves with the principle of its operation: there are no accounts, personal data (for example, the name or series and passport number) are not required and are not stored anywhere in Bitcoin.  But there must still be something that identifies you as the owner of the transaction outlets (i.e., the owner of the coins blocked at the exits).  And this is what Bitcoin addresses are for.  So far, we have used arbitrary strings as addresses, now it's time to implement real addresses, in the way they are implemented in Bitcoin. <br><a name="habracut"></a><br>  In this part we will change a lot of code, so I see no reason to explain everything in detail.  Visit <a href="https://jeiwan.cc/posts/building-blockchain-in-go-part-5/">this page</a> to see all the changes compared to the previous article. <br><br><h4>  Bitcoin address </h4><br>  Here is an example of a Bitcoin address: <a href="https://blockchain.info/address/1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa">1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa</a> .  This is the very first Bitcoin address that allegedly belongs to Satoshi Nakamoto.  Bitcoin addresses are publicly available.  If you want to send someone a coin, you need to know the address of the recipient.  But addresses (despite the uniqueness) do not identify you as the owner of the "wallet".  In fact, such addresses are a public key.  In Bitcoin, your identity is a pair (or pairs) of private and public keys stored on your computer (or in some other place to which you have access).  To create such keys, cryptographic algorithms are used that ensure that no one else can access your coins without physically accessing your keys.  Let's look at what these algorithms are. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Public key cryptosystem </h4><br>  Algorithms of public-key cryptosystems use key pairs: public and private.  Public keys can be reported to anyone.  Private keys, on the contrary, should not be disclosed to anyone: no one except the owner should have access to them, since these are private keys that serve as the owner's identifier.  Your face is your private keys (in the world of cryptocurrency, of course). <br><br>  In fact, a bitcoin wallet is just a couple of such keys.  When you install the wallet application or use the Bitcoin client to create a new address, a pair of keys is generated for you.  The one who controls the private key controls all the coins that were sent to it. <br><br>  Private and public keys are simply random sequences of bytes, so they cannot be printed on the screen and read by humans.  This is why Bitcoin uses an algorithm to convert public keys into a readable string. <br><br><blockquote>  If you have ever used a Bitcoin wallet as an application, it is likely that a mnemonic phrase was created for you.  Such phrases are used instead of private keys and can be used to generate them.  This mechanism is implemented in <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">BIP-039</a> . <br></blockquote><br>  So now we know what identifies users in Bitcoin.  But how does Bitcoin verify the owner of the exit transaction (and the coins that are stored there)? <br><br><h4>  Electronic digital signature </h4><br>  In mathematics and cryptography, there is the concept of electronic digital signature - algorithms that guarantee: <br><br><ol><li>  that the data has not been changed during transmission from the sender to the recipient </li><li>  that the data was created by a specific sender; </li><li>  that the sender cannot deny that he sent the data. </li></ol><br>  Applying the algorithm of electronic digital signature to the data (i.e., by signing the data), a signature is obtained, which can later be verified.  The data is signed using the private key, and the public key is required for verification. <br><br>  To sign the data, we need the following: <br><br><ol><li>  signature data; </li><li>  private key </li></ol><br>  The algorithm creates a signature that is stored in the inputs of the transaction.  To verify the signature, you need the following: <br><br><ol><li>  data that has been signed; </li><li>  signature; </li><li>  public key. </li></ol><br>  In simple terms, the verification process can be described as follows: we need to make sure that the signature is obtained from this data using the private key that was used to generate the public key. <br><blockquote>  Digital signatures are not encrypted, and data cannot be obtained from it.  This is similar to hashing: you convert data using an algorithm and get their unique representation.  The difference between the hash and the signature is the key pair that allows you to verify the latter. <br>  But such key pairs can also be used to encrypt data: the private key is used for encryption, and the public key is used for decryption.  However, Bitcoin does not use encryption algorithms. <br></blockquote><br>  Each transaction entry in Bitcoin is signed by those who created this transaction.  Each transaction in Bitcoin must be verified before placing it in a block.  Verification means (besides other procedures): <br><br><ol><li>  Verify that the inputs have sufficient rights to use the outputs from previous transactions. </li><li>  Verifying the signature of a transaction. </li></ol><br>  Schematically, the process of signing and verifying data is as follows: <br><br><img src="https://habrastorage.org/webt/5e/rq/kt/5erqktmmvdlxonlpenc_nlxib9y.png"><br><br>  Let's take a look at the full life cycle of a transaction: <br><br><ol><li> At the very beginning there is a genesis block with a coinbase transaction.  There are no real entries in coinbase transactions, so no signature is required.  The withdrawal of the transaction contains the hashed public key ( <code>RIPEMD16(SHA256(PubKey))</code> algorithms are used <code>RIPEMD16(SHA256(PubKey))</code> ). </li><li>  When someone sends coins, a transaction is created.  Transaction entries will refer to exits from previous transactions.  Each entry will store the public key (not hashed) and the signature of the entire transaction. </li><li>  Other nodes on the Bitcoin network that receive the transaction will also check it.  Among other things, here is the comparison of the public key hash at the input of the transaction with the hash of the corresponding output (this ensures that the sender spends only the coins belonging to him);  the signature is correct (this ensures that the transaction is created by the real owner of the coins). </li><li>  When the node is ready for mining a new block, it will put the transaction in the block and start mining it. </li><li>  When the block is mined, every other node in the network receives a message that the block has been mined and adds it to the chain. </li><li>  After the block is added to the chain, the transaction is completed, now its outputs can be referenced in new transactions. </li></ol><br><h4>  Elliptical cryptography </h4><br>  As we already spoke with you, public and private keys are sequences of random bytes.  We do not want to generate a private key belonging to someone else, so there is a need for a special algorithm for generating sequences. <br><br>  Bitcoin uses elliptic curves to generate secret keys.  Elliptic curves are a complex mathematical concept, which we will not explain in detail here (if interested, you can read about it <a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">here.</a> <b>WARNING</b> : a lot of mathematics!).  The curve used by Bitcoin can randomly select a number between 0 and 2¬≤‚Åµ‚Å∂ (which is approximately 10‚Å∑‚Å∑, note, the atoms in the visible universe are somewhere between 10 and 10‚Å∏¬≤).  Such a limit means that it is <i>almost</i> impossible to generate the same private key twice. <br><br>  In addition, Bitcoin uses (and we will) the <a href="https://ru.wikipedia.org/wiki/ECDSA">ECDSA</a> algorithm to sign transactions. <br><br><h4>  Base58 </h4><br>  Now let's go back to the above address 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa.  We now know that this is a public-key representation of a public key.  And if we decode it, it will look something like this (as a sequence of bytes written in hexadecimal): <br><br><pre> <code class="bash hljs">0062E907B15CBF27D5425399EBF6F0FB50EBB88F18C29B7D93</code> </pre> <br>  Bitcoin uses the Base58 algorithm to convert public keys into human-readable format.  The algorithm is very similar to the well-known Base64, but it uses a shorter alphabet: some letters have been removed from the alphabet to avoid <a href="https://en.wikipedia.org/wiki/IDN_homograph_attack">homographic attacks</a> .  In this regard, the following symbols are missing in this alphabet: 0 (zero), O (capital letter ‚Äúo‚Äù), I (capital letter ‚Äúi‚Äù), l (lower case ‚ÄúL‚Äù) as well as the signs ‚Äú+‚Äù and ‚Äú/ ". <br><br>  The process of getting an address from a public key looks like this: <br><br><img src="https://habrastorage.org/webt/0p/vp/jt/0pvpjtnmnngmdjlzzf4yolsbfz0.png"><br><br>  Following this scheme, the key that we cited above is divided into three parts: <br><br><pre> <code class="bash hljs">Version 00 Public key <span class="hljs-built_in"><span class="hljs-built_in">hash</span></span> 62E907B15CBF27D5425399EBF6F0FB50EBB88F18 Checksum C29B7D93</code> </pre><br>  Well, now that we put the pieces together, it's time to write the code!  I hope that now everything that was incomprehensible will become clear. <br><br><h4>  Implementation of addresses </h4><br>  Let's start with the structure of the wallet wallet <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Wallet <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { PrivateKey ecdsa.PrivateKey PublicKey []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Wallets <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Wallets <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]*Wallet } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewWallet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Wallet</span></span></span></span> { private, public := newKeyPair() wallet := Wallet{private, public} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;wallet } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newKeyPair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ecdsa.PrivateKey, []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { curve := elliptic.P256() private, err := ecdsa.GenerateKey(curve, rand.Reader) pubKey := <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *private, pubKey }</code> </pre><br>  A wallet is nothing but a pair of keys.  We will also need the <code>Wallets</code> type to store a collection of wallets, save them to a file and unload them from it.  A new key pair is created in the <code>Wallet</code> constructor.  The <code>newKeyPair</code> function <code>newKeyPair</code> simple, here we use ECDSA.  The private key is then created using a curve, and the public key is generated using the private key.  One note: in elliptic curve based algorithms, public keys are points on a curve.  Thus, a public key is a combination of X, Y coordinates. In Bitcoin, these coordinates are combined to form a public key. <br><br>  Now, let's create an address generation function: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w Wallet)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAddress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { pubKeyHash := HashPubKey(w.PublicKey) versionedPayload := <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>{version}, pubKeyHash...) checksum := checksum(versionedPayload) fullPayload := <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(versionedPayload, checksum...) address := Base58Encode(fullPayload) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> address } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HashPubKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pubKey []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { publicSHA256 := sha256.Sum256(pubKey) RIPEMD160Hasher := ripemd160.New() _, err := RIPEMD160Hasher.Write(publicSHA256[:]) publicRIPEMD160 := RIPEMD160Hasher.Sum(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> publicRIPEMD160 } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checksum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(payload []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> []</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte</span></span></span></span> { firstSHA := sha256.Sum256(payload) secondSHA := sha256.Sum256(firstSHA[:]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> secondSHA[:addressChecksumLen] }</code> </pre><br>  Let us step by step the conversion of the public key to the Base58 address: <br><br><ol><li>  Take the public key and write it twice using the <code>RIPEMD160 (SHA256 (PubKey))</code> hashing algorithms. </li><li>  Prepare a version. </li><li>  Calculate the checksum by hashing the result from step 2 and <code>SHA256 (SHA256 (payload))</code> .  The checksum is the first four bytes of the received hash. </li><li>  Add a checksum to the combination <code>version+PubKeyHash</code> . </li><li>  Encrypt the <code>version+PubKeyHash+checksum</code> combination using Base58. </li></ol><br>  As a result, you will get a <b>real Bitcoin address</b> , you can even check its balance on <a href="https://blockchain.info/">blockchain.info</a> .  But I am more than sure that nothing will be on the bill of this address.  This is why choosing the right public key encryption algorithm is so important: given that the private keys are random numbers, the probability of generating the same number should be as small as possible.  Ideally, it should not be repeated at all. <br><br>  Please note that you do not need to connect to the Bitcoin node to get the address.  The address generation algorithm uses a combination of algorithms that are already implemented in many standard libraries of popular programming languages. <br><br>  Now we need to change the inputs and outputs to use the addresses: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TXInput <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Txid []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Vout <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Signature []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> PubKey []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(in *TXInput)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UsesKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pubKeyHash []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { lockingHash := HashPubKey(in.PubKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes.Compare(lockingHash, pubKeyHash) == <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TXOutput <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Value <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> PubKeyHash []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out *TXOutput)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { pubKeyHash := Base58Decode(address) pubKeyHash = pubKeyHash[<span class="hljs-number"><span class="hljs-number">1</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(pubKeyHash)<span class="hljs-number"><span class="hljs-number">-4</span></span>] out.PubKeyHash = pubKeyHash } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out *TXOutput)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsLockedWithKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pubKeyHash []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bytes.Compare(out.PubKeyHash, pubKeyHash) == <span class="hljs-number"><span class="hljs-number">0</span></span> }</code> </pre><br>  Please note that we no longer use the <code>ScriptPubKey</code> and <code>ScriptSig</code> , instead <code>ScriptSig</code> is divided into <code>Signature</code> and <code>PubKey</code> , and <code>ScriptPubKey</code> renamed to <code>PubKeyHash</code> .  We will implement the same functions of blocking / unblocking outputs and logic of input signatures, as in Bitcoin, but we will implement this using methods. <br><br>  The <code>UsesKey</code> method verifies that the input uses a specific key to unlock the output.  Please note that the inputs store unshaded public keys, and the function accepts hashed.  <code>IsLockedWithKey</code> checks if the hash key of the public key was used to block the output.  This is an optional feature for <code>UsesKey</code> , and both are used in <code>FindUnspentTransactions</code> to build connections between transactions. <br><br>  <code>Lock</code> simply blocks the exit.  When we send coins to someone, we only know the address, so the function takes the address as the only argument.  Then the address is decoded, and the public key hash key is extracted from it and stored in the <code>PubKeyHash</code> field. <br><br>  Now let's check that everything works correctly: <br><br><pre> <code class="bash hljs">$ blockchain_go createwallet Your new address: 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt $ blockchain_go createwallet Your new address: 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h $ blockchain_go createwallet Your new address: 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy $ blockchain_go createblockchain -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt 0000005420fbfdafa00c093f56e033903ba43599fa7cd9df40458e373eee724d Done! $ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt Balance of <span class="hljs-string"><span class="hljs-string">'13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt'</span></span>: 10 $ blockchain_go send -from 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -to 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -amount 5 2017/09/12 13:08:56 ERROR: Not enough funds $ blockchain_go send -from 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt -to 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h -amount 6 00000019afa909094193f64ca06e9039849709f5948fbac56cae7b1b8f0ff162 Success! $ blockchain_go getbalance -address 13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt Balance of <span class="hljs-string"><span class="hljs-string">'13Uu7B1vDP4ViXqHFsWtbraM3EfQ3UkWXt'</span></span>: 4 $ blockchain_go getbalance -address 15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h Balance of <span class="hljs-string"><span class="hljs-string">'15pUhCbtrGh3JUx5iHnXjfpyHyTgawvG5h'</span></span>: 6 $ blockchain_go getbalance -address 1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy Balance of <span class="hljs-string"><span class="hljs-string">'1Lhqun1E9zZZhodiTqxfPQBcwr1CVDV2sy'</span></span>: 0</code> </pre><br>  Fine!  It's time to implement the signature transactions. <br><br><h4>  Implementation of signatures </h4><br>  Transactions must be signed, as this is the only way to guarantee Bitcoin transaction reliability.  If the signature is invalid, the transaction is considered invalid and, therefore, cannot be added to the chain. <br><br>  We have everything to implement the signature to the transaction, except for one thing: the data to be signed.  What part of the transaction should we sign?  Or is it necessary to sign the deal as a whole?  The choice of data to sign is very important.  The point is that the data to be signed must contain information that identifies the data in a unique way.  For example, it makes no sense to sign only output values, because such a signature will not take into account the sender and recipient. <br><br>  Considering that transactions unblock previous outputs, redistribute their values ‚Äã‚Äãand block new outputs, the following data should be signed: <br><br><ol><li>  Public key hashes stored in unlocked exits.  This identifies the "sender" of the transaction. </li><li>  Public key hashes stored in new, locked, exits.  This identifies the "recipient" of the transaction. </li><li>  Values ‚Äã‚Äãof new outputs. </li></ol><br><blockquote>  In Bitcoin, the lock / unlock logic is stored in scripts that are stored in the <code>ScriptSig</code> and <code>ScriptPubKey</code> input and output fields, respectively.  Because Bitcoin allows for different types of such scripts, it signs the entire contents of the <code>ScriptPubKey</code> . <br></blockquote><br>  In connection with this, in Bitcoin there is a signature not of a transaction, but of its processed copy with inputs that contain the <code>ScriptPubKey</code> specified output <br><br><blockquote>  <a href="">This</a> is a detailed process for handling a copy of a transaction.  Most likely, it is outdated, but I could not find a more reliable source of information. </blockquote><br>  It all looks quite complicated, let's start writing code.  And we begin with the <code>Sign</code> method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *Transaction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Sign</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(privKey ecdsa.PrivateKey, prevTXs </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">]Transaction)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.IsCoinbase() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } txCopy := tx.TrimmedCopy() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inID, vin := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> txCopy.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash txCopy.ID = txCopy.Hash() txCopy.Vin[inID].PubKey = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, txCopy.ID) signature := <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(r.Bytes(), s.Bytes()...) tx.Vin[inID].Signature = signature } }</code> </pre><br>  The method accepts a private key and an associative array of previous transactions.  As mentioned above, to sign a transaction, we need to access the exits specified in the transaction inputs, so we need transactions that store these exits. <br><br>  Let's take a closer look at this method: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tx.IsCoinbase() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre><br>  Coinbase transactions are not signed, as there are no real exits <br><br><pre> <code class="go hljs">txCopy := tx.TrimmedCopy()</code> </pre><br>  We sign the processed copy, not the entire transaction: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *Transaction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrimmedCopy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transaction</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inputs []TXInput <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> outputs []TXOutput <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, vin := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vin { inputs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(inputs, TXInput{vin.Txid, vin.Vout, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>}) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, vout := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vout { outputs = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(outputs, TXOutput{vout.Value, vout.PubKeyHash}) } txCopy := Transaction{tx.ID, inputs, outputs} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> txCopy }</code> </pre><br>  The copy will include all inputs and outputs, and <code>TXInput.Signature</code> and <code>TXInput.PubKey</code> will be equal to nil. <br><br>  Then go through each entry in the copy: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inID, vin := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> txCopy.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash</code> </pre><br>  At each input, the <code>Signature</code> set to nil (just a double check), and <code>PubKey</code> assigned a link to the exit to <code>PubKeyHash</code> .  At the moment, all transactions, except for the current one, are ‚Äúempty‚Äù, that is, the signature and <code>PubKey</code> are zero.  Thus, the <i>inputs are signed separately</i> , although this is not necessary for our application, but Bitcoin allows transactions to contain inputs that refer to different addresses. <br><br><pre> <code class="go hljs"> txCopy.ID = txCopy.Hash() txCopy.Vin[inID].PubKey = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre><br>  The <code>Hash</code> method serializes a transaction and hashes it using the SHA-256 algorithm.  The result is data ready for signature.  After receiving the hash, we have to reset the <code>PubKey</code> field <code>PubKey</code> that there is no impact on our further iterations. <br><br><pre> <code class="go hljs"> r, s, err := ecdsa.Sign(rand.Reader, &amp;privKey, txCopy.ID) signature := <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(r.Bytes(), s.Bytes()...) tx.Vin[inID].Signature = signature</code> </pre><br>  We sign <code>txCopy.ID</code> with <code>privKey</code> .  The ECDSA signature is a pair of numbers that we combine and store in the <code>Signature</code> input field. <br><br>  Consider the verification function: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *Transaction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Verify</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(prevTXs </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">map</span></span></span></span><span class="hljs-function"><span class="hljs-params">[</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">]Transaction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { txCopy := tx.TrimmedCopy() curve := elliptic.P256() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inID, vin := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash txCopy.ID = txCopy.Hash() txCopy.Vin[inID].PubKey = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> r := big.Int{} s := big.Int{} sigLen := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(vin.Signature) r.SetBytes(vin.Signature[:(sigLen / <span class="hljs-number"><span class="hljs-number">2</span></span>)]) s.SetBytes(vin.Signature[(sigLen / <span class="hljs-number"><span class="hljs-number">2</span></span>):]) x := big.Int{} y := big.Int{} keyLen := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(vin.PubKey) x.SetBytes(vin.PubKey[:(keyLen / <span class="hljs-number"><span class="hljs-number">2</span></span>)]) y.SetBytes(vin.PubKey[(keyLen / <span class="hljs-number"><span class="hljs-number">2</span></span>):]) rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ecdsa.Verify(&amp;rawPubKey, txCopy.ID, &amp;r, &amp;s) == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  The method is quite simple.  First, get a copy of the transaction, as in the past method: <br><br><pre> <code class="go hljs">txCopy := tx.TrimmedCopy()</code> </pre><br>  Then we need a curve that is used to generate key pairs: <br><br><pre> <code class="go hljs">curve := elliptic.P256()</code> </pre><br>  Then go through all the entrances and verify that they are signed: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inID, vin := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vin { prevTx := prevTXs[hex.EncodeToString(vin.Txid)] txCopy.Vin[inID].Signature = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> txCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash txCopy.ID = txCopy.Hash() txCopy.Vin[inID].PubKey = <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre><br>  This part is identical to that used in the Sign method, since during the test we need the same data that we signed <br><br><pre> <code class="go hljs"> r := big.Int{} s := big.Int{} sigLen := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(vin.Signature) r.SetBytes(vin.Signature[:(sigLen / <span class="hljs-number"><span class="hljs-number">2</span></span>)]) s.SetBytes(vin.Signature[(sigLen / <span class="hljs-number"><span class="hljs-number">2</span></span>):]) x := big.Int{} y := big.Int{} keyLen := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(vin.PubKey) x.SetBytes(vin.PubKey[:(keyLen / <span class="hljs-number"><span class="hljs-number">2</span></span>)]) y.SetBytes(vin.PubKey[(keyLen / <span class="hljs-number"><span class="hljs-number">2</span></span>):])</code> </pre><br>  Here we unpack the values ‚Äã‚Äãstored in <code>TXInput.Signature</code> and <code>TXInput.PubKey</code> , since the signature is a pair of numbers, and the public key is a pair of coordinates.  We have concatenated them before for storage, and now we need to unpack them for use in the <code>crypto/ecdsa</code> . <br><br><pre> <code class="go hljs"> rawPubKey := ecdsa.PublicKey{curve, &amp;x, &amp;y} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ecdsa.Verify(&amp;rawPubKey, txCopy.ID, &amp;r, &amp;s) == <span class="hljs-literal"><span class="hljs-literal">false</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br>  Now we create <code>ecdsa.PublicKey</code> using the public key, which we take from the input, and execute <code>ecdsa.Verify</code> , passing the signature, from the input.  If all entries are verified, we return true;  if at least one entry fails validation, return false. <br><br>  Now we need a function to get previous transactions.  Since this requires interaction with the entire chain, we will make it the <code>Blockchain</code> method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ID []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Transaction, error)</span></span></span></span> { bci := bc.Iterator() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { block := bci.Next() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tx := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> block.Transactions { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bytes.Compare(tx.ID, ID) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *tx, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(block.PrevBlockHash) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Transaction{}, errors.New(<span class="hljs-string"><span class="hljs-string">"Transaction is not found"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SignTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *Transaction, privKey ecdsa.PrivateKey)</span></span></span></span> { prevTXs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]Transaction) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, vin := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vin { prevTX, err := bc.FindTransaction(vin.Txid) prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX } tx.Sign(privKey, prevTXs) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VerifyTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tx *Transaction)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { prevTXs := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]Transaction) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, vin := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> tx.Vin { prevTX, err := bc.FindTransaction(vin.Txid) prevTXs[hex.EncodeToString(prevTX.ID)] = prevTX } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tx.Verify(prevTXs) }</code> </pre><br>  <code>FindTransaction</code> finds a transaction by identifier (this requires iteration over all blocks in the chain);  <code>SignTransaction</code> takes one transaction, finds the transactions to which it refers, and signs it;  <code>VerifyTransaction</code> simply verifies the transaction. <br><br>  Now we need to sign and verify transactions.  We will sign in the <code>NewUTXOTransaction</code> method: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewUTXOTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from, to </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bc *Blockchain)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transaction</span></span></span></span> { ... tx := Transaction{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, inputs, outputs} tx.ID = tx.Hash() bc.SignTransaction(&amp;tx, wallet.PrivateKey) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;tx }</code> </pre><br>  Verification of the transaction occurs before it is added to the block: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(bc *Blockchain)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MineBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(transactions []*Transaction)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastHash []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tx := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> transactions { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> bc.VerifyTransaction(tx) != <span class="hljs-literal"><span class="hljs-literal">true</span></span> { log.Panic(<span class="hljs-string"><span class="hljs-string">"ERROR: Invalid transaction"</span></span>) } } ... }</code> </pre><br>  That's all!  Let's check again: <br><br><pre> <code class="bash hljs">$ blockchain_go createwallet Your new address: 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR $ blockchain_go createwallet Your new address: 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab $ blockchain_go createblockchain -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR 000000122348da06c19e5c513710340f4c307d884385da948a205655c6a9d008 Done! $ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 6 0000000f3dbb0ab6d56c4e4b9f7479afe8d5a5dad4d2a8823345a1a16cf3347b Success! $ blockchain_go getbalance -address 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR Balance of <span class="hljs-string"><span class="hljs-string">'1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR'</span></span>: 4 $ blockchain_go getbalance -address 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab Balance of <span class="hljs-string"><span class="hljs-string">'1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab'</span></span>: 6</code> </pre><br>  We didn't even break anything, amazing! <br><br>  Let's comment out the <code>bc.SignTransaction (&amp; tx, wallet.PrivateKey)</code> in <code>NewUTXOTransaction</code> , to ensure that unsigned transactions cannot be minted: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewUTXOTransaction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(from, to </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, bc *Blockchain)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Transaction</span></span></span></span> { ... tx := Transaction{<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, inputs, outputs} tx.ID = tx.Hash() <span class="hljs-comment"><span class="hljs-comment">// bc.SignTransaction(&amp;tx, wallet.PrivateKey) return &amp;tx }</span></span></code> </pre><br><pre> <code class="bash hljs">$ go install $ blockchain_go send -from 1AmVdDvvQ977oVCpUqz7zAPUEiXKrX5avR -to 1NE86r4Esjf53EL7fR86CsfTZpNN42Sfab -amount 1 2017/09/12 16:28:15 ERROR: Invalid transaction</code> </pre><br><h4>  Conclusion </h4><br>  We have implemented almost all the key features of Bitcoin and this is amazing.  And in the next part, we will finally complete the implementation of transactions. <br><br><h4>  Links </h4><br><ol><li>  <a href="https://github.com/Jeiwan/blockchain_go/tree/part_5">Full source codes</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Public-key_cryptography">Public-key cryptography</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Digital_signature">Digital signatures</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Elliptic_curve">Elliptic curve</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography">Elliptic curve cryptography</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">Ecdsa</a> </li><li>  <a href="https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses">Technical background of Bitcoin addresses</a> </li><li>  <a href="https://en.bitcoin.it/wiki/Address">Address</a> </li><li>  <a href="https://en.bitcoin.it/wiki/Base58Check_encoding">Base58</a> </li><li>  <a href="http://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/">Elliptic curve cryptography</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/351834/">https://habr.com/ru/post/351834/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../351824/index.html">A look at Tokio: how this asynchronous event handler works</a></li>
<li><a href="../351826/index.html">A couple of stories about RAID'ersky lawlessness</a></li>
<li><a href="../351828/index.html">Welcome to Badoo PHP Meetup April 7</a></li>
<li><a href="../351830/index.html">The Department of Information Technology, Communications and Information Protection of the City of N requires ...</a></li>
<li><a href="../351832/index.html">‚ÄúTolik - sweetheart‚Äù, or as we did a survey of IT-satisfaction for 20 thousand people</a></li>
<li><a href="../351836/index.html">Sound games: an invisible market awaits heroes</a></li>
<li><a href="../351838/index.html">Waited for: YAML and Ansible support (no cows) in dapp</a></li>
<li><a href="../351842/index.html">"From Japan to Singapore": a new submarine cable will pass through 9 countries in Asia</a></li>
<li><a href="../351844/index.html">Thymeleaf Tutorial: Chapter 8. Template Layout</a></li>
<li><a href="../351846/index.html">VR in our life: travel, tours and pornography</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>