<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We consider Pi in parallel. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this series of posts, we will try to solve one simple problem using more or less relevant parallel programming technologies (Native streams, OpenMP...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We consider Pi in parallel. Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/5a0/4ae/75d/5a04ae75dd347ab4d02f1424d733d465.png"><br>  In this series of posts, we will try to solve one simple problem using more or less relevant parallel programming technologies (Native streams, OpenMP, TBB, MPI, CUDA, OpenCL, OpenACC, Chapel, there may be something more exotic. As if comparatively in hands -on the key. <br><a name="habracut"></a><br>  So that everything fits in one post (in several parts) and in general could be cumulatively covered by attention, the problem was deliberately trivial chosen.  Therefore, many aspects of the mentioned technologies and the main difficulties that arise during the actual programming of modern massively parallel systems will remain behind the scenes.  Also, do not use the examples and examples as a benchmark "GPU vs. CPU" or something like that.  The only goal is to show "how it works."  The post is designed for people with parallel programming is not very familiar.  Under the cut there will be a lot of code.  Actually we will consider the number Pi by numerical integration <img src="https://habrastorage.org/storage2/9a5/02b/ee9/9a502bee9982b008856091f94c53b6e7.gif" alt="image"><br><br>  Source codes are also available at <a href="https://github.com/undertherain/pi">github.com/undertherain/pi</a> (will be added as you write the following parts of the post). <br><br><h2>  Sequential version. </h2><br>  Let's first make a consistent version.  Those.  one that uses the same core of a conventional CPU.  Let us take the simplest of the numerical methods of integration ‚Äî the method of rectangles and code it in the C language (in general, we will use C \ C ++ surzhik for several reasons. <br>  <font color="#000080">Let's</font> declare a certain number of <font color="#000080">cntSteps of</font> rectangles into which we will divide our area under the integral, we will calculate the base: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs">step = <span class="hljs-number"><span class="hljs-number">1.</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(cntSteps);</code> </pre> <br><br>  and the entire area, counting the value of the function in each rectangle and multiplying it on the base. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;cntSteps; i++) { x = ( i + <span class="hljs-number"><span class="hljs-number">.5</span></span> ) *step; sum = sum + <span class="hljs-number"><span class="hljs-number">4.0</span></span>/(<span class="hljs-number"><span class="hljs-number">1.</span></span>+ x*x); }</code> </pre><br><br>  However, we will multiply on the basis of <font color="#000080">step,</font> we are better off  behind the cycle - that's basically all. <br><br>  Here is the complete program code: <br><br><pre> <code class="hljs django"><span class="xml"><span class="xml">#include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iostream</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">iomanip</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">sys</span></span></span></span><span class="xml"><span class="hljs-tag">/</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">times.h</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> #include </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">cmath</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> int main(int argc, char** argv) { const unsigned long cntSteps=500000000; /* # of rectangles */ double step; const double PI25DT = 3.141592653589793238462643; //reference Pi value double pi=0; double sum=0.0; double x; std::cout</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">calculating</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pi</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">on</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">CPU</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">single-threaded</span></span></span></span><span class="xml"><span class="hljs-tag">\</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">"; //  </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">clock_t</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">clockStart</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">clockStop</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">tms</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">tmsStart</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">tmsStop</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">clockStart</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">times(&amp;tmsStart);</span></span></span></span><span class="xml"><span class="hljs-tag"> //      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">step</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">1./static_cast</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">double</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(cntSteps); for (unsigned long i=0; i</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">cntSteps;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">++) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">(i</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.5</span></span></span></span><span class="xml"><span class="hljs-tag">)*</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">step</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">sum</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">sum</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">4.0</span></span></span></span><span class="xml"><span class="hljs-tag">/(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1.</span></span></span></span><span class="xml"><span class="hljs-tag">+ </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span></span><span class="xml"><span class="hljs-tag">*</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">x</span></span></span></span><span class="xml"><span class="hljs-tag">); } </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pi</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">sum*step;</span></span></span></span><span class="xml"><span class="hljs-tag"> //      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">clockStop</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">times(&amp;tmsStop);</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">The</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">of</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PI</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">is</span></span></span></span><span class="xml"><span class="hljs-tag"> " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pi</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Error</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">is</span></span></span></span><span class="xml"><span class="hljs-tag"> " &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">fabs</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pi</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PI25DT</span></span></span></span><span class="xml"><span class="hljs-tag">) &lt;&lt; "\</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">"; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">std::cout</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">The</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">time</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">calculate</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">PI</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">was</span></span></span></span><span class="xml"><span class="hljs-tag"> " ; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">double</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">secs</span></span></span></span><span class="xml"><span class="hljs-tag">= </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">(clockStop</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">clockStart</span></span></span></span><span class="xml"><span class="hljs-tag">)/</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">static_cast</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">double</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(sysconf(_SC_CLK_TCK)); std::cout </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">secs</span></span></span></span><span class="xml"><span class="hljs-tag"> &lt;&lt; " </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">seconds</span></span></span></span><span class="xml"><span class="hljs-tag">\</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">"; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">0</span></span></span></span><span class="xml"><span class="hljs-tag">; }</span></span></span></span></code> </pre><br><br>  A copy of the link <a href="http://dumpz.org/195276/">http://dumpz.org/195276/</a> . <br><br><h2>  Native threads </h2><br>  Perhaps the most accessible parallel architecture for simple users is a regular multi-core processor (it seems difficult now to find a processor with one core) or several processors on one motherboard.  In principle, one core is able to execute in parallel a few threads - this mode is called pseudo-parallel or competitive.  The kernel switches between processes (a process is roughly a program in memory), allocating a time slice to each.  In principle, such a mode of execution can already lead to an increase in performance due to hiding the memory latency, if not on conventional "home" processors, then on specialized multi-threaded, but more on that later.  In our case, an excess of threads would slow down due to the overhead of switching between threads. <br><br>  The most "historical" way to use several cores on a processor at once is the mechanism of operating system threads, which existed long before true-parallel processors for competition at least for the sake of more convenient writing of programs.  From a programmer's point of view, it is important that parallel threads executed on different cores or processors see the same address space, that is, there is no need to explicitly transfer data between threads.  But if all of a sudden different threads write / read the same variable, then you have to attend to synchronization. <br><br>  Okay, let's get closer to the code: from the point of view of the C language, the stream is a normal function or class method that satisfies a certain prototype.  Let's call it <b><font color="#0000FF">static</font></b> <font color="#009900">void</font> <font color="#990000">*</font> <b><font color="#000000">worker</font></b> <font color="#990000">(</font> <font color="#009900">void</font> <font color="#990000">*</font> <font color="#000080">ptrArgs</font> <font color="#990000">)</font> , with an argument it gets a pointer to a structure in which you can make as many fields as necessary to pass its arguments to the stream.  In our case, we say the streaming function in which range we assume our integral.  In the body of the streaming function, we already know the cycle that counts according to the range that we passed to it in the parameters. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> i=args-&gt;left; i&lt;args-&gt;right; i++) { x = (i + <span class="hljs-number"><span class="hljs-number">.5</span></span>)*step; sum = sum + <span class="hljs-number"><span class="hljs-number">4.0</span></span>/(<span class="hljs-number"><span class="hljs-number">1.</span></span>+ x*x); }</code> </pre><br><br>  The integration interval for each stream we will calculate in advance based on its sequence number.  If one of the threads considers its part earlier, then the corresponding core will be idle, i.e.  we will lose productivity.  It would be ideal to divide the interval into many small sections and distribute to the streams as they do their job.  But for now let's leave it as it is. <br><br><pre> <code class="cpp hljs">arrArgsThread[idThread].left = idThread*cntStepsPerThread; arrArgsThread[idThread].right = (idThread+<span class="hljs-number"><span class="hljs-number">1</span></span>)*cntStepsPerThread;</code> </pre><br><br>  For execution by a separate thread, the function is launched via the pthread_create system call in the POSIX case (in Linux, for example) or in the case of windows there will be a similar call from the Win32 API, it will look a little different, but it looks altogether. <br><br>  The result of each thread will be added to the general variable <font color="#000080">pi</font> <font color="#990000">+ =</font> <font color="#000080">sum</font> <font color="#990000">*</font> <font color="#000080">step</font> <font color="#990000">;</font>  (remember that we are in the general address space). <br><br>  So that the memory does not deteriorate if two threads simultaneously change one cell, we need to somehow guarantee that at one time only one thread gets access to the variable pi, i.e.  create a so-called "critical section".  To do this, you can use a special operating system mechanism called mutex (from the word mutual exclusion) - if one thread has blocked a mutex, another thread will wait (trying to get the mutex itself) until the first thread ‚Äúreleases‚Äù it. <br><br><pre> <code class="cpp hljs">pthread_mutex_lock(&amp;mutexReduction); pi += sum*step; pthread_mutex_unlock(&amp;mutexReduction);</code> </pre><br>  Total goes something like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; #include &lt;cstdlib&gt; #include &lt;pthread.h&gt; #include &lt;sys/times.h&gt; #define cntThreads 4 pthread_mutex_t mutexReduction; double pi=0.; //      struct ArgsThread { long long left,right; double step; }; //  static void *worker(void *ptrArgs) { ArgsThread * args = reinterpret_cast&lt;ArgsThread *&gt;(ptrArgs); double x; double sum=0.; double step=args-&gt;step; for (long long i=args-&gt;left; i&lt;args-&gt;right; i++) { x = (i + .5)*step; sum = sum + 4.0/(1.+ x*x); } pthread_mutex_lock(&amp;mutexReduction); pi += sum*step; pthread_mutex_unlock(&amp;mutexReduction); return NULL; } int main(int argc, char** argv) { const unsigned long num_steps=500000000; const double PI25DT = 3.141592653589793238462643; pthread_t threads[cntThreads]; ArgsThread arrArgsThread[cntThreads]; std::cout&lt;&lt;"POSIX threads. number of threads = "&lt;&lt;cntThreads&lt;&lt;std::endl; clock_t clockStart, clockStop; tms tmsStart, tmsStop; clockStart = times(&amp;tmsStart); double step = 1./(double)num_steps; long long cntStepsPerThread= num_steps / cntThreads; //          for (unsigned int idThread=0; idThread&lt;&lt;cntThreads; idThread++) { arrArgsThread[idThread].left = idThread*cntStepsPerThread; arrArgsThread[idThread].right = (idThread+1)*cntStepsPerThread; arrArgsThread[idThread].step = step; if (pthread_create(&amp;threads[idThread], NULL, worker, &amp;arrArgsThread[idThread]) != 0) { return EXIT_FAILURE; } } //        join for (unsigned int idThread=0; idThread&lt;cntThreads; idThread++) { if (pthread_join(threads[idThread], NULL) != 0) { return EXIT_FAILURE; } } //! clockStop = times(&amp;tmsStop); std::cout &lt;&lt; "The value of PI is " &lt;&lt; pi &lt;&lt; " Error is " &lt;&lt; fabs(pi - PI25DT) &lt;&lt; std::endl; std::cout &lt;&lt; "The time to calculate PI was " ; double secs= (clockStop - clockStart)/static_cast&lt;double&gt;(sysconf(_SC_CLK_TCK)); std::cout &lt;&lt; secs &lt;&lt; " seconds\n" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br><br>  A copy on <a href="http://dumpz.org/195404/">http://dumpz.org/195404/</a> in case if someone has my hellish formatting displayed irregularly. <br><br>  In fact, specifically in this example (but it will not always be <font color="#000080">lucky</font> ), it was possible to do without mutexes if you store the result in each thread into a separate variable ( <font color="#000080">ArgsThread</font> array <font color="#000080">element</font> <font color="#000080">arrArgsThread</font> <font color="#990000">[</font> <font color="#000080">cntThreads</font> <font color="#990000">];</font> <br>  ) and then, having waited for the completion of all the flows, sum up what happened. <br><br>  Here is the code without mutexes: <br><br><pre> <code class="hljs vbscript">#include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; #include &lt;cstdlib&gt; #include &lt;pthread.h&gt; #include &lt;sys/times.h&gt; #define cntThreads <span class="hljs-number"><span class="hljs-number">4</span></span> struct ArgsThread { long long <span class="hljs-built_in"><span class="hljs-built_in">left</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">right</span></span>; double <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; double partialSum; }; static void *worker(void *ptrArgs) { ArgsThread * args = reinterpret_cast&lt;ArgsThread *&gt;(ptrArgs); double x; double sum=<span class="hljs-number"><span class="hljs-number">0.</span></span>; double <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>=args-&gt;<span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (long long i=args-&gt;<span class="hljs-built_in"><span class="hljs-built_in">left</span></span>; i&lt;args-&gt;<span class="hljs-built_in"><span class="hljs-built_in">right</span></span>; i++) { x = (i + <span class="hljs-number"><span class="hljs-number">.5</span></span>)*<span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; sum = sum + <span class="hljs-number"><span class="hljs-number">4.0</span></span>/(<span class="hljs-number"><span class="hljs-number">1.</span></span>+ x*x); } args-&gt;partialSum=sum*<span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; return <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> main(<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> argc, char** argv) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> unsigned long num_steps=<span class="hljs-number"><span class="hljs-number">500000000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> double PI25DT = <span class="hljs-number"><span class="hljs-number">3.141592653589793238462643</span></span>; pthread_t threads[cntThreads]; ArgsThread arrArgsThread[cntThreads]; std::cout&lt;&lt;<span class="hljs-string"><span class="hljs-string">"POSIX threads. number of threads = "</span></span>&lt;&lt;cntThreads&lt;&lt;std::endl; clock_t clockStart, clockStop; tms tmsStart, tmsStop; clockStart = times(&amp;tmsStart); double <span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = <span class="hljs-number"><span class="hljs-number">1.</span></span>/(double)num_steps; long long cntStepsPerThread= num_steps / cntThreads; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> idThread=<span class="hljs-number"><span class="hljs-number">0</span></span>; idThread&lt;cntThreads; idThread++) { arrArgsThread[idThread].<span class="hljs-built_in"><span class="hljs-built_in">left</span></span> = idThread*cntStepsPerThread; arrArgsThread[idThread].<span class="hljs-built_in"><span class="hljs-built_in">right</span></span> = (idThread+<span class="hljs-number"><span class="hljs-number">1</span></span>)*cntStepsPerThread; arrArgsThread[idThread].<span class="hljs-keyword"><span class="hljs-keyword">step</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pthread_create(&amp;threads[idThread], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, worker, &amp;arrArgsThread[idThread]) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { return EXIT_FAILURE; } } double pi=<span class="hljs-number"><span class="hljs-number">0.</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (unsigned <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> idThread=<span class="hljs-number"><span class="hljs-number">0</span></span>; idThread&lt;cntThreads; idThread++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pthread_join(threads[idThread], <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) != <span class="hljs-number"><span class="hljs-number">0</span></span>) { return EXIT_FAILURE; } pi +=arrArgsThread[idThread].partialSum; } clockStop = times(&amp;tmsStop); std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"The value of PI is "</span></span> &lt;&lt; pi &lt;&lt; <span class="hljs-string"><span class="hljs-string">" Error is "</span></span> &lt;&lt; fabs(pi - PI25DT) &lt;&lt; std::endl; std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"The time to calculate PI was "</span></span> ; double secs= (clockStop - clockStart)/static_cast&lt;double&gt;(sysconf(_SC_CLK_TCK)); std::cout &lt;&lt; secs &lt;&lt; <span class="hljs-string"><span class="hljs-string">" seconds\n"</span></span> &lt;&lt; std::endl; return <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  And a copy at <a href="http://dumpz.org/195415/">http://dumpz.org/195415/</a> . <br><br>  As you can see, the code turned out to be rather cumbersome and non-platform.  If the latter is solved partly with the help of boost :: threads (but not everyone wants to put a boost) or in the new C ++ 11 threads generally become part of the language (in fact, it turned out very well) - but most of the software still uses the old C ++.  But the problem of bulkiness of the code still remains. <br><br><h2>  Openmp </h2><br>  OpenMP is an extension of the language (C / C ++ / Fortran) that allows you to do approximately the same thing that we did using the operating system thread APIs - but much simpler and more concise with the help of so-called pragmas.  The pragma as if tells the compiler to ‚Äútake this code and execute it in parallel‚Äù - and the communicator does the rest. <br>  To parallelize the for loop in our first sequential example, it suffices to add one line there: <br><pre> <code class="hljs vbscript">#pragma omp parallel <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> (x), reduction (+:sum) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;numSteps; i++) { x = (i + <span class="hljs-number"><span class="hljs-number">.5</span></span>)*<span class="hljs-keyword"><span class="hljs-keyword">step</span></span>; sum = sum + <span class="hljs-number"><span class="hljs-number">4.0</span></span>/(<span class="hljs-number"><span class="hljs-number">1.</span></span>+ x*x); }</code> </pre><br>  This pragma says that you need to parallelize the loop loop, make the variable x private for each stream, change the sum variable, and then perform a reduction (or how is it in Russian?) by summation.  Those.  first create one copy for each stream ‚Äî and then add them up.  Approximately the same thing that we did in the past example without mutecos.  OpenMP also provides a small API for service needs. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;sys/times.h&gt; #include &lt;cmath&gt; #include &lt;omp.h&gt; int main(int argc, char** argv) { const unsigned long numSteps=500000000; /* default # of rectangles */ double step; double PI25DT = 3.141592653589793238462643; double pi=0; double sum=0.0; double x; #pragma omp parallel { #pragma omp master { int cntThreads=omp_get_num_threads(); std::cout&lt;&lt;"OpenMP. number of threads = "&lt;&lt;cntThreads&lt;&lt;std::endl; } } clock_t clockStart, clockStop; tms tmsStart, tmsStop; step = 1./static_cast&lt;double&gt;(numSteps); clockStart = times(&amp;tmsStart); #pragma omp parallel for private (x), reduction (+:sum) for (int i=0; i&lt;numSteps; i++) { x = (i + .5)*step; sum = sum + 4.0/(1.+ x*x); } pi = sum*step; clockStop = times(&amp;tmsStop); std::cout &lt;&lt; "The value of PI is " &lt;&lt; pi &lt;&lt; " Error is " &lt;&lt; fabs(pi - PI25DT) &lt;&lt; std::endl; std::cout &lt;&lt; "The time to calculate PI was " ; double secs= (clockStop - clockStart)/static_cast&lt;double&gt;(sysconf(_SC_CLK_TCK)); std::cout &lt;&lt; secs &lt;&lt; " seconds\n" &lt;&lt; std::endl; return 0; }</span></span></span></span></code> </pre><br><br>  A copy of <a href="http://dumpz.org/195550/">http://dumpz.org/195550/</a> . <br>  Compile with the -fopenmp option in the case of g ++; in the case of another compiler, refer to the user manual. <br><br>  Questions and comments are welcomed, continued - should! </div><p>Source: <a href="https://habr.com/ru/post/147796/">https://habr.com/ru/post/147796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../147789/index.html">The challenge of the competition ICFPC-2012: the robot and Œª</a></li>
<li><a href="../147790/index.html">1532 days without code changes</a></li>
<li><a href="../147791/index.html">And if you compare the level of development of the communities of Habrahabr and Russian (!) Wikipedia, it turns out:</a></li>
<li><a href="../147793/index.html">GNU / Linux and the device on Rockchip 2918</a></li>
<li><a href="../147795/index.html">What are you striving for in your IT career? (Assume the same income of all options)</a></li>
<li><a href="../147797/index.html">If your life depends on the doctor, let it be a military doctor</a></li>
<li><a href="../147798/index.html">ICFPC 2012 with crowdsourcing and neural networks</a></li>
<li><a href="../147799/index.html">XNA Draw: improving the graphics of the game</a></li>
<li><a href="../147800/index.html">Does Rostelecom not have enough money for the development of LTE?</a></li>
<li><a href="../147802/index.html">Microsoft opens Bing Fund business incubator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>