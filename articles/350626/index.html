<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Flask Mega-Tutorial, Part XIV: Ajax</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="(edition 2018) 
 Miguel grinberg 



 There 


 This is the fourteenth part of the Flask, k Mega-Tutorial, in which I am going to add a real-time text...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Flask Mega-Tutorial, Part XIV: Ajax</h1><div class="post__text post__text-html js-mediator-article"><h2 id="izdanie-2018">  (edition 2018) </h2><br><h3 id="miguel-grinberg">  <em>Miguel grinberg</em> </h3><br><hr><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habrahabr.ru/post/350148/">There</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  This is the fourteenth part of the Flask, k Mega-Tutorial, in which I am going to add a real-time text translation function using the Microsoft translation service and some JavaScript. </p><a name="habracut"></a><br><p>  Under the spoiler is a list of all articles in this 2018 series. </p><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><ul><li>  <a href="https://habrahabr.ru/post/346306/"><strong>Chapter 1: Hello world!</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346340/"><strong>Chapter 2: Templates</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346342/"><strong>Chapter 3: Web Forms</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346344/"><strong>Chapter 4: Database</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346346/"><strong>Chapter 5: User Logins</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346348/"><strong>Chapter 6: Profile Page and Avatars</strong></a> </li><li>  <a href="https://habrahabr.ru/post/346880/"><strong>Chapter 7: Error Handling</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347450/"><strong>Chapter 8: Subscribers, Contacts, and Friends</strong></a> </li><li>  <a href="https://habrahabr.ru/post/347926/"><strong>Chapter 9: Pagination</strong></a> </li><li>  <a href="https://habrahabr.ru/post/348566/"><strong>Chapter 10: Email Support</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349060/"><strong>Chapter 11: Reconstruction</strong></a> </li><li>  <a href="https://habrahabr.ru/post/349604/"><strong>Chapter 12: Date and Time</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350148/"><strong>Chapter 13: I18n and L10n</strong></a> </li><li>  <a href="https://habrahabr.ru/post/350626/"><strong>Chapter 14: Ajax</strong></a> (This article) </li><li>  <a href="https://habrahabr.ru/post/351218/"><strong>Chapter 15: Improving Application Structure</strong></a> </li><li>  <a href="https://habrahabr.ru/post/351900/"><strong>Chapter 16: Full Text Search</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352266/"><strong>Chapter 17: Deploying to Linux</strong></a> </li><li>  <a href="https://habrahabr.ru/post/352830/"><strong>Chapter 18: Deploying to Heroku</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353234/"><strong>Chapter 19: Deploying to Docker Containers</strong></a> </li><li>  <a href="https://habrahabr.ru/post/353804/"><strong>Chapter 20: JavaScript Magic</strong></a> </li><li>  Chapter 21: User Notifications (Available April 24, 2018) </li><li>  Chapter 22: Reference Tasks (Available May 1, 2018) </li><li>  Chapter 23: Application Programming Interfaces (APIs) (Available May 8, 2018) </li></ul></div></div><br><p>  <em>Note 1: If you are looking for old versions of this course, this is <a href="https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world-legacy" title="here">here</a> .</em> </p><br><p>  <em>Note 2: If suddenly you would like to speak in support of my (Miguel) work, or simply do not have the patience to wait for the article for a week, I (Miguel Greenberg) offer the full version of this manual (in English) in the form of an electronic book or video.</em>  <em>For more information, visit <a href="http://learn.miguelgrinberg.com/" title="learn.miguelgrinberg.com">learn.miguelgrinberg.com</a> .</em> </p><br><p>  In this article, I‚Äôm going to go to the ‚Äúsafe zone‚Äù of server-side development and work on a function that has equally important server and client components.  Have you seen the ‚ÄúTranslate‚Äù links that some sites show next to user-generated content?  These are links that trigger automatic translation of content from a user‚Äôs native language in real time.  Translated content is usually entered below the original version.  Google shows search results in foreign languages.  Facebook does this for posts.  Twitter does it for tweets.  Today I will show you how to add the same feature to Microblog! </p><br><p>  <em>GitHub links for this chapter:</em> <a href="">Browse</a> , <a href="">Zip</a> , <a href="">Diff</a> . </p><br><h2 id="servernaya-i-klientskaya-storony">  Server and client side </h2><br><p>  In the traditional server model, which I have followed so far, there is a client (a web browser that the user manages) that makes HTTP requests to the application server.  A request may simply request an HTML page, for example, when you click the " <em>profile</em> " link, or it may initiate an action, for example, when you click the <em>Submit button</em> after editing the profile information.  In both types of requests, the server performs the request by sending a new web page to the client, either directly or by redirection.  The client then replaces the current page with a new one.  This cycle repeats while the user stays on the application website.  In this model, the server does all the work, while the client simply displays web pages and accepts user input. </p><br><p>  There is another model in which the client takes a more active role.  In this model, the client issues a request to the server, and the server responds with a web page, but unlike in the previous case, not all of these pages are HTML, there are also sections of the page with code usually written in Javascript.  As soon as the client receives the page, it displays HTML fragments and executes the code.  From this point on, you have an active client that can work independently, without any contact with the server.  In a strict client application, the entire application is downloaded to the client with a request for the initial page, and then the application is executed completely on the client, only occasionally contacting the server to receive or store data and make dynamic changes to the appearance of only the first and only web page.  This type of application is called <a href="http//en.wikipedia.org/wiki/Single-page_application">Single Page Applications</a> or SPA. </p><br><p>  Most applications are a hybrid between the two models and combine the technologies of both.  My Microblog application is basically a server application, but today I will add some client-side actions to it.  To perform real-time message translations, the client browser will send asynchronous requests to the server, to which the server will respond without causing the page to refresh.  The client will then dynamically insert translations into the current page.  This method is known as <a href="http://en.wikipedia.org/wiki/Ajax_(programming)">Ajax</a> , which is a shorthand for asynchronous JavaScript and XML (although nowadays, XML is often replaced by JSON). </p><br><h2 id="rabochiy-process-perevoda-v-realnom-vremeni">  Real-time translation workflow </h2><br><p>  The application has good support for foreign languages ‚Äã‚Äãthanks to <em>Flask-Babel</em> , which will support as many languages ‚Äã‚Äãas I can find translators.  But, of course, one element is missing.  Users will write blog posts in their native languages.  Therefore, it is possible that the user will encounter posts that are written in languages ‚Äã‚Äãunknown to him.  The quality of automated translations is not always great, but in most cases it is good enough if all you want is to have a basic understanding of what the text in another language means. </p><br><p>  This is an ideal opportunity to implement AJAX service.  Note that the index or explore pages may display several messages, some of which may be in foreign languages.  If I implement the translation using traditional server-side methods, the translation request will replace the original page with a new page.  The fact is that the request to translate one of the many blog posts displayed is not large enough to require a full page refresh; this function works much better if the translated text is dynamically inserted under the source text, leaving the rest of the page intact. </p><br><p>  Realization of automated real-time translation requires several steps.  First, I need a way to determine the source language of the text to translate.  I also need to know the preferred language for each user, because I want to show the ‚Äútranslate‚Äù link only for messages written in other languages.  When the link to the translation is offered and the user clicks on it, I will need to send an AJAX request to the server, and the server will contact the third-party translation API.  After the server sends a response with the translated text, the client javascript code will dynamically insert this text into the page.  As you probably noticed, there are several non-trivial problems.  Consider them one by one. </p><br><h2 id="language-identification">  Language Identification </h2><br><p> The first problem is determining which language the entry was written in.  This is not an exact science, since it is not always possible to uniquely identify a language, but in most cases automatic detection works quite well.  Python has a good language registration library called <code>guess_language</code> .  The original version of this package is quite old and has never been ported to Python 3, so I‚Äôm going to install a derived version that supports Python 2 and 3: </p><br><pre> <code class="hljs sql">(venv) $ pip <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> guess-language_spirit</code> </pre> <br><p>  The plan is to feed each blog post to this package to try to determine the language.  Since this analysis takes a lot of time, I don‚Äôt want to repeat this work every time a message is displayed on a page.  What I'm going to do is set the source language for the message at the time it was sent.  The detected language will then be stored in the Posts table. </p><br><p>  The first step is to add the <code>language</code> field to the <code>Post</code> model: </p><br><blockquote>  <em>app / models.py</em> : Add model to Post model. </blockquote><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">db</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Model</span></span></span><span class="hljs-class">): # ... language = db.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Column</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">db</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String(5)</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  As you remember, every time there are changes in database models, you need to migrate the database: </p><br><pre> <code class="hljs vhdl">(venv) $ flask db migrate -m <span class="hljs-string"><span class="hljs-string">"add language to posts"</span></span> INFO [alembic.runtime.migration] <span class="hljs-keyword"><span class="hljs-keyword">Context</span></span> impl SQLiteImpl. INFO [alembic.runtime.migration] Will <span class="hljs-keyword"><span class="hljs-keyword">assume</span></span> non-transactional DDL. INFO [alembic.autogenerate.compare] Detected added column <span class="hljs-symbol"><span class="hljs-symbol">'post</span></span>.language' Generating migrations/versions/<span class="hljs-number"><span class="hljs-number">2</span></span>b017edaa91f_add_language_to_posts.py ... done</code> </pre> <br><p>  Then you need to apply the migration to the database: </p><br><pre> <code class="hljs pgsql">(venv) $ flask db upgrade <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Context impl SQLiteImpl. <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Will assume non-transactional DDL. <span class="hljs-keyword"><span class="hljs-keyword">INFO</span></span> [alembic.runtime.migration] Upgrade ae346256b650 -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span>b017edaa91f, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-keyword"><span class="hljs-keyword">language</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> posts</code> </pre> <br><p>  Now I can detect and save the language when sending a message: </p><br><blockquote>  <em>app / routes.py</em> : Save language for new posts. </blockquote><br><pre> <code class="hljs ruby">from guess_language import guess_language @app.route(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, methods=[<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'POST'</span></span>]) @app.route(<span class="hljs-string"><span class="hljs-string">'/index'</span></span>, methods=[<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'POST'</span></span>]) @login_required <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: form = PostForm() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> form.validate_on_submit(): language = guess_language(form.post.data) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> language == <span class="hljs-string"><span class="hljs-string">'UNKNOWN'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> len(language) &gt; <span class="hljs-number"><span class="hljs-number">5</span></span>: language = <span class="hljs-string"><span class="hljs-string">''</span></span> post = Post(body=form.post.data, author=current_user, language=language) <span class="hljs-comment"><span class="hljs-comment"># ...</span></span></code> </pre> <br><p>  With this change, every time a message is sent, I skip the text through the <code>guess_language</code> function to try to determine the language.  If the language returns as unknown or I get an unexpectedly long result, I reinsure myself and save an empty string in the database.  I am going to accept an agreement that any message that has a language with an assigned value is an empty string, then it is assumed that it has an unknown language. </p><br><h2 id="otobrazhenie-ssylki-perevesti">  Displaying the "Translate" link </h2><br><p>  The second step is very simple.  I will add a "Translate" link next to any messages that differ from the language that is active for the current user. </p><br><blockquote>  <em><code>app/templates/_post.html</code></em> : Add a translate link to posts. </blockquote><br><pre> <code class="hljs django"><span class="xml"></span><span class="hljs-template-tag"><span class="xml"></span><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">if</span></span></span></span></span><span class="hljs-template-tag"> post.language and post.language != g.locale %}</span></span><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">br</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">br</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"#"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ _('Translate') }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span></span><span class="hljs-template-tag"><span class="hljs-template-tag">{% </span><span class="hljs-name"><span class="hljs-name"><span class="hljs-template-tag"><span class="hljs-name"><span class="hljs-name">endif</span></span></span></span></span><span class="hljs-template-tag"> %}</span></span><span class="xml"></span><span class="xml"></span></code> </pre> <br><p>  I do this in the <em><code>_post.html</code></em> so that this functionality is displayed on any page that displays blog entries.  The link to the translation will be displayed only on messages for which the language has been detected, and this language does not correspond to the language selected by the function decorated by the <code>localeselector</code> Flask-Babel.  Recall from <a href="https://habrahabr.ru/post/350148/">Chapter 13</a> that the selected locale is stored as <code>g.locale</code> .  The link text must be added in such a way that it can be translated by Flask-Babel, so I use the <code>_()</code> function to define it. </p><br><p>  Please note that I have not yet linked the action to this link.  First I want to figure out how to do actual translations. </p><br><h2 id="ispolzovanie-storonney-sluzhby-perevoda">  Using a third-party translation service </h2><br><p>  The two main translation services are the <a href="https://developers.google.com/translate/">Google Cloud Translation API</a> and the <a href="http://www.microsofttranslator.com/dev/">Microsoft Translator Text API</a> .  Both are paid services, but Microsoft‚Äôs offer has an entry-level option for a small amount of translations, which is free.  Google offered a free translation service in the past, but today, even the lowest level of service is paid.  Since I want to be able to experiment with translations without incurring costs, I am going to implement a Microsoft solution. </p><br><blockquote>  <em>Note</em>  <em>Translator:</em> There is still <a href="https://tech.yandex.ru/translate/">Yandex</a> about which Miguel does not seem to know.  Not a bad API!  There is a <a href="https://translate.yandex.ru/developers/offer">free version of</a> up to 1 M characters per day and 10 M per month versus 2 M per month for the microsoftware. </blockquote><p>  Before you can use the Microsoft Translator API, you must get an account in Azure, the Microsoft cloud service.  You can choose the Free level, during the offer provide the credit card number during the registration process.  Your card will not be charged as long as you remain at this level of service. </p><br><p>  After you have an Azure account, go to the Azure portal and click the "New" button in the upper left corner, then enter or select "Translator Text API".  When you click the "Create" button, you will be presented with a form in which you will define a new translator resource that will be added to your account.  Below you can see how I filled out the form: </p><br><p><img src="https://habrastorage.org/webt/qa/6q/x7/qa6qx73esifdx2hwag2igcskc1i.png"></p><br><p>  When you click the "Create" button again, the API translator resource will be added to your account.  If you wait a few seconds, you will receive a notification in the row at the top of the panel that the translator has been deployed.  Click the "Go to resource" button in the notification, and then on the "Keys" option on the left sidebar.  You will now see two keys labeled "Key 1" and "Key 2".  Copy one of the keys to the clipboard, and then enter it into the environment variable in your terminal (if you are using Microsoft Windows, replace <code>export</code> with <code>set</code> ): </p><br><pre> <code class="hljs javascript">(venv) $ <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> MS_TRANSLATOR_KEY=<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">paste-your-key-here</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  This key is used for authentication using the translation service, so you need to add it to the application configuration: </p><br><blockquote>  <em>config.py</em> : Add Microsoft Translator API key to the configuration. </blockquote><br><pre> <code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Config</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>): # ... MS_TRANSLATOR_KEY = os.environ.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'MS_TRANSLATOR_KEY'</span></span>)</code> </pre> <br><p>  As always with configuration values, I prefer to set them into environment variables and import them into the Flask configuration from there.  This is especially important when there is confidential information, such as keys or passwords, that provide access to third-party services.  You definitely do not want to write them explicitly in code. </p><br><p>  The Microsoft Translator API is a web service that accepts HTTP requests.  Python has several HTTP clients, but the most popular and easiest to use is <code>requests</code> .  Let's install it in a virtual environment: </p><br><pre> <code class="hljs sql">(venv) $ pip <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> requests</code> </pre> <br><p>  Below you can see the function that I encoded to translate text using the Microsoft Translator API.  I am adding a new <em>app / translate.py</em> module: </p><br><blockquote>  <em>app / translate.py</em> : Text translation function. </blockquote><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">json</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> requests <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask_babel <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> app def translate(<span class="hljs-type"><span class="hljs-type">text</span></span>, source_language, dest_language): <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'MS_TRANSLATOR_KEY'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> app.config <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> \ <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> app.config[<span class="hljs-string"><span class="hljs-string">'MS_TRANSLATOR_KEY'</span></span>]: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _(<span class="hljs-string"><span class="hljs-string">'Error: the translation service is not configured.'</span></span>) auth = {<span class="hljs-string"><span class="hljs-string">'Ocp-Apim-Subscription-Key'</span></span>: app.config[<span class="hljs-string"><span class="hljs-string">'MS_TRANSLATOR_KEY'</span></span>]} r = requests.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(<span class="hljs-string"><span class="hljs-string">'https://api.microsofttranslator.com/v2/Ajax.svc'</span></span> <span class="hljs-string"><span class="hljs-string">'/Translate?text={}&amp;from={}&amp;to={}'</span></span>.format( <span class="hljs-type"><span class="hljs-type">text</span></span>, source_language, dest_language), headers=auth) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r.status_code != <span class="hljs-number"><span class="hljs-number">200</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _(<span class="hljs-string"><span class="hljs-string">'Error: the translation service failed.'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">json</span></span>.loads(r.content.decode(<span class="hljs-string"><span class="hljs-string">'utf-8-sig'</span></span>))</code> </pre> <br><p>  The function accepts the text to be translated, and the source and target languages ‚Äã‚Äãare encoded as arguments, and returns a string with the translated text.  The action starts with checking the presence of a key for the translation service in the configuration, and if it does not exist, it returns an error.  The error is also a string, so from the outside it will look like translated text.  This ensures that in case of an error the user will see an error message. </p><br><p>  The <code>get()</code> method from the <code>requests</code> packet sends an HTTP request with a <code>GET</code> method to the URL specified as the first argument.  I use the URL <em>/v2/Ajax.svc/Translate</em> , which is the endpoint of the translation service that returns translations as JSON data.  Text, source and target languages ‚Äã‚Äãshould be specified as arguments of the query string in a URL named <code>text</code> , <code>from</code> and <code>to</code> respectively.  To authenticate with the service, I need to pass a key that I added to the configuration.  This key must be specified in a custom HTTP header named <code>Ocp-Apim-Subscription-Key</code> .  I created an <code>auth</code> dictionary with this header, and then passed it to the queries in the <code>headers</code> argument. </p><br><p>  The <code>requests.get()</code> method returns a response object containing all the information provided by the service.  First you need to check that the status code is 200, which is the code of the successful request.  If I get other codes, it means an error has occurred, so in this case I return an error string.  If the status code is 200, then the response body has a JSON encoded string with the translation, so all I need to do is use the <code>json.loads()</code> function from the standard Python library to decode the JSON into a Python string that I could use.  The response object attribute <code>content</code> contains the raw response text as a byte string, which is converted to a utf-8 string and sent to <code>json.loads()</code> . </p><br><p>  Below you can see a Python console session in which I use the new <code>translate()</code> function: </p><br><pre> <code class="hljs pgsql">&gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app.translate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> translate &gt;&gt;&gt; translate(<span class="hljs-string"><span class="hljs-string">'Hi, how are you today?'</span></span>, <span class="hljs-string"><span class="hljs-string">'en'</span></span>, <span class="hljs-string"><span class="hljs-string">'es'</span></span>) # English <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Spanish <span class="hljs-string"><span class="hljs-string">'Hola, ¬øc√≥mo est√°s hoy?'</span></span> &gt;&gt;&gt; translate(<span class="hljs-string"><span class="hljs-string">'Hi, how are you today?'</span></span>, <span class="hljs-string"><span class="hljs-string">'en'</span></span>, <span class="hljs-string"><span class="hljs-string">'de'</span></span>) # English <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> German <span class="hljs-string"><span class="hljs-string">'Are Hallo, how you heute?'</span></span> &gt;&gt;&gt; translate(<span class="hljs-string"><span class="hljs-string">'Hi, how are you today?'</span></span>, <span class="hljs-string"><span class="hljs-string">'en'</span></span>, <span class="hljs-string"><span class="hljs-string">'it'</span></span>) # English <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Italian <span class="hljs-string"><span class="hljs-string">'Ciao, come stai oggi?'</span></span> &gt;&gt;&gt; translate(<span class="hljs-string"><span class="hljs-string">'Hi, how are you today?'</span></span>, <span class="hljs-string"><span class="hljs-string">'en'</span></span>, <span class="hljs-string"><span class="hljs-string">'fr'</span></span>) # English <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> French "Salut, comment allez-vous aujourd'hui ?"</code> </pre> <br><p>  Pretty cool, right?  Now it's time to integrate this functionality with the application. </p><br><h2 id="ajax-from-the-server">  Ajax From The Server </h2><br><p>  I'll start with the implementation of the server side.  When the user clicks the "Translate" link that appears under the message, an asynchronous HTTP request is issued to the server.  I will show you how to do this in the next session, so for the moment I will focus on the server‚Äôs handling of this request. </p><br><p>  An asynchronous (or Ajax) request is similar to routes and browsing functions that I created in an application, with the only difference that instead of returning HTML or redirecting, it simply returns data formatted as <a href="http://en.wikipedia.org/wiki/XML">XML</a> or more often <a href="http://en.wikipedia.org/wiki/JSON">JSON</a> .  Below you can see the translation preview function, which calls the Microsoft Translator API, and then returns the translated text in JSON format: </p><br><blockquote>  <em>app / routes.py</em> : Text translation view function. </blockquote><br><pre> <code class="hljs python"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> jsonify <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> app.translate <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> translate @app.route(<span class="hljs-string"><span class="hljs-string">'/translate'</span></span>, methods=[<span class="hljs-string"><span class="hljs-string">'POST'</span></span>]) @login_required <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translate_text</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonify({<span class="hljs-string"><span class="hljs-string">'text'</span></span>: translate(request.form[<span class="hljs-string"><span class="hljs-string">'text'</span></span>], request.form[<span class="hljs-string"><span class="hljs-string">'source_language'</span></span>], request.form[<span class="hljs-string"><span class="hljs-string">'dest_language'</span></span>])})</code> </pre> <br><p>  As you can see, it is simple.  I ran this route as a <code>POST</code> request.  There is no absolute rule regarding when to use <code>GET</code> or <code>POST</code> (or other query methods that you have not yet seen).  Since the client will send the data, I decided to use a <code>POST</code> request, since this is similar to the requests that the form data represents.  The <code>request.form</code> attribute is a dictionary that Flask provides with all the data included in the view.  When I worked with web forms, I didn‚Äôt need to look for <code>request.form</code> , because Flask-WTF does everything to work as it should, but in this case there is actually no web form, so I have to directly access the data . </p><br><p>  So, let's look at what I am doing in this function.  The <code>translate()</code> function from the previous section is called and with it three arguments are passed directly from the data that was sent with the request.  The result is included in the dictionary with one single key under the name <code>text</code> , and the dictionary is passed as an argument to the <code>jsonify()</code> function Flask, which converts the dictionary into a formatted JSON payload.  The return value from <code>jsonify()</code> is the HTTP response that will be sent back to the client. </p><br><p>  For example, if a customer wants to translate the string <code>Hello, World!</code>  In Spanish, the response from this request will have the following useful data: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hola, Mundo!"</span></span> }</code> </pre> <br><h2 id="ajax-from-the-client">  Ajax from the client </h2><br><p>  So now that the server can provide translations via the URL <em>/ translate</em> , I need to call this URL when the user clicks on the ‚ÄúTranslate‚Äù link that I added above, passing the text to be translated, as well as the source and target languages.  If you are not familiar with working with JavaScript in the browser, it will be a good learning experience. </p><br><p>  When working with JavaScript in the browser, the currently displayed page is internally represented as a document object model or only DOM.  This is a hierarchical structure that refers to all elements that exist on the page.  JavaScript code running in this context can make changes to the DOM to trigger changes on the page. </p><br><p>  Let's first discuss how my JavaScript code running in a browser can get three arguments that I need to send to the translation function that runs on the server.  To get the text, I need to find a node in the DOM that contains the body of the blog post and read its contents.  To make it easier to identify DOM nodes containing blog entries, I'm going to add a unique identifier to them.  If you look at the <em>_post.html</em> template, the line that displays the message body simply reads <code>{{post.body}}</code> .  I'm going to wrap this content in a <code>&lt;span&gt;</code> element.  This will not change anything visually, but it gives me a place where I can insert an identifier: </p><br><blockquote>  <em><code>app/templates/_post.html</code></em> : Add an ID to each blog post. </blockquote><br><pre> <code class="hljs django"><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"post</span></span></span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ post.id }}</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ post.body }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  This will assign a unique identifier to each blog post in <code>post1</code> , <code>post2</code> format, etc., where the number corresponds to the database identifier for each post.  Now that each blog post has a unique identifier, given the ID value, I can use jQuery to search for the <code>&lt;span&gt;</code> element for this message and extract the text in it.  For example, if I wanted to get the text for a message with ID 123, here's what I would do: </p><br><pre> <code class="hljs mel">$(<span class="hljs-string"><span class="hljs-string">'#post123'</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">text</span></span>()</code> </pre> <br><p>  Here, the <code>$</code> sign is the name of the function provided by the jQuery library.  This library is used by Bootstrap, so it was already included in Flask-Bootstrap.  <code>#</code> is part of the selector syntax used by jQuery, which means that the element ID is next. </p><br><p>  I also want to have a place where I will insert the translated text after receiving it from the server.  Since I'm going to replace the "Translate" link with the translated text, I also need to have a unique identifier for this node: </p><br><blockquote>  <em><code>app/templates/_post.html</code></em> : I <em><code>app/templates/_post.html</code></em> ID to the link to translate. </blockquote><br><pre> <code class="hljs django"><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"translation</span></span></span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ post.id }}</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"#"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ _('Translate') }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  So now I have a <code>post&lt;ID&gt;</code> for the blog post and the corresponding <code>translation&lt;ID&gt;</code> node where I‚Äôll need to replace the ‚ÄúTranslation‚Äù link with the translated text as soon as I receive it. </p><br><p>  The next step is to write a function that can do all the translation work.  This function will accept input and output nodes of the DOM, as well as the source and destination languages, issue an asynchronous request to the server with three necessary arguments and, finally, replace the ‚ÄúTranslation‚Äù link with the translated text after the server responds.  This sounds like a lot of work, but the implementation is pretty simple: </p><br><blockquote>  <em>app / templates / base.html</em> : Client-side translation feature. </blockquote><br><pre> <code class="hljs xml">{% block scripts %} ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> </span></span><span class="hljs-title"><span class="javascript"><span class="hljs-function"><span class="hljs-title">translate</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">sourceElem, destElem, sourceLang, destLang</span></span></span></span><span class="javascript"><span class="hljs-function">) </span></span></span><span class="javascript">{ $(destElem).html(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'&lt;img src="{{ url_for('</span></span></span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">static</span></span></span><span class="hljs-string"><span class="javascript"><span class="hljs-string">', filename='</span></span></span><span class="javascript">loading.gif</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">') }}"&gt;'</span></span></span><span class="javascript">); $.post(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'/translate'</span></span></span><span class="javascript">, { </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">text</span></span></span><span class="javascript">: $(sourceElem).text(), </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">source_language</span></span></span><span class="javascript">: sourceLang, </span><span class="hljs-attr"><span class="javascript"><span class="hljs-attr">dest_language</span></span></span><span class="javascript">: destLang }).done(</span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"><span class="javascript"><span class="hljs-function"><span class="hljs-params">response</span></span></span></span><span class="javascript"><span class="hljs-function">) </span></span></span><span class="javascript">{ $(destElem).text(response[</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">'text'</span></span></span><span class="javascript">]) }).fail(</span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function">(</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ $(destElem).text(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"{{ _('Error: Could not contact server.') }}"</span></span></span><span class="javascript">); }); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> {% endblock %}</code> </pre> <br><p>  The first two arguments are unique IDs for messages and translation nodes.  The last two arguments are the source and target language codes. </p><br><p>  The function begins with a nice touch: it adds a <em>spinner</em> , replacing the ‚ÄúTransfer‚Äù link, so that the user knows that the transfer is in progress.  This is done using jQuery using the <code>$(destElem).html()</code> function to replace the original HTML, which identified a link to the translation with new HTML content based on the <code>&lt;img&gt;</code> link.  For a spinner, I'm going to use a small animated GIF tick, which I added to the <em>app / static / loading.gif directory</em> , which Flask reserves for static files.  To generate a URL that references this image, I use the <code>url_for()</code> function, passing the special name of the <code>static</code> route and giving the file name as an argument.  You can find the load.gif image in <a href="">the download package</a> for this chapter. </p><br><p>  So now I have a decent timer spinner, which replaced the "Translate" link and the user now knows that he needs to wait until the translation appears. </p><br><p>  The next step is to send a <code>POST</code> request to the URL <em>/ translate</em> , which I defined in the previous section.  For this, I'm also going to use jQuery, in this case the <code>$.post()</code> function.  This function sends data to the server in a format similar to how the browser submits the web form, which is convenient because it allows Flask to include this data in the <code>request.form</code> dictionary.  The two <code>$.post()</code> arguments are, first, the URL to send the request, and then the dictionary (or object, as they are called in JavaScript) with the three data elements that the server expects. </p><br><p>  You probably know that JavaScript works a lot with callback functions or a more advanced form of callback called <code>promises</code> .  What I want to do now is bash what I will do when this request is completed and the browser gets an answer.  In JavaScript, there is no such thing as waiting for anything, everything is asynchronous.  Instead, you must provide a callback function that the browser will call when the response is received.  And also as a way to make everything as reliable as possible, I want to specify what to do if an error suddenly occurred, so the second callback function will be error handling.  There are several ways to specify these callbacks, but in this case the use of promises makes the code quite clear.  The syntax is as follows: </p><br><pre> <code class="hljs lua">$.post(&lt;url&gt;, &lt;data&gt;).done(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span></span> { // success callback }).fail(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { // <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> callback })</code> </pre> <br><p>  The promise syntax allows you to basically hook up callbacks to the return value of the <code>$.post()</code> call.  On a successful callback, all I need to do is call <code>$(destElem).text()</code> with the translated text that comes into the turnkey <code>text</code> dictionary.  In the case of an error, I do the same thing, but the text I show will be a general error message, which I am sure is entered into the basic template as text that can be translated. </p><br><p>  So, it now remains only to call the <code>translate()</code> function with the correct arguments as a result of the user clicking the "Translate" link.  There are also several ways to do this.  What I'm going to do is simply embed a function call into the <code>href</code> attribute of the link: </p><br><blockquote>  <em><code>app/templates/_post.html</code></em> : Translate link handler. </blockquote><br><pre> <code class="hljs django"><span class="xml"><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"translation</span></span></span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ post.id }}</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"javascript:translate( '#post</span></span></span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ post.id }}</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">', '#translation</span></span></span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ post.id }}</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">', '</span></span></span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ post.language }}</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">', '</span></span></span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ g.locale }}</span></span><span class="xml"><span class="hljs-tag"><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">');"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="hljs-template-variable"><span class="hljs-template-variable">{{ _('Translate') }}</span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">a</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br><p>  The <code>href</code> link element can accept any JavaScript code if it has the <code>javascript:</code> prefix, so this is a convenient way to make a call to the translation function.       ,    ,     <code>{{ }}</code>     .            . <code>#</code> ,         <code>post&lt;ID&gt;</code>  <code>translation&lt;ID&gt;</code> , ,    ID . </p><br><p> Now the live translation feature is complete! If you have set a valid Microsoft Translator API key in your environment, you should now be able to trigger translations. Assuming you have your browser set to prefer English, you will need to write a post in another language to see the "Translate" link. Below you can see an example: </p><br><p>       !      Microsoft Translator API   ,      .       ,        ,    "".     : </p><br><p><img src="https://habrastorage.org/webt/jt/mc/dw/jtmcdw1fcyc7zmlvxhhxb_pjcym.png"></p><br><p>        ,      ,  ,     : </p><br><pre> <code class="hljs pgsql">(venv) $ flask translate <span class="hljs-keyword"><span class="hljs-keyword">update</span></span></code> </pre> <br><p>          messages.po    ,       ,                GitHub. </p><br><p>    ,   : </p><br><pre> <code class="hljs ruby">(venv) $ flask translate compile</code> </pre> <br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://habrahabr.ru/post/350148/">There</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/350626/">https://habr.com/ru/post/350626/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350614/index.html">Top 10 trends in artificial intelligence (AI) technology in 2018</a></li>
<li><a href="../350618/index.html">Hackaton MentorHack: Inside out</a></li>
<li><a href="../350620/index.html">Change of profession: from graphic designer to front-end developer</a></li>
<li><a href="../350622/index.html">Eternally Open Sesame, or Several Loopholes in Your IT Landscape</a></li>
<li><a href="../350624/index.html">Neural network that determines the age of the blood test - the development of scientists of the ITMO University</a></li>
<li><a href="../350628/index.html">Software Transactional Memory on Free Monads</a></li>
<li><a href="../350630/index.html">Unleash the game code using the Command pattern, and debugging while flying on the time machine</a></li>
<li><a href="../350632/index.html">Security Week 7: Dating through a coder and spam updates</a></li>
<li><a href="../350636/index.html">Cooking Juniper Network with Ansible</a></li>
<li><a href="../350638/index.html">Hardcore Java / JVM puzzles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>