<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How does hashCode () work by default?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Attempting to peer into hashCode() led to a speleological journey through the source code of the JVM, examining the structure of the objects and the a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How does hashCode () work by default?</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/3c9/f17/d09/3c9f17d09be34e7aa55ea381c3fbf96b.png"></div><br>  Attempting to peer into <code>hashCode()</code> led to a speleological journey through the source code of the JVM, examining the structure of the objects and the associated locking (biased locking), as well as surprising performance implications associated with the use of <code>hashCode()</code> by default. <br><a name="habracut"></a><br><h2>  Trivial mystery </h2><br>  Recently, in a working draft, I made a trivial change to the class: the implementation of <code>toString()</code> , so that the logs were useful.  To my surprise, this resulted in about a 5 percent reduction in coverage (coverage drop) of the class.  I knew that the whole new code was covered by already existing unit tests, so what's the matter?  When analyzing coverage reports, my colleague noticed that the implementation of <code>hashCode()</code> covered only before the changes were made, not after.  The reason was clear: by default, <code>toString()</code> calls <code>hashCode()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getClass().getName() + <span class="hljs-string"><span class="hljs-string">"@"</span></span> + Integer.toHexString(hashCode()); }</code> </pre> <br>  After adjusting <code>toString()</code> our custom <code>hashCode()</code> stopped being called.  We missed the test. <br><br>  Everyone knew what the default implementation of <code>toString()</code> , but ... 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  What is the default implementation of hashCode ()? </h2><br>  The default <code>hashCode()</code> returns a value that is called <b>an identity hash code</b> .  I will continue to use this value to distinguish it from hashes generated by the overridden implementations of <code>hashCode()</code> .  For information: even if the class overrides <code>hashCode()</code> , you can always get the identification hash of the object o by calling <code>System.identityHashCode(o)</code> . <br><br>  Common sense dictates that the identification hash uses an integer representation of the memory address.  This is evidenced by the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">J2SE documentation on Object.hashCode ()</a> : <br><br> <code>...          ,   Java    .</code> <br> <br>  However, there are problems with this, since the method contract requires: <br><br> <code>              Java-  hashCode           .</code> <br> <br>  Given that the JVM will move objects (for example, during garbage collection during promotion or compaction), after calculating the object's identification hash, we must make sure that it somehow tracks the location of the object itself. <br><br>  For example, you can take the current position of an object in memory when you first call <code>hashCode()</code> and save it somewhere, for example, in the object header.  Then, when the object is moved to another place, the source hash will move with it.  The disadvantage of the method is that two objects can have the same hash, but this is allowed by the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html">specification</a> . <br><br>  The best confirmation will be to look at the source code.  Unfortunately, the default <code>java.lang.Object::hashCode()</code> is a <a href="">native function</a> : <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">native</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hashCode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Wear a helmet! <br><br><h2>  Real hashCode () </h2><br>  Note that the <code>hashCode()</code> authentication implementation <b>depends on the JVM</b> .  I‚Äôll only consider OpenJDK source code, remember this with every further mention of the JVM.  All links refer to the <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/87ee5ee27509">changeset 5934: 87ee5ee27509</a> of the <a href="http://hg.openjdk.java.net/jdk8/jdk8/hotspot">Hotspot</a> tree, and I believe that most of them are applicable to Oracle JVM, but other machines have their own nuances. <br><br>  OpenJDK defines the <code>hashCode()</code> input point in <code>src/share/vm/prims/jvm.h</code> and <code>src/share/vm/prims/jvm.cpp</code> .  The latter contains: <br><br><pre> <code class="java hljs">JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle)) JVMWrapper(<span class="hljs-string"><span class="hljs-string">"JVM_IHashCode"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      ;  0,   NULL return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ; JVM_END</span></span></code> </pre> <br>  <a href="">ObjectSynchronizer :: FastHashCode () is</a> also called from <code>identity_hash_value_for</code> , which is used by several other call points (for example, <code>System.identityHashCode()</code> ) <br><br><pre> <code class="java hljs">intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FastHashCode (Thread::current(), obj()) ; }</code> </pre> <br>  You can naively expect <a href="">ObjectSynchronizer :: FastHashCode () to</a> do something like: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.hash() == <span class="hljs-number"><span class="hljs-number">0</span></span>) { obj.set_hash(generate_new_hash()); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj.hash();</code> </pre> <br>  But it turns out that there is a function for a hundred lines.  And this is much more complicated.  At the very least, we can mark a couple of ‚Äúif-not-exist-then-generate‚Äù blocks: <br><br><pre> <code class="java hljs">mark = monitor-&gt;header(); ... hash = mark-&gt;hash(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (hash == <span class="hljs-number"><span class="hljs-number">0</span></span>) { hash = get_next_hash(Self, obj); ... } ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hash;</code> </pre> <br>  This confirms our hypothesis.  For now, ignore <code>monitor</code> and be satisfied with getting the object header.  It is stored in <code>mark</code> , a pointer to an instance of <a href="">markOop</a> , which represents the <a href="http://openjdk.java.net/groups/hotspot/docs/HotSpotGlossary.html">word mark</a> belonging to the <a href="">lower</a> bits of the object's header.  So, we will try to thrust a hash into the word mark.  If it is missing, then generate it with <code>get_next_hash</code> , save and return. <br><br><h2>  Real-time identification hash generation </h2><br>  As we have seen, this is done in <a href="">get_next_hash</a> .  The function offers six methods based on the value of the <code>hashCode</code> variable. <br><br>  0. Randomly generated number. <br>  1. The function of the address of the object in memory. <br>  2. Rigidly programmed value of 1 (used for sensitivity testing). <br>  3. Consistency. <br>  4. The address of the object in memory, reduced to an integer value. <br>  5. Flow status combined with xorshift (https://en.wikipedia.org/wiki/Xorshift) <br><br>  What is the default method?  According to <a href="">globals.hpp</a> , in OpenJDK 8, this is method 5: <br><br><pre> <code class="java hljs">product(intx, hashCode, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">"(Unstable) select hashCode generation algorithm"</span></span>)</code> </pre> <br>  <a href="">The same is true</a> in OpenJDK 9. In <a href="">OpenJDK 7</a> and <a href="">OpenJDK 6</a> , the first method, <a href="">the random number generator</a> , is <a href="">used</a> . <br><br>  So, if I'm not mistaken, at least since version 6 <b>, the default implementation of hashCode in OpenJDK has nothing to do with the memory address.</b> <br><br><h2>  Object Headers and Sync </h2><br>  Let's go back a bit and consider a couple of missed moments.  First, the <a href="">ObjectSynchronizer :: FastHashCode ()</a> function looks too complicated, it uses more than 100 lines of code to accomplish what we considered to be a ‚Äúget-or-generate‚Äù operation.  Secondly, what is it all about - <code>monitor</code> - and why does it have the headers of our object? <br><br>  The structure of the word mark is a good place to start research.  In OpenJDK, it <a href="">looks like this</a> : <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// markOop   . // //  ,  mark ‚Äî    oop,   . //     oop   . // // -   (  ,   ): // // 32 : // -------- // hash:25 ------------&gt;| age:4 biased_lock:1 lock:2 ( ) // JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 ( (biased) ) // size:32 ------------------------------------------&gt;| (  CMS (CMS free block)) // PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (,  (promoted) CMS) // // 64 bits: // -------- // unused:25 hash:31 --&gt;| unused:1 age:4 biased_lock:1 lock:2 ( ) // JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 ( ) // PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (,  CMS) // size:64 -----------------------------------------------------&gt;| (  CMS) // // unused:25 hash:31 --&gt;| cms_free:1 age:4 biased_lock:1 lock:2 (COOP &amp;&amp;  ) // JavaThread*:54 epoch:2 cms_free:1 age:4 biased_lock:1 lock:2 (COOP &amp;&amp;  ) // narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOP &amp;&amp; ,  CMS) // unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOP &amp;&amp;   CMS)</span></span></code> </pre> <br>  For 32 and 64 bits, the format is slightly different.  In the second case, there may be two options, depending on whether the compressed <a href="https://wiki.openjdk.java.net/display/HotSpot/CompressedOops">Object Pointers</a> are included.  In Oracle and OpenJDK 8, they <b>are enabled</b> by default. <br><br>  Thus, object headers can refer to a free block or to a real object, so that several different states are possible.  In the simplest case (‚Äúnormal object‚Äù), the identification hash is stored directly into the lower bits of the header. <br><br>  But in other states, the pointer is associated with <code>JavaThread</code> or <code>PromotedObject</code> .  The case is complicated: if you put the identification hash in a ‚Äúnormal object‚Äù, will someone take it out?  And where?  If the object is biased, then where can we put the hash?  What is an anchored object? <br><br>  Let's try to answer all these questions. <br><br><h2>  Tied lock (biased locking) </h2><br>  Bound objects are the result of a <a href="https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">bound lock</a> .  This is the <a href="https://www.google.com/patents/US7814488">patented</a> mechanism, the default used since HotSpot 6. It tries to reduce the cost of blocking objects.  Such operations are expensive because, for the sake of safely processing requests for blocking / unlocking an object from different threads, their implementation is often based on atomic processor instructions ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2581_%25D0%25BE%25D0%25B1%25D0%25BC%25D0%25B5%25D0%25BD%25D0%25BE%25D0%25BC">comparison with exchange</a> ).  But it is noticed that in many implementations most objects are ever blocked by only one thread, so the use of atomic operations is often wasteful.  To avoid this, JVMs with anchored lock allow threads to try to ‚Äúsnap‚Äù an object on their own.  When the thread succeeds, it can block / unblock the object without using atomic instructions.  And since we do not have threads fighting for the same object, we get a performance boost. <br><br>  The <code>biased_lock</code> bit in the header indicates whether the object is bound to the stream specified in <code>JavaThread*</code> .  The <code>lock</code> bits indicate whether the object is locked. <br><br>  In OpenJDK, the implementation of an associated lock requires you to write a pointer to the word mark, and as a result you also need to move the word mark itself (containing the identification hash). <br>  This may explain the increased complexity of <code>FastHashCode</code> .  The header contains not only the identification hash, but also the blocking state (a pointer to the stream that has established the blocking).  Therefore, we need to consider all cases and determine the location of the identification hash. <br><br>  Let's start with <code>FastHashCode</code> .  The first thing we discover is: <br><br><pre> <code class="java hljs">intptr_t ObjectSynchronizer::FastHashCode (Thread * Self, oop obj) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UseBiasedLocking) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj-&gt;mark()-&gt;has_bias_pattern()) { ... BiasedLocking::revoke_and_rebias(hobj, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, JavaThread::current()); ... <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span>(!obj-&gt;mark()-&gt;has_bias_pattern(), <span class="hljs-string"><span class="hljs-string">"biases should be revoked by now"</span></span>); } }</code> </pre> <br>  Wait a minute  Here, the <b>binding and the associated object lock</b> are simply <b>canceled</b> (the <code>false</code> method means "do not try to bind again").  A few lines below it remains really unchanged: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//        assert (!mark-&gt;has_bias_pattern(), "invariant") ;</span></span></code> </pre> <br>  If I read it correctly, a <b>simple request for an object's identification hash disables the associated lock</b> , which prevents any attempts to block the object to use expensive atomic instructions. <br><br>  Hell. <br><br><h2>  Why does storing a locked lock state conflict with saving an identification hash? </h2><br>  To answer this question, we must understand where the word mark (containing the identification hash) may be located, depending on the blocking state of the object.  The following <a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">transitions</a> are shown: <br><br><img src="https://habrastorage.org/files/e1b/950/d92/e1b950d9273644009d4f9f1ccfdb1883.png"><br><br>  My (possibly erroneous) opinion is as follows. <br><br>  For the four states at the top of the schema, OpenJDK will be able to use thin-lock views.  In the simplest case (without locks), this means storing the identification hash and other data directly in the space of the word mark in the object: <br><br><pre> <code class="java hljs">unused:<span class="hljs-number"><span class="hljs-number">25</span></span> hash:<span class="hljs-number"><span class="hljs-number">31</span></span> --&gt;| unused:<span class="hljs-number"><span class="hljs-number">1</span></span> age:<span class="hljs-number"><span class="hljs-number">4</span></span> biased_lock:<span class="hljs-number"><span class="hljs-number">1</span></span> lock:<span class="hljs-number"><span class="hljs-number">2</span></span> ( )</code> </pre> <br>  In more complex cases, this space is used to store a pointer to a ‚Äúlock record‚Äù.  Then the word mark will be ‚Äúmoved‚Äù to another place. <br><br>  Since only one thread is trying to block an object, this pointer actually refers to the memory area in the thread's own stack.  This is good for two reasons: <br><br><ul><li>  speed (no disagreement or coordination of access to the memory area), </li><li>  this is enough for the thread to know that it owns the lock (the memory area refers to its own stack). </li></ul><br>  But it will not always work.  If we have competing objects (for example, objects used in synchronized expressions on which several threads intersect), then we need a more complex structure, suitable not only for copying object headers (again ‚Äúmoved‚Äù), but also for <a href="">a waiting list</a> .  A similar list is also required if the stream executes <code>object.wait()</code> . <br><br>  Our needs are met by the <a href="">ObjectMonitor</a> structure, which is called a ‚Äúheavy monitor‚Äù in the diagram.  The value remaining in the object header does not refer to the ‚Äúmoved word mark‚Äù, but to a real object (monitor).  To access the identification hash, it is now necessary to ‚Äúget the monitor‚Äù (inflating the monitor): make a pointer to the object and read / modify it depending on the field containing the moved word mark.  It is more expensive and requires coordination. <br><br>  There is work for <code>FastHashCode</code> . <br><br>  In lines <a href="">L640</a> through <a href="">L680</a> , a header is searched and a check for the presence of a cached identification hash.  I believe this is a quick way to check when we don‚Äôt need a monitor. <br><br>  Starting with <a href="">L682, you</a> 'll <a href="">have</a> to bite the bullet: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//      monitor = ObjectSynchronizer::inflate(Self, obj); //         mark = monitor-&gt;header(); ... hash = mark-&gt;hash();</span></span></code> </pre> <br>  If there is an id.  hash ( <code>hash != 0</code> ), then the JVM can return it.  Otherwise, we can get it from <code>get_next_hash</code> and safely save it in the moved header that is contained in <code>ObjectMonitor</code> . <br><br>  This gives a reasonable explanation of why the <code>hashCode()</code> call, as applied to a class object that does not override the default implementation, makes the objects inaccessible for the associated lock: <br><br><ul><li>  To preserve the consistency of the identity cache after the move, we need to store the hash in the object header. </li><li>  Streams requesting an identification hash may not bother with blocking an object at all.  But in practice they will share the data structures used by the lock mechanism.  This is a very complex system, since it can not only change, but also <b>move the</b> contents of the headers. </li><li>  A tied lock helps to perform lock / unlock operations without using atomic operations.  This is effective as long as the object is blocked by only one thread, because we need to store the lock state in the word mark.  I‚Äôm not quite sure, but as I understand it, since other threads may request an identification hash, <b>even if only one thread needs blocking</b> , the header word will be concurrent and you will need to use atomic operations for correct processing.  What makes sense an attached lock. </li></ul><br><h2>  Subtotals </h2><br><ul><li>  The default <code>hashCode()</code> (identification hash) is <b>not related to the memory address of the object</b> , at least in OpenJDK.  In versions 6 and 7, this is a randomly generated number.  In versions 8 and 9, this number is derived from the state of the stream.  Here is a test that led to <a href="https://stackoverflow.com/questions/1961146/memory-address-of-variables-in-java/20680667">the same conclusion</a> . <br><ul><li>  The proof of implementation-dependent warnings is not for aesthetics: <a href="https://www.azul.com/products/zing/virtual-machine/">Azul's Zing</a> <b>does</b> generate an identification hash based on the memory address of the object. </li></ul></li><li>  In HotSpot, an identification hash is generated only once, and then cached in the mark word in the object header. <br><ul><li>  In Zing, in order to preserve consistency when moving, a delaying mechanism for saving id.hash is used until the object is moved.  In this case, the hash is stored in the ‚Äúoverhead‚Äù. </li></ul></li><li>  In HotSpot, a default <code>hashCode()</code> or <code>System.identityHashCode()</code> call causes the object to become unavailable for the associated lock. <br><ul><li>  This means that when synchronizing objects that do not have disagreements, you should better override the default implementation of <b><code>hashCode()</code></b> , otherwise you will not be able to use JVM optimizations. </li></ul></li><li>  In HotSpot, <a href="https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">you can</a> disable the associated lock for each object separately. <br><ul><li>  This is a very useful feature.  I have encountered applications in which very often there are disagreements between production / consumption queues;  an attached lock was more disturbing than helping, so I had to turn it off.  We did this only for specific objects / classes, simply calling System.identityHashCode () with reference to them. </li></ul></li><li>  I did not find the flag in HotSpot that allows changing the generator by default, so experimenting with other options may require compiling from source. </li></ul><br><h2>  Benchmarks </h2><br>  To test my conclusions, I wrote a simple <a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a> test. <br><br>  The benchmark ( <a href="https://gist.github.com/srvaroa/aa1f6c273ea6ae215bbf43e481f7689e">source</a> ) does something like this: <br><br><pre> <code class="java hljs">object.hashCode(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(object) { counter++; } }</code> </pre> <br>  One configuration ( <code>withIdHash</code> ) synchronizes an object that uses an identification hash, so you can expect the <code>withIdHash</code> lock to be disabled when you call <code>hashCode()</code> .  The second configuration ( <code>withoutIdHash</code> ) implements a custom hash, in which the <code>withoutIdHash</code> lock is not disabled.  Each configuration is first run with one thread, then with two (they get the Contended suffix). <br><br>  By the way, you need to enable <code>-XX:BiasedLockingStartupDelay=0</code> , otherwise the JVM will take four seconds to start the optimization, which distorts the result. <br><br>  First start: <br><br><pre> <code class="java hljs">Benchmark Mode Cnt Score Error Units BiasedLockingBenchmark.withIdHash thrpt <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">35168</span></span>,<span class="hljs-number"><span class="hljs-number">021</span></span> ¬± <span class="hljs-number"><span class="hljs-number">230</span></span>,<span class="hljs-number"><span class="hljs-number">252</span></span> ops/ms BiasedLockingBenchmark.withoutIdHash thrpt <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">173742</span></span>,<span class="hljs-number"><span class="hljs-number">468</span></span> ¬± <span class="hljs-number"><span class="hljs-number">4364</span></span>,<span class="hljs-number"><span class="hljs-number">491</span></span> ops/ms BiasedLockingBenchmark.withIdHashContended thrpt <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">22478</span></span>,<span class="hljs-number"><span class="hljs-number">109</span></span> ¬± <span class="hljs-number"><span class="hljs-number">1650</span></span>,<span class="hljs-number"><span class="hljs-number">649</span></span> ops/ms BiasedLockingBenchmark.withoutIdHashContended thrpt <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">20061</span></span>,<span class="hljs-number"><span class="hljs-number">973</span></span> ¬± <span class="hljs-number"><span class="hljs-number">786</span></span>,<span class="hljs-number"><span class="hljs-number">021</span></span> ops/ms</code> </pre> <br>  A custom hash quadruples the lock / unlock cycle four times compared to the ID hash (which disables the lock lock).  When two threads compete for a lock, the associated lock is disabled anyway, so there is no significant difference between the two hashing methods. <br><br>  On the second launch, the <code>-XX:-UseBiasedLocking</code> lock is disabled ( <code>-XX:-UseBiasedLocking</code> ) in all configurations. <br><br><pre> <code class="java hljs">Benchmark Mode Cnt Score Error Units BiasedLockingBenchmark.withIdHash thrpt <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">37374</span></span>,<span class="hljs-number"><span class="hljs-number">774</span></span> ¬± <span class="hljs-number"><span class="hljs-number">204</span></span>,<span class="hljs-number"><span class="hljs-number">795</span></span> ops/ms BiasedLockingBenchmark.withoutIdHash thrpt <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">36961</span></span>,<span class="hljs-number"><span class="hljs-number">826</span></span> ¬± <span class="hljs-number"><span class="hljs-number">214</span></span>,<span class="hljs-number"><span class="hljs-number">083</span></span> ops/ms BiasedLockingBenchmark.withIdHashContended thrpt <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">18349</span></span>,<span class="hljs-number"><span class="hljs-number">906</span></span> ¬± <span class="hljs-number"><span class="hljs-number">1246</span></span>,<span class="hljs-number"><span class="hljs-number">372</span></span> ops/ms BiasedLockingBenchmark.withoutIdHashContended thrpt <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-number"><span class="hljs-number">18262</span></span>,<span class="hljs-number"><span class="hljs-number">290</span></span> ¬± <span class="hljs-number"><span class="hljs-number">1371</span></span>,<span class="hljs-number"><span class="hljs-number">588</span></span> ops/ms</code> </pre> <br>  The hashing method no longer affects the result, and <code>withoutIdHash</code> loses its advantage. <br><br>  All benchmarks were run on Intel Core i5 2.7 GHz. <br><br><h2>  Links </h2><br>  Everything that is not wild speculation and my weak reasoning in an attempt to comprehend the source code JVM, collected from various sources.  The main ones are: <br><br><ul><li>  <a href="https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot">blogs.oracle.com/dave/entry/biased_locking_in_hotspot</a> </li><li>  <a href="http://fuseyism.com/openjdk/cvmi/java2vm.xhtml">fuseyism.com/openjdk/cvmi/java2vm.xhtml</a> </li><li>  <a href="http://www.dcs.gla.ac.uk/~jsinger/pdfs/sicsa_openjdk/OpenJDKArchitecture.pdf">www.dcs.gla.ac.uk/~jsinger/pdfs/sicsa_openjdk/OpenJDKArchitecture.pdf</a> </li><li>  <a href="https://www.infoq.com/articles/Introduction-to-HotSpot">www.infoq.com/articles/Introduction-to-HotSpot</a> </li><li>  <a href="http://blog.takipi.com/5-things-you-didnt-know-about-synchronization-in-java-and-scala/">blog.takipi.com/5-things-you-didnt-know-about-synchronization-in-java-and-scala/#comment-1006598967</a> </li><li>  <a href="http://www.azulsystems.com/blog/cliff/2010-01-09-biased-locking">www.azulsystems.com/blog/cliff/2010-01-09-biased-locking</a> </li><li>  <a href="https://dzone.com/articles/why-should-you-care-about-equals-and-hashcode">dzone.com/articles/why-should-you-care-about-equals-and-hashcode</a> </li><li>  <a href="https://wiki.openjdk.java.net/display/HotSpot/Synchronization">wiki.openjdk.java.net/display/HotSpot/Synchronization</a> </li><li>  <a href="https://mechanical-sympathy.blogspot.com.es/2011/11/biased-locking-osr-and-benchmarking-fun.html">mechanical-sympathy.blogspot.com.es/2011/11/biased-locking-osr-and-benchmarking-fun.html</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/321306/">https://habr.com/ru/post/321306/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321292/index.html">There are two functions</a></li>
<li><a href="../321294/index.html">Browser Fingerprint - anonymous browser identification</a></li>
<li><a href="../321298/index.html">Free IOT & GPS service VIALATM</a></li>
<li><a href="../321302/index.html">How to remotely and centrally manage patches and software updates in the company</a></li>
<li><a href="../321304/index.html">Neurostream - a new chip for deep learning</a></li>
<li><a href="../321308/index.html">Securing user data: who is responsible for this?</a></li>
<li><a href="../321310/index.html">The book "Learning Node. Go to the server side. 2nd ed. supplemented and revised "</a></li>
<li><a href="../321312/index.html">What is UX / UI design really?</a></li>
<li><a href="../321314/index.html">Host controller 3D printer in 16 lines in C ++</a></li>
<li><a href="../321316/index.html">Do not kill your motivation: learn Ruby on Rails with interesting examples</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>