<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lazy loading images using IntersectionObserver</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nowadays, the main stumbling block on the way to high-speed download sites are images. This is especially true for e-commerce projects. The images on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lazy loading images using IntersectionObserver</h1><div class="post__text post__text-html js-mediator-article">  Nowadays, the main stumbling block on the way to high-speed download sites are images.  This is especially true for e-commerce projects.  The images on them, usually quite ‚Äúheavy‚Äù, make up the bulk of the content of the pages.  This, as a rule, leads to the fact that in order to show the user a page, his browser needs to load several megabytes of image data.  How to speed up page loading in this situation?  The answer to this question is devoted to the material, the translation of which we are publishing today. <br><br> <a href="https://habr.com/company/ruvds/blog/423485/"><img src="https://habrastorage.org/getpro/habr/post_images/943/040/c54/943040c5465e609d529aaa40f4f81f67.jpg" alt="image"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">General provisions</font> </h2><br>  Consider, for example, the home page of the <a href="https://www.walmart.com/cp/home/4044">Home</a> section on Walmart. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e09/717/79a/e0971779a66d1ee7c507d8db410dbb2b.gif"></div><br>  <i><font color="#999999">Page with many images</font></i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is information about how many images are being loaded to form this page: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/584/5d9/139/5845d91397a03e5e6763a0b953d72f93.png"></div><br>  <i><font color="#999999">Images uploaded when forming the page</font></i> <br><br>  As you can see, there are 137 images here!  This means that more than 80% of the data needed for the page output and transmitted over the network is in the form of graphic files. <br><br>  Let us now analyze the network requests that are performed when the page loads: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f42/618/dae/f42618daedd718f3766010a6a8a8cde3.png"></div><br>  <i><font color="#999999">Network queries that are performed during the formation of the page</font></i> <br><br>  In this case, the files resulting from the separation of the project code are loaded later than they could.  This happens because you first need to download the main <code>cp_ny.bundle</code> .  This bundle could be downloaded much faster, if it was not disturbed by 18 images competing with each other for bandwidth. <br><br>  How to fix it?  In fact, it‚Äôs not really possible to ‚Äúfix‚Äù this, but you can do a lot to optimize the loading of images.  There are many approaches to optimizing images used on web pages.  Among them - the use of different formats of graphic files, data compression, the use of blur animation techniques, the use of CDN.  I would like to dwell on the so-called ‚Äúlazy loading‚Äù of images (lazy loading).  In particular, we will talk about how to implement this technique on React sites, but since it is based on JavaScript mechanisms, it can be integrated into any web project. <br><br><h2>  <font color="#3AC1EF">Pilot project</font> </h2><br>  Let's start with this extremely simple React-component <code>Image</code> : <br><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Image</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ render() {   const { src } = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img align=<span class="hljs-string"><span class="hljs-string">"center"</span></span> src={src} /&gt;; } }</code> </pre> <br>  It accepts, as a property, a URL, and uses it to render the HTML <code>img</code> element.  <a href="https://jsfiddle.net/parkjoon/Lvhq8fap/">Here is the</a> corresponding code on the JSFiddle.  The following image shows the page containing this component.  Please note that in order to see the image displayed by him, you need to scroll through the contents of the page. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/754/978/b57/754978b574f4cc42960bda55487491a0.gif"></div><br>  <i><font color="#999999">Page with image output</font></i> <br><br>  In order to implement the method of lazy loading of images in this component, you need to perform the following three steps: <br><br><ol><li>  Do not render the image immediately after loading. </li><li>  Configure image appearance detection in the content viewing area. </li><li>  Display the image after it is detected that it has fallen into the viewing area. </li></ol><br>  Let's sort these steps. <br><br><h2>  <font color="#3AC1EF">Step 1</font> </h2><br>  At this step, the image is not displayed immediately after the download. <br><br><pre> <code class="hljs kotlin">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img /&gt;; }</code> </pre> <br><h2>  <font color="#3AC1EF">Step 2</font> </h2><br>  Here we set up mechanisms that allow you to detect when an image hits the viewing area. <br><br><pre> <code class="hljs coffeescript">componentDidMount() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntersectionObserver(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        }, {   root: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.observe(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element); } .... render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;img ref={el =&gt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element = el} /&gt;; }</code> </pre> <br>  Let's sort this code.  Here is what is done here: <br><br><ul><li>  Added <a href="https://reactjs.org/docs/refs-and-the-dom.html">ref</a> attribute to <code>img</code> element.  This allows you to later update the link to the image in <code>src</code> without having to re-render the component. </li><li>  A new instance of <code>IntersectionObserver</code> (we'll talk about this below). </li><li>  The <code>IntersectionObserver</code> object is proposed to observe the image using the <code>observe(this.element)</code> construction. </li></ul><br>  What is <code>IntersectionObserver</code> ?  Considering that the word ‚Äúintersection‚Äù is translated as ‚Äúintersection‚Äù, and ‚Äúobserver‚Äù is an ‚Äúobserver‚Äù, one can already guess the role of this object.  If you look for information about it on <a href="https://developer.mozilla.org/ru/docs/Web/API/Intersection_Observer_API">MDN</a> , then you can find out that the Intersection Observer API allows web applications to asynchronously monitor the change in the intersection of an element with its parent or viewport document scope. <br><br>  At first glance, this API feature may not seem very clear, but, in fact, it is very simple.  Several parameters are passed to the <code>IntersectionObserver</code> instance.  In particular, we used the <code>root</code> parameter, which allows you to specify the root DOM element, considered as a container, about the intersection of the element with the border of which we need to know.  By default, this is the area in which the visible fragment of the page (viewport) is located, but I explicitly set it to use the container that is in the JSFiddle <code>iframe</code> element.  This is done in order to, later, consider one possibility, which is not designed to use <code>iframe</code> elements. <br><br>  The reason why using <code>IntersectionObserver</code> to determine when an element becomes visible is more popular than more traditional methods, such as the use of <code>onScroll</code> and <code>getBoundingClientRect()</code> , because <code>IntersectionObserver</code> mechanisms run outside the main thread.  However, a callback, called after the <code>IntersectionObserver</code> detects the intersection of an element with a container, is executed, of course, in the main thread, so its code should not be too heavy. <br><br><h2>  <font color="#3AC1EF">Step 3</font> </h2><br>  Now we need to set up a callback that is called when an intersection of the <code>target</code> element ( <code>this.element</code> in our case) with the <code>root</code> container (in our case, the <code>div</code> element <code>.container</code> ) is <code>.container</code> . <br><br><pre> <code class="hljs kotlin">.... <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = new IntersectionObserver( entries =&gt; {   entries.forEach(entry =&gt; {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { isIntersecting } = entry;     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isIntersecting) {       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.element.src = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.src;       <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.observer.disconnect();     }   }); }, {   root: document.querySelector(<span class="hljs-string"><span class="hljs-string">".container"</span></span>) } ); ....</code> </pre> <br>  When a crossing is detected by a callback, an array of <code>entries</code> passed, which resembles a set of snapshots of the state of all target elements for which an intersection of a given boundary is detected.  The <code>isIntersecting</code> property indicates the direction of intersection.  If the element for which the observation is organized falls outside the root element, it is <code>true</code> .  If an element leaves the root element, then it is <code>false</code> . <br><br>  So, when it turns out that the element has crossed the bottom of the container, I manually set its <code>src</code> property and turn off monitoring it, which is no longer necessary. <br><br><h2>  <font color="#3AC1EF">Step 4 (secret)</font> </h2><br>  Now, in the fourth, secret step of our work, you can admire the result and enjoy the success.  Here is the <a href="https://jsfiddle.net/parkjoon/sgz9rbnf/">code</a> that contains what we just talked about. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edf/b5c/4e3/edfb5c4e3ab3bd515f11e96fe0e8d8ac.gif"></div><br>  <i><font color="#999999">The result of applying the technique of lazy loading images</font></i> <br><br>  However, if we take a closer look at what we did, it turns out that here you can find something that is not very good.  In order to see this, I quickly scrolled the page, slowing down the speed of the network connection. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/400/c00/2ce/400c002ce3f46f27875c40288bf39f4f.gif"></div><br>  <i><font color="#999999">The behavior of the page when it scrolls quickly and slows down the speed of the network connection</font></i> <br><br>  Since we load the image only after it has reached the area in which it should already be visible, the user does not have the opportunity to scroll the page and see the area occupied by the image, and, of course, the image itself before loading it.  When sites are viewed from ordinary computers connected to high-speed Internet, this does not cause problems.  But many modern users visit sites from their phones, sometimes they use 3G networks or, even worse, EDGE connections. <br><br>  With this problem, however, is not so difficult to cope.  This can be done due to the fact that the Intersection Observer API provides the developer with the opportunity to expand or narrow the boundaries of the root element (in our case, this is the <code>.container</code> element).  In order to use this opportunity, it is enough to add one line of code to where the root container is configured: <br><br><pre> <code class="hljs objectivec">rootMargin: <span class="hljs-string"><span class="hljs-string">"0px 0px 200px 0px"</span></span></code> </pre> <br>  In the <code>rootMargin</code> property, <code>rootMargin</code> need to write a string whose structure conforms to the CSS rules used to configure the indentation parameters for elements.  In our case, we inform the system that the lower boundary used to detect the intersection of an element with a container should be increased by 200 pixels.  This means that the corresponding callback will be called when the element falls into an area that is 200 pixels below the lower border of the root element (the default value is 0). <br><br>  <a href="https://jsfiddle.net/parkjoon/ytfc7vh5/">Here is the</a> code that implements this technique. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae8/e52/257/ae8e52257adaf3205addb04ac82dc10a.gif"></div><br>  <i><font color="#999999">Improving the technique of lazy loading images</font></i> <br><br>  As a result, it turns out that when we scroll the page only to the 4th list item, the image is loaded in an area that is 200 pixels below the visible area of ‚Äã‚Äãthe page. <br>  Now, it would seem, everything was done.  But it is not. <br><br><h2>  <font color="#3AC1EF">Image height problem</font> </h2><br>  If you have carefully studied the above GIF illustrations, then you may have noticed that the scrollbar performs a ‚Äújump‚Äù after the image is loaded.  Fortunately, this problem is easy to handle.  Its reason is that the element that displays the image initially has a height of 0, which, after loading the image, is equal to 300 pixels.  Therefore, to correct the problem, it is enough to set the element to a fixed height by adding the attribute <code>height={300}</code> to the image. <br><br><h2>  <font color="#3AC1EF">About optimization results</font> </h2><br>  What results did we, at Walmart, achieve after applying a lazy image upload on <a href="https://www.walmart.com/cp/home/4044">this</a> page?  In fact, the specific results vary greatly depending on a variety of circumstances, including the client‚Äôs connection speed to the network, the availability of the CDN, the number of images per page, and the rules for detecting the intersection with the root element applied to them.  In other words, you, in order to assess the impact of lazy loading of images on your own project, it is best to implement and test it yourself.  But if it is still interesting for you to take a look at what the lazy loading of images gave us, here are a couple of Lighthouse reports.  The first is formed before optimization, the second - after. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/4c8/698/5474c8698697e0489dd1ba213970b244.png"></div><br>  <i><font color="#999999">Lighthouse report generated before optimization</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/203/c82/7ec/203c827ec729a55597ac33568672365e.png"></div><br>  <i><font color="#999999">Lighthouse report generated after optimization</font></i> <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Today we looked at how to optimize web pages using lazy image loading.  If the pages of your site are full of pictures, then, quite possibly, this technique is useful to you. <br><br>  <b>Dear readers!</b>  How do you optimize images and upload them? <br><br><div style="text-align:center;"> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a href="https://habr.com/ru/post/423485/">https://habr.com/ru/post/423485/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../423475/index.html">Breaking the code of aging: the new science of aging and what it means to stay young</a></li>
<li><a href="../423477/index.html">Be a security ninja: start your way to the top of IB</a></li>
<li><a href="../423479/index.html">"First": whether to fly to Mars</a></li>
<li><a href="../423481/index.html">I need to raise the Kubernetes cluster, but I'm just a code programmer. There is an exit</a></li>
<li><a href="../423483/index.html">Finding the right way to split site content with a Webpack</a></li>
<li><a href="../423487/index.html">Node.js without node_modules</a></li>
<li><a href="../423489/index.html">I'm an emergency doctor, and I want to talk about the new Apple Watch electrocardiogram</a></li>
<li><a href="../423491/index.html">PHP Digest number 139 (September 3 - 17, 2018)</a></li>
<li><a href="../423493/index.html">Android Go is the next billion devices and 50 MB limit. Yandex lecture</a></li>
<li><a href="../423495/index.html">What's inside XGBoost, and where does Go</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>