<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithm to find the smallest common ancestor in the tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At leisure, I got an interesting idea that I developed into an algorithm for finding the smallest common ancestor (LCA) of two vertices in a tree. Bef...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithm to find the smallest common ancestor in the tree</h1><div class="post__text post__text-html js-mediator-article">  At leisure, I got an interesting idea that I developed into an algorithm for finding the smallest common ancestor (LCA) of two vertices in a tree.  Before the emergence of this idea of ‚Äã‚Äãother algorithms for searching LCA, I did not know.  Having checked the correctness of the work, I hurried to study other algorithms for solving this problem, but I did not find any similar ones.  Now I hasten to share it with the community. <br><br><h5>  Introduction </h5><br>  A tree is an undirected connected graph of <i>N</i> vertices and <i>N-1</i> edges.  From any vertex to any other, there is exactly one simple path. <br>  The root of the tree will be called such a vertex, from which the direction of movement along the tree is specified. <br>  The smallest common ancestor of two vertices <i>u</i> and <i>v</i> will be called such a vertex <i>p</i> that lies on the path from the root to the vertex <i>v</i> , and to the vertex <i>u</i> , as well as the most distant from it. <br><a name="habracut"></a><br><h5>  Input data </h5><br>  Information about the tree is input: <i>N</i> is the number of vertices, <i>N-1 is a</i> pair of vertices that are connected by an edge, and <i>M</i> is the number of requests.  Next, the program receives requests: two vertices <i>u</i> and <i>v</i> , for which you want to find their smallest common ancestor. <br><br><h5>  The idea of ‚Äã‚Äãthe algorithm </h5><br>  For each vertex, we will store the distance to the root and the previous vertex (ancestor) from which we came to it.  Further we will rise from the vertices <i>u</i> and <i>v</i> to the root of the tree.  At each step, we will choose the vertex <i>u</i> or <i>v</i> that which is the most distant from the root and then consider its ancestor instead, until the paths formed from the initial <i>u</i> and <i>v</i> are in one vertex - their smallest common ancestor.  With different tree variants, this path may consist of <i>N</i> steps, which, with a large number of vertices and queries, will work too slowly.  This implementation requires O (N) time to execute each request. <br>  Now we improve the algorithm.  For each vertex, we will store the distance to the root of the tree <i>dist</i> , the number of descendants of its <i>kids</i> , as well as the ancestor (the choice of which will be determined below) from which we came to it <i>last</i> and the number of the vertex where the ancestor goes an edge on the way to this vertex <i>turn</i> . <br>  We declare the necessary variables, for convenience, this will be done in global memory. <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SIZE = <span class="hljs-number"><span class="hljs-number">100050</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v[SIZE]; <span class="hljs-comment"><span class="hljs-comment">//      bool vis[SIZE]; //       int kids[SIZE]; // -     int dist[SIZE]; //      int last[SIZE]; //    int turn[SIZE];</span></span></code> </pre> <br>  Now for each vertex using the recursive function (call <i>k_go (0)</i> ) we calculate the number of descendants from it: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">k_go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = <span class="hljs-number"><span class="hljs-number">0</span></span>; vis[s] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, maxi = v[s].size(); i &lt; maxi; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!vis[v[s][i]]) res += k_go(v[s][i]) + <span class="hljs-number"><span class="hljs-number">1</span></span>; } kids[s] = res; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  And now we finish the preparatory part of the algorithm and fill in the necessary information for each vertex.  Call the function <i>l_go (0, 0, 0, 1)</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l_go</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ vis[s] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; dist[s] = d; last[s] = l; turn[s] = r; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxval = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> idx = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, maxi = v[s].size(); i &lt; maxi; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!vis[v[s][i]]) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = kids[v[s][i]]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(k &gt; maxval) idx = v[s][i], maxval = k; } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, maxi = v[s].size(); i &lt; maxi; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!vis[v[s][i]]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(idx == v[s][i]) l_go(v[s][i], d + <span class="hljs-number"><span class="hljs-number">1</span></span>, l, r); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> l_go(v[s][i], d + <span class="hljs-number"><span class="hljs-number">1</span></span>, s, v[s][i]); } } }</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Now I will explain how the last part of the code works, since the search for the number of descendants at the top is a fairly typical task. <br>  For each vertex we look at its descendants and from them we choose such a vertex with the maximum number of descendants.  For her, all information about the ancestor will be inherited from the current, and only the distance to the root will change.  For all other descendants of this vertex, now the ancestor of the <i>last</i> will be the current vertex, and the <i>turn is</i> the descendant itself. <br>  Now I argue that if we take some vertex <i>a</i> in the tree and until we reach the root from it, then the number of transitions to the <i>last</i> ancestor does not exceed the binary logarithm of the number of vertices in the tree. <br>  Proof: suppose we are at some vertex <i>v</i> which has one descendant.  Then it is obvious that the descendant of the <i>last</i> link to the ancestor will not change.  In the case of two or more vertices, we get one descendant (which has the largest number of descendants among all the descendants of the current vertex) from whom the link will inherit from the current one and all the others whose updates will be updated.  Denote the total number of descendants of the current vertex for <i>N.</i>  Then from the descendant of this vertex, in which we update the reference to the ancestor, there will be no more than <i>N / 2</i> descendants (otherwise this number will be the maximum, but then updating the reference is not required).  Thus, on each of the vertices, which is the ancestor of the <i>last</i> for someone, no more than half of the vertices are left, of all the descendants coming from it.  The total length of such a path will not exceed the binary logarithm of <i>N.</i> <br><br>  We now turn to the main function of the algorithm and the explanation of why it works. <br>  So, we have two vertices <i>u</i> and <i>v</i> , for which we need to know the answer to the query.  Call the function <i>p = lca (u, v)</i> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lca</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(turn[a] == turn[b]) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dist[a] &lt; dist[b]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dist[last[a]] &gt; dist[last[b]]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lca(last[a], b); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lca(last[b], a); }</code> </pre><br><br>  The function recursively rises in the direction of the root.  For each subsequent vertices <i>a</i> and <i>b,</i> we first check the vertex at which the last turn was made.  If it coincides, this means that either the vertex <i>a</i> lies on the path to the vertex <i>b</i> from the root, or vice versa.  Depending on which vertex is closer to the root, that is the desired smallest common ancestor. <br>  Otherwise, it is necessary to bring vertex <i>a</i> or <i>b</i> to the root.  We will approach on the basis of which of them will be farther from the root in the event of a transition to their ancestor (one vertex will constantly try to catch up with the second vertex on the way to the root).  Thus, sooner or later the vertices will come either to one vertex, which will immediately be their smallest common ancestor, or one of the vertices will lie on the path from the root to another vertex, as described in the first step. <br><br><h5>  Evaluation of the algorithm </h5><br>  To implement the algorithm, <i>O (N)</i> memory is required (the entire memory consumes <i>6N</i> ), <i>O (N)</i> preliminary calculation and <i>O (M * log (N))</i> time to answer all requests. <br>  The algorithm allows you to respond to requests on a predetermined tree and respond to requests immediately as they arrive for <i>O (log (N))</i> . <br><br><h5>  Efficiency of other algorithms for solving the LCA search problem </h5><br>  There are several algorithms for solving this problem, each of which is characterized by the complexity of writing, the time for preliminary calculation, the answer to the request and the size of the required memory. <br>  1) <a href="http://e-maxx.ru/algo/lca">Answer to the request for O (log N), preliminary calculation for O (N).</a>  The complexity of the implementation of the need to use the data structure "tree of segments" or "sqrt-decomposition." <br>  2) <a href="http://e-maxx.ru/algo/lca_simpler">Binary ascent method</a> .  Answer to the request for O (log N), preliminary calculation for O (log N), used memory (N * log (N)).  A fairly simple implementation with a slightly better runtime than the algorithm I have cited, but at the cost of additional memory used. <br>  3) <a href="http://e-maxx.ru/algo/lca_linear">Algorithm Farah-Colton and Bender</a> .  This is the most optimal algorithm that allows you to respond to a request for O (1), but also requires a lot of additional memory and is very complex in implementation. <br>  As well as an algorithm that allows you to respond to a request for O (1), but for this you need to know the information about all requests in advance. <br>  4) <a href="http://e-maxx.ru/algo/lca_linear_offline">Tarjan Algorithm</a> <br><br><h5>  Conclusion </h5><br>  Thus, the algorithm presented in the implementation complexity is slightly inferior to the slightly faster binary recovery algorithm, but it requires less memory and time for a preliminary calculation.  I would like to hear on this score the opinion of those who are familiar with the algorithms for solving this problem in order to evaluate the expediency of its use and uniqueness.  Thanks to everyone who took the time to understand this article. <br><br>  <b>UPD:</b> Knowledgeable people told me that my algorithm is just one of the applications of <a href="http://e-maxx.ru/algo/heavy_light">Heavy-Light</a> decomposition.  Before that, I was not familiar with this decomposition, but in any case it is nice to invent something for myself, even if it exists. </div><p>Source: <a href="https://habr.com/ru/post/198464/">https://habr.com/ru/post/198464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198450/index.html">Active Record vs. Data Mapper to save data</a></li>
<li><a href="../198452/index.html">Problem solving web server settings when publishing web applications</a></li>
<li><a href="../198454/index.html">Gadgets Inspired by Doctor Who</a></li>
<li><a href="../198456/index.html">Multifunctional Robot for washing windows of skyscrapers</a></li>
<li><a href="../198458/index.html">Switch to Selenium 2 + PhantomJS</a></li>
<li><a href="../198468/index.html">Setting up and using Geany with Python</a></li>
<li><a href="../198470/index.html">Singleton (Translated from the English chapter "Singleton" from the book "Pro Objective-C Design Patterns for iOS" by Carlo Chung)</a></li>
<li><a href="../198472/index.html">How I was a perfect customer</a></li>
<li><a href="../198474/index.html">Rosstat promises to open, but not for free</a></li>
<li><a href="../198478/index.html">Django Dash 2013 ended</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>