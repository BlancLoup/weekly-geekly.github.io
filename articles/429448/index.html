<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write the FPGA loader in LabVIEW. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Download configuration to FPGA via USB or disassemble FTDI MPSSE 
 We write the FPGA loader in LabVIEW. Part 1 


 In the first article, we run into t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write the FPGA loader in LabVIEW. Part 2</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://habr.com/post/426131/">Download configuration to FPGA via USB or disassemble FTDI MPSSE</a> <br>  <a href="https://habr.com/post/427529/">We write the FPGA loader in LabVIEW.</a>  <a href="https://habr.com/post/427529/">Part 1</a> </p><br><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><br>  In the first article, we run into the loading algorithm on the good old C, in the second article, we figured out how to organize a program in LabVIEW and implement a simple user interface.  This time we will get acquainted with new methods of work in LabVIEW, analyze the error handling features and complete the project: we will implement the protocol for loading the configuration file into the FPGA. <a name="habracut"></a><br><br><h2 id="obrabotka-oshibok">  Error processing </h2><br><p> We open the source code, analyze the function MPSSE_open.  Despite the algorithmic simplicity (functions are called for each other), quite a lot of D2XX API elements are required: <code>FT_OpenEx</code> , <code>FT_ResetDevice</code> , <code>FT_Purge</code> , <code>FT_SetUSBParameters</code> , <code>FT_SetChars</code> , <code>FT_SetTimeouts</code> , <code>FT_SetLatencyTimer</code> , <code>FT_SetFlowControl</code> , <code>FT_SetBitMode</code> , <code>FT_Purge</code> , <code>FT_SetUSBParameters</code> , <code>FT_SetChars</code> , <code>FT_SetTimeouts</code> , <code>FT_SetLatencyTimer</code> , <code>FT_SetFlowControl</code> , <code>FT_SetBitMode</code>  As shown in the <a href="https://habr.com/post/427529/">previous article</a> , functions are imported using the <code>Call library Function</code> node.  This node has dedicated terminals for error control.  There is one simple rule in LabVIEW: all <abbr title="Virtual Device">VIs</abbr> must track errors and report errors returned by the terminals errors.  Most embedded VP strictly follows it.  I hope everyone understands how important it is to monitor and handle errors, especially at the debugging stage, but there is another reason why this is so important, not obvious to "classical" programmers.  LabVIEW does not have a strict sequence of instrument execution on the block diagram: the instrument is executed when data are available at its inputs.  If from the output of one VP the data is transmitted to the input of another VI, then it is clear that at the beginning the first VI will work, only after it the second.  And what if there is no data transfer, and the VIs perform independent actions?  Of course, you can use the cumbersome "Flat Sequence Structure", but it is much more convenient to connect devices with each other by a stream of errors. </p><br><p>  When importing D2XX functions, we encounter two types of errors.  The first - this is an error directly imported - returns the block <code>Call library Function</code> .  The second is the error of the library itself, returned by almost every function via <code>FT_STATUS</code> .  All possible values ‚Äã‚Äãare described as enum in the ftd2xx.h header file.  Although it is enough to know that the value of <code>FT_OK</code> is the absence of an error, and all other values ‚Äã‚Äãare error codes, I would like to track not only the fact of the error, but also what error occurred and exactly where it occurred. </p><br><p>  In LabVIEW, error data is propagated through <code>error</code> clusters.  This is such a special dedicated data type, LabVIEW has a lot of VIs and functions for working with it.  The error cluster consists of three elements: a logical variable ‚Äî it displays the status, a signed integer number ‚Äî the error code, and a string ‚Äî the source of the error.  The status indicates whether an error occurred, the error code determines its type and is used by special VIs to generate a report.  The line gives a more detailed idea of ‚Äã‚Äãexactly where the error occurred.  In LabVIEW, if the status is <code>TRUE</code> , then this is an error, if the status is <code>FALSE</code> , but the code is not zero and the description string is not empty, then this <em>warning</em> , if the status is <code>FALSE</code> , the code is zero and the string is empty - there is no error. </p><br><img src="https://habrastorage.org/webt/pm/ku/gv/pmkugvhr1yzt6uarss9lfnmthuc.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>  LabVIEW contains an internal database in which each error code is associated with its description.  For each type of error, a special range of code values ‚Äã‚Äãis allocated.  For example, for the errors associated with the network operation, several ranges are allocated: from ‚Äì2147467263 to ‚Äì1967390460, from 61 to 65, from 116 to 118 and 122, 1101, 1114, 1115, 1132 to 1134, from 1139 to 1143 and from 1178 to 1185 For user-defined errors, two ranges from ‚Äì8999 to ‚Äì8000 and from 5000 to 9999 are reserved. From these ranges, we can choose values ‚Äã‚Äãfor the error codes of the D2XX library. </p><br><p>  Create a VI that accepts the status of the D2XX function as an input and converts this status into a LabVIEW error cluster.  Most functions and VIs in LabVIEW, having received the <code>Error In</code> status <code>TRUE</code> , do not execute their code, but transmit error information to the <code>Error Out</code> terminal.  This allows you to effectively transfer information about the source through the entire chain to the error handler, eliminating the execution of code in emergency mode.  It is desirable that our VP behaves similarly. </p><br><p>  Let's make a list of D2XX statuses in the form of <code>enum</code> and render it into a separate type (in the previous article we did this with the FTDI types). </p><br><div class="spoiler">  <b class="spoiler_title">enum FT_Status</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/mb/bp/kp/mbbpkpzguefjrdg2p4l2n7-rpg0.png"></div></div><br><p>  The new VI is saved as FT_error.vi.  Two <code>Error In</code> and <code>Error Out</code> clusters are added to the front panel, you can find them in the "Array, Matrix &amp; Cluster" palette.  We connect them to the terminals in the connections panel in the lower left and lower right corners, respectively, as was mentioned in the previous article, this is the location of the error stream terminals in LabVIEW.  Add a <code>Case</code> structure to the block diagram, <code>Case selector</code> input an <code>Error In</code> cluster, then the <code>Case</code> structure changes color and two subdiagrams divide: "No Error" - green, and "Error" - red.  Inside the Error case, we pass an error cluster from the selector terminal directly to the output tunnel on the right border.  And in the green case, we add another <code>Case</code> , depending on the status it will determine whether to create an error (status is not FT_OK), or leave it as it is: skip the input error cluster to the output without changing. </p><br><p>  In order to technically convert the error code into a cluster, you can use the <code>Error Cluster From Error Code VI</code> .  This <abbr title="Sub Virtual Instrument. He is a Sub-device">SubVI</abbr> adds a call chain to the error description, so that we can determine not only <strong>what</strong> happened, but also <strong>where</strong> it happened. </p><br><p>  To select the text corresponding to the input status (FT_Status), use the property block: select "RingText.Text".  Error text is passed to the input <code>error message</code> VP <code>Error Cluster From Error Code VI</code> . <br>  Do not forget to draw the "talking" icon. </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/xx/xw/ub/xxxwubdzodjs1jfaywcbjamsrtg.png"><br>  <em>Front (front) sub-instrument panel</em> </p><br><p><img src="https://habrastorage.org/webt/ja/wu/te/jawuteahiriyixrjpcgbm91esjo.png"><br>  <em>Block diagram</em>  <em>Error input</em> </p><br><p><img src="https://habrastorage.org/webt/yd/qf/lp/ydqflp1m-zexy_zvvdx8drixu9e.png"><br>  <em>Block diagram</em>  <em>There is no error at the input and the status is FT_OK</em> </p><br><p><img src="https://habrastorage.org/webt/1h/wp/7m/1hwp7mcprzgv3mf9oz3jenbco4q.png"><br>  <em>Block diagram</em>  <em>There is no error at the input, but the status is different from FT_OK</em> </p><br></div></div><br><p>  For the FT_error test, you can create an empty VI, add the created VI there and see how the value will change at startup if you submit different statuses. </p><br><div class="spoiler">  <b class="spoiler_title">FT_error.vi test</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/rn/_r/be/rn_rbewvlb--au_hi3nosghkjmk.png"><br>  <em>Front (front) panel of the instrument</em> </p><br><p><img src="https://habrastorage.org/webt/ju/44/fz/ju44fzmyx2aly2-fraydjrkyffg.png"><br>  <em>Block diagram</em> </p></div></div><br><p>  Now, after any function call from the D2XX API, we will use SubVI FT_error.vi.  And the cluster of errors will pass through all the VIs throughout the call hierarchy. </p><br><p>  In the top-level VI, we need to decide what to do with the detected error: you can display a message in the dialog box, write it to the report file, ignore it, or just end the application silently.  The dialog box is the easiest and most popular way to report errors.  And it is also convenient for a novice programmer, since nothing needs to be done.  In each VI, the default <strong>automatic error handling</strong> mode is enabled ( <strong>Enable automatic error error handling</strong> , located in the Execution category of the Properties VI menu).  It works like this: if in some node the output terminal <code>Error Out</code> not connected anywhere, and an error occurs in that node, LabVIEW pauses the execution of the application and displays a dialog box.  If the node's <code>Error Out</code> terminal is connected, the error stream propagates as programmed, and no additional action occurs.  However, the message window can be called up programmatically, for this you need to use the <code>General Error Handler</code> and <code>Simple Error Handler</code> VIs (located in the "Dialog &amp; User Interface" panel).  In this case, information about the error we can use to complete the program.  On the block diagram, it looks like this: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/u9/8y/_p/u98y_paluq1jtgm2gylcaceydgs.png"></a> <br>  <em>Clickable image</em> </p><br><p>  When an error occurs, the program will be paused, a window with a report will appear, after closing the window the program will terminate correctly. </p><br><div class="spoiler">  <b class="spoiler_title">Report window</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><h2 id="otkryt-i-zakryt-ftdi">  Open and close FTDI </h2><br><p>  So, back to the <code>MPSSE_open</code> function.  Create a new <abbr title="Virtual Instrument">VI</abbr> .  First of all, we add terminals for the error stream.  Add a selection structure and feed the selector input <code>Error In</code> .  In the green case, we do the import of functions in the order and with the parameters as in the Sishny prototype.  All nodes of the <code>Call Library Function Node</code> chained by a stream of errors.  In the red case through the tunnel we connect <code>Error In</code> to the output terminal of the error. </p><br><p> <a href=""><img src="https://habrastorage.org/webt/4p/qq/zx/4pqqzxgwcgsbb-jcvepvyaj6jam.png"></a> <br>  <em>Clickable image</em> </p><br><p><img src="https://habrastorage.org/webt/5z/uq/k6/5zuqk6hmya20zgu9ddnciwgj5a0.png"><br>  <em>VP MPSSE_open.vi</em> </p><br><p>  The input to SubVI is a string describing FTDI ( <code>Description</code> ), the output is <code>Handle</code> and an initialized FTDI chip in MPSSE mode. </p><br><p>  Let's create a VP, completing the work with FTDI and you can already test the performance on the hardware. </p><br><div class="spoiler">  <b class="spoiler_title">FT_Close.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/1e/te/g3/1eteg3uh0t2t16y9yho_kxjbufe.png"><br>  <em>Block diagram</em> </p><br><p><img src="https://habrastorage.org/webt/ki/ez/tt/kiezttogb-2n4zl1qe893hfc55w.png"><br>  <em>Front Panel</em> </p></div></div><br><p>  In the previous article for debugging the interface, we made the SP plug SP_FT_MPSSE_FPGA.vi, now it is time to fill it.  Add on its block diagram MPSSE_open.vi and FT_Close.vi.  At this stage, it is rather difficult to assess whether the initialization was correct, but a nonzero <code>Handle</code> value at the output of MPSSE_open.vi and the absence of an error will tell us a lot. </p><br><p><img src="https://habrastorage.org/webt/ci/rn/q5/cirnq5ik2_g5p-wbz3cmfcxzquo.png"><br>  <em>SP_FT_MPSSE_FPGA.vi block diagram</em> </p><br><p>  In order to see the value of <code>Handle</code> you can use the window "Probe Watch Window".  This is a handy debugging tool that allows you to display the value of data on any (almost any) wire in the course of instrument execution.  In order to install a sample on a line, select the "Probe" item in the context menu of this line itself.  The ‚ÄúProbe Watch Window‚Äù window will open, and a tsiferka with a sample number will appear on the line.  In the picture above it is "3." </p><br><div class="spoiler">  <b class="spoiler_title">Probe watch window</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/yq/qv/u_/yqqvu_pkihohde2in-uy7sttt-i.png"><br>  <em>On the line Handle value 698389336</em> </p></div></div><br><p>  Fine!  Run the top-level VI, connect the debugging board to the computer.  The description of the connected FTDI chip appears in the "Select device" list, press the "Program" button and ... nothing happens.  Only in the "Probe Watch" appeared value <code>Handle</code> .  And this is good. </p><br><p>  Turning off the board, the list of devices is cleared.  Click "Program".  This is where the error report window pops up. </p><br><div class="spoiler">  <b class="spoiler_title">Report window</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/9g/mh/lc/9gmhlc7e8mf-2uqzheifbdtgdek.png"></p></div></div><br><p>  After clicking the "Continue" button, the VI ends its work. </p><br><p>  It is necessary to prohibit pressing the button if no device is found.  Modify the case "Timeout" event handler.  Let me remind you that FTDI chips connected to a PC are scanned twice a second, if they are detected and can be used for programming an FPGA, then using the <code>Strings[]</code> property, their descriptors are added to the <code>Devices list</code> .  We create the <code>Disabled</code> property for "Program", and if no suitable devices are detected, then disable and dim the button. </p><br><div class="spoiler">  <b class="spoiler_title">Case timeout</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/wx/nf/5n/wxnf5n-ttwqqrsmbtydmttzcghw.png"></a> <br>  <em>The picture is clickable</em> </p></div></div><br><h2 id="osvaivaem-gpio">  Mastering GPIO </h2><br><p>  After MPSSE is activated, it is handled through the so-called "op-code", and from the API functions D2XX, only <code>FT_Write</code> , <code>FT_Read</code> and <code>FT_Queue</code> (to find out the status of the receiver buffer).  On the basis of the track, we create the corresponding VI: FT_Write.vi, FT_Read.vi, FT_Queue.vi. </p><br><div class="spoiler">  <b class="spoiler_title">Little routine</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/tw/or/ku/tworkua4o2qj3bntqoer1jb4o0u.png"><br>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/8k/pm/4s/8kpm4sdeaqgzlsctp-106wvtdz0.png"><br>  <em>Block diagram</em>  <em>FT_Write.vi</em> </p><br><p><img src="https://habrastorage.org/webt/i0/px/18/i0px189plvqpokb3sijjuxtxbei.png"><br>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ku/hm/xw/kuhmxw1j66symp05f0ergjkriag.png"><br>  <em>Block diagram</em>  <em>FT_Read.vi</em> </p><br><p><img src="https://habrastorage.org/webt/bf/2s/q_/bf2sq_t4uinirm94vmh-ugkzqzy.png"><br>  <em>FT_Queue.vi</em> </p><br><p><img src="https://habrastorage.org/webt/5p/zm/dv/5pzmdvtnhtdq0ivxzfs0t32nfjk.png"><br>  <em>Block diagram</em>  <em>FT_Queue.vi</em> </p></div></div><br><p>  Now from these three bricks lay out the VI for reading the parallel port and writing to it.  The value is conveniently represented as an array of Boolean variables. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Set_LByte.vi and MPSSE_Get_LByte.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/oy/uh/8l/oyuh8lrdyniwp6ub2pvgwrxtlvw.png"><br>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/g4/ab/u-/g4abu-lurodnce0udnamj1ftsjm.png"><br>  <em>Block diagram</em>  <em>MPSSE_Set_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/7g/s9/5d/7gs95ddkb8pg9fjzt-s0vflzes4.png"><br>  <em>MPSSE_Get_LByte.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ki/dm/n_/kidmn_ewfihbrokreabs90538p0.png"><br>  <em>Block diagram</em>  <em>MPSSE_Get_LByte.vi</em> </p><br><p>  I repent, I was lazy to create a named list for all op-code, so I left them in the form of Magic Numbers. </p></div></div><br><p>  As mentioned in the very first <a href="https://habr.com/post/426131/">article,</a> the FPGA "Passive Serial" download protocol is nothing more than SPI with additional flag manipulation.  A total of five legs are used: the <em>DCLK</em> , <em>DATA [0]</em> , <em>nCONFIG lines</em> must be configured as outputs, and the <em>nSTATUS</em> and <em>CONF_DONE lines</em> as inputs. </p><br><div class="spoiler">  <b class="spoiler_title">Pinout scheme in the form of a table</b> <div class="spoiler_text"><table><thead><tr><th>  FPGA pin </th><th>  Pin name </th><th>  Pin </th><th>  MPSSE </th><th>  Direction </th><th>  default </th></tr></thead><tbody><tr><td>  DCLK </td><td>  BDBUS0 </td><td>  38 </td><td>  TCK / SK </td><td>  Out </td><td>  0 </td></tr><tr><td>  DATA [0] </td><td>  BDBUS1 </td><td>  39 </td><td>  TDI / DO </td><td>  Out </td><td>  one </td></tr><tr><td>  nCONFIG </td><td>  BDBUS2 </td><td>  40 </td><td>  TDO / DI </td><td>  Out </td><td>  one </td></tr><tr><td>  nSTATUS </td><td>  BDBUS3 </td><td>  41 </td><td>  TMS / CS </td><td>  In </td><td>  one </td></tr><tr><td>  CONF_DONE </td><td>  BDBUS4 </td><td>  43 </td><td>  GPIOL0 </td><td>  In </td><td>  one </td></tr></tbody></table></div></div><br><p>  We will need a VP, which will be able to change the value on the selected leg without affecting all the others.  First of all, we create <code>Enum</code> with the sequence numbers of the legs in the port, save it as "Strict Type Def" to the file SP_LBYTE_BITS.ctl.  Create a new VI, add the usual error stream terminals.  We read the current value of the parallel port using MPSSE_Get_LByte.vi, using the <code>Replace Array Subset</code> function, we modify the necessary bit and write the value back to the port (MPSSE_Set_LByte.vi). </p><br><div class="spoiler">  <b class="spoiler_title">SP_Set_Flag.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/y7/d3/ap/y7d3aps-9ima93quyatag0ggkui.png"><br>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/jn/ae/h4/jnaeh4ewehebgcba9fstkxnxa4o.png"><br>  <em>Block diagram</em>  <em>SP_Set_Flag.vi</em> </p><br><p><img src="https://habrastorage.org/webt/ud/mt/jx/udmtjxpekkcskrmisie8t2h4hfw.png"><br>  <em>Enum SP_LBYTE_BITS.ctl</em> </p></div></div><br><p>  To begin configuration, the MPSSE controller must generate a low-to-high transition on the <em>nCONFIG</em> line.  As soon as the FPGA is ready to receive data, it will form a high level on the <em>nSTATUS</em> line.  At this stage, everything is ready for an experiment in iron.  Add the control of the <em>nCONFIG</em> line to the block diagram SP_FT_MPSSE_FPGA.v - after the initialization of the MPSSE, we submit a low level and then a high one.  After each operation (for debugging) we read the state of the port's legs. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/5q/8g/u1/5q8gu1k9oezxomhdblxqyjbxxas.png"><br>  <em>During launch</em> </p><br><p><img src="https://habrastorage.org/webt/nj/qv/bv/njqvbvi3dibaezauuqh4t2thdo8.png"><br>  <em>Block diagram</em> </p></div></div><br><p>  In general, during the launch of the VI, it can be seen that the FPGA responds to the transition on the <em>nCONFIG</em> lines ‚Äî a zero is set on the <em>nSTATUS pin</em> and then a one.  But it will not be superfluous to check it with an oscilloscope.  Almost any dual channel oscilloscope with the ability to run on the trigger (standby).  Channel <strong>A</strong> (blue track) I put in the control point of the <em>nCONFIG</em> circuit, channel <strong>B</strong> (red track) - the chain <em>nSTATUS</em> .  The trigger is set to the falling edge of channel <strong>A.</strong> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/ca/b9/ti/cab9tizq5kpbnbguzew2avmi_je.png"></a> <br>  <em>The picture is clickable.</em>  <em>With details!</em> </p><br><h2 id="rabota-s-faylom">  Work with file </h2><br><p>  FPGA is ready to accept the configuration file.  Are we ready to transfer the file to the FPGA? </p><br><p>  LabVIEW contains an extensive set of tools for working with files.  Not to say that the functional is enough for absolutely the whole range of tasks, but the basic operations like <em>reading</em> and <em>writing</em> are easy and pleasant.  The basic set of VI for working with files can be found in the "File I / O" panel.  For the problem to be solved, it is necessary to open the configuration file, estimate its size (we need to know how many bytes to send the FPGA), read it and close it.  Everything is simple and one after the other.  Use the <code>Open/Create/Replace File</code> VI, <code>Get File Size</code> , <code>Read from Binary File</code> , <code>Close File</code> , combine them with an error stream chain and <code>refnum</code> - a number, such as a file descriptor, is created when the file is opened and must be passed to the input by other VIs working with this file. </p><br><p>  So far we have nowhere to recycle the read data, but if you really want to check the performance of the chain, then you can create an indicator of the <code>String</code> type and adjust it a little.  In the context menu, activate the "Hex Display" option, turn on the vertical scrollbar (Visible Items -&gt; Vertical Scrollbar) and after launching we observe the contents of the binary configuration file. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/7w/r8/dy/7wr8dyzaxomkxwmqioien0rn2om.png"><br>  <em>Front Panel.</em>  <em>We look at the contents of the file</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/qf/8l/vv/qf8lvvjj6xtwo_be0aiu-3aa2co.png"></a> <br>  <em>Block diagram</em>  <em>Karinka clickable</em> </p></div></div><br><p>  The block diagram of the VP formed two independent parallel lines of code, so separate error chains are used for them.  In order to reduce parallel threads into one <code>Error Out</code> terminal, the <code>Merge Errors</code> function is used.  This function looks for errors at the input from top to bottom (yes, there may be more than two input terminals, stretched with the mouse) and returns the first one it finds.  If there are no errors, it returns the first warning that occurred.  If no warnings are detected, then there is no error at the output.  It is important to note that the order of connecting inputs <code>Merge Errors</code> determines the priority of errors, and if an error occurs in two chains at once, the lower error will be ignored.  To this must be treated carefully. </p><br><p>  If we try to press the "Program" button in the top-level VI without selecting a file, then SP_FT_MPSSE_FPGA.vi will have a blank path at the input, which will cause the error "Error 1430. LabVIEW: (Hex 0x596) absolute path. "  As my childhood friend says: "Trivia, it‚Äôs something everyday!"  And this mistake is not a mistake at all, but a user's inattention.  We will not stop the program and swear at it with a window with a red cross, simply remove the error with this code from the stream and in the dialog box we recommend the user to decide on the file.  To filter errors, use the "Clear Errors" VP from the "Dialog &amp; User Interface" palette.  To display the message - "One Button Dialog". </p><br><p><img src="https://habrastorage.org/webt/o2/nf/bm/o2nfbmdreh3hdppvxsabj7hsgt4.png"></p><br><div class="spoiler">  <b class="spoiler_title">Block diagram</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/-6/ik/cp/-6ikcptiqxx7uloza1v2g5y6wdo.png"></a> <br>  <em>The picture is clickable</em> </p></div></div><br><h2 id="zagruzka-konfiguracii">  Loading configuration </h2><br><p>  For serial data transmission to the MPSSE processor, you need to send op-code 0x18, the command arguments will be the length of the transmitted sequence (two bytes, starting from the low order), and the data sequence itself.  Length is coded minus one.  Sending a data block will be issued as MPSSE_send. </p><br><div class="spoiler">  <b class="spoiler_title">MPSSE_Send.vi</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/my/du/hi/myduhilu9cbsm8f3j_ceduagppq.png"><br>  <em>MPSSE_Send.vi</em> </p><br><p><img src="https://habrastorage.org/webt/fv/13/9m/fv139mrjy-t8l8cz-u82btswts8.png"><br>  <em>Block diagram</em> </p></div></div><br><p>  We convert the input buffer size ( <code>Array Size</code> ) to the <code>U16</code> two-byte type, subtract the unit, swap the low byte and high byte ( <code>Swap Bytes</code> ) - send the length starting from the low byte, and convert the two-byte number to a one-byte array ( <code>Type Cast</code> ). </p><br><p>  The <code>Type Cast</code> feature deserves special attention.  This is such a universal type converter, the acumen of which is sometimes very surprising.  In short, then: </p><br><p><img src="https://habrastorage.org/webt/k9/qp/0t/k9qp0tiyjs2ajjgisnhbfuaonpe.png"><br>  <em>Visually for programmers</em> </p><br><p>  However, this is not just a conversion of data to another type, it is also a heuristic interpretation.  This function allows you to convert between incompatible data types, and the function does not hesitate to align the input data and even remove the "extra" parts.  If the requested data type requires more memory than the input data, the function will allocate the missing amount.  For a novice developer, LabVIEW <code>Type Cast</code> can become a lifesaver, but with growing up, it is better to refuse such a converter ‚Äî it is very much hidden from view and can become a source of unforeseen errors.  It is better to use more explicit conversion methods, for example, <code>Coerce To Type</code> . </p><br><p>  When initializing the MPSSE processor, we set the maximum allowable buffer size for data transfer to 65536 bytes, hence the configuration file we should divide into fragments whose size does not exceed the specified size.  We use the <code>Array Subset</code> function, this function selects subarrays from an array starting with the <code>index</code> element and <code>length</code> .  We will split in the <code>While</code> loop, each iteration of the index will be increased by 65536, between iterations we will pass the value through the shift register.  As soon as it is not possible to pinch 65536 bytes from the main array, we take everything that is left, we send and stop the cycle. </p><br><p>  According to the download protocol, after all the data has been transmitted, you need to submit two more clock pulses in order for the FPGA to initialize.  To do this, after the cycle, we are sending another ‚Äúempty‚Äù byte. </p><br><div class="spoiler">  <b class="spoiler_title">SP_FT_MPSSE_FPGA.vi</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/vp/y4/wr/vpy4wrsts1szqayvnquvjtb2nzw.png"></a> <br>  <em>The picture is clickable</em> </p></div></div><br><p>  In order to understand the success of the firmware, we consider the flags, and if <em>CONF_DONE is</em> set to one, we <em>report the</em> top level VI, that everything is OK. </p><br><p>  The program is complete.  It remains to make sure that the FPGA is successfully flashed, and the board blinks happily with LEDs. </p><br><h2 id="pro-imenovanie-vp">  About naming VP </h2><br><p>     ,             ,       LabVIEW, ,      SubVI.              .        : </p><br><ul><li>    ‚Äî  ,     FTDI,           API D2XX.            "FT",  FT_Close.vi  FT_Read.vi. </li><li>   ‚Äî     MPSSE.        "MPSSE". : MPSSE_open.vi, MPSSE_Set_LByte.vi, MPSSE_Get_LByte.vi. </li><li>   ‚Äî    "Passive Serial"  MPSSE.     "S". , SP_FT_MPSSE_FPGA.vi ( ,   )  SP_LBYTE_BITS.ctl. </li><li>  .   .    , . </li></ul><br><p>     ( ),             .          <em>subVI</em> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  ,     ,           . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/ff/i0/fq/ffi0fqqs7gbi3aczbucvusrw2qi.jpeg"></p></div></div><br><p>         ,        LabVIEW,        .    ,     ,        ,         (    ).         . </p><br><h2 id="materialy-po-teme">  Materials on the topic </h2><br><ol><li>  . LabVIEW:  .  Per.  from English  by ed.  .‚Äì .: <br>  , 2008 ‚Äì 400 .: . </li><li> <a href="https://bitbucket.org/Shamrel/labview_mpsse">labview_mpsse</a> .   . </li><li> <a href="http://www.labfor.ru/devices/leso7">   </a> .    </li><li> <a href="http://www.ftdichip.com/Support/Documents/ProgramGuides/D2XX_Programmer%27s_Guide(FT_000071).pdf">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/429448/">https://habr.com/ru/post/429448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../429438/index.html">Own VPN client on JavaScript. Part 7 - Electron Context Component</a></li>
<li><a href="../429440/index.html">Own VPN client on JavaScript. Part 8 - Electron Setting Component</a></li>
<li><a href="../429442/index.html">Own VPN client on JavaScript. Part 9 - Electron component Callback</a></li>
<li><a href="../429444/index.html">Own VPN client on JavaScript. 10 part - Combining all components</a></li>
<li><a href="../429446/index.html">Own VPN client on JavaScript. Part 11 - Building an Application for Windows</a></li>
<li><a href="../429450/index.html">Generalized programming techniques in Rust: how we translated Exonum from Iron to actix-web</a></li>
<li><a href="../429452/index.html">The Pentagon began to declassify other people's malware</a></li>
<li><a href="../429456/index.html">Already a story: how did a startup culture start in the 1930s</a></li>
<li><a href="../429458/index.html">How I did the animation of the solar system for a second-grade son</a></li>
<li><a href="../429460/index.html">Summary of the report ‚ÄúWhat we know about microservices‚Äù (HL2018, Avito, Vadim Madison)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>