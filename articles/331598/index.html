<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Phoenix Framework - Webpack instead of Brunch, deploy using Distillery and a little systemd</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is an attempt by the author to bring together in the form of a small guide several topics that, in one way or another, almost all web app...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Phoenix Framework - Webpack instead of Brunch, deploy using Distillery and a little systemd</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/7dd/658/7e9/7dd6587e97a043a4801f1787449ed434.png" alt="logo"></p><br><p>  This article is an attempt by the author to bring together in the form of a small guide several topics that, in one way or another, almost all web application developers face, namely work with static files, configurations and application delivery to the server.  At the time of this writing, the last stable branch of the Phoenix Framework was the 1.2.x branch. </p><br><p>  Who cares why not Brunch and how to combine migrations with Distillery - I ask for cat. </p><a name="habracut"></a><br><p>  Phoenix for working with JS-code and assets uses <a href="http://brunch.io/">Brunch by</a> default - perhaps a very simple and fast bandler, but certainly not the most common and not the most powerful in terms of ecosystem capabilities and size (and answers to StackOverflow, of course).  Therefore, Brunch was replaced on the <a href="https://webpack.js.org/">Webpack</a> , de facto the number one bandler in the current world of the front end. </p><br><p>  But to solve issues of deployment, the framework provides almost nothing but the ability to put different configurations for different environments.  Judging by the answers of various developers on forums and other sites, many of them deploy their applications by installing development tools directly on the combat server and compiling and running the application using Mix.  For a number of reasons, I consider such an approach unacceptable, therefore, having tried several options for packaging an application in a self-contained package, I settled on Distillery. </p><br><p>  Since  Since an article is a tutorial, an absolutely unnecessary application will be developed as an example, displaying a certain list of certain users.  All code is available on <a href="https://github.com/h8/userlist">GitHub</a> , each step is fixed as a separate commit, therefore I recommend watching the change history.  Also, I will give links to commits on certain steps, so that, on the one hand, it was clearly visible on the diff, what changes were made, and on the other - not to clutter the text with listings. </p><br><h2 id="podgotovka">  Training </h2><br><p>  So, create a template for our project, with the indication that we will not use Brunch: </p><br><pre><code class="bash hljs">$ mix phoenix.new userlist --no-brunch</code> </pre> <br><p>  Nothing interesting happens here.  We need to go inside the new project, correct the database settings in the <em>config / dev.exs file</em> , start the creation of the Ecto repository and migrations ( <a href="https://github.com/h8/userlist/commit/cbfa0c924cc5b09dd80f9f21841ea40bb36470a0">commit</a> ): </p><br><pre> <code class="bash hljs">$ mix ecto.create &amp;&amp; mix ecto.migrate</code> </pre> <br><p>  In order to make an example at least a little clearer, I added a model of User entity, containing two fields - a name and a binary sign, whether the user is active or not ( <a href="https://github.com/h8/userlist/commit/b75e7f4793e50d6fd8687731e11b3610e16333a1">commit</a> ): </p><br><pre> <code class="bash hljs">$ mix phoenix.gen.model User users name active:boolean</code> </pre> <br><p>  Further, in order to fill the database with at least some data, I added three instances of "users" to the <em>priv / repo / seeds.exs file</em> , which is used for such purposes.  After that, you can perform the migration and insert the data into the database: </p><br><pre> <code class="bash hljs">$ mix ecto.migrate &amp;&amp; mix run priv/repo/seeds.exs</code> </pre> <br><p>  Now we have the migration in <em>priv / repo / migrations /</em> - it will be useful to us later, but for now, we must also add the http API, according to which the application can pick up the list of users in the format of a JSON object ( <a href="https://github.com/h8/userlist/commit/3f319b8e218dee030dc582b14db0194995944831">commit</a> ).  I will not clutter the text with listings, the diff on the GitHub will be more obvious, let me just say that a controller has been added, I twist and change the routing so that we have an "http-handle" along the path <em>/ api / users</em> , which will return JSON with users. </p><br><p>  That's all with the preparations, and at this stage the application can be started with the command </p><br><pre> <code class="bash hljs">$ mix phoenix.server</code> </pre> <br><p>  and make sure everything works as intended. </p><br><h2 id="staticheskie-fayly-i-js">  Static files and JS </h2><br><p>  Now let's pay attention to the structure of the project directories, namely, two of them - <em>priv / static /</em> and <em>web / static /</em> .  The first of them already contains the files that are needed to display the phoenix "Hello, World!"  pages, and this directory is used by the application, when it is running, to upload static files.  The second directory, <em>web / static /</em> , is enabled by default during development, and Brunch (in projects with it), roughly speaking, <em>puts</em> files from it into <em>priv / static</em> , processing them simultaneously ( <a href="http://www.phoenixframework.org/docs/static-assets">article in the official documentation about this</a> ). </p><br><p>  Both of the above mentioned directories are under the control of the version control system, files can be added to both of them, only if you add the files directly to <em>priv / static /</em> , they will not be processed by Brunch, and if they are added to <em>web / static /</em> , , but if you put the file in the <em>web / static / assets /</em> , then again will not ... It seems to me that something went wrong here, because I propose a more rigorous approach, namely: </p><br><ul><li>  the contents of the <em>priv / static /</em> directory never appear there as a result of some manual actions, only as a result of the work of some kind of pipeline.  Moreover, this directory is removed from VCS and added to <em>.gitignore</em> ; </li><li>  The <em>web / static /</em> directory contains static files that will be copied unchanged into <em>/ priv / static by the</em> corresponding pipeline when compiling, building the release package, etc. </li><li>  everything else that should appear in <em>priv / static /</em> (js, for example) lies somewhere else in the source tree and enters the resulting directory only through the corresponding pipeler bandler. </li></ul><br><p>  So, the next step I cleared <em>priv / static</em> from unnecessary files, and <em>robots.txt</em> and <em>favicon.ico</em> transferred to <em>web / static /</em> - we will return to them later.  Also, I cleaned the html layout of the main page and its template ( <a href="https://github.com/h8/userlist/commit/c7402fd39be122593e20e4d526676b76b87b89aa">commit</a> ). </p><br><p>  Before adding a Webpack, you need to initialize the NPM itself: </p><br><pre> <code class="bash hljs">$ npm init</code> </pre> <br><p>  I cleaned the resulting package.json, leaving only the most important thing in it ( <a href="https://github.com/h8/userlist/commit/9d7d1355c7160c5e44856de325e9e11ca3683b41">commit</a> ): </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"userlist"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"1.0.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Phoenix example application"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scripts"</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"MIT"</span></span> }</code> </pre> <br><p>  And after that we add Webpack itself ( <a href="https://github.com/h8/userlist/commit/05ced21de8029ef6e64ec2a53fe84e6af5e38863">commit</a> ): </p><br><pre> <code class="bash hljs">$ npm install --save-dev webpack</code> </pre> <br><p>  Now let's add some minimal JS code to the project, for example, like this: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"App js loaded."</span></span>);</code> </pre> <br><p>  For JS files, I created the <em>web / js /</em> directory, where I put the <em>app.js</em> file with the code above.  <em>Let's</em> connect it in the <em>web / templates / layout / app.html.eex template</em> by pasting the closing &lt;/ body&gt; tag: </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"&lt;%= static_path(@conn, "</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">js</span></span></span><span class="hljs-tag">/</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">app.js</span></span></span><span class="hljs-tag">") %&gt;</span></span><span class="undefined"><span class="undefined">"&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  It is very important to use the macro static_path, otherwise you will lose the ability to load resources with a digest-tag, which will lead to problems with the invalidation of caches by clients and in general, this is not according to the rules. </p><br><p>  Create a Webpack configuration ‚Äî the webpack.config.js file in the project root: </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">entry</span></span>: __dirname + <span class="hljs-string"><span class="hljs-string">"/web/js/app.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: __dirname + <span class="hljs-string"><span class="hljs-string">"/priv/static"</span></span>, <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">"js/app.js"</span></span> } };</code> </pre> <br><p>  From the code it can be seen that the resulting <em>app.js</em> file will be located in the <em>priv / static / js /</em> directory as intended.  At this stage, you can start the Webpack manually, but this is not very convenient, so let's add automation, since the framework allows it.  The first thing to do is add the watch shortcut to the scripts section of the <em>package.json</em> file: </p><br><pre> <code class="hljs objectivec"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"watch"</span></span>: <span class="hljs-string"><span class="hljs-string">"webpack --watch-stdin --progress --color"</span></span> },</code> </pre> <br><p>  Now Webpack can be run with the command </p><br><pre> <code class="bash hljs">$ npm run watch</code> </pre> <br><p>  But you don‚Äôt need to do this either, let Phoenix do it, especially since the endpoint of your application has the watchers option, which is exactly what is meant for running such external utilities.  Change the <em>config / dev.exs</em> file by adding the npm call: </p><br><pre> <code class="hljs objectivec">watchers: [npm: [<span class="hljs-string"><span class="hljs-string">"run"</span></span>, <span class="hljs-string"><span class="hljs-string">"watch"</span></span>]]</code> </pre> <br><p>  After that, the Webpack in the tracking mode for changes in directories and files will be launched every time along with the main application by the command </p><br><pre> <code class="bash hljs">$ mix phoenix.server</code> </pre> <br><p>  A commit with all the above changes <a href="https://github.com/h8/userlist/commit/03bc107109b950f5a65978062a49253ed01d3c86">here</a> . </p><br><p>  C JS code figured out a bit, but there are still files in the <em>web / static /</em> .  I also assigned the task of copying them to the Webpack, adding the copy extension to it: </p><br><pre> <code class="bash hljs">$ npm install --save-dev copy-webpack-plugin</code> </pre> <br><p>  Configure the plugin in the <em>webpack.config.js</em> file ( <a href="https://github.com/h8/userlist/commit/16bd8bb6f1da097ce4eb5508df30d05aab4527cc">commit</a> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> CopyWebpackPlugin = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"copy-webpack-plugin"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">entry</span></span>: __dirname + <span class="hljs-string"><span class="hljs-string">"/web/js/app.js"</span></span>, <span class="hljs-attr"><span class="hljs-attr">output</span></span>: { <span class="hljs-attr"><span class="hljs-attr">path</span></span>: __dirname + <span class="hljs-string"><span class="hljs-string">"/priv/static"</span></span>, <span class="hljs-attr"><span class="hljs-attr">filename</span></span>: <span class="hljs-string"><span class="hljs-string">"js/app.js"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">plugins</span></span>: [ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CopyWebpackPlugin([{ <span class="hljs-attr"><span class="hljs-attr">from</span></span>: __dirname + <span class="hljs-string"><span class="hljs-string">"/web/static"</span></span> }]) ] };</code> </pre> <br><p>  After these manipulations, our <em>priv / static /</em> directory will begin to be filled with two pipelines - JS processed and static files that do not require it.  On top of this stage, I added the display of the list of users with the help of JS ( <a href="https://github.com/h8/userlist/commit/ca4c31b0fa9ca72b8c7c4a1a051ff5e80a6f7a08">commit</a> ), visual style for inactive users ( <a href="https://github.com/h8/userlist/commit/9ff22eeeb152c43988473c0f305819fd5bbfee7c">commit</a> ) and a picture-logo for greater visualization of the work of the pipeline ( <a href="https://github.com/h8/userlist/commit/fc5eb18a49b8e1f3a94cced6138690eb5b56a56b">commit</a> ). </p><br><p>  The question may arise - what to do if you need to make pre-processing, for example, CSS.  The answer is banal - to put the CSS in a separate directory, add the appropriate plug-ins to the Webpack and set up a pipeline similar to that used for JS.  Or use css-loader'y, but this is a separate story. </p><br><h2 id="sborka-reliznogo-paketa-distillery">  Build release package.  Distillery. </h2><br><p>  Distillery is the second approach of Exrm in an attempt to make a good tool for packaging and creating release packages for Elixir projects.  Errors of the first were taken into account, much has been fixed, it is convenient to use Distillery.  Add it to the project, specifying the dependency in <em>mix.exs</em> : </p><br><pre> <code class="hljs json">{:distillery, <span class="hljs-attr"><span class="hljs-attr">"~&gt; 1.4"</span></span>}</code> </pre> <br><p>  Update the dependencies and create a release configuration template ( <a href="https://github.com/h8/userlist/commit/f7d489336e77e9143aaaf21584134d622cbcb3f9">commit</a> ): </p><br><pre> <code class="bash hljs">$ mix deps.get &amp;&amp; mix release.init</code> </pre> <br><p>  The last command will create a file <em>rel / config.exs of</em> approximately the following content: </p><br><div class="spoiler">  <b class="spoiler_title">Lot of code</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">Path</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">join</span></span>(["rel", "plugins", "*.exs"]) |&gt; <span class="hljs-type"><span class="hljs-type">Path</span></span>.wildcard() |&gt; Enum.map(&amp;Code.eval_file(&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>)) use Mix.Releases.Config, # This sets the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">release</span></span> built <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> `mix <span class="hljs-keyword"><span class="hljs-keyword">release</span></span>` default_release: :<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, # This sets the <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> environment used <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> `mix <span class="hljs-keyword"><span class="hljs-keyword">release</span></span>` default_environment: Mix.env() environment :dev <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> dev_mode: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> include_erts: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> cookie: :"Mp@oK==RSu$@QW.`F9(oYks&amp;xDCzAWCpS*?jkSC?Zo{p5m9Qq!pKD8!;Cl~gTC?k" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> environment :prod <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> include_erts: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> include_src: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> cookie: :"/s[5Vq9hW(*IA&gt;grelN4p*NjBHTH~[gfl;vD;:kc}qAShL$MtAI1es!VzyYFcC%p" <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">release</span></span> :userlist <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: current_version(:userlist) <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> applications: [ :runtime_tools ] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> </div></div><br><p>  I propose to leave it as it is for now.  Specified in the configuration is enough: one release: userlist, it's the same: default, because  the first and only release list, as well as two environments: dev and: prod.  The release here refers to the OTP Release, the set of applications that will be included in the resulting package, the ERTS version.  In this case, our release corresponds to the application: userlist, which is enough for us.  But, we can have several releases and several environments and combine them as needed. </p><br><p>  Distillery is expanded with plug-ins, so that any additional pipeline can be arranged during assembly.  More about plugins <a href="https://hexdocs.pm/distillery/plugins.html">here</a> . </p><br><p>  Prepare an application for release.  First of all, you need to edit the file <em>config / prod.secret.exs</em> , <em>fix the</em> database settings in it.  This file is not added to the VCS, therefore, in case of its absence, it is necessary to create it yourself with approximately the following content: </p><br><div class="spoiler">  <b class="spoiler_title">prod.secret.exs</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">use Mix.Config config :userlist, Userlist.Endpoint, secret_key_base: "uE1oi7t7E/mH1OWo/vpYf0JLqwnBa7bTztVPZvEarv9VTbPMALRnqXKykzaESfMo" # Configure your <span class="hljs-keyword"><span class="hljs-keyword">database</span></span> config :userlist, Userlist.Repo, adapter: Ecto.Adapters.Postgres, username: "phoenix", <span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: "", <span class="hljs-keyword"><span class="hljs-keyword">database</span></span>: "userlist_prod", pool_size: <span class="hljs-number"><span class="hljs-number">20</span></span></code> </pre> </div></div><br><p>  The next important step is to correct the configuration of the Userlist.Endpoint in the <em>config / prod.exs file</em> .  First of all, replace the host with the required one, and the port from 80 to the PORT parameter read from the environment and add the most important server option, which is a sign that this endpoint will start the Cowboy: </p><br><pre> <code class="hljs axapta">url: [host: <span class="hljs-string"><span class="hljs-string">"localhost"</span></span>, port: {:system, <span class="hljs-string"><span class="hljs-string">"PORT"</span></span>}], ... <span class="hljs-keyword"><span class="hljs-keyword">server</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span></code> </pre> <br><p>  Next, I added Babel to the JS code processing pipeline, since  UglifyJS, used by default in Webpack, is not trained to handle ES6: </p><br><pre> <code class="bash hljs">$ npm install --save-dev babel-loader babel-core babel-preset-es2015</code> </pre> <br><p>  And the Babel configuration section in <em>webpack.config.js</em> after the plugins: </p><br><div class="spoiler">  <b class="spoiler_title">webpack.config.js</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>: { <span class="hljs-attr"><span class="hljs-attr">loaders</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">test</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/\.js$/</span></span>, <span class="hljs-attr"><span class="hljs-attr">exclude</span></span>: <span class="hljs-regexp"><span class="hljs-regexp">/node_modules/</span></span>, <span class="hljs-attr"><span class="hljs-attr">loader</span></span>: <span class="hljs-string"><span class="hljs-string">"babel-loader"</span></span>, <span class="hljs-attr"><span class="hljs-attr">query</span></span>: { <span class="hljs-attr"><span class="hljs-attr">presets</span></span>: [<span class="hljs-string"><span class="hljs-string">"es2015"</span></span>] } } ] }</code> </pre> </div></div><br><p>  And the last thing is to add short deploy to the NPM configuration ( <a href="https://github.com/h8/userlist/commit/9a57577bebb1ae318af9f6f15decadd4d46337c7">commit</a> ): </p><br><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"scripts"</span></span>: { <span class="hljs-string"><span class="hljs-string">"watch"</span></span>: <span class="hljs-string"><span class="hljs-string">"webpack --watch-stdin --progress --color"</span></span>, <span class="hljs-string"><span class="hljs-string">"deploy"</span></span>: <span class="hljs-string"><span class="hljs-string">"webpack -p"</span></span> },</code> </pre> <br><p>  At this stage, you can try to build and run the release: </p><br><pre> <code class="bash hljs">$ npm run deploy $ MIX_ENV=prod mix phoenix.digest $ MIX_ENV=prod mix release $ PORT=8080 _build/prod/rel/userlist/bin/userlist console</code> </pre> <br><p>  With the first command we prepare JS (minification, etc.), copy static files;  the second generates a digest for all files;  the third directly collects the release for the corresponding environment.  Well, in the end - launching the application online, with the console. </p><br><p>  After the release, the <em>_build</em> directory will contain the unpacked (exploded) version of the package, and the archive will be located along the path <em>_build / prod / rel / userlist / releases / 0.0.1 / userlist.tar.gz</em> . </p><br><p>  The application will start, but when you try to get a list of users, an error will be caused, because  we did not apply migration for this database.  The documentation for Distillery <a href="https://hexdocs.pm/distillery/running-migrations.html">describes this point</a> , but I simplified it a bit. </p><br><h2 id="migracii">  Migrations </h2><br><p>  After the build, the executable file of the application provides us with one of the options called command: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">command</span></span> &lt;mod&gt; &lt;fun&gt; [&lt;args..&gt;] <span class="hljs-comment"><span class="hljs-comment"># execute the given MFA</span></span></code> </pre> <br><p>  This is very similar to rpc, with the difference that the command will be executed on an application that is not running as well.  We will create a module with the migration function, remembering that the application will not be running.  I placed this file in <em>lib / userlist / release_tasks.ex</em> ( <a href="https://github.com/h8/userlist/commit/373aa0f1584918c33a33ba76746fe2590368f1bf">commit</a> ): </p><br><pre> <code class="hljs ruby">defmodule Release.Tasks <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> Userlist.Repo <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">migrate</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Application</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:userlist</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span>} = Application.ensure_all_started(<span class="hljs-symbol"><span class="hljs-symbol">:ecto</span></span>) {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span>} = Repo.__adapter_<span class="hljs-number"><span class="hljs-number">_</span></span>.ensure_all_started(Repo, <span class="hljs-symbol"><span class="hljs-symbol">:temporary</span></span>) {<span class="hljs-symbol"><span class="hljs-symbol">:ok</span></span>, <span class="hljs-number"><span class="hljs-number">_</span></span>} = Repo.start_link(<span class="hljs-symbol"><span class="hljs-symbol">pool_size:</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) path = Application.app_dir(<span class="hljs-symbol"><span class="hljs-symbol">:userlist</span></span>, <span class="hljs-string"><span class="hljs-string">"priv/repo/migrations"</span></span>) Ecto.Migrator.run(Repo, path, <span class="hljs-symbol"><span class="hljs-symbol">:up</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">all:</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-symbol"><span class="hljs-symbol">:init</span></span>.stop() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  As you can see from the code, we load, and then run not all applications, but exactly necessary ones - in this case, this is only Ecto.  Now all that remains is to rebuild the release (only Elixir, since the rest has not changed): </p><br><pre> <code class="bash hljs">$ MIX_ENV=prod mix release</code> </pre> <br><p>  start migration: </p><br><pre> <code class="bash hljs">$ _build/prod/rel/userlist/bin/userlist <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> <span class="hljs-string"><span class="hljs-string">'Elixir.Release.Tasks'</span></span> migrate</code> </pre> <br><p>  and run the application: </p><br><pre> <code class="bash hljs">$ PORT=8080 _build/prod/rel/userlist/bin/userlist console</code> </pre> <br><p>  That's all, but there are still a couple of small things left.  For example, it is not very convenient to start migrations in this way, specifying the full module name, function.  Distillery provides hooks and commands for this (now others). </p><br><h2 id="huki-i-komandy-distillery">  Hooks and Distillery teams </h2><br><p>  The concept of hooks and commands is simple - these are ordinary shell scripts that are called at a certain stage of the application‚Äôs life (hooks) or manually (commands) and which are extensions of the main executable boot script.  Hooks can be of four types: pre / post_start and pre / post_stop. </p><br><p>  I added an example of two hooks to the project, <a href="https://github.com/h8/userlist/commit/0a4c7c0ede2bed45969593e40c3ae41310ca9bc1">see the code</a> , it will best explain how to do this. </p><br><p>  In turn, the commands will help to hide unnecessary details, so that, for example, the migrations look like: </p><br><pre> <code class="bash hljs">$ _build/prod/rel/userlist/bin/userlist migrate</code> </pre> <br><h2 id="esli-vam-nuzhen-manifestjson">  If you need manifest.json </h2><br><p>  When building a release, after executing the phoenix.digest command, all static files get a hash sum in their name (plus compressed versions are added), and a correspondence table is generated between the original file name and the new one, which is in the <em>priv / static / manifest.json</em> file , if you did not change its position in the configuration.  If suddenly you need information from it during the execution of the application, then you have two options: </p><br><ul><li><p>  add it to the list of files that are sent from the directory with statics in <em>lib / userlist / endpoint.ex</em> : </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">only</span></span>: ~<span class="hljs-selector-tag"><span class="hljs-selector-tag">w</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">fonts</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">images</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">js</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">favicon</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.ico</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">robots</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.txt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">manifest</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.json</span></span>)</code> </pre> <br><p>  after which, it can be picked up by Ajax, for example; </p><br></li><li><p>  if you need it on the backend, or if you want to render it in a template (I don‚Äôt know why, but suddenly it‚Äôs necessary), you can extend the LayoutView to this: </p><br><pre> <code class="hljs ruby">defmodule Userlist.LayoutView <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> use Userlist.Web, <span class="hljs-symbol"><span class="hljs-symbol">:view</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">digest</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">manifest</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Application</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_env</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-symbol"><span class="hljs-function"><span class="hljs-params"><span class="hljs-symbol">:userlist</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Userlist.Endpoint, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">%{}</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>[<span class="hljs-symbol"><span class="hljs-symbol">:cache_static_manifest</span></span>] <span class="hljs-params"><span class="hljs-params">||</span></span> <span class="hljs-string"><span class="hljs-string">"priv/static/manifest.json"</span></span> manifest_file = Application.app_dir(<span class="hljs-symbol"><span class="hljs-symbol">:userlist</span></span>, manifest) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> File.exists?(manifest_file) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> manifest_file <span class="hljs-params"><span class="hljs-params">|&gt; File.read! </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">else</span></span></span><span class="hljs-params"> %{} </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="hljs-params"><span class="hljs-keyword">end</span></span></span></span></code> </pre> <br><p>  so that later, somewhere in the template, write the following: </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> digest = </span><span class="xml"><span class="hljs-tag"><span class="javascript"><span class="xml"><span class="hljs-tag">&lt;</span></span></span><span class="hljs-name"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-name">%=</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag"> </span></span></span><span class="hljs-attr"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">raw</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag"> </span></span></span><span class="hljs-attr"><span class="javascript"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">digest</span></span></span></span></span><span class="javascript"><span class="xml"><span class="hljs-tag">() %&gt;</span></span></span></span><span class="javascript"><span class="xml"> </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br></li></ul><br><p>  Commit with this madness <a href="https://github.com/h8/userlist/commit/40b4bcf55584bc219aea0194620d3bfd11e95ee2">here</a> . </p><br><h2 id="systemd">  systemd </h2><br><p>  The last thing I would like to mention is the launch of the application on the combat server.  Since systemd appeared in our system, init-scripts writing is not something that has improved, but has simply become elementary. </p><br><p>  Assume that we will deploy the archive with the application in <em>/ opt / userlist /</em> and run as user userlist.  Create a <em>userlist.service</em> file with the following content ( <a href="https://github.com/h8/userlist/commit/8a0d07982cb1ce8dfeb809bef870410899285a66">commit</a> ): </p><br><pre> <code class="hljs pgsql"># Userlis <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a Phoenix, Webpack <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Distillery demo application [Unit] Description=Userlist application <span class="hljs-keyword"><span class="hljs-keyword">After</span></span>=network.target [Service] <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>=simple <span class="hljs-keyword"><span class="hljs-keyword">User</span></span>=userlist RemainAfterExit=yes Environment=PORT=<span class="hljs-number"><span class="hljs-number">8080</span></span> WorkingDirectory=/opt/userlist ExecStart=/opt/userlist/bin/userlist <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> ExecStop=/opt/userlist/bin/userlist stop <span class="hljs-keyword"><span class="hljs-keyword">Restart</span></span>=<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>-failure TimeoutSec=<span class="hljs-number"><span class="hljs-number">300</span></span> [Install] WantedBy=multi-<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.target</code> </pre> <br><p>  After that, all you need to do is copy it to <em>/ etc / systemd / system /</em> : </p><br><pre> <code class="bash hljs">$ sudo cp userlist.service /etc/systemd/system</code> </pre> <br><p>  Include in "autoload": </p><br><pre> <code class="bash hljs">$ sudo systemctl <span class="hljs-built_in"><span class="hljs-built_in">enable</span></span> userlist.service</code> </pre> <br><p>  And run the application: </p><br><pre> <code class="bash hljs">$ sudo systemctl start userlist</code> </pre> <br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  The purpose of this article was to try to gather together isolated information on different topics regarding Phoenix and to give some more or less complete idea about the life cycle of applications written in this wonderful framework.  A lot of things are left behind the scenes, there are a lot of topics worthy of individual articles, for example, methods of delivering release packages to a server, etc. </p><br><p>  I, as an author, understand perfectly well that I can be wrong, because I apologize in advance for errors or inaccuracies and ask to write about those in the comments. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331598/">https://habr.com/ru/post/331598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331586/index.html">Design of the city based on data. Lecture in Yandex</a></li>
<li><a href="../331588/index.html">Compressing photos without apparent loss of quality: the Yelp experience</a></li>
<li><a href="../331590/index.html">Using MapXtreme .Net</a></li>
<li><a href="../331594/index.html">GUI on Grafana for mgstat - system monitoring utilities on InterSystems Cach√©, Ensemble or HealthShare</a></li>
<li><a href="../331596/index.html">Level editor for three in a row</a></li>
<li><a href="../331600/index.html">Two in one: how to use vim and nano?</a></li>
<li><a href="../331604/index.html">How to create visual effects for games</a></li>
<li><a href="../331606/index.html">The digest of interesting materials for the mobile developer # 209 (June 19 - June 25)</a></li>
<li><a href="../331608/index.html">Java place in the HFT world</a></li>
<li><a href="../331612/index.html">Limit the number of method executions per second</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>