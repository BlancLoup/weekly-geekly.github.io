<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Recover Huffman Tables in Intel ME 11.x</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, Positive Technologies expert Dmitry Sklyarov at the Black Hat conference in London will talk about the structure of the file system on which In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Recover Huffman Tables in Intel ME 11.x</h1><div class="post__text post__text-html js-mediator-article">  <i>Today, Positive Technologies expert Dmitry Sklyarov at the Black Hat conference in London will talk about the <a href="https://www.blackhat.com/eu-17/briefings/schedule/index.html">structure of the file system on which Intel CSME / ME version 11.x is located</a> and some files for this system.</i>  <i>We present to your attention his article on the recovery of Huffman tables in Intel ME 11.x.</i> <br><br><img src="https://habrastorage.org/webt/y8/5r/wr/y85rwrvgodhd9khvw60c1-f-2pm.png"><br><br>  As you <a href="https://recon.cx/2014/slides/Recon%25202014%2520Skochinsky.pdf">know</a> , many Intel ME 11.x modules are stored in a flash memory in a packaged form, and two algorithms are used for compression - LZMA and <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman Encoding</a> .  For LZMA, there is a <a href="http://www.7-zip.org/sdk.html">public implementation</a> that can be used to decompress, but for Huffman everything is more complicated.  The Huffman Encoding unpacker in ME is implemented at the hardware level, and the construction of equivalent program code is a complex and non-standard task. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Previous versions of ME </h2><br>  After reading the source texts that are part of the <a href="http://io.netgarage.org/me/">unhuffme</a> project, it is easy to see that for previous versions of ME there are two sets of Huffman tables and there are two tables in each of the sets.  The presence of two tables (one for code and one for data) is probably due to the fact that the statistical properties of code and data are very different. <br><br>  Also noteworthy are the following properties: <br><br><ul><li>  For different sets of tables, the lengths of codewords differ (7‚Äì19 and 7‚Äì15 bits, inclusive). </li><li>  Each code sequence encodes an integer number of bytes (from 1 to 15 inclusive). </li><li>  Both sets use <a href="http://www.cs.uofs.edu/~mccloske/courses/cmps340/huff_canonical_dec2015.html">Canonical Huffman Coding</a> (this allows you to quickly determine the length of the next code word when unpacking). </li><li>  Within one set of lengths, the encoded values ‚Äã‚Äãfor any codeword are the same in all tables (Code and Data). </li></ul><br><h2>  Formulation of the problem </h2><br>  It can be assumed that in the Huffman tables for ME 11.x, the last three properties are also observed.  Then, to fully restore the tables, you need to find the following: <br><br><ul><li>  range of codeword lengths; </li><li>  boundaries of codeword values ‚Äã‚Äãhaving the same length (Shape); </li><li>  the length of the encoded sequences for each code word; </li><li>  coded values ‚Äã‚Äãfor each codeword in both tables. </li></ul><br><h2>  Splitting compressed data into separate pages </h2><br>  To obtain information about the individual modules, you can use the existing knowledge about the <a href="https://www.troopers.de/troopers17/talks/772-intel-me-the-way-of-the-static-analysis/">internal structures of the firmware</a> . <br><br>  Having examined the Lookup Table, which is part of the Code Directory Directory Partition, it is easy to determine for which modules Huffman coding is applied, where their packed data starts, and what size the module will have after unpacking. <br><br>  Having examined the Module Attributes Extension for a specific module, it is easy to find the size of the compressed and decompressed data and SHA256 from the unpacked data. <br><br>  Having fluently analyzed several firmware for ME 11.x, it is easy to notice that the data size after unpacking by Huffman is always a multiple of the page size (4096 == 0x1000 bytes).  At the beginning of the packed data is an array of four-byte integer values.  The number of array elements corresponds to the number of pages in the unpacked data. <br>  For example, for a module of size 81920 == 0x14000 bytes, the array will occupy 80 == 0x50 bytes and consist of 20 == 0x14 elements. <br><br><img src="https://habrastorage.org/webt/2a/lp/tg/2alptgtr8phkilu43_kj8bonwfg.png"><br><br>  The two high-order bits of each of the Little-Endian values ‚Äã‚Äãstore the table number (0b01 for the code and 0b11 for the data).  In the remaining 30 bits, the offset of the beginning of the compressed page relative to the end of the array of offsets is stored.  The above snippet describes 20 pages: <br><br><img src="https://habrastorage.org/webt/gq/be/w-/gqbew-3m16fgdc62am40xvi19fu.png"><br><br>  It is noteworthy that the packaged data offsets for each page are sorted in ascending order, and the packed data size for each page does not appear explicitly anywhere.  In the example above, the packed data for each specific page begins at the boundary of a multiple of 64 = 0x40 bytes, and the unused areas are filled with zeros.  But for other modules, you can establish that the presence of alignment is not mandatory.  This suggests that the unpacker stops when the amount of data in the unpacked page reaches 4096 bytes. <br><br>  Since we know the total size of the packaged module (from the Module Attributes Extension), we can divide the packaged data into separate pages and work with each page separately.  The beginning of a packed page is determined from the array of offsets, and the size by the offset of the beginning of the next page or the total size of the module.  In this case, after the packed data, there can be an arbitrary number of insignificant bits (these bits can have any values, but in practice they are usually zero). <br><br><img src="https://habrastorage.org/webt/y8/5r/wr/y85rwrvgodhd9khvw60c1-f-2pm.png"><br><br>  The screenshot shows that the last compressed page (starting at offset 0xFA40) consists of byte 0xB2 == 0b10110010, followed by 273 bytes with the value 0xEC == 0b11101100, and then only zeros.  Since the bit sequence 11101100 (or 01110110) is repeated 273 times, we can assume that it encodes 4096/273 == 15 identical bytes (most likely with values ‚Äã‚Äãof 0x00 or 0xFF).  Then the bit sequence 10110010 (or 1011001) encodes 4096-273 * 15 == 1 byte. <br><br>  This agrees well with the assumption that each code sequence encodes an integer number of bytes (from 1 to 15 inclusive).  However, it is not possible to fully restore the Huffman tables in this way. <br><br><h2>  Finding pairs of "compressed text - clear text" </h2><br>  As was <a href="https://www.troopers.de/troopers17/talks/772-intel-me-the-way-of-the-static-analysis/">shown earlier</a> , in different versions of firmware for ME 11, modules with the same name can be packaged with different algorithms.  If you parse the Module Attributes Extension for modules of the same name, packaged with both LZMA and Huffman, and extract the SHA256 values ‚Äã‚Äãfor each module, you will not find a single pair of modules packaged with different algorithms and having the same hash values. <br><br>  But if we recall that for modules packed with LZMA, SHA256 is usually considered to be compressed data, and to calculate SHA256 for modules after unpacking LZMA, a lot of suitable pairs will be found.  And for each such ‚Äúpaired‚Äù module, we immediately get several pairs of pages - in a packaged Huffman and unpacked form. <br><br><h2>  Shape, Length, Value </h2><br>  The presence of a large set of pages in compressed and open form (separately for code and data) allows you to recover all the code sequences used in these pages.  The solution of the problem is located at the junction of linear algebra and search engine optimization methods.  Probably, you can build a rigorous mathematical model that takes into account all the limitations, but since the task is one-time, it turned out to be faster to do part of the work manually, and to automate part. <br><br>  The most important thing is to at least approximately determine the Shape (points of change in the length of code sequences).  For example, that 7-bit sequences have values ‚Äã‚Äãfrom 1111111 to 1110111, 8-bit from 11101101 to 10100011, etc. Since Canonical Huffman Coding is used, knowledge of Shape allows you to determine the length of the following code sequence (the shortest sequence consists of only one , the longest - only from zeros, and the smaller the value, the longer the sequence). <br><br>  Since we do not know the exact size of the compressed data, all sequences consisting of only zero bits can be thrown out of the ‚Äútail‚Äù (since they are the longest, and the appearance of the rarest code sequence in the last position is unlikely). <br><br>  When each compressed page can be represented as a set of code sequences, you can begin to determine the lengths of the values ‚Äã‚Äãthey encode.  The sum of the lengths of the encoded values ‚Äã‚Äãfor each page should be 4096 bytes.  This allows you to create a system of linear equations, where the lengths of the encoded values ‚Äã‚Äãare unknown, the coefficients are the number of occurrences of the corresponding code sequence in the compressed page, and the place of the free term is always 4096. The code and data pages can be processed together, since for identical code sequences the lengths of the coded values ‚Äã‚Äãmust match. <br><br>  With enough pages (and equations), the only solution to the system is easily found by the Gauss method.  And having the plaintext, knowing the length of each value and the order in which they are followed, it is easy to get a match for the code sequences and the values ‚Äã‚Äãthey encode. <br><br><h2>  Unknown sequences </h2><br>  After processing all the available ‚Äúpaired‚Äù pages, it will turn out to find out the values ‚Äã‚Äãfor approximately 70% of the sequences from the code table and 68% of the sequences from the data table.  Lengths will be known for about 92% of the sequences.  And there will remain some uncertainty in the Shape: in some places either one value of a shorter length or two values ‚Äã‚Äãof a greater length can be used, and it is impossible to determine the boundary until one of the values ‚Äã‚Äãis found in the packed data. <br><br>  Now we can proceed to the restoration of values ‚Äã‚Äãfor code sequences that are found only in modules for which there are no open texts. <br><br>  If a sequence with an unknown length is encountered, another line is added to the system of equations, and this allows you to quickly determine the length.  But how to determine the value without having a clear text? <br><br><h2>  Verifier and brute-force </h2><br>  Fortunately, SHA256 from the unpacked module is stored in the metadata.  And if we correctly guess the value of all unknown code sequences in all pages that make up the module, the calculated SHA256 value should match the SHA256 value from the Module Attributes Extension. <br><br>  When the total length of unknown sequences is 1 or 2 bytes, the unknown bytes are simply found by a frontal search.  You can do the same with 3 and even 4 unknown bytes (especially if they are located close to the end of the module), but the search can take from several hours to several days on one core (it is easy to parallelize to several cores or machines).  Attempts to search 5 or more bytes were not made. <br><br>  Thus it is possible to recover several more code sequences (and several modules).  But then there are only modules in which the total amount of unknown bytes exceeds the capabilities of the brute-force selection. <br><br><h2>  Heuristics </h2><br>  However, the presence of a large number of modules, slightly differing from each other, allows you to apply different heuristics and use them to find the values ‚Äã‚Äãof unknown code sequences. <br><br><h3>  Using the second Huffman table </h3><br>  Since there are two Huffman tables in the unpacker, the compressor tries to compress the data of each of them, and leaves the version that takes up less space.  As a result, the division into "code" and "data" is conditional.  And when changing part of a page, another table may be more efficient.  That is, looking at other versions of the same module, you can find identical fragments that were packed by another table, and so recover unknown bytes. <br><br><h3>  Reuse </h3><br>  When one code sequence occurs many times in one (or different) modules (for example, in code and in data), it is often easy to determine which restrictions are imposed on unknown values. <br><br><h3>  Constants and tables with offsets </h3><br>  In the field of these modules, constants and offsets are quite common (for example, to text strings or functions).  Constants can be common for different modules (for example, for hashing functions and encryption algorithms), and offsets are unique for each version of the module, but should refer to the same (or very similar) pieces of data or code.  And their values ‚Äã‚Äãare very easy to restore. <br><br><h3>  String constants from open libraries </h3><br>  Some pieces of ME code were obviously borrowed from open-source projects (for example, wpa_supplicant), and fragments of text strings are easily guessed by context and by peeping at the source code. <br><br><h3>  Open Library Code </h3><br>  Looking at the sources and finding the text of the function, for the compiled code of which is unknown a few bytes, you can work with the compiler and guess which values ‚Äã‚Äãare appropriate in this place. <br><br><h3>  Similar functions in modules of another version </h3><br>  Since in different (but close) versions of one module there should not be strong differences, sometimes it is enough to find an equivalent function in a module of another version, and by its code understand what should be in unknown bytes. <br><br><h3>  Similar features in previous versions of ME </h3><br>  If the code is not taken from public sources, some fragment is unknown in all available versions of the module, and is not found in any other module (that‚Äôs how it was with the amt module) you can find the same place (for example, in ME 10), find out the logic functions, and then project it to an unknown place in ME 11.x. <br><br><h2>  Process convergence </h2><br>  Starting from the modules in which there were the least unknown sequences, and combining different heuristics, it was possible to increment the known part of the Huffman tables step by step (each time checking the correctness of the assumptions by calculating SHA256).  With increasing coverage, the modules, where the number of unknown sequences was initially measured in dozens, turned out to be not so frightening.  The process looked convergent, but everything came up against amt. <br><br>  This module is the largest in size (on the order of 2 megabytes, approximately 30% of the total volume), contains many code sequences that are not found in any other module, but are found in all versions of amt.  You can guess several sequences with a high probability, but the only way to test an assumption is to guess them all (so that SHA256 matches).  Thanks to the invaluable help of Maxim Goryachiy, we managed to overcome this barrier, as a result of which we were able to unpack any of the modules contained in the firmware we have and packed with the Huffman algorithm. <br><br>  Over time, new firmware appeared, and not previously encountered code words appeared in them.  But each time one of the heuristics worked, the module was successfully unpacked and the coverage of the tables increased. <br><br><h2>  Final touch </h2><br>  By mid-June 2017, we were able to recover approximately 89.4% of the sequences for the code table and 86.4% of the sequences for the data table.  But the chances of building a reasonable time 100% coverage of the tables through the analysis of new modules are very weak. <br><br>  On June 19, <a href="https://github.com/IllegalArgument/Huffman11">fragments of Huffman tables</a> were <a href="https://github.com/IllegalArgument/Huffman11">published</a> on GitHub by a user with the nickname IllegalArgument, covering 80.8% of the sequences for the code table and 78.1% of the sequences for the data table.  Probably, the author (or authors) used a similar approach based on the analysis of available firmware.  And in the published tables there was nothing new. <br><br>  And on July 17, Mark Yermolov and Maxim Goryachiy got the opportunity to find out the unpacked values ‚Äã‚Äãfor any compressed data.  We prepared 4 compressed pages (two for the code and for the data), and restored all <a href="https://github.com/ptresearch/unME11">1519 sequences for both tables</a> . <br><br>  At the same time, one strange place was found.  In the Huffman table for data, the value 00410E088502420D05 corresponds to both the sequence 10100111 (8 bits long) and the sequence 000100101001 (12 bits long).  This is a clear redundancy, but most likely it is due to a random error. <br><br>  The resulting Shape is as follows: <br><br><img src="https://habrastorage.org/webt/iw/wb/x0/iwwbx02mjf-4pugtla3lkrvbfzi.png"><br><br>  <b>Posted by</b> Dmitry Sklyarov, Positive Technologies </div><p>Source: <a href="https://habr.com/ru/post/344056/">https://habr.com/ru/post/344056/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344046/index.html">Extending Ansible with plugins: part 1</a></li>
<li><a href="../344048/index.html">What is virtualization and how does a virtual server work?</a></li>
<li><a href="../344050/index.html">What's new in WebStorm 2017.3</a></li>
<li><a href="../344052/index.html">Short shoulder match</a></li>
<li><a href="../344054/index.html">Practical use of multiple bounds generic in Java</a></li>
<li><a href="../344058/index.html">Mac OS High Sierra, is there a remote ‚Äúpasswordless root‚Äù? (Yes, but unlikely)</a></li>
<li><a href="../344060/index.html">Tale of how SQL saves time</a></li>
<li><a href="../344062/index.html">The evolution of solid-state drives: from the first models of the 70s to the present day</a></li>
<li><a href="../344064/index.html">GDPR - new rules for the processing of personal data in Europe for the international IT market</a></li>
<li><a href="../344066/index.html">[Translation of the article] 7 basic rules for protection against phishing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>