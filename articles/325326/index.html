<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>3.5 years, 500k Go lines. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a translation of Nate Finch‚Äôs article ( original published March 24, 2017). 


 January 31, 2017 was my last day at Canonical after 3.5 years ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>3.5 years, 500k Go lines. Part 1</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>This is a translation of Nate Finch‚Äôs article ( <a href="https://npf.io/2017/03/3.5yrs-500k-lines-of-go/">original</a> published March 24, 2017).</em> </p><br><p>  January 31, 2017 was my last day at Canonical after 3.5 years of work on one of the largest open source projects written in Go - <a href="https://github.com/juju/juju">Juju</a> . </p><br><p>  At the time of writing, the main <a href="http://github.com/juju/juju">Juju</a> repository is 3,542 files, 540,000 lines of Go code (this number does not include 65,000 comment lines).  With all the dependencies, except for the standard library, Juju contains 9,523 files, which contain 1,963,000 lines of Go code (excluding 331,000 lines of comments). </p><br><p>  Here are a few lessons learned from approximately 7,000 hours of work on this project. </p><a name="habracut"></a><br><p>  It is worth noting that not everyone in the Juju team agrees with me, and the code base is so great that you can work with it for a year and not see even 2/3 of the code.  So treat the following with some skepticism. </p><br><h2 id="juju">  Juju </h2><br><p>  Juju is a tool for orchestrating services, akin to Nomad, Kubernetes and the like.  Juju consists (mainly) of two binary files: client and server.  The server can work in several different modes (previously the server was in the form of several different files, but since they were 99% identical, it was easier to make one that is easier to distribute).  The server can work in the cloud of your choice.  You can run several additional instances on separate machines and they will be managed by a central server.  The client and the auxiliary machines communicate with the main server via RPC over the web socket. </p><br><p>  Juju is a monolith.  Any microservices, for work one binary file is necessary.  And it really works well, because Go is good at competitiveness - no need to worry about some kind of gorutin blocking anything.  Therefore, it is convenient to use everything in one process.  You avoid overheading from serialization and other interprocess interactions.  This makes code more interdependent, but <em>sharing responsibility is</em> not always the highest priority in development.  As a result, it seems to me that the monolith was much easier to develop and test than if it were a bunch of small services, and correct code splitting and encapsulation would help avoid confusing code. </p><br><h2 id="upravlenie-paketami">  Package management </h2><br><p> Juju does not use vending.  In my opinion, it would be worth it, but the project was launched before normal tools appeared, and the transition to the use of vendoring never seemed worth the time spent on it.  Now we use Roger Peppe godeps (by the way, this is not a <code>godep</code> ) to fix the revisions.  True, there is a problem with him - he brings a mess to other packages in your GOPATH, setting them in accordance with the specified commit, so if you ever build another project that does not use vending, there is a possibility that the dependencies will not be collected from the master - flowers.  However, revision fixing gave us repeatable builds (until no one did anything really terrible in the external repositories), and there were no special problems, <em>except</em> that the file containing the commit hashes was always a point of conflict. merge  Since it was often changed, and even by a large number of developers, sooner or later a situation had to occur when two people changed the same or adjacent lines in this file <em>(for <code>godeps</code> , the <code>godeps</code> utility uses a file in which to update the sources) the packages and the hash of the commit to be installed are indicated).</em>  This became a real problem, so I started writing a utility to automatically resolve these conflicts (since <code>godeps</code> keeps the date of a committed commit, it is almost always possible to just choose a more recent commit).  The problem remains when using <code>glide</code> , as well as any similar tool that stores dependency hashes in a single file.  Not sure I know how to fix it. </p><br><p>  All in all, I have never had the feeling that package management is a huge problem.  The insignificant thing in our daily work ... so it was always strange for me to read stories that people don‚Äôt take Go seriously due to the lack of a package manager.  Most third-party repositories support stable APIs, and we could tie our code to a specific commit ... well, that was not a problem. </p><br><h2 id="organizaciya-proekta">  Project organization </h2><br><p>  Juju is an 80% monolithic repository (monorepo) located at &lt;github.com/juju/juju&gt;, and the remaining 20% ‚Äã‚Äãof the code exists in separate repositories (at &lt;github.com/juju&gt;).  There are pros and cons in allocating a mono-repository ... It's easy to make large-scale changes across the code, but it also means that you can most likely not support a stable API in <code>foo/bar/baz/bat/alt/special</code> ... so we didn't support it.  And this translates into insanity for anyone importing a package from this monorepository and will think that the package will continue to exist in about the same way in the future.  Vending, of course, will save in this case, but if you ever need to upgrade, good luck. </p><br><p>  A mono-repository also meant that we were less cautious about the API, the division of responsibility, and the code was more interdependent than it could be.  Not to say that we were careless, but it seems to me that things outside the main Juju repository were much more standardized due to the same division of responsibility, quality and stability of the API.  Of course, the documentation for external repositories was also better, and this in itself means a lot. </p><br><p>  The problem with external repositories was managing packages and synchronizing changes between repositories.  If you updated the external repository, you had to make changes to the main repository after that in order to start using the changes to the external one.  Of course, it is impossible to do this atomically for two github repositories.  And sometimes the ability to make changes to the master is blocked due to code inspection or failed tests or something else, and then you have potentially incompatible changes found in the external repository that anyone who decides to make changes to this external repository stumbles on . </p><br><p>  I will say one more thing: utility repositories are evil.  Many times we were going to backport the fix to a sub-package of our <code>utils</code> repository to an earlier version of Juju, and once again realized that many, many other unrelated changes would come up with this fix.  And all because we have too much of everything in one repository.  It turns out that we had to do all sorts of horrible branches, ‚Äúcrutch‚Äù, ‚Äúcopy-paste‚Äù, and in general it's all bad and don't do it.  Just say no to the <code>utils</code> packages and repositories. </p><br><h2 id="vseobschaya-prostota">  General simplicity </h2><br><p>  The simplicity of Go was definitely a major success factor for the Juju project.  Only about a third of the developers we hired used to work with Go.  The rest were newbies.  A week later, most newcomers have already become very experienced.  The size and complexity of the product was much more of a problem for developers than the language itself.  There have been cases when more experienced Go developers received questions from the team about how best to make X in Go, but this was quite rare.  Compare this with C # in my previous work, where I constantly explained different parts of the language or why something works that way and not otherwise. </p><br><p>  Simplicity was a boon to the project, since we could hire good overall developers, not just those who had Go programming experience.  That is, this language has never been an obstacle for understanding the new part of the code.  Juju was so huge that no one could know the details of the whole project.  But at the same time, almost everyone could get into a piece of code and find out what 100 or so lines containing an error do and how they do it (more or less).  Most of the problems with learning a new piece of code were the same as they would be in any language - what is the architecture, how the information is transmitted, what are the expectations <em>(orig .: expectations)</em> . </p><br><p>  Since Go has very little magic, it seems to me that it was easier to implement this project on Go than if it were some other language.  You do not have the magic that other languages ‚Äã‚Äãhave.  Magic that can add unexpected functionality with seemingly simple and clear lines of code.  While studying the old Go code piece you will never have to wonder "how does it work?" Because it‚Äôs just a Go code piece.  Of course, this does not mean that there is no complicated code over which it is necessary to ‚Äúbrainwash‚Äù, hidden expectations and preliminary conditions ... but at least this is not hidden behind language features that obscure the basic algorithms. </p><br><h2 id="testirovanie">  Testing </h2><br><h3 id="komplekty-testov">  Test suites </h3><br><p>  At Juju, we used <a href=""><code>gocheck</code></a> Gustavo Nieyemer to run our tests.  Thanks to the features of <code>gocheck</code> it is possible to carry out full testing (full stack testing), deploying the Juju server and mongo database environment in automatic mode before each test, thereby reducing overhead costs for the developer.  After the tests were written, it turned out that they are simply huge, but you could just embed this "basic set" into the structure of your test set, and it will automatically do all the dirty work for you.  As a result, our unit tests were performed for almost 20 minutes on a very productive laptop, because for each test a lot of actions were performed.  Such a large amount of test code made them fragile and difficult to understand and debug.  To understand why the test passed or failed, you needed to understand all the code that ran before the open brace of your test function, and since it is easy to embed a set into a set, often LOT of which was done before this open brace. </p><br><p>  In the future, instead, I will stick to the standard library for testing.  I like that tests with the standard library are written the same way as regular Go code, and also that dependencies should be explicit.  If you want to run the code at the beginning of your test, you can simply put the method there ... you must put the method there. </p><br><h3 id="time-v-butylke">  <code>time</code> in a bottle </h3><br><p>  The <code>time</code> package is a curse of tests and test code.  If you have a code that should time out after 30 seconds, how do you test it?  Do the test take 30 seconds to complete?  And the rest of the tests run for 30 seconds, if something goes wrong?  This is connected not only with <code>time.Sleep</code> , but also with <code>time.After</code> or <code>time.Ticker</code> ... well, this is a disaster during the tests.  And not to mention that when testing (especially when running with the -race key), your code can run much slower than in production. </p><br><p>  The solution is to make fun of time ... which is, of course, non-trivial, because the <code>time</code> package is just a bunch of top-level functions.  Therefore, wherever the <code>time</code> package is used, you need to take your special interface instead, which is a wrapper for <code>time</code> , and then pass this fake <code>time</code> for tests, which you can already control.  This greatly increased our time to create ready-made assemblies and propagate changes in the code.  For a long time, it was a constant source of flakey tests.  These are tests that will take place most of the time, but if on some day the CI machine was thoughtful, some random tests failed.  And when you have hundreds of thousands of lines of tests, there is a high probability that a test will not pass, and, most likely, it will not be the same test as the last time.  The repair of the flakey test was similar to the game "kill the mole" <em>(orig .: whack-a-mole; a slot machine in which out of 9 holes the moles protrude, which must be hammered)</em> . </p><br><h2 id="schaste-kross-kompilyacii">  Cross compilation happiness </h2><br><p>  I don‚Äôt know the exact number of all OS and architecture combinations, but Juju‚Äôs server is precisely built for Windows and Linux (Centos and Ubuntu), as well as for many architectures, not just for amd64, but even for such eccentric ones as ppc64le, arm64 and s390x. </p><br><p>  Juju first used gccgo for architectures that the gc compiler did not support.  Because of this, there were a few mistakes in Juju, where gccgo was doing some kind of subtle crap.  When gc was updated and began to support all architectures, we were very pleased to throw out an additional compiler from the project and work only with gc. </p><br><p>  When we switched to gc, architectural-specific errors almost disappeared.  And it's great, given the breadth of the supported Juju architectures, as well as the fact that usually those eccentric architectures used large companies that have a lot of leverage over Canonical. </p><br><h3 id="os-specifichnye-oshibki">  OS specific errors </h3><br><p>  First, when we first started building support for Windows, we had a few bugs related to the OS (we all developed on Ubuntu, so Windows-specific errors did not come up until it worked out CI).  They basically boiled down to two common file system errors. </p><br><p>  The first is the use of default forward slashes for paths in tests.  For example, if you know that the configuration file should be located in the "juju" subfolder and called "config.yml", then your test can verify that the file path is <code>folder + "/juju/config.yml"</code> , and under Windows it should be <code>folder + "\juju\config.yml"</code> . </p><br><p>  When creating new directories, even in tests, use <code>filepath.Join</code> instead of <code>path.Join</code> , and certainly not by combining strings and slashes.  <code>filepath.Join</code> will use the correct slashes for the OS.  To compare paths, always use <code>path.ToSlash</code> to bring paths to a canonical form, which can already be compared. </p><br><p>  Another common mistake was that Linux developers allow you to delete / move an open file.  This does not work in Windows, because Windows locks the file when it is opened.  This often happened in the form of a call to <code>defer file.Delete()</code> , which, according to the FIFO, was called before the deferred call to <code>file.Close()</code> and, thus, an attempt was made to delete the file that was still open.  Embarrassment.  One solution is to simply always call <code>file.Close()</code> before doing the move or delete.  Note that you can call Close several times, so it‚Äôs safe to call it before deleting, even if you already have <code>defer file.Close()</code> , which will work at the end of the function. </p><br><p>  None of these errors is difficult, and I believe that such strong support for cross-platform in the standard library simplifies the development of cross-platform code. </p><br><h2 id="obrabotka-oshibok">  Error processing </h2><br><p>  Error handling in Go definitely had a beneficial effect on Juju's stability.  The fact that you can tell where a particular function might fail with an error makes it much easier to write code that is waiting for a crash, and does it gracefully. </p><br><p>  For a long time, Juju simply used the standard <code>errors</code> package.  However, we felt that we needed more context in order to better track the path of the code that caused the error, and we thought that it would be nice to save more detailed information about the error and also add context to it (for example, when using <code>fmt.Errorf</code> information is lost about the original error, if, say, it would be an error ( <code>os.NotFound</code> ). </p><br><p>  A couple of years ago, we started developing our own error package, which captures more context without losing the original information about the error.  After fruitless throwing in different directions, we combined all our ideas into <a href="https://github.com/juju/errors">https://github.com/juju/errors</a> .  This, of course, is not an ideal library, and over the years it has expanded due to new features, but it was a good start. </p><br><p>  The main problem is that you always need to call <code>errors.Trace(err)</code> when returning an error in order to find out the current file name and line number when you need to display such a thing as stack trace.  Today, I would choose the &lt;github.com/pkg/errors&gt; package from Dave Cheney, which captures the stack trace at the time the error was created and avoids full tracing.  Honestly, I don‚Äôt find the stack trace on error just super useful.  In practice, unexpected errors have sufficient context from just <code>fmt.Errorf("while doing foo: %v", err)</code> , so most often the stack trace is not needed.  The ability to explore the properties of the original error can sometimes come in handy, but most likely not as often as you think.  If <code>foobar.init()</code> returns something like <code>os.IsNotFound</code> , does this really help your code?  In most cases, no. </p><br><h2 id="stabilnost">  Stability </h2><br><p>  For such a huge project, Juju is very stable (this does not mean that there are no many mistakes in it ... I just mean that it almost never fell or was very buggy).  I think a lot depends on the language.  The company I worked for before Canonical had a million lines of C # code, and it often fell with "null reference" exceptions and other unhandled exceptions.  Honestly, I don‚Äôt remember ever seeing a panic because of the empty pointer in Juju production code, only occasionally in the development process, when I did some stupid things in the new code. </p><br><p>  I‚Äôm sure that the multiple return pattern in Go serves to indicate errors.  Using the template <code>foo, err :=</code> and always always checking for errors - this really leads to a very small chance of encountering a null pointer.  Checking for an error before accessing the returned variable (s) is the basic principle of Go, so important that we document exceptions to this rule.  The additional error return value cannot be ignored or forgotten due to compiler checks for unused variables.  This quite well reduces the problem of null pointers in Go, as compared to other similar languages. </p><br><h2 id="dzheneriki">  Generics </h2><br><p>  This section will be short because ... well, you know.  Only once or twice while working on Juju, I felt that I personally lacked generics.  And I do not remember that during the review of the code I would like generics for foreign sources.  I was happy that I did not have to ‚Äúgrokat‚Äù the cognitive (intellectual) complexity with which I met with generics in C #.  Go interfaces are good enough for 99% of cases and I don't mean <code>interface{}</code> .  We rarely used <code>interface{}</code> in Juju, and almost always it was because some kind of serialization was performed. </p><br><h2 id="prodolzhenie-sleduet">  To be continued </h2><br><p>  This is already a rather long post, so I think it's time to stop.  I have many more specific things that I can talk about ... about the API, versioning, database, refactoring, logging, idioms, code inspections, etc. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325326/">https://habr.com/ru/post/325326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325312/index.html">The right to oblivion does not apply to data in business registers: decision of the Court of Justice of the European Union of March 9, 2017</a></li>
<li><a href="../325316/index.html">MySQL sample rotation</a></li>
<li><a href="../325318/index.html">How I stopped being afraid and re-invented QML</a></li>
<li><a href="../325320/index.html">Node.js Streams and Reactive Programming</a></li>
<li><a href="../325322/index.html">Productive weekend: when all things can be put off until later</a></li>
<li><a href="../325328/index.html">Tuning SQL Server 2012 under SharePoint 2013/2016. Part 2</a></li>
<li><a href="../325330/index.html">Security Watch: IBM QRadar SIEM</a></li>
<li><a href="../325334/index.html">Stanislavsky data center: how DataLine corporate theater works</a></li>
<li><a href="../325336/index.html">Iron for nuclear winter - with protection from cold, fog and smoke</a></li>
<li><a href="../325338/index.html">Russian Maxim Senah confessed to involvement in the Windigo cyber campaign.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>