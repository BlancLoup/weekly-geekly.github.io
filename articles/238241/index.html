<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Access to HID devices from a Qt program for Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 With the release of Qt 5, there was a convenient opportunity to expand the list of platforms supported by the program to mobile OS, in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Access to HID devices from a Qt program for Android</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  With the release of Qt 5, there was a convenient opportunity to expand the list of platforms supported by the program to mobile OS, in particular on Android. <br>  The process of porting the program from the desktop version of Qt to the mobile has been reduced to a banal recompilation.  The interface and the logic started right away, except for the part without which, in fact, the program is useless: exchange with an HID device. <br><a name="habracut"></a><br><h4>  First difficulties </h4><br>  From the very beginning, the HIDAPI library is used to communicate with the device.  It is multiplatform and easy to use. <br>  The first difficulty encountered was that there is no hidraw for Android, which was used to access devices for desktop Linux.  To work around, I had to switch to using the libusb library and its interface to it in HIDAPI. <br>  The first launch showed that the enumeration of devices works, but it is impossible to open the device file, due to the lack of rights of the application. <br>  In the README libusb / android file there is a description of possible ways to circumvent this problem: either change the rights of the device file, or use the android.hardware.usb.UsbDevice interface to open devices. <br><br>  A simple change of the file access mask to 777 on the root device confirmed the operability of the chosen scheme, but also led to the understanding that this is not quite the right way, because  It works on a very small circle of devices.  Therefore, I had to climb into the jungle API Android. <br><br>  Reading the documentation showed that there are two ways to access the device: using an intent filter and a simple listing of devices. <br>  The first way to make it work failed; no events occurred when the device appeared in the system.  Actually, this path is also a dead end, because  implies that the program must be started before the device is connected, and this means that we should take full advantage of the provided API for accessing USB. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to get by with a minimum of alterations in the existing code, it was decided to bring to the Java part only the code associated with the request for permission to access the device from the user and the actual opening of the device.  The rest of the work on enumerating devices and exchanging data is done by the HIDAPI-libusb bundle. <br><br><h4>  Implementation. </h4><br>  The first thing that had to be done was to request permission from the user to open the device. <br>  Again, adapting to the existing algorithm, we got the following: when a device is found, the path to its file is passed to a function in the Activity class of the program via the JNI interface: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> HidTransport::openAndroidDevice(QString devPath) { QAndroidJniObject dP = QAndroidJniObject::fromString(devPath); jint dFD = QAndroidJniObject::callStaticMethod&lt;jint&gt;(<span class="hljs-string"><span class="hljs-string">"org/HidManager/HidDevice"</span></span>, <span class="hljs-string"><span class="hljs-string">"tryOpenDevice"</span></span>, <span class="hljs-string"><span class="hljs-string">"(Ljava/lang/String;)I"</span></span>, dP.object&lt;jstring&gt;()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dFD; }</code> </pre> <br><br>  Here I want to make some digression: for some reason, the Qt interface to the JNI can only be called static class methods.  Therefore, we are actually creating singelton.  Below are the constructor and onCreate of the Activity class: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HidDevice m_instance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> UsbManager m_usbManager; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> PendingIntent mPermissionIntent; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> HashMap&lt;String, Integer&gt; deviceCache = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HashMap&lt;String, Integer&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String ACTION_USB_PERMISSION = <span class="hljs-string"><span class="hljs-string">"com.android.example.USB_PERMISSION"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HidDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_instance = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_usbManager==<span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { m_usbManager = (UsbManager) m_instance.getSystemService(Context.USB_SERVICE); } mPermissionIntent = PendingIntent.getBroadcast(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(ACTION_USB_PERMISSION), <span class="hljs-number"><span class="hljs-number">0</span></span>); IntentFilter filter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IntentFilter(ACTION_USB_PERMISSION); registerReceiver(mUsbReceiver, filter); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); }</code> </pre><br><br>  The tryOpenDevice function, called from native code, looks like this: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tryOpenDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String devPath)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deviceCache.containsKey(devPath)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = deviceCache.get(devPath); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fd; } deviceCache.put(devPath, -<span class="hljs-number"><span class="hljs-number">1</span></span>); HashMap&lt;String, UsbDevice&gt; deviceList = m_usbManager.getDeviceList(); Iterator&lt;UsbDevice&gt; deviceIterator = deviceList.values().iterator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(deviceIterator.hasNext()) { UsbDevice device = deviceIterator.next(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (devPath.compareTo(device.getDeviceName())==<span class="hljs-number"><span class="hljs-number">0</span></span>) { m_usbManager.requestPermission(device, mPermissionIntent); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } }</code> </pre><br><br>  deviceCache acts as an intermediate storage for the state of the device opening process.  This option was chosen because the native code algorithm tries to open every found but not yet open device with a certain frequency. <br><br>  Next, the Android permissions mechanism comes in and this function is used to get the results: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BroadcastReceiver mUsbReceiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BroadcastReceiver() { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ String action = intent.getAction(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ACTION_USB_PERMISSION.equals(action)) { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { UsbDevice device = (UsbDevice)intent.getParcelableExtra(UsbManager.EXTRA_DEVICE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(device != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ m_instance.openDevice(device); } } } } } };</code> </pre><br><br>  As can be seen from it, if permission is obtained, then the function of opening the device is called: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">openDevice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UsbDevice device)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!res) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; UsbDeviceConnection devConn = m_usbManager.openDevice(device); Integer fd = devConn.getFileDescriptor(); deviceCache.put(device.getDeviceName(), fd); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } }</code> </pre><br>  Which saves the resulting file descriptor in deviceCache. <br><br>  After going through all these steps, we get the file handle of the open device.  But another problem appears: HIDAPI and libusb cannot take descriptors as a pointer to a device. <br><br>  Fortunately, this problem was solved simply.  There is a <a href="https://github.com/martinmarinov/rtl_tcp_andro-/tree/master/jni/libusb-andro">libusb fork</a> that takes an open device file descriptor as an argument. <br><br><h4>  Conclusion </h4><br>  So, quite simply, you can access the USB from the native code. <br><br>  Unfortunately, this approach does not work on all devices.  Many manufacturers do not include permission <br>  android.hardware.usb.host in its firmware, which leads to a situation where physically the tablet can work as a host for flash drives or mice, but other devices do not work.  In this case, the USB device file is created by the kernel, but even UsbManager does not see them. <br><br>  In this case, it is possible to bypass this restriction on devices with a working root, changing access rights to the file, since  libusb is able to see connected devices.  But for now this is only a theory. </div><p>Source: <a href="https://habr.com/ru/post/238241/">https://habr.com/ru/post/238241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../238225/index.html">Adobe is leaving Russia</a></li>
<li><a href="../238231/index.html">Jump start on October 7th. Modernizing the company's IT infrastructure using Windows Server 2012 R2</a></li>
<li><a href="../238233/index.html">Creating a multi-user touch-enabled interface for Windows</a></li>
<li><a href="../238235/index.html">Police drones are looking for undeclared mansions in Argentina</a></li>
<li><a href="../238237/index.html">Universal metasystem in C ++</a></li>
<li><a href="../238245/index.html">IB in American. Part 1. What is NIST 800-53 and what do security controls look like?</a></li>
<li><a href="../238247/index.html">How to buy gold?</a></li>
<li><a href="../238249/index.html">Cybercortex. Extended Perception and Thinking System</a></li>
<li><a href="../238253/index.html">DVR ParkCity DVR HD 450: tested on the roads</a></li>
<li><a href="../238255/index.html">7 reasons why conversion optimization is useful for business growth</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>