<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Automation of mobile applications based on Appium</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Author: Anton Sirota (QA, Automation) 

 In this article, based on a lecture that I recently read, we will look at the Appium framework. This is an in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Automation of mobile applications based on Appium</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/031/e16/4bc/031e164bc2a64cb09b31d39cadc1ecca.png"><br>  <i>Author: Anton Sirota (QA, Automation)</i> <br><br>  In this article, based on a lecture that I recently read, we will look at the Appium framework.  This is an introductory material designed to understand how mobile applications are being automated in principle, what is required for this, what to start with, and what difficulties you will have to face. <br><br>  Automation of mobile applications is a relatively new phenomenon, but its demand is constantly growing.  There are some difficulties with Appium, although in general the process of automation with its use has already been debugged. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Content </h2><br>  ÔÇß Environment for mobile automation <br>  ÔÇß Search and work with items <br>  ÔÇß Work with the driver <br>  ÔÇß Work with contexts <br>  ÔÇß Emulator or real device? <br>  ÔÇß Possible problems / difficulties <br>  ÔÇß Mobile automation process <br>  ÔÇß Cloud services <a name="habracut"></a><br><br><h1>  Types of mobile applications: </h1><br>  ÔÇß Native. <br>  ÔÇß Web. <br>  ÔÇß Hybrid. <br><br>  Before talking about automation, it is worth considering the types of mobile applications themselves. <br><br>  <b>Native applications.</b>  The main type of mobile applications are installed on the phone and work directly on the phone.  Native applications do not require a browser and the Internet, and if they do, they are not dependent on their presence. <br><br>  <b>Web applications.</b>  Now often there are adaptive designs that adapt the web application from the desktop version to the mobile one.  You need to test such applications in conditions as close as possible to the real environment ‚Äî on emulators or devices. <br><br>  <b>Hybrid applications.</b>  Native applications that have built-in the ability to open web pages when access to the web is implemented through the native application. <br><br><h1>  Environment for automation </h1><br><table><tbody><tr><th>  iOS Automation </th><th>  Android Automatoin </th></tr><tr><td>  Mac OS </td><td>  Mac OS / Windows / Linux </td></tr><tr><td>  Xcode </td><td>  Android SDK </td></tr><tr><td>  Node js </td><td>  Emulator setup </td></tr><tr><td>  Appium </td><td>  Appium </td></tr><tr><td>  Application </td><td>  Application </td></tr><tr><td></td><td>  Haxm driver (for SDK Emulator) </td></tr></tbody></table><br><br>  Before you begin the process of automation, it is important to understand what environment will need to be configured.  And, of course, the two main operating systems that will have to deal with - iOS and Android. <br><br>  What requires iOS to start?  Apple is a complete system, so if tomorrow you need to automate an iOS application, you will need a Mac operating system, as an option - everything can be deployed on Mac-mini.  Why?  Because we will need xCode with Mac OS. <br><br>  Appium will be the next tool.  There are two ways to launch Appium: UI or console.  To install and run the console version, we will additionally need NodeJs.  A UI-version can be downloaded from the official site, and it will immediately be ready to go. <br><br>  If we are talking about automating web applications, we will need to make sure that the emulator has a browser installed.  For Android, this will be Google Chrome, for iOS, Safari (which by default always already exists in the emulator). <br><br>  If we are testing the native application that the developers gave us, we need to make sure that it is on our machine, and indicate the way - how it can be accessed in Appium. <br><br>  For Android automation, the issue of choosing an operating system is not so critical - here everything can be configured under Windows, Linux and MacOS.  It should be noted that it is not always possible to deploy Android automation under a virtual machine due to the lack of a graphics adapter, without which we simply cannot run the Android emulator.  To start, we will need the Android SDK, i.e., the development kit for Android, which already has a built-in emulator. <br><br>  The next step is to set up an emulator.  There you can create and configure an emulator and emulate almost any Android device. <br><br>  We also need Appium and the .apk application itself, or Chrome.apk for Android.  It is important to know that the standard Android emulator doesn‚Äôt have a big problem: SDK - the emulator is very slow, you can tick the ‚ÄúUse host GPU‚Äù checkbox when creating the emulator, and the Haxm driver (mentioned in the list) must be installed.  Then the emulator starts to work with more or less decent speed.  Of course, there are more stable and faster tools like Genymotion - it is conditionally free, but if you want to use it in your project, you will have to purchase a paid license. <br><br><h1>  Search and work with items </h1><br>  <b>Tools:</b> <br>  ÔÇß Appium Inspector <br>  ÔÇß UI Automator Viewer (Android) <br>  ÔÇß UI Automation (iOS) <br><br>  <b>Locators:</b> <br>  ‚Ä¢ Xpath <br>  ‚Ä¢ Id <br>  ‚Ä¢ Class <br>  ‚Ä¢ Name <br>  ‚Ä¢ UI Automation id <br>  ‚Ä¢ Css (mobile web only) <br>  ‚Ä¢ Accessibility id (ios only) <br><br>  If you work with a mobile web application, you can simply open it in the browser, reduce it to the size of the device you need and find the necessary elements. <br><br>  If the application is native or hybrid, you need Appium Inspector - the built-in inspector in Appium works with both Android and iOS.  That is, if you are running the UI version of Appium, you can click Inspect, after which a tree of application elements will appear.  There are also separate programs: UI Automator Viewer for Android and UI Automation for iOS.  These are auxiliary tools that allow you to see the elements and find them, so that you can use them in the future for automation. <br><br>  What locators are there?  Even for native applications, we can use the same markup language as for web applications - Xpath.  IDs if items have any IDs.  You can also use Class or Name, there is also a UI Automation ID - it can be useful if you don‚Äôt see any element in the standard tree.  That is, when an element is on the device, is on the emulator, we see it, but it is not in the element tree and in xml - this also happens.  UI Automation allows you to record your actions, to generate after this code, parts of which can be used in automation.  You can use CSS, but you need to consider that CSS locators will only work when automating mobile web applications. <br><br><h1>  An example of finding locators in native applications </h1><br>  Opening UI Automation Viewer, on the left you will see a screenshot of the screen, on the right - a tree of elements that are in the application.  We can go through the tree and build the Xpath.  The locator will use two slashes and include elements that allow you to build a dependency. <br><br>  We have a tree and details for each element of the application.  That is, we take some element, and we can see from it a class, index, text, id, etc.  All this can be used when searching for an item.  When building a locator, we can find an element by class if the class is unique.  Also, we may have a resource_id, inside which there is id =, such elements can be located directly by id =.  Appium Inspector will be very similar to the UI Automation viewer, which comes in the Android SDK package (the tools folder, and in it the uiautomatorviewer.bat file that launches the UI Automation viewer and allows you to view the tree of elements).  With it, you can see the elements not only on the emulator - you can find the same elements from a real device if it is connected via a cable. <br><br>  In UI Automation Viewer, you can click on the device screenshot button, then it connects to the emulator using ADB and gets a screenshot and xml of the open application through it.  After receiving a screenshot and a tree of elements, we can check whether we have the necessary elements and check which attributes can be used to create a unique locator.  Thus, elements in native applications are found. <br><br><h1>  Work with the driver </h1><br>  WebDriver - RemoteWebDriver - AppiumDriver = IOSDriver / AndroidDriver <br><br>  Before working with the driver, you need to set up the environment, the emulator, install the application on the emulator, open it and make sure that the application elements are available in the element tree.  That is, check that you are ready for further automation. <br><br>  After that, you can build automation directly.  It is also worth mentioning the layers in automation, where the end point is your application, which is installed on the device, a lower level, the device, and the Appium interacts with it, which is installed separately.  Commands in Appium are transmitted from code, which in general will look almost the same as when automating web applications using Selenium.  That is, you use the same Page Object, you also work with elements, only this will not be WebElements, but MobileElements.  The code itself interacts with Appium through the driver. <br><br>  A web driver is an interface in which there is a framework of possible actions.  Next comes the RemoteWebDriver, which inherits WebDriver.  Next is AppiumDriver, which will be necessary when automating mobile native applications (when automating mobile web applications, you can use RemoteWebDriver).  And already from AppiumDriver, IOSDriver and AndroidDriver are inherited, in which certain actions are implemented in their own way for each operating system. <br><br>  If more: <br>  ÔÇß WebDriver - basic interface. <br>  ÔÇß RemoteWebDriver - often used for automation with the use of Selenium Grid (automation of web applications). <br>  ÔÇß AppiumDriver is a general abstract class for automating mobile applications. <br>  ÔÇß IOSDriver - used for iOS Automation. <br>  ÔÇß AndroidDriver - used for Android Automation. <br><br>  Using RemoteWebDriver when automating mobile web applications is not always convenient, because sometimes there is a need to refer to certain native parts.  In the same Facebook, if you automate the mobile web version of the application, after entering the login and password, you will be prompted to remember the password.  After apruv, a native pop-up pops up, which will block the site until you click ‚ÄúOk‚Äù.  To do this, you already need AppiumDriver (or iOSDriver / AndroidDriver), which can work with the native context, since RemoteWebDriver can only work with web contexts. <br><br>  AppiumDriver (General abstract class for Mobile) is an abstract class for mobile automation and for automation of Android / iOS.  Depending on the device, you can use IOSDriver or AndroidDriver, which is inherited from AppiumDriver. <br><br><h1>  Initialization example </h1><br><img src="https://habrastorage.org/files/1c3/eda/7a1/1c3eda7a14e345f28f81f4f214b25f2d.png"><br><br>  This example is taken from a real project.  Here we can specify the required capability.  After the automation environment is ready, you can implement everything in the code, which will further send the necessary requests to Appium.  To do this, you need to specify the URL at which it will go to Appium, and the necessary capability. <br><br>  The initialization example shows the settings for Mobile Chrome and Mobile Safari.  The capability is indicated by a browserName, where we indicate whether it will be Chrome or Safari.  Further, we can use different devices and platforms.  There are also autoAcceptAlerts to prevent native allergies from popping up, and newCommandTimeout, which is set to tell the driver how easy it is for him to end the session. <br><br><h1>  Work with contexts </h1><br>  Get all contexts: <br>  getDriver (). getContextHandles (); <br>  Switch context: <br>  getDriver (). context (" <b>WEBVIEW</b> "); <br>  getDriver (). context (" <b>NATIVE_APP</b> "); <br>  getDriver (). context (" <b>CONTEXT_NAME</b> "); <br><br>  This is mostly true for hybrid apps.  When automating native applications, either Appium Inspector or UI Automator Viewer will help us.  As for hybrid applications, when a native application opens, after certain steps, you can open a web page in the same application, or a part of it will be displayed. <br><br><img src="https://habrastorage.org/files/f2f/fa1/d9b/f2ffa1d9bfbe42f79a6c467229ce6891.png"><br><br>  In this example, Appium Inspector is open.  This is what it looks like when an iOS application is open.  The element tree opens here sequentially.  You select any element and, if there are more elements inside, the next tree of internal elements will be displayed.  Here you can see contexts, that is, you can choose NATIVE_VIEW ‚Äî native context, or WEB_VIEW ‚Äî web context. <br><br>  It also happens that you have a native header in the application, and below is the embedded web page.  In such cases, you have several contexts, and you can switch between them to find the right items. <br><br>  How it works?  If you talk about how this is implemented in the code, you have a driver in which you can get all contexts by calling the getContextHandles () method. <br><br>  Also, you have an Appium-inspector to confirm that all contexts are available;  It is possible to deduce from the code all contexts that exist at the moment, after which you can switch to these contexts. <br><br>  That is, the main thing you need is the getContextHandles () method, which takes all the contexts that are on the current open page of the application. <br><br>  If you need to switch between contexts, open the native application in the test, go through it to the web part, after which you need to switch from the native context to the web.  To do this, call the context () method, which is in AppimDriver, and specify in it the context to which you want to switch - for example, WEB_VIEW or NATIVE_VIEW. <br><br><h1>  Devices or emulators </h1><br><table><tbody><tr><th></th><th>  <b>Real device</b> </th><th>  <b>Emulator</b> </th></tr><tr><td>  Easy setup </td><td>  Android: Quick install <br>  iOS: You have to dig </td><td>  Android: There are pitfalls when setting up <br>  iOS: requires xcode and minimum settings </td></tr><tr><td>  Run speed </td><td>  Quickly </td><td>  Android: speed depends on the emulator <br>  iOS: low startup speed, fast run </td></tr><tr><td>  Stability </td><td>  Relatively stable </td><td>  Android: There are certain instabilities <br>  iOS: The problem can be solved with additional bash scripts </td></tr><tr><td>  Behavior </td><td>  May differ depending on OS version. </td><td>  May differ depending on OS version. </td></tr><tr><td>  Item availability </td><td>  In WebView, elements can be defined as Native. </td><td>  WebView elements are available as web elements. </td></tr></tbody></table><br>  We worked with real devices and emulators.  In each case, there were pros and cons. <br><br>  The real Android device as a whole manages to be set up pretty quickly.  You need to make sure that developer mode is enabled on the device.  And after connecting the device, you need to confirm the connection on the phone itself by clicking on the ‚ÄúOk‚Äù window that popped up, and that‚Äôs it - with minimal effort you are ready to automate Android mobile applications. <br><br>  If we are dealing with iOS, we will have to rummage - there are difficulties in connecting a real device.  A bundle with Appium is possible, but you need to spend time to set it up. <br><br>  If we talk about the Android-emulator, the main pitfall is the problem of speed.  The standard emulator is very slow, but installing the haxm driver and choosing Use Host GPU when setting up the emulator speeds it up. <br><br>  If it is web automation, it is important to install the correct version of the browser.  For example, if you have an x86 platform, you need to install Google Chrome x86 versions too. <br><br>  If we consider the iOS-emulator, in general, everything is not so difficult - you will need the minimum settings.  You need to run Appium so that the emulator of the required version is on Xcode.  For example, to run the test on the iPhone 6, under iOS 9.3, you just need to make sure that this version is present in Xcode. <br><br>  In general, real devices work faster than emulators.  In the case of emulators, for Android, the speed depends on the emulator itself.  As an alternative to Android, there is a Genymotion emulator, which installs pretty quickly and runs faster and more stable than the standard one.  Using Genymotion, you can drive tests in several threads on one machine, which allows you to significantly increase the speed of passing tests. <br><br>  If we talk about the IOS-emulator, we get a high run speed, but a low test launch speed.  Because if we run a test in a new session (and more often we need it to work on a clean application), it will reopen the emulator each time, which takes time.  In this case, the tests themselves run pretty quickly. <br><br>  In Android emulators, certain instabilities can be observed.  If we talk about real devices, everything is relatively stable.  But in general, problems with unstable runs under a standard emulator can be partially solved with additional batch scripts - they will kill all unnecessary processes (which could remain from the previous run) before starting the tests and start a clean session of Appium and the emulator before running the test group. <br><br>  There are cases when the behavior of the application may differ depending on the version of the operating system, some pop-up windows may not appear at all or vice versa pop up constantly.  These are trifles, but this happens - such moments also have to be processed somehow. <br><br><h1>  Item availability </h1><br>  So far, we have noticed this only in one project: in the native application a web page opens, and the elements on this page are defined differently on the emulator and the real device.  It happens that the elements on a real device are defined as native, and in the emulator everything works as a WebView, i.e., as a regular web site where we can find elements even on the CSS locator. <br><br>  As I already noted, we noticed a similar difference in one project: we could find an element using the CSS locator that would work fine on the emulator, but when we run the same test on real devices, it basically doesn‚Äôt find anything, context, and sees everything as a native context. <br><br><h2>  Possible problems </h2><br>  ÔÇß Some items may not be available. <br>  ÔÇß Not all standard methods work correctly (ex. Scroll / swipe). <br>  ÔÇß Need to keep track of updates. <br>  ÔÇß You need to monitor compliance with the versions (OS, Appium, Emulator). <br>  ÔÇß It is important to properly configure the emulator. <br><br>  In the case of the automation of mobile applications is still not as perfectly debugged as in web automation, but in general, all the problems that we have considered are solved.  You just have to spend some time on this. <br><br>  As I mentioned earlier, some items may not be available.  We had a case when the validation on the page was visually visible, but it was not in the element tree.  You can call getPageSource (), as with web automation, and the xml of the currently open page will be returned to us, i.e., everything that is visible on the page at the moment.  But more often, if the item is not available in the inspector, xml will not open anything new either.  In this case, there are two possible solutions: either leave this case for manual testing, or talk to developers, ask them to add ID or other additional attributes. <br><br>  Not all standard methods work correctly.  And here you need to understand that Appium is a relatively new framework, if we compare it, say, with Selenium.  This is noticeable when it comes to such actions as scroll / swipe, when we need to scroll left / right or up / down in the native application.  In AppiumDriver, there is a scrollToText () method that can scroll the page to specific text, but, unfortunately, for the time being it does not always work for iOS.  Be prepared that you have to write your custom scroll - there are certain solutions on the Internet that can be used. <br><br>  AppiumDriver also has a swipe method, but it has a lot of parameters.  Therefore, to use it in tests, most often you will need to write your own wrapper, which will move the screen by a certain number of percent or pixels left and right.  That is, in general, the question is solved, but the problem will have to be faced. <br><br>  You need to keep track of updates and compliance with the version - one of the things that previously did not work in Appium, it works successfully in new versions.  That is, we will have to update Appium as Application, just like the API in the code.  In both cases, we must try to maintain the latest version, because it is regularly improved and improved.  At the same time, if you have the latest version of Appium and some old xCode with an old emulator, the application will probably not work. <br><br><h1>  Mobile Automation Workflow </h1><br><img src="https://habrastorage.org/files/d59/359/8b8/d593598b8c524460934f58b51cf41afe.png"><br><br>  Actually, this is how everything should work ideally.  A native application is a file that we need to take from somewhere, and then use it when running tests.  So that the automation process is implemented correctly, you need an assembly that will assemble the mobile application.  For example, the automatic assembly of the Android application that will create the .apk file.  Next, the Jenkins task can be automatically launched by the trigger, which will transfer the location of the assembled .apk application and run the necessary tests on it.  You can configure the application build and run tests on it every night, so we will always have up-to-date tests, and we will be able to see and analyze test run results every morning and detect bugs as quickly as possible. <br><br><h1>  Cloud Services </h1><br><img src="https://habrastorage.org/files/1ba/f08/03f/1baf0803f9e44ebeb35d8952f55926ca.jpg"><br><br>  To automate iOS tests, we needed Mac-mini.  But what if we need to provide multi-threading?  Suppose there are 300 tests, and they all go in a single stream for 12 hours, and we need to get the results in just an hour.  Work becomes much more difficult: for each thread you need a separate mac-machine.  In this case, you need to constantly monitor the updates of versions of Appium, Xcode and OS. <br><br>  In cloud services you pay a relatively small amount for the possibility of its unlimited use and you can select the desired number of streams.  With the right approach, you can convince the customer that, at the expense of the obtained opportunities and saving time, to support local testing environments, he will save rather than spend too much. <br><br>  Take a BrowserStack.  This vendor allocates virtual machines, and we simply indicate in the code RemoteUrl, on which the tests will be run.  And, if we specified a run in three streams, it will automatically be distributed to three cars on the side of the browserstack.  In addition, they update all applications on time and closely monitor compatibility.  It means that it will be much easier to work.  The most significant advantage of cloud services is that you do not spend a lot of time setting up and supporting environments for automated testing. <br><br><h2>  Benefits of Cloud Services </h2>  : <br>  ‚Ä¢ Do not waste time setting environment. <br>  ‚Ä¢ Do not waste time supporting the environment. <br>  ‚Ä¢ Stable work. <br>  ‚Ä¢ Higher test passing speed (most often). <br>  ‚Ä¢ Simple multithreading implementation. <br><br>  Cloud services also provide a video of what is happening - this applies to mobile and web applications.  And if you need to test under a certain system, for example, Windows XP or Internet Explorer 8, you can easily set the parameters when running the test, and the cloud service will automatically start the test under the desired environment.  By the way, for manual testing the same browserstack provides the possibility of free use. <br><br>  Now you can not waste time on setting up the environment and its support: just tell the test how it should run, and we always know that all the latest updates are already installed there. <br><br>  Stable work of cloud services means that you will not need to write additional scripts that control the stability of the run and the start of scripts in a clean session.  Tests in cloud services usually run faster, although if you have an absolutely top-end and very expensive Mac machine, you can win in speed.  But if you have Mac-mini the year before last, even with good parameters the same before the last year, the test will not be as fast as most cloud services. <br><br>  Moreover, the cloud service allows us to run one task in several streams and, accordingly, your 9-hour tests can be run in an hour or two. </div><p>Source: <a href="https://habr.com/ru/post/308180/">https://habr.com/ru/post/308180/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308166/index.html">Do not use Illuminate Support</a></li>
<li><a href="../308168/index.html">Overview of Mathematica 11 and Wolfram Language Features</a></li>
<li><a href="../308170/index.html">BMW Music Light</a></li>
<li><a href="../308174/index.html">‚ÄúGreen‚Äù data centers: what do the giants of the industry use to reduce the energy consumption of their DCs?</a></li>
<li><a href="../308178/index.html">The digest of interesting materials for the mobile # 167 developer (August 15-21)</a></li>
<li><a href="../308182/index.html">Docker Swarm + Consul + Gobetween as an engine for a geo-distributed cluster</a></li>
<li><a href="../308184/index.html">Translation of excerpts from Robert Heinlein‚Äôs book, Take Your Government Back - part 15</a></li>
<li><a href="../308186/index.html">"Front End Developer" or who I am by profession</a></li>
<li><a href="../308188/index.html">DIY DI in Ruby</a></li>
<li><a href="../308190/index.html">The digest of fresh materials from the world of the frontend for the last week No. 224 (August 15 - 21, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>