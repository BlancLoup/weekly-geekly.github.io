<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We implement touch logger for Android using CVE-2016‚Äì5195</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The story of how a linux kernel vulnerability helps me collect data for a dissertation 
 A couple of years ago I decided to find out whether a person ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We implement touch logger for Android using CVE-2016‚Äì5195</h1><div class="post__text post__text-html js-mediator-article"><h4><blockquote>  The story of how a linux kernel vulnerability helps me collect data for a dissertation </blockquote></h4><br>  A couple of years ago I decided to find out whether a person can be identified by the gestures that he enters on the screen of a smartphone.  A kind of "keyboard style", but only for the touch screen.  To understand this, you need to analyze hundreds of thousands of gestures from many different users.  But ... How to collect this data on a smartphone? <br><br>  I will talk about my way to solving this problem.  He was long, thorny, but damn fascinating!  I hope you will be interested to follow him and learn for yourself something new about linux, android, their security and their insides.  I am not a guru in a linux device, so some explanations will seem to someone obvious and unnecessarily detailed, but again, this is my way and I describe in detail everything that I learned in the process.  I hope this does not alienate experienced linuxoids and slightly lower the entry threshold for everyone else.  So.  How to implement touch logger for android? <br><a name="habracut"></a><br><h3>  Choosing a path </h3><br>  The simplest and most obvious solution is to write a separate application and collect the parameters of gestures only in it, as was done in <a href="https://link.springer.com/chapter/10.1007/978-3-642-31668-5_10">[1]</a> .  But this is a completely uninteresting task.  And not only because it is too simple.  By limiting data collection to a single application, there is a risk of missing some important behavioral characteristics of user gestures, which appear only under <i>special</i> conditions.  Therefore, I would like to collect gestures regardless of the application in which the user works, although it is not so easy to do it. <br><br>  Mobile operating systems are much better than desktop ones.  They, unlike the latter, were already being developed in those times when serious thought was taken of the security and isolation of processes, and the same Android simply does not allow you to track user gestures outside the view of your application.  I suspect that in other mobile OS the same situation.  But is it really so well protected that you had to resort to using linux kernel vulnerabilities to get touch coordinates? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Many now, for example, remembered about the android accessibility service - a universal access service.  A handy thing for helping people with disabilities or writing various kinds of Trojans for Android.  You can subscribe to universal access events in your application and receive information about user gestures.  It would seem that!  Take it and use it, everything is already written for you.  But alas, I don‚Äôt extract the parameters of gestures I need from this data. <br><br>  Well, there are not so many options.  Try, for example, to include the item "display touches" in the developer menu. <br><br><img src="https://habrastorage.org/web/3a9/342/ba6/3a9342ba6e464f2692e9a2a437232479.png"><br><br>  After that, the traces of your gestures will remain on the screen, no matter what application you are.  So, this code at least has access to information about touch coordinates.  I wonder where he took this data and is it still there?  In search of an answer, we dive into the android source and discover <a href="">this</a> : <br><br><img src="https://habrastorage.org/web/7b0/d89/8a6/7b0d898a610045cea731ccd4f80dcb26.png"><br>  The <code>mPointerLocationView</code> line allows the <code>mPointerLocationView</code> object <code>mPointerLocationView</code> handle all input events from the touch screen. <br><br>  If you examine the class hierarchy and call graph, it becomes clear that in the end it all comes down to calling the <code>registerPointerEventListener</code> method on the <code>WindowManagerService</code> system service.  The latter, through the <code>WindowManager</code> interface, allows ordinary applications to call their methods remotely.  It seems that it is enough to get access to <code>WindowManager</code> in the application, call this method, and the application will be able to handle the coordinates coming from the system.  But there is a catch: in Android, access to system services is provided through <a href="http://elinux.org/Android_Binder">Binder IPC</a> , and WindowManager can call only those methods that are in the corresponding <a href="">AIDL file</a> .  Unfortunately, there is no our method in AIDL, and it will not be possible to call it remotely from the user application.  But if you are a vendor, and you don‚Äôt know how else to monitor users, you can change the android sources and add gesture logging directly to the device‚Äôs firmware, which I did for the sake of interest <a href="https://github.com/BOOtak/platform_frameworks_base/tree/thesis">here</a> .  However, in our case, this solution is not suitable.  You can flash one, two data collection devices, but dozens of unfamiliar test users will not take this step.  A more versatile way is needed. <br><br>  Well, here it is, a solution to which I tried with all my might to find an alternative, but I could not.  So, Android is based on the linux kernel, and the input system architecture is the same as in any linux distribution.  Input device drivers, including touchscreens, transmit data to the userspace via character devices located in <code>/dev/input/</code> , from where they can be read.  And directly from the driver, you can get all the data that you can wish for: coordinates, time stamps, touch area, gesture type ... Enough for more than one study.  True, here, too, there is a catch: in Android, access to these devices has either root, or a user who is in the input group.  Android applications are launched on behalf of users who cannot brag of such rights. <br><br>  The way out of this situation is to launch an application to collect data on rooted devices.  It is for this purpose that I wrote the <a href="https://github.com/BOOtak/touchlogger-client">second version of</a> my touch logger. <br><br>  I used this version for data collection.  There were plenty of people willing to help, but only some devices were ruled, so I didn‚Äôt collect so much.  If you find a way to collect data without a root installed, there will be a few more suitable test devices, which will give us hundreds and hundreds of megabytes of valuable data for analysis.  One great vulnerability in the linux kernel will help us in this. <br><br><h3>  CVE-2016‚Äì5195 aka DirtyCOW </h3><br><img src="https://habrastorage.org/web/45d/b28/44a/45db2844a5a647b4baf3752c55f1cfdc.png"><br>  <i>Himself</i> <br><br>  The history of finding and fixing this vulnerability is in itself very entertaining.  She was accidentally noticed <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/%3Fid%3D19be0eaffa3ac7d8eb6784ad9bdbc7d67ed8e619">11 years ago</a> , but never closed.  Once again, it was discovered and corrected only in 2016, after the discovery of a ready exploit that used it.  That's how the vulnerability with an 11-year history turned into a 0-day.  Remarkably, it is present on all versions of the kernel, starting from 2.6.22!  That is, on all versions of android.  In the android security bulletins, this vulnerability <a href="https://source.android.com/security/bulletin/2016-12-01%3Fhl%3Dru">appeared</a> in December 2016, which means that it was fixed only on those devices that received security updates after this date.  Nexus 5, for example, remained susceptible to it, like hundreds of other android devices. <br><br>  What does dirtyCOW do?  In short, it allows you to overwrite any file that the user can only read.  By ‚Äúany,‚Äù I mean ANY, even if the file system itself is mounted only for reading (in android, this is exactly the way of the / system partition, where the most delicious system files are stored).  You can read about the mechanism of the vulnerability, for example, <a href="https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails">here</a> .  We should remember only two things.  First: changes to the read-only file system will disappear after a reboot, and second: you cannot change the file size, that is, write to it more than it takes up disk space. <br><br>  Well, with the power given to us by the vulnerability, we can temporarily overwrite any system file that is readable.  It would seem that this gives us a free hand, you can do whatever you want!  But again, android is well protected, and will have to try to get around this protection and achieve their goals. <br><br><h3>  Idea implementation </h3><br>  Our task is to start a process from a normal application that can read data from input devices.  Let me remind you that only the process started from the user with UID = 0 (root) or in the input group has access to the input device (in android it has GID = 1004). <br><br>  Consider, for example, the file <code>/system/bin/ping</code> .  It can be found in almost all android-devices, and it is available for reading and execution for everyone.  Remarkably, this file has a SUID bit.  SUID ( <b>S</b> et owner <b>U</b> ser <b>ID</b> up on execution - set owner UID during execution) is one of the attributes of a file in Linux.  Usually the process inherits the rights of the user who started it.  The presence of the SUID bit allows you to start the process with the rights of the owner of the executable file, as well as with its UID and GID.  Accordingly, since the owner of the ping is root, then this file will be executed as root.  Do you understand what I'm getting at?  If we rewrite ping with dirtyCOW and run it, our code will execute as root and be able to read input devices!  Well, gentlemen, congratulations, we did it, all the great lads, we disagree ... No. <br><br><h3>  SELinux </h3><br>  Yes, our plan will work amazingly on all versions of android up to 4.2.  But on more recent versions may arise, but starting from 5.0 some difficulties will arise.  The whole blame for SELinux (Security-Enhanced Linux) is a kernel module that implements a mandatory security policy in addition to an existing discretionary one.  Briefly on how it works.  Each user, process, file, network port, character device, and so on has a so-called security context ‚Äî some label, an additional attribute.  There is a set of policies in the system that describes the operations allowed for users and processes based on their contexts.  All operations that are not in the policy set are prohibited and strictly suppressed by the system. <br><br>  Third-party applications run in processes with a untrusted_app context.  Already from the name of the context it follows that the rights of such processes are few.  The <code>/system/bin/ping</code> file has a system_file context, and yes, SELinux does not allow running system_file from the untrusted_app context.  Therefore, we will not be able to start pinging from an application on android 5.0+, like other system files with a SUID bit. <br><blockquote>  In fact, contexts in SELinux consist of several parts, for example, in ping, the context has the full form <b><code>u:object_r:system_file:s0</code></b> , and the user has <b><code>u:r:untrusted_app:s0</code></b> .  In our case it doesn't matter, so I will use a shorter recording. </blockquote><br><h3>  other methods </h3><br>  So, in the system there are no files with SUID-bits available to run from third-party applications.  But what if you overwrite a file and make it so that the system launches it as root?  In android there is such a thing as a service.  Not the one that runs from your application and does something in the background.  Service is a daemon that starts at system startup. <br><br><img src="https://habrastorage.org/web/15b/a5b/0c0/15ba5b0c0a8f48ecaef4cd8750e458e3.png"><br>  <i>Examples of services described in the file <a href="">init.rc</a></i> <br><br>  Remarkably, android restarts services if they crash.  What is even more interesting, many services are running as root.  In android 6.0.1, this is vold, healthd, debuggerd, installd, zygote and many others.  And yes, the file <code>/system/bin/app_process</code> , aka zygote, is readable by all users! <br><br><img src="https://habrastorage.org/web/a99/2b7/584/a992b7584fd94d3da00667265b51786b.png"><br>  <i>The zygote service, described in a separate file</i> <br><br>  Little by little, the outlines of the new plan.  If you overwrite <code>/system/bin/app_process</code> on our payload and drop the zygote service, android restarts it and our code in the app_process file runs as root. <br><br>  The question arises how to drop a zygote.  In fact, this is the most unreliable moment in the implementation of the touch-logger.  Now I rely on the fact that when overwriting <code>/system/bin/app_process</code> our payload, zygote will fall ‚Äúby itself‚Äù.  But there is no guarantee that this will always work.  Let's see what happens when the app_process file is overwritten and why this may or may not lead to a crash. <br><br><h3>  Virtual memory and mmap </h3><br>  In Linux, each process has its own virtual address space.  It stores all the data needed by the process: its stack, heap, environment variables and much, much more.  This space is translated by the kernel into physical addresses in RAM. <br><br><img src="https://habrastorage.org/web/422/335/dea/422335deace04482a92c1618eac42c5c.png"><br>  <i>Good visualization of this concept.</i> <br><br>  However, in the same space is the executable file of the process itself, and its interpreter, and libraries from its dependencies, and many more different files.  It would be too wasteful to store all this in RAM, so linux has a rather elegant mechanism for loading files into the process memory without using RAM at all.  It is called a memory-mapped file, or a file reflected in memory.  The kernel creates in the address space of the process a page with the contents of the file, but in fact this virtual page is translated by the kernel not into RAM, but directly onto the disk.  That is, the process works with the contents of the file as if with a large chunk of allocated memory, although in reality it reads or writes bytes on the disk.  (by the way, if you haven‚Äôt read about dirtyCOW‚Äôs work principle yet, it‚Äôs just based on bugs with multi-thread access to the memory-mapped file). <br><br>  It is in this ‚Äúreflected‚Äù form that its executable file is stored in the process memory.  Partially, it is loaded into memory, but most of it remains on the disk.  Therefore, changes to the file immediately appear in the memory of the process.  Suppose that after replacing the executable file, the process loads the following instruction from memory.  With a high probability, it may be ‚Äúinappropriate‚Äù and lead the process to a fall, or it may even turn out to be rubbish, with the same ending.  However, it may happen that the process during the replacement of the executable file will ‚Äúhang‚Äù in the blocking call, executing some select (), read () or waitpid ().  In this case, nothing will happen to him until the end of the call and he will continue to exist.  There are probably other scenarios for the survival of the process after replacing the executable file, but I am not familiar with them due to some experience in linux. <br><br>  We found out what happens when a file is overwritten and how it can cause (or not) a drop in the process.  I never came up with a more reliable way to restart, so let's leave everything as it is.  Moreover, this method still works quite well (the exception is samsung devices that have their own, Samsung's magic does not allow zygote to fall after rewriting its executable file. I did not find out how it works). <br><br>  Let's go back to the zygote.  What kind of insignificant service is this, that I can easily replace it with some other binary file?  Zygote is a process that spawns all android applications.  When you click on the icon of the same clash of clans, zygote creates a copy of its process using fork (), and in that copy launches the desired application.  This is done to save resources and speed up the launch.  If you kill zygote, all android applications will fall after it.  This state of affairs deprives our touch logger of any meaning.  Why collect custom gestures from bricks?  Fortunately, this problem is easy to get around. <br><br><h3>  Demons </h3><br>  First of all, why all of a sudden all android applications should terminate if zygote crashes?  After all, at the completion of the parent process in linux, the child continues to work fine, and its new parent becomes init.  But the fact is that when starting up, zygote spawns a new group of processes, or a new session.  In this session, all android applications are launched, all child processes of android applications, their child processes, and so on.  When the process that generated the session is completed, the entire branching tree of its descendants in the same session is completed with it.  So when you close the terminal emulator, all processes running in it will end.  That is why a zygote in case of a fall will necessarily drag all android applications to hell. <br><br>  As mentioned above, this causes some problems.  The first.  Who will return the app_process to the site after the payload has been launched, and our application will be killed?  And the second.  How to leave our payload running after returning app_process? <br><br>  In order for the process to continue to work after the session is completed, it must be untied from the current session ... Having created a new one!  This is done using the setsid () system call.  But you can do more cunning.  In one call, you can start a new process, untie it from the current session and untie it from the standard input / output streams.  This magic call is called daemon () and it combines the power of fork () and setsid (), creating a new demon process that will work even if the parent disappears in hell along with his entire session, for the demon itself is a creature of hell. <br><br>  With the help of daemon () both problems mentioned above are perfectly solved.  First we create a daemon inside the application.  It will survive the zygote crash, so it can rewrite the app_process to payload, wait for it to start, and then return the app_process back. <br><br><img src="https://habrastorage.org/web/e05/20d/435/e0520d435a2444cba83f47c8e1e0c431.png"><br>  <i>The solution to the first problem in pictures</i> <br><br>  The second is solved in a similar way: when the system launches our payload, we will create another daemon in it, which will work even after the app_process recovery.  But will it?  The fall of the process when overwriting its executable file has not been canceled, even demonization does not help.  From this save perhaps that replacing the executable file on the fly.  So why not do this? <br><br><h3>  Execve () </h3><br><img src="https://habrastorage.org/web/2fb/7d7/6c9/2fb7d76c985044669a3295de04b29502.jpeg"><br>  <i>Essence execve ()</i> <br><br>  This system call replaces the current process with a new one by running the binary file specified in the arguments.  You can read more about this in the corresponding <a href="https://www.opennet.ru/man.shtml%3Ftopic%3Dexecve%26category%3D2%26russian%3D2">man</a> . <br><blockquote>  By the way, almost all linux processes are started with fork () + execve (). </blockquote><br>  As a result, the system launches our payload.  We inside it do daemon () and execve () to run another binary, let's call it exec_payload.  Then we return the app_process to the site, but exec_payload continues to work. <br><br><img src="https://habrastorage.org/web/c12/154/238/c12154238acc4b4aa4c80601ffb7b3f7.png"><br>  <i>The solution to the second problem in pictures</i> <br><br>  Now we know how to start the process as root from a normal application.  More precisely, how, after killing half of the system, make it execute our code as root and return everything ‚Äúas it was‚Äù.  However, the difficulties do not end there.  Remember about SELinux?  So, he has not gone away and still does not allow the execution of many operations. <br><br><h3>  SELinux [2] </h3><br>  Consider what situation our exec_payload will be in after starting from the point of view of SELinux contexts.  In zygote, the context of the same name is zygote.  Exec_payload inherits when launched.  Character devices in <code>/dev/input</code> also have their context: input_device.  And, as expected, SELinux does not allow processes with a zygote context to access files with an input_device context.  Have we really come all this way just to rest on SELinux again? <br><br>  Not really.  This time, the situation is still a little better, and we have more rights.  Remember that zygote runs all android applications?  So, if a process with a zygote context has a descendant with a untrusted_app context (or platform_app for embedded applications, or isolated_app ... who would know for what), this means that zygote has the right to change the selinux context.  It remains to find the necessary context that has access to input devices.  And it is easy to find it: it is a shell. <br><br>  Shell is a user (with the same context), on whose behalf all commands are executed, if you access the Android device remotely via <a href="https://developer.android.com/studio/command-line/adb.html">ADB</a> (Android debug bridge).  It has less rights than root with an init or kernel context, but significantly more than android applications.  In particular, the shell user has access to input devices for reading and writing.  By changing the context from the zygote to the shell and adding ourselves to the input group, our exec_payload can finally get access to the desired input devices. <br><br><div class="spoiler">  <b class="spoiler_title">Getting the shell context from zygote</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> __aarch64__ void * selinux = dlopen(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/system/lib64/libselinux.so"</span></span></span><span class="hljs-meta">, RTLD_LAZY); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> void* selinux = dlopen(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/system/lib/libselinux.so"</span></span></span><span class="hljs-meta">, RTLD_LAZY); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (selinux) { void* getcon = dlsym(selinux, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"getcon"</span></span></span><span class="hljs-meta">); const char* </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = dlerror(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">) { getcon_t* getcon_p = (getcon_t*) getcon; char* secontext; int ret = (*getcon_p)(&amp;secontext); void* setcon = dlsym(selinux, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"setcon"</span></span></span><span class="hljs-meta">); const char* </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = dlerror(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">) { setcon_t* setcon_p = (setcon_t*) setcon; </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> ((*setcon_p)(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"u:r:shell:s0"</span></span></span><span class="hljs-meta">) != 0) { LOGV(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Unable to set context: %s!"</span></span></span><span class="hljs-meta">, strerror(errno)); } (*getcon_p)(&amp;secontext); LOGV(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Current context: %s"</span></span></span><span class="hljs-meta">, secontext); } } dlclose(selinux); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { LOGV(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SELinux not found."</span></span></span><span class="hljs-meta">); }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, it remains to solve the last problem. </font><font style="vertical-align: inherit;">How to exchange data between our (newly launched after the fall of half of the system) application and the daemon, reading the data from </font></font><code>/dev/input/event[X]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Perhaps several options. </font><font style="vertical-align: inherit;">Unfortunately, the most adequate of them (UNIX socket, FIFO) are not available to us (insidious SELinux!). </font><font style="vertical-align: inherit;">It remains to write data to the SD card by one process and read them from there by another process. </font><font style="vertical-align: inherit;">Not the coolest option, but still. </font><font style="vertical-align: inherit;">In addition, you can send data to the application via special intent using the built-in am utility (in fact, this is the command interface for the Activity Manager). </font><font style="vertical-align: inherit;">Perhaps there are other ways that I did not think of.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Manual" way to collect data </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using exploits to achieve different goals is very unreliable. It is rarely possible to implement a universal solution based on an exploit that will work on all devices with any versions of Android. My implementation of the touch logger is no exception. Not everywhere will zygote fall after rewriting app_process. Probably, not all SELinux devices will allow changing the context from zygote to the shell to our payload. And surely there are other pitfalls, while unknown to me. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, our goal is to collect input events, and if test users agree to provide their devices for this, you can implement another solution, simple and 100% universal. True, to launch it will have to do several manual operations. If to throw exec_payload on adb in a directory</font></font><code>/data/local/tmp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(where the shell has access), and from there start it - the daemon will start working in the same way as if it was launched by our application. </font><font style="vertical-align: inherit;">The only thing will be different UID (2000 instead of 0), but it will not affect access to input devices. </font><font style="vertical-align: inherit;">So in the third version of my touch-logger (which is now being brought to mind) I am going to provide such an option as a last resort, while leaving the possibility of launching on rooted devices as another backup option.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Other DirtyCOW Applications on Android </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is clear that exploits are not always (almost never) used for such noble purposes as science. And you are probably wondering what else the use of DirtyCOW can be found using the above method of elevating privileges. As you understand, this is not a full-fledged root, so our capabilities are very limited. However, it is possible to mess things up with these rights. First, you can use access to input devices to steal passwords (I made a ‚Äúpause‚Äù button in the touch logger to prevent this data from falling into my hands and potentially into the wrong hands). Second: you can use built-in utilities like am and pm. This allows you to secretly install and uninstall applications. Am, in turn, allows you to get information about the activity that is currently running on top of the rest. Perfect functionality for a banking trojan,which, when launching a banking application, will draw over its own login form. In general, dirtyCOW, like any tool, can be used for different purposes, both in good and not so much.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> One last trick </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, I want to talk about the most interesting: one more way to execute your code from a more privileged user. </font><font style="vertical-align: inherit;">It will allow you to run code with the privileges of mediaserver, netd, debuggerd, or other services, if you suddenly need it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, it is not necessary to rewrite the executable file, so that when it starts it executes arbitrary code. </font><font style="vertical-align: inherit;">This is very good news if we do not have permissions to read this file, or its size is so small that it is not possible to overwrite it with something more or less useful.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of the trick is very simple and elegant. Virtually any executable file in Android has a dependency on the system library libcutils.so. And when you run the executable file, this library will be loaded into the process memory. The feature of shared libraries in ELF format is that they have special sections </font></font><code>.init</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>.init_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Functions whose addresses will be placed in these sections will be executed when the library is loaded into the process. Accordingly, if we compile the library with the function in the section </font></font><code>.init_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and overwrite the file </font></font><code>/system/lib/libcutils.so</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with it, then when it is loaded into the process, this function will be safely executed with the privileges of the process.</font></font><br><br><pre> <code class="cpp hljs">__attribute__((constructor)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">say_hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ payload_main(); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function with the constructor attribute is placed in the </font></font><code>.init_array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">library </font><font style="vertical-align: inherit;">section when compiled </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But how universal is this solution? </font><font style="vertical-align: inherit;">I would not want processes in different versions of Android to have difficulty with the fact that they will not be able to find certain functions in this vital library. </font><font style="vertical-align: inherit;">Indeed, rewriting libcutils itself is quite dangerous. </font><font style="vertical-align: inherit;">But he, in turn, also has dependencies on other libraries. </font><font style="vertical-align: inherit;">True, other libraries are quite important, and I would not like to touch them. </font><font style="vertical-align: inherit;">Here comes to the aid of another, a little less simple, but no less elegant hack.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DT_SONAME ‚Üí DT_NEEDED </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each library in the ELF format has a header that contains all the library information that the linker needs. We are interested in information about its dependencies and its name. You can learn all this, for example, with the help of the command </font></font><code>objdump -p</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <b><code class="bash hljs"> : [.....] STRTAB 0x00001660 STRSZ 0x000014ec GNU_HASH 0x00002b4c NEEDED liblog.so NEEDED libc++.so NEEDED libdl.so NEEDED libc.so NEEDED libm.so SONAME libcutils.so FINI_ARRAY 0x0000fbf0 [.....]</code></b> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the fragment of the title libcutils.so. The NEEDED fields contain dependencies that will be loaded by the linker in the same process as libcutils itself. Notice the SONAME field containing the library name. It is noteworthy that it does not need the linker to work properly, it searches for libraries by the names of their files. So why not parse the ELF header and insert another dependency instead of this unnecessary field? From some less important system library? Here you need to be careful: the length of the name of the new dependency should not exceed the length of the name of the library itself (so I chose libcutils, and not, for example, libc). Fortunately, there is an excellent candidate in mind: libmtp.so. It is large (several tens of kilobytes), with a short name, and is needed only when connected to a computer via USB to transfer files using the MTP protocol.That is, 2 minutes you can live without it. The rest is a matter of technique. Parse the ELF file, find the field with the library name, change the field type from DT_SONAME (0xE) to DT_NEEDED (0x1), and change the name itself to libmtp.so.</font></font> Done!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Libcutils.so has a new dependency: </font></font><br><br><pre> <b><code class="bash hljs"> : [.....] STRTAB 0x00001660 STRSZ 0x000014ec GNU_HASH 0x00002b4c NEEDED liblog.so NEEDED libc++.so NEEDED libdl.so NEEDED libc.so NEEDED libm.so NEEDED libmtp.so FINI_ARRAY 0x0000fbf0 [.....]</code></b> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it‚Äôs easy to do: rewrite libmtp.so at our discretion and restart the process on whose behalf we want to run the code. </font><font style="vertical-align: inherit;">This can be done, again, by dropping the zygote, since not only the android applications, but also many system services, fall behind it.</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth saying thanks to the authors of the </font></font><a href="https://vms.drweb.ru/virus/%3F_is%3D1%26i%3D9009578"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android.Loki.28.origin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> virus </font><font style="vertical-align: inherit;">, from whom I got this great idea from introducing dependencies into the library.</font></font></blockquote><br><h3>  Instead of conclusion </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gone are the days when Android exploits exploited flagrant OS security vulnerabilities, which allowed us to create anything in the system with impunity. </font><font style="vertical-align: inherit;">Today, Android is well protected, and SELinux, introduced in version 4.3, and enabled by default in 5.0, made a significant contribution to protection. </font><font style="vertical-align: inherit;">Nevertheless, there are still loopholes in defense, and they still elevate privileges so that they can be used in practice, both for good purposes and for evil. </font><font style="vertical-align: inherit;">I hope you were interested in finding out how one of the most seemingly useless exploits in Android was able to find useful applications. </font><font style="vertical-align: inherit;">And I hope that the new version of the touch logger will help me collect the cars of the most valuable user data and will advance the study of the behavioral signs of gestures on the touch screen forward.</font></font></div><p>Source: <a href="https://habr.com/ru/post/332916/">https://habr.com/ru/post/332916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332906/index.html">What's new in CUBA Platform 6.5</a></li>
<li><a href="../332908/index.html">A little about the bugs in the BIOS / UEFI of Lenovo / Fujitsu / Toshiba / HP / Dell laptops</a></li>
<li><a href="../332910/index.html">Fly UNIGINE airplanes: a new aircraft simulator for MAKS-2017</a></li>
<li><a href="../332912/index.html">27000 errors in the Tizen operating system</a></li>
<li><a href="../332914/index.html">20 materials about the methods of successful traffic to the site</a></li>
<li><a href="../332918/index.html">Gremlins and ELF magic: what if the ELF file is a container?</a></li>
<li><a href="../332920/index.html">Deploy and demonize the ASP.NET Core Linux application as a background service.</a></li>
<li><a href="../332922/index.html">How isometric worlds are created</a></li>
<li><a href="../332924/index.html">Tcl / Tk. GUI development for command line utilities</a></li>
<li><a href="../332928/index.html">Implementing Elliptic curve Menezes-Vanstone cryptosystem based on the OpenSSL API</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>