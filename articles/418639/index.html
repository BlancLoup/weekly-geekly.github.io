<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Akka Streams for mere mortals</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="How can a few lines of code print a continuous stream of messages from Twitter, adding to it weather data in the places of residence of their authors?...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Akka Streams for mere mortals</h1><div class="post__text post__text-html js-mediator-article">  How can a few lines of code print a continuous stream of messages from Twitter, adding to it weather data in the places of residence of their authors?  And how to limit the speed of requests to the weather provider so that they do not put us on the black list? <br><br>  We will tell you today how to do this, but first we will get acquainted with Akka Streams technology, which allows you to work with real-time data streams as easily as programmers work with LINQ expressions, without requiring manual implementation of either individual actors or Reactive Streams interfaces . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ibpnza_PCr0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The article is based on the transcript of the <a href="http://2017.dotnext-moscow.ru/2017/msk/talks/3n90v5rogcu2cyq4s4awuc/">report of Vagif Abilov</a> from our December conference DotNext 2017 Moscow. <br><a name="habracut"></a><br>  My name is Vagif, I work for the Norwegian company Miles.  Today we talk about the library Akka Streams. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Akka and Reactive Streams is the intersection of rather narrow sets, and it may appear that this is such a niche to enter which you need to have some great knowledge, but just the opposite.  And this article is intended to show that using Akka Streams, you can avoid the low level programming that is required when working with Reactive Streams and Akka.NET.  Looking ahead, I can immediately say: if at the very beginning of our project, on which we use Akka, we knew about the existence of Akka Streams, we would have written a lot differently, saved both time and code. <br><blockquote>  <i>‚ÄúAlmost the worst thing you can do is get people who are not in pain to take your aspirin‚Äù</i> <br>  Max Kreminsky <br>  <a href="https://mkremins.github.io/blog/doors-headaches-intellectual-need/">‚ÄúClosed doors, headache and intellectual needs‚Äù</a> </blockquote>  Before we get into the technical details, a little bit about what your path to Akka Streams may turn out to be, which might lead you there.  Somehow, the blog of Max Kreminsky caught my eye, where he asked such a philosophical question for programmers: how or why it is impossible for a programmer to explain what monads are.  He explained it this way: very often, people immediately move on to technical details, explaining how functional programming is generally beautiful and how much sense there is in a monad, without bothering to ask why the programmer needs it at all.  Drawing an analogy, it's like trying to sell aspirin without bothering to find out if your patient is in pain. <br><br>  Using this analogy, I would like to ask the following question: if Akka Streams is aspirin, then what should be the pain that will lead you to it? <br><br><h1>  Data streams </h1><br>  First, let's talk about data streams.  Flow can be quite simple, linear. <br><br><div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">  Your browser does not support HTML5 video. <source src="https://media.giphy.com/media/ZNejul2eTftImnVrsY/giphy.mp4" type="video/mp4"></video></div></div></div><br>  Here we have a certain data consumer (rabbit video).  It consumes data at a rate that suits him.  This is the ideal consumer interaction with the stream: it sets the bandwidth, and the data is quietly coming to it.  This simple data stream can be endless, and it can end. <br><br>  But the flow can be more complicated.  If you plant several rabbits side by side, we will already have thread parallelization.  What Reactive Streams is trying to solve is how you can communicate with flows on a more conceptual level, i.e., regardless of whether it is just a matter of measuring a temperature sensor where we take linear measurements , or we have continuous measurements of thousands of temperature sensors that enter the system through RabbitMQ queues and are stored in system logs.  All of the above can be considered as one composite stream.  If you go further, then automated production management (for example, some online store) can also be reduced to a data flow, and it would be great if you could talk about planning such a flow regardless of how complicated it is. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7c/fa0/3af/a7cfa03af65ad4d88c1ce13d316e272e.jpg"><br><br>  Modern projects are not very good at supporting threads.  If I remember correctly, Aaron Stannard, whose tweet you see in the picture, wanted to get a stream of a multi-gigabyte file containing CSV, i.e.  text, and it turned out that there is nothing that you can just take and immediately use, without a heap of additional actions.  And he just could not get a stream of CSV-values, which saddened him.  There are few solutions (with the exception of some special areas), a lot of things are implemented by the old methods, when we open all this, we start to read, buffer, in the worst case, we get something like notepad, which says that the file is too large. <br><br>  At a high conceptual level, we are all involved in processing data streams, and Akka Streams will help you if: <br><br><ul><li>  You are familiar with Akka, but you want to save yourself from the details related to the writing of the code of actors and their coordination; <br></li><li>  You are familiar with Reactive Streams and would like to take advantage of a ready-made implementation of their specification; <br></li><li>  Akka Streams block elements are suitable for modeling your process; <br></li><li>  You want to take advantage of Akka Streams back pressure (backpressure) to control and dynamically refine the throughput of your workflow stages. <br></li></ul><br><h1>  From actors to Akka Streams </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/9e2/067/5d1/9e20675d1a251ffc62b578eba2e7167d.jpg"><br><br>  The first path is from actors to Akka Streams, my path. <br><br>  The picture shows why we began to use the model of actors.  We were exhausted by the manual flow control, the shared state, that‚Äôs all.  Anyone who has worked with large systems, multi-threaded, understands how much time it takes and how easy it is to make a mistake that can be fatal for the whole process.  This led us to the actor model.  We do not regret the choice made, but, of course, when you start working, you program more, it‚Äôs not that the initial enthusiasm gives way to something else, but you begin to realize that something could be done even more effectively. <br><blockquote>  <i>‚ÄúBy default, the recipients of their messages are written in the actor code.</i>  <i>If I create actor A, which sends a message to actor B, and you want to replace the recipient with actor C, in general, this will not work for you ‚Äù</i> <br>  Noel Welch (underscore.io) </blockquote>  Actors are criticized for not composing.  One of the first people to write about this in his blog was Noel Welsh, one of the Underscore developers.  He noted that the system of actors looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8f/e3b/3dd/d8fe3b3dd378bb187c4a85de3e982960.jpg"><br><br>  If you do not use any additional things, such as dependency injection, the recipient's address is sewn into the actor. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/62f/78b/3df62f78bf5f64bda875c5f448057427.jpg"><br><br>  When they begin to send messages to each other, you set all this in advance by programming the actors.  And without additional tweaks, such a tough system is obtained. <br>  One of the developers of Akka, Roland Kuhn, <a href="http://tinyurl.com/AkkaStreamsNdc3">explained</a> what is generally understood as a bad layout.  The actor's message is based on the tell method, that is, unidirectional messages: it is of type void, that is, it returns nothing (or unit, depending on the language).  Therefore, it is impossible to construct a description of the process from the chain of actors.  Here you send a tell, then what?  Stop.  We have turned void.  You can compare it, for example, with LINQ expressions, where each element of the expression returns IQueryable, IEnumerable, and all this can be easily put together.  Actors do not give such an opportunity.  At the same time, Roland Kuhn objected that they, they say, are not assembled in principle, saying that in fact they are arranged in other ways, in the same sense in which human society is amenable to composition.  Sounds like a philosophical argument, but if you think about it, the analogy makes sense - yes, the actors send one-way messages to each other, but we also communicate with each other, saying one-way messages, but we interact quite effectively, that is, we create complex systems.  Nevertheless, such criticism of actors exists. <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SampleActor</span></span> : <span class="hljs-title"><span class="hljs-title">ReceiveActor</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SampleActor</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Idle(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreStart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Idle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;Job&gt;(job =&gt; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Working</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Receive&lt;Cancel&gt;(job =&gt; <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span>); } }</code> </pre> <br>  In addition, the implementation of the actor requires at least the writing of a class if working on C #, or a function if working on F #.  The example above is the boilerplate code, which you will have to write anyway.  Although it is not very big, but it is a certain number of lines that you will always have to write at this low level.  Almost all the code that is present here is a kind of ceremony.  What happens when an actor directly receives a message is not shown here at all.  And all this needs to be written.  This, of course, is not very much, but it is evidence that we work with actors on a low level, creating such void-methods. <br><br>  What if we could go to another, higher level, to ask questions about the modeling of our process, which involves processing data from different sources, which are mixed, transformed, and transmitted further? <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = db.Companies .Join(db.People, c =&gt; c.CompanyID, p =&gt; p.PersonID, (c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c, p }) .Where(z =&gt; zcCreated &gt;= fromDate) .OrderByDescending(z =&gt; zcCreated) .Select(z =&gt; zp) .ToList();</code> </pre> <br>  An analogue of this approach may be something to which we have all got used to working with LINQ for ten years.  We do not ask ourselves how join works.  We know that there is such a LINQ provider that will do all this for us, and we are interested at a higher level in fulfilling the request.  And we, in general, can mix databases here, we can send distribution requests.  What if you could describe the process in this way? <br><br><pre> <code class="cs hljs">HttpGet pageUrl |&gt; fun s -&gt; Regex.Replace(s, <span class="hljs-string"><span class="hljs-string">"[^A-Za-z']"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>) |&gt; fun s -&gt; Regex.Split(s, <span class="hljs-string"><span class="hljs-string">" +"</span></span>) |&gt; Set.ofArray |&gt; Set.filter (fun word -&gt; not (Spellcheck word)) |&gt; Set.iter (fun word -&gt; printfn <span class="hljs-string"><span class="hljs-string">" %s"</span></span> word)</code> </pre> <br>  <a href="https://lorgonblog.wordpress.com/2008/03/30/pipelining-in-f/">(A source)</a> <br><br>  Or, for example, functional transformations.  How many people like functional programming is the fact that you can skip data through a series of transformations, and you get quite a clear compact code, regardless of what language you write it.  It's easy enough to read.  The code in the picture is specifically written in F #, but in general, probably, everyone understands what is happening here. <br><br><pre> <code class="cs hljs">val <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> = Source(<span class="hljs-number"><span class="hljs-number">1</span></span> to <span class="hljs-number"><span class="hljs-number">10</span></span>) val <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> = Sink.ignore val bcast = builder.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Broadcast[Int](<span class="hljs-number"><span class="hljs-number">2</span></span>)) val merge = builder.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(Merge[Int](<span class="hljs-number"><span class="hljs-number">2</span></span>)) val f1,f2,f3,f4 = Flow[Int].map(_ + <span class="hljs-number"><span class="hljs-number">10</span></span>) source ~&gt; f1 ~&gt; bcast ~&gt; f2 ~&gt; merge ~&gt; f3 ~&gt; sink bcast ~&gt; f4 ~&gt; merge ~&gt;</code> </pre> <br>  <a href="http://doc.akka.io/docs/akka/2.4/scala/stream/stream-graphs.html">(A source)</a> <br><br>  How then about this?  In the example above, we have the Source data source, which consists of integers from 1 to 10. This is the so-called graphical DSL (domain-specific language).  The elements of the domain language in the example above are the symbols of unidirectional arrows ‚Äî these are additional operators defined by means of the language, graphically showing the direction of flow.  We skip the Source through a series of transformations ‚Äî for ease of demonstration, they all simply add a ten to the number.  Next comes Broadcast: we multiply the channels, i.e., each number comes in two channels.  Then again we add 10, we mix our data streams, we get a new stream, we also add 10 in it, and all this goes to our data sink, in which nothing happens.  This is real code written in Scala, part of Akka Streams, implemented in this language.  That is, you specify the transformation phases of your data, specify what to do with it, specify the source, drain, some checkpoints, and then create such a graph using graphical DSL.  This is all the code of a single program  A few lines of code show what is happening in your process. <br><br>  Let's forget how to write the code for identifying individual actors and learn instead the high-level layout primitives that will create and connect the required actors.  When we launch such a graph, the system that provides Akka Streams itself creates the required actor, sends all this data there, processes it as it should, and eventually returns it to the final recipient. <br><br><pre> <code class="hljs pgsql">var runnable = Source .<span class="hljs-keyword"><span class="hljs-keyword">From</span></span>(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().<span class="hljs-keyword"><span class="hljs-keyword">Select</span></span>(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">To</span></span>(Sink.<span class="hljs-keyword"><span class="hljs-keyword">ForEach</span></span>&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;(x =&gt; Console.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(x.ToString));</code> </pre> <br>  The example above shows how this might look like in C #.  The easiest way: we have one data source - these are numbers from 1 to 1000 (as you can see, in Akka Streams, any IEnumerable can be a source of data flow, which is very convenient).  We do some simple calculation, say, multiply by two, and then on the data sink all this is displayed on the screen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(builder =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcast = builder.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = builder.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = Flow.FromFunction(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sum = Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Sum((x, y) =&gt; x + y); builder.From(bcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)).To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); builder.From(bcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)).Via(count).Via(sum).To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(bcast.In, merge.Out); });</code> </pre> <br>  What is shown in the example above is called ‚Äúgraphical DSL in C #‚Äù.  In fact, there is no graphics here, this is a port with Scala, but in C # there is no possibility to define operators in this way, so it looks a bit more cumbersome, but still compact enough to understand what is happening here.  So, we create a certain graph (there are different types of graph, here it is called FlowShape) from different components, where there is a data source and there are some transformations.  We release data on one channel, in which we generate count, that is, the number of the data element to be transmitted, and in the other we generate the sum and then we mix it all up.  Next we will see more interesting examples than just processing integers. <br>  This is the first way that can lead you to Akka Streams, if you have experience with the model of actors, and you are thinking about whether you need to write by hand each, even the simplest actor.  The second path that Akka Streams comes to is through Reactive Streams. <br><br><h1>  From Reactive Streams to Akka Streams </h1><br>  What is <a href="http://www.reactive-streams.org/">Reactive Streams</a> ?  This is a joint initiative to develop a standard for asynchronous data stream processing.  It defines the minimum set of interfaces, methods and protocols that describe the necessary operations and entities to achieve the goal - asynchronous data processing in real time with non-blocking back pressure (back pressure).  Allows various implementations using different programming languages. <br><br>  Reactive Streams allows you to process a potentially unlimited number of elements in a sequence and asynchronously transfer elements between components with non-blocking back pressure. <br><br>  The list of initiators of the creation of Reactive Streams is quite impressive: here is Netflix, and Oracle, and Twitter. <br><br>  The specification is very simple to make implementation in different languages ‚Äã‚Äãand platforms as accessible as possible.  Main components of the Reactive Streams API: <br><br><ol><li>  Publisher <br></li><li>  Subscriber <br></li><li>  Subscription <br></li><li>  Processor <br></li></ol><br>  It is significant that this specification does not imply that you will manually begin to implement these interfaces.  The implication is that there are some library developers who will do this for you.  And Akka Streams is one of the implementations of this specification. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPublisher</span></span>&lt;<span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Subscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISubscriber&lt;T&gt; subscriber</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISubscriber</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnSubscribe</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISubscription subscription</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnNext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T element</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception cause</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnComplete</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; }</code> </pre> <br>  Interfaces, as seen in the example, are really very simple: for example, Publisher contains only one method - ‚Äúsubscribe‚Äù.  The subscriber, Subscriber, contains only a few reactions to the event. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISubscription</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Request</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Cancel</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IProcessor</span></span>&lt;<span class="hljs-title"><span class="hljs-title">in</span></span> <span class="hljs-title"><span class="hljs-title">T1</span></span>, <span class="hljs-title"><span class="hljs-title">out</span></span> <span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">ISubscriber</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T1</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">IPublisher</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T2</span></span>&gt; { }</code> </pre> <br>  Finally, a subscription contains two methods - this is ‚Äústart‚Äù and ‚Äúrefuse‚Äù.  The processor does not define any new methods at all, it combines a publisher and a subscriber. <br><br>  What makes Reactive Streams stand out among other thread implementations?  Reactive Streams combines push and pull models.  For support, this is the most efficient scenario of speed.  Suppose you have a slow data subscriber.  In this case, push for him can be fatal: if you send him a huge amount of data, he will not be able to process them.  It is better to use pull, so that the subscriber himself pulls the data from the publisher.  But if the publisher is slow, it turns out that the subscriber is blocked all the time, waiting all the time.  Configuration can be an interim solution: we have a config file in which we determine which of them is faster.  And if their speeds change? <br><br>  So, the most elegant implementation is one in which we can dynamically change push and pull models. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/971/ab6/298/971ab6298b3f313b90503cf6a860e188.png"><br>  <a href="https://data-artisans.com/blog/how-flink-handles-backpressure">(Source (Apache Flink))</a> <br><br>  The diagram shows how this can occur.  This demo uses Apache Flink.  Yellow is a publisher, producer of data, it has been set at about 50% of its ability.  The subscriber is trying to choose the best strategy - it turns out to be push.  Then we reset the subscriber to a speed of about 20%, and he goes to pull.  Then we go out 100%, again return to 20%, to the pull model, etc. All this happens in dynamics, no need to stop the service, enter something into the configuration.  This is an illustration of how Akka Streams back pressure works. <br><br><h1>  Akka Streams working principles </h1><br>  Of course, Akka Streams would not be gaining popularity if there were no built-in blocks that are very easy to use.  There are a lot of them.  They are divided into three main groups: <br><br><ol><li>  Data source (Source) - processing stage with one output. <br></li><li>  Stoke (Sink) - a stage of processing with one entrance. <br></li><li>  Checkpoint (Flow) - processing stage with one input and one output.  Here functional transformations take place, and not necessarily in memory: it can be, for example, accessing a web service, to some elements of parallelism, multi-threaded. <br></li></ol><br>  From these three types it is possible to form graphs (Graph).  These are already more complex processing stages, which are built from sources, sinks and checkpoints.  But not every graph can be executed: if there are holes in it, i.e., open entrances and exits, then this graph is not allowed. <br>  A graph is runnable (Runnable Graph), if it is closed, that is, there is an exit for each input: if the data is entered, they must go somewhere. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/41f/059/a3c/41f059a3cebba7f1e023c8036a29cc8e.jpg"><br><br>  In Akka Streams there are built-in sources: in the picture you see how many of them are.  About one-to-one names reflect the Scala or JVM, with the exception of some .NET-specific useful sources.  The first two (FromEnumerator and From) are one of the most important: any numerator, any ienumerable can be turned into a stream source. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/504/3cb/0e7/5043cb0e7cd9fb15e6b00582b5230103.jpg"><br><br>  There are built-in sinks: some of them resemble LINQ methods, for example, First, Last, FirstOrDefault.  Of course, you can drop everything that you get into files, into streams, not in Akka Streams, but in .NET streams.  And again, if you have any actors in your system, you can use them both at the input and at the output of the system, i.e. if you wish, embed it in your ready-made system. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0a6/947/229/0a6947229a7ddbb5577b39634a4b6c11.jpg"><br><br>  And there are a huge number of built-in checkpoints, which, perhaps, remind LINQ even more, because there are both Select, and SelectMany, and GroupBy, that is, everything that we are used to working with in LINQ. <br><br>  For example, Scala's Select is called SelectAsync: it is powerful enough, because one of its arguments is the level of parallelism.  That is, you can specify that, for example, Select sends data to a web service in parallel in ten streams, then they are all collected and passed on.  In fact, you determine the degree of scaling of a checkpoint with a single line of code. <br><br>  The declaration of the flow is its executive plan, that is, the graph, even when it is started, cannot be executed just like that - it needs to be materialized.  There must be an instantiated system, actor system, you must give it a flow, this plan for execution, and then it will be executed.  Moreover, at runtime, it is highly optimized, much like when you send a LINQ expression to the database: the provider can optimize your SQL for more efficient data output, in effect replacing the query command with another.  The same with Akka Streams: starting from version 2.0, you can specify a certain number of checkpoints, and the system will understand that some of them can be combined to be performed by one actor (operator fusion).  Checkpoints, as a rule, keep the order of processing elements. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> results = db.Companies .Join(db.People, c =&gt; c.CompanyID, p =&gt; p.PersonID, (c, p) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c, p }) .Where(z =&gt; zcCreated &gt;= fromDate) .OrderByDescending(z =&gt; zcCreated) .Select(z =&gt; zp) .ToList();</code> </pre> <br>  Materialization of the stream can be compared with the last ToList element in the LINQ expression in the example above.  If we do not write ToList, then we will get an immaterialized LINQ expression that will not cause the data to be transferred to SQL Server or Oracle, since most LINQ providers support the so-called deferred query execution, t . e. the request is executed only when a command is given to give some result.  Depending on what is requested - the list or the first result - the most effective team will be formed.  When we say ToList, we thereby request the LINQ provider to give us the finished result. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runnable = Source .From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Select(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .To(Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; Console.Write(x.ToString));</code> </pre> <br>  Akka Streams works in a similar way.  In the picture, our startup graph consists of a source of checkpoints and a drain, and now we want to launch it. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> runnable = Source .From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)) .Via(Flow.Create&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;().Select(x =&gt; x * <span class="hljs-number"><span class="hljs-number">2</span></span>) .To(Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(x =&gt; Console.Write(x.ToString)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> system = ActorSystem.Create(<span class="hljs-string"><span class="hljs-string">"MyActorSystem"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> materializer = ActorMaterializer.Create(system)) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> runnable.Run(materializer); }</code> </pre> <br>  In order for this to happen, we need to create a system of actors, in it is a materializer, give him our graph, and he will execute it.  If we re-create it, it will execute it again, with other results. <br><br>  In addition to the materialization of the flow, speaking of the material part of Akka Streams, it is worth mentioning the materialized values. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source1 = Source.From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink1 = Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(output.Add); IRunnableGraph&lt;NotUsed&gt; runnable1 = source1.To(sink1); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source2 = Source.From(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sink2 = Sink.Sum&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;((x,y) =&gt; x + y); IRunnableGraph&lt;Task&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; runnable2 = source2.ToMaterialized(sink2, Keep.Right);</code> </pre> <br>  When we have a stream that goes from the source through checkpoints to the drain, then if we do not request any intermediate values, they are not available to us, since it will be executed in the most efficient way.  It is like a black box.  But it may be interesting to us to pull out some intermediate values, because at each point on the left some values ‚Äã‚Äãcome in, other values ‚Äã‚Äãcome out on the right, and you can, by setting the graph, indicate what you are interested in.  In the example above, a triggered graph in which NotUsed is specified, that is, we are not interested in any materialized values.  Below we create it with the indication that on the right side of the drain, that is, after performing all the transformations, we need to give the materialized values.  We get the Task graph - a task that, when executed, we get an int, that is, what happens at the end of this graph.  It is possible to indicate at each point that you need some materialized values, all this will gradually be collected. <br><br>  To transfer data into Akka Streams streams or to pull them out from there, we need, of course, some kind of interaction with the outside world.  Built-in source stages contain a wide range of reactive data streams: <br><br><ul><li>  Source.FromEnumerator and Source.From allow you to transfer data from any source that implements the IEnumerable; <br></li><li>  Unfold and UnfoldAsync form the results of the function calculations provided that it returns nonzero values; <br></li><li>  FromInputStream converts Stream; <br></li><li>  FromFile converts the contents of the file to the jet stream; <br></li><li>  ActorPublisher converts actor messages. <br></li></ul><br>  As I said before, for .NET developers, using Enumerator or IEnumerable is very productive, but sometimes this is too primitive, too inefficient a way to access data.  More complex and containing a large number of data sources require special connectors.  Such connectors are written.  There is an open source project Alpakka, which originally appeared in Scala and is now in .NET.  In addition, Akka has so-called persistent actors, and they have their own streams that can be used (for example, the Akka Persistence Query forms the content stream of the Akka Event Journal). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/109/c40/b29/109c40b2934e0a4a4e280b27d2cd1e8b.jpg"><br><br>  If you work with Scala, then the easiest thing for you: there are a huge number of connectors, and you will surely find something to your taste.  For information, Kafka is the so-called Reactive Kafka, not Kafka Streams.  Kafka Streams, as far as I know, does not support back pressure.  Reactive Kafka is a Kafka stream implementation that supports Reactive Streams. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f24/160/09d/f2416009d41f26f08e665b2d510aa7db.jpg"><br><br>  The list of Alpakka .NET connectors is more modest, but it is growing, and there is an element of competition.  There is a tweet six months ago, David Fowler from Microsoft, who said that SignalR can now exchange data with Reactive Extensions, and one of the Akka developers said that in fact Akka Streams had been around for a while.  Akka supports various services from Microsoft Azure.  CSV is the result of Aaron Stannard‚Äôs frustration when he discovered that there is no good stream for CSV: now Akka has his own stream for CSV XML.  There is AMQP (in reality RabbitMQ), it is in the development process, but is available for use, it works.  Kafka is also under development.  This list will continue to expand. <br><br>  A few words about alternatives, because if you work with data streams, Akka Streams is, of course, not the only way to process these streams.  Most likely, in your project, the choice of how to implement flows will depend on many other factors that may be key.  For example, if you work a lot with Microsoft Azure and Orleans are organically built into the needs of your project with their support for virtual actors, or, as they call them, grains, then they have their own implementation that does not conform to the Reactive Streams - Orleans Streams specification, which for you will be the closest, and it makes sense for you to pay attention to it.  If you work a lot with TPL, there is a TPL DataFlow - this is perhaps the closest analogy to Akka Streams: there are also primitives for linking data streams, as well as buffers and bandwidth limiting tools (BoundedCapacity, MaxMessagePerTask).  If the ideas of the actor model are close to you, then Akka Streams is a way to address this and save a significant amount of time without having to write each actor manually. <br><br><h1>  Example implementation: event log stream </h1><br>  Let's look at a couple of examples of implementation.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first example is not a direct flow implementation; this is how to use a flow. This was our first experience with Akka Streams, when we found that we could actually subscribe to some stream, which will simplify a lot for us. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/43e/de0/51f/43ede051f01ec132e11502f9cebaccaf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We upload different media files to the cloud. It was an early stage of the project: here in the last 15 minutes, 23 files, of which 7 errors. Now there are practically no errors and the number of files is much larger - hundreds pass through every few minutes. All this is contained in the Kibana Dashboard.</font></font><br> Kibana    Elasticsearch ,   Elasticsearch  ,    ,      ,        ,    .     ,      ,    , . .    .      (event journal) Akka,      Microsoft SQL Server.    ,          . <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> EventJournal ( Ordering <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, PersistenceID <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, SequenceNr <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Timestamp</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, IsDeleted <span class="hljs-built_in"><span class="hljs-built_in">BIT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Manifest <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">500</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Payload VARBINARY(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, Tags <span class="hljs-keyword"><span class="hljs-keyword">NVARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> QU_EventJournal <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (PersistenceID, SequenceNr) )</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To achieve this, we need, on the one hand, to rewrite the data taken from SQL Server, which contains a certain event store of persistent actors Akka, eventJournal. The picture shows a typical eventstore. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/cae/28e/b8e/cae28eb8efd64485e534c63d90550ce2.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other hand, the data comes in real time. And it turns out that in order to write the index, we need to read data from the database, plus data comes in real time, and at some point we need to understand: here the data from here ran out, this is new. This borderline moment requires additional verification in order to not lose anything and not record anything twice. That is, it turned out somehow quite difficult. My colleague and I were not happy with what we have coming out. This is not something that is very complex code, just rather dreary. So far, we have not remembered that the persistent actors in Akka support the persistence query.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6b2/bb9/08b/6b2bb908be095a552de279cbefad7f1b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is just the opportunity to get them in the form of a data stream abstracted from the source, they come from the database or are obtained in real time. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inline queries (persistence queries):</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AllPersistencelds </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CurrentPersistencelds </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EventsByPersistenceld </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CurrentEventsByPers existenceld </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> EventsByTag </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CurrentEventsByTag </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And there are a number of methods that we can use, for example, there is a Current method - this is a snapshot, given historically up to a given point in time. </font><font style="vertical-align: inherit;">And without this prefix - first and including real ones. </font><font style="vertical-align: inherit;">We needed EventsByTag.</font></font><br><br><pre> <code class="hljs kotlin">let system = mailbox.Context.System let queries = PersistenceQuery.Get(system) .ReadJournalFor&lt;SqlReadJournal&gt;(SqlReadJournal.Identifier) let mat = ActorMaterializer.Create(system) let offset = getCurrentOffset client config let ks = KillSwitches.Shared <span class="hljs-string"><span class="hljs-string">"persistence-elastic"</span></span> let task = queries.EventsByTag(PersistenceUtils.anyEventTag, offset) .Select(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> e -&gt; ElasticTypes.EventEnvelope.FromAkka e) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GroupedWithin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config.BatchSize, config.BatchTimeout)</span></span></span></span> .Via(ks.Flow()) .RunForeach((<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> batch -&gt; processItems client batch), mat) .</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ContinueWith</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(handleStreamError mailbox, TaskContinuationOptions.OnlyOnFaulted)</span></span></span></span> |&gt; Async.AwaitTaskVoid</code> </pre> <br>  ,    .     F#,   C#      .   EventsByTag,    Akka Streams,      ,     Elasticsearch. . .   -   ,       ,   ,    ‚Äî          .        . <br><br>       .   ,       ,    ,       ,  Twitter      ,   ‚Äî  ,   , ,    .     ,   Akka Streams. <br><br><h1>  :   </h1><br>    Akka  Scala,  Akka.NET,      ,      ,        ,      , . .          -  .     <a href="https://github.com/linvi/tweetinvi">Tweetinvi</a> ‚Äî   ,     Twitter,         .      Reactive Streams, . .      ,    ,     ,  ,   -  Akka,      ,     . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/acf/ac1/103/acfac11035eee1b69f2eb4c148f2f7f4.jpg"><br><br>       ,      , . .  Broadcast-.        ,     ,       .         :     ,         ,    ,    ,          . <br><br>      GitHub-,  <a href="https://github.com/object/AkkaStreamsDemo">AkkaStreamsDemo</a> .    (      <a href="https://youtu.be/ibpnza_PCr0%3Ft%3D39m44s">   </a> ). <br><br>  Let's start with the simple.        Twitter:   Program.cs <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> useCachedTweets = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In case I get banned from Twitter, I have cached tweets, they are faster. </font><font style="vertical-align: inherit;">For a start, we create a certain RunnableGraph.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IRunnableGraph&lt;IActorRef&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateRunnableGraph</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tweetSource = Source.ActorRef&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>, OverflowStrategy.DropHead); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> formatFlow = Flow.Create&lt;ITweet&gt;().Select(Utils.FormatTweet); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> writeSink = Sink.ForEach&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(Console.WriteLine); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tweetSource.Via(formatFlow).To(writeSink); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a tweet source here that comes from an actor. </font><font style="vertical-align: inherit;">I‚Äôll show you how we drag these tweets there, format them (the tweet format simply shows the author of the tweet) and then we write it on the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StartTweetStream - here we will use the Tweetinvi library.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartTweetStream</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IActorRef actor</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stream = Stream.CreateSampleStream(); stream.TweetReceived += (_, arg) =&gt; { arg.Tweet.Text = arg.Tweet.Text.Replace(<span class="hljs-string"><span class="hljs-string">"\r"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>).Replace(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> json = JsonConvert.SerializeObject(arg.Tweet); File.AppendAllText(<span class="hljs-string"><span class="hljs-string">"tweets.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{json}</span></span></span><span class="hljs-string">\r\n"</span></span>); actor.Tell(arg.Tweet); }; stream.StartStream(); }</code> </pre> <br> ( <a href=""></a> ) <br><br>  CreateSampleStream    ,       .      ,   ,    ,  : ¬´  ¬ª.     IEnumerable,       . <br><br>  <a href="">TweetEnumerator</a>   :     ,     Current, MoveNext, Reset,   Dispose,    .    ,      .   ,      .      . <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now we change the value of useCachedTweets to true, and this is where the complications begin. CashedTweets is the same, only I have a file out of 50,000 tweets there that I have already selected, saved, we will use them. I tried to choose tweets in which there is data on the geographical coordinates of their authors, that we need. The next stage - we want to parallelize tweets. After doing this, we‚Äôll have the owner of the tweet in the list first, and then the coordinates. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TweetsWithBroadcast:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates)) .Via(formatCoordinates) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If it were Scala, it would really look like a graphical DSL. </font><font style="vertical-align: inherit;">Here we create a Broadcast with two channels - out (0), out (1) - and in one case we print CreatedBy, in the other we print the coordinates, then we mix it all up and send it to the drain. </font><font style="vertical-align: inherit;">Too simple for now. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next stage of our demo is to make it a bit more complicated. </font><font style="vertical-align: inherit;">Let's start changing bandwidth.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy) .Throttle(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, ThrottleMode.Shaping)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates) .Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>, OverflowStrategy.DropNew) .Throttle(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, ThrottleMode.Shaping)) .Via(formatCoordinates) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br><br>          10   ,               10.    ,    ,  ,    . , ,   Akka Streams   Reactive Streams:     .   ,     ,   ,  ,    -  .    , ,    ,          .    ,      .   ,    ,    .     Buffer(10, OverFlowStrategy.DropHead).      ,         .      10        ,      .  , ,  - ,   ‚Äî      - ,   , ,   , . .          . ,      . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> graph = GraphDsl.Create(b =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> broadcast = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Broadcast&lt;ITweet&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> merge = b.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Merge&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">0</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.CreatedBy) .Throttle(<span class="hljs-number"><span class="hljs-number">10</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, ThrottleMode.Shaping)) .Via(formatUser) .To(merge.In(<span class="hljs-number"><span class="hljs-number">0</span></span>)); b.From(broadcast.Out(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .Via(Flow.Create&lt;ITweet&gt;().Select(tweet =&gt; tweet.Coordinates) .Buffer(<span class="hljs-number"><span class="hljs-number">10</span></span>, OverflowStrategy.DropNew) .Throttle(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeSpan.FromSeconds(<span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>, ThrottleMode.Shaping)) .Via(Flow.Create&lt;ICoordinates&gt;().SelectAsync(<span class="hljs-number"><span class="hljs-number">5</span></span>, Utils.GetWeatherAsync)) .Via(formatTemperature) .To(merge.In(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FlowShape&lt;ITweet, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(broadcast.In, merge.Out); });</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we have the second channel, it has SelectAsync, in which we get the weather. We do not just send it to the weather service, we also say that this code is executed with a parallelization level of 5: this means that 5 parallel streams will be created if this service is slow enough that this service will request the weather. The service itself is implemented here, it also makes sense to show how simple this code looks.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">decimal</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWeatherAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICoordinates coordinates</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestUrl = <span class="hljs-string"><span class="hljs-string">$"http://api.met.no/weatherapi/locationforecast/1.9/?lat=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{coordinates.Latitude}</span></span></span><span class="hljs-string">;lon=</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{coordinates.Latitude}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> httpClient.GetStringAsync(requestUrl); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doc = XDocument.Parse(result); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> temp = doc.Root.Descendants(<span class="hljs-string"><span class="hljs-string">"temperature"</span></span>).First().Attribute(<span class="hljs-string"><span class="hljs-string">"value"</span></span>).Value; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span>.Parse(temp); }</code> </pre> <br> ( <a href=""></a> ) <br><br>    .     -,      ,   -  ,   HttpClient   ,   XML,   ,     . <br><br>  ,   <a href="https://youtu.be/ibpnza_PCr0%3Ft%3D47m35s">  </a> ,      ,      .     10     10    ,          ,   . <br><br>  ,    ‚Äî   ,       .     ,     Akka Streams,   ,    . ,       ,  . <br><br>      , ,  ,       Akka Streams,        .  ,        ,      Akka Streams,       C#      ,      ,        ,    ,    . <br><br><h1>   </h1><br><img src="https://habrastorage.org/getpro/habr/post_images/17a/f2f/c2b/17af2fc2bfbacfc95fbe5bc9504a346e.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What ideas about Akka Streams would I like you to take out for yourself after reading this article? On DotNext 2017 Moscow I was on </font></font><a href="https://youtu.be/XwezhwHdvkI"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Alex Thyssen report</font></font></a>  Azure Functions.   -     ,      deployment,    ,      (      - ,     ,   ),            .     ,        ,    ,        .        ,      ,    Akka Streams, ..    ,            .                 . <br><br>  Akka Streams       , ,   ,     ,   ,      .    ,         ,     ,      ,    ,           .   Akka Streams ‚Äî  ,     ,          . <br><br>        ,       Akka Streams,  ¬´Akka Stream Rap¬ª.  <a href="https://youtu.be/1Ct3eIQ0Tgc"></a>  ,    . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1Ct3eIQ0Tgc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><blockquote> <i>This is the Akka Stream. <br><br> This is the Source that feeds the Akka Stream. <br><br> This is the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Streams. <br><br> This is the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream. <br><br> This is the Bidiflow that turns back the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the source that feeds the Akka Streams. <br><br> This is the Sink that is filled from the Bidiflow that turns back the Throttle that speeds down the TakeWhile that pulls from the Drop that removes from the Zip that combines from the Balance that splits the FilterNot that selects from the Merge that collects from the Broadcast that forks the MapAsync that maps from the Source that feeds the Akka Stream.</i> </blockquote> <b> .</b>         ‚Äî 22-23      <a href="https://dotnext-moscow.ru/">DotNext 2018 Moscow</a> ,        .  <a href="https://dotnext-moscow.ru/tickets/"> </a>    (     ). </div><p>Source: <a href="https://habr.com/ru/post/418639/">https://habr.com/ru/post/418639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418629/index.html">How to independently verify whether you can patent your product and conduct a patent search</a></li>
<li><a href="../418631/index.html">7 recommendations on the design of the JavaScript code</a></li>
<li><a href="../418633/index.html">Reactivity in JavaScript: a simple and clear example</a></li>
<li><a href="../418635/index.html">Creating an emulator arcade machine. Part 1</a></li>
<li><a href="../418637/index.html">Kubernetes to the masses: Slurm starts on August 3</a></li>
<li><a href="../418641/index.html">A mistake that prevents a designer from growing</a></li>
<li><a href="../418645/index.html">Reports from the spring conference C ++ Russia 2018</a></li>
<li><a href="../418649/index.html">Constant generation of alternative versions of TLS will solve the problem of the ‚Äúossification‚Äù of the old protocol</a></li>
<li><a href="../418653/index.html">Is WebAssembly returning Java and Flash applets?</a></li>
<li><a href="../418655/index.html">Windows Mixed Reality: Developer Guide (Part 1)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>