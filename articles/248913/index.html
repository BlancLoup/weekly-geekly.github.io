<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write extensions with Roslyn by 2015 studios (part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... This article is a continuation of the first part about writing extensions to the studio with Roslyn. 

 Here I will describe what to do if we want...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write extensions with Roslyn by 2015 studios (part 2)</h1><div class="post__text post__text-html js-mediator-article">  ... This article is a continuation of the <a href="http://habrahabr.ru/post/248899/">first part</a> about writing extensions to the studio with Roslyn. <br><br>  Here I will describe what to do if we want to generate / change some code.  To generate the code, we will use the static methods of the SyntaxFactory class.  Some methods require you to specify a keyword / type of expression / type of token, for this there is an enumeration - SyntaxKind, which contains all this together. <br><br>  Well, let's generate for example a code containing the number 10. This is done simply. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">SyntaxFactory</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LiteralExpression</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">SyntaxKind</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.NumericLiteralExpression</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">SyntaxFactory</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Literal</span></span>(10))</code> </pre> <br>  I was not joking when I said that to create code, the easiest way is to parse a string.  Fortunately, SyntaxFactory provides a bunch of methods for this (ParseSyntaxTree, ParseToken, ParseName, ParseTypeName, ParseExpression, ParseStatement, ParseCompilationUnit, Parse * List). <br><br>  But this is not the way of the real samurai. <br><a name="habracut"></a><br><h2>  So syntaxfactory </h2><br>  Ok, let's get rid of the first mistake I made.  I forgot that C # is now version 6.  And one of the C # 6 chips is static imports.  Let's trash our global scope. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Microsoft</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CodeAnalysis</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CSharp</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SyntaxFactory</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">using</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">static</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Microsoft</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CodeAnalysis</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SymbolKind</span></span>; ... <span class="hljs-selector-tag"><span class="hljs-selector-tag">LiteralExpression</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">NumericLiteralExpression</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Literal</span></span>(10))</code> </pre> <br>  A little better, but still does not look very.  If we write this in code, we will very quickly lose context and forget what we wanted to do.  And get bogged down with implementation details.  This is unreadable code. <br><br>  But the solution we have is essentially one thing - to make our own auxiliary methods that hide low level far away. <br><br>  For example, like this: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> LiteralExpressionSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToLiteral</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> number</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> LiteralExpression(NumericLiteralExpression, Literal(number)); } <span class="hljs-number"><span class="hljs-number">10.</span></span>ToLiteral()</code> </pre> <br><br>  Already a little better.  You may not like that we litter the scope for all ints with our methods.  But for me to write DSL normally. <br><br>  Well, let's try calling a method.  For this, there is the InvocationExpression method, the first parameter of which is an expression describing the method (for example this.Invoke, or my.LittlePony.Invoke ()), the second parameter is the list of arguments to the method. <br><br>  Those.  if we want to call this.Add (1, 2) method, then we need to write something like this: <br><br><pre> <code class="hljs pgsql">var <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> = MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, ThisExpression(), IdentifierName("Add")) // this.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span> var argument1 = Argument(<span class="hljs-number"><span class="hljs-number">1.</span></span>ToLiteral()); var argument2 = Argument(<span class="hljs-number"><span class="hljs-number">2.</span></span>ToLiteral()); var arguments = ArgumentList(SeparatedList(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> [] { argument1, argument2 })); var invocation = InvocationExpression(<span class="hljs-keyword"><span class="hljs-keyword">method</span></span>, arguments)</code> </pre> <br><br>  No beauty code.  Let's write a couple of DSL methods (these are DSL, not helpers. They do not bring anything into the code, neither the possibility of code reuse, nor the grouping of the code by meaning). <br><br>  First, the 1st line can be written as: <pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method = <span class="hljs-type"><span class="hljs-type">This</span></span>().<span class="hljs-type"><span class="hljs-type">Member</span></span>(<span class="hljs-string"><span class="hljs-string">"Add"</span></span>);</code> </pre>  And the last four can be written like this: <pre> <code class="hljs lisp">InvocationExpression(<span class="hljs-name"><span class="hljs-name">method</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>.ToLiteral(), <span class="hljs-number"><span class="hljs-number">2</span></span>.ToLiteral())</code> </pre>  Further, we reduce to one line: <pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">This</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.Member</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">Add</span></span>")<span class="hljs-selector-class"><span class="hljs-selector-class">.ToInvocation</span></span>(1<span class="hljs-selector-class"><span class="hljs-selector-class">.ToLiteral</span></span>(), 2<span class="hljs-selector-class"><span class="hljs-selector-class">.ToLiteral</span></span>())</code> </pre>  Or so: <pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">This</span></span>()<span class="hljs-selector-class"><span class="hljs-selector-class">.ToInvocation</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">Add</span></span>", 1. <span class="hljs-selector-tag"><span class="hljs-selector-tag">ToLiteral</span></span>(), 2<span class="hljs-selector-class"><span class="hljs-selector-class">.ToLiteral</span></span>())</code> </pre> <br><br>  Everything is simple, I will not describe what extension methods I wrote - they are stupid and obvious. <br><br>  Already an order of magnitude better, but still not beautiful.  That would get rid of this dull ToLiteral ().  After all, we have arguments that are at least ExpressionSyntax, we are not going anywhere.  If we force the ToInvocation method to accept only numbers, we will not be able to transfer something else there.  Or go away? <br><br>  Let's introduce the type of AutoExpressionWrapper. <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> AutoExpressionWrapper { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExpressionSyntax Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AutoExpressionWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExpressionSyntax </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { Value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">implicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AutoExpressionWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoExpressionWrapper(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.ToLiteral()) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">implicit</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AutoExpressionWrapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ExpressionSyntax </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AutoExpressionWrapper(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> InvocationExpressionSyntax </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToInvocation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> member, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">params</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AutoExpressionWrapper[] expressions</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> InvocationExpression(IdentifierName(member), expressions.ToArgumentList()); } This().ToInvocation(<span class="hljs-string"><span class="hljs-string">"Add"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br><br>  Beauty. <br><br>  The truth is that it is achieved in such a quantity of the left code that the mother does not worry.  Well, okay.  But beautiful and much more understandable. <br><br>  Everyone has their own choice, you can not write such a bunch of code, and stop early - where your heart desires.  Personally, my development process looks like this: <br><ul><li>  Wrote sample code that I want to generate. </li><li>  With the help of Roslyn Syntax Visualizer looked into what it parses </li><li>  I found the corresponding methods in SyntaxFactory, wrote the code, checked that it works correctly </li><li>  I rewrote everything to be beautiful and not too lazy. </li><li>  A couple of days came back, I realized that the code is bad, I rewrote </li><li>  I learned about the previously unknown API, I was upset </li></ul><br><br>  Let's do something simple, for example, we want to generate a code like "! Condition".  Here we have an identifier and a logical negation.  In code, it looks like this: <br><br><pre> <code class="hljs lisp">PrefixUnaryExpression(<span class="hljs-name"><span class="hljs-name">LogicalNotExpression</span></span>, IdentifierName(<span class="hljs-string"><span class="hljs-string">"condition"</span></span>))</code> </pre> <br>  With a slight movement of the hand, it is as follows <br><br><pre> <code class="hljs lisp">LogicalNot(<span class="hljs-name"><span class="hljs-name">IdentifierName</span></span>(<span class="hljs-string"><span class="hljs-string">"condition"</span></span>))</code> </pre> <br>  You may have trouble understanding which SyntaxKind you can use in which SyntaxFactory method.  <a href="">SyntaxKindFacts.cs</a> analysis can help you with this <a href="">.</a> <br><br>  Similarly generated for example, "a! = B": <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">BinaryExpression</span></span>(<span class="hljs-type"><span class="hljs-type">NotEqualsExpression</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">left</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">right</span></span>)</code> </pre> <br>  Ok, let's do something more complicated - let's declare the whole variable!  To do this, we just need to create a VariableDeclaration.  But since in C # the record is <i>int a = 2, b = 3;</i>  is a valid correct entry, then VariableDeclaration is a type of variables + a list of variables.  The variable itself (a = 2), for example, is the VariableDeclarator.  And what is the initializer?  Just an expression representing the number "2"?  Netushka is an expression representing "= 2".  And if we want to declare the variable ‚Äúint a = 2;‚Äù, then we will have the following code: <br><br><pre> <code class="hljs lisp">VariableDeclaration( <span class="hljs-name"><span class="hljs-name">IdentifierName</span></span>(<span class="hljs-string"><span class="hljs-string">"int"</span></span>), SeparatedList(<span class="hljs-name"><span class="hljs-name">new</span></span> [] { VariableDeclarator(<span class="hljs-string"><span class="hljs-string">"a"</span></span>).WithInitializer(<span class="hljs-name"><span class="hljs-name">EqualsValueClause</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>.ToLiteral())) }))</code> </pre> <br>  Okay, what if we want to declare a protected field?  Well, we should do this: <pre> <code class="hljs cs">FieldDeclaration(variableDeclaration).WithModifiers(TokenList(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { Token(ProtectedKeyword) }))</code> </pre> <br><br>  The biggest joke is that the entities of the field, properties, events, method, constructor have access modifiers.  But on the code it is not displayed in any way.  Each class that represents an entity simply has methods for working with modifiers.  Those.  you cannot write a generic method that makes everything beautiful (except through dynamic). <br><br>  Now let's assign some value to the variable.  To do this, you need to declare an expression (Expression) of an assignment (Assigment) and wrap it in something more independent ‚Äî ExpressionStatement or ReturnStatement. <br><pre> <code class="hljs smalltalk"><span class="hljs-type"><span class="hljs-type">ExpressionStatement</span></span>(<span class="hljs-type"><span class="hljs-type">AssignmentExpression</span></span>(<span class="hljs-type"><span class="hljs-type">SimpleAssignmentExpression</span></span>, <span class="hljs-type"><span class="hljs-type">IdentifierName</span></span>(<span class="hljs-comment"><span class="hljs-comment">"a"</span></span>), <span class="hljs-number"><span class="hljs-number">10.</span></span><span class="hljs-type"><span class="hljs-type">ToLiteral</span></span>())))</code> </pre> <br><br>  And if you want to determine the method in which such an assignment is performed, then first it would be nice to combine a bunch of Statements into one using BlockSyntax.  By the way, the method is determined surprisingly simply <br><br><pre> <code class="hljs objectivec">SyntaxFactory .MethodDeclaration(returnType: returnType, identifier: <span class="hljs-string"><span class="hljs-string">"DoAssignment"</span></span>) .WithParameterList(SyntaxFactory.ParameterList()) <span class="hljs-comment"><span class="hljs-comment">//      .WithBody(codeBlock) // codeBlock -  BlockSyntax</span></span></code> </pre> <br>  You can also specify access modifiers if you still want to. <br><br><h2>  SyntaxGenerator </h2><br>  But, to your happiness, not everything is so bad.  SyntaxFactory is a low-level API for generating code nodes.  You need to know about him.  But a lot of things can be done with the help of SyntaxGenerator, and your code will be cleaner and more beautiful.  His only drawback is that he is not a static class.  This may interfere with the development of its DSL, but the SyntaxGenerator is a clear move forward on the readability of the code. <br><br>  You can get it like this: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">SyntaxGenerator</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.GetGenerator</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span>)</code> </pre> <br>  And now you can try to generate a field. <br><br><pre> <code class="hljs ruby">generator.FieldDeclaration( <span class="hljs-string"><span class="hljs-string">"_myField"</span></span>, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   IdentifierName(<span class="hljs-string"><span class="hljs-string">"int"</span></span>), <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Accessibility.ProtectedOrInternal, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    protected internal  <span class="hljs-comment"><span class="hljs-comment"># DeclarationModifiers.ReadOnly, 2.ToLiteral() // ,    EqualsValueClause )</span></span></code> </pre> <br>  You can learn more about what methods the <a href="http://source.roslyn.codeplex.com/">SyntaxGenerator</a> provides and look at the implementation of the <a href="http://source.roslyn.codeplex.com/">CSharpSyntaxGenerator</a> . <br><br>  Also in the SyntaxGenerator you can find all sorts of methods like WithStatements, which are designed to get information or create a corrected code point.  They are also a bit higher-level than the methods defined in SyntaxNode and derivatives. <br><br><h2>  DocumentEditor </h2><br>  You remember that all code points are persistent unchanging trees?  So, after creating some code node, you need to put it in order, add the missing points, and then insert it into some other code node.  And then replace the old code-knot in the root with a modified one.  And if there are a lot of them?  It is not comfortable. <br><br>  But there is such a cool thing DocumentEditor - it turns work with immutable trees into a sequence of iterative actions.  It is created like this: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">DocumentEditor</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CreateAsync</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">document</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">token</span></span>)</code> </pre> <br>  Well, or you can create a SyntaxEditor (of which DocumentEditor is the heir). <br><br>  SyntaxEditor defines methods for replacing a node, adding, deleting, and getting a modified tree.  There are also a bunch of useful extension methods in <a href="http://source.roslyn.codeplex.com/">SyntaxEditorExtensions</a> .  Then the modified tree can be obtained with GetChangedRoot, and the modified document with GetChangedDocument.  Similar functionality but in size of the solution is organized in the form of SolutionEditor. <br><br>  Alas, the high-level API has not yet been fully tested and there are some bugs. <br><br>  Nice code generation. </div><p>Source: <a href="https://habr.com/ru/post/248913/">https://habr.com/ru/post/248913/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248901/index.html">Annotation to "Effective Modern C ++" by Scott Myers. Part 2</a></li>
<li><a href="../248903/index.html">Launch Linux in Microsoft Azure</a></li>
<li><a href="../248907/index.html">Software routing with VyOS</a></li>
<li><a href="../248909/index.html">A brief course of computer graphics: we write a simplified OpenGL do it yourself, article 3.1 of 6</a></li>
<li><a href="../248911/index.html">CSS Report 2014: Testing the use of CSS in the ‚Äúfield‚Äù</a></li>
<li><a href="../248917/index.html">CSRF in my home router and how I closed it</a></li>
<li><a href="../248919/index.html">Keyboard layout indicator with taskbar color and window title in modern versions of Windows using DWM</a></li>
<li><a href="../248933/index.html">Linux DDoS Trojan is hidden behind a built-in rootkit</a></li>
<li><a href="../248935/index.html">(Kiev) February 18-19, we invite you to the training course "Basics of modern server architecture"</a></li>
<li><a href="../248937/index.html">KodiCMS Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>