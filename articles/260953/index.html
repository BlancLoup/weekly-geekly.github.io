<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>10 Tips for Using ExecutorService</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I offer the readers of Habrakhabr the translation of the publication ‚ÄúExecutorService - 10 tips and tricks‚Äù . 



 The ExecutorService abstraction was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>10 Tips for Using ExecutorService</h1><div class="post__text post__text-html js-mediator-article">  <i>I offer the readers of Habrakhabr the translation of the publication <a href="http://www.nurkiewicz.com/2014/11/executorservice-10-tips-and-tricks.html">‚ÄúExecutorService - 10 tips and tricks‚Äù</a> .</i> <br><br><img src="https://habrastorage.org/files/f91/418/a40/f91418a4049743a19b6902accfb0e1af.jpg"><br><br>  The ExecutorService abstraction was introduced back in Java 5. The year was 2004 ... For a moment, now Java 5 and 6 are no longer supported and Java 7 is preparing to add to the list.  And many Java programmers still do not fully understand how ExecutorService works.  There are many sources at your disposal, but now I would like to tell you about little-known subtleties and practices for working with it. <br><a name="habracut"></a><br><h4>  <b>1. Name thread pools</b> </h4><br>  I can not mention this.  When dumping or during debugging, you can see that the standard flow naming scheme is as follows: <i>pool-N-thread-M</i> , where N denotes the sequential number of the pool (every time you create a new pool, the global counter N is incremented) thread number in the pool.  For example, <i>pool-2-thread-3</i> means the third thread in the second pool of the JVM life cycle.  See: <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html">Executors.defaultThreadFactory ()</a> .  Not very informative, is it?  JDK makes it a little difficult to properly name threads, because  The naming strategy is hidden inside <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadFactory.html">ThreadFactory</a> .  Fortunately, Google Guava has a built-in class for this: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.google.common.util.concurrent.ThreadFactoryBuilder; <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ThreadFactory threadFactory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadFactoryBuilder() .setNameFormat(<span class="hljs-string"><span class="hljs-string">"-%d"</span></span>) .setDaemon(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) .build(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number"><span class="hljs-number">10</span></span>, threadFactory);</code> </pre> <br>  By default, <i>non-daemon</i> thread pools are created, decide for yourself which ones are more appropriate. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <b>2. Change names depending on context.</b> </h4><br>  I learned about this trick from the article <a href="http://www.takipiblog.com/supercharged-jstack-how-to-debug-your-servers-at-100mph/">‚ÄúSupercharged jstack: How to Debug Your Servers at 100mph‚Äù</a> .  Once we know about the names of the streams, we can change them in runtime whenever we want!  This makes sense since the stream dump contains the names of classes and methods without parameters and local variables.  By including some important information in the stream name, we can easily trace which messages / posts / requests, etc.  inhibit the system or cause deadlock. <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String messageId)</span></span></span><span class="hljs-function"> </span></span>{ executorService.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Thread currentThread = Thread.currentThread(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String oldName = currentThread.getName(); currentThread.setName(<span class="hljs-string"><span class="hljs-string">"-"</span></span> + messageId); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... } finally { currentThread.setName(oldName); } }); }</span></span></code> </pre> <br>  Inside the <i>try-finally</i> block, the current thread is called <i>Processing-current-message ID</i> , which can be useful when tracking the message flow in the system. <br><br><h4>  <b>3. Explicit and secure completion</b> </h4><br>  A queue of tasks lies between the client threads and the thread pool.  When the application finishes, you have to worry about two things: what will happen with the tasks waiting in the queue, and how the already running ones will behave (more on that later).  Surprisingly, many developers do not close the thread pool properly.  There are two ways: either allow me to work all the tasks in the queue ( <i>shutdown ()</i> ), or delete them ( <i>shutdownNow ()</i> ) - depending on the specific case.  For example, if we have queued a set of tasks and want to return control as soon as all of them are executed, use <i>shutdown ()</i> : <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendAllEmails</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;String&gt; emails)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> InterruptedException </span></span>{ emails.forEach(email -&gt; executorService.submit(() -&gt; sendEmail(email))); executorService.shutdown(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> done = executorService.awaitTermination(<span class="hljs-number"><span class="hljs-number">1</span></span>, TimeUnit.MINUTES); log.debug(<span class="hljs-string"><span class="hljs-string">"    ? {}"</span></span>, done); }</code> </pre><br>  In this example, we send a batch of letters, each as a separate task for the thread pool.  After placing these tasks in the queue, we close the pool so that it can no longer accept new tasks.  Next, we wait a maximum of one minute until all tasks are completed.  However, if some tasks have not yet been completed, <i>awaitTermination ()</i> will simply return <i>false</i> .  In addition, the remaining tasks will continue.  I know hipsters are ready to go for: <br><pre> <code class="java hljs">emails.parallelStream().forEach(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::sendEmail);</code> </pre> <br>  Call me old fashioned, but I like to control the number of parallel threads.  An alternative to gradual <i>shutdown ()</i> is <i>shutdownNow ()</i> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> List&lt;Runnable&gt; rejected = executorService.shutdownNow(); log.debug(<span class="hljs-string"><span class="hljs-string">" : {}"</span></span>, rejected.size());</code> </pre> <br>  This time, all queued tasks are discarded and returned.  Already running tasks are allowed to continue. <br><br><h4>  <b>4. Handle thread interruption with care.</b> </h4><br>  A less well-known feature of the <i>Future</i> interface is the ability to cancel.  The following is one of my previous articles: <a href="http://www.nurkiewicz.com/2014/05/interruptedexception-and-interrupting.html">InterruptedException and interrupting threads explained</a> . <br>  Since the <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html">InterruptedException</a> exception is explicitly checked, no one, most likely, did not even think about how many errors it has suppressed over all these years.  And since it must be processed, many do it wrongly or thoughtlessly.  Let's look at a simple example of a stream that periodically does some sort of cleaning, and in the intervals it sleeps most of the time. <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cleaner</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ Cleaner() { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Thread cleanerThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); cleanerThread.start(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { cleanUp(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { TimeUnit.SECONDS.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { <span class="hljs-comment"><span class="hljs-comment">// TODO Auto-generated catch block e.printStackTrace(); } } } private void cleanUp() { //... } }</span></span></code> </pre><br>  This code is terrible anyway! <br><ol><li>  Running a stream from a constructor is often a bad idea.  For example, some frameworks, such as Spring, like to create dynamic subclasses to support interception methods.  Ultimately, we get two threads running from two instances. </li><li>  The <i>InterruptedException</i> exception is swallowed, not handled properly. </li><li>  This class starts a new thread in each instance.  Instead, it should use the <a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html">ScheduledThreadPoolExecutor</a> , which will produce the same threads for many objects, which is more reliable and efficient. </li><li>  In addition, using the <i>ScheduledThreadPoolExecutor,</i> we can avoid writing sleep / work cycles and go to work really on schedule. </li><li>  Last but not least.  There is no way to get rid of this thread, even if no one else refers to the Cleaner instance. </li></ol><br>  All of the problems listed are important, but suppressing <i>InterruptedException</i> is the greatest sin.  Before we understand why, let's think about why this exception is needed and how we can use its advantages to gracefully interrupt threads.  Many blocking operations in the JDK oblige how to handle <i>InterruptedException</i> , for example: <br><ul><li>  <i>Object.wait ()</i> </li><li>  <i>Thread.sleep ()</i> </li><li>  <i>Process.waitFor ()</i> </li><li>  A number of blocking methods in <i>java.util.concurrent. *</i> , Such as <i>ExecutorService.awaitTermination (), Future.get (), BlockingQueue.take (), Semaphore.acquire () Condition.await ()</i> and many, many others </li><li>  <i>SwingUtilities.invokeAndWait ()</i> </li></ul><br>  Note that blocking I / O does not throw an InterruptedException (which is unfortunate).  If all these classes declare <i>InterruptedException</i> , you may be surprised when these exceptions are thrown: <br><ul><li>  When a thread is blocked on any method that declares an <i>InterruptedException</i> , and you call <i>Thread.interrupt ()</i> on that thread, the blocking method will most likely immediately throw an <i>InterruptedException</i> . </li><li>  If you have queued a task ( <i>ExecutorService.submit ()</i> ) and called <i>Future.cancel (true)</i> while it is still running, the thread pool will try to interrupt the thread executing this task, effectively completing it. <br></li></ul><br>  Knowing what <i>InterruptedException</i> really is, we can handle it correctly.  If someone tries to interrupt our thread, and we discovered this, by handling <i>InterruptedException</i> , it would be wise to allow it to terminate immediately, for example: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cleaner</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AutoCloseable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Thread cleanerThread; Cleaner() { cleanerThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Cleaner"</span></span>); cleanerThread.start(); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { cleanUp(); TimeUnit.SECONDS.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException ignored) { log.debug(<span class="hljs-string"><span class="hljs-string">"Interrupted, closing"</span></span>); } } <span class="hljs-comment"><span class="hljs-comment">//... @Override public void close() { cleanerThread.interrupt(); } }</span></span></code> </pre><br>  Notice that the <i>try-finally</i> block in this example surrounds a <i>while loop</i> .  Thus, if <i>sleep ()</i> throws an <i>InterruptedException</i> , we will interrupt this cycle.  You may argue that we should log the <i>InterruptedException</i> exception stack.  It depends on situation.  In this case, the interruption of the flow is the expected behavior, not a fall.  In general, at your discretion.  In most cases, the thread will stop during sleep () and we will quickly end the <i>run ()</i> method at the same time.  If you are very careful, you will probably ask - and what will happen if the flow is interrupted during the <i>cleanUp () cleanup</i> ?  Often you will come up with a decision to manually set a flag, like this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> stop = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!stop) { cleanUp(); TimeUnit.SECONDS.sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ stop = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }</code> </pre><br>  Remember that the stop flag (it must be volatile!) Will not interrupt blocking operations, we must wait until the sleep () method completes.  On the other hand, this explicit flag gives us better control, because  we can monitor it at any time.  It turns out that thread interruption works the same way.  If someone interrupted the stream while he was performing non-blocking calculations (for example, <i>cleanUp ()</i> ), such calculations would not be interrupted immediately.  However, the thread has already been marked as interrupted, so any next blocking operation such as <i>sleep ()</i> will immediately stop and throw an <i>InterruptedException</i> , so we will not lose this signal. <br><br>  We can also take advantage of this fact if we implement a non-blocking stream, which still wants to take advantage of the thread interruption mechanism.  Instead of relying on <i>InterruptedException</i> , we should just check <i>Thread.isInterrupted ()</i> periodically <i>:</i> <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Thread.currentThread().isInterrupted()) { someHeavyComputations(); } }</code> </pre> <br>  As you can see, if someone interrupts our stream, we will cancel the calculations as soon as the previous iteration of <i>someHeavyComputations</i> () <i>allows</i> .  If it runs for a very long time or forever, we will never reach the interrupt flag.  It is noteworthy that this flag is not one-time.  We can call <i>Thread.interrupted ()</i> instead of <i>isInterrupted (),</i> which will reset the value of the flag and we can continue.  Sometimes you may want to ignore the interrupt flag and continue execution.  In this case, <i>interrupted ()</i> may come in handy. <br><br>  If you are an old school programmer, you probably remember the <i>Thread.stop ()</i> method, which was outdated 10 years ago.  In Java 8, there were plans for its ‚Äúde-implementation‚Äù, but in 1.8u5 it is still with us.  However, do not use it and refactor any code in which it occurs using <i>Thread.interrupt ()</i> . <br><br>  You may sometimes want to completely ignore InterruptedException.  In this case, look at the <i>Uninterruptibles</i> class from Guava.  It contains many methods such as <i>sleepUninterruptibly ()</i> or <i>awaitUninterruptibly (CountDownLatch).</i>  Just be careful with them.  They do not declare <i>InterruptedException</i> , but they also completely eliminate the interruption flow, which is rather unusual. <br><br>  So, now you have an understanding of why some methods throw <i>InterruptedException</i> : <br><ul><li>  Thrown <i>InterruptedException</i> must be adequately handled in most cases. </li><li>  Suppressing <i>InterruptedException</i> is often a bad idea. </li><li>  If the thread was interrupted during non-blocking calculations.  Use <i>isInterrupted</i> (). </li></ul><br><br><h4>  <b>5. Watch the queue length and determine the boundary.</b> </h4><br>  Poor-sized thread pools can lead to poor performance, instability, and memory leaks.  If you specify too few threads, the queue will grow, consuming a lot of memory.  On the other hand, too many threads will slow down the entire system due to frequent context switches, which will lead to the same symptoms.  It is important to maintain the queue depth and determine its boundaries.  An overloaded pool can simply temporarily abandon new tasks. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayBlockingQueue&lt;&gt;(<span class="hljs-number"><span class="hljs-number">100</span></span>); executorService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadPoolExecutor(n, n, <span class="hljs-number"><span class="hljs-number">0L</span></span>, TimeUnit.MILLISECONDS, queue);</code> </pre> <br>  The above code is equivalent to <i>Executors.newFixedThreadPool (n)</i> , but instead of using the default unlimited <i>LinkedBlockingQueue</i> , we use an <i>ArrayBlockingQueue</i> with a fixed capacity of 100. This means that if 100 tasks have already been recruited, the next task will be rejected with the exception of <i>RejectedExecutionException</i> .  In addition, since the queue is now accessible from the outside, we can periodically inquire about its size in order to write to the log, send to JMX, etc. <br><br><h4>  <b>6. Remember exception handling</b> </h4><br>  What is the result of the following code? <br><pre> <code class="java hljs">executorService.submit(() -&gt; { System.out.println(<span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0</span></span>); });</code> </pre> <br>  I was puzzled by how many times he did not print anything.  No sign of <i>java.lang.ArithmeticException: / by zero</i> , nothing.  The thread pool just swallowed the exception, as if it had never been thrown away.  If it were a thread created from scratch, without a wrapper in the form of a pool, the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.UncaughtExceptionHandler.html">UncaughtExceptionHandler</a> could work.  But with the thread pool, you need to be more careful.  If you send a <i>Runnable</i> (without any result, as above), you must put the entire method body inside a <i>try-catch</i> .  If you are queuing Callable, make sure that you always retrieve the result using the get () blocker to rethrow the exception: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Future&lt;Integer&gt; division = executorService.submit(() -&gt; <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   ExecutionException,  ArithmeticException division.get();</span></span></code> </pre> <br>  It is noteworthy that even the <i>Spring framework</i> made this mistake in <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/annotation/Async.html">@Async</a> , see: <a href="https://jira.spring.io/browse/SPR-8995">SPR-8995</a> and <a href="https://jira.spring.io/browse/SPR-12090">SPR-12090</a> . <br><br><h4>  <b>7. Keep track of waiting times in the queue.</b> </h4><br>  Monitoring of the working queue depth is one-way.  When solving problems with a single transaction / task, it makes sense to see how much time has passed between the statement of the problem and the beginning of its execution.  This time should ideally tend to zero (when there is an idle thread in the pool), but it will increase as tasks are queued.  In addition, if the pool does not have a fixed number of threads, launching a new task may require the birth of a new thread, which will also take some time.  To clearly measure this indicator, wrap the original <i>ExecutorService</i> into something similar: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WaitTimeMonitoringExecutorService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExecutorService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WaitTimeMonitoringExecutorService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExecutorService target)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = target; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;T&gt; task)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> startTime = System.currentTimeMillis(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.submit(() -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> queueDuration = System.currentTimeMillis() - startTime; log.debug(<span class="hljs-string"><span class="hljs-string">" {}    {} "</span></span>, task, queueDuration); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task.call(); } ); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Runnable task, T result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> submit(() -&gt; { task.run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Future&lt;?&gt; submit(Runnable task) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> submit(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Callable&lt;Void&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Void </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ task.run(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }); } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre> <br>  This is not a complete implementation, but the essence is clear.  At the moment when we set the task to the thread pool, we immediately noted the time.  Then they stopped the stopwatch as soon as the task was retrieved and sent for execution.  Do not be deceived by the proximity <i>startTime</i> and <i>queueDuration</i> in the source code.  In fact, these two strings are executed in different threads, in milliseconds or even in seconds from each other. <br><h4>  <b>8. Keep track of client stack</b> </h4><br>  Nowadays, increased attention is paid to reactive programming: <a href="http://www.reactivemanifesto.org/">Reactive manifesto</a> , <a href="http://www.reactive-streams.org/">reactive streams</a> , <a href="https://github.com/ReactiveX/RxJava">RxJava</a> (already 1.0!), <a href="http://clojure.org/agents">Clojure agents</a> , <a href="">scala.rx</a> ... It all looks great, but the structure is no longer your friend, it is by and large useless.  Consider, for example, the following exception that occurs during the execution of a job in a thread pool: <br><pre>  java.lang.NullPointerException: null
     at com.nurkiewicz.MyTask.call (Main.java:76) ~ [classes /: na]
     at com.nurkiewicz.MyTask.call (Main.java:72) ~ [classes /: na]
     at java.util.concurrent.FutureTask.run (FutureTask.java:266) ~ [na: 1.8.0]
     at java.util.concurrent.ThreadPoolExecutor.runWorker (ThreadPoolExecutor.java:1142) ~ [na: 1.8.0]
     at java.util.concurrent.ThreadPoolExecutor $ Worker.run (ThreadPoolExecutor.java:617) ~ [na: 1.8.0]
     at java.lang.Thread.run (Thread.java:744) ~ [na: 1.8.0] </pre><br>  We can easily notice that <i>MyTask</i> threw NPE on line 76. But we have no idea who approved this task, since the stack only applies to <i>Thread</i> and <i>ThreadPoolExecutor</i> .  Technically, we can simply navigate through the code in the hope of finding only one area where the <i>MyTask</i> is being queued.  But without separate streams (not to mention event-oriented, reactive, etc. programming), we always see the whole picture at once.  What if we could save the client's codetect stack (of what the task initiates) and show it, for example, when an error occurs?  The idea is not new, for example, <a href="http://hazelcast.com/">Hazelcast</a> distributes exceptions from the owner node to the client code.  Below is a simple example of how to do this: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExecutorServiceWithClientTrace</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExecutorService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ExecutorService target; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecutorServiceWithClientTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExecutorService target)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.target = target; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Future&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">submit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Callable&lt;T&gt; task)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> target.submit(wrap(task, clientTrace(), Thread.currentThread().getName())); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">Callable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Callable&lt;T&gt; task, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Exception clientStack, String clientThreadName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> () -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task.call(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { log.error(<span class="hljs-string"><span class="hljs-string">" {}     {}:"</span></span>, e, clientThreadName, clientStack); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Exception </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clientTrace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-string"><span class="hljs-string">" "</span></span>); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> InterruptedException { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tasks.stream().map(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::submit).collect(toList()); } <span class="hljs-comment"><span class="hljs-comment">//... }</span></span></code> </pre><br>  This time, in case of failure, we retrieve the complete spectrum and the name of the thread where the task was queued.  Much more valuable information than the standard exception discussed earlier: <br>  Exception java.lang.NullPointerException in the task from the main stream: <br><pre>  java.lang.Exception: Client Framework
     at com.nurkiewicz.ExecutorServiceWithClientTrace.clientTrace (ExecutorServiceWithClientTrace.java:43) ~ [classes /: na]
     at com.nurkiewicz.ExecutorServiceWithClientTrace.submit (ExecutorServiceWithClientTrace.java:28) ~ [classes /: na]
     at com.nurkiewicz.Main.main (Main.java:31) ~ [classes /: na]
     at sun.reflect.NativeMethodAccessorImpl.invoke0 (Native Method) ~ [na: 1.8.0]
     at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:62) ~ [na: 1.8.0]
     at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:43) ~ [na: 1.8.0]
     at java.lang.reflect.Method.invoke (Method.java:483) ~ [na: 1.8.0]
     at com.intellij.rt.execution.application.AppMain.main (AppMain.java:134) ~ [idea_rt.jar: na] </pre><br><br><h4>  <b>9. Prefer CompletableFuture</b> </h4><br>  In Java 8, the more powerful <a href="http://www.nurkiewicz.com/2013/05/java-8-definitive-guide-to.html">CompletableFuture</a> class was introduced.  Please use it where possible.  <i>ExecutorService has</i> not been extended to support this abstraction, so you should take care of this yourself.  Instead: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Future&lt;BigDecimal&gt; future = executorService.submit(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculate);</code> </pre> <br><br>  Use: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> CompletableFuture&lt;BigDecimal&gt; future = CompletableFuture.supplyAsync(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>::calculate, executorService);</code> </pre> <br><br>  <i>CompletableFuture</i> extends <i>Future</i> , so everything works as before.  But the more advanced users of your API will truly appreciate the advanced functionality provided by CompletableFuture. <br><br><h4>  <b>10. Synchronous queues</b> </h4><br>  <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/SynchronousQueue.html">SynchronousQueue</a> is an interesting variation of <i>BlockingQueue</i> , which is actually not exactly a queue.  It is not even a data structure per se.  Best of all, it can be defined as a queue with zero capacity. <br>  This is what <i>JavaDoc</i> says: <br><blockquote>  Each added operation must wait for the corresponding delete operation on another thread, and vice versa.  A synchronous queue has no internal capacity, even a single one.  You cannot look into the synchronous queue, because the element is presented only when you try to delete it;  you cannot insert an element (using any method) until another thread deletes it: you cannot bypass the queue because there is nothing to bypass. <br>  Synchronous queues are similar to the ‚Äúrendezvous channels‚Äù used in CSP and Ada. </blockquote><br>  How does all this relate to thread pools?  Let's try to use the <i>SynchronousQueue</i> with the <i>ThreadPoolExecutor</i> : <br><pre> <code class="java hljs">BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SynchronousQueue&lt;&gt;(); ExecutorService executorService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ThreadPoolExecutor(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0L</span></span>, TimeUnit.MILLISECONDS, queue);</code> </pre> <br>  We created a pool of threads with two threads and a <i>SynchronousQueue</i> before this.  In fact, the <i>SynchronousQueue</i> is a queue with a capacity of 0, so such <i>ExecutorService</i> will only accept new tasks if an idle thread is available.  If all threads are busy, the new task will be immediately rejected and will never wait in the queue.  This mode can be useful for immediate background processing, if possible. <br><br>  That's all, I hope you discovered at least one interesting feature! </div><p>Source: <a href="https://habr.com/ru/post/260953/">https://habr.com/ru/post/260953/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../260941/index.html">Google broke GCM in Chrome</a></li>
<li><a href="../260943/index.html">Intel Edison on guard of health. Experience "FRUIT MD"</a></li>
<li><a href="../260945/index.html">What you need to know about working with text preview emails</a></li>
<li><a href="../260947/index.html">Monitoring and alerting about events in Windows logs: sending to E-mail in Windows Server 2012 R2</a></li>
<li><a href="../260949/index.html">Why is programming so hard?</a></li>
<li><a href="../260955/index.html">Backup with Bareos and Relax-and-Recover</a></li>
<li><a href="../260957/index.html">Who is stronger - an elephant or ... an elephant?</a></li>
<li><a href="../260961/index.html">We write on JS in functional and declarative style</a></li>
<li><a href="../260963/index.html">Generating mapping via t4 templates</a></li>
<li><a href="../260965/index.html">Building a Rubik's Cube with a genetic algorithm online without SMS</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>