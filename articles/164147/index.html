<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Diskless network boot and life after it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Story 
 Once we received (well, not yourselves ...) servers with 14 hard drives of 2TB each. Having got rid of a hardware raid (why a separate questio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Diskless network boot and life after it</h1><div class="post__text post__text-html js-mediator-article"><h4>  Story </h4><br>  Once we received (well, not yourselves ...) servers with 14 hard drives of 2TB each.  Having got rid of a hardware raid (why a separate question), we thought about what it would be nice to do network booting for them in order to get rid of the fuss with partitions.  The disks were supposed to be exported via iSCSI, and I didn‚Äôt want to allocate any disks to the Special System Disks, but some for everything else.  Thus, the task arose to make a boot over the network with the location of the root directory in RAM. <br><a name="habracut"></a><br><h4>  Theory </h4><br>  In fact, in order for the system to boot, it needs 3 components ‚Äî the kernel, the initial initramfs environment, and the root directory in which the system will work. <br><br><h4>  Practice </h4><br>  All actions are performed on a machine with ubuntu precise. <br><br><h5>  PXE </h5><br>  First, let's configure PXE.  There are a lot of manuals on this topic, so I will tell only the essence. <br>  We put your favorite dhcp server, for example, isc-dhcp-server, which will distribute IP addresses to machines and specify the path to the pxelinux.0 file, which will be sent to the tftp server (tftp-hpa or atftp). <br><pre><code class="bash hljs">aptitude install isc-dhcp-server tftpd-hpa</code> </pre> <br>  An example of the dhcp server config.  In the example, the pxe server is located at 10.0.0.1. <br><pre> <code class="bash hljs">option domain-name-servers 8.8.8.8; server-name <span class="hljs-string"><span class="hljs-string">"pxe"</span></span>; subnet 10.0.0.0 netmask 255.255.255.0 { range dynamic-bootp 10.0.0.2 10.0.0.10; option subnet-mask 255.255.255.0; option routers 10.0.0.1; option root-path <span class="hljs-string"><span class="hljs-string">"10.0.0.1:/var/lib/tftpboot/"</span></span>; filename <span class="hljs-string"><span class="hljs-string">"pxelinux.0"</span></span>; }</code> </pre>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We start the tftp server (in ubuntu it has an init-script, but it is likely that you will have to run it through inetd / xinetd). <br>  We check the performance.  Put the file in the / var / lib / tftpboot directory and try to pull it off with a tftp client. <br><br><pre> <code class="bash hljs">tftp 10.0.0.1 tftp&gt; get pxelinux.0</code> </pre><br><br>  In principle, it doesn‚Äôt matter where you take the pxelinux.0 file, since it is just a bootloader, into which we transfer what we need to load further. <br>  You can make a beautiful menu in the bootloader, but now we don‚Äôt need it, so my pxelinux.cfg / default looks like this <br><br><pre> <code class="bash hljs">default vesamenu.c32 aprompt 1 timeout 2 label ubuntu 12.04 menu label Ubuntu precise kernel vmlinuz append initrd=initrd.img boot=ram rooturl=http://10.0.0.1/rootfs.squashfs ip=dhcp</code> </pre><br><br><h5>  rootfs </h5><br>  We build the rootfs image via debootstrap, spin it into it and install the necessary programs.  We configure the network, hostname, firewall, and so on. The more settings we make, the larger the image will be.  The main thing do not forget to change the password to root. <br><br><pre> <code class="bash hljs">mkdir -p /mnt/rootfs debootstrap precise /mnt/rootfs/ http://mirror.yandex.ru/ubuntu/ chroot /mnt/rootfs /bin/bash aptitude install vim ...</code> </pre><br>  With our minimum set, the system turned out to weigh 200MB. <br><br><h5>  Initramfs </h5><br>  In this example, we will take the root fs image from the web server located on our network boot server, that is, at 10.0.0.1.  The solution was simply because our initramfs had a wget utility.  In order not to draw a large amount of data over the network, we decided to compress the image.  This could be done with the usual tar, but you can try squashfs, especially since tar is usually not built into initramfs, on the other hand, nothing prevents it from being added there. <br><br>  <b>Squashfs</b> <br>  <a href="http://ru.wikipedia.org/wiki/Squashfs">Squashfs</a> is a compression file system that has been included in the kernel since version 2.6.29.  With its help, you can archive the directory, mount the device on the loop and read from it, to write, you need to carry out the procedure of adding files to the archive.  Since when you access the squashfs, you read from the archive, this gives an additional load on cpu. <br><br><pre> <code class="bash hljs"> mksquashfs /mnt/rootfs/ rootfs.squashfs -noappend -always-use-fragments du -hs rootfs.squashfs 92M rootfs.squashfs</code> </pre><br>  For more efficient compression, you can use the -comp option to set the type of compression; gzip is used by default. <br><br>  Next, you need to teach init from initramfs to take the root image and put it into RAM. <br><br>  <b>init</b> in initramfs is a sh script that parses options from the cmdline, mounts the fs, makes the switch_root and starts the main init-process of the system. <br>  Let's use this and add our options for cmdline.  Let's write the ram script, which will be called when the boot = ram option is set. <br><br>  vim / usr / share / initramfs-tools / scripts / ram <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash retry_nr=0 do_rammount() { log_begin_msg "Configuring networking" configure_networking log_end_msg log_begin_msg "Downloading rootfs image" mkdir -p /tmp/squashfs wget ${rooturl} -O /tmp/squashfs/rootfs.squashfs log_end_msg log_begin_msg "Mounting rootfs image to /mnt/squashfs" mkdir -p /mnt/squashfs mount -t squashfs -o loop /tmp/squashfs/rootfs.squashfs /mnt/squashfs log_end_msg log_begin_msg "Mounting tmpfs and copy rootfs image" mkdir -p ${rootmnt} mount -t tmpfs -o size=1G none ${rootmnt} cp -r -v /mnt/squashfs/* ${rootmnt} || exit 2 log_end_msg log_begin_msg "Umount squashfs" umount /mnt/squashfs || exit 2 log_end_msg } mountroot() { for x in $(cat /proc/cmdline); do case $x in rooturl=*) export rooturl=${x#rooturl=} ;; esac done log_begin_msg "Loading module squashfs" modprobe squashfs log_end_msg # For DHCP modprobe af_packet wait_for_udev 10 # Default delay is around 180s delay=${ROOTDELAY:-180} # loop until rammount succeeds do_rammount while [ ${retry_nr} -lt ${delay} ] &amp;&amp; [ ! -e ${rootmnt}${init} ]; do log_begin_msg "Retrying rammount" /bin/sleep 1 do_rammount retry_nr=$(( ${retry_nr} + 1 )) log_end_msg done }</span></span></code> </pre><br><br>  Through the rooturl parameter, you can specify where to download the root fs image.  To work with squashfs, you need to load its module into the kernel.  Specify in /etc/initramfs-tools/initramfs.conf BOOT = ram and reassemble the initramfs <br><br><pre> <code class="bash hljs">mkinitramfs -o /var/lib/tftpboot/initrd.img</code> </pre><br><br>  Turn on the machine on which we will test, and look at what is happening.  After a successful download, we received a diskless system, which takes up about 300MB in memory, and we can write to it, but after reboot, the system will return to its original state. <br><br>  In this example, we used squashfs just to compress the image, but why don't we try to mount the root partition in squashfs and see what happens?  We change our script, in the do_rammount () function we leave only the squashfs mount. <br><br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_rammount</span></span></span></span>() { log_begin_msg <span class="hljs-string"><span class="hljs-string">"Configuring networking"</span></span> configure_networking log_end_msg log_begin_msg <span class="hljs-string"><span class="hljs-string">"Downloading rootfs image"</span></span> mkdir -p /tmp/squashfs wget <span class="hljs-variable"><span class="hljs-variable">${rooturl}</span></span> -O /tmp/squashfs/rootfs.squashfs log_end_msg log_begin_msg <span class="hljs-string"><span class="hljs-string">"Mounting rootfs image to /mnt/squashfs"</span></span> mkdir -p /mnt/squashfs mount -t squashfs -o loop /tmp/squashfs/rootfs.squashfs <span class="hljs-variable"><span class="hljs-variable">${rootmnt}</span></span> log_end_msg }</code> </pre><br><br>  Reassemble initramfs, run, look.  The system boots in ro mode, but it only takes up about 180MB in memory. <br>  In some cases, mounting in ro mode is good, but we are not satisfied with it, but we also do not want to waste RAM.  The solution was found using Aufs. <br><br>  <b>Aufs</b> <br>  <a href="http://ru.wikipedia.org/wiki/AUFS">Aufs</a> allows you to do cascade-combined mount file systems - one in read-only mode, and the second in rw.  It works in the copy-on-write mode, that is, all changes are written to the rw system and after that the read is performed from it. <br>  Again we rewrite our script. <br>  Add to mountroot () function <br><pre> <code class="bash hljs"> log_begin_msg <span class="hljs-string"><span class="hljs-string">"Loading module aufs"</span></span> modprobe aufs log_end_msg</code> </pre><br><br>  And the do_rammount () function is reduced to the following form: <br><pre> <code class="bash hljs"><span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_rammount</span></span></span></span>() { log_begin_msg <span class="hljs-string"><span class="hljs-string">"Configuring networking"</span></span> configure_networking log_end_msg log_begin_msg <span class="hljs-string"><span class="hljs-string">"Downloading rootfs image"</span></span> mkdir -p /tmp/squashfs wget <span class="hljs-variable"><span class="hljs-variable">${rooturl}</span></span> -O /tmp/squashfs/rootfs.squashfs log_end_msg log_begin_msg <span class="hljs-string"><span class="hljs-string">"Mounting rootfs image to /mnt/ro"</span></span> mkdir -p /mnt/ro mount -t squashfs -o loop /tmp/squashfs/rootfs.squashfs /mnt/ro log_end_msg log_begin_msg <span class="hljs-string"><span class="hljs-string">"Mounting tmpfs to /mnt/rw"</span></span> mkdir -p /mnt/rw mount -t tmpfs -o size=1G none /mnt/rw log_end_msg log_begin_msg <span class="hljs-string"><span class="hljs-string">"Mounting aufs to /mnt/aufs"</span></span> mkdir -p /mnt/aufs mount -t aufs -o <span class="hljs-built_in"><span class="hljs-built_in">dirs</span></span>=/mnt/rw=rw:/mnt/ro=ro aufs /mnt/aufs log_end_msg [ -d /mnt/aufs/mnt/ro ] || mkdir -p /mnt/aufs/mnt/ro [ -d /mnt/aufs/mnt/rw ] || mkdir -p /mnt/aufs/mnt/rw mount --move /mnt/ro /mnt/aufs/mnt/ro <span class="hljs-comment"><span class="hljs-comment">#  squashfs   aufs mount --move /mnt/rw /mnt/aufs/mnt/rw #   tmpfs  aufs mount --move /mnt/aufs ${rootmnt} #   aufs  ${rootmnt} }</span></span></code> </pre><br><br>  Reassemble initramfs, run, look.  The system takes up 181Mb in memory, while we can change it, write, read.  All changes are stored separately in / mnt / rw, and the system itself is stored in / mnt / ro. <br><br>  As a result, we received a system that is loaded over the network, takes up a small amount in memory, and after each reboot, all changes disappear (therefore, we need to pre-assemble all the necessary waste products of the system in a safe place). <br><br>  All of the above methods have the right to life.  I hope that this information will be useful to you, but it will be interesting for me to read / listen to your comments. <br>  Thanks for attention. <br><br><h4>  Links </h4><br>  <a href="https://wiki.ubuntu.com/BootToRAM">Ubuntu boot to ram</a> <br>  <a href="http://squashfs.sourceforge.net/">Squashfs home page</a> <br>  <a href="http://www.syslinux.org/wiki/index.php/PXELINUX">PXE</a> </div><p>Source: <a href="https://habr.com/ru/post/164147/">https://habr.com/ru/post/164147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164133/index.html">Answers Minister of Communications to the questions of users: part 3</a></li>
<li><a href="../164135/index.html">Russia and the United States will jointly fight free file sharing</a></li>
<li><a href="../164139/index.html">Androgenizer - a tool for assembling sources for Android</a></li>
<li><a href="../164143/index.html">Microsoft Reporting Services Tips for Beginners</a></li>
<li><a href="../164145/index.html">Bitcoin Foundation holds a competition for projects on standardization, protection and promotion of Bitcoin</a></li>
<li><a href="../164153/index.html">LLST: New Life Little Smalltalk</a></li>
<li><a href="../164157/index.html">App Annie: analysis of the mobile market in Russia</a></li>
<li><a href="../164159/index.html">Chinese Institute of Microelectronics created 22nm transistors</a></li>
<li><a href="../164161/index.html">10 special-purpose Linux distributions</a></li>
<li><a href="../164163/index.html">What should be able to personal account of the wholesale company in 2013?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>