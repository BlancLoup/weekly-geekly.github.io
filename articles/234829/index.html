<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker image optimization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Docker images can be very large. Many exceed 1 GB in size. How do they become like that? Should they be like that? Can we make them smaller without sa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker image optimization</h1><div class="post__text post__text-html js-mediator-article"> Docker images can be very large.  Many exceed 1 GB in size.  How do they become like that?  Should they be like that?  Can we make them smaller without sacrificing functionality? <br><br>  At CenturyLink Lab we have been working a lot on building various <a href="https://registry.hub.docker.com/repos/centurylink/">docker images</a> lately.  When we started experimenting with their creation, we found that our assemblies very quickly swell in volume (it was common to build an image that weighs 1 GB or more).  The size, of course, is not so important if we are talking about images of two gigabytes lying on the local machine.  But it becomes a problem when you start constantly downloading / sending these images via the Internet. <br><br>  I decided that it was worthwhile to dig deeper and figure out how the process of creating docker images works, in order to understand what can be done to reduce the size of our assemblies. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>As a small digression, Adriaan de Jonge recently published an article, ‚Äú <a href="http://blog.xebia.com/2014/07/04/create-the-smallest-possible-docker-container/">Creating the smallest possible Docker container,</a> ‚Äù in which he described how to build an image that does not contain anything other than the Go static binary link that runs with the container.</i>  <i>His image is strikingly small - 3.6 MB.</i>  <i>Here I will not consider such extremes.</i>  <i>As a person who is used to working with languages ‚Äã‚Äãlike Python and Ruby, I need a slightly higher level of support from the OS, and I will gladly sacrifice a hundred megabytes of free space to be able to run Debian and <code>apt-get install</code> my dependencies.</i>  <i>Therefore, although I envy Adrian‚Äôs tiny image, I need support from a wider range of applications, which makes his approach impractical.</i> <br><br><h4>  Layers </h4><br>  Before we get to the topic of reducing your images, you need to talk about layers.  The concept of layers affects various low-level technical details about things like the root file system ( <i>rootfs</i> ), the <i>copy-on-write</i> mechanism, and the cascade-integrated mount ( <i>union mount</i> ).  Fortunately, this topic is well covered <a href="http://docs.docker.com/terms/layer/">elsewhere</a> , so I will not retell it here.  For our purposes, it is important to understand that each instruction in the Dockerfile leads to the creation of a new image layer. <br><br>  Let's take a look at the Dockerfile example to see this in action: <br><br><pre> <code class="bash hljs">FROM debian:wheezy RUN mkdir /tmp/foo RUN fallocate -l 1G /tmp/foo/bar</code> </pre><br>  A completely useless image, but it will help us demonstrate what has been said.  Here we use <code>debian:wheezy</code> as the base image, create the <code>/tmp/foo</code> , and in it select 1 GB of space for the <code>bar</code> file. <br><br>  Let's collect this image: <br><br><pre> <code class="bash hljs">$ docker build -t sample . Sending build context to Docker daemon 2.56 kB Sending build context to Docker daemon Step 0 : FROM debian:wheezy ---&gt; e8d37d9e3476 Step 1 : RUN mkdir /tmp/foo ---&gt; Running <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 3d5d8b288cc2 ---&gt; 9876aa270471 Removing intermediate container 3d5d8b288cc2 Step 2 : RUN fallocate -l 1G /tmp/foo/bar ---&gt; Running <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> 6c797329ee43 ---&gt; 3ebe08b36733 Removing intermediate container 6c797329ee43 Successfully built 3ebe08b36733</code> </pre><br>  If you look at the output of the <code>docker build</code> , you can see what exactly Docker does to build our image: <br><br><ol><li>  Using the value of the <code>FROM</code> instruction, Docker launches a container based on a <code>debian:wheezy</code> image (container ID: <code>3d5d8b288cc2</code> ) </li><li>  Inside this container, Docker runs the <code>mkdir /tmp/foo</code> command. </li><li>  The container is stopped, commited (as a result, a new image with ID <code>9876aa270471</code> ) and then deleted </li><li>  Docker launches another container, this time from the image saved in the previous step (this container has ID <code>6c797329ee43</code> ) </li><li>  Inside the running Docker container, execute the <code>fallocate -l 1G /tmp/foo/bar</code> </li><li>  The container is stopped, commited (as a result, a new image was created with ID <code>3ebe08b36733</code> ) and then deleted </li></ol><br>  We can see the final result by running the <code>docker images --tree</code> (unfortunately, the <code>--tree</code> flag <code>--tree</code> obsolete and is likely to be removed in future releases): <br><br><pre> <code class="bash hljs">$ docker images --tree Warning: <span class="hljs-string"><span class="hljs-string">'--tree'</span></span> is deprecated, it will be removed soon. See usage. ‚îî‚îÄ511136ea3c5a Virtual Size: 0 B Tags: scratch:latest ‚îî‚îÄ59e359cb35ef Virtual Size: 85.18 MB ‚îî‚îÄe8d37d9e3476 Virtual Size: 85.18 MB Tags: debian:wheezy ‚îî‚îÄ9876aa270471 Virtual Size: 85.18 MB ‚îî‚îÄ3ebe08b36733 Virtual Size: 1.159 GB Tags: sample:latest</code> </pre><br>  Here you can see the image marked as <code>debian:wheezy</code> , followed by the two containers mentioned earlier (one for each instruction in the Dockerfile). <br><br>  We often talk about layers and images as if they were different things.  But, in fact, each layer is an image, and an image layer is just a collection of other images. <br><br>  Just as we do: <br><pre> <code class="bash hljs">docker run -it sample:latest /bin/bash</code> </pre>  We can easily run one of the unnamed layers: <br><pre> <code class="bash hljs">docker run -it 9876aa270471 /bin/bash</code> </pre><br>  Both of them are images, on the basis of which containers can be launched.  The only difference is that the first is named and the second is not.  This ability to run containers from any layer can be quite useful when debugging your Dockerfile. <br><br><h4>  Image size </h4><br>  Knowing that an image is nothing more than a collection of other images, one can come to an obvious conclusion: the image size is equal to the sum of the sizes of the images that make it up. <br><br>  Let's look at the output of the <code>docker history</code> : <br><br><pre> <code class="bash hljs">$ docker <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> sample IMAGE CREATED CREATED BY SIZE 3ebe08b36733 3 minutes ago /bin/sh -c fallocate -l 1G /tmp/foo/bar 1.074 GB 9876aa270471 3 minutes ago /bin/sh -c mkdir /tmp/foo 0 B e8d37d9e3476 4 days ago /bin/sh -c <span class="hljs-comment"><span class="hljs-comment">#(nop) CMD [/bin/bash] 0 B 59e359cb35ef 4 days ago /bin/sh -c #(nop) ADD file:1e2ba3d9379f 85.18 MB 511136ea3c5a 13 months ago 0 B</span></span></code> </pre><br>  We can see all the layers of the <code>sample</code> image along with the commands that led to their creation and their size (note that the order of the layers in <code>docker history</code> is the same as the order displayed in <code>docker images --tree</code> ). <br><br>  There are only two instructions that do something meaningful to our image: an <code>ADD</code> instruction (inherited from <code>debian:wheezy</code> ) and our <code>fallocate</code> command. <br><br>  Let's save our image to a tarball and see what the weight will be: <br><br><pre> <code class="bash hljs">$ docker save sample &gt; sample.tar $ ls -lh sample.tar -rw-r--r-- 1 core core 1.1G Jul 26 02:35 sample.tar</code> </pre><br>  When the image is saved in a tar file this way, different metadata about each layer is also placed there, so the final size will be slightly more than the sum of the sizes of all the layers. <br><br>  Add one more instruction to the Dockerfile: <br><br><pre> <code class="bash hljs">FROM debian:wheezy RUN mkdir /tmp/foo RUN fallocate -l 1G /tmp/foo/bar RUN rm /tmp/foo/bar</code> </pre><br>  A new instruction will delete the file immediately after it is created. <br><br>  If we do the <code>docker build</code> for the updated Dockerfile and look at the story again, we will see the following: <br><br><pre> <code class="bash hljs">$ docker <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> sample IMAGE CREATED CREATED BY SIZE 9d9bdb929b00 8 seconds ago /bin/sh -c rm /tmp/foo/bar 0 B 3ebe08b36733 24 minutes ago /bin/sh -c fallocate -l 1G /tmp/foo/bar 1.074 GB 9876aa270471 24 minutes ago /bin/sh -c mkdir /tmp/foo 0 B e8d37d9e3476 4 days ago /bin/sh -c <span class="hljs-comment"><span class="hljs-comment">#(nop) CMD [/bin/bash] 0 B 59e359cb35ef 4 days ago /bin/sh -c #(nop) ADD file:1e2ba3d9379f 85.18 MB 511136ea3c5a 13 months ago 0 B</span></span></code> </pre><br>  Notice that the <code>rm</code> call has added a new layer (to 0 bytes), but everything else remains the same.  If we save our updated image, we should see that the size has practically not changed (there will be a slight difference due to the metadata of the added layer): <br><br><pre> <code class="bash hljs">$ docker save sample &gt; sample.tar $ ls -lh sample.tar -rw-r--r-- 1 core core 1.1G Jul 26 02:55 sample.tar</code> </pre><br>  If we called the <code>docker run</code> for this image and looked into the <code>/tmp/foo</code> , we would find it empty (ultimately, the file was deleted).  However, since our Dockerfile generated a layer containing a 1 GB file, it has become an integral part of the image. <br><br>  <b>Each additional instruction in your Dockerfile will only increase the overall size of the image.</b> <br><br>  Of course, this example is far-fetched.  But understanding the fact that images are sums of the layers of which they are composed is important when looking for ways to reduce them.  Below I will describe several ways to do this. <br><br><h4>  Choose your base </h4><br>  Pretty obvious advice.  However, the choice of the base can significantly affect the final size of the image.  For example, here is a list of popular base images and their sizes: <br><br><pre> <code class="bash hljs">$ docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE scratch latest 511136ea3c5a 13 months ago 0 B busybox latest a9eb17255234 7 weeks ago 2.433 MB debian latest e8d37d9e3476 4 days ago 85.18 MB ubuntu latest ba5877dc9bec 4 days ago 192.7 MB centos latest 1a7dc42f78ba 2 weeks ago 236.4 MB fedora latest 88b42ffd1f7c 10 days ago 373.7 MB</code> </pre><br>  We used to use <code>ubuntu</code> as a basis for the team - mostly because most of us already knew it.  However, after playing a little with <code>debian</code> , we concluded that it fully satisfies our needs and at the same time retains 100+ MB of space. <br><br>  The list of useful databases may be different and depends on your needs, but you should definitely check it out.  If you use Ubuntu, when BusyBox would be enough, then you waste a lot of space. <br><br>  It would be desirable, that the size of images was displayed in storage of Docker.  But now, unfortunately, to find out the size, the image must be downloaded. <br><br><h4>  Reuse your base </h4><br>  One of the advantages of the layer approach is the ability to reuse layers between different images.  The example below shows three images that use <code>debian:wheezy</code> as a basis: <br><br><pre> <code class="bash hljs">$ docker images --tree Warning: <span class="hljs-string"><span class="hljs-string">'--tree'</span></span> is deprecated, it will be removed soon. See usage. ‚îî‚îÄ511136ea3c5a Virtual Size: 0 B Tags: scratch:latest ‚îî‚îÄe8d37d9e3476 Virtual Size: 85.18 MB Tags: debian:wheezy ‚îú‚îÄ22a0de5ea279 Virtual Size: 85.18 MB ‚îÇ ‚îî‚îÄ057ac524d834 Virtual Size: 85.18 MB ‚îÇ ‚îî‚îÄbd30825f7522 Virtual Size: 106.2 MB Tags: creeper:latest ‚îú‚îÄd689af903018 Virtual Size: 85.18 MB ‚îÇ ‚îî‚îÄbcf6f6a90302 Virtual Size: 85.18 MB ‚îÇ ‚îî‚îÄffab3863d257 Virtual Size: 95.67 MB Tags: enderman:latest ‚îî‚îÄ9876aa270471 Virtual Size: 85.18 MB ‚îî‚îÄ3ebe08b36733 Virtual Size: 1.159 GB ‚îî‚îÄ9d9bdb929b00 Virtual Size: 1.159 GB Tags: sample:latest</code> </pre><br>  Each one builds on <code>debian:wheezy</code> , but these are not three copies of Debian.  Instead of copying, each image contains a link to an instance of the Debian layer (one of the reasons I like <code>docker images --tree</code> , is that it clearly demonstrates the connections between different layers). <br><br>  This means that once you download <code>debian:wheezy</code> , you no longer have to drag these layers again, and every bit of it used in the images will take place only once. <br><br>  So you can save a considerable amount of space and Internet traffic using a common base for different images. <br><br><h4>  Group your teams </h4><br>  In the example above, we create the file and then immediately delete it.  The situation, though contrived, but something similar often occurs during the construction of images.  Let's look at something more realistic: <br><br><pre> <code class="bash hljs">FROM debian:wheezy WORKDIR /tmp RUN wget -nv RUN tar -xvf someutility-v1.0.0.tar.gz RUN mv /tmp/someutility-v1.0.0/someutil /usr/bin/someutil RUN rm -rf /tmp/someutility-v1.0.0 RUN rm /tmp/someutility-v1.0.0.tar.gz</code> </pre><br>  We download the tarball, unpack it, move and clean up something. <br><br>  As we saw earlier, each of these instructions creates a separate layer.  Although we delete the archive and the extracted files, they still remain part of the image. <br><br><pre> <code class="bash hljs">$ docker <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> some utility IMAGE CREATED CREATED BY SIZE 33f4a99 16 seconds ago /bin/sh -c rm /tmp/someutility-v1.0.0.tar.gz 0 B fec7b5e 17 seconds ago /bin/sh -c rm -rf /tmp/someutility-v1.0.0 0 B 0851974 18 seconds ago /bin/sh -c mv /tmp/someutility-v1.0.0/someuti 12.21 MB 5b6b996 19 seconds ago /bin/sh -c tar -xvf someutility-v1.0.0.tar.gz 99.91 MB 0eebad5 20 seconds ago /bin/sh -c wget -nv http://centurylinklabs.com 55.34 MB d6798fc 8 minutes ago /bin/sh -c <span class="hljs-comment"><span class="hljs-comment">#(nop) WORKDIR /tmp 0 B e8d37d9 5 days ago /bin/sh -c #(nop) CMD [/bin/bash] 0 B 59e359c 5 days ago /bin/sh -c #(nop) ADD file:1e2ba3d9379f7685a1 85.18 MB 511136e 13 months ago 0 B</span></span></code> </pre><br>  Running <code>wget</code> results in a 55 MB layer, and unpacking the archive to a 99 MB layer.  We do not need these files, which means we just waste 150+ MB in vain. <br><br>  We can fix this by doing a little refactoring of our Dockerfile: <br><br><pre> <code class="bash hljs">FROM debian:wheezy WORKDIR /tmp RUN wget -nv &amp;&amp; \ tar -xvf someutility-v1.0.0.tar.gz &amp;&amp; \ mv /tmp/someutility-v1.0.0/someutil /usr/bin/someutil &amp;&amp; \ rm -rf /tmp/someutility-v1.0.0 &amp;&amp; \ rm /tmp/someutility-v1.0.0.tar.gz</code> </pre><br>  Instead of running each command in a separate <code>RUN</code> instruction, we grouped them using the <code>&amp;&amp;</code> operator.  And although the Dockerfile becomes a bit less readable, it allows us to remove the tarball and extracted directory before the layer is committed. <br><br>  Here is what happened as a result: <br><br><pre> <code class="bash hljs">$ docker <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> some utility IMAGE CREATED CREATED BY SIZE 8216b5f 7 seconds ago /bin/sh -c wget -nv http://centurylinklabs.com 12.21 MB d6798fc 17 minutes ago /bin/sh -c <span class="hljs-comment"><span class="hljs-comment">#(nop) WORKDIR /tmp 0 B e8d37d9 5 days ago /bin/sh -c #(nop) CMD [/bin/bash] 0 B 59e359c 5 days ago /bin/sh -c #(nop) ADD file:1e2ba3d9379f7685a1 85.18 MB 511136e 13 months ago 0 B</span></span></code> </pre><br><br>  Note that in the end we got the same image, while getting rid of a few extra layers and saving 150 MB of free space. <br><br>  I would not advise you to urgently go and rewrite all the commands in your Dockerfile in one line.  However, if you notice that somewhere there is a similar situation when you create and then delete files, then combining several instructions into one will help you keep the image size as small as possible. <br><br><h4>  "Shut down" your images </h4><br>  All the strategies described above are based on the assumption that you are creating your own image, or, at least, you have access to the Dockerfile.  However, it is possible that you have an image created by someone else and you want to make it a little easier. <br><br>  In this case, we can take advantage of the fact that the creation of the container leads to the merging of all layers into one. <br><br>  Let's go back to our <code>sample</code> image (the one with <code>fallocate</code> and <code>rm</code> ) and run it: <br><br><pre> <code class="bash hljs">$ docker run -d sample 7423d238b754e6a2c5294aab7b185f80be2457ee36de22795685b19ff1cf03ec</code> </pre><br>  Since our image, in fact, does nothing, it immediately completes the work.  This gives us a stopped container, which is the result of merging all the layers of the image (I used the <code>-d</code> flag just to display the container ID). <br><br>  If we export this container by redirecting the output to the <code>docker import</code> , we can turn it back into an image: <br><br><pre> <code class="bash hljs">$ docker <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> 7423d238b | docker import - sample:flat 3995a1f00b91efb016250ca6acc31aaf5d621c6adaf84664a66b7a4594f695eb $ docker <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> sample:flat IMAGE CREATED CREATED BY SIZE 3995a1f00b91 12 seconds ago 85.18 MB</code> </pre><br>  Please note that the story for our new image <code>sample:flat</code> shows only one layer weighing 85 MB, - the layer containing the gigabyte file is missing. <br><br>  And, although this is a rather clever trick, it should be noted that it has significant drawbacks: <br><br><ul><li>  Merging all the layers together, you lose the advantage of sharing layers in different ways described earlier.  Our <code>sample:flat</code> image now contains a built-in <code>debian:wheezy</code> copy. </li><li>  All metadata, usually stored with the image, is lost in the process of launching / exporting / importing.  Opening ports, environment variables, default command ‚Äî everything that can be declared in the original image is lost. </li></ul><br>  Therefore, I definitely would not advise you to rush to "collapse" all your images.  But, sometimes, it can be useful: if you are trying to optimize someone else's image, or just want to find out how much you can press your own. <br><br>  - <i>Source: <a href="http://www.centurylinklabs.com/optimizing-docker-images/">Optimizing Docker Images</a></i> </div><p>Source: <a href="https://habr.com/ru/post/234829/">https://habr.com/ru/post/234829/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../234819/index.html">To wash or not to wash? Foursquare for clean drivers</a></li>
<li><a href="../234821/index.html">Transformation of smartphones, or is it convenient to call on the tablet</a></li>
<li><a href="../234823/index.html">My experience of teaching children 8-10 years of programming on Scratch</a></li>
<li><a href="../234825/index.html">Nice to meet you. Custom</a></li>
<li><a href="../234827/index.html">Database Development with Code First</a></li>
<li><a href="../234831/index.html">What does ITshnik like to love some marketers or marketing guide for an IT startup?</a></li>
<li><a href="../234833/index.html">As I pointed out to the bank on the bugs or data leakage</a></li>
<li><a href="../234835/index.html">Asynchronous multithreaded pool of Perl workers</a></li>
<li><a href="../234837/index.html">Reflections on Personal Information Management</a></li>
<li><a href="../234839/index.html">The 2014 LVEE Conference was held. Results</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>